dSingleInteger`0`x`()->Join(IntegerNumberSystem,etc)``SINT`SingleInteger is intended to support machine integer arithmetic.
o/\`2`x`(_$,_$)->_$`dSingleInteger``\spad{n} \spad{/\} \spad{m} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
oAnd`2`x`(_$,_$)->_$`dSingleInteger``\spad{And(n,{}m)} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
oNot`1`x`(_$)->_$`dSingleInteger``\spad{Not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.
oOr`2`x`(_$,_$)->_$`dSingleInteger``\spad{Or(n,{}m)} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
o\/`2`x`(_$,_$)->_$`dSingleInteger``\spad{n} \spad{\/} \spad{m} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
omax`0`x`()->_$`dSingleInteger``\spad{max()} returns the largest single integer.
omin`0`x`()->_$`dSingleInteger``\spad{min()} returns the smallest single integer.
onot`1`x`(_$)->_$`dSingleInteger``\spad{not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.
oxor`2`x`(_$,_$)->_$`dSingleInteger``\spad{xor(n,{}m)} returns the bit-by-bit logical {\em xor} of the single integers \spad{n} and \spad{m}.
o~`1`x`(_$)->_$`dSingleInteger``\spad{~ n} returns the bit-by-bit logical {\em not } of the single integer \spad{n}.
acanonical`0`x``dSingleInteger``\spad{canonical} means that mathematical equality is implied by data structure equality.
acanonicalsClosed`0`x``dSingleInteger``\spad{canonicalClosed} means two positives multiply to give positive.
anoetherian`0`x``dSingleInteger``\spad{noetherian} all ideals are finitely generated (in fact principal).
cIntegerNumberSystem`0`x`()->Category``INS`An \spad{IntegerNumberSystem} is a model for the integers.
oaddmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{addmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a+b mod p}.
obase`0`x`()->_$`cIntegerNumberSystem``\spad{base()} returns the base for the operations of \spad{IntegerNumberSystem}.
obit?`2`x`(_$,_$)->Boolean`cIntegerNumberSystem``\spad{bit?(n,{}i)} returns \spad{true} if and only if \spad{i}-th bit of \spad{n} is a 1.
ocopy`1`x`(_$)->_$`cIntegerNumberSystem``\spad{copy(n)} gives a copy of \spad{n}.
odec`1`x`(_$)->_$`cIntegerNumberSystem``\spad{dec(x)} returns \spad{x - 1}.
oeven?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{even?(n)} returns \spad{true} if and only if \spad{n} is even.
ohash`1`x`(_$)->_$`cIntegerNumberSystem``\spad{hash(n)} returns the hash code of \spad{n}.
oinc`1`x`(_$)->_$`cIntegerNumberSystem``\spad{inc(x)} returns \spad{x + 1}.
oinvmod`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{invmod(a,{}b)},{} \spad{0<=a<b>1},{} \spad{(a,{}b)=1} means \spad{1/a mod b}.
olength`1`x`(_$)->_$`cIntegerNumberSystem``\spad{length(a)} length of \spad{a} in digits.
omask`1`x`(_$)->_$`cIntegerNumberSystem``\spad{mask(n)} returns \spad{2**n-1} (an \spad{n} bit mask).
omulmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{mulmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a*b mod p}.
oodd?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{odd?(n)} returns \spad{true} if and only if \spad{n} is odd.
opositiveRemainder`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{positiveRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{0 <= r < b} and \spad{r == a rem b}.
opowmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{powmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a**b mod p}.
orandom`1`x`(_$)->_$`cIntegerNumberSystem``\spad{random(a)} creates a random element from 0 to \spad{n-1}.
orandom`0`x`()->_$`cIntegerNumberSystem``\spad{random()} creates a random element.
orational`1`x`(_$)->Fraction(Integer)`cIntegerNumberSystem``\spad{rational(n)} creates a rational number (see \spadtype{Fraction Integer})..
orational?`1`x`(_$)->Boolean`cIntegerNumberSystem``\spad{rational?(n)} tests if \spad{n} is a rational number (see \spadtype{Fraction Integer}).
orationalIfCan`1`x`(_$)->Union(Fraction(Integer),"failed")`cIntegerNumberSystem``\spad{rationalIfCan(n)} creates a rational number,{} or returns "failed" if this is not possible.
oshift`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{shift(a,{}i)} shift \spad{a} by \spad{i} digits.
osubmod`3`x`(_$,_$,_$)->_$`cIntegerNumberSystem``\spad{submod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a-b mod p}.
osymmetricRemainder`2`x`(_$,_$)->_$`cIntegerNumberSystem``\spad{symmetricRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{ -b/2 <= r < b/2 }.
acanonicalUnitNormal`0`x``cIntegerNumberSystem``
amultiplicativeValuation`0`x``cIntegerNumberSystem``euclideanSize(a*b) returns \spad{euclideanSize(a)*euclideanSize(b)}.
xIntegerNumberSystem&`1`x`(IntegerNumberSystem)->etc`(S)`INS-`An \spad{IntegerNumberSystem} is a model for the integers.
obinomial`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
obit?`2`x`(S,S)->Boolean`xIntegerNumberSystem&(S)``
ocharacteristic`0`x`()->NonNegativeInteger`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->DoubleFloat`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Float`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->InputForm`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Integer`xIntegerNumberSystem&(S)``
oconvert`1`x`(S)->Pattern(Integer)`xIntegerNumberSystem&(S)``
ocopy`1`x`(S)->S`xIntegerNumberSystem&(S)``
odifferentiate`2`x`(S,NonNegativeInteger)->S`xIntegerNumberSystem&(S)``
odifferentiate`1`x`(S)->S`xIntegerNumberSystem&(S)``
oeuclideanSize`1`x`(S)->NonNegativeInteger`xIntegerNumberSystem&(S)``
oeven?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
ofactor`1`x`(S)->Factored(S)`xIntegerNumberSystem&(S)``
ofactorial`1`x`(S)->S`xIntegerNumberSystem&(S)``
oinit`0`x`()->S`xIntegerNumberSystem&(S)``
oinvmod`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
omask`1`x`(S)->S`xIntegerNumberSystem&(S)``
onextItem`1`x`(S)->Union(S,"failed")`xIntegerNumberSystem&(S)``
opatternMatch`3`x`(S,Pattern(Integer),PatternMatchResult(Integer,S))->PatternMatchResult(Integer,S)`xIntegerNumberSystem&(S)``
opermutation`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
opositive?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
opowmod`3`x`(S,S,S)->S`xIntegerNumberSystem&(S)``
oprime?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
orational`1`x`(S)->Fraction(Integer)`xIntegerNumberSystem&(S)``
orational?`1`x`(S)->Boolean`xIntegerNumberSystem&(S)``
orationalIfCan`1`x`(S)->Union(Fraction(Integer),"failed")`xIntegerNumberSystem&(S)``
oretract`1`x`(S)->Integer`xIntegerNumberSystem&(S)``
oretractIfCan`1`x`(S)->Union(Integer,"failed")`xIntegerNumberSystem&(S)``
osquareFree`1`x`(S)->Factored(S)`xIntegerNumberSystem&(S)``
osymmetricRemainder`2`x`(S,S)->S`xIntegerNumberSystem&(S)``
