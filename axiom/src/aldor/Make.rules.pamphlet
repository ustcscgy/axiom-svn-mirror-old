\documentclass{article}
\usepackage{../scripts/tex/axiom}
\begin{document}
\title{\$SPAD/src/aldor2 Makefile}
\author{Peter Broadbery}
\maketitle
\begin{abstract}
The aldor rules make file.  Or how to make make more confusing, vol. 2.
\end{abstract}

<<thewholething>>=
# This file is generated from src/aldor/Make.rules.pamphlet
# -*-Makefile-*-
# This file is made up of a number of sections, delimited by 'ifeq
# (...$(MODE),...)'  Each of these builds a set of files, see each for
# details.  'work' is set when a section has been read - if this isn't set
# then MODE is set incorrectly.

work :=
ifeq ($(strip $(MODE)),INIT)

# General variables:
#  ALL_DIRS: List of directories to be created
#  ALL_SOURCES: List of all source (non-generated) files
#		Rule is to add to this where you first mention a file
#  ALL_AOLIBS:  List of libraries to create
#  ALL_AOS:  AO Files generated from .as's
# ALL_INCLUDES: Files that have been included

ALL_DIRS    := 
ALL_SOURCES :=
ALL_AOLIBS  :=
ALL_SPADSETS :=
# System-set
ALL_AOS      :=
ALL_INCLUDES :=
ALL_SPADSET_APS :=

# Include stuff used everywhere
ALL_SOURCES += $(IN)/Make.rules.pamphlet
ALL_SOURCES += $(IN)/Make.functions.pamphlet
include $(IN)/Make.functions

# Include initialisation for these guys 
include $(IN)/Make.axiom
include $(IN)/Make.aldor

PAMPHLET_FILES += $(IN)/Make.functions $(IN)/Make.axiom $(IN)/Make.aldor

work := $(MODE)
endif

#
# Libaries
#

# libraries need these variables set:
# 	$(LIB)_AOLIB_COMPONENTS: List components of library
#	$(LIB)_LSPS: Generate lisp for these names

ifeq ($(strip $(MODE)),LIB)

ifeq ($(origin ALL_LIB_MBRS),undefined)
ALL_LIB_MBRS :=
ALL_AO_MKS   :=
ALL_AO_LSPS  :=
ALL_AO_TMPLIBS :=
endif

$(LIB)_ELTS := $(foreach comp,$($(LIB)_AOLIB_COMPONENTS),$(MEMBERS_$(comp)))
$(LIB)_AOS  := $(patsubst %,$(MID)/ao/%.ao,$($(LIB)_ELTS))
$(LIB)_MBRS := $(patsubst %,$(MID)/lib/lib$(LIB).al(%.ao), $($(LIB)_ELTS))
$(LIB)_AO_MKS := $(patsubst %,%.mk, $($(LIB)_AOS))
$(LIB)_COMP_MBR_MAP := $(foreach comp,$($(LIB)_AOLIB_COMPONENTS), \
					$(patsubst %,$(comp)-%,$(MEMBERS_$(comp))))

$(LIB)_INST_LSPS   := $(patsubst %,$(AXIOM)/aldor/lib/%.lsp,$($(LIB)_LSPS))
$(LIB)_INST_LSPS_O := $(patsubst %,$(AXIOM)/aldor/lib/%.o,$($(LIB)_LSPS))
$(LIB)_OBJ_LSPS := $(patsubst %,$(OUT)/lib/%.lsp,$($(LIB)_LSPS))
$(LIB)_GEN_LSPS  := $(patsubst %,$(MID)/lsp/%.lsp,$($(LIB)_LSPS))

ALL_LIB_MBRS     += $($(LIB)_MBRS)
ALL_AO_MKS       += $($(LIB)_AO_MKS)
ALL_AO_LSPS      += $($(LIB)_GEN_LSPS)
ALL_AO_INST_LSPS += $($(LIB)_INST_LSPS)

ALL_AO_TMPLIBS   += $(patsubst %, $(MID)/tmp/lib$(LIB)_%.lst, $($(LIB)_ELTS))

ALL_LISP_O_TARGETS += $($(LIB)_INST_LSPS_O)

# This checks for duplicates - barf if there are any
# This is a sanity check - it should never happen in working makefiles.
ifneq ($(words $($(LIB)_AOS)),$(words $(sort $($(LIB)_AOS))))
counts := $(foreach ao,$($(LIB)_AOS),$(ao)-$(words $(filter $(ao),$($(LIB)_AOS))))
$(error duplicate entries in $(LIB))
$(warning $(sort $(filter-out %-1,$(counts))))
endif

ALL_AOS += $($(LIB)_AOS)

$($(LIB)_AO_MKS): library:=$(LIB)

$($(LIB)_AOS): ao_library_name    := $(LIB)
$($(LIB)_AOS): ao_library_flags   :=	      
$($(LIB)_AOS): ao_library_bootlib := $($(LIB)_BOOTLIB)
$($(LIB)_AOS): $($(LIB)_BOOTLIB)

INCLS := $(foreach comp,$($(LIB)_AOLIB_COMPONENTS),$(ALL_COMP_INCLS_$(comp)))
WANTED   := $(words $(INCLS))
INCLUDED := $(words $(filter $(INCLS),$(ALL_INCLUDES)))

# Idea of this is that make will not find a rule to build the library until it
# has managed to include all the files mentioned in $(INCLS).  Without the
# 'if' make would build the library before all its prerequisites are defined.
# This would clearly be a bad thing.

$(warning W: $(WANTED) I: $(INCLUDED))
$(warning W: $(INCLS))

ifeq ($(strip $(WANTED)),$(strip $(INCLUDED)))

$($(LIB)_MBRS): $(MID)/lib/lib$(LIB).al(%): $(MID)/ao/%

all_lib$(LIB):  $($(LIB)_INST_LSPS_O) $(AXIOM)/algebra/lib$(LIB).al
	echo built $(AXIOM)/algebra/lib$(LIB).al

.PHONY: all_lib$(LIB)

$(AXIOM)/algebra/lib$(LIB).al: $($(LIB)_MBRS)
	@echo "BUILT: " $(notdir $@)
	cp -p $(MID)/lib/lib$(LIB).al $@

ALL_DIRS += $(AXIOM)/aldor/lib

$($(LIB)_INST_LSPS): $(AXIOM)/aldor/lib/%.lsp: $(MID)/lsp/%.lsp $(AXIOM)/aldor/lib/.dir
	cp $< $@

LIB :=
endif

work := $(MODE)
endif


# Library members
# DEPS is passed down via a rule

ifeq ($(strip $(MODE)),LIBAO)

find-comp = $(subst -$(1),,$(filter %-$(1),$($(LIB)_COMP_MBR_MAP)))
dep-closure = $(1) $(foreach dep,$(1),$(call dep-closure,$(Deps_$(dep))))

# The order of members is crucially important since aldor reads .al files
# once, and will give undefined ref. errors for forward definitions.

COMP   := $(call find-comp,$(AO_TGT))
DEPIDS := $(foreach comp,$(Deps_$(COMP)),$(COMP_TOPLVL_$(comp)))
DEPIDS += $(Deps_$(COMP)_$(AO_TGT))

DEPS   := $(patsubst %,$(MID)/ao/%.ao,$(DEPIDS))
DEPMBRS:= $(patsubst %,$(MID)/lib/lib$(LIB).al(%.ao),$(DEPIDS))

#$(warning deps for $(AO_TGT) $(DEPIDS))
#$(warning extdeps $(AO_TGT) \
#	$(call dep-closure,$(Deps_$(COMP))))

$(MID)/ao/$(AO_TGT).ao: $(Src_$(AO_TGT)) $(MID)/tmp/lib$(LIB)_$(AO_TGT).lst
$(MID)/ao/$(AO_TGT).ao: ao_library_flags := $($(COMP)_aldoropts)

$(MID)/lib/lib$(LIB).al($(AO_TGT).ao): $(DEPMBRS)

# Temporary library for the member:

libdeps := $(patsubst %,$(MID)/tmp/lib$(LIB)_%.lst,$(DEPIDS))
aodeps := $(patsubst %, $(MID)/ao/%.ao, $(DEPIDS))

$(MID)/tmp/lib$(LIB)_$(AO_TGT).lst: $(libdeps) $(aodeps)
$(MID)/tmp/lib$(LIB)_$(AO_TGT).lst: ao_library_name=$(LIB)

work := $(MODE)
endif

#NOT WORKING YET

#
# SpadSets - the .ap part of a library
#
ifeq ($(strip $(MODE)),SPADSETS)

$(warning ALL SPADSETS $(ALL_SPADSETS))
ALL_SPADSET_MKS := $(patsubst %,$(MID)/%/spadset.mk,$(ALL_SPADSETS))
ALL_SPADSET_CHKS := $(patsubst %,$(MID)/%/spadset_check.mk,$(ALL_SPADSETS))

$(ALL_SPADSET_CHKS): $(MID)/%/spadset_check.mk: $(MID)/%/.dir 
	@echo > $@
	@echo 'MODE := SPADSET_CHECK' >> $@
	@echo 'THIS_SPADSET  := $*' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

work := $(MODE)
endif

#
# Check that the includes have happened
#
ifeq ($(strip $(MODE)),SPADSET_CHECK)

WANTED   := $(words $(ALL_INCLS_$(THIS_SPADSET)))
INCLUDED := $(words $(filter $(ALL_INCLS_$(THIS_SPADSET)),$(ALL_INCLUDES)))

$(warning ($(strip $(WANTED)),$(strip $(INCLUDED))))

ifeq ($(strip $(WANTED)),$(strip $(INCLUDED)))

include $(MID)/$(THIS_SPADSET)/spadset.mk
ALL_INCLUDES += $(MID)/$(THIS_SPADSET)/spadset.mk

ALL_INCL_SPADSETS += $(THIS_SPADSET)

SPADSET_APS_$(THIS_SPADSET) := $(patsubst %,$(MID)/ap/%.ap, $(SPADSET_$(THIS_SPADSET)))
ALL_SPADSET_APS += $(SPADSET_APS_$(THIS_SPADSET))

$(SPADSET_APS_$(THIS_SPADSET)): C := $(THIS_SPADSET)

SPADSET_MKS := $(patsubst %,$(MID)/make/spad_%.mk,$(SPADSET_$(THIS_SPADSET)))

#include $(SPADSET_MKS)
MODE := SPADSET_CHECK
$(SPADSET_MKS): $(MID)/make/spad_%.mk: 
	@echo "MODE := SPAD_ELT" > $@
	@echo "SPAD_ELT := $*" >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

endif

work := $(MODE)
endif

# A Spad Set is a group of .ap files that are generated together
#
# Related input variables:
#    ALL_SPADSETS: List of all known sets
#    SPADSET_INCL_<id>: List of files to include before reading the makefile set 
#    SPADSET_DEFFILE: Name of .mk defining the spadset 
#
# Mode variables
#    spadset_id: <id> for this spadset
#
# Related files:
#    $(MID)/<id>/spadset.mk: Makefile for spadset
#

# A component is a group of .ao files making up a library.
#
# Related input variables:
#     	ALL_COMPONENTS: List of all known components
#       <id>_spadset:	Spadset defining this component
#	MEMBERS_<id>:   Identifiers for this component
#		nb: only one of spadset & members should be specified
#
# Defines:
#     ALL_COMP_INCLS_<id>: List of files to include before using variables
# 			   from this component
# Targets:
#	$(MID)/$(spadset)/spadmbr.mk: Makefile defining each component's .ap file
#
# Locals:
#	spadset: The spadset defining this component

ifeq ($(strip $(MODE)),COMPONENT)

ifneq ($(origin $(COMPONENT)_spadset),undefined)

spadset := $($(COMPONENT)_spadset)

MEMBERS_$(COMPONENT) := $(filter-out $(COMP_BLACKLIST_$(COMPONENT)), $(SPADSET_$(spadset)))

SPADMKS := $(patsubst %,$(MID)/$(spadset)/spadmbr_%.mk,$(SPADSET_$(spadset)))

ALL_COMP_INCLS_$(COMPONENT) := $(ALL_INCLS_$(spadset))

-include $(SPADMKS)
MODE := COMPONENT

$(SPADMKS): C := $(COMPONENT)
$(SPADMKS): S := $(spadset)

$(SPADMKS): $(MID)/$(spadset)/spadmbr_%.mk: 
	@echo > $@
	@echo 'MODE    := COMP_SPAD_MBR' >> $@
	@echo 'MBR     := $*' >> $@
	@echo 'SPADSET := $(S)' >> $@
	@echo 'COMP    := $(C)' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@
endif


# This finds the members of the component which are not dependencies of some
# other member - the idea is that we can use the top lvl instead of a list of
# all members.

toplvl = $(filter-out $(foreach mbr, $(MEMBERS_$(COMPONENT)), \
				$(Deps_$(COMPONENT)_$(mbr))), \
		      $(MEMBERS_$(COMPONENT)))

COMP_TOPLVL_$(COMPONENT) := $(call toplvl, $(COMPONENT))

work := $(MODE)
endif

#
# COMP_SPAD_MBR: .ao file generated from .ap spad file
#

ifeq ($(strip $(MODE)),COMP_SPAD_MBR)

Src_$(MBR) := $(MID)/ap/$(MBR).ap
work := $(MODE)

# Scary looking expand macro - written this way to allow for tail recursion
# elimination - as if make could do that.  Anyway it takes two lists, stuff to
# do & stuff found.  If the 1st is empty, we're done.  If the first element of
# the first list is in the second list, drop the element and move to the next
# element of the 1st list.  Otherwise, add the first element to the second
# list, and replace the 1st element with its dependencies.
#
#expand =  $(if $(strip $(1)), \
#		$(if $(filter $(firstword $(1)), $(2)),					\
#	   	     $(call expand, $(wordlist 2,$(words $(1)),$(1)),$(2)),		\
#	   	     $(call expand, $(sort $(SPADSET_DEPS_$(SPADSET)_$(firstword $(1))) \
#			                   $(wordlist 2,$(words $(1)),$(1))),		\
#	   		       $(sort $(firstword $(1)) $(2)))),$(2))
#
#$(warning deps: $(MBR): $(Deps_$(COMP)_$(MBR)))

Deps_$(COMP)_$(MBR) := $(SPADSET_DEPS_$(SPADSET)_$(MBR))

endif

ifeq ($(strip $(MODE)),DEP)

$(MID)/dep_$(THIS_DEP).stamp: DEP  := $(THIS_DEP)
$(MID)/dep_$(THIS_DEP).stamp: FILE := $(MID)/tmp/mkdeps_$(THIS_DEP).lsp
$(MID)/dep_$(THIS_DEP).stamp: $(DEP_FILES_$(THIS_DEP))

work := $(MODE)
endif

#
# Building lsp from .o - just need to declare the source
#
ifeq ($(strip $(MODE)),LSP_O)
$(AXIOM)/aldor/lib/$(TGT).o: $(AXIOM)/aldor/lib/$(TGT).lsp
work := $(MODE)
endif

# FINAL: This does all the housework at the end, and most of the necessary
# including of files.
#
ifeq ($(strip $(MODE)),FINAL)

#
# SpadSet makefiles;
#
#
# See MODE = SPADSETS...

include $(MID)/all_spadsets.mk

$(MID)/all_spadsets.mk: $(MID)/.dir
	@echo "SPADSET MK: $(shell basename $@)"
	@echo > $@
	@echo 'MODE := SPADSETS' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

include $(ALL_SPADSET_CHKS)

#
# Component makefiles
#
ALL_DIRS += $(MID)/make

COMPONENT_MKS := $(patsubst %,$(MID)/make/comp_%.mk,$(ALL_COMPONENTS))

-include $(COMPONENT_MKS)
$(COMPONENT_MKS): $(MID)/make/comp_%.mk: $(MID)/make/.dir $(IN)/Make.rules
	@echo 'MODE := COMPONENT' > $@
	@echo 'COMPONENT := $*' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

#
# Library management
#
ALL_DIRS += $(MID)/lib $(MID)/make

ALL_LIB_MKS  := $(patsubst %,$(MID)/make/lib_%.mk, $(ALL_AOLIBS))

-include $(ALL_LIB_MKS)

$(ALL_LIB_MBRS): $(MID)/lib/%: $(MID)/lib/.dir
	@echo LIB $(notdir $@) $(%F) D: $(words $^) files
	@test -f $(filter %/$(%F), $^)
	@ar r $@ $(filter %/$(%F), $^)

$(ALL_LIB_MKS): $(MID)/make/lib_%.mk: $(MID)/make/.dir
	@echo 'MODE := LIB' > $@
	@echo 'LIB := $*' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

-include $(ALL_AO_MKS)

$(ALL_AO_MKS): $(MID)/ao/%.ao.mk: $(MID)/ao/.dir 
	@echo 'MODE := LIBAO' > $@
	@echo 'AO_TGT := $*' >> $@
	@echo 'LIB  := $(library)' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@

#
# Building .o files from .lsp
#

mks := $(patsubst $(AXIOM)/aldor/lib/%.lsp,$(OBJ)/%.o.mk, $(ALL_AO_INST_LSPS))
-include $(mks)

$(mks): $(OBJ)/%.o.mk:
	@echo 'MODE := LSP_O' > $@
	@echo 'TGT := $*' >> $@
	@echo 'include $$(IN)/Make.rules' >> $@


# Compiling aldor
ALL_SOURCES += $(IN)/Make.aldor.pamphlet $(IN)/Make.axiom.pamphlet
MODE := FINAL
include $(IN)/Make.axiom
MODE := FINAL
include $(IN)/Make.aldor

# Directories
ALL_DIRS += $(MID) $(OBJ)
DIR_TARGETS := $(sort $(patsubst %,%/.dir,$(ALL_DIRS)))
$(DIR_TARGETS): %/.dir: 
	mkdir -p $*
	touch -t 199901010000 $*/.dir

work := $(MODE)
endif

# Quick check that we actually did something...
ifeq ($(strip $(work)),)
$(error Unknown mode '$(MODE)', please make me do something!)
endif

MODE :=

@

<<*>>=
<<thewholething>>
@

\end{document}
