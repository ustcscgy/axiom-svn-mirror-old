\documentclass{article}
\usepackage{../scripts/tex/axiom}
\begin{document}
\title{\$SPAD/src/aldor2 Makefile}
\author{Peter Broadbery}
\maketitle
\begin{abstract}
The aldor aldor-related rules make file.  Or how to make make more confusing, vol. 4.
\end{abstract}

The basic unit used to compile the axiom library is a spadset - a set of
related axiom types; we define 2 sets here:
\begin{enumerate}
\item [[sax0]] Axiom domains and categories that [axextend.as] depends on.
\item [[saxiom]] Other axiom domains and categories
\end{enumerate}

The setup is such that more could be defined if required.  Simply add more
rules for breaking up the complete set of types.

An axiom call is used to generate the dependencies for any piece of axiom and
aldor code.  These are written to the [[int/aldor/gendeps]] directory.  See
[[genax.lsp]] for details of this.

[[Sort.java]] is used to sort these dependencies, creating the two units
above.

Within sax0 there is a large strongly interdependent set of files that need to
be compiled together (about 90% of the types).  In order to simplify things,
we have to manually break this set into subparts.

To do this, we use aldor's extend keyword to first define the essential part
of a domain, and later embellish it with all the operations. 

For example, [[DoubleFloat]] is first defined as\footnote{Note we're only
interested in declarations - the actual type definition is in a .spad file}.

\begin{verbatim}
DoubleFloat: SetCategory
\end{verbatim}

We later extend this with something like:

\begin{verbatim}
extend DoubleFloat: Field with { ... }
\end{verbatim}

The "essential" part of a type is the exports required by
categories in the strongly dependent set.  This step is manual - one has to
decide which domains need this, and which can go through without an extend.

Once this splitting is done, it turns out there is a single large set
containing 27 domains ([[INT]], [[SGROUP]], [[ALGEBRA]] and related), one
containing 2 elements ([[FIELD]], [[DIVRING]]) and all the others can be
compiled independently.

<<typerules>>=

INTERPSYS := $(OBJ)/$(SYS)/bin/interpsys
DAASE     := $(INT)

ALL_SPAD_FILES := $(wildcard $(INT)/algebra/*.spad)
ALL_SPAD_TYPES := $(patsubst $(INT)/algebra/%.spad,%,$(ALL_SPAD_FILES))

INIT_DEFS    := $(IN)/baselist.lsp
CLQ_TOPLEVEL := axlit.as axextend.as

PAMPHLET_FILES += $(IN)/genax.lsp
PAMPHLET_FILES += $(IN)/baselist.lsp
PAMPHLET_FILES += $(IN)/extra_deps.lst
PAMPHLET_FILES += $(IN)/list_spadset.mk

PAMPHLET_FILES += $(IN)/as/axlit.as
PAMPHLET_FILES += $(IN)/as/axextend.as

PAMPHLET_FILES += $(IN)/gen-axiom-types.sh

ifeq ($(fns_included),1)

$(MID)/typelist: $(ALL_SPAD_FILES) $(MID)/.dir $(IN)/gen-axiom-types.sh
	@sh $(IN)/gen-axiom-types.sh all $(MID) > $@.gen
	@$(call move-if-changed,$@.gen,$@)

$(MID)/catlist: $(ALL_SPAD_FILES) $(MID)/.dir  $(IN)/gen-axiom-types.sh
	@sh $(IN)/gen-axiom-types.sh categories $(MID) > $@.gen
	@$(call move-if-changed,$@.gen,$@)

$(MID)/typemap: $(ALL_SPAD_FILES) $(MID)/.dir  $(IN)/gen-axiom-types.sh
	@sh $(IN)/gen-axiom-types.sh typemap $(MID) > $@.gen
	@$(call move-if-changed,$@.gen,$@)

$(MID)/all_spad_types.mk: $(MID)/typelist
	@echo "ALL_SPAD_TYPES := $(shell cat $(MID)/typelist | sort)" > $@.gen
	@$(call move-if-changed,$@.gen,$@)

$(MID)/all_spad_cats.mk: $(MID)/catlist
	@echo "ALL_SPAD_CATS := $(shell cat $(MID)/catlist| sort)" > $@.gen
	@$(call move-if-changed,$@.gen,$@)

endif

include $(MID)/all_spad_types.mk
include $(MID)/all_spad_cats.mk

ALL_SPAD_AP_FILES := $(patsubst %,$(MID)/ap/%.ap,$(ALL_SPAD_TYPES))


#
#  Generate dependencies for top of libax0 clique
#

ALL_DEP_LISTS += ax0
DEP_TYPES_ax0 := $(patsubst %.as,"$(MID)/ap/%.ap",$(CLQ_TOPLEVEL))
DEP_FILES_ax0 := $(patsubst %.as,$(MID)/ap/%.ap,$(CLQ_TOPLEVEL))
DEP_BASENAMES_ax0 := $(patsubst %.as,%,$(CLQ_TOPLEVEL))
DEP_DEPLST_ax0 := $(patsubst %.as,$(DEP_DIR)/%.dep,$(CLQ_TOPLEVEL))
DEP_FUNCTION_ax0 := generate-deps-from-ap-files

#
# .ap -> .dep
#

ALL_DEP_LISTS += spad
DEP_TYPES_spad := $(ALL_SPAD_TYPES)
DEP_FILES_spad := $(ALL_SPAD_FILES)
DEP_BASENAMES_spad := $(ALL_SPAD_TYPES)
DEP_FUNCTION_spad := generate-deps


#
# init list -> { initdomains, deps, base init }
#

ALL_DIRS += $(MID)/init_ap

INIT_DOMS      := $(MID)/initdomains
INIT_DOM_STAMP := $(MID)/initdomains.stamp

ifeq ($(fns_included),1)

$(INIT_DOM_STAMP): $(MID)/.dir $(MID)/deps/.dir $(MID)/gendeps/.dir $(MID)/init_ap/.dir \
		   $(IN)/baselist.lsp $(IN)/genax.lsp 
	echo > $(MID)/mkinit.lsp
	echo ")set bre fast" >> $(MID)/mkinit.lsp
	echo ")lisp (break)" >> $(MID)/mkinit.lsp
	echo '(load "$(IN)/genax.lsp")' >> $(MID)/mkinit.lsp
	echo '(generate-init-files "$(INIT_DEFS)" "$(INIT_DOMS).tmp")' >> $(MID)/mkinit.lsp
	-(cd $(MID); DAASE="$(DAASE)"; export DAASE; $(INTERPSYS)) \
				< $(MID)/mkinit.lsp > $(MID)/tmp/mkinit.log
	test -f $(INIT_DOMS).tmp
	@$(call move-if-changed,$(INIT_DOMS).tmp,$(INIT_DOMS))
	@(for i in $$(cat $(INIT_DOMS)); \
	  do \
		cat $(MID)/gendeps/$$i.dep | sort | uniq > $(MID)/gendeps/$$i.tmp;	\
		mv $(MID)/gendeps/$$i.tmp $(MID)/gendeps/$$i.dep ;			\
		$(call move-if-changed,$(MID)/gendeps/$$i.dep,$(MID)/deps/$$i.dep); \
	  done)
	touch $@

endif

#
# .spad -> .ap
#
#ALL_DIRS += $(MID)/ap/tmp

#$(ALL_SPAD_AP_FILES): $(MID)/ap/%.ap: $(INT)/algebra/%.spad \
#		      $(IN)/genax.lsp $(MID)/ap/.dir $(MID)/ap/tmp/.dir
#	@echo generating $*.ap $(C)
#	false
#	@echo > $(MID)/mkax_$*.lsp
#	@echo ")set bre fast" >> $(MID)/tmp/mkax_$*.lsp
#	@echo ")lisp (break)" >> $(MID)/tmp/mkax_$*.lsp
#	@echo '(load "$(IN)/genax.lsp")' >> $(MID)/tmp/mkax_$*.lsp
#
#	@echo "(setq comp-name '$* )" >> $(MID)/tmp/mkax_$*.lsp
#	@echo "(setq components '($* $*) )" >> $(MID)/tmp/mkax_$*.lsp
#
#	@echo "(generate-ax-file comp-name components nil)" >> $(MID)/tmp/mkax_$*.lsp
#	@(cd $(MID); DAASE="$(DAASE)"; export DAASE; $(INTERPSYS)) < $(MID)/tmp/mkax_$*.lsp
#	@rm -f $(MID)/tmp/mkax_$*.lsp
#	@test -f $@

ALL_DIRS += $(MID)/deps $(MID)/tmp $(MID)/gendeps

#
# Base clique (I think)
#
ALL_DIRS += $(MID)/sax0
ALL_SPADSETS += sax0
ALL_INCLS_sax0 := $(AX0_AP_MKS)

$(MID)/sax0/spadset.mk: \
	$(MID)/Sort.class $(MID)/typelist $(MID)/sax0/.dir \
	$(INIT_DOM_STAMP)  $(MID)/dep_ax0.stamp $(MID)/dep_spad.stamp \
	$(IN)/extra_deps.lst
	(cd $(MID); \
	 java -cp `pwd` Sort base $(MID)/deps/axextend.dep $(MID)/typelist $(MID)/initdomains \
				  $(IN)/extra_deps.lst)


$(MID)/sax0/spadset.lst: $(MID)/sax0/spadset.mk $(IN)/list_spadset.mk
	make -f $(IN)/list_spadset.mk MID=$(MID) spadset=sax0 dest=$@

#
# Everything else
#

ALL_DIRS += $(MID)/saxiom
ALL_SPADSETS += saxiom
ALL_INCLS_saxiom := $(AX0_AP_MKS) $(MID)/sax0/spadset.mk

$(warning $(MID)/saxiom/spadset.mk $(ALL_SPADSET_APS))
$(MID)/saxiom/spadset.mk: \
	$(MID)/Sort.class $(MID)/typelist $(MID)/sax0/.dir \
	$(ALL_SPADSET_APS)				\
	$(MID)/dep_spad.stamp				\
	$(MID)/sax0/spadset.lst
	(cd $(MID); \
	 java -cp `pwd` Sort connected saxiom $(filter-out $(shell cat $(MID)/sax0/spadset.lst), $(ALL_SPAD_TYPES)))

#
# Sort.java -> Sort.class
#
PAMPHLET_FILES += $(IN)/Sort.java
ALL_SOURCES += $(IN)/Sort.java.pamphlet

$(MID)/Sort.class: $(IN)/Sort.java $(MID)/.dir
	(javac -d $(MID) $(IN)/Sort.java)
@

<<*>>=
<<typerules>>
@

\end{document}
