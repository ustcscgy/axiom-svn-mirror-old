\documentclass{article}
\usepackage{../../../../src/scripts/tex/axiom}
\begin{document}
\title{\$SPAD/lsp/ccl/src/util/ diff.c}
\author{Arthur Norman}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=
/* > c.diff - Paul's new thorts on longest common subsequences */

/*
Let the 2 sequences be a[1]...a[N]
                       b[1]...b[M]

Define Places[i] to be the set of items in seq. A that are equal to item
b[i]. This can be calculated in O(N+M), via a hash table.

Define CSS[j], the set of common subsequences starting at item b[j]. 

For each sequence k in CSS(j), let a[l] be the item corresponding to item
b[j]. Then sequence k has a corresponding sequence in CSS(j-1) iff a[l-1] in
Places(b[j-1]), (which is one longer, of course).

Hence we can consider all sequences by setting CSS(M)=Place(b[M]) and working
back through the file, increasing the length of all sequences in CSS(M) that
are still going (ie.the line above them is in the new Places() set), deleting
all sequences for which this is not true, and adding all the rest of Places()
as sequences of length 1.

As we delete them, we maintain knowledge of the longest.

So for each line i we do at most |Places(i)| + |Places(i+1)| operations,
hence total number of operations is of the order of

     M
     _
     >  | Places(i) | 
     -
     1

Aho, Hopcroft, Ullman define this as 'p' and claim it is typically order n.
(worst case n^2, of course). I would claim that it's usually (n/K)^2, K some
fairly large number ~10-20, since there are usually (for source files anyway)
blank lines liberally scattered through the file.

In any case, the algorithm (used in the Unix 'diff' utility) they present is
p log n in time, and the one I have described is order p !

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
             
#define LINECHUNKSIZE 100
#define MAXLEN 255
#define HASHSIZ 97 /* keep it prime */

char *file1,*file2;

struct section { struct { int top,len;} one,two;};
struct item { int line; struct item *next; } ;
struct sequence { int line,len; struct sequence *next; } *freelist=0;
struct bucket { char *text; struct item *list; struct bucket *next;}
              **linea,**lineb,*hashtable[HASHSIZ];

int reada(FILE *),readb(FILE *);
struct bucket *readline(FILE *);
char *alloc(int);
int hash(char *);
int difference(struct section);
struct section lcs(struct section );
void merge(struct sequence *,int,struct item *,struct section *,struct section *);

main(argc,argv)
int argc;
char **argv;
{
int i;
FILE *stream1,*stream2;
struct section whole;

if (argc!=3) 
   {
   printf("Diff - differences between two files - (1.00, 22nd July 1987)\n\nUse: 'diff file1 file2'\n");
   exit(-1);
   }

file1=argv[1];
file2=argv[2];

stream1=fopen(file1,"r");
if (stream1==NULL) 
   {
   printf("Diff: couldn't open %s\n",file1);
   exit(-1);
   }

stream2=fopen(file2,"r");
if (stream2==NULL) 
   {
   fclose(stream1);
   printf("Diff: couldn't open %s\n",file2);
   exit(-1);
   }

for(i=0;i<HASHSIZ;++i) hashtable[i]=NULL;
whole.one.top=1;
whole.two.top=1;
whole.one.len=reada(stream1);
whole.two.len=readb(stream2);

if (difference(whole)==0) puts("Identical");

}

reada(stream)
FILE *stream;
{
struct item *atom;
int line=1;
int maxline=LINECHUNKSIZE;
linea=(struct bucket **)alloc((maxline+1)*sizeof(struct bucket *));
while ((linea[line]=readline(stream))!=NULL)
    {
    atom=(struct item *)alloc(sizeof(struct item));
    atom->next=linea[line]->list;
    linea[line]->list=atom;
    atom->line=line;
    if (line==maxline)
       {
       maxline+=LINECHUNKSIZE;
       linea=(struct bucket **)realloc(linea,(maxline+1)*sizeof(struct bucket *));
       }
    ++line;
    }
return line-1;
}

readb(stream)
FILE *stream;
{
int line;
int maxline=LINECHUNKSIZE;
lineb=(struct bucket **)alloc((maxline+1)*sizeof(struct bucket *));
for (line=1;(lineb[line]=readline(stream))!=NULL;++line)
    if (line==maxline)
       {
       maxline+=LINECHUNKSIZE;
       lineb=(struct bucket **)realloc(lineb,(maxline+1)*sizeof(struct bucket *));
       }
return line-1;
}

struct bucket *readline(stream)
FILE *stream;
{
char line[MAXLEN];
int h;
struct bucket *chain;

if (fgets(line,MAXLEN,stream)==NULL) return NULL;

h=hash(line);

chain=hashtable[h];
while (chain) 
      {
      if (strcmp(chain->text,line)==0)
         return chain;
      else chain=chain->next;
      }
chain=(struct bucket *)alloc(sizeof(struct bucket));
chain->next=hashtable[h];
hashtable[h]=chain;
chain->text=alloc(strlen(line)+1);
strcpy(chain->text,line);
chain->list=NULL;
return chain;
}

hash(str)
char *str;
{
unsigned int h=0;
while(*str) h=h+h+*str++;
return h%HASHSIZ;
}

difference(chunk)
struct section chunk;
{
struct section before,common,after;
int changed;

if ((chunk.one.len==0)&&(chunk.two.len==0))
    return 0;

if (chunk.one.len==0)
   {
   if (chunk.one.top!=1) 
       {
       printf("after %s line %4d: %s",
              file1,chunk.one.top-1,linea[chunk.one.top-1]->text);
       }
    else 
       {
       printf("at start of %s\n",file1);
       } 
    for (;chunk.two.len>0;++chunk.two.top,--chunk.two.len)
        {
        printf("add %s line %4d: %s",
        file2,chunk.two.top,lineb[chunk.two.top]->text);
        }
/*
   printf("add after file %s line %d, file %s line %d to %d\n",
          file1,chunk.one.top,file2,chunk.two.top,chunk.two.top+chunk.two.len);
*/
   return 1;
   }

if (chunk.two.len==0)
   {
   for (;chunk.one.len>0;++chunk.one.top,--chunk.one.len)
       {
       printf("remove %s line %4d: %s",
       file1,chunk.one.top,linea[chunk.one.top]->text);
       }

/*
   printf("remove line %d to %d from file %s\n",
          chunk.one.top,chunk.one.top+chunk.one.len,file1);
*/
   return 1;
   }

common=lcs(chunk);

if (common.one.len==0)
   {
   printf("change %s, line %d to %d\n",
           file1,chunk.one.top,chunk.one.top+chunk.one.len-1);
   for (;chunk.one.len>0;++chunk.one.top,--chunk.one.len)
       {
       printf("  line %4d: %s",
       chunk.one.top,linea[chunk.one.top]->text);
       }
   printf("to %s, line %d to %d\n",
           file2,chunk.two.top,chunk.two.top+chunk.two.len-1);   
   for (;chunk.two.len>0;++chunk.two.top,--chunk.two.len)
       {
       printf("  line %4d: %s",
       chunk.two.top,lineb[chunk.two.top]->text);
       }
/*
   printf("change file %s, line %d to %d to file %s, line %d to %d\n",
          file1,chunk.one.top,chunk.one.top+chunk.one.len,
          file2,chunk.two.top,chunk.two.top+chunk.two.len);
*/
   return 1;
   }

before.one.top=chunk.one.top;
before.one.len=common.one.top-chunk.one.top;
before.two.top=chunk.two.top;
before.two.len=common.two.top-chunk.two.top;;

after.one.top=common.one.top+common.one.len;
after.one.len=chunk.one.len-(after.one.top-chunk.one.top);
after.two.top=common.two.top+common.two.len;
after.two.len=chunk.two.len-(after.two.top-chunk.two.top);

changed=difference(before);
changed|=difference(after);
return changed;
}

struct section lcs(chunk)    
struct section chunk;
{
int i;
struct sequence hd;
struct section common;
hd.next=0;
common.one.len=common.two.len=0;

for (i=chunk.two.top+chunk.two.len-1;i>=chunk.two.top;--i)
    {
    merge(&hd,i,lineb[i]->list,&chunk,&common);
    }
merge(&hd,chunk.two.top-1,NULL,&chunk,&common); /* end all sequences */
return common;
}

void merge(hd,i,p,chunk,common)
struct section *chunk,*common;
struct sequence *hd;
struct item *p;
int i;
{
struct sequence *ls,*th,*atom;

ls=hd;
th=hd->next;
/*printf("p %.8x th %.8x\n",p,th);*/
while ( p || th )
      {         
      if     ((p==0) || ((th!=0)&&(th->line>p->line+1)))
              {     
              /* an existing sequence can't be continued
                 the line above it isn't an occurence of the
                 current line - remove it, checking to see whether
                 it's longer than the current best.
              */
              ls->next=th->next;
              if (th->len>common->one.len)
                 {
                 common->two.len=common->one.len=th->len;
                 common->two.top=i+1;
                 common->one.top=th->line;
                 }
/*
              printf("removing sequence top %d, len %d\n",th->line,th->len);
*/
              th->next=freelist;
              freelist=th;
              th=ls->next;
              }
      else if (p->line<chunk->one.top)
               p=0;
      else if (p->line>=chunk->one.top+chunk->one.len)
              /* the occurence of the current line is below
                 the section we're considering - skip it
              */
              p=p->next;
      else if ((th==0)||(th->line<p->line+1))
              {                         
              /* an occurence of the current line is not part of
                 an existing sequence - add to the list of sequences
              */
              if (freelist)
                 {
                 atom=freelist;
                 freelist=freelist->next;
                 }
              else atom=(struct sequence *)alloc(sizeof(struct sequence));
              ls->next=atom;
              atom->next=th;
              atom->line=p->line;
              atom->len=1;
              ls=atom;
/*
              printf("adding sequence top %d\n",p->line);
*/
              p=p->next;
              }
      else /* sequence already on list, so move it's start up, and 
              increment it's length */
              {
              --th->line;
              ++th->len;
              ls=th;
/*
              printf("lengthening sequence top %d, len %d\n",th->line,th->len);
*/
              th=th->next;
              p=p->next;              
              }
      }
/*
printf("common file1: top %d len %d, file2: top %d len %d\n",
        common->one.top,common->one.len,common->two.top,common->two.len);
*/
}


char *alloc(size)
int size;
{
char *t=malloc(size);
if (t==0)
   {
   printf("no room");
   exit(-1);
   }
return t;
}
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
