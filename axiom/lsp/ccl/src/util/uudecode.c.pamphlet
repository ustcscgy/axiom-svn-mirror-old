\documentclass{article}
\usepackage{../../../../src/scripts/tex/axiom}
\begin{document}
\title{\$SPAD/lsp/ccl/src/util/ uudecode.c}
\author{Arthur Norman}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

/* uudecode.c */

/*
 * This version of "uudecode" is provided so that I have one that
 * will run on non-Unix machines.  The #ifdef statements here are
 * intended to suggest machines that I would expect to be able to
 * cope with.
 */

#ifdef DOS16RM                      /* Intel 80286 family (16 bit mode)     */
                                    /* For use with Zortech Mode Z extender */
#  define MS_DOS                1
#  define ZORTECH_C             1
#endif

#ifdef DOS386                       /* Zortech 32-bit mode 386 */
#  define MS_DOS                1
#  define ZORTECH_C             1
#endif

#ifdef DOS86                       /* Zortech virtual mode */
#  define MS_DOS                1
#  define ZORTECH_C             1
#endif

#ifdef ATARI                       /* Lattice C for all STs */
#  define LATTICE_C             1
#endif

#ifdef THINK_C     /* Development on a Mac LC with 4 Mbytes, System 7 and Think C 5.0 */
#include <memory.h>
#define malloc(n) NewPtr(n)
#define free(p)   DisposPtr((Ptr)(p))
#endif

#ifdef arm                          /* Old RISCIX compiler... */
#  define __arm                 1
#endif

#ifdef __arm
#endif  /* __arm */

#ifdef __mips
#  ifndef __mips__
#     define __mips__
#  endif
#endif

#ifdef __mips__
#  define NO_BINARY_FOPEN    1
#  define UNIX               1
#endif

#ifdef vax
#  ifdef vms
      /* this allows me to compile under VAX/VMS directly */
#     define __vmsvax__
#  endif
#endif

#ifdef __vax__
#  define NO_BINARY_FOPEN       1
#  define UNIX                  1
#endif

#ifdef __vmsvax__
#endif

#ifdef _rs6000
#  define UNIX                  1
#endif

#ifdef __clipper
#  define UNIX                  1
#endif

#ifdef __hp9000s300
#  define UNIX                  1
#endif

#ifdef __hp9000s800
#  define UNIX                  1
#endif

#ifdef __APOLLO__
#  define UNIX                  1
#endif

#ifdef __ibm370
#endif

#ifdef __m88k__
#  define UNIX                  1
#endif

#ifdef __sparc__
#  ifdef sun              /* For Sparcstation with sub-standard C library */
                          /* You may need to adjust this for your sun     */
/*
 * These symbols should have been defined by standard #include files
 */
#     define CLOCKS_PER_SEC 1000000
#     define EXIT_SUCCESS 0
#     define EXIT_FAILURE 1
      typedef char *VoidStar;
#  endif
#  define UNIX                  1
#endif

#ifdef __sparc
#  define UNIX                  1
#  define NO_BINARY_FOPEN       1   /* probably not needed */
#endif

#ifdef __kcm                    /* The ICL "Knowledge Crunching Machine */
#endif

#include <stdio.h>      /* almost everybody needs this               */
#include <time.h>       /* so I can declare base_time etc as clock_t */

#ifndef CLOCKS_PER_SEC
#  ifndef CLK_TCK
      #error "please predefine CLOCKS_PER_SEC for this machine"
#     define CLK_TCK 1000000    /* Utterly spurious value - I know no better */
#  endif
#  define CLOCKS_PER_SEC (CLK_TCK)
#endif

typedef long int            int32;
typedef unsigned long int   unsigned32;
typedef int                 bool;
#define TRUE                1
#define FALSE               0

#ifdef NO_BINARY_FOPEN
#  define RB_MODE           "r"
#  define WB_MODE           "w"
#endif

#ifndef RB_MODE
#  define RB_MODE           "rb"
#  define WB_MODE           "wb"
#endif

#include <stdlib.h>

int main(int argc, char *argv[])
{
    char *src;
    FILE *f1, *f2;
    char line[96];
    int c, linep, access;
    switch (argc)
    {
case 2:
        src = argv[1];
        break;
default:
        fprintf(stderr, "Usage:  uudecode <src>\n");
        exit(EXIT_SUCCESS);
    }
    f1 = fopen(src, "r");
    if (f1 == NULL)
    {   fprintf(stderr, "Unable to access \"%s\"\n", src);
        exit(EXIT_FAILURE);
    }
    fprintf(stderr, "Will decode the file \"%s\"\n", src);
    for (;;)
    {   char line1[96];
        linep = 0;
        while ((c = getc(f1)) != '\n')
        {   if (c == EOF)
            {   fprintf(stderr, "No \"begin\" line found\n");
                exit(EXIT_FAILURE);
            }
            if (linep < 80) line1[linep++] = c;
        }
        line1[linep] = 0;
        if (sscanf(line1, "begin %o %s\n", &access, line) == 2) break;
    }
    fprintf(stderr, "Create file \"%s\" (was mode %3.3o)\n", line, access);
    
    f2 = fopen(line, WB_MODE);
    if (f2 == NULL)
    {   fprintf(stderr, "Unable to access \"%s\"\n", line);
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    for (;;)
    {   int i, len, eolfound;
        linep = 0;
        len = getc(f1);
        if (len == EOF) goto format_error;
        if (len == '\n') eolfound = len = ' ';
        else eolfound = 0;
        len = (len - ' ') & 0x3f;     /* Length of next input line */
        if (len == 0) break;

        for (i=len; i>0; i-=3)
        {   int c1, c2, c3, c4, b1, b2, b3;
            if (eolfound) c1 = c2 = c3 = c4 = ' ';
            else
            {   c1 = getc(f1);
                if (c1 == '\n') eolfound = c1 = c2 = c3 = c4 = ' ';
                else
                {   c2 = getc(f1);
                    if (c2 == '\n') eolfound = c2 = c3 = c4 = ' ';
                    else
                    {   c3 = getc(f1);
                        if (c3 == '\n') eolfound = c3 = c4 = ' ';
                        else
                        {   c4 = getc(f1);
                            if (c4 == '\n') eolfound = c4 = ' ';
                        }
                    }
                }
            }
            if (c1 == EOF || c2 == EOF || c3 == EOF || c4 == EOF)
                goto format_error;
            c1 = (c1 - ' ') & 0x3f;
            c2 = (c2 - ' ') & 0x3f;
            c3 = (c3 - ' ') & 0x3f;
            c4 = (c4 - ' ') & 0x3f;
            b1 = (c1 << 2) 
                 | (c2 >> 4);
            b2 = (c2 << 4) 
                 | (c3 >> 2);
            b3 = (c3 << 6) | c4;
            if (i >= 1) putc(b1, f2);
            if (i >= 2) putc(b2, f2);
            if (i >= 3) putc(b3, f2);
        }
        if (eolfound == 0)
        {   int c5 = getc(f1);
            if (c5 != '\n') goto format_error;
        }
        continue;
    format_error:
        fprintf(stderr, "Format error in uuencoded file\n");
        exit(EXIT_FAILURE);
    }
    fclose(f1);
    fclose(f2);
    fprintf(stderr, "Decoding OK\n");
    return 0;
}

/* end of uudecode.c */
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
