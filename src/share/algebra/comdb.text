0`
150`\spad{additiveValuation} implies \spad{euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}.
275`euclideanSize(a*b) = euclideanSize(a) + euclideanSize(\spad{b})
346`\spad{approximate} means "is an approximation to the real numbers".
463`\spad{arbitraryPrecision} means the user can set the precision for subsequent calculations.
547`canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element.
718`canonicalUnitNormal guarantees that the function unitCanonical returns the same representative for all associates of any particular element.
803`\spad{canonicalUnitNormal} is \spad{true} if we can choose a canonical representative for each class of associate elements,{} that is \spad{associates?(a,{}b)} returns \spad{true} if and only if \spad{unitCanonical(a) = unitCanonical(b)}.
853`either 0 or 1.
941`we can choose a unique representative for each associate class. This normalization is chosen to be normalization of leading coefficient (by default).
1029`\spad{canonical} is \spad{true} if and only if distinct elements have distinct data structures. For example,{} a domain of mathematical objects which has the \spad{canonical} attribute means that two objects are mathematically equal if and only if their data structures are equal.
1164`\spad{canonical} means that equal elements are in fact identical.
1283`mathematical equality is data structure equality.
1314`mathematical equality is data structure equality.
1350`\spad{canonical} means that mathematical equality is implied by data structure equality.
1387`\spad{canonicalsClosed} is \spad{true} if \spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.
1435`since \spad{0*0=0},{} \spad{1*1=1}
1471`two positives multiply to give positive.
1509`two positives multiply to give positive.
1552`\spad{canonicalClosed} means two positives multiply to give positive.
1596`the elements of the Ring \spad{R},{} viewed as diagonal matrices,{} commute with all matrices and,{} indeed,{} are the only matrices which commute with all matrices.
1664`\spad{central} is \spad{true} if,{} given an algebra over a ring \spad{R},{} the image of \spad{R} is the center of the algebra,{} \spadignore{i.e.} the set of members of the algebra which commute with all others is precisely the image of \spad{R} in the algebra.
1703`\spad{commutative("*")} is \spad{true} if it has an operation \spad{"*": (D,{}D) -> D} which is commutative.
1751`multiplication is commutative.
1797`a domain \spad{D} has \spad{commutative("*")} if it has an operation \spad{"*": (D,{}D) -> D} which is commutative.
1842`\spad{commutative("*")} means multiplication is commutative : \spad{x*y = y*x}.
1891`\spad{commutative("*")} means multiplication is commutative : x*y = \spad{y*x}
1937`indicates that \% has sqrt(\spad{-1})
2284`\spad{finiteAggregate} is \spad{true} if it is an aggregate with a finite number of elements.
2331`Binary trees have a finite number of components
2379`attribute to indicate an aggregate of finite size
2523`matrices are finite
2705`matrices are finite
2849`two-dimensional arrays are finite
3259`nextItem never returns "failed".
3289`\spad{leftUnitary} is \spad{true} if \spad{1 * x = x} for all \spad{x}.
3332`\spad{1 * x = x}
3366`\spad{multiplicativeValuation} imples \spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}.
3512`euclideanSize(a*b) returns \spad{euclideanSize(a)*euclideanSize(b)}.
3661`\spad{noZeroDivisors} is \spad{true} if \spad{x * y \~~= 0} implies both \spad{x} and \spad{y} are non-zero.
3707`if a product is zero then one of the factors must be zero.
3816`\spad{noetherian} is \spad{true} if all of its ideals are finitely generated.
3858`ascending chain condition on ideals.
3890`ascending chain condition on ideals.
3927`\spad{noetherian} all ideals are finitely generated (in fact principal).
3965`\spad{partiallyOrderedSet} is \spad{true} if a set with \spadop{<} which is transitive,{} but \spad{not(a < b or a = b)} does not necessarily imply \spad{b<a}.
4059`\spad{rightUnitary} is \spad{true} if \spad{x * 1 = x} for all \spad{x}.
4103`\spad{x * 1 = x}
4227`One may destructively alter TwoDimensionalArray\spad{'s}.
4277`\spad{shallowlyMutable} is \spad{true} if its values have immediate components that are updateable (mutable). Note: the properties of any component domain are irrevelant to the \spad{shallowlyMutable} proper.
4325`shallowlyMutable means that elements of bags may be destructively changed.
4368`Binary trees have updateable components
4470`One may destructively alter matrices
4620`one may destructively alter arrays
4848`one may destructively alter a stream by assigning new values to its entries.
4917`the invertible matrices are simply the matrices whose determinants are units in the Ring \spad{R}.
5087`\spad{unitsKnown} is \spad{true} if a monoid (a multiplicative semigroup with a 1) has \spad{unitsKnown} means that the operation \spadfun{recip} can only return "failed" if its argument is not a unit.
5200`unitsKnown means that \spadfun{recip} truly yields reciprocal or \spad{"failed"} if not a unit,{} similarly for \spadfun{leftRecip} and \spadfun{rightRecip}. The reason is that we use left,{} respectively right,{} minimal polynomials to decide this question.
5277`unitsKnown asserts that recip only returns "failed" for non-units.
5307`recip truly yields reciprocal or "failed" if not a unit. Note: \spad{recip(0) = "failed"}.
5336`The class of abelian groups,{} \spadignore{i.e.} additive monoids where each element has an additive inverse. \blankline
5381`Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} and with the coefficients (which themselves may or may not be commutative). See \spadtype{FiniteAbelianMonoidRing} for the case of finite supp
5381`--ort a useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on.
5457`The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with an additive identity element. \blankline
5503`the class of all additive (commutative) semigroups,{} \spadignore{i.e.} a set with a commutative and associative operation \spadop{+}. \blankline
5551`The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogenous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as "the set of \spad{x} satisfying relation {\em r(x)}" An attribute \spadatt{finiteAggregate} is used to assert that a doma
5551`--in has a finite number of elements.
5589`The category of associative algebras (modules which are themselves rings). \blankline
5647`Model for algebraically closed fields.
5700`Model for algebraically closed function spaces.
5785`Category for the inverse hyperbolic trigonometric functions.
5844`Category for the inverse trigonometric functions.
5993`This category exports the attributes in the AXIOM Library
6089`\spadtype{BasicType} is the basic category for describing a collection of elements with \spadop{=} (equality).
6131`A \spadtype{BiModule} is both a left and right module with respect to potentially different rings. \blankline
6345`A cachable set is a set whose elements keep an integer as part of their structure.
6389`This is an \spadtype{AbelianMonoid} with the cancellation property,{} \spadignore{i.e.} \spad{ a+b = a+c => b=c }. This is formalised by the partial subtraction operator,{} which satisfies the axioms listed below: \blankline
6446`Rings of Characteristic Non Zero
6499`Rings of Characteristic Zero.
6548`A is coercible to \spad{B} means any element of A can automatically be converted into an element of \spad{B} by the interpreter.
6643`Category for the usual combinatorial functions.
6703`CombinatorialOpsCategory is the category obtaining by adjoining summations and products to the usual combinatorial operations.
6760`The category of commutative rings with unity,{} \spadignore{i.e.} rings where \spadop{*} is commutative,{} and which have a multiplicative identity. element.
6871`A is convertible to \spad{B} means any element of A can be converted into an element of \spad{B},{} but not automatically by the interpreter.
7089`Differential extensions of a ring \spad{R}. Given a differentiation on \spad{R},{} extend it to a differentiation on \%.
7291`An ordinary differential ring,{} that is,{} a ring with an operation \spadfun{differentiate}. \blankline
7492`A division ring (sometimes called a skew field),{} \spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.
7593`Category for the elementary functions.
7781`Entire Rings (non-commutative Integral Domains),{} \spadignore{i.e.} a ring not necessarily commutative which has no zero divisors. \blankline
7824`A constructive euclidean domain,{} \spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\spadfun{euclideanSize}) than the divisor. \blankline Conditional attributes: \indented{2}{multiplicativeValuation\tab{25}\spad{Size(a*b)=Size(a)*Size(b)}} \indented{2}{additiveValuation\tab{25}\spad{Size(a*b)=Size(a)+Size(b)}}
7871`This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\spad{''} substitutions.
7925`An expression space is a set which is closed under certain operators.
8127`The category of commutative fields,{} \spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \spadfun{factor} operation while trivial is useful to have defined. \blankline
8163`This category provides an interface to operate on files in the computer\spad{'s} file system. The precise method of naming files is determined by the Name parameter. The type of the contents of the file is determined by \spad{S}.
8239`This category provides an interface to names in the file system.
8287`This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general.
8435`This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{'s} are integers and the \spad{P}\spad{'s} are finite rational points on the curve.
8731`A FiniteRankAlgebra is an algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.
8837`A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.
8980`The category of domains composed of a finite set of elements. We include the functions \spadfun{lookup} and \spadfun{index} to give a bijection between the finite set and an initial segment of positive integers. \blankline
9429`A \spadtype{FramedAlgebra} is a \spadtype{FiniteRankAlgebra} together with a fixed \spad{R}-module basis.
9531`FramedNonAssociativeAlgebra(\spad{R}) is a \spadtype{FiniteRankNonAssociativeAlgebra} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank) over a commutative ring \spad{R} together with a fixed \spad{R}-module basis.
9610`A free abelian monoid on a set \spad{S} is the monoid of finite sums of the form \spad{reduce(+,{}[\spad{ni} * \spad{si}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are in a given abelian monoid. The operation is commutative.
9710`The category of free Lie algebras. It is used by domains of non-commutative algebra: \spadtype{LiePolynomial} and \spadtype{XPBWPolynomial}. \newline Author: Michel Petitot (petitot@lifl.\spad{fr})
9792`A domain of this category implements formal linear combinations of elements from a domain \spad{Basis} with coefficients in a domain \spad{R}. The domain \spad{Basis} needs only to belong to the category \spadtype{SetCategory} and \spad{R} to the category \spadtype{Ring}. Thus the coefficient ring may be non-commutative. See the \spadtype{XDistributedPolynomial} constructor for examples of domains built with the \spadtype{FreeModule
9792`--Cat} category constructor. Author: Michel Petitot (petitot@lifl.\spad{fr})
9862`This category provides a selection of evaluation operations depending on what the argument type \spad{R} provides.
9927`\spad{S} is \spadtype{FullyLinearlyExplicitRingOver R} means that \spad{S} is a \spadtype{LinearlyExplicitRingOver R} and,{} in addition,{} if \spad{R} is a \spadtype{LinearlyExplicitRingOver Integer},{} then so is \spad{S}
9997`A set \spad{S} is PatternMatchable over \spad{R} if \spad{S} can lift the pattern-matching functions of \spad{S} over the integers and float to itself (necessary for matching in towers).
10059`\indented{2}{A is fully retractable to \spad{B} means that A is retractable to \spad{B},{} and,{}} \indented{2}{in addition,{} if \spad{B} is retractable to the integers or rational} \indented{2}{numbers then so is A.} \indented{2}{In particular,{} what we are asserting is that there are no integers} \indented{2}{(rationals) in A which don\spad{'t} retract into \spad{B}.} Date Created: March 1990 Date Last Updated: 9 April 1991
10118`This category is a model for the function field of a plane algebraic curve.
10287`A space of formal functions with arguments in an arbitrary ordered set.
10342`This category describes domains where \spadfun{\spad{gcd}} can be computed but where there is no guarantee of the existence of \spadfun{factor} operation for factorisation into irreducibles. However,{} if such a \spadfun{factor} operation exist,{} factorization will be unique up to order and units.
10384`GradedAlgebra(\spad{R},{}\spad{E}) denotes ``E-graded \spad{R}-algebra\spad{''}. A graded algebra is a graded module together with a degree preserving \spad{R}-linear map,{} called the {\em product}. \blankline The name ``product\spad{''} is written out in full so inner and outer products with the same mapping type can be distinguished by name.
10463`GradedModule(\spad{R},{}\spad{E}) denotes ``E-graded \spad{R}-module\spad{''},{} \spadignore{i.e.} collection of \spad{R}-modules indexed by an abelian monoid \spad{E}. An element \spad{g} of \spad{G[s]} for some specific \spad{s} in \spad{E} is said to be an element of \spad{G} with {\em degree} \spad{s}. Sums are defined in each module \spad{G[s]} so two elements of \spad{G} have a sum if they have the same degree. \blankl
10463`--ine Morphisms can be defined and composed by degree to give the mathematical category of graded modules.
10541`The class of multiplicative groups,{} \spadignore{i.e.} monoids with multiplicative inverses. \blankline
10633`Category for the hyperbolic trigonometric functions.
10765`This category represents the direct product of some set with respect to an ordered indexing set.
10851`This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\spad{''} substitutions. The difference between this and \spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation.
10919`An \spad{IntegerNumberSystem} is a model for the integers.
10968`The category of commutative integral domains,{} \spadignore{i.e.} commutative rings with no zero divisors. \blankline Conditional attributes: \indented{2}{canonicalUnitNormal\tab{20}the canonical field is the same for all associates} \indented{2}{canonicalsClosed\tab{20}the product of two canonicals is itself canonical}
11015`\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Date Last Updated: + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: + This category is an implementation of interval arithmetic and transcendental + functions over intervals.
11173`LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?',{} \spadignore{e.g.} 'first' and 'rest',{} will also cause lazy evaluation if necessary.
11233`The category of all left algebras over an arbitrary ring.
11282`The category of left modules over an \spad{rng} (ring not necessarily with unit). This is an abelian group which supports left multiplation by elements of the \spad{rng}. \blankline
11332`\axiom{JacobiIdentity} means that \axiom{[\spad{x},{}[\spad{y},{}\spad{z}]]+[\spad{y},{}[\spad{z},{}\spad{x}]]+[\spad{z},{}[\spad{x},{}\spad{y}]] = 0} holds.
11443`\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}
11526`An extension ring with an explicit linear dependence test.
11590`Category for the transcendental Liouvillian functions.
11697``Logic' provides the basic operations for lattices,{} \spadignore{e.g.} boolean algebra.
11734`\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the function \spadfun{minRowIndex}. T
11734`--he index of the 'first' column may be obtained by calling the function \spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.
11848`The category of modules over a commutative ring. \blankline
11905`\indented{1}{MonadWithUnit is the class of multiplicative monads with unit,{}} \indented{1}{\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \indented{3}{leftIdentity("*":(\%,{}\%)\spad{->}\%,{}1)\space{3}\tab{30} 1*x=x} \indented{3}{rightIdentity("*":(\%,{}\%)\spad{->}\%,{}1)\space{2}\tab{30} x*1=x} Common Additional Axioms \indented{3}{unitsKnown
11905`---if "recip" says "failed",{} that PROVES input wasn\spad{'t} a unit}
11952`Monad is the class of all multiplicative monads,{} \spadignore{i.e.} sets with a binary operation.
11989`A \spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.
12094`This is the category of linear operator rings with one generator. The generator is not named by the category but can always be constructed as \spad{monomial(1,{}1)}. \blankline For convenience,{} call the generator \spad{G}. Then each value is equal to \indented{4}{\spad{sum(a(i)*G**i,{} i = 0..n)}} for some unique \spad{n} and \spad{a(i)} in \spad{R}. \blankline Note that multiplication is not necessarily commutative. In fact,{} if \spad{a} 
12094`--is in \spad{R},{} it is quite normal to have \spad{a*G \^= G*a}.
12154`The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with a multiplicative identity element. \blankline
12311`\spadtype{MultivariateTaylorSeriesCategory} is the most general multivariate Taylor series category.
12401`NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \indented{3}{\spad{r*}(a*b) = (r*a)\spad{*b} = a*(\spad{r*b})}
12472`A NonAssociativeRing is a non associative \spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative.
12524`NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \indented{2}{\spad{x*}(\spad{y+z}) = x*y + \spad{x*z}} \indented{2}{(x+y)\spad{*z} = \spad{x*z} + \spad{y*z}} Common Additional Axioms \indented{2}{noZeroDivisors\space{2}ab = 0 \spad{=>} \spad{a=0} or \spad{b=0}}
12573`The category of normalized triangular sets. A triangular set \spad{ts} is said normalized if for every algebraic variable \spad{v} of \spad{ts} the polynomial \spad{select(ts,{}v)} is normalized \spad{w}.\spad{r}.\spad{t}. every polynomial in \spad{collectUnder(ts,{}v)}. A polynomial \spad{p} is said normalized \spad{w}.\spad{r}.\spad{t}. a non-c
12573`--onstant polynomial \spad{q} if \spad{p} is constant or \spad{degree(p,{}mdeg(q)) = 0} and \spad{init(p)} is normalized \spad{w}.\spad{r}.\spad{t}. \spad{q}. One of the important features of normalized triangular sets is that they are regular sets.\newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991} \indented{1}{[2] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZ
12573`--A "On the Theories} \indented{5}{of Triangular Sets" Journal of Symbol. Comp. (to appear)} \indented{1}{[3] \spad{M}. MORENO MAZA and \spad{R}. RIOBOO "Computations of \spad{gcd} over} \indented{5}{algebraic towers of simple extensions" In proceedings of \spad{AAECC11}} \indented{5}{Paris,{} 1995.} \indented{1}{[4] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \
12573`--spad{P}.etM. Curie,{} Paris,{} 1997.}
12846`OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the the quaternions in the same way as doubling the Complex numbers to get the quaternions.
12972`\spadtype{OpenMath} provides operations for exporting an object in OpenMath format.
13009`Ordered sets which are also abelian groups,{} such that the addition preserves the ordering.
13062`This domain is an OrderedAbelianMonoid with a \spadfun{sup} operation added. The purpose of the \spadfun{sup} operator in this domain is to act as a supremum with respect to the partial order imposed by \spadop{-},{} rather than with respect to the total \spad{>} order (since that is "max"). \blankline
13118`Ordered sets which are also abelian monoids,{} such that the addition preserves the ordering.
13170`Ordered sets which are also abelian semigroups,{} such that the addition preserves the ordering. \indented{2}{\spad{ x < y => x+z < y+z}}
13225`Ordered sets which are also abelian cancellation monoids,{} such that the addition preserves the ordering.
13290`Ordered finite sets.
13336`The category of ordered commutative integral domains,{} where ordering and the arithmetic operations are compatible \blankline
13391`Ordered sets which are also monoids,{} such that multiplication preserves the ordering. \blankline
13503`Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \blankline
13548`The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \spad{(a,{}b)} exactly one of the following relations holds \spad{a<b or a=b or b<a} and the relation is transitive,{} \spadignore{i.e.} \spad{a<b and b<c => a<c}.
13663`This is the catefory of stream-based representations of \indented{2}{the \spad{p}-adic integers.}
13798`A partial differential ring with differentiations indexed by a parameter type \spad{S}. \blankline
13868`This is the description of any package which provides partial functions on a domain belonging to TranscendentalFunctionCategory.
13965`A set \spad{R} is PatternMatchable over \spad{S} if elements of \spad{R} can be matched to patterns over \spad{S}.
14028`An object \spad{S} is Patternable over an object \spad{R} if \spad{S} can lift the conversions from \spad{R} into \spadtype{Pattern(Integer)} and \spadtype{Pattern(Float)} to itself.
14078`PermutationCategory provides a categorial environment \indented{1}{for subgroups of bijections of a set (\spadignore{i.e.} permutations)}
14145`PlottablePlaneCurveCategory is the category of curves in the plane which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \spad{x}-coordinates and \spad{y}-coordinates of the points on the curve.
14206`PlottableSpaceCurveCategory is the category of curves in 3-space which may be plotted via the graphics facilities. Functions are provided for obtaining lists of lists of points,{} representing the branches of the curve,{} and for determining the ranges of the \spad{x-},{} \spad{y-},{} and \spad{z}-coordinates of the points on the curve.
14315`The category for general multi-variate polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}.
14418`This is the category of domains that know "enough" about themselves in order to factor univariate polynomials over themselves. This will be used in future releases for supporting factorization over finitely generated coefficient fields,{} it is not yet available in the current release of axiom.
14482`A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \spad{R} being an integral domain,{} a set of polynomials may be viewed as a representation of the ideal it generates in the
14482`-- polynomial ring \spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions.
14641`\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.
14744`Category for the functions defined by integrals.
14803`The category of constructive principal ideal domains,{} \spadignore{i.e.} where a single generator can be constructively found for any ideal given by a finite set of generators. Note that this constructive definition only implies that finitely generated ideals are principal. It is not clear what we would mean by an infinitely generated ideal.
14917`\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.
15036`QuotientField(\spad{S}) is the category of fractions of an Integral Domain \spad{S}.
15150`\axiomType{RealClosedField} provides common acces functions for all real closed fields.
15280`\axiomType{RealRootCharacterizationCategory} provides common access functions for all real root codings.
15430`\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \spad{R}-modules and will be non-mutable.
15659`A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \axiomOp{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in the ordered set,{} so that some operatio
15659`--ns usually defined for univariate polynomials make sense here.
15766`The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polynomial ring \spad{k[x1,{}...,{}xn]} where
15766`-- \spad{k} is the fraction field of \spad{R}. The triangular set \spad{[t1,{}...,{}tm]} is regular iff for every \spad{i} the initial of \spad{ti+1} is invertible in the tower of simple extensions associated with \spad{[t1,{}...,{}\spad{ti}]}. A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \spad{I} iff the radical of \spad{I} is equal to the intersection of the radical ideals generated by the saturated ideals of the \spad{[T1,{}...,{}\spad{T
15766`--i}]}. A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \spad{T} iff it is a split of Kalkbrener of the saturated ideal of \spad{T}. Let \spad{K} be an algebraic closure of \spad{k}. Assume that \spad{V} is finite with cardinality \spad{n} and let \spad{A} be the affine space \spad{K^n}. For a regular triangular set \spad{T} let denote by \spad{W(T)} the set of regular zeros of \spad{T}. A family \spad{[T1,{}...,{}Ts]} of regular tria
15766`--ngular sets is a split of Lazard of a given subset \spad{S} of \spad{A} iff the union of the \spad{W(\spad{Ti})} contains \spad{S} and is contained in the closure of \spad{S} (\spad{w}.\spad{r}.\spad{t}. Zariski topology). A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Lazard of a given triangular set \spad{T} if it is a split of Lazard of \spad{W(T)}. Note that if \spad{[T1,{}...,{}Ts]} is a split of Lazard of \spad{T} then it is also a split of Kalkbrener of \spad{T
15766`--}. The converse is \spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \newline References : \indented{1}{[1] \spad{M}. KALKBRENER "Three contributions to elimination theory"} \indented{5}{\spad{Phd} Thesis
15766`--,{} University of Linz,{} Austria,{} 1991.} \indented{1}{[2] \spad{M}. KALKBRENER "Algorithmic properties of polynomial rings"} \indented{5}{Journal of Symbol. Comp. 1998} \indented{1}{[3] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZA "On the Theories} \indented{5}{of Triangular Sets" Journal of Symbol. Comp. (to appear)} \indented{1}{[4] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
15922`A is retractable to \spad{B} means that some elementsif A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.
15976`The category of right modules over an \spad{rng} (ring not necessarily with unit). This is an abelian group which supports right multiplation by elements of the \spad{rng}. \blankline
16027`The category of rings with unity,{} always associative,{} but not necessarily commutative.
16062`The category of associative rings,{} not necessarily commutative,{} and not necessarily with a 1. This is a combination of an abelian group and a semigroup,{} with multiplication distributing over addition. \blankline
16095`This category allows the manipulation of Lisp values while keeping the grunge fairly localized.
16228`This category provides operations on ranges,{} or {\em segments} as they are called.
16283`This category provides an interface for expanding segments to a stream of elements.
16378`the class of all multiplicative semigroups,{} \spadignore{i.e.} a set with an associative operation \spadop{*}. \blankline
16475`\spadtype{SetCategory} is the basic category for describing a collection of elements with \spadop{=} (equality) and \spadfun{coerce} to output form. \blankline Conditional Attributes: \indented{3}{canonical\tab{15}data structure equality is the same as \spadop{=}}
16519`Category for the other special functions.
16575`The category of square-free and normalized triangular sets. Thus,{} up to the primitivity axiom of [1],{} these sets are Lazard triangular sets.\newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991}
16744`The category of square-free regular triangular sets. A regular triangular set \spad{ts} is square-free if the \spad{gcd} of any polynomial \spad{p} in \spad{ts} and \spad{differentiate(p,{}mvar(p))} \spad{w}.\spad{r}.\spad{t}. \axiomOpFrom{collectUnder}{TriangularSetCategory}(\spad{ts},{}\axiomOpFrom{mvar}{RecursivePolynomialCategory}(\sp
16744`--ad{p})) has degree zero \spad{w}.\spad{r}.\spad{t}. \spad{mvar(p)}. Thus any square-free regular set defines a tower of square-free simple extensions.\newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991} \indented{1}{[2] \spad{M}. KALKBRENER "Algorithmic properties of polynomial rings"} \indented{5}{Habilitation Thesis,{} ETZH,{} Zurich,{} 1995.} \indented{1}{[3] \spad{M}. MO
16744`--RENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
16910`\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col.
17119`A class of objects which can be 'stepped through'. Repeated applications of \spadfun{nextItem} is guaranteed never to return duplicate items and only return "failed" after exhausting all elements of the domain. This assumes that the sequence starts with \spad{init()}. For infinite domains,{} repeated application of \spadfun{nextItem} is not required to reach all possible domain elements starting from any initial element. \blankline Conditional attributes: \ind
17119`--ented{2}{infinite\tab{15}repeated \spad{nextItem}\spad{'s} are never "failed".}
17428`Category for the transcendental elementary functions.
17492`The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \axiom{\spad{R}} be an integral domain and \axiom{\spad{V}} a finite ordered set of variables,{} say \axiom{\spad{X1} < \spad{X2} < ... < \spad{Xn}}. A set \axiom{\spad{S}} of polynomials in \axiom{\spad{R}[\spad{X1},{}\spad{X2},{}...,{}\spad{Xn}]
17492`--} is triangular if no elements of \axiom{\spad{S}} lies in \axiom{\spad{R}},{} and if two distinct elements of \axiom{\spad{S}} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \axiom{\spad{P}} is reduced \spad{w}.\spad{r}.\
17492`--spad{t} a non-constant polynomial \axiom{\spad{Q}} if the degree of \axiom{\spad{P}} in the main variable of \axiom{\spad{Q}} is less than the main degree of \axiom{\spad{Q}}. A polynomial \axiom{\spad{P}} is reduced \spad{w}.\spad{r}.\spad{t} a triangular set \axiom{\spad{T}} if it is reduced \spad{w}.\spad{r}.\spad{t}. every polynomial of \axiom{\spad{T}}. \newline References : \indented{1}{[1] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZA "On the Theories} \indented{5}{of Tr
17492`--iangular Sets" Journal of Symbol. Comp. (to appear)}
17646`Category for the trigonometric functions.
17709`\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the 'first' row may be obtained by calling the function 'minRowIndex'. The index of the 'first' column may be obt
17709`--ained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa.
17837`The fundamental Type.
17930`A constructive unique factorization domain,{} \spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.
17985`\spadtype{UnivariateLaurentSeriesCategory} is the category of Laurent series in one variable.
18059`This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \spad{[n,{}f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x**n * f(x)}.
18191`The category of univariate polynomials over a ring \spad{R}. No particular model is assumed - implementations can be either sparse or dense.
18259`\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents.
18358`\spadtype{UnivariatePuiseuxSeriesCategory} is the category of Puiseux series in one variable.
18433`This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{}f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.
18566`This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}. This category is an evolution of the types \indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \indented{2}{NonCommutativeOperatorDivision} developped by Jean Della Dora and Stephen \spad{M}. Watt.
18639`\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.
18763`Vector Spaces (not necessarily finite dimensional) over a field.
18815`This is the category of algebras over non-commutative rings. It is used by constructors of non-commutative algebras such as: \indented{4}{\spadtype{XPolynomialRing}.} \indented{4}{\spadtype{XFreeAlgebra}} Author: Michel Petitot (petitot@lifl.\spad{fr})
18861`This category specifies opeations for polynomials and formal series with non-commutative variables.
18926`The Category of polynomial rings with non-commutative variables. The coefficient ring may be non-commutative too. However coefficients commute with vaiables.
18995`AlgebraGivenByStructuralConstants implements finite rank algebras over a commutative ring,{} given by the structural constants \spad{gamma} with respect to a fixed basis \spad{[a1,{}..,{}an]},{} where \spad{gamma} is an \spad{n}-vector of \spad{n} by \spad{n} matrices \spad{[(gammaijk) for k in 1..rank()]} defined by \spad{\spad{ai} * aj
18995`-- = gammaij1 * a1 + ... + gammaijn * an}. The symbols for the fixed basis have to be given as a list of symbols.
19162`Function field defined by \spad{f}(\spad{x},{} \spad{y}) = 0.
19364`Algebraic closure of the rational numbers,{} with mathematical =
19425`This domain implements anonymous functions
19476`The domain of antisymmetric polynomials.
19559`\spadtype{Any} implements a type that packages up objects and their types in objects of \spadtype{Any}. Roughly speaking that means that if \spad{s : S} then when converted to \spadtype{Any},{} the new object will include both the original object and its type. This is a way of converting arbitrary objects into a single type without losing any of the original information. Any object can be converted to one of \spadtype{Any}.
19677`\spadtype{ASP10} produces Fortran for Type 10 ASPs,{} needed for NAG routine \axiomOpFrom{d02kef}{d02Package}. This ASP computes the values of a set of functions,{} for example:\begin{verbatim}      SUBROUTINE COEFFN(P,Q,DQDL,X,ELAM,JINT)      DOUBLE PRECISION ELAM,P,Q,X,DQDL      INTEGER JINT      P=1.0D0      Q=((-1.0D0*X**3)+ELAM*X*X-2.0D0)/(X*X)      DQDL=1.0D0      RETURN      END\end{verbatim}
19757`\spadtype{Asp12} produces Fortran for Type 12 ASPs,{} needed for NAG routine \axiomOpFrom{d02kef}{d02Package} etc.,{} for example:\begin{verbatim}      SUBROUTINE MONIT (MAXIT,IFLAG,ELAM,FINFO)      DOUBLE PRECISION ELAM,FINFO(15)      INTEGER MAXIT,IFLAG      IF(MAXIT.EQ.-1)THEN        PRINT*,"Output from Monit"      ENDIF      PRINT*,MAXIT,IFLAG,ELAM,(FINFO(I),I=1,4)      RETURN      END\end{verbatim}
19830`\spadtype{Asp19} produces Fortran for Type 19 ASPs,{} evaluating a set of functions and their jacobian at a given point,{} for example:\begin{verbatim}      SUBROUTINE LSFUN2(M,N,XC,FVECC,FJACC,LJC)      DOUBLE PRECISION FVECC(M),FJACC(LJC,N),XC(N)      INTEGER M,N,LJC      INTEGER I,J      DO 25003 I=1,LJC        DO 25004 J=1,N          FJACC(I,J)=0.0D025004   CONTINUE25003 CONTINUE      FVECC(1)=((XC(1)-0.14D0
19830`--)*XC(3)+(15.0D0*XC(1)-2.1D0)*XC(2)+1.0D0)/(     &XC(3)+15.0D0*XC(2))      FVECC(2)=((XC(1)-0.18D0)*XC(3)+(7.0D0*XC(1)-1.26D0)*XC(2)+1.0D0)/(     &XC(3)+7.0D0*XC(2))      FVECC(3)=((XC(1)-0.22D0)*XC(3)+(4.333333333333333D0*XC(1)-0.953333     &3333333333D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))      FVECC(4)=((XC(1)-0.25D0)*XC(3)+(3.0D0*XC(1)-0.75D0)*XC(2)+1.0D0)/(     &XC(3)+3.0D0*XC(2))      FVECC(5)=((XC(1)-0.29D0)*XC(3)+(2.2D0*XC(1)-0.6379999999999999D0)*     &XC(2)+1.0D0)/
19830`--(XC(3)+2.2D0*XC(2))      FVECC(6)=((XC(1)-0.32D0)*XC(3)+(1.666666666666667D0*XC(1)-0.533333     &3333333333D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))      FVECC(7)=((XC(1)-0.35D0)*XC(3)+(1.285714285714286D0*XC(1)-0.45D0)*     &XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))      FVECC(8)=((XC(1)-0.39D0)*XC(3)+(XC(1)-0.39D0)*XC(2)+1.0D0)/(XC(3)+     &XC(2))      FVECC(9)=((XC(1)-0.37D0)*XC(3)+(XC(1)-0.37D0)*XC(2)+1.285714285714     &286D0)/(XC(3)+XC(2))      FVECC(10)=((XC(1)-0.
19830`--58D0)*XC(3)+(XC(1)-0.58D0)*XC(2)+1.66666666666     &6667D0)/(XC(3)+XC(2))      FVECC(11)=((XC(1)-0.73D0)*XC(3)+(XC(1)-0.73D0)*XC(2)+2.2D0)/(XC(3)     &+XC(2))      FVECC(12)=((XC(1)-0.96D0)*XC(3)+(XC(1)-0.96D0)*XC(2)+3.0D0)/(XC(3)     &+XC(2))      FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333     &3333D0)/(XC(3)+XC(2))      FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X     &C(2))      FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0
19830`--D0)/(XC(3     &)+XC(2))      FJACC(1,1)=1.0D0      FJACC(1,2)=-15.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)      FJACC(1,3)=-1.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)      FJACC(2,1)=1.0D0      FJACC(2,2)=-7.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)      FJACC(2,3)=-1.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)      FJACC(3,1)=1.0D0      FJACC(3,2)=((-0.1110223024625157D-15*XC(3))-4.333333333333333D0)/(     &XC(3)**2+8.666666666666666D0*XC(2)*XC(3)+1
19830`--8.77777777777778D0*XC(2)     &**2)      FJACC(3,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+8.666666     &666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)**2)      FJACC(4,1)=1.0D0      FJACC(4,2)=-3.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)      FJACC(4,3)=-1.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)      FJACC(5,1)=1.0D0      FJACC(5,2)=((-0.1110223024625157D-15*XC(3))-2.2D0)/(XC(3)**2+4.399     &999999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)      FJACC
19830`--(5,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+4.399999     &999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)      FJACC(6,1)=1.0D0      FJACC(6,2)=((-0.2220446049250313D-15*XC(3))-1.666666666666667D0)/(     &XC(3)**2+3.333333333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)     &**2)      FJACC(6,3)=(0.2220446049250313D-15*XC(2)-1.0D0)/(XC(3)**2+3.333333     &333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)**2)      FJACC(7,1)=1.0D0      FJACC(7,2)=((-0.5551115123125783D
19830`---16*XC(3))-1.285714285714286D0)/(     &XC(3)**2+2.571428571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)     &**2)      FJACC(7,3)=(0.5551115123125783D-16*XC(2)-1.0D0)/(XC(3)**2+2.571428     &571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)**2)      FJACC(8,1)=1.0D0      FJACC(8,2)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(8,3)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(9,1)=1.0D0      FJACC(9,2)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*     
19830`--&*2)      FJACC(9,3)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*     &*2)      FJACC(10,1)=1.0D0      FJACC(10,2)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)     &**2)      FJACC(10,3)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)     &**2)      FJACC(11,1)=1.0D0      FJACC(11,2)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(11,3)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(12,1)=1.0D0      FJACC(12,2)=-3.0D0/(XC(3)**2+2.0D0*XC(
19830`--2)*XC(3)+XC(2)**2)      FJACC(12,3)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(13,1)=1.0D0      FJACC(13,2)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)     &**2)      FJACC(13,3)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)     &**2)      FJACC(14,1)=1.0D0      FJACC(14,2)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(14,3)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      FJACC(15,1)=1.0D0      FJACC(15,2)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC
19830`--(3)+XC(2)**2)      FJACC(15,3)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)      RETURN      END\end{verbatim}
19910`\spadtype{Asp1} produces Fortran for Type 1 ASPs,{} needed for various NAG routines. Type 1 ASPs take a univariate expression (in the symbol \spad{X}) and turn it into a Fortran Function like the following:\begin{verbatim}      DOUBLE PRECISION FUNCTION F(X)      DOUBLE PRECISION X      F=DSIN(X)      RETURN      END\end{verbatim}
19982`\spadtype{Asp20} produces Fortran for Type 20 ASPs,{} for example:\begin{verbatim}      SUBROUTINE QPHESS(N,NROWH,NCOLH,JTHCOL,HESS,X,HX)      DOUBLE PRECISION HX(N),X(N),HESS(NROWH,NCOLH)      INTEGER JTHCOL,N,NROWH,NCOLH      HX(1)=2.0D0*X(1)      HX(2)=2.0D0*X(2)      HX(3)=2.0D0*X(4)+2.0D0*X(3)      HX(4)=2.0D0*X(4)+2.0D0*X(3)      HX(5)=2.0D0*X(5)      HX(6)=(-2.0D0*X(7))+(-2.0D0*X(6))      HX(7)=(-2.0D0*X(
19982`--7))+(-2.0D0*X(6))      RETURN      END\end{verbatim}
20062`\spadtype{Asp24} produces Fortran for Type 24 ASPs which evaluate a multivariate function at a point (needed for NAG routine \axiomOpFrom{e04jaf}{e04Package}),{} for example:\begin{verbatim}      SUBROUTINE FUNCT1(N,XC,FC)      DOUBLE PRECISION FC,XC(N)      INTEGER N      FC=10.0D0*XC(4)**4+(-40.0D0*XC(1)*XC(4)**3)+(60.0D0*XC(1)**2+5     &.0D0)*XC(4)**2+((-10.0D0*XC(3))+(-40.0D0*XC(1)**3))*XC(4)+16.0D0*X     &C(3)**4+(-3
20062`--2.0D0*XC(2)*XC(3)**3)+(24.0D0*XC(2)**2+5.0D0)*XC(3)**2+     &(-8.0D0*XC(2)**3*XC(3))+XC(2)**4+100.0D0*XC(2)**2+20.0D0*XC(1)*XC(     &2)+10.0D0*XC(1)**4+XC(1)**2      RETURN      END\end{verbatim}
20136`\spadtype{Asp27} produces Fortran for Type 27 ASPs,{} needed for NAG routine \axiomOpFrom{f02fjf}{f02Package} ,{}for example:\begin{verbatim}      FUNCTION DOT(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)      DOUBLE PRECISION W(N),Z(N),RWORK(LRWORK)      INTEGER N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)      DOT=(W(16)+(-0.5D0*W(15)))*Z(16)+((-0.5D0*W(16))+W(15)+(-0.5D0*W(1     &4)))*Z(15)+((-0.5D0*W(15))+W(14)+(-0.5D0*W(13)))*Z(14)+((-0.5D0*W(
20136`--     &14))+W(13)+(-0.5D0*W(12)))*Z(13)+((-0.5D0*W(13))+W(12)+(-0.5D0*W(1     &1)))*Z(12)+((-0.5D0*W(12))+W(11)+(-0.5D0*W(10)))*Z(11)+((-0.5D0*W(     &11))+W(10)+(-0.5D0*W(9)))*Z(10)+((-0.5D0*W(10))+W(9)+(-0.5D0*W(8))     &)*Z(9)+((-0.5D0*W(9))+W(8)+(-0.5D0*W(7)))*Z(8)+((-0.5D0*W(8))+W(7)     &+(-0.5D0*W(6)))*Z(7)+((-0.5D0*W(7))+W(6)+(-0.5D0*W(5)))*Z(6)+((-0.     &5D0*W(6))+W(5)+(-0.5D0*W(4)))*Z(5)+((-0.5D0*W(5))+W(4)+(-0.5D0*W(3     &)))*Z(4)+((-0.5D0*W(4))+W(3)+(-0.5D0*W(2)))*Z(3)+((-0.
20136`--5D0*W(3))+W(     &2)+(-0.5D0*W(1)))*Z(2)+((-0.5D0*W(2))+W(1))*Z(1)      RETURN      END\end{verbatim}
20198`\spadtype{Asp28} produces Fortran for Type 28 ASPs,{} used in NAG routine \axiomOpFrom{f02fjf}{f02Package},{} for example:\begin{verbatim}      SUBROUTINE IMAGE(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)      DOUBLE PRECISION Z(N),W(N),IWORK(LRWORK),RWORK(LRWORK)      INTEGER N,LIWORK,IFLAG,LRWORK      W(1)=0.01707454969713436D0*Z(16)+0.001747395874954051D0*Z(15)+0.00     &2106973900813502D0*Z(14)+0.002957434991769087D0*Z(13)+(-0.00700554
20198`--     &0882865317D0*Z(12))+(-0.01219194009813166D0*Z(11))+0.0037230647365     &3087D0*Z(10)+0.04932374658377151D0*Z(9)+(-0.03586220812223305D0*Z(     &8))+(-0.04723268012114625D0*Z(7))+(-0.02434652144032987D0*Z(6))+0.     &2264766947290192D0*Z(5)+(-0.1385343580686922D0*Z(4))+(-0.116530050     &8238904D0*Z(3))+(-0.2803531651057233D0*Z(2))+1.019463911841327D0*Z     &(1)      W(2)=0.0227345011107737D0*Z(16)+0.008812321197398072D0*Z(15)+0.010     &94012210519586D0*Z(14)+(-0.0176407246399974
20198`--4D0*Z(13))+(-0.01357136     &72105995D0*Z(12))+0.00157466157362272D0*Z(11)+0.05258889186338282D     &0*Z(10)+(-0.01981532388243379D0*Z(9))+(-0.06095390688679697D0*Z(8)     &)+(-0.04153119955569051D0*Z(7))+0.2176561076571465D0*Z(6)+(-0.0532     &5555586632358D0*Z(5))+(-0.1688977368984641D0*Z(4))+(-0.32440166056     &67343D0*Z(3))+0.9128222941872173D0*Z(2)+(-0.2419652703415429D0*Z(1     &))      W(3)=0.03371198197190302D0*Z(16)+0.02021603150122265D0*Z(15)+(-0.0     &06607305534689702D0*Z
20198`--(14))+(-0.03032392238968179D0*Z(13))+0.002033     &305231024948D0*Z(12)+0.05375944956767728D0*Z(11)+(-0.0163213312502     &9967D0*Z(10))+(-0.05483186562035512D0*Z(9))+(-0.04901428822579872D     &0*Z(8))+0.2091097927887612D0*Z(7)+(-0.05760560341383113D0*Z(6))+(-     &0.1236679206156403D0*Z(5))+(-0.3523683853026259D0*Z(4))+0.88929961     &32269974D0*Z(3)+(-0.2995429545781457D0*Z(2))+(-0.02986582812574917     &D0*Z(1))      W(4)=0.05141563713660119D0*Z(16)+0.005239165960779299D0*Z(15)+(-0.
20198`--     &01623427735779699D0*Z(14))+(-0.01965809746040371D0*Z(13))+0.054688     &97337339577D0*Z(12)+(-0.014224695935687D0*Z(11))+(-0.0505181779315     &6355D0*Z(10))+(-0.04353074206076491D0*Z(9))+0.2012230497530726D0*Z     &(8)+(-0.06630874514535952D0*Z(7))+(-0.1280829963720053D0*Z(6))+(-0     &.305169742604165D0*Z(5))+0.8600427128450191D0*Z(4)+(-0.32415033802     &68184D0*Z(3))+(-0.09033531980693314D0*Z(2))+0.09089205517109111D0*     &Z(1)      W(5)=0.04556369767776375D0*Z(16)+(-0.00182
20198`--2737697581869D0*Z(15))+(     &-0.002512226501941856D0*Z(14))+0.02947046460707379D0*Z(13)+(-0.014     &45079632086177D0*Z(12))+(-0.05034242196614937D0*Z(11))+(-0.0376966     &3291725935D0*Z(10))+0.2171103102175198D0*Z(9)+(-0.0824949256021352     &4D0*Z(8))+(-0.1473995209288945D0*Z(7))+(-0.315042193418466D0*Z(6))     &+0.9591623347824002D0*Z(5)+(-0.3852396953763045D0*Z(4))+(-0.141718     &5427288274D0*Z(3))+(-0.03423495461011043D0*Z(2))+0.319820917706851     &6D0*Z(1)      W(6)=0.0401514
20198`--7277405744D0*Z(16)+0.01328585741341559D0*Z(15)+0.048     &26082005465965D0*Z(14)+(-0.04319641116207706D0*Z(13))+(-0.04931323     &319055762D0*Z(12))+(-0.03526886317505474D0*Z(11))+0.22295383396730     &01D0*Z(10)+(-0.07375317649315155D0*Z(9))+(-0.1589391311991561D0*Z(     &8))+(-0.328001910890377D0*Z(7))+0.952576555482747D0*Z(6)+(-0.31583     &09975786731D0*Z(5))+(-0.1846882042225383D0*Z(4))+(-0.0703762046700     &4427D0*Z(3))+0.2311852964327382D0*Z(2)+0.04254083491825025D0*Z(1)      W(
20198`--7)=0.06069778964023718D0*Z(16)+0.06681263884671322D0*Z(15)+(-0.0     &2113506688615768D0*Z(14))+(-0.083996867458326D0*Z(13))+(-0.0329843     &8523869648D0*Z(12))+0.2276878326327734D0*Z(11)+(-0.067356038933017     &95D0*Z(10))+(-0.1559813965382218D0*Z(9))+(-0.3363262957694705D0*Z(     &8))+0.9442791158560948D0*Z(7)+(-0.3199955249404657D0*Z(6))+(-0.136     &2463839920727D0*Z(5))+(-0.1006185171570586D0*Z(4))+0.2057504515015     &423D0*Z(3)+(-0.02065879269286707D0*Z(2))+0.03160990266745513D0
20198`--*Z(1     &)      W(8)=0.126386868896738D0*Z(16)+0.002563370039476418D0*Z(15)+(-0.05     &581757739455641D0*Z(14))+(-0.07777893205900685D0*Z(13))+0.23117338     &45834199D0*Z(12)+(-0.06031581134427592D0*Z(11))+(-0.14805474755869     &52D0*Z(10))+(-0.3364014128402243D0*Z(9))+0.9364014128402244D0*Z(8)     &+(-0.3269452524413048D0*Z(7))+(-0.1396841886557241D0*Z(6))+(-0.056     &1733845834199D0*Z(5))+0.1777789320590069D0*Z(4)+(-0.04418242260544     &359D0*Z(3))+(-0.02756337003947642D0*Z(2))
20198`--+0.07361313110326199D0*Z(     &1)      W(9)=0.07361313110326199D0*Z(16)+(-0.02756337003947642D0*Z(15))+(-     &0.04418242260544359D0*Z(14))+0.1777789320590069D0*Z(13)+(-0.056173     &3845834199D0*Z(12))+(-0.1396841886557241D0*Z(11))+(-0.326945252441     &3048D0*Z(10))+0.9364014128402244D0*Z(9)+(-0.3364014128402243D0*Z(8     &))+(-0.1480547475586952D0*Z(7))+(-0.06031581134427592D0*Z(6))+0.23     &11733845834199D0*Z(5)+(-0.07777893205900685D0*Z(4))+(-0.0558175773     &9455641D0*Z(3))+0.0
20198`--02563370039476418D0*Z(2)+0.126386868896738D0*Z(     &1)      W(10)=0.03160990266745513D0*Z(16)+(-0.02065879269286707D0*Z(15))+0     &.2057504515015423D0*Z(14)+(-0.1006185171570586D0*Z(13))+(-0.136246     &3839920727D0*Z(12))+(-0.3199955249404657D0*Z(11))+0.94427911585609     &48D0*Z(10)+(-0.3363262957694705D0*Z(9))+(-0.1559813965382218D0*Z(8     &))+(-0.06735603893301795D0*Z(7))+0.2276878326327734D0*Z(6)+(-0.032     &98438523869648D0*Z(5))+(-0.083996867458326D0*Z(4))+(-0.02113506688   
20198`--  &615768D0*Z(3))+0.06681263884671322D0*Z(2)+0.06069778964023718D0*Z(     &1)      W(11)=0.04254083491825025D0*Z(16)+0.2311852964327382D0*Z(15)+(-0.0     &7037620467004427D0*Z(14))+(-0.1846882042225383D0*Z(13))+(-0.315830     &9975786731D0*Z(12))+0.952576555482747D0*Z(11)+(-0.328001910890377D     &0*Z(10))+(-0.1589391311991561D0*Z(9))+(-0.07375317649315155D0*Z(8)     &)+0.2229538339673001D0*Z(7)+(-0.03526886317505474D0*Z(6))+(-0.0493     &1323319055762D0*Z(5))+(-0.04319641116207706D0*Z(
20198`--4))+0.048260820054     &65965D0*Z(3)+0.01328585741341559D0*Z(2)+0.04015147277405744D0*Z(1)      W(12)=0.3198209177068516D0*Z(16)+(-0.03423495461011043D0*Z(15))+(-     &0.1417185427288274D0*Z(14))+(-0.3852396953763045D0*Z(13))+0.959162     &3347824002D0*Z(12)+(-0.315042193418466D0*Z(11))+(-0.14739952092889     &45D0*Z(10))+(-0.08249492560213524D0*Z(9))+0.2171103102175198D0*Z(8     &)+(-0.03769663291725935D0*Z(7))+(-0.05034242196614937D0*Z(6))+(-0.     &01445079632086177D0*Z(5))+0.0294704
20198`--6460707379D0*Z(4)+(-0.002512226     &501941856D0*Z(3))+(-0.001822737697581869D0*Z(2))+0.045563697677763     &75D0*Z(1)      W(13)=0.09089205517109111D0*Z(16)+(-0.09033531980693314D0*Z(15))+(     &-0.3241503380268184D0*Z(14))+0.8600427128450191D0*Z(13)+(-0.305169     &742604165D0*Z(12))+(-0.1280829963720053D0*Z(11))+(-0.0663087451453     &5952D0*Z(10))+0.2012230497530726D0*Z(9)+(-0.04353074206076491D0*Z(     &8))+(-0.05051817793156355D0*Z(7))+(-0.014224695935687D0*Z(6))+0.05     &468897
20198`--337339577D0*Z(5)+(-0.01965809746040371D0*Z(4))+(-0.016234277     &35779699D0*Z(3))+0.005239165960779299D0*Z(2)+0.05141563713660119D0     &*Z(1)      W(14)=(-0.02986582812574917D0*Z(16))+(-0.2995429545781457D0*Z(15))     &+0.8892996132269974D0*Z(14)+(-0.3523683853026259D0*Z(13))+(-0.1236     &679206156403D0*Z(12))+(-0.05760560341383113D0*Z(11))+0.20910979278     &87612D0*Z(10)+(-0.04901428822579872D0*Z(9))+(-0.05483186562035512D     &0*Z(8))+(-0.01632133125029967D0*Z(7))+0.05375944956767
20198`--728D0*Z(6)+0     &.002033305231024948D0*Z(5)+(-0.03032392238968179D0*Z(4))+(-0.00660     &7305534689702D0*Z(3))+0.02021603150122265D0*Z(2)+0.033711981971903     &02D0*Z(1)      W(15)=(-0.2419652703415429D0*Z(16))+0.9128222941872173D0*Z(15)+(-0     &.3244016605667343D0*Z(14))+(-0.1688977368984641D0*Z(13))+(-0.05325     &555586632358D0*Z(12))+0.2176561076571465D0*Z(11)+(-0.0415311995556     &9051D0*Z(10))+(-0.06095390688679697D0*Z(9))+(-0.01981532388243379D     &0*Z(8))+0.052588891863382
20198`--82D0*Z(7)+0.00157466157362272D0*Z(6)+(-0.     &0135713672105995D0*Z(5))+(-0.01764072463999744D0*Z(4))+0.010940122     &10519586D0*Z(3)+0.008812321197398072D0*Z(2)+0.0227345011107737D0*Z     &(1)      W(16)=1.019463911841327D0*Z(16)+(-0.2803531651057233D0*Z(15))+(-0.     &1165300508238904D0*Z(14))+(-0.1385343580686922D0*Z(13))+0.22647669     &47290192D0*Z(12)+(-0.02434652144032987D0*Z(11))+(-0.04723268012114     &625D0*Z(10))+(-0.03586220812223305D0*Z(9))+0.04932374658377151D0*Z     &(8
20198`--)+0.00372306473653087D0*Z(7)+(-0.01219194009813166D0*Z(6))+(-0.0     &07005540882865317D0*Z(5))+0.002957434991769087D0*Z(4)+0.0021069739     &00813502D0*Z(3)+0.001747395874954051D0*Z(2)+0.01707454969713436D0*     &Z(1)      RETURN      END\end{verbatim}
20260`\spadtype{Asp29} produces Fortran for Type 29 ASPs,{} needed for NAG routine \axiomOpFrom{f02fjf}{f02Package},{} for example:\begin{verbatim}      SUBROUTINE MONIT(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)      DOUBLE PRECISION D(K),F(K)      INTEGER K,NEXTIT,NEVALS,NVECS,ISTATE      CALL F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)      RETURN      END\end{verbatim}
20333`\spadtype{Asp30} produces Fortran for Type 30 ASPs,{} needed for NAG routine \axiomOpFrom{f04qaf}{f04Package},{} for example:\begin{verbatim}      SUBROUTINE APROD(MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)      DOUBLE PRECISION X(N),Y(M),RWORK(LRWORK)      INTEGER M,N,LIWORK,IFAIL,LRWORK,IWORK(LIWORK),MODE      DOUBLE PRECISION A(5,5)      EXTERNAL F06PAF      A(1,1)=1.0D0      A(1,2)=0.0D0      A(1,3)=0.0D0      A(1,4)=-1.0D0     
20333`-- A(1,5)=0.0D0      A(2,1)=0.0D0      A(2,2)=1.0D0      A(2,3)=0.0D0      A(2,4)=0.0D0      A(2,5)=-1.0D0      A(3,1)=0.0D0      A(3,2)=0.0D0      A(3,3)=1.0D0      A(3,4)=-1.0D0      A(3,5)=0.0D0      A(4,1)=-1.0D0      A(4,2)=0.0D0      A(4,3)=-1.0D0      A(4,4)=4.0D0      A(4,5)=-1.0D0      A(5,1)=0.0D0      A(5,2)=-1.0D0      A(5,3)=0.0D0      A(5,4)=-1.0D0      A(5,5)=4.0D0      IF(MODE.EQ.1)THEN        CALL F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)      ELSEIF(MODE.EQ
20333`--.2)THEN        CALL F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)      ENDIF      RETURN      END\end{verbatim}
20395`\spadtype{Asp31} produces Fortran for Type 31 ASPs,{} needed for NAG routine \axiomOpFrom{d02ejf}{d02Package},{} for example:\begin{verbatim}      SUBROUTINE PEDERV(X,Y,PW)      DOUBLE PRECISION X,Y(*)      DOUBLE PRECISION PW(3,3)      PW(1,1)=-0.03999999999999999D0      PW(1,2)=10000.0D0*Y(3)      PW(1,3)=10000.0D0*Y(2)      PW(2,1)=0.03999999999999999D0      PW(2,2)=(-10000.0D0*Y(3))+(-60000000.0D0*Y(2))      
20395`--PW(2,3)=-10000.0D0*Y(2)      PW(3,1)=0.0D0      PW(3,2)=60000000.0D0*Y(2)      PW(3,3)=0.0D0      RETURN      END\end{verbatim}
20475`\spadtype{Asp33} produces Fortran for Type 33 ASPs,{} needed for NAG routine \axiomOpFrom{d02kef}{d02Package}. The code is a dummy ASP:\begin{verbatim}      SUBROUTINE REPORT(X,V,JINT)      DOUBLE PRECISION V(3),X      INTEGER JINT      RETURN      END\end{verbatim}
20548`\spadtype{Asp34} produces Fortran for Type 34 ASPs,{} needed for NAG routine \axiomOpFrom{f04mbf}{f04Package},{} for example:\begin{verbatim}      SUBROUTINE MSOLVE(IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)      DOUBLE PRECISION RWORK(LRWORK),X(N),Y(N)      INTEGER I,J,N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)      DOUBLE PRECISION W1(3),W2(3),MS(3,3)      IFLAG=-1      MS(1,1)=2.0D0      MS(1,2)=1.0D0      MS(1,3)=0.0D0      MS(2,1)=1.0D0
20548`--      MS(2,2)=2.0D0      MS(2,3)=1.0D0      MS(3,1)=0.0D0      MS(3,2)=1.0D0      MS(3,3)=2.0D0      CALL F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)      IFLAG=-IFLAG      RETURN      END\end{verbatim}
20610`\spadtype{Asp35} produces Fortran for Type 35 ASPs,{} needed for NAG routines \axiomOpFrom{c05pbf}{c05Package},{} \axiomOpFrom{c05pcf}{c05Package},{} for example:\begin{verbatim}      SUBROUTINE FCN(N,X,FVEC,FJAC,LDFJAC,IFLAG)      DOUBLE PRECISION X(N),FVEC(N),FJAC(LDFJAC,N)      INTEGER LDFJAC,N,IFLAG      IF(IFLAG.EQ.1)THEN        FVEC(1)=(-1.0D0*X(2))+X(1)        FVEC(2)=(-1.0D0*X(3))+2.0D0*X(2)        FVEC(3)=
20610`--3.0D0*X(3)      ELSEIF(IFLAG.EQ.2)THEN        FJAC(1,1)=1.0D0        FJAC(1,2)=-1.0D0        FJAC(1,3)=0.0D0        FJAC(2,1)=0.0D0        FJAC(2,2)=2.0D0        FJAC(2,3)=-1.0D0        FJAC(3,1)=0.0D0        FJAC(3,2)=0.0D0        FJAC(3,3)=3.0D0      ENDIF      END\end{verbatim}
20690`\spadtype{Asp41} produces Fortran for Type 41 ASPs,{} needed for NAG routines \axiomOpFrom{d02raf}{d02Package} and \axiomOpFrom{d02saf}{d02Package} in particular. These ASPs are in fact three Fortran routines which return a vector of functions,{} and their derivatives \spad{wrt} \spad{Y}(\spad{i}) and also a continuation parameter EPS,{} for example:\begin{verbatim}      SUBROUTINE FCN(
20690`--X,EPS,Y,F,N)      DOUBLE PRECISION EPS,F(N),X,Y(N)      INTEGER N      F(1)=Y(2)      F(2)=Y(3)      F(3)=(-1.0D0*Y(1)*Y(3))+2.0D0*EPS*Y(2)**2+(-2.0D0*EPS)      RETURN      END      SUBROUTINE JACOBF(X,EPS,Y,F,N)      DOUBLE PRECISION EPS,F(N,N),X,Y(N)      INTEGER N      F(1,1)=0.0D0      F(1,2)=1.0D0      F(1,3)=0.0D0      F(2,1)=0.0D0      F(2,2)=0.0D0      F(2,3)=1.0D0      F(3,1)=-1.0D0*Y(3)      F(3,2)=4.0D0*EPS*Y(2)      F(3,3)=-1.0D0*Y(1)      RETURN      END     
20690`-- SUBROUTINE JACEPS(X,EPS,Y,F,N)      DOUBLE PRECISION EPS,F(N),X,Y(N)      INTEGER N      F(1)=0.0D0      F(2)=0.0D0      F(3)=2.0D0*Y(2)**2-2.0D0      RETURN      END\end{verbatim}
20805`\spadtype{Asp42} produces Fortran for Type 42 ASPs,{} needed for NAG routines \axiomOpFrom{d02raf}{d02Package} and \axiomOpFrom{d02saf}{d02Package} in particular. These ASPs are in fact three Fortran routines which return a vector of functions,{} and their derivatives \spad{wrt} \spad{Y}(\spad{i}) and also a continuation parameter EPS,{} for example:\begin{verbatim}      SUBROUTINE G(EP
20805`--S,YA,YB,BC,N)      DOUBLE PRECISION EPS,YA(N),YB(N),BC(N)      INTEGER N      BC(1)=YA(1)      BC(2)=YA(2)      BC(3)=YB(2)-1.0D0      RETURN      END      SUBROUTINE JACOBG(EPS,YA,YB,AJ,BJ,N)      DOUBLE PRECISION EPS,YA(N),AJ(N,N),BJ(N,N),YB(N)      INTEGER N      AJ(1,1)=1.0D0      AJ(1,2)=0.0D0      AJ(1,3)=0.0D0      AJ(2,1)=0.0D0      AJ(2,2)=1.0D0      AJ(2,3)=0.0D0      AJ(3,1)=0.0D0      AJ(3,2)=0.0D0      AJ(3,3)=0.0D0      BJ(1,1)=0.0D0      BJ(1,2)=0.0D0      
20805`--BJ(1,3)=0.0D0      BJ(2,1)=0.0D0      BJ(2,2)=0.0D0      BJ(2,3)=0.0D0      BJ(3,1)=0.0D0      BJ(3,2)=1.0D0      BJ(3,3)=0.0D0      RETURN      END      SUBROUTINE JACGEP(EPS,YA,YB,BCEP,N)      DOUBLE PRECISION EPS,YA(N),YB(N),BCEP(N)      INTEGER N      BCEP(1)=0.0D0      BCEP(2)=0.0D0      BCEP(3)=0.0D0      RETURN      END\end{verbatim}
20920`\spadtype{Asp49} produces Fortran for Type 49 ASPs,{} needed for NAG routines \axiomOpFrom{e04dgf}{e04Package},{} \axiomOpFrom{e04ucf}{e04Package},{} for example:\begin{verbatim}      SUBROUTINE OBJFUN(MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER)      DOUBLE PRECISION X(N),OBJF,OBJGRD(N),USER(*)      INTEGER N,IUSER(*),MODE,NSTATE      OBJF=X(4)*X(9)+((-1.0D0*X(5))+X(3))*X(8)+((-1.0D0*X(3))+X(1))*X(7)     &+(-1.0D0*X(2)*X(6)) 
20920`--     OBJGRD(1)=X(7)      OBJGRD(2)=-1.0D0*X(6)      OBJGRD(3)=X(8)+(-1.0D0*X(7))      OBJGRD(4)=X(9)      OBJGRD(5)=-1.0D0*X(8)      OBJGRD(6)=-1.0D0*X(2)      OBJGRD(7)=(-1.0D0*X(3))+X(1)      OBJGRD(8)=(-1.0D0*X(5))+X(3)      OBJGRD(9)=X(4)      RETURN      END\end{verbatim}
20994`\spadtype{Asp4} produces Fortran for Type 4 ASPs,{} which take an expression in \spad{X}(1) .. \spad{X}(NDIM) and produce a real function of the form:\begin{verbatim}      DOUBLE PRECISION FUNCTION FUNCTN(NDIM,X)      DOUBLE PRECISION X(NDIM)      INTEGER NDIM      FUNCTN=(4.0D0*X(1)*X(3)**2*DEXP(2.0D0*X(1)*X(3)))/(X(4)**2+(2.0D0*     &X(2)+2.0D0)*X(4)+X(2)**2+2.0D0*X(2)+1.0D0)      RETURN      END\end{verbatim}
21066`\spadtype{Asp50} produces Fortran for Type 50 ASPs,{} needed for NAG routine \axiomOpFrom{e04fdf}{e04Package},{} for example:\begin{verbatim}      SUBROUTINE LSFUN1(M,N,XC,FVECC)      DOUBLE PRECISION FVECC(M),XC(N)      INTEGER I,M,N      FVECC(1)=((XC(1)-2.4D0)*XC(3)+(15.0D0*XC(1)-36.0D0)*XC(2)+1.0D0)/(     &XC(3)+15.0D0*XC(2))      FVECC(2)=((XC(1)-2.8D0)*XC(3)+(7.0D0*XC(1)-19.6D0)*XC(2)+1.0D0)/(X     &C(3)+7.0D
21066`--0*XC(2))      FVECC(3)=((XC(1)-3.2D0)*XC(3)+(4.333333333333333D0*XC(1)-13.866666     &66666667D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))      FVECC(4)=((XC(1)-3.5D0)*XC(3)+(3.0D0*XC(1)-10.5D0)*XC(2)+1.0D0)/(X     &C(3)+3.0D0*XC(2))      FVECC(5)=((XC(1)-3.9D0)*XC(3)+(2.2D0*XC(1)-8.579999999999998D0)*XC     &(2)+1.0D0)/(XC(3)+2.2D0*XC(2))      FVECC(6)=((XC(1)-4.199999999999999D0)*XC(3)+(1.666666666666667D0*X     &C(1)-7.0D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))      
21066`--FVECC(7)=((XC(1)-4.5D0)*XC(3)+(1.285714285714286D0*XC(1)-5.7857142     &85714286D0)*XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))      FVECC(8)=((XC(1)-4.899999999999999D0)*XC(3)+(XC(1)-4.8999999999999     &99D0)*XC(2)+1.0D0)/(XC(3)+XC(2))      FVECC(9)=((XC(1)-4.699999999999999D0)*XC(3)+(XC(1)-4.6999999999999     &99D0)*XC(2)+1.285714285714286D0)/(XC(3)+XC(2))      FVECC(10)=((XC(1)-6.8D0)*XC(3)+(XC(1)-6.8D0)*XC(2)+1.6666666666666     &67D0)/(XC(3)+XC(2))      FVECC(11)=((XC(1)-8.299
21066`--999999999999D0)*XC(3)+(XC(1)-8.299999999999     &999D0)*XC(2)+2.2D0)/(XC(3)+XC(2))      FVECC(12)=((XC(1)-10.6D0)*XC(3)+(XC(1)-10.6D0)*XC(2)+3.0D0)/(XC(3)     &+XC(2))      FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333     &3333D0)/(XC(3)+XC(2))      FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X     &C(2))      FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3     &)+XC(2))      END\end{verbatim}
21146`\spadtype{Asp55} produces Fortran for Type 55 ASPs,{} needed for NAG routines \axiomOpFrom{e04dgf}{e04Package} and \axiomOpFrom{e04ucf}{e04Package},{} for example:\begin{verbatim}      SUBROUTINE CONFUN(MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER     &,USER)      DOUBLE PRECISION C(NCNLN),X(N),CJAC(NROWJ,N),USER(*)      INTEGER N,IUSER(*),NEEDC(NCNLN),NROWJ,MODE,NCNLN,NSTATE      IF(NEEDC(1).GT.0)THEN        C(1)
21146`--=X(6)**2+X(1)**2        CJAC(1,1)=2.0D0*X(1)        CJAC(1,2)=0.0D0        CJAC(1,3)=0.0D0        CJAC(1,4)=0.0D0        CJAC(1,5)=0.0D0        CJAC(1,6)=2.0D0*X(6)      ENDIF      IF(NEEDC(2).GT.0)THEN        C(2)=X(2)**2+(-2.0D0*X(1)*X(2))+X(1)**2        CJAC(2,1)=(-2.0D0*X(2))+2.0D0*X(1)        CJAC(2,2)=2.0D0*X(2)+(-2.0D0*X(1))        CJAC(2,3)=0.0D0        CJAC(2,4)=0.0D0        CJAC(2,5)=0.0D0        CJAC(2,6)=0.0D0      ENDIF      IF(NEEDC(3).GT.0)THEN        C(3)=X(3)
21146`--**2+(-2.0D0*X(1)*X(3))+X(2)**2+X(1)**2        CJAC(3,1)=(-2.0D0*X(3))+2.0D0*X(1)        CJAC(3,2)=2.0D0*X(2)        CJAC(3,3)=2.0D0*X(3)+(-2.0D0*X(1))        CJAC(3,4)=0.0D0        CJAC(3,5)=0.0D0        CJAC(3,6)=0.0D0      ENDIF      RETURN      END\end{verbatim}
21226`\spadtype{Asp6} produces Fortran for Type 6 ASPs,{} needed for NAG routines \axiomOpFrom{c05nbf}{c05Package},{} \axiomOpFrom{c05ncf}{c05Package}. These represent vectors of functions of \spad{X}(\spad{i}) and look like:\begin{verbatim}      SUBROUTINE FCN(N,X,FVEC,IFLAG)      DOUBLE PRECISION X(N),FVEC(N)      INTEGER N,IFLAG      FVEC(1)=(-2.0D0*X(2))+(-2.0D0*X(1)**2)+3.0D0*X(1)+1.0D0      FVEC(2)=(-2.0D0*X(3))+(-2.0D
21226`--0*X(2)**2)+3.0D0*X(2)+(-1.0D0*X(1))+1.     &0D0      FVEC(3)=(-2.0D0*X(4))+(-2.0D0*X(3)**2)+3.0D0*X(3)+(-1.0D0*X(2))+1.     &0D0      FVEC(4)=(-2.0D0*X(5))+(-2.0D0*X(4)**2)+3.0D0*X(4)+(-1.0D0*X(3))+1.     &0D0      FVEC(5)=(-2.0D0*X(6))+(-2.0D0*X(5)**2)+3.0D0*X(5)+(-1.0D0*X(4))+1.     &0D0      FVEC(6)=(-2.0D0*X(7))+(-2.0D0*X(6)**2)+3.0D0*X(6)+(-1.0D0*X(5))+1.     &0D0      FVEC(7)=(-2.0D0*X(8))+(-2.0D0*X(7)**2)+3.0D0*X(7)+(-1.0D0*X(6))+1.     &0D0      FVEC(8)=(-2.0D0*X(9))+(-2.0D
21226`--0*X(8)**2)+3.0D0*X(8)+(-1.0D0*X(7))+1.     &0D0      FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0      RETURN      END\end{verbatim}
21304`\spadtype{Asp73} produces Fortran for Type 73 ASPs,{} needed for NAG routine \axiomOpFrom{d03eef}{d03Package},{} for example:\begin{verbatim}      SUBROUTINE PDEF(X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI)      DOUBLE PRECISION ALPHA,EPSOLN,PHI,X,Y,BETA,DELTA,GAMMA,PSI      ALPHA=DSIN(X)      BETA=Y      GAMMA=X*Y      DELTA=DCOS(X)*DSIN(Y)      EPSOLN=Y+X      PHI=X      PSI=Y      RETURN      END\end{verbati
21304`--m}
21384`\spadtype{Asp74} produces Fortran for Type 74 ASPs,{} needed for NAG routine \axiomOpFrom{d03eef}{d03Package},{} for example:\begin{verbatim}      SUBROUTINE BNDY(X,Y,A,B,C,IBND)      DOUBLE PRECISION A,B,C,X,Y      INTEGER IBND      IF(IBND.EQ.0)THEN        A=0.0D0        B=1.0D0        C=-1.0D0*DSIN(X)      ELSEIF(IBND.EQ.1)THEN        A=1.0D0        B=0.0D0        C=DSIN(X)*DSIN(Y)      ELSEIF(IBND.EQ.2)THE
21384`--N        A=1.0D0        B=0.0D0        C=DSIN(X)*DSIN(Y)      ELSEIF(IBND.EQ.3)THEN        A=0.0D0        B=1.0D0        C=-1.0D0*DSIN(Y)      ENDIF      END\end{verbatim}
21464`\spadtype{Asp77} produces Fortran for Type 77 ASPs,{} needed for NAG routine \axiomOpFrom{d02gbf}{d02Package},{} for example:\begin{verbatim}      SUBROUTINE FCNF(X,F)      DOUBLE PRECISION X      DOUBLE PRECISION F(2,2)      F(1,1)=0.0D0      F(1,2)=1.0D0      F(2,1)=0.0D0      F(2,2)=-10.0D0      RETURN      END\end{verbatim}
21544`\spadtype{Asp78} produces Fortran for Type 78 ASPs,{} needed for NAG routine \axiomOpFrom{d02gbf}{d02Package},{} for example:\begin{verbatim}      SUBROUTINE FCNG(X,G)      DOUBLE PRECISION G(*),X      G(1)=0.0D0      G(2)=0.0D0      END\end{verbatim}
21624`\spadtype{Asp7} produces Fortran for Type 7 ASPs,{} needed for NAG routines \axiomOpFrom{d02bbf}{d02Package},{} \axiomOpFrom{d02gaf}{d02Package}. These represent a vector of functions of the scalar \spad{X} and the array \spad{Z},{} and look like:\begin{verbatim}      SUBROUTINE FCN(X,Z,F)      DOUBLE PRECISION F(*),X,Z(*)      F(1)=DTAN(Z(3))      F(2)=((-0.03199999999999999D0*DCOS(Z(3))*DTAN(Z(3)))+(-0.02D0*Z(2)     
21624`--&**2))/(Z(2)*DCOS(Z(3)))      F(3)=-0.03199999999999999D0/(X*Z(2)**2)      RETURN      END\end{verbatim}
21702`\spadtype{Asp80} produces Fortran for Type 80 ASPs,{} needed for NAG routine \axiomOpFrom{d02kef}{d02Package},{} for example:\begin{verbatim}      SUBROUTINE BDYVAL(XL,XR,ELAM,YL,YR)      DOUBLE PRECISION ELAM,XL,YL(3),XR,YR(3)      YL(1)=XL      YL(2)=2.0D0      YR(1)=1.0D0      YR(2)=-1.0D0*DSQRT(XR+(-1.0D0*ELAM))      RETURN      END\end{verbatim}
21782`\spadtype{Asp8} produces Fortran for Type 8 ASPs,{} needed for NAG routine \axiomOpFrom{d02bbf}{d02Package}. This ASP prints intermediate values of the computed solution of an ODE and might look like:\begin{verbatim}      SUBROUTINE OUTPUT(XSOL,Y,COUNT,M,N,RESULT,FORWRD)      DOUBLE PRECISION Y(N),RESULT(M,N),XSOL      INTEGER M,N,COUNT      LOGICAL FORWRD      DOUBLE PRECISION X02ALF,POINTS(8)      EXTERNAL X02ALF      INTEGER I    
21782`--  POINTS(1)=1.0D0      POINTS(2)=2.0D0      POINTS(3)=3.0D0      POINTS(4)=4.0D0      POINTS(5)=5.0D0      POINTS(6)=6.0D0      POINTS(7)=7.0D0      POINTS(8)=8.0D0      COUNT=COUNT+1      DO 25001 I=1,N        RESULT(COUNT,I)=Y(I)25001 CONTINUE      IF(COUNT.EQ.M)THEN        IF(FORWRD)THEN          XSOL=X02ALF()        ELSE          XSOL=-X02ALF()        ENDIF      ELSE        XSOL=POINTS(COUNT)      ENDIF      END\end{verbatim}
21842`\spadtype{Asp9} produces Fortran for Type 9 ASPs,{} needed for NAG routines \axiomOpFrom{d02bhf}{d02Package},{} \axiomOpFrom{d02cjf}{d02Package},{} \axiomOpFrom{d02ejf}{d02Package}. These ASPs represent a function of a scalar \spad{X} and a vector \spad{Y},{} for example:\begin{verbatim}      DOUBLE PRECISION FUNCTION G(X,Y)      DOUBLE PRECISION X,Y(*)      G=X+Y(1)      RETURN      END\end{verbatim} If the user provides 
21842`--a constant value for \spad{G},{} then extra information is added via COMMON blocks used by certain routines. This specifies that the value returned by \spad{G} in this case is to be ignored.
21914`\indented{1}{AssociatedJordanAlgebra takes an algebra \spad{A} and uses \spadfun{*\$A}} \indented{1}{to define the new multiplications \spad{a*b := (a *\$A b + b *\$A a)/2}} \indented{1}{(anticommutator).} \indented{1}{The usual notation \spad{{a,{}b}_+} cannot be used due to} \indented{1}{restrictions in the current language.} \indented{1}{This domain only gives a Jordan 
21914`--algebra if the} \indented{1}{Jordan-identity \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds} \indented{1}{for all \spad{a},{}\spad{b},{}\spad{c} in \spad{A}.} \indented{1}{This relation can be checked by} \indented{1}{\spadfun{jordanAdmissible?()\$A}.} \blankline If the underlying algebra is of type \spadtype{FramedNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank,{} together with a fixed \spad{R}-module basis),{} 
21914`--then the same is \spad{true} for the associated Jordan algebra. Moreover,{} if the underlying algebra is of type \spadtype{FiniteRankNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank),{} then the same \spad{true} for the associated Jordan algebra.
22045`AssociatedLieAlgebra takes an algebra \spad{A} and uses \spadfun{*\$A} to define the Lie bracket \spad{a*b := (a *\$A b - b *\$A a)} (commutator). Note that the notation \spad{[a,{}b]} cannot be used due to restrictions of the current compiler. This domain only gives a Lie algebra if the Jacobi-identity \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} holds for all \spad{a},{}\spad{b},{}\
22045`--spad{c} in \spad{A}. This relation can be checked by \spad{lieAdmissible?()\$A}. \blankline If the underlying algebra is of type \spadtype{FramedNonAssociativeAlgebra(R)} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank,{} together with a fixed \spad{R}-module basis),{} then the same is \spad{true} for the associated Lie algebra. Also,{} if the underlying algebra is of type \spadtype{FiniteRankNonAssociativeAlgebra(R)} (\spadignore{i.e.}
22045`-- a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank),{} then the same is \spad{true} for the associated Lie algebra.
22339`Automorphism \spad{R} is the multiplicative group of automorphisms of \spad{R}.
22483`Stream-based implementation of \spad{Zp:} \spad{p}-adic numbers are represented as sum(\spad{i} = 0..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in -(\spad{p} - 1)\spad{/2},{}...,{}(\spad{p} - 1)\spad{/2}.
22561`Stream-based implementation of \spad{Qp:} numbers are represented as sum(\spad{i} = \spad{k}..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in -(\spad{p} - 1)\spad{/2},{}...,{}(\spad{p} - 1)\spad{/2}.
22731`A basic operator is an object that can be applied to a list of arguments from a set,{} the result being a kernel over that set.
22786`This domain allows rational numbers to be presented as repeating binary expansions.
22866`This domain provides an implementation of binary files. Data is accessed one byte at a time as a small integer.
23185`\spadtype{Bits} provides logical functions for Indexed Bits.
23234`\indented{1}{\spadtype{Boolean} is the elementary logic with 2 values:} \spad{true} and \spad{false}
23287`Members of the domain CardinalNumber are values indicating the cardinality of sets,{} both finite and infinite. Arithmetic operations are defined on cardinal numbers as follows. \blankline If \spad{x = \#X} and \spad{y = \#Y} then \indented{2}{\spad{x+y\space{2}= \#(X+Y)}\space{3}\tab{30}disjoint union} \indented{2}{\spad{x-y\space{2}= \#(X-Y)}\space{3}\tab{30}relative complement} \indented{2}{\spad{x*y\space{2}= \#(X*Y)}\space{3}\tab{30}cartesi
23287`--an product} \indented{2}{\spad{x**y = \#(X**Y)}\space{2}\tab{30}\spad{X**Y = \{g| g:Y->X\}}} \blankline The non-negative integers have a natural construction as cardinals \indented{2}{\spad{0 = \#\{\}},{} \spad{1 = \{0\}},{} \spad{2 = \{0,{} 1\}},{} ...,{} \spad{n = \{i| 0 <= i < n\}}.} \blankline That \spad{0} acts as a zero for the multiplication of cardinals is equivalent to the axiom of choice. \blankline The generalized continuum hypothesis asserts \center{\spad{2**Aleph i = Aleph(i+1)}} 
23287`--and is independent of the axioms of set theory [Goedel 1940]. \blankline Three commonly encountered cardinal numbers are \indented{3}{\spad{a = \#Z}\space{7}\tab{30}countable infinity} \indented{3}{\spad{c = \#R}\space{7}\tab{30}the continuum} \indented{3}{\spad{f = \#\{g| g:[0,{}1]->R\}}} \blankline In this domain,{} these values are obtained using \indented{3}{\spad{a := Aleph 0},{} \spad{c := 2**a},{} \spad{f := 2**c}.} \blankline
23344`CartesianTensor(minix,{}dim,{}\spad{R}) provides Cartesian tensors with components belonging to a commutative ring \spad{R}. These tensors can have any number of indices. Each index takes values from \spad{minix} to \spad{minix + dim - 1}.
23597`CliffordAlgebra(\spad{n},{} \spad{K},{} \spad{Q}) defines a vector space of dimension \spad{2**n} over \spad{K},{} given a quadratic form \spad{Q} on \spad{K**n}. \blankline If \spad{e[i]},{} \spad{1<=i<=n} is a basis for \spad{K**n} then \indented{3}{1,{} \spad{e[i]} (\spad{1<=i<=n}),{} \spad{e[i1]*e[i2]} (\spad{1<=i1<i2<=n}),{}...,{}\spad{e[1]*e[2]*..*e[n]}} is a basis for the Clifford Algebra. \bl
23597`--ankline The algebra is defined by the relations \indented{3}{\spad{e[i]*e[j] = -e[j]*e[i]}\space{2}(\spad{i \~~= j}),{}} \indented{3}{\spad{e[i]*e[i] = Q(e[i])}} \blankline Examples of Clifford Algebras are: gaussians,{} quaternions,{} exterior algebras and spin algebras.
23751`A type for basic commutators
23880`\spadtype{ContinuedFraction} implements general \indented{1}{continued fractions.\space{2}This version is not restricted to simple,{}} \indented{1}{finite fractions and uses the \spadtype{Stream} as a} \indented{1}{representation.\space{2}The arithmetic functions assume that the} \indented{1}{approximants alternate below/above the convergence point.} \indented{1}{This is enforced by ensuring the partial numerators and pa
23880`--rtial} \indented{1}{denominators are greater than 0 in the Euclidean domain view of \spad{R}} \indented{1}{(\spadignore{i.e.} \spad{sizeLess?(0,{} x)}).}
23962`This domain provides some nice functions on lists
24033`\indented{1}{This domain implements a simple view of a database whose fields are} indexed by symbols
24109`The deRham complex of Euclidean space,{} that is,{} the class of differential forms of arbitary degree over a coefficient ring. See Flanders,{} Harley,{} Differential Forms,{} With Applications to the Physical Sciences,{} New York,{} Academic Press,{} 1963.
24238`This domain allows rational numbers to be presented as repeating decimal expansions.
24576`This constructor provides a direct product type with a left matrix-module view.
24775`This constructor provides a direct product of \spad{R}-modules with an \spad{R}-module view.
25279`\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the corresponding functions on the Taylor series domain. We
25279`-- also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return "failed" when this is not possible.
25533`\indented{1}{This package provides elementary functions on any Laurent series} domain over a field which was constructed from a Taylor series domain. These functions are implemented by calling the correspo
25533`--nding functions on the Taylor series domain. We also provide 'partial functions' which compute transcendental functions of Laurent series when possible and return "failed" when this is not possible.
25834`\spad{Enumeration(a,b,...,c)} is a primitive type in AXIOM used to represent the object composed of the symbols \spad{a},\spad{b},..., and \spad{c}.
25882`This domain provides tables where the keys are compared using \spadfun{eq?}. Thus keys are considered equal only if they are the same instance of a structure.
25988`Equations as mathematical objects. All properties of the basis domain,{} \spadignore{e.g.} being an abelian group are carried over the equation domain,{} by performing the structural operations on the left and on the right hand side.
26038`These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{ModularRing},{} \spadtype{ModularField}
26279`A function which does not return directly to its caller should have Exit as its return type. \blankline Note: It is convenient to have a formal \spad{coerce} into each type from type Exit. This allows,{} for example,{} errors to be raised in one half of a type-balanced \spad{if}.
26317`UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent essential singularities of functions. Objects in this domain are quotients of sums,{} where each term in the sum is a univariate Puiseux series times the exponential of a univariate Puiseux s
26317`--eries.
26552`ExponentialOfUnivariatePuiseuxSeries is a domain used to represent essential singularities of functions. An object in this domain is a function of the form \spad{exp(f(x))},{} where \spad{f(x)} is a Puiseux series with no terms of non-negative degree. Objects are ordered according to order of singularity,{} with functions which tend more rapidly to 
26552`--zero or infinity considered to be larger. Thus,{} if \spad{order(f(x)) < order(g(x))},{} \spadignore{i.e.} the first non-zero term of \spad{f(x)} has lower degree than the first non-zero term of \spad{g(x)},{} then \spad{exp(f(x)) > exp(g(x))}. If \spad{order(f(x)) = order(g(x))},{} then the ordering is essentially random. This domain is used in computing limits involving functions with essential singularities.
26707`Expressions involving symbolic functions.
26779`A domain used in the construction of the exterior algebra on a set \spad{X} over a ring \spad{R}. This domain represents the set of all ordered subsets of the set \spad{X},{} assumed to be in correspondance with {1,{}2,{}3,{} ...}. The ordered subsets are themselves ordered lexicographically and are in bijective correspondance with an ordered basis of the exterior algebra. In this domain we are dealing strictly with the exponents of basis elements w
26779`--hich can only be 0 or 1. \blankline The multiplicative identity element of the exterior algebra corresponds to the empty subset of \spad{X}. A coerce from List Integer to an ordered basis element is provided to allow the convenient input of expressions. Another exported function forgets the ordered structure and simply returns the list corresponding to an ordered subset.
26832`\spadtype{Factored} creates a domain whose objects are kept in factored form as long as possible. Thus certain operations like multiplication and \spad{gcd} are relatively easy to do. Others,{} like addition require somewhat more work,{} and unless the argument domain provides a factor function,{} the result may not be completely factored. Each object consists of a unit and a list of factors,{} where a factor has a member of \spad{R
26832`--} (the "base"),{} and exponent and a flag indicating what is known about the base. A flag may be one of "nil",{} "sqfr",{} "irred" or "prime",{} which respectively mean that nothing is known about the base,{} it is square-free,{} it is irreducible,{} or it is prime. The current restriction to integral domains allows simplification to be performed without worrying about multiplication order.
26902`This domain provides an interface to names in the file system.
26950`This domain provides a basic model of files to save arbitrary values. The operations provide sequential access to the contents.
27025`This domains implements finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{'s} are integers and the \spad{P}\spad{'s} are finite rational points on the curve.
27243`FiniteFieldCyclicGroupExtensionByPolynomial(\spad{GF},{}defpol) implements a finite extension field of the ground field {\em GF}. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial {
27243`--\em defpol},{} which MUST be primitive (user responsibility). Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.
27417`FiniteFieldCyclicGroupExtension(\spad{GF},{}\spad{n}) implements a extension of degree \spad{n} over the ground field {\em GF}. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by {\em creat
27417`--ePrimitivePoly} from \spadtype{FiniteFieldPolynomialPackage}. Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.
27561`FiniteFieldCyclicGroup(\spad{p},{}\spad{n}) implements a finite field extension of degee \spad{n} over the prime field with \spad{p} elements. Its elements are represented by powers of a primitive element,{} \spadignore{i.e.} a generator of the multiplicative (cyclic) group. As primitive element we choose the root of the extension polynomial,{} which is created by
27561`-- {\em createPrimitivePoly} from \spadtype{FiniteFieldPolynomialPackage}. The Zech logarithms are stored in a table of size half of the field size,{} and use \spadtype{SingleInteger} for representing field elements,{} hence,{} there are restrictions on the size of the field.
27701`FiniteFieldExtensionByPolynomial(\spad{GF},{} defpol) implements the extension of the finite field {\em GF} generated by the extension polynomial {\em defpol} which MUST be irreducible. Note: the user has the responsibility to ensure that {\em defpol} is irreducible.
27852`FiniteFieldExtensionByPolynomial(\spad{GF},{} \spad{n}) implements an extension of the finite field {\em GF} of degree \spad{n} generated by the extension polynomial constructed by \spadfunFrom{createIrreduciblePoly}{FiniteFieldPolynomialPackage} from \spadtype{FiniteFieldPolynomialPackage}.
27968`FiniteFieldNormalBasisExtensionByPolynomial(\spad{GF},{}uni) implements a finite extension of the ground field {\em GF}. The elements are represented by coordinate vectors with respect to. a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-power
27968`--s) of an element,{} in this case called normal element,{} where \spad{q} is the size of {\em GF}. The normal element is chosen as a root of the extension polynomial,{} which MUST be normal over {\em GF} (user responsibility)
28197`FiniteFieldNormalBasisExtensionByPolynomial(\spad{GF},{}\spad{n}) implements a finite extension field of degree \spad{n} over the ground field {\em GF}. The elements are represented by coordinate vectors with respect to a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-powers) of an element,{} in this case called normal element
28197`--. This is chosen as a root of the extension polynomial,{} created by {\em createNormalPoly} from \spadtype{FiniteFieldPolynomialPackage}
28341`FiniteFieldNormalBasis(\spad{p},{}\spad{n}) implements a finite extension field of degree \spad{n} over the prime field with \spad{p} elements. The elements are represented by coordinate vectors with respect to a normal basis,{} \spadignore{i.e.} a basis consisting of the conjugates (\spad{q}-powers) of an element,{} in this case called normal element. This is cho
28341`--sen as a root of the extension polynomial created by \spadfunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}.
28481`FiniteField(\spad{p},{}\spad{n}) implements finite fields with p**n elements. This packages checks that \spad{p} is prime. For a non-checking version,{} see \spadtype{InnerFiniteField}.
28675`\spadtype{Float} implements arbitrary precision floating point arithmetic. The number of significant digits of each operation can be set to an arbitrary value (the default is 20 decimal digits). The operation \spad{float(mantissa,{}exponent,{}\spadfunFrom{base}{FloatingPointSystem})} for integer \spad{mantissa},{} \spad{exponent} specifies the number \spad{mantissa * \spadfunFrom{base}{FloatingPointSystem} ** exponent} The underlying representa
28675`--tion for floats is binary not decimal. The implications of this are described below. \blankline The model adopted is that arithmetic operations are rounded to to nearest unit in the last place,{} that is,{} accurate to within \spad{2**(-\spadfunFrom{bits}{FloatingPointSystem})}. Also,{} the elementary functions and constants are accurate to one unit in the last place. A float is represented as a record of two integers,{} the mantissa and the exponent. The \spadfunFrom{base}{FloatingPointSystem
28675`--} of the representation is binary,{} hence a \spad{Record(m:mantissa,{}e:exponent)} represents the number \spad{m * 2 ** e}. Though it is not assumed that the underlying integers are represented with a binary \spadfunFrom{base}{FloatingPointSystem},{} the code will be most efficient when this is the the case (this is \spad{true} in most implementations of Lisp). The decision to choose the \spadfunFrom{base}{FloatingPointSystem} to be binary has some unfortunate consequences. First,{} decimal n
28675`--umbers like 0.3 cannot be represented exactly. Second,{} there is a further loss of accuracy during conversion to decimal for output. To compensate for this,{} if \spad{d} digits of precision are specified,{} \spad{1 + ceiling(log2 d)} bits are used. Two numbers that are displayed identically may therefore be not equal. On the other hand,{} a significant efficiency loss would be incurred if we chose to use a decimal \spadfunFrom{base}{FloatingPointSystem} when the underlying integer base is bi
28675`--nary. \blankline Algorithms used: For the elementary functions,{} the general approach is to apply identities so that the taylor series can be used,{} and,{} so that it will converge within \spad{O( sqrt n )} steps. For example,{} using the identity \spad{exp(x) = exp(x/2)**2},{} we can compute \spad{exp(1/3)} to \spad{n} digits of precision as follows. We have \spad{exp(1/3) = exp(2 ** (-sqrt s) / 3) ** (2 ** sqrt s)}. The taylor series will converge in less than sqrt \spad{n} steps and the e
28675`--xponentiation requires sqrt \spad{n} multiplications for a total of \spad{2 sqrt n} multiplications. Assuming integer multiplication costs \spad{O( n**2 )} the overall running time is \spad{O( sqrt(n) n**2 )}. This approach is the best known approach for precisions up to about 10,{}000 digits at which point the methods of Brent which are \spad{O( log(n) n**2 )} become competitive. Note also that summing the terms of the taylor series for the elementary functions is done using integer operation
28675`--s. This avoids the overhead of floating point operations and results in efficient code at low precisions. This implementation makes no attempt to reuse storage,{} relying on the underlying system to do \spadgloss{garbage collection}. \spad{I} estimate that the efficiency of this package at low precisions could be improved by a factor of 2 if in-place operations were available. \blankline Running times: in the following,{} \spad{n} is the number of bits of precision \indented{5}{\spad{*},{} \sp
28675`--ad{/},{} \spad{sqrt},{} \spad{\spad{pi}},{} \spad{exp1},{} \spad{log2},{} \spad{log10}: \spad{ O( n**2 )}} \indented{5}{\spad{exp},{} \spad{log},{} \spad{sin},{} \spad{atan}:\space{2}\spad{ O( sqrt(n) n**2 )}} The other elementary functions are coded in terms of the ones above.
28733`This domain builds representations of program code segments for use with the FortranProgram domain.
28786`A domain of expressions involving functions which can be translated into standard Fortran-77,{} with some extra extensions from the NAG Fortran Library.
28941`\axiomType{FortranProgram} allows the user to build and manipulate simple models of FORTRAN subprograms. These can then be transformed into actual FORTRAN notation.
29120`Creates and manipulates objects which correspond to the basic FORTRAN data types: REAL,{} INTEGER,{} COMPLEX,{} LOGICAL and CHARACTER
29192`Code to manipulate Fortran templates
29269`Creates and manipulates objects which correspond to FORTRAN data types,{} including array dimensions.
29322`\indented{1}{Author: James Davenport} Date Created: 17 April 1992 Date Last Updated: 12 June 1992 Basic Functions: Related Constructors: Also See: AMS Classifications: Keywords: References: Description:
29395`\indented{1}{Author: James Davenport} Date Created: 17 April 1992 Date Last Updated: Basic Functions: Related Constructors: Also See: AMS Classifications: Keywords: References: Description:
29507`Fraction takes an IntegralDomain \spad{S} and produces the domain of Fractions with numerators and denominators from \spad{S}. If \spad{S} is also a GcdDomain,{} then \spad{gcd}\spad{'s} between numerator and denominator will be cancelled during all operations.
29589`Fractional ideals in a framed algebra.
29766`Module representation of fractional ideals.
29946`The free abelian group on a set \spad{S} is the monoid of finite sums of the form \spad{reduce(+,{}[\spad{ni} * \spad{si}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are integers. The operation is commutative.
30024`The free abelian monoid on a set \spad{S} is the monoid of finite sums of the form \spad{reduce(+,{}[\spad{ni} * \spad{si}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are non-negative integers. The operation is commutative.
30129`The free group on a set \spad{S} is the group of finite products of the form \spad{reduce(*,{}[\spad{si} ** \spad{ni}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are integers. The multiplication is not commutative.
30192`This domain implements linear combinations of elements from the domain \spad{S} with coefficients in the domain \spad{R} where \spad{S} is an ordered set and \spad{R} is a ring (which may be non-commutative). This domain is used by domains of non-commutative algebra such as: \indented{4}{\spadtype{XDistributedPolynomial},{}} \indented{4}{\spadtype{XRecursivePolynomial}.} Author: Michel Petitot (petitot@lifl.\spad{fr})
30275`A \spad{bi}-module is a free module over a ring with generators indexed by an ordered set. Each element can be expressed as a finite linear combination of generators. Only non-zero terms are stored.
30351`The free monoid on a set \spad{S} is the monoid of finite products of the form \spad{reduce(*,{}[\spad{si} ** \spad{ni}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are nonnegative integers. The multiplication is not commutative.
30417`Generate the Free Lie Algebra over a ring \spad{R} with identity; A \spad{P}. Hall basis is generated by a package call to HallBasis.
30556`\indented{1}{Full partial fraction expansion of rational functions} Author: Manuel Bronstein Date Created: 9 December 1992 Date Last Updated: 6 October 1993 References: \spad{M}.Bronstein & \spad{B}.Salvy,{} \indented{12}{Full Partial Fraction Decomposition of Rational Functions,{}} \indented{12}{in Proceedings of \spad{ISSAC'93},{} Kiev,{} ACM Press.}
30690`This domain implements named functions
30761`\indented{2}{This type supports distributed multivariate polynomials} whose variables are from a user specified list of symbols. The coefficient ring may be non commutative,{} but the variables are assumed to commute. The term ordering is specified by its third parameter. Suggested types which define term
30761`-- orderings include: \spadtype{DirectProduct},{} \spadtype{HomogeneousDirectProduct},{} \spadtype{SplitHomogeneousDirectProduct} and finally \spadtype{OrderedDirectProduct} which accepts an arbitrary user function to define a term ordering.
30961`This package \undocumented
31262`A domain for polynomial sets.
31459`A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key.
31611`A domain constructor of the category \axiomType{TriangularSetCategory}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. Triangular sets 
31611`--are stored as sorted lists \spad{w}.\spad{r}.\spad{t}. the main variables of their members but they are displayed in reverse order.\newline References : \indented{1}{[1] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZA "On the Theories} \indented{5}{of Triangular Sets" Journal of Symbol. Comp. (to appear)}
31786`This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{}f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x\^r)}.
31930`AlgebraGenericElementPackage allows you to create generic elements of an algebra,{} \spadignore{i.e.} the scalars are extended to include symbolic coefficients
32179`This domain provides access to the underlying Lisp hash tables. By varying the hashfn parameter,{} tables suited for different purposes can be obtained.
32374`This domain allows rational numbers to be presented as repeating hexadecimal expansions.
32460`\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered first by the sum of their components,{} and then refined using a reverse lexicographic ordering. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.
32779`This domains implements finite rational divisors on an hyperelliptic curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{'s} are integers and the \spad{P}\spad{'s} are finite rational points on the curve. The equation of the curve must be \spad{y^2
32779`--} = \spad{f}(\spad{x}) and \spad{f} must have odd degree.
33004`\indented{1}{This domain implements a container of information} about the AXIOM library
33057`\spadtype{IndexedBits} is a domain to compactly represent large quantities of Boolean data.
33125`\indented{1}{Indexed direct products of abelian groups over an abelian group \spad{A} of} generators indexed by the ordered set \spad{S}. All items have finite support: only non-zero terms are stored.
33233`\indented{1}{Indexed direct products of abelian monoids over an abelian monoid \spad{A} of} generators indexed by the ordered set \spad{S}. All items have finite support. Only non-zero terms are stored.
33344`\indented{1}{Indexed direct products of objects over a set \spad{A}} of generators indexed by an ordered set \spad{S}. All items have finite support.
33456`\indented{1}{Indexed direct products of ordered abelian monoid sups \spad{A},{}} generators indexed by the ordered set \spad{S}. All items have finite support: only non-zero terms are stored.
33600`\indented{1}{Indexed direct products of ordered abelian monoids \spad{A} of} generators indexed by the ordered set \spad{S}. The inherited order is lexicographical. All items have finite support: only non-zero terms are stored.
33734`converts entire exponents to OutputForm
33825`\indented{1}{Author: Michael Monagan \spad{July/87},{} modified \spad{SMW} \spad{June/91}} A FlexibleArray is the notion of an array intended to allow for growth at the end only. Hence the following efficient operations \indented{2}{\spad{append(x,{}a)} meaning append item \spad{x} at the end of the array \spad{a}} \indented{2}{\spad{delete(a,{}n)} meaning delete the last item from the array \spad{
33825`--a}} Flexible arrays support the other operations inherited from \spadtype{ExtensibleLinearAggregate}. However,{} these are not efficient. Flexible arrays combine the \spad{O(1)} access time property of arrays with growing and shrinking at the end in \spad{O(1)} (average) time. This is done by using an ordinary array which may have zero or more empty slots at the end. When the array becomes full it is copied into a new larger (50\% larger) array. Conversely,{} when the array becomes less than 1
33825`--/2 full,{} it is copied into a smaller array. Flexible arrays provide for an efficient implementation of many data structures in particular heaps,{} stacks and sets.
33996`An \spad{IndexedMatrix} is a matrix where the minimal row and column indices are parameters of the type. The domains Row and Col are both IndexedVectors. The index of the 'first' row may be obtained by calling the function \spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \spadfun{minColIndex}. The index of the
33996`-- first element of a 'Row' is the same as the index of the first column in a matrix and vice versa.
34146`\indented{1}{Author Micheal Monagan \spad{Aug/87}} This is the basic one dimensional array data type.
34319`\indented{1}{An IndexedTwoDimensionalArray is a 2-dimensional array where} the minimal row and column indices are parameters of the type. Rows and columns are returned as IndexedOneDimensionalArray\spad{'s} with minimal indices matching those of the IndexedTwoDimensionalArray. The index of the 'first' ro
34319`--w may be obtained by calling the function 'minRowIndex'. The index of the 'first' column may be obtained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa.
34591`\indented{1}{This package implements 'infinite tuples' for the interpreter.} The representation is a stream.
34670`Algebraic closure of the rational numbers.
34738`InnerFiniteField(\spad{p},{}\spad{n}) implements finite fields with \spad{p**n} elements where \spad{p} is assumed prime but does not check. For a version which checks that \spad{p} is prime,{} see \spadtype{FiniteField}.
34862`Internal implementation of a free abelian monoid.
34989`\indented{1}{This is an internal type which provides an implementation of} 2-dimensional arrays as PrimitiveArray\spad{'s} of PrimitiveArray\spad{'s}.
35189`This domain implements \spad{Zp},{} the \spad{p}-adic completion of the integers. This is an internal domain.
35285`InnerPrimeField(\spad{p}) implements the field with \spad{p} elements. Note: argument \spad{p} MUST be a prime (this domain does not check). See \spadtype{PrimeField} for a domain that does check.
35370`InnerSparseUnivariatePowerSeries is an internal domain \indented{2}{used for creating sparse Taylor and Laurent series.}
35490`This domain is used to provide a conditional "add" domain for the implementation of \spadtype{Table}.
35648`Internal package for dense Taylor series. This is an internal Taylor series type in which Taylor series are represented by a \spadtype{Stream} of \spadtype{Ring} elements. For univariate series,{} the \spad{Stream} elements are the Taylor coefficients. For multivariate series,{} the \spad{n}th Stream element is a form of degree \spad{n} in the power series variables.
35716`Domain of parsed forms which can be passed to the interpreter. This is also the interface between algebra code and facilities in the interpreter.
35826`IntegerMod(\spad{n}) creates the ring of integers reduced modulo the integer \spad{n}.
35903`\spadtype{Integer} provides the domain of arbitrary precision integers.
36012`If a function \spad{f} has an elementary integral \spad{g},{} then \spad{g} can be written in the form \spad{g = h + c1 log(u1) + c2 log(u2) + ... + cn log(un)} where \spad{h},{} which is in the same field than \spad{f},{} is called the rational part of the integral,{} and \spad{c1 log(u1) + ... cn log(un)} is called the logarithmic part of the integral. This domain manipulates integrals represented in that form,{} by kee
36012`--ping both parts separately. The logs are not explicitly computed.
36094`\indented{1}{+ Author: Mike Dewar} + Date Created: November 1996 + Date Last Updated: + Basic Functions: + Related Constructors: + Also See: + AMS Classifications: + Keywords: + References: + Description: + This domain is an implementation of interval arithmetic and transcendental + functions over intervals.
36179`A kernel over a set \spad{S} is an operator applied to a given list of arguments from \spad{S}.
36245`This domain allows a random access file to be viewed both as a table and as a file object.
36367`\indented{1}{Univariate polynomials with negative and positive exponents.} Author: Manuel Bronstein Date Created: May 1988 Date Last Updated: 26 Apr 1990
36502`This domain provides a simple way to save values in files.
36568`Management of the Lie Group associated with a free nilpotent Lie algebra. Every Lie bracket with length greater than \axiom{Order} are assumed to be null. The implementation inherits from the \spadtype{XPBWPolynomial} domain constructor: Lyndon coordinates are exponential coordinates of the second kind. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
36692`This type supports Lie polynomials in Lyndon basis see Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
36802`LieSquareMatrix(\spad{n},{}\spad{R}) implements the Lie algebra of the \spad{n} by \spad{n} matrices over the commutative ring \spad{R}. The Lie bracket (commutator) of the algebra is given by \spad{a*b := (a *\$SQMATRIX(n,{}R) b - b *\$SQMATRIX(n,{}R) a)},{} where \spadfun{*\$SQMATRIX(\spad{n},{}\spad{R})} is the usual matrix multiplication.
36952`\spad{LinearOrdinaryDifferentialOperator1} defines a ring of differential operators with coefficients in a differential ring A. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}
37076`\spad{LinearOrdinaryDifferentialOperator2} defines a ring of differential operators with coefficients in a differential ring A and acting on an A-module \spad{M}. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}
37240`\spad{LinearOrdinaryDifferentialOperator} defines a ring of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}
37364`This internal package represents monoid (abelian or not,{} with or without inverses) as lists and provides some common operations to the various flavors of monoids.
37598`LocalAlgebra produces the localization of an algebra,{} \spadignore{i.e.} fractions whose numerators come from some \spad{R} algebra.
37714`Localize(\spad{M},{}\spad{R},{}\spad{S}) produces fractions with numerators from an \spad{R} module \spad{M} and denominators from some multiplicative subset \spad{D} of \spad{R}.
37824`Lyndon words over arbitrary (ordered) symbols: see Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). A Lyndon word is a word which is smaller than any of its right factors \spad{w}.\spad{r}.\spad{t}. the pure lexicographical ordering. If \axiom{a} and \axiom{\spad{b}} are two Lyndon words such that \axiom{a < \spad{b}} holds \spad{w}.\spad{r}.\spad{t} lexicographical ordering then \axiom{a*b} is a Lyndon wor
37824`--d. Parenthesized Lyndon words can be generated from symbols by using the following rule: \axiom{[[a,{}\spad{b}],{}\spad{c}]} is a Lyndon word iff \axiom{a*b < \spad{c} \spad{<=} \spad{b}} holds. Lyndon words are internally represented by binary trees using the \spadtype{Magma} domain constructor. Two ordering are provided: lexicographic and length-lexicographic. \newline Author : Michel Petitot (petitot@lifl.\spad{fr}).
37897`A domain which models the complex number representation used by machines in the AXIOM-NAG link.
37973`A domain which models the floating point representation used by machines in the AXIOM-NAG link.
38040`A domain which models the integer representation used by machines in the AXIOM-NAG link.
38114`This type is the basic representation of parenthesized words (binary trees over arbitrary symbols) useful in \spadtype{LiePolynomial}. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
38182`MakeCachableSet(\spad{S}) returns a cachable set which is equal to \spad{S} as a set.
38259`\spad{Mapping(T,S)} is a primitive type in AXIOM used to represent mappings from source type \spad{S} to target type \spad{T}. Similarly, \spad{Mapping(T,A,B)} denotes a mapping from source type \spad{(A,B)} to target type \spad{T}.
38301`\spadtype{Matrix} is a matrix domain where 1-based indexing is used for both rows and columns.
38387`This package \undocumented
38511`\indented{1}{These domains are used for the factorization and gcds} of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{ModularRing},{} \spadtype{EuclideanModularRing}
38704`These domains are used for the factorization and gcds of univariate polynomials over the integers in order to work modulo different primes. See \spadtype{EuclideanModularRing} ,{}\spadtype{ModularField}
38894`This package \undocumented
39059`Algebra of ADDITIVE operators on a module.
39139`\indented{1}{MoebiusTransform(\spad{F}) is the domain of fractional linear (Moebius)} transformations over \spad{F}.
39205`\spadtype{MonoidRing}(\spad{R},{}\spad{M}),{} implements the algebra of all maps from the monoid \spad{M} to the commutative ring \spad{R} with finite support. Multiplication of two maps \spad{f} and \spad{g} is defined to map an element \spad{c} of \spad{M} to the (convolution) sum over {\em f(a)g(b)} such that {\em ab = c}. Thus \spad{M} can be identified with a canonical basis and the maps can also be considered as formal linear comb
39205`--inations of the elements in \spad{M}. Scalar multiples of a basis element are called monomials. A prominent example is the class of polynomials where the monoid is a direct product of the natural numbers with pointwise addition. When \spad{M} is \spadtype{FreeMonoid Symbol},{} one gets polynomials in infinitely many non-commuting variables. Another application area is representation theory of finite groups \spad{G},{} where modules over \spadtype{MonoidRing}(\spad{R},{}\spad{G}) are studied.
39272`A multiset is a set with multiplicities.
39348`\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are from a user specified list of symbols. The ordering is specified by the position of the variable in the list. The coefficient ring may be non commutative,{} but the variables are assumed to commute.
39507`A post-facto extension for \axiomType{\spad{SMP}} in order to speed up operations related to pseudo-division and \spad{gcd}. This domain is based on the \axiomType{NSUP} constructor which is itself a post-facto extension of the \axiomType{SUP} constructor.
39666`A post-facto extension for \axiomType{SUP} in order to speed up operations related to pseudo-division and \spad{gcd} for both \axiomType{SUP} and,{} consequently,{} \axiomType{NSMP}.
39767`\spadtype{NonNegativeInteger} provides functions for non \indented{2}{negative integers.}
39841`\spadtype{None} implements a type with no objects. It is mainly used in technical situations where such a thing is needed (\spadignore{e.g.} the interpreter and some of the internal \spadtype{Expression} code).
40196`Octonion implements octonions (Cayley-Dixon algebra) over a commutative ring,{} an eight-dimensional non-associative algebra,{} doubling the quaternions in the same way as doubling the complex numbers to get the quaternions the main constructor function is {\em octon} which takes 8 arguments: the real part,{} the \spad{i} imaginary part,{} the \spad{j} imaginary part,{} the \spad{k} imaginary part,{} (as with quaternions) and
40196`-- in addition the imaginary parts \spad{E},{} \spad{I},{} \spad{J},{} \spad{K}.
40362`Adjunction of a complex infinity to a set. Date Created: 4 Oct 1989 Date Last Updated: 1 Nov 1989
40442`\spadtype{OpenMathConnection} provides low-level functions for handling connections to and from \spadtype{OpenMathDevice}\spad{s}.
40489`\spadtype{OpenMathDevice} provides support for reading and writing openMath objects to files,{} strings etc. It also provides access to low-level operations from within the interpreter.
40531`\spadtype{OpenMathEncoding} is the set of valid OpenMath encodings.
40593`\spadtype{OpenMathErrorKind} represents different kinds of OpenMath errors: specifically parse errors,{} unknown \spad{CD} or symbol errors,{} and read errors.
40657`\spadtype{OpenMathError} is the domain of OpenMath errors.
40716`Algebra of ADDITIVE operators over a ring.
40767`This constructor creates the \spadtype{MonogenicLinearOperator} domain which is ``opposite\spad{''} in the ring sense to \spad{P}. That is,{} as sets \spad{P = \$} but \spad{a * b} in \spad{\$} is equal to \spad{b * a} in \spad{P}.
40896`\indented{1}{Author : Larry Lambe} Date created : 14 August 1988 Date Last Updated : 11 March 1991 Description : A domain used in order to take the free \spad{R}-module on the Integers \spad{I}. This is actually the forgetful functor from OrderedRings to OrderedSets applied to \spad{I}
40949`Adjunction of two real infinites quantities to a set. Date Created: 4 Oct 1989 Date Last Updated: 1 Nov 1989
41028`\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The ordering on the type is determined by its third argument which represents the less than function on vectors. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.
41183`\indented{3}{The free monoid on a set \spad{S} is the monoid of finite products of} the form \spad{reduce(*,{}[\spad{si} ** \spad{ni}])} where the \spad{si}\spad{'s} are in \spad{S},{} and the \spad{ni}\spad{'s} are non-negative integers. The multiplication is not commutative. For two elements \spad{x} and \spad{y} the relation \spad{x < y} holds if either \spad{length(x) < length(y)} holds or if these lengths are equal an
41183`--d if \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \spad{S}. This domain inherits implementation from \spadtype{FreeMonoid}.
41264`This domain implements ordered variables
41643`This constructor produces an ordinary differential ring from a partial differential ring by specifying a variable.
41792`This domain represents truncated weighted polynomials over the "Polynomial" type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented.
41934`This domain is used to create and manipulate mathematical expressions for output. It is intended to provide an insulating layer between the expression rendering software (\spadignore{e.g.} TeX,{} or Script) and the output coercions in the various domains.
41992`Stream-based implementation of \spad{Zp:} \spad{p}-adic numbers are represented as sum(\spad{i} = 0..,{} a[\spad{i}] * p^i),{} where the a[\spad{i}] lie in 0,{}1,{}...,{}(\spad{p} - 1).
42062`This is the category of stream-based representations of \spad{Qp}.
42199`Stream-based implementation of \spad{Qp:} numbers are represented as sum(\spad{i} = \spad{k}..,{} a[\spad{i}] * p^i) where the a[\spad{i}] lie in 0,{}1,{}...,{}(\spad{p} - 1).
42348`ParametricPlaneCurve is used for plotting parametric plane curves in the affine plane.
42422`ParametricSpaceCurve is used for plotting parametric space curves in affine 3-space.
42496`ParametricSurface is used for plotting parametric surfaces in affine 3-space.
42566`The domain \spadtype{PartialFraction} implements partial fractions over a euclidean domain \spad{R}. This requirement on the argument domain allows us to normalize the fractions. Of particular interest are the 2 forms for these fractions. The ``compact\spad{''} form has only one fractional term per prime in the denominator,{} while the \spad{``p}-adic\spad{''} form expands each numerator \spad{p}-adically via the prime \spad{p} in t
42566`--he denominator. For computational efficiency,{} the compact form is used,{} though the \spad{p}-adic form may be gotten by calling the function \spadfunFrom{padicFraction}{PartialFraction}. For a general euclidean domain,{} it is not known how to factor the denominator. Thus the function \spadfunFrom{partialFraction}{PartialFraction} takes as its second argument an element of \spadtype{Factored(R)}.
42637`\indented{1}{Partition is an OrderedCancellationAbelianMonoid which is used} as the basis for symmetric polynomial representation of the sums of powers in SymmetricPolynomial. Thus,{} \spad{(5 2 2 1)} will represent \spad{s5 * s2**2 * s1}.
42716`A PatternMatchListResult is an object internally returned by the pattern matcher when matching on lists. It is either a failed match,{} or a pair of PatternMatchResult,{} one for atoms (elements of the list),{} and one for lists.
42837`A PatternMatchResult is an object internally returned by the pattern matcher; It is either a failed match,{} or a list of matches of the form (var,{} expr) meaning that the variable var matches the expression expr.
42932`Patterns for use by the pattern matcher.
43086`PermutationGroup implements permutation groups acting on a set \spad{S},{} \spadignore{i.e.} all subgroups of the symmetric group of \spad{S},{} represented as a list of permutations (generators). Note that therefore the objects are not members of the \Language category \spadtype{Group}. Using the idea of base and strong generators by Sims,{} basic routines and algorithms are implemented so that the word problem for permutati
43086`--on groups can be solved.
43164`Permutation(\spad{S}) implements the group of all bijections \indented{2}{on a set \spad{S},{} which move only a finite number of points.} \indented{2}{A permutation is considered as a map from \spad{S} into \spad{S}. In particular} \indented{2}{multiplication is defined as composition of maps:} \indented{2}{{\em pi1 * pi2 = pi1 o pi2}.} \indented{2}{The internal representation of permuatations are two lists} \indented{2}{
43164`--of equal length representing preimages and images.}
43245`\indented{1}{Symbolic fractions in \%\spad{pi} with integer coefficients;} \indented{1}{The point for using \spad{Pi} as the default domain for those fractions} \indented{1}{is that \spad{Pi} is coercible to the float types,{} and not Expression.} Date Created: 21 Feb 1990 Date Last Updated: 12 Mai 1992
43288`\indented{1}{Plot a NON-SINGULAR plane algebraic curve \spad{p}(\spad{x},{}\spad{y}) = 0.} Author: Clifton \spad{J}. Williamson Date Created: Fall 1988 Date Last Updated: 27 April 1990 Keywords: algebraic curve,{} non-singular,{} plot Examples: References:
43374`Plot3D supports parametric plots defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example,{} floating point numbers and infinite continued fractions are real number systems. The facilities at this point are limited to 3-dimensional parametric plots.
43443`The Plot domain supports plotting of functions defined over a real number system. A real number system is a model for the real numbers and as such may be an approximation. For example floating point numbers and infinite continued fractions. The facilities at this point are limited to 2-dimensional plots or either a single function or a parametric function.
43508`This domain provides the internal representation of polynomials in non-commutative variables written over the Poincare-Birkhoff-Witt basis. See the \spadtype{XPBWPolynomial} domain constructor. See Free Lie Algebras by \spad{C}. Reutenauer (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
43650`This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations,{} including intersection sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is \spad{true} if the generators are a Groebner basis. The algorithms use
43650`--d are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings.
43830`This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and terms indexed by their exponents (from an arbitrary ordered abelian monoid). This type is used,{} for example,{} by the \spadtype{DistributedMultivariatePolynomial} domain where the exponent domain is a direct product of non negative integers.
43936`\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials whose variables are arbitrary symbols. The ordering is alphabetic determined by the Symbol type. The coefficient ring may be non commutative,{} but the variables are assumed to commute.
44040`\spadtype{PositiveInteger} provides functions for \indented{2}{positive integers.}
44103`PrimeField(\spad{p}) implements the field with \spad{p} elements if \spad{p} is a prime number. Error: if \spad{p} is not prime. Note: this domain does not check that argument is a prime.
44182`\indented{1}{This provides a fast array type with no bound checking on elt\spad{'s}.} Minimum index is 0 in this type,{} cannot be changed
44261`This domain implements cartesian product
44346`This domain provides modest support for quadratic forms.
44434`\spadtype{QuasiAlgebraicSet} constructs a domain representing quasi-algebraic sets,{} which is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the common zeros of a 
44434`--polynomial \spad{f} (the defining polynomial for the inequation). This domain provides simplification of a user-given representation using groebner basis computations. There are two simplification routines: the first function \spadfun{idealSimplify} uses groebner basis of ideals alone,{} while the second,{} \spadfun{simplify} uses both groebner basis and factorization. The resulting defining equations \spad{L} always form a groebner basis,{} and the resulting defining inequation \spad{f} is al
44434`--ways reduced. The function \spadfun{simplify} may be applied several times if desired. A third simplification routine \spadfun{radicalSimplify} is provided in \spadtype{QuasiAlgebraicSet2} for comparison study only,{} as it is inefficient compared to the other two,{} as well as is restricted to only certain coefficient domains. For detail analysis and a comparison of the three methods,{} please consult the reference cited. \blankline A polynomial function \spad{q} defined on the quasi-algebrai
44434`--c set is equivalent to its reduced form with respect to \spad{L}. While this may be obtained using the usual normal form algorithm,{} there is no canonical form for \spad{q}. \blankline The ordering in groebner basis computation is determined by the data type of the input polynomials. If it is possible we suggest to use refinements of total degree orderings.
44612`\spadtype{Quaternion} implements quaternions over a \indented{2}{commutative ring. The main constructor function is \spadfun{quatern}} \indented{2}{which takes 4 arguments: the real part,{} the \spad{i} imaginary part,{} the \spad{j}} \indented{2}{imaginary part and the \spad{k} imaginary part.}
44685`This domain implements simple database queries
44823`Function field defined by y**n = \spad{f}(\spad{x}).
45063`This domain allows rational numbers to be presented as repeating decimal expansions or more generally as repeating expansions in any base.
45153`This domain implements the real closure of an ordered field.
45246`\spad{Record(a:A,b:B,...,c:C)} is a primitive type in AXIOM used to represent composite objects made up of objects of type \spad{A}, \spad{B},..., \spad{C} which are indexed by "keys" (identifiers) \spad{a},\spad{b},...,\spad{c}.
45298`\spadtype{RectangularMatrix} is a matrix domain where the number of rows and the number of columns are parameters of the domain.
45475`\indented{1}{\spadtype{Reference} is for making a changeable instance} of something.
45528`A domain for regular chains (\spadignore{i.e.} regular triangular sets) over a \spad{Gcd}-Domain and with a fix list of variables. This is just a front-end for the \spadtype{RegularTriangularSet} domain constructor.
45764`This domain provides an implementation of regular chains. Moreover,{} the operation \axiomOpFrom{zeroSetSplit}{RegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\newline References : \indented{1}{[1] \spad{M}. MORENO MAZA "A new algorithm f
45764`--or computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
45953`ResidueRing is the quotient of a polynomial ring by an ideal. The ideal is given as a list of generators. The elements of the domain are equivalence classes expressed in terms of reduced elements
46149`A domain used to return the results from a call to the NAG Library. It prints as a list of names and types,{} though the user may choose to display values automatically if he or she wishes.
46217`\indented{1}{Rules for the pattern matcher} Author: Manuel Bronstein Date Created: 24 Oct 1988 Date Last Updated: 26 October 1993 Keywords: pattern,{} matching,{} rule.
46345`\axiomType{RightOpenIntervalRootCharacterization} provides work with interval root coding.
46568`\spadtype{RomanNumeral} provides functions for converting \indented{1}{integers to roman numerals.}
46705`This domain implements named rules
46773`A ruleset is a set of pattern matching rules grouped together.
46900`This domain allows the manipulation of Lisp values over arbitrary atomic types.
47077`This domain allows the manipulation of the usual Lisp values.
47176`\spadtype{ScriptFormulaFormat} provides a coercion from \spadtype{OutputForm} to IBM SCRIPT/VS Mathematical Formula Format. The basic SCRIPT formula format object consists of three parts: a prologue,{} a formula part and an epilogue. The functions \spadfun{prologue},{} \spadfun{formula} and \spadfun{epilogue} extract these parts,{} respectively. The central parts of the expression go into the formula part. The other parts can be set (\s
47176`--padfun{setPrologue!},{} \spadfun{setEpilogue!}) so that contain the appropriate tags for printing. For example,{} the prologue and epilogue might simply contain ":df." and ":edf." so that the formula section will be printed in display math mode.
47243`This domain is used to provide the function argument syntax \spad{v=a..b}. This is used,{} for example,{} by the top-level \spadfun{draw} functions.
47305`This type is used to specify a range of values from type \spad{S}.
47669`\spadtype{SetOfMIntegersInOneToN} implements the subsets of \spad{M} integers in the interval \spad{[1..n]}
47768`A set over a domain \spad{D} models the usual mathematical notion of a finite set of elements from \spad{D}. Sets are unordered collections of distinct elements (that is,{} order and duplication does not matter). The notation \spad{set [a,{}b,{}c]} can be used to create a set and the usual operations such as union and intersection are available to form new sets. In our implementation,{} \Language{} maintains the entries in sorted order. Speci
47768`--fically,{} the parts function returns the entries as a list in ascending order and the extract operation returns the maximum entry. Given two sets \spad{s} and \spad{t} where \spad{\#s = m} and \spad{\#t = n},{} the complexity of \indented{2}{\spad{s = t} is \spad{O(min(n,{}m))}} \indented{2}{\spad{s < t} is \spad{O(max(n,{}m))}} \indented{2}{\spad{union(s,{}t)},{} \spad{intersect(s,{}t)},{} \spad{minus(s,{}t)},{} \spad{symmetricDifference(s,{}t)} is \spad{O(max(n,{}m))}} \indented{2}{\spad{me
47768`--mber(x,{}t)} is \spad{O(n log n)}} \indented{2}{\spad{insert(x,{}t)} and \spad{remove(x,{}t)} is \spad{O(n)}}
47829`Domain which represents simple algebraic extensions of arbitrary rings. The first argument to the domain,{} \spad{R},{} is the underlying ring,{} the second argument is a domain of univariate polynomials over \spad{K},{} while the last argument specifies the defining minimal polynomial. The elements of the domain are canonically represented as polynomials of degree less th
47829`--an that of the minimal polynomial with coefficients in \spad{R}. The second argument is both the type of the third argument and the underlying representation used by \spadtype{SAE} itself.
47961`\axiomType{SimpleFortranProgram(\spad{f},{}type)} provides a simple model of some FORTRAN subprograms,{} making it possible to coerce objects of various domains into a FORTRAN subprogram called \axiom{\spad{f}}. These can then be translated into legal FORTRAN code.
48076`SingleInteger is intended to support machine integer arithmetic.
48142`This trivial domain lets us build Univariate Polynomials in an anonymous variable
48207`\indented{2}{This type is the basic representation of sparse recursive multivariate} polynomials. It is parameterized by the coefficient ring and the variable set which may be infinite. The variable ordering is determined by the variable set parameter. The coefficient ring may be non-commutative,{} but the variables are assumed to commute.
48343`This domain provides multivariate Taylor series with variables from an arbitrary ordered set. A Taylor series is represented by a stream of polynomials from the polynomial domain \spad{SMP}. The \spad{n}th element of the stream is a form of degree \spad{n}. SMTS is an internal domain.
48542`A sparse table has a default entry,{} which is returned if no other value has been explicitly stored for a key.
48645`Sparse Laurent series in one variable \indented{2}{\spadtype{SparseUnivariateLaurentSeries} is a domain representing Laurent} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented
48645`--{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{SparseUnivariateLaurentSeries(Integer,{}x,{}3)} represents Laurent} \indented{2}{series in \spad{(x - 3)} with integer coefficients.}
48842`This domain represents univariate polynomials over arbitrary (not necessarily commutative) coefficient rings. The variable is unspecified so that the variable displays as \spad{?} on output. If it is necessary to specify the variable name,{} use type \spadtype{UnivariatePolynomial}. The representation is sparse in the sense that only non-zero terms are represented.
48939`Sparse Puiseux series in one variable \indented{2}{\spadtype{SparseUnivariatePuiseuxSeries} is a domain representing Puiseux} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indent
48939`--ed{2}{variable,{} and the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{SparseUnivariatePuiseuxSeries(Integer,{}x,{}3)} represents Puiseux} \indented{2}{series in \spad{(x - 3)} with \spadtype{Integer} coefficients.}
49138`This is the domain of sparse univariate skew polynomials over an Ore coefficient field. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}.
49283`Sparse Taylor series in one variable \indented{2}{\spadtype{SparseUnivariateTaylorSeries} is a domain representing Taylor} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and the center of the power series expansion.\s
49283`--pace{2}For example,{}} \indented{2}{\spadtype{SparseUnivariateTaylorSeries}(Integer,{}\spad{x},{}3) represents Taylor} \indented{2}{series in \spad{(x - 3)} with \spadtype{Integer} coefficients.}
49420`\indented{2}{This type represents the finite direct or cartesian product of an} underlying ordered component type. The vectors are ordered as if they were split into two blocks. The \spad{dim1} parameter specifies the length of the first block. The ordering is lexicographic between the blocks but acts like \spadtype{HomogeneousDirectProduct} w
49420`--ithin each block. This type is a suitable third argument for \spadtype{GeneralDistributedMultivariatePolynomial}.
49582`This domain exports a modest implementation for the vertices of splitting trees. These vertices are called here splitting nodes. Every of these nodes store 3 informations. The first one is its value,{} that is the current expression to evaluate. The second one is its condition,{} that is the hypothesis under which the value has to be evaluated. The last one is its status,{} that is a boolean f
49582`--lag which is \spad{true} iff the value is the result of its evaluation under its condition. Two splitting vertices are equal iff they have the sane values and the same conditions (so their status do not matter).
49693`This domain exports a modest implementation of splitting trees. Spliiting trees are needed when the evaluation of some quantity under some hypothesis requires to split the hypothesis into sub-cases. For instance by adding some new hypothesis on one hand and its negation on another hand. The computations are terminated is a splitting tree \axiom{a} when \axiom{status(
49693`--value(a))} is \axiom{\spad{true}}. Thus,{} if for the splitting tree \axiom{a} the flag \axiom{status(value(a))} is \axiom{\spad{true}},{} then \axiom{status(value(\spad{d}))} is \axiom{\spad{true}} for any subtree \axiom{\spad{d}} of \axiom{a}. This property of splitting trees is called the termination condition. If no vertex in a splitting tree \axiom{a} is equal to another,{} \axiom{a} is said to satisfy the no-duplicates condition. The splitting tree \axiom{a} will satisfy this condition i
49693`--f nodes are added to \axiom{a} by mean of \axiom{splitNodeOf!} and if \axiom{construct} is only used to create the root of \axiom{a} with no children.
49831`This domain provides an implementation of square-free regular chains. Moreover,{} the operation \axiomOpFrom{zeroSetSplit}{SquareFreeRegularTriangularSetCategory} is an implementation of a new algorithm for solving polynomial systems by means of regular chains.\newline References : \indented{1}{[
49831`--1] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.} \indented{2}{Version: 2}
50041`\spadtype{SquareMatrix} is a matrix domain of square matrices,{} where the number of rows (= number of columns) is a parameter of the type.
50262`A stream is an implementation of an infinite sequence using a list of terms that have been computed and a function closure to compute additional terms when needed.
50333`This domain provides tables where the keys are strings. A specialized hash function for strings is used.
50615`This domain implements "such that" forms
50701`This domain builds representations of boolean expressions for use with the \axiomType{FortranCode} domain.
50766`Create and manipulate a symbol table for generated FORTRAN code
50836`Basic and scripted symbols.
50888`This domain implements symmetric polynomial
50987`This is the general purpose table type. The keys are hashed to look up the entries. This creates a \spadtype{HashTable} if equal for the Key domain is consistent with Lisp EQUAL otherwise an \spadtype{AssociationList}
51092`\indented{1}{The tableau domain is for printing Young tableaux,{} and} coercions to and from List List \spad{S} where \spad{S} is a set.
51143`\spadtype{TaylorSeries} is a general multivariate Taylor series domain over the ring Coef and with variables of type Symbol.
51242`\spadtype{TexFormat} provides a coercion from \spadtype{OutputForm} to \TeX{} format. The particular dialect of \TeX{} used is \LaTeX{}. The basic object consists of three parts: a prologue,{} a tex part and an epilogue. The functions \spadfun{prologue},{} \spadfun{tex} and \spadfun{epilogue} extract these parts,{} respectively. The main guts of the expression go into the tex part. The other parts can be set (\spadfun{setPrologue!},{} \spadfun{setEpi
51242`--logue!}) so that contain the appropriate tags for printing. For example,{} the prologue and epilogue might simply contain \spad{``}\verb+\spad{\[}+\spad{''} and \spad{``}\verb+\spad{\]}+\spad{''},{} respectively,{} so that the TeX section will be printed in LaTeX display math mode.
51295`This domain provides an implementation of text files. Text is stored in these files using the native character set of the computer.
51370`Creates and manipulates one global symbol table for FORTRAN code generation,{} containing details of types,{} dimensions,{} and argument lists.
51441`This domain represents three dimensional matrices over a general object type
51726`\indented{2}{Package for constructing tubes around 3-dimensional parametric curves.} Domain of tubes around 3-dimensional parametric curves.
51795`\indented{1}{This domain is used to interface with the interpreter\spad{'s} notion} of comma-delimited sequences of values.
51872`\indented{1}{A TwoDimensionalArray is a two dimensional array with} 1-based indexing for both rows and columns.
52074`\spad{Union(A,B,...,C)} is a primitive type in AXIOM used to represent objects of type \spad{A} or of type \spad{B} or...or of type \spad{C}.
52118`This package enables one to construct a univariate Laurent series domain from a univariate Taylor series domain. Univariate Laurent series are represented by a pair \spad{[n,{}f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x**n * f(x)}.
52291`Dense Laurent series in one variable \indented{2}{\spadtype{UnivariateLaurentSeries} is a domain representing Laurent} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} and 
52291`--the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{UnivariateLaurentSeries(Integer,{}x,{}3)} represents Laurent series in} \indented{2}{\spad{(x - 3)} with integer coefficients.}
52475`This domain represents univariate polynomials in some symbol over arbitrary (not necessarily commutative) coefficient rings. The representation is sparse in the sense that only non-zero terms are represented.
52576`This package enables one to construct a univariate Puiseux series domain from a univariate Laurent series domain. Univariate Puiseux series are represented by a pair \spad{[r,{}f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.
52751`UnivariatePuiseuxSeriesWithExponentialSingularity is a domain used to represent functions with essential singularities. Objects in this domain are sums,{} where each term in the sum is a univariate Puiseux series times 
52751`--the exponential of a univariate Puiseux series. Thus,{} the elements of this domain are sums of expressions of the form \spad{g(x) * exp(f(x))},{} where \spad{g}(\spad{x}) is a univariate Puiseux series and \spad{f}(\spad{x}) is a univariate Puiseux series with no terms of non-negative degree.
53039`Dense Puiseux series in one variable \indented{2}{\spadtype{UnivariatePuiseuxSeries} is a domain representing Puiseux} \indented{2}{series in one variable with coefficients in an arbitrary ring.\space{2}The} \indented{2}{parameters of the type specify the coefficient ring,{} the power series} \indented{2}{variable,{} an
53039`--d the center of the power series expansion.\space{2}For example,{}} \indented{2}{\spad{UnivariatePuiseuxSeries(Integer,{}x,{}3)} represents Puiseux series in} \indented{2}{\spad{(x - 3)} with \spadtype{Integer} coefficients.}
53225`This is the domain of univariate skew polynomials over an Ore coefficient field in a named variable. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}.
53372`Dense Taylor series in one variable \spadtype{UnivariateTaylorSeries} is a domain representing Taylor series in one variable with coefficients in an arbitrary ring. The parameters of the type specify the coefficient ring,{} the power series variable,{} and the center of the power series expansion. For example,{} \spadtype{UnivariateTaylorSeries}(Integer,{}\spad{x},{}3) repre
53372`--sents Taylor series in \spad{(x - 3)} with \spadtype{Integer} coefficients.
53502`This domain provides segments which may be half open. That is,{} ranges of the form \spad{a..} or \spad{a..b}.
53579`This domain implements variables
53708`This type is used when no value is needed,{} \spadignore{e.g.} in the \spad{then} part of a one armed \spad{if}. All values can be coerced to type Void. Once a value has been coerced to Void,{} it cannot be recovered.
53739`This domain represents truncated weighted polynomials over a general (not necessarily commutative) polynomial type. The variables must be specified,{} as must the weights. The representation is sparse in the sense that only non-zero terms are represented.
53962`A domain constructor of the category \axiomType{GeneralTriangularSet}. The only requirement for a list of polynomials to be a member of such a domain is the following: no polynomial is constant and two distinct polynomials have distinct main variables. Such a triangular set may not be auto-reduced or consistent. The 
53962`--\axiomOpFrom{construct}{WuWenTsunTriangularSet} operation does not check the previous requirement. Triangular sets are stored as sorted lists \spad{w}.\spad{r}.\spad{t}. the main variables of their members. Furthermore,{} this domain exports operations dealing with the characteristic set method of Wu Wen Tsun and some optimizations mainly proposed by Dong Ming Wang.\newline References : \indented{1}{[1] \spad{W}. \spad{T}. WU "A Zero Structure Theorem for polynomial equations solving"} \indent
53962`--ed{6}{\spad{MM} Research Preprints,{} 1987.} \indented{1}{[2] \spad{D}. \spad{M}. WANG "An implementation of the characteristic set method in Maple"} \indented{6}{Proc. \spad{DISCO'92}. Bath,{} England.}
54151`\indented{2}{This type supports distributed multivariate polynomials} whose variables do not commute. The coefficient ring may be non-commutative too. However,{} coefficients and variables commute.
54270`This domain constructor implements polynomials in non-commutative variables written in the Poincare-Birkhoff-Witt basis from the Lyndon basis. These polynomials can be used to compute Baker-Campbell-Hausdorff relations. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
54385`This domain represents generalized polynomials with coefficients (from a not necessarily commutative ring),{} and words belonging to an arbitrary \spadtype{OrderedMonoid}. This type is used,{} for instance,{} by the \spadtype{XDistributedPolynomial} domain constructor where the Monoid is free.
54462`\indented{2}{This type supports multivariate polynomials} whose set of variables is \spadtype{Symbol}. The representation is recursive. The coefficient ring may be non-commutative and the variables do not commute. However,{} coefficients and variables commute.
54540`\indented{2}{This type supports multivariate polynomials} whose variables do not commute. The representation is recursive. The coefficient ring may be non-commutative. Coefficients and variables commute.
56732`\spad{\# p} returns the number of terms in \spad{p}.
56794`\spad{\#((a1,{}...,{}an))} returns \spad{n}.
56866`\spad{\# u} returns the number of items in \spad{u}.
57003`\spad{a ** b} is the formal exponential a**b.
57056`\spad{x ** q} is \spad{x} raised to the rational power \spad{q}.
57150`\spad{x ** n} computes the \spad{n}-th power of a square matrix. The power \spad{n} is assumed greater than 1.
57802`\spad{s ** n} returns the product of \spad{s} by itself \spad{n} times.
58397`\spad{s ** n} returns the product of \spad{s} by itself \spad{n} times.
58455`\spad{s ** n} returns the product of \spad{s} by itself \spad{n} times.
59228`\spad{st1 ** st2} computes the power of a power series \spad{st1} by another power series \spad{st2}.
59323`\spad{st1 ** st2} computes the power of a power series \spad{st1} by another power series \spad{st2}.
59432`\spad{s ** r} raises a Laurent series \spad{s} to a rational power \spad{r}
59550`\spad{z ** r} raises a Puiseaux series \spad{z} to a rational power \spad{r}
59677`\spad{x**n} \undocumented{} See \axiomFunFrom{\spad{**}}{DivisionRing}
59762`\spad{a ** b} returns the input form corresponding to \spad{a ** b}.
59847`\spad{a ** b} returns the input form corresponding to \spad{a ** b}.
59902`\spad{a ** n} returns the pattern \spad{a ** n}.
59958`\spad{f ** g} creates the equivalent infix form.
59998`\spad{a ** b} returns the pattern \spad{a ** b}.
60038`\spad{f**n} is the function which is the \spad{n}-fold application \indented{1}{of \spad{f}.}
60110`\spad{op**n} \undocumented
60175`\spad{f(x) ** a} computes a power of a power series. When the coefficient ring is a field,{} we may raise a series to an exponent from the coefficient ring provided that the constant coefficient of the series is 1.
60258`\spad{x ** y} is the rational exponentiation of \spad{x} by the power \spad{y}.
60318`\spad{x**n} returns \spad{x} raised to the integer power \spad{n}.
60365`\spad{x**n} returns \spad{x} raised to the integer power \spad{n}.
60405`\spad{m**n} computes an integral power of the matrix \spad{m}. Error: if matrix is not square or if the matrix is square but not invertible.
60477`\spad{m**n} computes an integral power of the matrix \spad{m}. Error: if the matrix is not invertible.
60560`\spad{op**n} \undocumented
60614`\spad{x**n} returns \spad{x} * \spad{x} * \spad{x} * ... * \spad{x} (\spad{n} times).
60692`\spad{x ** n} computes a non-negative integral power of the matrix \spad{x}. Error: if the matrix is not square.
60763`\spad{a**n} returns the \spad{n}\spad{-}th power of \spad{a},{} defined by repeated squaring.
60822`\spad{x**n} returns the repeated product of \spad{x} \spad{n} times,{} \spadignore{i.e.} exponentiation.
60874`\spad{I**n} computes the \spad{n}th power of the ideal \spad{I}.
60958`\spad{a**n} returns the \spad{n}\spad{-}th power of \spad{a},{} defined by repeated squaring.
61006`\spad{x**n} returns the repeated product of \spad{x} \spad{n} times,{} \spadignore{i.e.} exponentiation.
61058`\spad{x**y} returns \spad{x} to the power \spad{y}.
61114`\spad{x**y} returns \spad{\#(X**Y)} where \spad{X**Y} is defined \indented{1}{as \spad{\{g| g:Y->X\}}.}
61158`\spad{x ** y} returns the \spad{y}th power of \spad{x} (equal to \spad{exp(y log x)}).
61199`\spad{x ** y} computes \spad{exp(y log x)} where \spad{x >= 0}.
61234`\spad{r * a} returns the power series scalar multiplication of \spad{r} by \spad{a}: \spad{r * [a0,{}a1,{}...] = [r * a0,{}r * a1,{}...]}
61369`\spad{c*x} returns the product of \spad{c} and the series \spad{x}.
61423`\spad{s * p} returns a point whose coordinates are the scalar multiple of the point \spad{p} by the scalar \spad{s},{} preserving the color,{} or fourth coordinate,{} of \spad{p}.
63140`\spad{p*x} \undocumented
64335`\axiom{\spad{r} * \spad{v}} computes the product of \axiom{\spad{r}} and \axiom{\spad{v}}
65387`\spad{s*r} returns the product \spad{r*s} used by \spadtype{XRecursivePolynomial}
65850`\spad{s * x} returns the product of \spad{x} by \spad{s} on the left.
65890`\spad{s * x} returns the product of \spad{x} by \spad{s} on the left.
65931`\spad{s * x} returns the product of \spad{x} by \spad{s} on the left.
65979`\spad{smp*ts} multiplies a TaylorSeries by a monomial \spad{SMP}.
66053`\spad{a * r} returns the power series scalar multiplication of \spad{a} by \spad{r:} \spad{[a0,{}a1,{}...] * r = [a0 * r,{}a1 * r,{}...]}
66126`\spad{a * b} returns the power series (Cauchy) product of \spad{a} and \spad{b:} \spad{[a0,{}a1,{}...] * [b0,{}b1,{}...] = [c0,{}c1,{}...]} where \spad{ck = sum(i + j = k,{}\spad{ai} * bk)}.
66207`\spad{x*y} \undocumented{} See \axiomFunFrom{*}{SemiGroup}
66294`\spad{x*c} returns the product of \spad{c} and the series \spad{x}.
66348`\spad{x*i} returns the product of integer \spad{i} and the series \spad{x}.
66405`\spad{p*r} returns the product of \spad{p} by \spad{r}.
66453`\spad{x * s} returns the product of \spad{x} by \spad{s} on the right.
66493`\spad{x * s} returns the product of \spad{x} by \spad{s} on the right.
66534`\spad{x * s} returns the product of \spad{x} by \spad{s} on the right.
66582`\spad{a * b} returns the input form corresponding to \spad{a * b}.
66620`\axiom{x*y} returns the tree \axiom{[\spad{x},{}\spad{y}]}.
66662`\spad{f * g} creates the equivalent infix form.
66701`\spad{a * b} returns the pattern \spad{a * b}.
66740`\spad{f*g} is the function \spad{h} \indented{1}{such that \spad{h x= f(g x)}.}
66803`\spad{s * c},{} returns the color \spad{c},{} whose weighted shade has been scaled by \spad{s}.
66846`\spad{e * s} returns \spad{e} times \spad{s}.
66903`\spad{n*x} is the product of \spad{x} by the integer \spad{n}.
66949`\spad{n * x} is an integer multiple.
67008`\spad{n * y} multiplies each component of the vector \spad{y} by the integer \spad{n}.
67078`\spad{n * x} is left-multiplication by a non negative integer
67136`\spad{n*x} computes the left-multiplication of \spad{x} by the positive integer \spad{n}. This is equivalent to adding \spad{x} to itself \spad{n} times.
67194`\spad{s * c},{} returns the color \spad{c},{} whose weighted shade has been scaled by \spad{s}.
67241`\spad{r*b} returns the product of \spad{r} by \spad{b}.
67294`\spad{r * y} multiplies the element \spad{r} times each component of the vector \spad{y}.
67363`\spad{r*g} is left module multiplication.
67408`\spad{r*x} returns the left multiplication of the module element \spad{x} by the ring element \spad{r}.
67449`\spad{r*x} is the left scalar multiple of the scalar \spad{r} and the matrix \spad{x}.
67502`\spad{r * y} multiplies the element \spad{r} times each component of the vector \spad{y}.
67560`\spad{r * x} is the product of the row vector \spad{r} and the matrix \spad{x}. Error: if the dimensions are incompatible.
67616`\spad{r * x} is the product of the row vector \spad{r} and the matrix \spad{x}. Error: if the dimensions are incompatible.
67683`\spad{x*eqn} produces a new equation by multiplying both sides of equation eqn by \spad{x}.
67738`\spad{x * c} is the product of the matrix \spad{x} and the column vector \spad{c}. Error: if the dimensions are incompatible.
67794`\spad{x * c} is the product of the matrix \spad{x} and the column vector \spad{c}. Error: if the dimensions are incompatible.
67861`\spad{y * r} multiplies each component of the vector \spad{y} by the element \spad{r}.
67930`\spad{g*r} is right module multiplication.
67975`\spad{x * r} is the right scalar multiple of the scalar \spad{r} and the matrix \spad{x}.
68028`\spad{x*r} returns the right multiplication of the module element \spad{x} by the ring element \spad{r}.
68070`\spad{y * r} multiplies each component of the vector \spad{y} by the element \spad{r}.
68128`\spad{x * r} returns the product of \spad{x} by \spad{r}. Usefull if \spad{R} is a non-commutative Ring.
68174`\spad{eqn*x} produces a new equation by multiplying both sides of equation eqn by \spad{x}.
68229`\spad{x * y} is the product of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.
68283`\spad{a*b} is the product of \spad{a} and \spad{b} in a set with a binary operation.
68317`\spad{x*y} returns the product of \spad{x} and \spad{y}.
68355`\spad{s*t} is the inner product of the tensors \spad{s} and \spad{t} which contracts the last index of \spad{s} with the first index of \spad{t},{} \spadignore{i.e.} \indented{4}{\spad{t*s = contract(t,{}rank t,{} s,{} 1)}} \indented{4}{\spad{t*s = sum(k=1..N,{} t[i1,{}..,{}iN,{}k]*s[k,{}j1,{}..,{}jM])}} This is compatible with the use of \spad{M*v} to denote the matrix-vector inner product.
68412`\spad{I*J} computes the product of the ideal \spad{I} and \spad{J}.
68479`\spad{v * x} returns the product of a variable \spad{x} by \spad{x}.
68526`\spad{p + q} computes and returns a point whose coordinates are the sums of the coordinates of the two points \spad{p} and \spad{q},{} using the color,{} or fourth coordinate,{} of the first point \spad{p} as the color also of the point \spad{q}.
68836`\spad{a + b} returns the power series sum of \spad{a} and \spad{b}: \spad{[a0,{}a1,{}..] + [b0,{}b1,{}..] = [a0 + b0,{}a1 + b1,{}..]}
68917`\spad{a + b} returns the input form corresponding to \spad{a + b}.
68955`\spad{f + g} creates the equivalent infix form.
68994`\spad{a + b} returns the pattern \spad{a + b}.
69033`\spad{s + x} returns the sum of \spad{s} and \spad{x}.
69091`\spad{x+eqn} produces a new equation by adding \spad{x} to both sides of equation eqn.
69153`\spad{p + x} returns the sum of \spad{p} and \spad{x}
69216`\spad{eqn+x} produces a new equation by adding \spad{x} to both sides of equation eqn.
69278`\spad{x+y} computes the sum of \spad{x} and \spad{y}.
69323`\spad{g+h} is the sum of \spad{g} and \spad{h} in the module of elements of the same degree as \spad{g} and \spad{h}. Error: if \spad{g} and \spad{h} have different degrees.
69369`\spad{x + y} is the sum of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.
69423`\spad{x + y} returns the component-wise sum of the vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.
69492`\spad{c1 + c2} additively mixes the two colors \spad{c1} and \spad{c2}.
69526`\spad{db1+db2} returns the merge of databases \spad{db1} and \spad{db2}
69566`\spad{I+J} computes the ideal generated by the union of \spad{I} and \spad{J}.
69974`\spad{- a} returns the power series negative of \spad{a}: \spad{- [a0,{}a1,{}...] = [- a0,{}- a1,{}...]}
70045`\spad{- f} creates the equivalent prefix form.
70081`\spad{-x} is the additive inverse of \spad{x}.
70119`\spad{-g} is the additive inverse of \spad{g} in the module of elements of the same grade as \spad{g}.
70162`\spad{-x} returns the negative of the matrix \spad{x}.
70213`\spad{-x} negates all components of the vector \spad{x}.
70275`\spad{p - q} computes and returns a point whose coordinates are the differences of the coordinates of two points \spad{p} and \spad{q},{} using the color,{} or fourth coordinate,{} of the first point \spad{p} as the color also of the point \spad{q}.
70722`\spad{a - b} returns the power series difference of \spad{a} and \spad{b}: \spad{[a0,{}a1,{}..] - [b0,{}b1,{}..] = [a0 - b0,{}a1 - b1,{}..]}
70803`\spad{f - g} creates the equivalent infix form.
70842`\spad{x-eqn} produces a new equation by subtracting both sides of equation eqn from \spad{x}.
70900`\spad{eqn-x} produces a new equation by subtracting \spad{x} from both sides of equation eqn.
70958`\spad{x - y} returns an element \spad{z} such that \spad{z+y=x} or "failed" if no such element exists.
71017`\spad{x-y} is the difference of \spad{x} and \spad{y} \spadignore{i.e.} \spad{x + (-y)}.
71058`\spad{g-h} is the difference of \spad{g} and \spad{h} in the module of elements of the same degree as \spad{g} and \spad{h}. Error: if \spad{g} and \spad{h} have different degrees.
71104`\spad{x - y} is the difference of the matrices \spad{x} and \spad{y}. Error: if the dimensions are incompatible.
71158`\spad{x - y} returns the component-wise difference of the vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.
71223`\spad{db1-db2} returns the difference of databases \spad{db1} and \spad{db2} \spadignore{i.e.} consisting of elements in \spad{db1} but not in \spad{db2}
71301`\spadignore { /\ }returns the logical `meet',{} \spadignore{e.g.} `and'.
71336`\spad{n} \spad{/\} \spad{m} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
71417`\spad{a / d} divides the element \spad{a} by \spad{d}.
71463`\spad{m / d} divides the element \spad{m} by \spad{d}.
71817`\spad{a / b} returns the power series quotient of \spad{a} by \spad{b}. An error message is returned if \spad{b} is not invertible. This function is used in fixed point computations.
71898`\spad{x/y} \undocumented{} See \axiomFunFrom{/}{Field}
71985`\spad{p/r} returns \spad{p*(1/r)}.
72045`\spad{x / d} divides the element \spad{x} by \spad{d}.
72092`\spad{x / d} divides the element \spad{x} by \spad{d}.
72135`\spad{x/y} division (only works if minimum weight of divisor is zero,{} and if \spad{R} is a Field)
72236`\spad{x/y} division (only works if minimum weight of divisor is zero,{} and if \spad{R} is a Field)
72340`\spad{a / b} returns the input form corresponding to \spad{a / b}.
72378`\spad{f / g} creates the equivalent infix form.
72417`\spad{a / b} returns the pattern \spad{a / b}.
72456`\spad{d1 / d2} returns the fraction \spad{d1} divided by \spad{d2}.
72507`\spad{p1/p2} returns the quotient of \spad{p1} and \spad{p2} as an element of \%.
72653`\spad{x / i} computes the division from \spad{x} by an integer \spad{i}.
72698`\spad{x / i} computes the division from \spad{x} by an integer \spad{i}.
72737`\spad{p/c} divides \spad{p} by the coefficient \spad{c}.
72799`\axiom{\spad{x/r}} returns the division of \axiom{\spad{x}} by \axiom{\spad{r}}.
72852`\spad{m/r} divides the elements of \spad{m} by \spad{r}. Error: if \spad{r = 0}.
72917`\spad{m/r} divides the elements of \spad{m} by \spad{r}. Error: if \spad{r = 0}.
72997`\spad{x/y} divides the vector \spad{x} by the scalar \spad{y}.
73039`\spad{x/y} divides the element \spad{x} by the element \spad{y}. Error: if \spad{y} is 0.
73073`\spad{x/y} is the same as \spad{x} times the inverse of \spad{y}.
73107`\spad{e1/e2} produces a new equation by dividing the left and right hand sides of equations \spad{e1} and \spad{e2}.
73613`\spad{f <= g} creates the equivalent infix form.
73653`\spad{x <= y} is a less than or equal test.
73698`\spad{gp1 <= gp2} returns \spad{true} if and only if {\em gp1} is a subgroup of {\em gp2}. Note: because of a bug in the parser you have to call this function explicitly by {\em gp1 <=\$(PERMGRP S) gp2}.
74233`\spad{f < g} creates the equivalent infix form.
74272`\spad{x < y} is a strict total ordering on the elements of the set.
74316`\spad{p < q} is an order relation on permutations. Note: this order is only total if and only if \spad{S} is totally ordered or \spad{S} is finite.
74372`\spad{s < t} returns \spad{true} if all elements of set aggregate \spad{s} are also elements of set aggregate \spad{t}.
74421`\spad{gp1 < gp2} returns \spad{true} if and only if {\em gp1} is a proper subgroup of {\em gp2}.
75304`\spad{a=b} tests if \spad{a} and \spad{b} are equal.
75350`\spad{f = g} creates the equivalent infix form.
75389`\spad{a=b} creates an equation.
75427`\spad{x=y} tests if \spad{x} and \spad{y} are equal.
75470`\spad{x=y} tests for equality
75563`\spad{f >= g} creates the equivalent infix form.
75603`\spad{x >= y} is a greater than or equal test.
75689`\spad{f > g} creates the equivalent infix form.
75728`\spad{x > y} is a greater than test.
75772`\spad{AND(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x and y}.
75981`\spad{Aleph(n)} provides the named (infinite) cardinal number.
76041`\spad{An(x)} \undocumented
76090`\spad{And(n,{}m)} returns the bit-by-bit logical {\em And} of \spad{n} and \spad{m}.
76136`\spad{And(n,{}m)} returns the bit-by-bit logical {\em and} of the single integers \spad{n} and \spad{m}.
76180`\spad{B1solve(s)} solves the system (\spad{s}.mat) \spad{z} = \spad{s}.vec for the variables given by the column indices of \spad{s}.cols in terms of the other variables and the right hand side \spad{s}.vec b
76180`--y assuming that the rank is \spad{s}.rank,{} that the system is consistent,{} with the linearly independent equations indexed by the given row indices \spad{s}.rows; the coefficients in \spad{s}.mat involving parameters are treated as polynomials. B1solve(\spad{s}) returns a particular solution to the system and a basis of the homogeneous system (\spad{s}.mat) \spad{z} = 0.
76479`\spad{s by n} creates a new segment in which only every \spad{n}\spad{-}th element is used.
76532`\spad{BasicMethod(n)} returns the factorization of integer \spad{n} by trial division
76606`\spad{Beta(x,{}y)} returns the beta function applied to \spad{x} and \spad{y}
76665`\spad{Beta(n,{}m)} \undocumented
76760`\spad{Beta(x,{} y)} is the Euler beta function,{} \spad{B(x,{}y)},{} defined by \indented{2}{\spad{Beta(x,{}y) = integrate(t^(x-1)*(1-t)^(y-1),{} t=0..1)}.} This is related to \spad{Gamma(x)} by \indented{2}{\spad{Beta(x,{}y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.}
76873`\spad{Beta(x,{} y)} is the Euler beta function,{} \spad{B(x,{}y)},{} defined by \indented{2}{\spad{Beta(x,{}y) = integrate(t^(x-1)*(1-t)^(y-1),{} t=0..1)}.} This is related to \spad{Gamma(x)} by \indented{2}{\spad{Beta(x,{}y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.}
76959`\spad{Beta(x,{}y)} is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.
77014`\spad{Beta(x,{}y)} is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.
77057`\spad{BumInSepFFE(f)} is a local function,{} exported only because it has multiple conditional definitions.
77259`\spad{\spad{Ci}(f)} denotes the cosine integral
77308`\spad{\spad{Ci}(x)} returns the cosine integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{cos(x) / x dx}.
77428`\spad{D()} provides the operator corresponding to a derivation in the ring \spad{A}.
77582`\spad{D(x)} returns the derivative of \spad{x}. This function is a simple differential operator where no variable needs to be specified.
77624`\spad{D(f)} returns the derivative of \spad{f}.
78078`\spad{D(x,{} deriv)} differentiates \spad{x} extending the derivation deriv on \spad{R}.
78135`\spad{D(x,{}[s1,{}...sn])} computes successive partial derivatives,{} \spadignore{i.e.} \spad{D(...D(x,{} s1)...,{} sn)}.
78195`\spad{D(x,{} n)} returns the \spad{n}-th derivative of \spad{x}.
78256`\spad{D(f,{} n)} returns the \spad{n}-th derivative of \spad{f}.
78335`\spad{D(x,{}v)} computes the partial derivative of \spad{x} with respect to \spad{v}.
78767`\spad{D(x,{} deriv,{} n)} differentiate \spad{x} \spad{n} times using a derivation which extends \spad{deriv} on \spad{R}.
78843`\spad{D(x,{} [s1,{}...,{}sn],{} [n1,{}...,{}nn])} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{D(...D(x,{} s1,{} n1)...,{} sn,{} nn)}.
78928`\spad{D(x,{} s,{} n)} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{n}-th derivative of \spad{x} with respect to \spad{s}.
79001`\spad{EQ(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x = y}.
79209`\spad{\spad{Ei}(f)} denotes the exponential integral
79258`\spad{\spad{Ei}(x)} returns the exponential integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{exp(x)/x dx}.
79312`\spad{F2FG(a + sqrt(-1) b)} returns \spad{a + i b}.
79379`\spad{FG2F(a + i b)} returns \spad{a + sqrt(-1) b}.
79446`\spad{F(n,{}m)} \undocumented
79538`\spad{FormatArabic(n)} forms an Arabic numeral string from an integer \spad{n}.
79605`\spad{FormatRoman(n)} forms a Roman numeral string from an integer \spad{n}.
79671`\spad{Frobenius(x)} \undocumented
79794`\spad{Frobenius(a)} returns \spad{a ** q} where \spad{q} is the \spad{size()\$F}.
79924`\spad{Frobenius(a,{}s)} returns \spad{a**(q**s)} where \spad{q} is the size()\$\spad{F}.
80007`\spad{GE(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x>=y}.
80215`\spad{GF2FG(a + i b)} returns \spad{a + i b} viewed as a function with the \spad{i} pushed down into the coefficient domain.
80292`\spad{GT(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x>y}.
80500`\spad{Gamma(f)} returns the formal Gamma function applied to \spad{f}
80558`\spad{Gamma(x)} is the Euler gamma function,{} \spad{Gamma(x)},{} defined by \indented{2}{\spad{Gamma(x) = integrate(t^(x-1)*exp(-t),{} t=0..\%infinity)}.}
80651`\spad{Gamma(x)} is the Euler gamma function,{} \spad{Gamma(x)},{} defined by \indented{2}{\spad{Gamma(x) = integrate(t^(x-1)*exp(-t),{} t=0..\%infinity)}.}
80726`\spad{Gamma(x)} is the Euler Gamma function.
80779`\spad{Gamma(x)} is the Euler Gamma function.
80820`\spad{Gamma(a,{}x)} returns the incomplete Gamma function applied to a and \spad{x}
80880`\spad{Gamma(a,{}x)} is the incomplete Gamma function.
80936`\spad{GospersMethod(b,{} n,{} new)} returns a rational function \spad{rf(n)} such that \spad{a(n) * rf(n)} is the indefinite sum of \spad{a(n)} with respect to upward difference on \spad{n},{} \spadignore{i.e.} \spad{a(n+1) * rf(n+1) - a(n) * rf(n) = a(n)},{} where \spad{b(n) = a(n)/a(n-1)} is a rational function. Returns "failed" if no such rational function \spad{rf(n)} exists. Note: \spad{new} is a nullary fu
80936`--nction returning a new \spad{V} every time. The condition on \spad{a(n)} is that \spad{a(n)/a(n-1)} is a rational function of \spad{n}.
81028`\axiom{Hausdorff(a,{}\spad{b},{}\spad{n})} returns log(exp(a)*exp(\spad{b})) truncated at order \axiom{\spad{n}}.
81128`\spad{HenselLift(pol,{}lfacts,{}prime,{}bound)} lifts \spad{lfacts},{} that are the factors of \spad{pol} mod \spad{prime},{} to factors of \spad{pol} mod prime**k > \spad{bound}. No recombining is done .
81248`\spad{HermiteIntegrate(f,{} D)} returns \spad{[g,{} h,{} s,{} p]} such that \spad{f = Dg + h + s + p},{} \spad{h} has a squarefree denominator normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and all the squarefree factors of the denominator of \spad{s} are special \spad{w}.\spad{r}.\spad{t}. \spad{D}. Furthermore,{} \spad{h} and
81248`-- \spad{s} have no polynomial parts. \spad{D} is the derivation to use on \spadtype{UP}.
81426`\spad{HermiteIntegrate(f,{} ')} returns \spad{[g,{}h]} such that \spad{f = g' + h} and \spad{h} has a only simple finite normal poles.
81539`\spad{Is([e1,{}...,{}en],{} pat)} matches the pattern pat on the list of expressions \spad{[e1,{}...,{}en]} and returns the result.
81659`\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a list of matches \spad{[v1 = e1,{}...,{}vn = en]}; returns an empty list if either \spad{expr} is exactly equal to pat or if pat does not match \spad{expr}.
81820`\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a list of matches \spad{[v1 = e1,{}...,{}vn = en]}; returns an empty list if either \spad{expr} is exactly equal to pat or if pat does not match \spad{expr}.
81941`\spad{Is(expr,{} pat)} matches the pattern pat on the expression \spad{expr} and returns a match of the form \spad{[v1 = e1,{}...,{}vn = en]}; returns an empty match if \spad{expr} is exactly equal to pat. returns a \spadfun{failed} match if pat does not match \spad{expr}.
82320`\spad{LE(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x<=y}.
82528`\spad{LODO2FUN(op)} returns the function to pass to the series ODE solver in order to solve \spad{op y = 0}.
82597`\spad{LT(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x<y}.
82805`\spad{LagrangeInterpolation(l1,{}l2)} \undocumented
82901`\axiom{\spad{Lazard2}(\spad{F},{} \spad{x},{} \spad{y},{} \spad{n})} computes \axiom{(x/y)\spad{**}(\spad{n}-1) * \spad{F}}
82991`\axiom{\spad{LazardQuotient2}(\spad{p},{}a,{}\spad{b},{}\spad{n})} returns \axiom{(a**(\spad{n}-1) * \spad{p}) exquo \spad{b**}(\spad{n}-1)} assuming that this quotient does not fail.
83111`\axiom{LazardQuotient(a,{}\spad{b},{}\spad{n})} returns \axiom{a**n exquo \spad{b**}(\spad{n}-1)} assuming that this quotient does not fail.
83227`\axiom{Lazard(\spad{x},{} \spad{y},{} \spad{n})} computes \axiom{x**n/y**(\spad{n}-1)}
83308`\axiom{LiePolyIfCan(\spad{p})} returns \axiom{\spad{p}} in Lyndon basis if \axiom{\spad{p}} is a Lie polynomial,{} otherwise \axiom{"failed"} is returned.
83414`\axiom{LiePolyIfCan(\spad{p})} return \axiom{\spad{p}} if \axiom{\spad{p}} is a Lie polynomial.
83512`\axiom{LiePoly(\spad{l})} returns the bracketed form of \axiom{\spad{l}} as a Lie polynomial.
83584`\spad{ListOfTerms([l1]*[l2]*...[ln])} returns the list of words \spad{l1,{} l2,{} .... ln}.
83681`\axiom{ListOfTerms(\spad{p})} returns the internal representation of \axiom{\spad{p}}.
83805`\spad{ListOfTerms(x)} returns a list \spad{lt} of terms with type \spad{Record(k: Basis,{} c: R)} such that \spad{x} equals \spad{reduce(+,{} map(x +-> monom(x.k,{} x.c),{} lt))}.
83886`\spad{LowTriBddDenomInv(B,{}d)} returns \spad{M},{} where \spad{B} is a non-singular lower triangular matrix and \spad{d} is an element of \spad{R} such that \spad{M = d * inv(B)} has entries in \spad{R}.
83967`\axiom{LyndonBasis(\spad{lv})} returns the Lyndon basis of the nilpotent free Lie algebra.
84071`\axiom{LyndonCoordinates(\spad{g})} returns the exponential coordinates of \axiom{\spad{g}}.
84180`\axiom{\spad{LyndonWordsList1}(\spad{vl},{} \spad{n})} returns an array of lists of Lyndon words over the alphabet \axiom{\spad{vl}},{} up to order \axiom{\spad{n}}.
84292`\axiom{LyndonWordsList(\spad{vl},{} \spad{n})} returns the list of Lyndon words over the alphabet \axiom{\spad{vl}},{} up to order \axiom{\spad{n}}.
84382`\spad{NOT(x)} returns the \axiomType{Switch} expression representing \spad{\~~x}.
84502`\spad{NOT(x)} returns the \axiomType{Switch} expression representing \spad{\~~x}.
84536`\spad{Not(n)} returns the bit-by-bit logical {\em Not} of \spad{n}.
84579`\spad{Not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.
84620`\spad{Nul()} gives the basis element 1 for the algebra generated by \spad{n} generators.
84675`\spad{ODESolve(args)} performs the integration of the function given the strategy or method returned by \axiomFun{measure}.
84944`\spad{OMParseError?(u)} tests whether \spad{u} is an OpenMath parsing error.
85004`\spad{OMReadError?(u)} tests whether \spad{u} is an OpenMath read error.
85063`\spad{OMUnknownCD?(u)} tests whether \spad{u} is an OpenMath unknown \spad{CD} error.
85122`\spad{OMUnknownSymbol?(u)} tests whether \spad{u} is an OpenMath unknown symbol error.
85185`\spad{OMbindTCP}
85256`\spad{OMcloseConn}
85312`\spad{OMclose(dev)} closes \axiom{\spad{dev}},{} flushing output if necessary.
85360`\spad{OMconnInDevice:}
85429`\spad{OMconnOutDevice:}
85499`\spad{OMconnectTCP}
85580`\spad{OMencodingBinary()} is the constant for the OpenMath binary encoding.
85635`\spad{OMencodingSGML()} is the constant for the deprecated OpenMath SGML encoding.
85688`\spad{OMencodingUnknown()} is the constant for unknown encoding types. If this is used on an input device,{} the encoding will be autodetected. It is invalid to use it on an output device.
85744`\spad{OMencodingXML()} is the constant for the OpenMath \spad{XML} encoding.
85796`\spad{OMgetApp(dev)} reads a begin application token from \axiom{\spad{dev}}.
85845`\spad{OMgetAtp(dev)} reads a begin attribute pair token from \axiom{\spad{dev}}.
85894`\spad{OMgetAttr(dev)} reads a begin attribute token from \axiom{\spad{dev}}.
85944`\spad{OMgetBVar(dev)} reads a begin bound variable list token from \axiom{\spad{dev}}.
85994`\spad{OMgetBind(dev)} reads a begin binder token from \axiom{\spad{dev}}.
86044`\spad{OMgetEndApp(dev)} reads an end application token from \axiom{\spad{dev}}.
86096`\spad{OMgetEndAtp(dev)} reads an end attribute pair token from \axiom{\spad{dev}}.
86148`\spad{OMgetEndAttr(dev)} reads an end attribute token from \axiom{\spad{dev}}.
86201`\spad{OMgetEndBVar(dev)} reads an end bound variable list token from \axiom{\spad{dev}}.
86254`\spad{OMgetEndBind(dev)} reads an end binder token from \axiom{\spad{dev}}.
86307`\spad{OMgetEndError(dev)} reads an end error token from \axiom{\spad{dev}}.
86361`\spad{OMgetEndObject(dev)} reads an end object token from \axiom{\spad{dev}}.
86416`\spad{OMgetError(dev)} reads a begin error token from \axiom{\spad{dev}}.
86467`\spad{OMgetFloat(dev)} reads a float from \axiom{\spad{dev}}.
86525`\spad{OMgetInteger(dev)} reads an integer from \axiom{\spad{dev}}.
86581`\spad{OMgetObject(dev)} reads a begin object token from \axiom{\spad{dev}}.
86633`\spad{OMgetString(dev)} reads a string from \axiom{\spad{dev}}.
86687`\spad{OMgetSymbol(dev)} reads a symbol from \axiom{\spad{dev}}.
86764`\spad{OMgetType(dev)} returns the type of the next object on \axiom{\spad{dev}}.
86816`\spad{OMgetVariable(dev)} reads a variable from \axiom{\spad{dev}}.
86872`\spad{OMlistCDs()} lists all the \spad{CDs} supported by AXIOM.
86929`\spad{OMlistSymbols(cd)} lists all the symbols in \axiom{\spad{cd}}.
86996`\spad{OMmakeConn}
87060`\spad{OMopenFile(f,{}mode,{}enc)} opens file \axiom{\spad{f}} for reading or writing OpenMath objects (depending on \axiom{\spad{mode}} which can be \spad{"r"},{} \spad{"w"} or "a" for read,{} write and append respectively),{} in the encoding \axiom{\spad{enc}}.
87137`\spad{OMopenString(s,{}mode)} opens the string \axiom{\spad{s}} for reading or writing OpenMath objects in encoding \axiom{enc}.
87209`\spad{OMputApp(dev)} writes a begin application token to \axiom{\spad{dev}}.
87258`\spad{OMputAtp(dev)} writes a begin attribute pair token to \axiom{\spad{dev}}.
87307`\spad{OMputAttr(dev)} writes a begin attribute token to \axiom{\spad{dev}}.
87357`\spad{OMputBVar(dev)} writes a begin bound variable list token to \axiom{\spad{dev}}.
87407`\spad{OMputBind(dev)} writes a begin binder token to \axiom{\spad{dev}}.
87457`\spad{OMputEndApp(dev)} writes an end application token to \axiom{\spad{dev}}.
87509`\spad{OMputEndAtp(dev)} writes an end attribute pair token to \axiom{\spad{dev}}.
87561`\spad{OMputEndAttr(dev)} writes an end attribute token to \axiom{\spad{dev}}.
87614`\spad{OMputEndBVar(dev)} writes an end bound variable list token to \axiom{\spad{dev}}.
87667`\spad{OMputEndBind(dev)} writes an end binder token to \axiom{\spad{dev}}.
87720`\spad{OMputEndError(dev)} writes an end error token to \axiom{\spad{dev}}.
87774`\spad{OMputEndObject(dev)} writes an end object token to \axiom{\spad{dev}}.
87829`\spad{OMputError(dev)} writes a begin error token to \axiom{\spad{dev}}.
87880`\spad{OMputFloat(dev,{}i)} writes the float \axiom{\spad{i}} to \axiom{\spad{dev}}.
87943`\spad{OMputInteger(dev,{}i)} writes the integer \axiom{\spad{i}} to \axiom{\spad{dev}}.
88004`\spad{OMputObject(dev)} writes a begin object token to \axiom{\spad{dev}}.
88056`\spad{OMputString(dev,{}i)} writes the string \axiom{\spad{i}} to \axiom{\spad{dev}}.
88115`\spad{OMputSymbol(dev,{}cd,{}s)} writes the symbol \axiom{\spad{s}} from \spad{CD} \axiom{\spad{cd}} to \axiom{\spad{dev}}.
88181`\spad{OMputVariable(dev,{}i)} writes the variable \axiom{\spad{i}} to \axiom{\spad{dev}}.
88242`\spad{OMreadFile(f)} reads an OpenMath object from \axiom{\spad{f}} and passes it to AXIOM.
88297`\spad{OMreadStr(f)} reads an OpenMath object from \axiom{\spad{f}} and passes it to AXIOM.
88351`\spad{OMread(dev)} reads an OpenMath object from \axiom{\spad{dev}} and passes it to AXIOM.
88410`\spad{OMreceive(c)} reads an OpenMath object from connection \axiom{\spad{c}} and returns the appropriate AXIOM object.
88482`\spad{OMsend(c,{}u)} attempts to output \axiom{\spad{u}} on \aciom{\spad{c}} in OpenMath.
88556`\spad{OMserve(portnum,{}timeout)} puts AXIOM into server mode on port number \axiom{\spad{portnum}}. The parameter \axiom{\spad{timeout}} specifies the \spad{timeout} period for the connection.
88636`\spad{OMsetEncoding(dev,{}enc)} sets the encoding used for reading or writing OpenMath objects to or from \axiom{\spad{dev}} to \axiom{\spad{enc}}.
88707`\spad{OMsupportsCD?(cd)} returns \spad{true} if AXIOM supports \axiom{\spad{cd}},{} \spad{false} otherwise.
88769`\spad{OMsupportsSymbol?(s,{}cd)} returns \spad{true} if AXIOM supports symbol \axiom{\spad{s}} from \spad{CD} \axiom{\spad{cd}},{} \spad{false} otherwise.
88842`\spad{OMunhandledSymbol(s,{}cd)} raises an error if AXIOM reads a symbol which it is unable to handle. Note that this is different from an unexpected symbol.
88977`\spad{OMwrite(u)} returns the OpenMath \spad{XML} encoding of \axiom{\spad{u}} as a complete OpenMath object.
89172`\spad{OMwrite(dev,{} u)} writes the OpenMath form of \axiom{\spad{u}} to the OpenMath device \axiom{\spad{dev}} as a complete OpenMath object.
89229`\spad{OMwrite(u,{} true)} returns the OpenMath \spad{XML} encoding of \axiom{\spad{u}} as a complete OpenMath object; OMwrite(\spad{u},{} \spad{false}) returns the OpenMath \spad{XML} encoding of \axiom{\spad{u}} as an OpenMath fragment.
89367`\spad{OMwrite(dev,{} u,{} true)} writes the OpenMath form of \axiom{\spad{u}} to the OpenMath device \axiom{\spad{dev}} as a complete OpenMath object; OMwrite(\spad{dev},{} \spad{u},{} \spad{false}) writes the object as an OpenMath fragment.
89432`\spad{OR(x,{}y)} returns the \axiomType{Switch} expression representing \spad{x or y}.
89640`\spad{Or(n,{}m)} returns the bit-by-bit logical {\em Or} of \spad{n} and \spad{m}.
89685`\spad{Or(n,{}m)} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
89728`\spad{PDESolve(args)} performs the integration of the function given the strategy or method returned by \axiomFun{measure}.
90073`\spad{ParCondList(c,{}r)} computes a list of subdeterminants of each rank \spad{>=} \spad{r} of the matrix \spad{c} and returns a groebner basis for the ideal they generate
90289`\spad{ParCond(m,{}k)} returns the list of all \spad{k} by \spad{k} subdeterminants in the matrix \spad{m}
90445`\spad{PollardSmallFactor(n)} returns a factor of \spad{n} or "failed" if no one is found
90532`\spad{RF2UTS(f)} converts \spad{f} to a Taylor series.
90618`\spad{ReduceOrder(op,{} s)} returns \spad{op1} such that for any solution \spad{z} of \spad{op1 z = 0},{} \spad{y = s \int z} is a solution of \spad{op y = 0}. \spad{s} must satisfy \spad{op s = 0}.
90675`\spad{ReduceOrder(op,{} [f1,{}...,{}fk])} returns \spad{[op1,{}[g1,{}...,{}gk]]} such that for any solution \spad{z} of \spad{op1 z = 0},{} \spad{y = gk \int(g_{k-1} \int(... \int(g1 \int z)...)} is a solution of \spad{op y = 0}. Each \spad{\spad{fi}} must satisfy \spad{op \spad{fi} = 0}.
90832`\spad{RemainderList(p)} returns the regular part of \spad{p} as a list of terms.
91017`\axiom{RittWuCompare(a,{}\spad{b})} returns \axiom{"failed"} if \axiom{a} and \axiom{\spad{b}} have same rank \spad{w}.\spad{r}.\spad{t}. Ritt and Wu Wen Tsun ordering using the refinement of Lazard,{} otherwise returns \axiom{infRittWu?(a,{}\spad{b})}.
91113`\spad{SEGMENT(x)} creates the prefix form: \spad{x..}.
91155`\spad{l..} produces a half open segment,{} that is,{} one with no upper bound.
91205`\spad{SEGMENT(x,{}y)} creates the infix form: \spad{x..y}.
91250`\spad{l..h} creates a segment with \spad{l} and \spad{h} as the endpoints.
91301`\spad{SFunction(\spad{li})} is the \spad{S}-function of the partition \spad{\spad{li}} \indented{1}{expressed in terms of power sum symmetric functions.}
91397`\spad{ScanArabic(s)} forms an integer from an Arabic numeral string \spad{s}.
91462`\spad{ScanFloatIgnoreSpacesIfCan(s)} tries to form a floating point number from the string \spad{s} ignoring any spaces.
91549`\spad{ScanFloatIgnoreSpaces(s)} forms a floating point number from the string \spad{s} ignoring any spaces. Error is generated if the string is not recognised as a floating point number.
91615`\spad{ScanRoman(s)} forms an integer from a Roman numeral string \spad{s}.
91679`\spad{\spad{Si}(f)} denotes the sine integral
91728`\spad{\spad{Si}(x)} returns the sine integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{sin(x) / x dx}.
91782`\spad{SturmHabichtCoefficients(p1,{}p2)} computes the principal Sturm-Habicht coefficients of \spad{p1} and \spad{p2}
91909`\spad{SturmHabichtMultiple(p1,{}p2)} computes \spad{c_}{+}\spad{-c_}{-} where \spad{c_}{+} is the number of real roots of \spad{p1} with \spad{p2>0} and \spad{c_}{-} is the number of real roots of \spad{p1} with \spad{p2<0}. If \spad{p2=1} what you get is the number of real roots of \spad{p1}.
92048`\spad{SturmHabichtSequence(p1,{}p2)} computes the Sturm-Habicht sequence of \spad{p1} and \spad{p2}
92195`\spad{SturmHabicht(p1,{}p2)} computes \spad{c_}{+}\spad{-c_}{-} where \spad{c_}{+} is the number of real roots of \spad{p1} with \spad{p2>0} and \spad{c_}{-} is the number of real roots of \spad{p1} with \spad{p2<0}. If \spad{p2=1} what you get is the number of real roots of \spad{p1}.
92310`\spad{UP2UTS(p)} converts \spad{p} to a Taylor series.
92365`\spad{UP2ifCan(x)} should be local but conditional.
92567`\spad{UTS2UP(s,{} n)} converts the first \spad{n} terms of \spad{s} to a univariate polynomial.
92641`\spad{UnVectorise(v)} \undocumented
92699`\spad{UpTriBddDenomInv(B,{}d)} returns \spad{M},{} where \spad{B} is a non-singular upper triangular matrix and \spad{d} is an element of \spad{R} such that \spad{M = d * inv(B)} has entries in \spad{R}.
92779`\spad{Vectorise(x)} \undocumented
92835`\spad{Y(f)} computes a fixed point of the function \spad{f}.
92923`\spad{Y(g,{}n)} computes a fixed point of the function \spad{g},{} where \spad{g} takes a list of \spad{n} streams and returns a list of \spad{n} streams.
93106`\spadignore{ \/ } returns the logical `join',{} \spadignore{e.g.} `or'.
93141`\spad{n} \spad{\/} \spad{m} returns the bit-by-bit logical {\em or} of the single integers \spad{n} and \spad{m}.
93184`\spad{f ^= g} creates the equivalent infix form.
93259`\spad{^ b} returns the logical {\em not} of bit aggregate \axiom{\spad{b}}.
93297`\spad{^ n} returns the negation of \spad{n}.
93746`\spad{x^n} returns \spad{x} raised to the integer power \spad{n}.
93792`\spad{x^n} returns \spad{x} raised to the integer power \spad{n}.
93831`\spad{x^n} returns the repeated product of \spad{x} \spad{n} times,{} \spadignore{i.e.} exponentiation.
93882`\spad{x^n} returns the repeated product of \spad{x} \spad{n} times,{} \spadignore{i.e.} exponentiation.
93933`\spad{aCubic(f,{}g,{}h,{}j)} \undocumented
93999`\spad{aLinear(f,{}g)} \undocumented
94062`\spad{aQuadratic(f,{}g,{}h)} \undocumented
94130`\spad{aQuartic(f,{}g,{}h,{}i,{}k)} \undocumented
94200`\spad{abelianGroup([n1,{}...,{}nk])} constructs the abelian group that is the direct product of cyclic groups with order {\em \spad{ni}}.
94303`\spad{abs(f)} returns the absolute value operator applied to \spad{f}
94525`\spad{abs(o)} computes the absolute value of an octonion,{} equal to the square root of the \spadfunFrom{norm}{Octonion}.
94594`\spad{abs(q)} computes the absolute value of quaternion \spad{q} (sqrt of norm).
94665`\spad{abs(x)} returns the absolute value of \spad{x} = sqrt(norm(\spad{x})).
94734`\spad{abs(x)} returns the absolute value of \spad{x}.
94773`\spad{abs x} returns the absolute value of \spad{x}.
94817`\spad{abs(x)} returns the absolute value of \spad{x}.
94868`\spad{abs(x)} represents the Fortran intrinsic function ABS
94948`\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?
95033`\spad{absolutelyIrreducible?()} tests if the curve absolutely irreducible?
95115`\spad{accuracyIF(o)} returns the intensity value of the accuracy requirements of the input ODE. A request of accuracy of 10^-6 corresponds to the neutral intensity. It returns a value in the range [0,{}1].
95358`\spad{acosIfCan(z)} returns acos(\spad{z}) if possible,{} and "failed" otherwise.
95439`\spad{acos(x)} applies the inverse cosine operator to \spad{x}
95649`\spad{acos(st)} computes arccosine of a power series \spad{st}.
95733`\spad{acos(st)} computes arccosine of a power series \spad{st}.
95831`\spad{acos(z)} returns the arc-cosine of Laurent series \spad{z}.
95918`\spad{acos(z)} returns the arc-cosine of a Puiseux series \spad{z}.
96014`\spad{acos(x)} returns the arc-cosine of \spad{x}.
96075`\spad{acos(x)} represents the Fortran intrinsic function ACOS
96156`\spad{acoshIfCan(z)} returns acosh(\spad{z}) if possible,{} and "failed" otherwise.
96238`\spad{acosh(x)} applies the inverse hyperbolic cosine operator to \spad{x}
96452`\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \spad{st}.
96537`\spad{acosh(st)} computes the inverse hyperbolic cosine of a power series \spad{st}.
96636`\spad{acosh(z)} returns the inverse hyperbolic cosine of Laurent series \spad{z}.
96724`\spad{acosh(z)} returns the inverse hyperbolic cosine of a Puiseux series \spad{z}.
96821`\spad{acosh(x)} returns the hyperbolic arc-cosine of \spad{x}.
96880`\spad{acotIfCan(z)} returns acot(\spad{z}) if possible,{} and "failed" otherwise.
96961`\spad{acot(x)} applies the inverse cotangent operator to \spad{x}
97128`\spad{acot(st)} computes arccotangent of a power series \spad{st}.
97212`\spad{acot(st)} computes arccotangent of a power series \spad{st}.
97310`\spad{acot(z)} returns the arc-cotangent of Laurent series \spad{z}.
97397`\spad{acot(z)} returns the arc-cotangent of a Puiseux series \spad{z}.
97493`\spad{acot(x)} returns the arc-cotangent of \spad{x}.
97554`\spad{acothIfCan(z)} returns acoth(\spad{z}) if possible,{} and "failed" otherwise.
97636`\spad{acoth(x)} applies the inverse hyperbolic cotangent operator to \spad{x}
97806`\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \spad{st}.
97891`\spad{acoth(st)} computes the inverse hyperbolic cotangent of a power series \spad{st}.
97990`\spad{acoth(z)} returns the inverse hyperbolic cotangent of Laurent series \spad{z}.
98078`\spad{acoth(z)} returns the inverse hyperbolic cotangent of a Puiseux series \spad{z}.
98175`\spad{acoth(x)} returns the hyperbolic arc-cotangent of \spad{x}.
98234`\spad{acscIfCan(z)} returns acsc(\spad{z}) if possible,{} and "failed" otherwise.
98315`\spad{acsc(x)} applies the inverse cosecant operator to \spad{x}
98484`\spad{acsc(st)} computes arccosecant of a power series \spad{st}.
98568`\spad{acsc(st)} computes arccosecant of a power series \spad{st}.
98666`\spad{acsc(z)} returns the arc-cosecant of Laurent series \spad{z}.
98753`\spad{acsc(z)} returns the arc-cosecant of a Puiseux series \spad{z}.
98849`\spad{acsc(x)} returns the arc-cosecant of \spad{x}.
98910`\spad{acschIfCan(z)} returns acsch(\spad{z}) if possible,{} and "failed" otherwise.
98992`\spad{acsch(x)} applies the inverse hyperbolic cosecant operator to \spad{x}
99162`\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \spad{st}.
99247`\spad{acsch(st)} computes the inverse hyperbolic cosecant of a power series \spad{st}.
99346`\spad{acsch(z)} returns the inverse hyperbolic cosecant of Laurent series \spad{z}.
99434`\spad{acsch(z)} returns the inverse hyperbolic cosecant of a Puiseux series \spad{z}.
99531`\spad{acsch(x)} returns the hyperbolic arc-cosecant of \spad{x}.
99590`\spad{adaptive3D?()} determines whether plotting be done adaptively.
99635`\spad{adaptive?()} determines whether plotting be done adaptively
99676`\spad{adaptive()} determines whether plotting will be done adaptively.
99728`\spad{adaptive(true)} turns adaptive plotting on; \spad{adaptive(false)} turns adaptive plotting off.
99787`\spad{adaptive(b)} turns adaptive 2D plotting on if \spad{b} is \spad{true},{} or off if \spad{b} is \spad{false}. This option is expressed in the form \spad{adaptive == b}.
99835`\spad{adaptive(l,{}b)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{adaptive}. If the option does not exist the value,{} \spad{b} is returned.
99915`\spad{addBadValue(p,{} v)} adds \spad{v} to the list of "bad values" for \spad{p}; \spad{p} is not allowed to match any of its "bad values".
99991`\spad{addBadValue(p,{} v)} adds \spad{v} to the list of "bad values" for \spad{p}. Note: \spad{p} is not allowed to match any of its "bad values".
100041`\spad{addMatchRestricted(var,{} expr,{} r,{} val)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} provided that \spad{expr} satisfies the predicates attached to \spad{var},{} that \spad{var} is not matched to another expression already,{} and that either \spad{var} is an optional pattern variable or that \spad{expr} is not equal to val (usually an identity).
100122`\spad{addMatch(var,{} expr,{} r)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} provided that \spad{expr} satisfies the predicates attached to \spad{var},{} and that \spad{var} is not matched to another expression already.
100191`\spad{addPoint2(s,{}p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. The subspace \spad{s} is returned with the additional point.
100247`\spad{addPointLast(s,{}s2,{}\spad{li},{}p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. \spad{s2} point to the end of the subspace \spad{s}. \spad{n} is the path in the \spad{s2} component. The subspace \spad{s} is returned with the additional point.
100328`\spad{addPoint(s,{}p)} adds the point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s},{} and returns the new total number of points in \spad{s}.
100399`\spad{addPoint(s,{}\spad{li},{}i)} adds the 4 dimensional point indicated by the index location,{} \spad{i},{} to the 3 dimensional subspace,{} \spad{s}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\spad{'s} length should range from 0 to \spad{n - 1} where \spad{n} is the dimension o
100399`--f the subspace. If the length is \spad{n - 1},{} then a specific lowest level component is being referenced. If it is less than \spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \spad{s} is returned with the additional point.
100489`\spad{addPoint(s,{}\spad{li},{}p)} adds the 4 dimensional point,{} \spad{p},{} to the 3 dimensional subspace,{} \spad{s}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the point is to be added. It\spad{'s} length should range from 0 to \spad{n - 1} where \spad{n} is the dimension of the subspace. If the length is \spad{n 
100489`--- 1},{} then a specific lowest level component is being referenced. If it is less than \spad{n - 1},{} then some higher level component (0 indicates top level component) is being referenced and a component of that level with the desired point is created. The subspace \spad{s} is returned with the additional point.
100569`\spad{addiag(x)} performs diagonal addition of a stream of streams. if \spad{x} = \spad{[[a<0,{}0>,{}a<0,{}1>,{}..],{}[a<1,{}0>,{}a<1,{}1>,{}..],{}[a<2,{}0>,{}a<2,{}1>,{}..],{}..]} and \spad{addiag(x) = [b<0,{}b<1>,{}...],{} then b<k> = sum(i+j=k,{}a<i,{}j>)}.
100653`\spad{addmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a+b mod p}.
100842`\spad{adjoint(m)} returns the ajoint matrix of \spad{m} (\spadignore{i.e.} the matrix \spad{n} such that \spad{m*n} = determinant(\spad{m})*id) and the detrminant of \spad{m}.
100958`\spad{adjoint(a)} returns the adjoint operator of a.
101035`\spad{adjoint(op)} returns the adjoint of the operator \spad{op}.
101171`\spad{adjoint(op1,{} op2)} sets the adjoint of \spad{op1} to be \spad{op2}. \spad{op1} must be a basic operator
101247`\spad{airyAi(x)} returns the airyai function applied to \spad{x}
101306`\spad{airyAi(x)} is the Airy function \spad{\spad{Ai}(x)}. This function satisfies the differential equation: \indented{2}{\spad{\spad{Ai}''(x) - x * \spad{Ai}(x) = 0}.}
101400`\spad{airyAi(x)} is the Airy function \spad{\spad{Ai}(x)}. This function satisfies the differential equation: \indented{2}{\spad{\spad{Ai}''(x) - x * \spad{Ai}(x) = 0}.}
101476`\spad{airyAi(x)} is the Airy function \spad{\spad{Ai}(x)}.
101530`\spad{airyBi(x)} returns the airybi function applied to \spad{x}
101589`\spad{airyBi(x)} is the Airy function \spad{\spad{Bi}(x)}. This function satisfies the differential equation: \indented{2}{\spad{\spad{Bi}''(x) - x * \spad{Bi}(x) = 0}.}
101683`\spad{airyBi(x)} is the Airy function \spad{\spad{Bi}(x)}. This function satisfies the differential equation: \indented{2}{\spad{\spad{Bi}''(x) - x * \spad{Bi}(x) = 0}.}
101759`\spad{airyBi(x)} is the Airy function \spad{\spad{Bi}(x)}.
101813`\spad{algDsolve(op,{} g)} returns \spad{["failed",{} []]} if the equation \spad{op y = g} has no solution in \spad{R}. Otherwise,{} it returns \spad{[f,{} [y1,{}...,{}ym]]} where \spad{f} is a particular rational solution and the \spad{y_i's} form a basis for the solutions in \spad{R} of the homogeneous equation.
102076`\spad{algSplitSimple(f,{} D)} returns \spad{[h,{}d,{}d',{}g]} such that \spad{f=h/d},{} \spad{h} is integral at all the normal places \spad{w}.\spad{r}.\spad{t}. \spad{D},{} \spad{d' = Dd},{} \spad{g = gcd(d,{} discriminant())} and \spad{D} is the derivation to use. \spad{f} must have at most simple finite poles.
102316`\spad{algebraic?(a)} tests whether an element \spad{a} is algebraic with respect to the ground field \spad{F}.
102442`\axiom{algebraic?(\spad{v},{}\spad{ts})} returns \spad{true} iff \axiom{\spad{v}} is the main variable of some polynomial in \axiom{\spad{ts}}.
102602`\spad{algebraicCoefficients?(p,{}ts)} returns \spad{true} iff every variable of \spad{p} which is not the main one of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.
102993`\axiom{algebraicOf(char)} is the external number
103131`\axiom{algebraicSort(\spad{lts})} sorts \axiom{\spad{lts}} \spad{w}.\spad{r}.\spad{t} \axiomOpFrom{supDimElseRittWu?}{QuasiComponentPackage}.
103214`\axiom{algebraicSort(\spad{lts})} sorts \axiom{\spad{lts}} \spad{w}.\spad{r}.\spad{t} \axiomOpFrom{supDimElseRittWu}{QuasiComponentPackage}.
103382`\axiom{algebraicVariables(\spad{ts})} returns the decreasingly sorted list of the main variables of the polynomials of \axiom{\spad{ts}}.
103460`\spad{algint(f,{} x,{} y,{} d)} returns the integral of \spad{f(x,{}y)dx} where \spad{y} is an algebraic function of \spad{x}; \spad{d} is the derivation to use on \spad{k[x]}.
103616`\spad{algintegrate(f,{} d)} integrates \spad{f} with respect to the derivation \spad{d}.
104195`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104278`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104351`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104419`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104518`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104607`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} naming each uniquely
104691`\axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} in the Real Closure,{} assumed in order.
104787`\spad{alphabetic?(c)} tests if \spad{c} is a letter,{} \spadignore{i.e.} one of a..\spad{z} or A..\spad{Z}.
104837`\spad{alphabetic()} returns the class of all characters for which \spadfunFrom{alphabetic?}{Character} is \spad{true}.
104884`\spad{alphanumeric?(c)} tests if \spad{c} is either a letter or number,{} \spadignore{i.e.} one of 0..9,{} a..\spad{z} or A..\spad{Z}.
104936`\spad{alphanumeric()} returns the class of all characters for which \spadfunFrom{alphanumeric?}{Character} is \spad{true}.
104985`\spad{alternatingGroup(\spad{li})} constructs the alternating group acting on the integers in the list {\em \spad{li}},{} generators are in general the {\em n-2}-cycle {\em (\spad{li}.3,{}...,{}\spad{li}.n)} and the 3-cycle {\em (\spad{li}.1,{}\spad{li}.2,{}\spad{li}.3)},{} if \spad{n} is odd and product of the 2-cycle {\em (\spad{li}.1,{}\spad{li}.2)} with {\em n-2}-cycle {\em (\spad{li}.3,{}...,{}\spad{
104985`--li}.n)} and the 3-cycle {\em (\spad{li}.1,{}\spad{li}.2,{}\spad{li}.3)},{} if \spad{n} is even. Note: duplicates in the list will be removed.
105084`\spad{alternatingGroup(n)} constructs the alternating group {\em An} acting on the integers 1,{}...,{}\spad{n},{} generators are in general the {\em n-2}-cycle {\em (3,{}...,{}n)} and the 3-cycle {\em (1,{}2,{}3)} if \spad{n} is odd and the product of the 2-cycle {\em (1,{}2)} with {\em n-2}-cycle {\em (3,{}...,{}n)} and the 3-cycle {\em (1,{}2,{}3)} if \spad{n} is even.
105185`\spad{alternating n} is the cycle index of the \indented{1}{alternating group of degree \spad{n}.}
105277`\spad{alternative?()} tests if \spad{2*associator(a,{}a,{}b) = 0 = 2*associator(a,{}b,{}b)} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
105354`\spad{alternative?()} tests if \spad{2*associator(a,{}a,{}b) = 0 = 2*associator(a,{}b,{}b)} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
105428`\spad{f and g} creates the equivalent infix form.
105469`\spad{a and b} returns the logical {\em and} of bit aggregates \axiom{a} and \axiom{\spad{b}}.
105512`\spad{a and b} returns the logical {\em and} of Boolean \spad{a} and \spad{b}.
105550`\spad{anfactor(p)} tries to factor \spad{p} over algebraic numbers,{} returning "failed" if it cannot
105734`\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \spadignore{i.e.} \spad{(a*b)*c + a*(b*c) = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra.
105815`\spad{antiAssociative?()} tests if multiplication in algebra is anti-associative,{} \spadignore{i.e.} \spad{(a*b)*c + a*(b*c) = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra.
105893`\spad{antiCommutative?()} tests if \spad{a*a = 0} for all \spad{a} in the algebra. Note: this implies \spad{a*b + b*a = 0} for all \spad{a} and \spad{b}.
105974`\spad{antiCommutative?()} tests if \spad{a*a = 0} for all \spad{a} in the algebra. Note: this implies \spad{a*b + b*a = 0} for all \spad{a} and \spad{b}.
106107`\spad{antiCommutator(a,{}b)} returns \spad{a*b+b*a}.
106166`\spad{anticoord }\undocumented
106499`\spad{antisymmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and antisymmetric (\spadignore{i.e.} \spad{m[i,{}j] = -m[j,{}i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.
106568`\spad{antisymmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and antisymmetric (\spadignore{i.e.} \spad{m[i,{}j] = -m[j,{}i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.
106652`\spad{antisymmetricTensors(la,{}n)} applies to each \spad{m}-by-\spad{m} square matrix in the list {\em la} the irreducible,{} polynomial representation of the general linear group {\em GLm} which corresponds to the partition {\em (1,{}1,{}...,{}1,{}0,{}0,{}...,{}0)} of \spad{n}. Error: if \spad{n} is greater than \spad{m}. Note: this corresponds to the symme
106652`--trization of the representation with the sign representation of the symmetric group {\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \spad{n}-fold tensor product.
106798`\spad{antisymmetricTensors(a,{}n)} applies to the square matrix {\em a} the irreducible,{} polynomial representation of the general linear group {\em GLm},{} where \spad{m} is the number of rows of {\em a},{} which corresponds to the partition {\em (1,{}1,{}...,{}1,{}0,{}0,{}...,{}0)} of \spad{n}. Error: if \spad{n} is greater than \spad{m}. Note: this corresponds to the
106798`-- symmetrization of the representation with the sign representation of the symmetric group {\em Sn}. The carrier spaces of the representation are the antisymmetric tensors of the \spad{n}-fold tensor product.
107447`\spad{any?(p,{}u)} tests if \axiom{\spad{p}(\spad{x})} is \spad{true} for any element \spad{x} of \spad{u}. Note: for collections,{} \axiom{any?(\spad{p},{}\spad{u}) = reduce(or,{}map(\spad{f},{}\spad{u}),{}\spad{false},{}\spad{true})}.
107551`\spad{any(type,{}object)} is a technical function for creating an \spad{object} of \spadtype{Any}. Arugment \spad{type} is a \spadgloss{LISP} form for the \spad{type} of \spad{object}.
107596`\spad{appendPoint(\spad{gi},{}pt)} appends the point \spad{pt} to the end of the list of points component for the graph,{} \spad{\spad{gi}},{} which is of the domain \spadtype{GraphImage}.
107663`\spad{append(u1,{}u2)} appends the elements of list \spad{u1} onto the front of list \spad{u2}. This new list and \spad{u2} will share some structure.
107818`\spad{applyQuote(foo,{} [x1,{}...,{}xn])} returns \spad{'foo(x1,{}...,{}xn)}.
107882`\spad{applyQuote(foo,{} x)} returns \spad{'foo(x)}.
107996`\spad{applyQuote(foo,{} x,{} y)} returns \spad{'foo(x,{}y)}.
108115`\spad{applyQuote(foo,{} x,{} y,{} z)} returns \spad{'foo(x,{}y,{}z)}.
108239`\spad{applyQuote(foo,{} x,{} y,{} z,{} t)} returns \spad{'foo(x,{}y,{}z,{}t)}.
108306`\spad{applyRules([r1,{}...,{}rn],{} expr)} applies the rules \spad{r1},{}...,{}\spad{rn} to \spad{f} an unlimited number of times,{} \spadignore{i.e.} until none of \spad{r1},{}...,{}\spad{rn} is applicable to the expression.
108387`\spad{applyRules([r1,{}...,{}rn],{} expr,{} n)} applies the rules \spad{r1},{}...,{}\spad{rn} to \spad{f} a most \spad{n} times.
108550`\spad{apply(m,{}a)} defines a left operation of \spad{n} by \spad{n} matrices where \spad{n} is the rank of the algebra in terms of matrix-vector multiplication,{} this is a substitute for a left module structure. Error: if shape of matrix doesn\spad{'t} fit.
108620`\spad{apply(p,{} f,{} m)} returns \spad{p(m)} where the action is given by \spad{x m = f(m)}. \spad{f} must be an \spad{R}-pseudo linear map on \spad{M}.
108693`\spad{apply(p,{} c,{} m)} returns \spad{p(m)} where the action is given by \spad{x m = c sigma(m) + delta(m)}.
108761`\spad{apply(p,{} c,{} m,{} sigma,{} delta)} returns \spad{p(m)} where the action is given by \spad{x m = c sigma(m) + delta(m)}.
108856`\spad{approxRoot(n,{}r)} returns an approximation \spad{x} to \spad{n**(1/r)} such that \spad{-1 < x - n**(1/r) < 1}
108926`\spad{approxSqrt(n)} returns an approximation \spad{x} to \spad{sqrt(n)} such that \spad{-1 < x - sqrt(n) < 1}. Compute an approximation \spad{s} to \spad{sqrt(n)} such that \indented{10}{\spad{-1 < s - sqrt(n) < 1}} A variable precision Newton iteration is used. The running time is \spad{O( log(n)**2 )}.
108974`\spad{approximants(x)} returns the stream of approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be infinite and periodic with period 1.
109196`\spad{approximate(x,{}n)} returns a rational number \spad{y} such that \spad{y = x (mod p^n)}.
109288`\spad{approximate(f)} returns a truncated power series with the series variable viewed as an element of the coefficient domain.
109459`\spad{approximate(x,{}n)} returns an integer \spad{y} such that \spad{y = x (mod p^n)} when \spad{n} is positive,{} and 0 otherwise.
109531`\axiom{approximate(\spad{n},{}\spad{p})} gives an approximation of \axiom{\spad{n}} that has precision \axiom{\spad{p}}
109600`\axiom{approximate(term,{}root,{}prec)} gives an approximation of \axiom{term} over \axiom{root} with precision \axiom{prec}
109709`\spad{areEquivalent?(aG0,{}aG1)} calls {\em areEquivalent?(aG0,{}aG1,{}true,{}25)}. Note: the choice of 25 was rather arbitrary.
109821`\spad{areEquivalent?(aG0,{}aG1,{}numberOfTries)} calls {\em areEquivalent?(aG0,{}aG1,{}true,{}25)}. Note: the choice of 25 was rather arbitrary.
109941`\spad{areEquivalent?(aG0,{}aG1,{}randomelements,{}numberOfTries)} tests whether the two lists of matrices,{} all assumed of same square shape,{} can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators,{} the representations are equivalent. The algorithm tries {\em numberOfTries} times to create elements in the generated 
109941`--algebras in the same fashion. If their ranks differ,{} they are not equivalent. If an isomorphism is assumed,{} then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (\spadignore{e.g.} irreducibility !) we use {\em standardBasisOfCyclicSubmodule} to create the only possible transition matrix. The method checks whether the matrix conjugates all corresp
109941`--onding matrices from {\em aGi}. The way to choose the singular matrices is as in {\em meatAxe}. If the two representations are equivalent,{} this routine returns the transformation matrix {\em TM} with {\em aG0.i * TM = TM * aG1.i} for all \spad{i}. If the representations are not equivalent,{} a small 0-matrix is returned. Note: the case with different sets of group generators cannot be handled.
110069`\spad{arg1(a,{}c)} selects its first argument.
110131`\spad{arg2(a,{}c)} selects its second argument.
110193`\spad{argscript(s,{} [a1,{}...,{}an])} returns \spad{s} arg-scripted by \spad{[a1,{}...,{}an]}.
110250`\spad{argumentList!(l)} declares that the argument list for the current subprogram in the global symbol table is \spad{l}.
110314`\spad{argumentList!(f,{}l)} declares that the argument list for subprogram \spad{f} in the global symbol table is \spad{l}.
110385`\spad{argumentList!(f,{}l,{}tab)} declares that the argument list for subprogram \spad{f} in symbol table \spad{tab} is \spad{l}.
110459`\spad{argumentListOf(f,{}tab)} returns the argument list of \spad{f}
110576`\spad{argument(x)} returns the argument of a given sin/cos expressions
110627`\spad{argument(op(a1,{}...,{}an))} returns \spad{[a1,{}...,{}an]}.
110674`\spad{argument(x)} returns the angle made by (0,{}1) and (0,{}\spad{x}).
110761`\spad{arity(op)} returns \spad{n} if \spad{op} is \spad{n}-ary,{} and "failed" if \spad{op} has arbitrary arity.
110836`\spad{aromberg(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax,{}nint)} uses the adaptive romberg method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary fr
110836`--om \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
111010`\spad{arrayStack([x,{}y,{}...,{}z])} creates an array stack with first (top) element \spad{x},{} second element \spad{y},{}...,{}and last element \spad{z}.
111063`\spad{asecIfCan(z)} returns asec(\spad{z}) if possible,{} and "failed" otherwise.
111144`\spad{asec(x)} applies the inverse secant operator to \spad{x}
111313`\spad{asec(st)} computes arcsecant of a power series \spad{st}.
111397`\spad{asec(st)} computes arcsecant of a power series \spad{st}.
111495`\spad{asec(z)} returns the arc-secant of Laurent series \spad{z}.
111582`\spad{asec(z)} returns the arc-secant of a Puiseux series \spad{z}.
111678`\spad{asec(x)} returns the arc-secant of \spad{x}.
111739`\spad{asechIfCan(z)} returns asech(\spad{z}) if possible,{} and "failed" otherwise.
111821`\spad{asech(x)} applies the inverse hyperbolic secant operator to \spad{x}
111991`\spad{asech(st)} computes the inverse hyperbolic secant of a power series \spad{st}.
112076`\spad{asech(st)} computes the inverse hyperbolic secant of a power series \spad{st}.
112175`\spad{asech(z)} returns the inverse hyperbolic secant of Laurent series \spad{z}.
112263`\spad{asech(z)} returns the inverse hyperbolic secant of a Puiseux series \spad{z}.
112360`\spad{asech(x)} returns the hyperbolic arc-secant of \spad{x}.
112419`\spad{asimpson(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax,{}nint)} uses the adaptive simpson method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary fr
112419`--om \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
112593`\spad{asinIfCan(z)} returns asin(\spad{z}) if possible,{} and "failed" otherwise.
112674`\spad{asin(x)} applies the inverse sine operator to \spad{x}
112884`\spad{asin(st)} computes arcsine of a power series \spad{st}.
112968`\spad{asin(st)} computes arcsine of a power series \spad{st}.
113066`\spad{asin(z)} returns the arc-sine of Laurent series \spad{z}.
113153`\spad{asin(z)} returns the arc-sine of a Puiseux series \spad{z}.
113249`\spad{asin(x)} returns the arc-sine of \spad{x}.
113310`\spad{asin(x)} represents the Fortran intrinsic function ASIN
113391`\spad{asinhIfCan(z)} returns asinh(\spad{z}) if possible,{} and "failed" otherwise.
113473`\spad{asinh(x)} applies the inverse hyperbolic sine operator to \spad{x}
113687`\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \spad{st}.
113772`\spad{asinh(st)} computes the inverse hyperbolic sine of a power series \spad{st}.
113871`\spad{asinh(z)} returns the inverse hyperbolic sine of Laurent series \spad{z}.
113959`\spad{asinh(z)} returns the inverse hyperbolic sine of a Puiseux series \spad{z}.
114056`\spad{asinh(x)} returns the hyperbolic arc-sine of \spad{x}.
114115`\spad{aspFilename("f")} returns a String consisting of \spad{"f"} suffixed with \indented{1}{an extension identifying the current AXIOM session.}
114180`\spad{assert(x,{} s)} makes the assertion \spad{s} about \spad{x}. Error: if \spad{x} is not a symbol.
114244`\spad{assert(x,{} s)} makes the assertion \spad{s} about \spad{x}.
114325`\spad{assert(op,{} s)} attaches property \spad{s} to \spad{op}. Argument \spad{op} is modified "in place",{} \spadignore{i.e.} no copy is made.
114376`\spad{assign(f,{}g)} creates a form for the assignment \spad{f := g}.
114420`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114493`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114557`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114623`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114696`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114767`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114840`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114921`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
114993`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115067`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115148`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115227`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115308`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115377`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115444`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115513`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115566`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115647`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115719`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115793`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115874`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
115953`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
116034`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
116103`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
116170`\spad{assign(x,{}y)} creates a representation of the FORTRAN expression x=y.
116239`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116338`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116428`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116520`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116619`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116716`\spad{assign(x,{}l,{}y)} creates a representation of the assignment of \spad{y} to the \spad{l}\spad{'}th element of array \spad{x} (\spad{l} is a list of indices).
116815`\spad{assoc(k,{}u)} returns the element \spad{x} in association list \spad{u} stored with key \spad{k},{} or "failed" if \spad{u} has no key \spad{k}.
116925`\spad{associatedEquations(op,{} m)} returns \spad{[w,{} eq,{} lw,{} lop]} such that \spad{eq(w) = 0} where \spad{w} is the given minor,{} and \spad{lw_i = lop_i(w)} for all the other minors.
117105`\spad{associatedSystem(op,{} m)} returns \spad{[M,{}w]} such that the \spad{m}-th associated equation system to \spad{L} is \spad{w' = M w}.
117339`\spad{associates?(x,{}y)} tests whether \spad{x} and \spad{y} are associates,{} \spadignore{i.e.} differ by a unit factor.
117397`\spad{associative?()} tests if multiplication in algebra is associative.
117474`\spad{associative?()} tests if multiplication in algebra is associative.
117548`\spad{associatorDependence()} looks for the associator identities,{} \spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \spad{associator(a,{}b,{}c)} which yield 0,{} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra. The order of the permutations is \spad{123 231 312 132 321 213}.
117641`\spad{associatorDependence()} looks for the associator identities,{} \spadignore{i.e.} finds a basis of the solutions of the linear combinations of the six permutations of \spad{associator(a,{}b,{}c)} which yield 0,{} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra. The order of the permutations is \spad{123 231 312 132 321 213}.
117805`\spad{associator(a,{}b,{}c)} returns \spad{(a*b)*c-a*(b*c)}.
117863`\spad{atanIfCan(z)} returns atan(\spad{z}) if possible,{} and "failed" otherwise.
117944`\spad{atan(x)} applies the inverse tangent operator to \spad{x}
118098`\spad{atan(st)} computes arctangent of a power series \spad{st}.
118182`\spad{atan(st)} computes arctangent of a power series \spad{st}.
118280`\spad{atan(z)} returns the arc-tangent of Laurent series \spad{z}.
118367`\spad{atan(z)} returns the arc-tangent of a Puiseux series \spad{z}.
118463`\spad{atan(x)} returns the arc-tangent of \spad{x}.
118524`\spad{atan(x)} represents the Fortran intrinsic function ATAN
118605`\spad{atan(x,{}y)} computes the arc tangent from \spad{x} with phase \spad{y}.
118648`\spad{atan(x,{}y)} computes the arc tangent from \spad{x} with phase \spad{y}.
118685`\spad{atanhIfCan(z)} returns atanh(\spad{z}) if possible,{} and "failed" otherwise.
118767`\spad{atanh(x)} applies the inverse hyperbolic tangent operator to \spad{x}
118981`\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \spad{st}.
119066`\spad{atanh(st)} computes the inverse hyperbolic tangent of a power series \spad{st}.
119165`\spad{atanh(z)} returns the inverse hyperbolic tangent of Laurent series \spad{z}.
119253`\spad{atanh(z)} returns the inverse hyperbolic tangent of a Puiseux series \spad{z}.
119350`\spad{atanh(x)} returns the hyperbolic arc-tangent of \spad{x}.
119409`\spad{atom?(s)} is \spad{true} if \spad{s} is a Lisp atom.
119485`\spad{atoms(r)} returns the list of matches that match atoms (elements of the lists).
119565`\spad{atrapezoidal(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax,{}nint)} uses the adaptive trapezoidal method to numerically integrate function \spad{fn} over the closed interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence chec
119565`--king vary from \spad{nmin} to \spad{nmax},{} and where \spad{nint} is the number of independent intervals to apply the integrator. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
119743`\spad{att2Result(m)} converts a attributes record into a \axiomType{Result}
120769`\spad{augment(lp,{}lts)} returns the same as \spad{concat([augment(lp,{}ts) for ts in lts])}
120858`\spad{augment(lp,{}ts)} returns \spad{ts} if \spad{empty? lp},{} \spad{augment(p,{}ts)} if \spad{lp = [p]},{} otherwise \spad{augment(first lp,{} augment(rest lp,{} ts))}
120941`\spad{augment(p,{}lts)} returns the same as \spad{concat([augment(p,{}ts) for ts in lts])}
121024`\spad{augment(p,{}ts)} assumes that \spad{p} is a non-constant polynomial whose main variable is greater than any variable of \spad{ts}. This operation assumes also that if \spad{p} is added to \spad{ts} the resulting set,{} say \spad{ts+p},{} is a regular triangular set. Then it returns a split of Kalkbrener of \spad{ts+p}. This may not be \spad{ts+p} itself,{} if for instance \spad{ts+p} is required to be square-free.
121191`\axiom{autoReduced?(\spad{ts},{}redOp?)} returns \spad{true} iff every element of \axiom{\spad{ts}} is reduced \spad{w}.\spad{r}.\spad{t} to every other in the sense of \axiom{redOp?}
121284`\spad{axesColorDefault()} returns the default color of the axes in a 2D viewport.
121347`\spad{axesColorDefault(p)} sets the default color of the axes in a 2D viewport to the palette \spad{p}.
121417`\spad{axes(v,{}s)} displays the axes of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or does not display the axes if \spad{s} is "off".
121479`\spad{axes(v,{}n,{}c)} displays the axes of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with the axes color set to the given palette color \spad{c}.
121556`\spad{axes(v,{}n,{}s)} displays the axes of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the axes if \spad{s} is "off".
121632`\spad{backOldPos(genPos)} takes the result produced by \spadfunFrom{generalPosition}{PolynomialIdeals} and performs the inverse transformation,{} returning the original ideal \spad{backOldPos(generalPosition(I,{}listvar))} = \spad{I}.
121755`\spad{back(q)} returns the element at the back of the queue. The queue \spad{q} is unchanged by this operation. Error: if \spad{q} is empty.
121800`\spad{badNum(p)} \undocumented
121896`\spad{badNum(u)} \undocumented
121967`\spad{badValues(p)} returns the list of "bad values" for \spad{p}; \spad{p} is not allowed to match any of its "bad values".
122081`\spad{bag([x,{}y,{}...,{}z])} creates a bag with elements \spad{x},{}\spad{y},{}...,{}\spad{z}.
122129`\spad{balancedBinaryTree(n,{} s)} creates a balanced binary tree with \spad{n} nodes each with value \spad{s}.
122211`\spad{balancedFactorisation(a,{} [b1,{}...,{}bn])} returns a factorisation \spad{a = p1^e1 ... pm^em} such that each \spad{pi} is balanced with respect to \spad{[b1,{}...,{}bm]}.
122303`\spad{balancedFactorisation(a,{} b)} returns a factorisation \spad{a = p1^e1 ... pm^em} such that each \spad{\spad{pi}} is balanced with respect to \spad{b}.
122389`\spad{bandedHessian(v,{}xlist,{}k)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in \spad{xlist},{} \spad{k} is the semi-bandwidth,{} the number of nonzero subdiagonals,{} 2*k+1 being actual bandwidth. Stores the nonzero band in lower triangle in a matrix,{} dimensions \spad{k+1} by \#xlist,{} 
122389`--whose rows are the vectors formed by diagonal,{} subdiagonal,{} etc. of the real,{} full-matrix,{} hessian. (The notation conforms to LAPACK/NAG-\spad{F07} conventions.)
122502`\spad{bandedJacobian(vf,{}xlist,{}kl,{}ku)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in \spad{xlist},{} \spad{kl} is the number of nonzero subdiagonals,{} \spad{ku} is the number of nonzero superdiagonals,{} \spad{kl+ku+1} being actual bandwidth. Stores the n
122502`--onzero band in a matrix,{} dimensions \spad{kl+ku+1} by \#xlist. The upper triangle is in the top \spad{ku} rows,{} the diagonal is in row \spad{ku+1},{} the lower triangle in the last \spad{kl} rows. Entries in a column in the band store correspond to entries in same column of full store. (The notation conforms to LAPACK/NAG-\spad{F07} conventions.)
122638`\spad{baseRDE(f,{} g)} returns a \spad{[y,{} b]} such that \spad{y' + fy = g} if \spad{b = true},{} \spad{y} is a partial solution otherwise (no solution in that case). \spad{D} is the derivation to use.
122756`\spad{baseRDEsys(f,{} g1,{} g2)} returns fractions \spad{y_1.y_2} such that \spad{(y1',{} y2') + ((0,{} -f),{} (f,{} 0)) (y1,{}y2) = (g1,{}g2)} if \spad{y_1,{}y_2} exist,{} "failed" otherwise.
122892`\spad{base()} returns the base of the \spadfunFrom{exponent}{FloatingPointSystem}.
122951`\spad{base()} returns the base of the model
123003`\spad{base()} returns the base for the operations of \spad{IntegerNumberSystem}.
123049`\spad{base(b)} sets the base of the model to \spad{b}
123116`\spad{base(gp)} returns a base for the group {\em gp}.
123289`\axiom{basicSet(\spad{ps},{}redOp?)} returns \axiom{[\spad{bs},{}\spad{ts}]} where \axiom{concat(\spad{bs},{}\spad{ts})} is \axiom{\spad{ps}} and \axiom{\spad{bs}} is a basic set in Wu Wen Tsun sense of \axiom{\spad{ps}} \spad{w}.\spad{r}.\spad{t} the reduction-test \axiom{redOp?},{} if no non-zero constant polynomial lie in \axiom{\spad{ps}},{} otherwise \axiom{"failed"} is return
123289`--ed.
123545`\axiom{basicSet(\spad{ps},{}pred?,{}redOp?)} returns the same as \axiom{basicSet(\spad{qs},{}redOp?)} where \axiom{\spad{qs}} consists of the polynomials of \axiom{\spad{ps}} satisfying property \axiom{pred?}.
123681`\spad{basisOfCenter()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{commutator(x,{}a) = 0} and \spad{associator(x,{}a,{}b) = associator(a,{}x,{}b) = associator(a,{}b,{}x) = 0} for all \spad{a},{}\spad{b} in \spad{A}.
123741`\spad{basisOfCentroid()} returns a basis of the centroid,{} \spadignore{i.e.} the endomorphism ring of \spad{A} considered as \spad{(A,{}A)}-bimodule.
123811`\spad{basisOfCommutingElements()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = commutator(x,{}a)} for all \spad{a} in \spad{A}.
123882`\spad{basisOfLeftAnnihilator(a)} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = x*a}.
123952`\spad{basisOfLeftNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(x,{}a,{}b)} for all \spad{a},{}\spad{b} in \spad{A}.
124017`\spad{basisOfLeftNucloid()} returns a basis of the space of endomorphisms of \spad{A} as right module. Note: left nucloid coincides with left nucleus if \spad{A} has a unit.
124090`\spad{basisOfMiddleNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(a,{}x,{}b)} for all \spad{a},{}\spad{b} in \spad{A}.
124157`\spad{basisOfNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{associator(x,{}a,{}b) = associator(a,{}x,{}b) = associator(a,{}b,{}x) = 0} for all \spad{a},{}\spad{b} in \spad{A}.
124218`\spad{basisOfRightAnnihilator(a)} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = a*x}.
124289`\spad{basisOfRightNucleus()} returns a basis of the space of all \spad{x} of \spad{A} satisfying \spad{0 = associator(a,{}b,{}x)} for all \spad{a},{}\spad{b} in \spad{A}.
124355`\spad{basisOfRightNucloid()} returns a basis of the space of endomorphisms of \spad{A} as left module. Note: right nucloid coincides with right nucleus if \spad{A} has a unit.
124484`\spad{basis()} returns a fixed basis of \spad{\$} as \spad{F}-vectorspace.
124552`\spad{basis()} returns the fixed \spad{R}-module basis.
124607`\spad{basis()} returns the fixed \spad{R}-module basis.
124673`\spad{basis(n)} \undocumented{} See \axiomFunFrom{basis}{FiniteAlgebraicExtensionField}
124766`\spad{basis((f1,{}...,{}fn))} returns the vector \spad{[f1,{}...,{}fn]}.
124828`\spad{basis((f1,{}...,{}fn))} = the vector \spad{[f1,{}...,{}fn]}.
124894`\spad{basis(n)} returns a fixed basis of a subfield of \spad{\$} as \spad{F}-vectorspace.
124977`\spad{basis(va)} selects a basis from the elements of \spad{va}.
125062`\spad{bat1(llp)} unbumps a tableau \spad{llp}. Operation \spad{bat1} is the inverse of \spad{tab1}.
125137`\spad{bat(ls)} unbumps a tableau \spad{ls}
125208`\spad{beauzamyBound(p)} returns a bound on the larger coefficient of any factor of \spad{p}.
125292`\spad{belong?(op)} is \spad{true} if \spad{op} is an algebraic operator,{} that is,{} an \spad{n}th root or implicit algebraic operator.
125362`\spad{belong?(op)} is \spad{true} if \spad{op} is a combinatorial operator.
125436`\spad{belong?(p)} returns \spad{true} if operator \spad{p} is elementary
125507`\spad{belong?(op)} is \spad{true} if \spad{op} is a special function operator.
125585`\spad{belong?(op)} checks if \spad{op} is Liouvillian
125657`\spad{belong?(op)} tests if \% accepts \spad{op} as applicable to its elements.
125786`\spad{belong?(op)} tests if \% accepts \spad{op} as applicable to its elements.
125849`\spad{bernoulliB(n,{}r)} \undocumented
125971`\spad{bernoulli(n)} returns the \spad{n}th Bernoulli polynomial \spad{B[n](x)}. Note: Bernoulli polynomials denoted \spad{B(n,{}x)} computed by solving the differential equation \spad{differentiate(B(n,{}x),{}x) = n B(n-1,{}x)} where \spad{B(0,{}x) = 1} and initial condition comes from \spad{B(n) = B(n,{}0)}.
126084`\spad{bernoulli(n)} returns the \spad{n}th Bernoulli number. this is \spad{B(n,{}0)},{} where \spad{B(n,{}x)} is the \spad{n}th Bernoulli polynomial.
126166`\spad{besselI(x,{}y)} returns the besseli function applied to \spad{x} and \spad{y}
126228`\spad{besselI(v,{}x)} is the modified Bessel function of the first kind,{} \spad{I(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.}
126344`\spad{besselI(v,{}x)} is the modified Bessel function of the first kind,{} \spad{I(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.}
126433`\spad{besselI(v,{}z)} is the modified Bessel function of the first kind.
126491`\spad{besselJ(x,{}y)} returns the besselj function applied to \spad{x} and \spad{y}
126553`\spad{besselJ(v,{}x)} is the Bessel function of the first kind,{} \spad{J(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.}
126669`\spad{besselJ(v,{}x)} is the Bessel function of the first kind,{} \spad{J(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.}
126758`\spad{besselJ(v,{}z)} is the Bessel function of the first kind.
126816`\spad{besselK(x,{}y)} returns the besselk function applied to \spad{x} and \spad{y}
126878`\spad{besselK(v,{}x)} is the modified Bessel function of the first kind,{} \spad{K(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.} Note: The default implmentation uses the relation \indented{2}{\spad{K(v,{}x) = \%pi/2*(I(-v,{}x) - I(v,{}x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.
126994`\spad{besselK(v,{}x)} is the modified Bessel function of the first kind,{} \spad{K(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.} Note: The default implmentation uses the relation \indented{2}{\spad{K(v,{}x) = \%pi/2*(I(-v,{}x) - I(v,{}x))/sin(v*\%\spad{pi})}.} so is not valid for integer values of \spad{v}.
127083`\spad{besselK(v,{}z)} is the modified Bessel function of the second kind.
127141`\spad{besselY(x,{}y)} returns the bessely function applied to \spad{x} and \spad{y}
127203`\spad{besselY(v,{}x)} is the Bessel function of the second kind,{} \spad{Y(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.} Note: The default implmentation uses the relation \indented{2}{\spad{Y(v,{}x) = (J(v,{}x) cos(v*\%\spad{pi}) - J(-v,{}x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.
127319`\spad{besselY(v,{}x)} is the Bessel function of the second kind,{} \spad{Y(v,{}x)}. This function satisfies the differential equation: \indented{2}{\spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.} Note: The default implmentation uses the relation \indented{2}{\spad{Y(v,{}x) = (J(v,{}x) cos(v*\%\spad{pi}) - J(-v,{}x))/sin(v*\%\spad{pi})}} so is not valid for integer values of \spad{v}.
127408`\spad{besselY(v,{}z)} is the Bessel function of the second kind.
127466`\spad{bezoutDiscriminant(p)} computes the discriminant of a polynomial \spad{p} by computing the determinant of a Bezout matrix.
127570`\spad{bezoutMatrix(p,{}q)} returns the Bezout matrix for the two polynomials \spad{p} and \spad{q}.
127637`\spad{bezoutResultant(p,{}q)} computes the resultant of the two polynomials \spad{p} and \spad{q} by computing the determinant of a Bezout matrix.
127741`\spad{bfEntry(k)} returns the entry in the \axiomType{BasicFunctions} table corresponding to \spad{k}
127881`\spad{bfKeys()} returns the names of each function in the \axiomType{BasicFunctions} table
127934`\spad{biRank(x)} determines the number of linearly independent elements in \spad{x},{} \spad{x*bi},{} \spad{bi*x},{} \spad{bi*x*bj},{} \spad{i,{}j=1,{}...,{}n},{} where \spad{b=[b1,{}...,{}bn]} is a basis. Note: if \spad{A} has a unit,{} then \spadfunFrom{doubleRank}{AlgebraPackage},{} \spadfunFrom{weakBiRank}{AlgebraPackage} and \spadfunFrom{biRank}{AlgebraPackage} coincide.
127999`\spad{binaryFunction(s)} is a local function
128087`\spad{binarySearchTree(l)} \undocumented
128152`\spad{binaryTournament(ls)} creates a binary tournament with the elements of \spad{ls} as values at the nodes.
128217`\spad{binaryTree(v)} is an non-empty binary tree with value \spad{v},{} and left and right empty.
128264`\spad{binaryTree(l,{}v,{}r)} creates a binary tree with value \spad{v} with left subtree \spad{l} and right subtree \spad{r}.
128317`\spad{binary(r)} converts a rational number to a binary expansion.
128378`\spad{binary(op,{} [a1,{}...,{}an])} returns the input form corresponding to \spad{a1 op a2 op ... op an}.
128509`\spad{binomThmExpt(p,{}q,{}n)} returns \spad{(x+y)^n} by means of the binomial theorem trick.
128618`\spad{binomial(n,{} r)} returns the number of subsets of \spad{r} objects taken among \spad{n} objects,{} \spadignore{i.e.} \spad{n!/}(\spad{r!} * (\spad{n}-\spad{r})!).
128677`\spad{binomial(n,{}f)} \undocumented
128816`\spad{binomial(n,{}m)} creates a form for the binomial coefficient of \spad{n} and \spad{m}.
128862`\spad{binomial(n,{}r)} returns the binomial coefficient \spad{C(n,{}r) = n!/(r! (n-r)!)},{} where \spad{n >= r >= 0}. This is the number of combinations of \spad{n} objects taken \spad{r} at a time.
128926`\spad{binomial(n,{}r)} returns the \spad{(n,{}r)} binomial coefficient (often denoted in the literature by \spad{C(n,{}r)}). Note: \spad{C(n,{}r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.
128991`\spad{bipolarCylindrical(a)} transforms from bipolar cylindrical coordinates to Cartesian coordinates: \spad{bipolarCylindrical(a)} is a function which will map the point \spad{(u,{}v,{}z)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \spad{y = a*sin(u)/(cosh(v)-cos(u))},{} \spad{z}.
129071`\spad{bipolar(a)} transforms from bipolar coordinates to Cartesian coordinates: \spad{bipolar(a)} is a function which will map the point \spad{(u,{}v)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},{} \spad{y = a*sin(u)/(cosh(v)-cos(u))}.
129140`\spad{birth(x)} \undocumented
129236`\spad{bit?(n,{}i)} returns \spad{true} if and only if \spad{i}-th bit of \spad{n} is a 1.
129292`\spad{bitCoef(n,{}m)} returns the coefficient of 2**m in abs(\spad{n})
129353`\spad{bitLength(n)} returns the number of bits to represent abs(\spad{n})
129408`\spad{bitTruth(n,{}m)} returns \spad{true} if coefficient of 2**m in abs(\spad{n}) is 1
129470`\spad{bits()} returns ceiling\spad{'s} precision in bits.
129529`\spad{bits(n)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{n} bits.
129640`\spad{bits(n,{}b)} creates bits with \spad{n} values of \spad{b}
129697`\axiom{bivariate?(\spad{p})} returns \spad{true} iff \axiom{\spad{p}} involves two and only two variables.
129774`\axiom{bivariatePolynomials(\spad{lp})} returns \axiom{\spad{bps},{}nbps} where \axiom{\spad{bps}} is a list of the bivariate polynomials,{} and \axiom{nbps} are the other ones.
129900`\spad{bivariateSLPEBR(lp,{}p,{}v)} implements the bivariate case of \spadfunFrom{solveLinearPolynomialEquationByRecursion}{PolynomialFactorizationByRecursionUnivariate}; its implementation depends on \spad{R}
130107`\spad{blankSeparate(l)} creates the form separating the elements of \spad{l} by blanks.
130161`\spad{block(l)} creates a representation of the statements in \spad{l} as a block.
130208`\spad{blue()} returns the position of the blue hue from total hues.
130240`\spad{bombieriNorm(p)} returns quadratic Bombieri\spad{'s} norm of \spad{p}.
130317`\spad{bombieriNorm(p,{}n)} returns the \spad{n}th Bombieri\spad{'s} norm of \spad{p}.
130410`\spad{bottom!(d)} returns the element at the bottom (back) of the dequeue.
130460`\axiom{boundOfCauchy(\spad{p})} bounds the roots of \spad{p}
130668`\spad{box(f)} encloses \spad{f} in a box.
130706`\spad{box([f1,{}...,{}fn])} returns \spad{(f1,{}...,{}fn)} with a 'box' around them that prevents the \spad{fi} from being evaluated when operators are applied to them,{} and makes them applicable to a unary operator. For example,{} \spad{atan(box [x,{} 2])} returns the formal kernel \spad{atan(x,{} 2)}.
130755`\spad{box(f)} returns \spad{f} with a 'box' around it that prevents \spad{f} from being evaluated when operators are applied to it. For example,{} \spad{log(1)} returns 0,{} but \spad{log(box 1)} returns the formal kernel log(1).
130844`\spad{brace()}\$\spad{D} (otherwise written {}\$\spad{D}) creates an empty set aggregate of type \spad{D}. This form is considered obsolete. Use \axiomFun{set} instead.
130940`\spad{brace(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in curly brackets.
130986`\spad{brace(f)} creates the form enclosing \spad{f} in braces (curly brackets).
131026`\spad{brace([x,{}y,{}...,{}z])} creates a set aggregate containing items \spad{x},{}\spad{y},{}...,{}\spad{z}. This form is considered obsolete. Use \axiomFun{set} instead.
131076`\spad{bracket(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in square brackets.
131124`\spad{bracket(f)} creates the form enclosing \spad{f} in square brackets.
131166`\axiom{branchIfCan(leq,{}\spad{ts},{}lineq,{}\spad{b1},{}\spad{b2},{}\spad{b3},{}\spad{b4},{}\spad{b5})} is an internal subroutine,{} exported only for developement.
131345`\axiom{branchIfCan(leq,{}\spad{ts},{}lineq,{}\spad{b1},{}\spad{b2},{}\spad{b3},{}\spad{b4},{}\spad{b5})} is an internal subroutine,{} exported only for developement.
131534`\spad{branchPoint?(a)} tests whether \spad{x = a} is a branch point.
131607`\spad{branchPoint?(p)} tests whether \spad{p(x) = 0} is a branch point.
131681`\spad{branchPointAtInfinity?()} tests if there is a branch point at infinity.
131763`\spad{bright(c)} sets the shade of a hue,{} \spad{c},{} above dim,{} but below pastel.
131804`\spad{bright(l)} sets the font property of a list of strings,{} \spad{l},{} to bold-face type.
131869`\spad{bright(s)} sets the font property of the string \spad{s} to bold-face type.
131928`\spad{brillhartIrreducible?(p)} returns \spad{true} if \spad{p} can be shown to be irreducible by a remark of Brillhart,{} \spad{false} is inconclusive.
131997`\spad{brillhartIrreducible?(p,{}noLinears)} returns \spad{true} if \spad{p} can be shown to be irreducible by a remark of Brillhart,{} \spad{false} else. If \spad{noLinears} is \spad{true},{} we are being told \spad{p} has no linear factors \spad{false} does not mean that \spad{p} is reducible.
132074`\spad{brillhartTrials()} returns the number of tests in \spadfun{brillhartIrreducible?}.
132146`\spad{brillhartTrials(n)} sets to \spad{n} the number of tests in \spadfun{brillhartIrreducible?} and returns the previous value.
132236`\spad{bringDown(f)} \undocumented
132308`\spad{bringDown(f,{}k)} \undocumented
132418`\spad{bsolve(c,{} w,{} r,{} s,{} m)} returns a list of regimes and solutions of the system \spad{c} \spad{z} = \spad{w} for ranks at least \spad{r}; depending on the mode \
132418`--spad{m} chosen,{} it writes the output to a file given by the string \spad{s}.
132753`\spad{btwFact(p,{}sqf,{}pd,{}r)} returns the factorization of \spad{p},{} the result is a Record such that \spad{contp=}content \spad{p},{} \spad{factors=}List of irreducible factors of \spad{p} with exponent. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors). \spad{pd} is the \sp
132753`--adtype{Set} of possible degrees. \spad{r} is a lower bound for the number of factors of \spad{p}. Please do not use this function in your code because its design may change.
132921`\spad{bubbleSort!(a)} \undocumented
132988`\spad{bubbleSort!(a,{}f)} \undocumented
133053`\spad{build(r,{}i,{}e)} \undocumented
133126`\spad{bumprow(cf,{}pr,{}r)} is an auxiliary function which bumps a row \spad{r} with a pair \spad{pr} using comparison function \spad{cf},{} and returns a record
133254`\spad{bumptab1(pr,{}t)} bumps a tableau \spad{t} with a pair \spad{pr} using comparison function \spadfun{<},{} returning a new tableau
133347`\spad{bumptab(cf,{}pr,{}t)} bumps a tableau \spad{t} with a pair \spad{pr} using comparison function \spad{cf},{} returning a new tableau
133454`\spad{c02aff(a,{}n,{}scale,{}ifail)} finds all the roots of a complex polynomial equation,{} using a variant of Laguerre\spad{'s} Method. See \downlink{Manual Page}{manpageXXc02aff}.
133555`\spad{c02agf(a,{}n,{}scale,{}ifail)} finds all the roots of a real polynomial equation,{} using a variant of Laguerre\spad{'s} Method. See \downlink{Manual Page}{manpageXXc02agf}.
133656`\spad{c05adf(a,{}b,{}eps,{}eta,{}ifail,{}f)} locates a zero of a continuous function in a given interval by a combination of the methods of linear interpolation,{} extrapolation and bisection. See \downlink{Manual Page}{manpageXXc05adf}.
133795`\spad{c05nbf(n,{}lwa,{}x,{}xtol,{}ifail,{}fcn)} is an easy-to-use routine to find a solution of a system of nonlinear equations by a modification of the Powell hybrid method. See \downlink{Manual Page}{manpageXXc05nbf}.
133936`\spad{c05pbf(n,{}ldfjac,{}lwa,{}x,{}xtol,{}ifail,{}fcn)} is an easy-to-use routine to find a solution of a system of nonlinear equations by a modification of the Powell hybrid method. The user must provide the Jacobian. See \downlink{Manual Page}{manpageXXc05pbf}.
134086`\spad{c06eaf(n,{}x,{}ifail)} calculates the discrete Fourier transform of a sequence of \spad{n} real data values. (No extra workspace required.) See \downlink{Manual Page}{manpageXXc06eaf}.
134179`\spad{c06ebf(n,{}x,{}ifail)} calculates the discrete Fourier transform of a Hermitian sequence of \spad{n} complex data values. (No extra workspace required.) See \downlink{Manual Page}{manpageXXc06ebf}.
134272`\spad{c06ecf(n,{}x,{}y,{}ifail)} calculates the discrete Fourier transform of a sequence of \spad{n} complex data values. (No extra workspace required.) See \downlink{Manual Page}{manpageXXc06ecf}.
134385`\spad{c06ekf(job,{}n,{}x,{}y,{}ifail)} calculates the circular convolution of two real vectors of period \spad{n}. No extra workspace is required. See \downlink{Manual Page}{manpageXXc06ekf}.
134506`\spad{c06fpf(m,{}n,{}init,{}x,{}trig,{}ifail)} computes the discrete Fourier transforms of \spad{m} sequences,{} each containing \spad{n} real data values. This routine is designed to be particularly efficient on vector processors. See \downlink{Manual Page}{manpageXXc06fpf}.
134634`\spad{c06fqf(m,{}n,{}init,{}x,{}trig,{}ifail)} computes the discrete Fourier transforms of \spad{m} Hermitian sequences,{} each containing \spad{n} complex data values. This routine is designed to be particularly efficient on vector processors. See \downlink{Manual Page}{manpageXXc06fqf}.
134762`\spad{c06frf(m,{}n,{}init,{}x,{}y,{}trig,{}ifail)} computes the discrete Fourier transforms of \spad{m} sequences,{} each containing \spad{n} complex data values. This routine is designed to be particularly efficient on vector processors. See \downlink{Manual Page}{manpageXXc06frf}.
134910`\spad{c06fuf(m,{}n,{}init,{}x,{}y,{}trigm,{}trign,{}ifail)} computes the two-dimensional discrete Fourier transform of a bivariate sequence of complex data values. This routine is designed to be particularly efficient on vector processors. See \downlink{Manual Page}{manpageXXc06fuf}.
135078`\spad{c06gbf(n,{}x,{}ifail)} forms the complex conjugate of \spad{n} data values. See \downlink{Manual Page}{manpageXXc06gbf}.
135171`\spad{c06gcf(n,{}y,{}ifail)} forms the complex conjugate of a sequence of \spad{n} data values. See \downlink{Manual Page}{manpageXXc06gcf}.
135264`\spad{c06gqf(m,{}n,{}x,{}ifail)} forms the complex conjugates,{} each containing \spad{n} data values. See \downlink{Manual Page}{manpageXXc06gqf}.
135365`\spad{c06gsf(m,{}n,{}x,{}ifail)} takes \spad{m} Hermitian sequences,{} each containing \spad{n} data values,{} and forms the real and imaginary parts of the \spad{m} corresponding complex sequences. See \downlink{Manual Page}{manpageXXc06gsf}.
135466`\spad{cAcos(f)} computes the arccosine of the power series \spad{f}. For use when the coefficient ring is commutative.
135570`\spad{cAcosh(f)} computes the inverse hyperbolic cosine of the power series \spad{f}. For use when the coefficient ring is commutative.
135675`\spad{cAcot(f)} computes the arccotangent of the power series \spad{f}. For use when the coefficient ring is commutative.
135779`\spad{cAcoth(f)} computes the inverse hyperbolic cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.
135884`\spad{cAcsc(f)} computes the arccosecant of the power series \spad{f}. For use when the coefficient ring is commutative.
135988`\spad{cAcsch(f)} computes the inverse hyperbolic cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.
136093`\spad{cAsec(f)} computes the arcsecant of the power series \spad{f}. For use when the coefficient ring is commutative.
136197`\spad{cAsech(f)} computes the inverse hyperbolic secant of the power series \spad{f}. For use when the coefficient ring is commutative.
136302`\spad{cAsin(f)} computes the arcsine of the power series \spad{f}. For use when the coefficient ring is commutative.
136406`\spad{cAsinh(f)} computes the inverse hyperbolic sine of the power series \spad{f}. For use when the coefficient ring is commutative.
136511`\spad{cAtan(f)} computes the arctangent of the power series \spad{f}. For use when the coefficient ring is commutative.
136615`\spad{cAtanh(f)} computes the inverse hyperbolic tangent of the power series \spad{f}. For use when the coefficient ring is commutative.
136720`\spad{cCos(f)} computes the cosine of the power series \spad{f}. For use when the coefficient ring is commutative.
136823`\spad{cCosh(f)} computes the hyperbolic cosine of the power series \spad{f}. For use when the coefficient ring is commutative.
136927`\spad{cCot(f)} computes the cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.
137030`\spad{cCoth(f)} computes the hyperbolic cotangent of the power series \spad{f}. For use when the coefficient ring is commutative.
137134`\spad{cCsc(f)} computes the cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.
137237`\spad{cCsch(f)} computes the hyperbolic cosecant of the power series \spad{f}. For use when the coefficient ring is commutative.
137341`\spad{cExp(f)} computes the exponential of the power series \spad{f}. For use when the coefficient ring is commutative.
137444`\spad{cLog(f)} computes the logarithm of the power series \spad{f}. For use when the coefficient ring is commutative.
137547`\spad{cPower(f,{}r)} computes \spad{f^r},{} where \spad{f} has constant coefficient 1. For use when the coefficient ring is commutative.
137657`\spad{cRationalPower(f,{}r)} computes \spad{f^r}. For use when the coefficient ring is commutative.
137788`\spad{cSec(f)} computes the secant of the power series \spad{f}. For use when the coefficient ring is commutative.
137891`\spad{cSech(f)} computes the hyperbolic secant of the power series \spad{f}. For use when the coefficient ring is commutative.
137995`\spad{cSin(f)} computes the sine of the power series \spad{f}. For use when the coefficient ring is commutative.
138098`\spad{cSinh(f)} computes the hyperbolic sine of the power series \spad{f}. For use when the coefficient ring is commutative.
138202`\spad{cTan(f)} computes the tangent of the power series \spad{f}. For use when the coefficient ring is commutative.
138305`\spad{cTanh(f)} computes the hyperbolic tangent of the power series \spad{f}. For use when the coefficient ring is commutative.
138409`\spad{cache()} returns the current cache as a list.
138456`\spad{calcRanges(l)} \undocumented
138552`\spad{call(s)} creates a representation of a FORTRAN CALL statement
138596`\spad{cap(s1,{}s2)},{} introduced by Redfield,{} \indented{1}{is the scalar product of two cycle indices.}
138729`\spad{car((a1,{}...,{}an))} returns \spad{a1}.
138868`\spad{cardinality(u)} returns the number of elements of \spad{u}. Note: \axiom{cardinality(\spad{u}) = \#u}.
138941`\spad{cartesian(pt)} returns the Cartesian coordinates of point \spad{pt}.
139007`\spad{cdr((a1,{}...,{}an))} returns \spad{(a2,{}...,{}an)}.
139121`\spad{ceiling(x)} returns the smallest integral element above \spad{x}.
139202`\spad{ceiling x} returns the small integer \spad{>= x}.
139250`\spad{center(f)} centers form \spad{f} in total space.
139291`\spad{center(f)} returns the point about which the series \spad{f} is expanded.
139365`\spad{center(f,{}n)} centers form \spad{f} within space of width \spad{n}.
139414`\spad{center(l,{}i,{}s)} takes a list of strings \spad{l},{} and centers them within a list of strings which is \spad{i} characters long,{} in which the remaining spaces are filled with strings composed of as many repetitions as possible of the last string parameter \spad{s}.
139494`\spad{center(s,{}i,{}s)} takes the first string \spad{s},{} and centers it within a string of length \spad{i},{} in which the other elements of the string are composed of as many replications as possible of the second indicated string,{} \spad{s} which must have a length greater than that of an empty string.
139562`\spad{central?(f,{}g,{}l)} \undocumented{}
139667`\axiom{certainlySubVariety?(newlp,{}\spad{lp})} returns \spad{true} iff for every \axiom{\spad{p}} in \axiom{\spad{lp}} the remainder of \axiom{\spad{p}} by \axiom{newlp} using the division algorithm of Groebner techniques is zero.
139768`\spad{cfirst n} is used internally.
139884`\axiom{chainSubResultants(\spad{P},{} \spad{Q})} computes the list of non zero subresultants of \axiom{\spad{P}} and \axiom{\spad{Q}}.
139973`\spad{changeBase(exp,{}man,{}base)} \undocumented{}
140049`\spad{changeBase(M,{} A,{} sig,{} der)}: computes the new matrix of a pseudo-linear transform given by the matrix \spad{M} under the change of base A
140156`\spad{changeMeasure(R,{}s,{}newValue)} changes the maximum value for a measure of the given NAG routine.
140220`\spad{changeNameToObjf(s,{}r)} changes the name of item \axiom{\spad{s}} in \axiom{\spad{r}} to objf.
140292`\spad{changeName(s,{}t,{}r)} changes the name of item \axiom{\spad{s}} in \axiom{\spad{r}} to \axiom{\spad{t}}.
140365`\spad{changeThreshhold(R,{}s,{}newValue)} changes the value below which,{} given a NAG routine generating a higher measure,{} the routines will make no attempt to generate a measure.
140432`\spad{changeVar(+/[\spad{ai} D^i],{} a)} returns the operator \spad{+/[\spad{ai} (D+a)\spad{^i}]}.
140505`\spad{changeVar(+/[\spad{ai} D^i],{} a)} returns the operator \spad{+/[\spad{ai} (D+a)\spad{^i}]}.
140568`\spad{changeWeightLevel(n)} This changes the weight level to the new value given: \spad{NB:} previously calculated terms are not affected
140672`\spad{changeWeightLevel(n)} changes the weight level to the new value given: \spad{NB:} previously calculated terms are not affected
140779`\spad{charClass(l)} creates a character class which contains exactly the characters given in the list \spad{l}.
140840`\spad{charClass(s)} creates a character class which contains exactly the characters given in the string \spad{s}.
140892`\spad{char(i)} provides a character corresponding to the integer code \spad{i}. It is always \spad{true} that \spad{ord char i = i}.
140935`\spad{char(s)} provides a character from a string \spad{s} of length one.
140977`\spad{character?(t)} tests whether \spad{t} is equivalent to the FORTRAN type CHARACTER.
141034`\spad{characteristicPolynomial(e)} returns the characteristic polynomial of \spad{e} using resultants
141362`\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over complex rationals with a new symbol as variable.
141510`\spad{characteristicPolynomial(m)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over \spad{RN} with a new symbol as variable.
141637`\spad{characteristicPolynomial(m)} returns the characteristicPolynomial of the matrix \spad{m} using a new generated symbol symbol as the main variable.
141741`\spad{characteristicPolynomial(a)} returns the characteristic polynomial of the regular representation of \spad{a} with respect to any basis.
141813`\spad{characteristicPolynomial(m,{}x)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over Complex Rationals with variable \spad{x}.
141968`\spad{characteristicPolynomial(m,{}x)} returns the characteristic polynomial of the matrix \spad{m} expressed as polynomial over \spad{RN} with variable \spad{x}. Fraction \spad{P} \spad{RN}.
142102`\spad{characteristicPolynomial(m,{}var)} returns the characteristicPolynomial of the matrix \spad{m} using the symbol \spad{var} as the main variable.
142213`\spad{characteristicPolynomial(m,{}r)} computes the characteristic polynomial of the matrix \spad{m} evaluated at the point \spad{r}. In particular,{} if \spad{r} is the polynomial \spad{'x},{} then it returns the characteristic polynomial expressed as a polynomial in \spad{'x}.
142304`\axiom{characteristicSerie(\spad{ps})} returns the same as \axiom{characteristicSerie(\spad{ps},{}initiallyReduced?,{}initiallyReduce)}.
142390`\axiom{characteristicSerie(\spad{ps},{}redOp?,{}redOp)} returns a list \axiom{\spad{lts}} of triangular sets such that the zero set of \axiom{\spad{ps}} is the union of the regular zero sets of the members of \axiom{\spad{lts}}. This is made by the Ritt and Wu Wen Tsun process applying the operation \axiom{characteristicSet(\spad{ps},{}redOp?,{}redOp)} to compute characteristic sets in Wu Wen T
142390`--sun sense.
142500`\axiom{characteristicSet(\spad{ps})} returns the same as \axiom{characteristicSet(\spad{ps},{}initiallyReduced?,{}initiallyReduce)}.
142594`\axiom{characteristicSet(\spad{ps},{}redOp?,{}redOp)} returns a non-contradictory characteristic set of \axiom{\spad{ps}} in Wu Wen Tsun sense \spad{w}.\spad{r}.\spad{t} the reduction-test \axiom{redOp?} (using \axiom{redOp} to reduce polynomials \spad{w}.\spad{r}.\spad{t} a \axiom{redOp?} basic set),{} if no non-zero constant polynomial appear during those reductions,{} else \axiom{"fa
142594`--iled"} is returned. The operations \axiom{redOp} and \axiom{redOp?} must satisfy the following conditions: \axiom{redOp?(redOp(\spad{p},{}\spad{q}),{}\spad{q})} holds for every polynomials \axiom{\spad{p},{}\spad{q}} and there exists an integer \axiom{\spad{e}} and a polynomial \axiom{\spad{f}} such that we have \axiom{init(\spad{q})^e*p = \spad{f*q} + redOp(\spad{p},{}\spad{q})}.
143350`\spad{characteristic()} returns the characteristic of the ring.
143421`\spad{characteristic()} returns the characteristic of the ring this is the smallest positive integer \spad{n} such that \spad{n*x=0} for all \spad{x} in the ring,{} or zero if no such \spad{n} exists.
143478`\spad{charpol(m)} computes the characteristic polynomial of a matrix \spad{m} with entries in \spad{K}. This function returns a polynomial over \spad{K},{} while the general one (that is in EiegenPackage) returns Fraction \spad{P} \spad{K}
143993`\spad{charthRoot(x)} returns the \spad{p}th root of \spad{x} where \spad{p} is the characteristic of the ring.
144065`\spad{charthRoot(r)} returns the \spad{p}\spad{-}th root of \spad{r},{} or "failed" if none exists in the domain.
144176`\spad{charthRoot(a)} takes the characteristic'th root of {\em a}. Note: such a root is alway defined in finite fields.
144230`\spad{chebyshevT(n)} returns the \spad{n}th Chebyshev polynomial \spad{T[n](x)}. Note: Chebyshev polynomials of the first kind,{} denoted \spad{T[n](x)},{} computed from the two term recurrence. The generating function \spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x)*t**n,{} n=0..infinity)}.
144334`\spad{chebyshevT(n,{}x)} is the \spad{n}-th Chebyshev polynomial of the first kind,{} \spad{T[n](x)}. These are defined by \spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x) *t**n,{} n = 0..)}.
144418`\spad{chebyshevU(n)} returns the \spad{n}th Chebyshev polynomial \spad{U[n](x)}. Note: Chebyshev polynomials of the second kind,{} denoted \spad{U[n](x)},{} computed from the two term recurrence. The generating function \spad{1/(1-2*t*x+t**2) = sum(T[n](x)*t**n,{} n=0..infinity)}.
144522`\spad{chebyshevU(n,{}x)} is the \spad{n}-th Chebyshev polynomial of the second kind,{} \spad{U[n](x)}. These are defined by \spad{1/(1-2*t*x+t**2) = sum(T[n](x) *t**n,{} n = 0..)}.
144606`\spad{checkForZero(p,{} a,{} b,{} incl?)} is \spad{true} if \spad{p} has a zero between a and \spad{b},{} \spad{false} otherwise,{} "failed" if this cannot be determined. Check for a and \spad{b} inclusive if incl? is \spad{true},{} exclusive otherwise.
144770`\spad{checkForZero(p,{} x,{} a,{} b,{} incl?)} is \spad{true} if \spad{p} has a zero for \spad{x} between a and \spad{b},{} \spad{false} otherwise,{} "failed" if this cannot be determined. Check for a and \spad{b} inclusive if incl? is \spad{true},{} exclusive otherwise.
144925`\spad{checkPrecision()} \undocumented{}
144988`\spad{checkRur(ts,{}lus)} returns \spad{true} if \spad{lus} is a rational univariate representation of \spad{ts}.
145094`\spad{check(s)} returns lllpt,{} list of lists of lists of point information about the \spadtype{ThreeSpace} \spad{s}.
145145`\spad{check should} be local
145345`\spad{chiSquare1(n)} \undocumented
145423`\spad{chiSquare(n)} \undocumented
145617`\spad{child?(u,{}v)} tests if node \spad{u} is a child of node \spad{v}.
145695`\spad{child(x,{}n)} \undocumented
145937`\spad{children(x)} \undocumented
145989`\spad{children(u)} returns a list of the children of aggregate \spad{u}.
146049`\spad{chineseRemainder(llv,{}lm)} returns a list of values,{} each of which corresponds to the Chinese remainder of the associated element of \axiom{\spad{llv}} and axiom{\spad{lm}}. This is more efficient than applying chineseRemainder several times.
146127`\spad{chineseRemainder(lv,{}lm)} returns a value \axiom{\spad{v}} such that,{} if \spad{x} is \axiom{\spad{lv}.\spad{i}} modulo \axiom{\spad{lm}.\spad{i}} for all \axiom{\spad{i}},{} then \spad{x} is \axiom{\spad{v}} modulo \axiom{\spad{lm}(1)\spad{*lm}(2)*...\spad{*lm}(\spad{n})}.
146193`\spad{chineseRemainder(lu,{}lr,{}n)} \undocumented
146415`\spad{chineseRemainder(u1,{}m1,{}u2,{}m2)} returns \spad{w},{} where \spad{w} is such that \spad{w = u1 mod m1} and \spad{w = u2 mod m2}. Note: \spad{m1} and \spad{m2} must be relatively prime.
146518`\spad{choosemon }\undocumented
146696`\spad{chvar(f(x,{}y),{} p(x,{}y))} returns \spad{[g(z,{}t),{} q(z,{}t),{} c1(z),{} c2(z),{} n]} such that under the change of variable \spad{x = c1(z)},{} \spad{y = t * c2(z)},{} one gets \spad{f(x,{}y) = g(z,{}t)}. The algebraic relation between \spad{x} and \spad{y} is \spad{p(x,{} y) = 0}. The algebraic relation between \spad{z} and \spad{t} is \spad{q(z,{} 
146696`--t) = 0}.
146840`\spad{clearCache()} empties the cache.
146889`\spad{clearDenominator([q1,{}...,{}qn])} returns \spad{[p1,{}...,{}pn]} such that \spad{\spad{qi} = pi/d} where \spad{d} is a common denominator for the \spad{qi}\spad{'s}.
146959`\spad{clearDenominator([q1,{}...,{}qn])} returns \spad{[p1,{}...,{}pn]} such that \spad{\spad{qi} = pi/d} where \spad{d} is a common denominator for the \spad{qi}\spad{'s}.
147022`\spad{clearDenominator(q)} returns \spad{p} such that \spad{q = p/d} where \spad{d} is a common denominator for the elements of \spad{q}.
147105`\spad{clearDenominator(q)} returns \spad{p} such that \spad{q = p/d} where \spad{d} is a common denominator for the coefficients of \spad{q}.
147191`\spad{clearFortranOutputStack()} clears the Fortran output stack
147273`\axiom{clearTable!()} clears the hash-table and assumes that it will no longer be used.
147347`\spad{clearTheFTable()} clears the current table of functions.
147411`\spad{clearTheIFTable()} clears the current table of intensity functions.
147477`\spad{clearTheSymbolTable()} clears the current symbol table.
147535`\spad{clearTheSymbolTable(x)} removes the symbol \spad{x} from the table
147599`\spad{clikeUniv(v)} is used internally.
147718`\spad{clipBoolean(l,{}b)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{clipBoolean}. If the option does not exist the value,{} \spad{b} is returned.
147801`\spad{clipParametric(p)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the parametric curve \spad{x = f(t)},{} \spad{y = g(t)}; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \fakeAxiomFun{iClipParametric} subroutine,{} which is called by thi
147801`--s function.
147968`\spad{clipParametric(p,{}frac,{}sc)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the parametric curve \spad{x = f(t)},{} \spad{y = g(t)}; the fraction parameter is specified by \spad{frac} and the scale parameter is specified by \spad{sc} for use in the
147968`-- \fakeAxiomFun{iClipParametric} subroutine,{} which is called by this function.
148171`\spad{clipPointsDefault()} determines whether or not automatic clipping is to be done.
148232`\spad{clipPointsDefault(true)} turns on automatic clipping; \spad{clipPointsDefault(false)} turns off automatic clipping. The default setting is \spad{true}.
148300`\spad{clipSurface(v,{}s)} displays the graph with the specified clipping region removed if \spad{s} is "on",{} or displays the graph without clipping implemented if \spad{s} is "off",{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
148369`\spad{clipWithRanges(pointLists,{}xMin,{}xMax,{}yMin,{}yMax)} performs clipping on a list of lists of points,{} \spad{pointLists}. Clipping is done within the specified ranges of \spad{xMin},{} \spad{xMax} and \spad{yMin},{} \spad{yMax}. This function is used intern
148369`--ally by the \fakeAxiomFun{iClipParametric} subroutine in this package.
148610`\spad{clip(ll)} performs two-dimensional clipping on a list of lists of points,{} \spad{ll}; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \fakeAxiomFun{iClipParametric} subroutine,{} which is called by this function.
148793`\spad{clip(l)} performs two-dimensional clipping on a curve \spad{l},{} which is a list of points; the default parameters \spad{1/2} for the fraction and \spad{5/1} for the scale are used in the \fakeAxiomFun{iClipParametric} subroutine,{} which is called by this function.
148970`\spad{clip(p)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the graph of one variable,{} \spad{y = f(x)}; the default parameters \spad{1/4} for the fraction and \spad{5/1} for the scale are used in the \spadfun{clip} function.
149127`\spad{clip(b)} turns 2D clipping on if \spad{b} is \spad{true},{} or off if \spad{b} is \spad{false}. This option is expressed in the form \spad{clip == b}.
149171`\spad{clip([l])} provides ranges for user-defined clipping as specified in the list \spad{l}. This option is expressed in the form \spad{clip == [l]}.
149228`\spad{clip(p,{}frac,{}sc)} performs two-dimensional clipping on a plot,{} \spad{p},{} from the domain \spadtype{Plot} for the graph of one variable \spad{y = f(x)}; the fraction parameter is specified by \spad{frac} and the scale parameter is specified by \spad{sc} for use in the \spadfun{clip} function.
149421`\spad{close!(f)} returns the file \spad{f} closed to input and output.
149472`\spad{closeComponent(s,{}\spad{li},{}b)} sets the property of the component in the 3 dimensional subspace,{} \spad{s},{} to be closed if \spad{b} is \spad{true},{} or open if \spad{b} is \spad{false}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose closed property is to be set. The subspace,{} \spad{s},{} is returned with 
149472`--the component property modification.
149557`\spad{close(v)} closes the viewport window of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} and terminates the corresponding process ID.
149611`\spad{close(v)} closes the viewport window of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} and terminates the corresponding process ID.
149667`\spad{close(x,{}b)} \undocumented
149735`\spad{closed?(x)} \undocumented
149797`\spad{closed?(t)} tests whether the given tube plot \spad{t} is closed.
149849`\spad{closedCurve?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} contains a single closed curve component,{} \spadignore{i.e.} the first element of the curve is also the last element,{} or \spad{false} otherwise.
149912`\spad{closedCurve(lp)} sets a list of points defined by the first element of \spad{lp} through the last element of \spad{lp} and back to the first elelment again and returns a \spadtype{ThreeSpace} whose component is the closed curve defined by \spad{lp}.
149981`\spad{closedCurve(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single closed curve component defined by a list of points in which the first point is also the last point,{} all of which are from the domain \spad{PointDomain(m,{}R)} and if so,{} returns the list of points. An error is signaled otherwise.
150050`\spad{closedCurve(s,{}[[lr0],{}[lr1],{}...,{}[lrn],{}[lr0]])} adds a closed curve component defined by a list of points \spad{lr0} through \spad{lrn},{} which are lists of elements from the domain \spad{PointDomain(m,{}R)},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined and \spad{m} is the dimension of the points,{} in which the last element of the list of points contains a copy of the first elemen
150050`--t list,{} \spad{lr0}. The closed curve is added to the \spadtype{ThreeSpace},{} \spad{s}.
150121`\spad{closedCurve(s,{}[p0,{}p1,{}...,{}pn,{}p0])} adds a closed curve component which is a list of points defined by the first element \spad{p0} through the last element \spad{pn} and back to the first element \spad{p0} again,{} to the \spadtype{ThreeSpace} \spad{s}.
150193`\spad{cn(x,{}k)} expands the elliptic function \spad{cn} as a Taylor \indented{1}{series.}
150352`\axiom{coHeight(\spad{ts})} returns \axiom{size()\spad{\$}\spad{V}} minus \axiom{\spad{\#}\spad{ts}}.
150444`\spad{code(f)} returns the internal representation of the object represented by \spad{f}.
151174`\spad{coefChoose should} be local
151257`\spad{coef(p,{}e)} extracts the coefficient of the monomial \spad{e}. Returns zero if \spad{e} is not present.
151307`\axiom{coef(\spad{x},{}\spad{y})} returns the scalar product of \axiom{\spad{x}} by \axiom{\spad{y}},{} the set of words being regarded as an orthogonal basis.
151390`\spad{coef(x,{}w)} returns the coefficient of the word \spad{w} in \spad{x}.
151458`\spad{coef(x,{}y)} returns scalar product of \spad{x} by \spad{y},{} the set of words being regarded as an orthogonal basis.
151571`\spad{coefficient(x,{}n)} \undocumented
151637`\spad{coefficient(f,{}m)} extracts the coefficient of \spad{m} in \spad{f} with respect to the canonical basis \spad{M}.
151689`\spad{coefficient(s,{} n)} gives the terms of total degree \spad{n}.
151789`\spad{coefficient(df,{}u)},{} where \spad{df} is a differential form,{} returns the coefficient of \spad{df} containing the basis term \spad{u} if such a term exists,{} and 0 otherwise.
151880`\spad{coefficient(p,{}u)} returns the coefficient of the term in \spad{p} containing the basis term \spad{u} if such a term exists,{} and 0 otherwise. Error: if the second argument \spad{u} is not a basis element.
151934`\spad{coefficient(s,{} e1 a1 + ... + en an)} returns \spad{ei} such that \spad{ai} = \spad{s},{} or 0 if \spad{s} is not one of the \spad{ai}\spad{'s}.
152001`\spad{coefficient(x,{}b)} returns the coefficient of \spad{b} in \spad{x}.
152064`\spad{coefficient(p,{}e)} extracts the coefficient of the monomial with exponent \spad{e} from polynomial \spad{p},{} or returns zero if exponent is not present.
152123`\spad{coefficient(x,{}[i1,{}i2,{}...,{}iN])} extracts the coefficient of \spad{e(i1)*e(i2)*...*e(iN)} in \spad{x}.
152202`\spad{coefficient(s,{} n)} gives the terms of total degree \spad{n}.
152289`\spad{coefficient(l,{}k)} is \spad{a(k)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
152369`\spad{coefficient(l,{}k)} is \spad{a(k)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
152646`\spad{coefficient(f,{}[x1,{}x2,{}...,{}xk],{}[n1,{}n2,{}...,{}nk])} returns the coefficient of \spad{x1^n1 * ... * xk^nk} in \spad{f}.
152759`\spad{coefficient(p,{} lv,{} ln)} views the polynomial \spad{p} as a polynomial in the variables of \spad{lv} and returns the coefficient of the term \spad{lv**ln},{} \spadignore{i.e.} \spad{prod(lv_i ** ln_i)}.
152863`\spad{coefficient(f,{}x,{}n)} returns the coefficient of \spad{x^n} in \spad{f}.
152964`\spad{coefficient(p,{}v,{}n)} views the polynomial \spad{p} as a univariate polynomial in \spad{v} and returns the coefficient of the \spad{v**n} term.
153197`\spad{coefficients(f)} lists all non-zero coefficients.
153254`\spad{coefficients(x)} returns a stream of ring elements. \indented{1}{When \spad{x} is a univariate series,{} this is a stream of Taylor} \indented{1}{coefficients. When \spad{x} is a multivariate series,{} the} \indented{1}{\spad{n}th element of the stream is a form of} \indented{1}{degree \spad{n} in the power series variables.}
153324`\spad{coefficients(p)} gives the list of non-zero coefficients of polynomial \spad{p}.
153394`\spad{coefficients(x)} returns the list of coefficients of \spad{x}.
153458`\spad{coefficients(l)} returns the list of all the nonzero coefficients of \spad{l}.
153535`\spad{coefficients(a0 + a1 x + a2 x**2 + ...)} returns a stream of coefficients: \spad{[a0,{}a1,{}a2,{}...]}. The entries of the stream may be zero.
153618`\spad{coerceImages(ls)} coerces the list {\em ls} to a permutation whose image is given by {\em ls} and the preimage is fixed to be {\em [1,{}...,{}n]}. Note: {coerceImages(\spad{ls})=coercePreimagesImages([1,{}...,{}\spad{n}],{}\spad{ls})}.
153724`\spad{coerceImages(ls)} coerces the list {\em ls} to a permutation whose image is given by {\em ls} and the preimage is fixed to be {\em [1,{}...,{}n]}. Note: {coerceImages(\spad{ls})=coercePreimagesImages([1,{}...,{}\spad{n}],{}\spad{ls})}.
153806`\spad{coerceListOfPairs(lls)} coerces a list of pairs {\em lls} to a permutation. Error: if not consistent,{} \spadignore{i.e.} the set of the first elements coincides with the set of second elements. coerce(\spad{p}) generates output of the permutation \spad{p} with domain OutputForm.
153873`\spad{coerceP(v)} coerces a vector \spad{v} with entries in \spadtype{Matrix R} as vector over \spadtype{Matrix Polynomial R}
153975`\spad{coercePreimagesImages(lls)} coerces the representation {\em lls} of a permutation as a list of preimages and images to a permutation.
154670`\spad{coerce(r)} converts a ring element \spad{r} to a stream with one element.
154909`\spad{coerce(e)} returns \spad{1*e}
154959`\spad{coerce(f)} produces the equivalence class of \spad{f} in the residue ring
156260`\spad{coerce(\spad{gi})} converts the indicated \spadtype{GraphImage},{} \spad{gi},{} into the \spadtype{TwoDimensionalViewport} form.
157452`\axiom{coerce(\spad{p})} returns \axiom{\spad{p}}.
157528`\spad{coerce(l)} converts a list of 0\spad{'s} and 1\spad{'s} into a basis element,{} where 1 (respectively 0) designates that the variable of the corresponding index of \spad{l} is (respectively,{} is not) present. Error: if an element of \spad{l} is not 0 or 1.
157581`\spad{coerce(llp)} component(\spad{gi},{}\spad{pt}) creates and returns a graph of the domain \spadtype{GraphImage} which is composed of the list of list of points given by \spad{llp},{} and whose point colors,{} line colors and point sizes are determined by the default functions \spadfun{pointColorDefault},{} \spadfun{lineColorDefault},{} and \spadfun{pointSizeDefault}. The graph data is then sent to the viewport manager where it wai
157581`--ts to be included in a two-dimensional viewport window.
157650`\spad{coerce(lt)} converts a list of terms and coefficients to a member of the domain.
157722`\spad{coerce(p)} coerces \spad{p} into Weighted form,{} applying weights and ignoring terms
157919`\spad{coerce(p)} coerces a Polynomial(\spad{R}) into Weighted form,{} applying weights and ignoring terms
158005`\spad{coerce(a)} makes a tuple from primitive array a
158684`\spad{coerce(x)} \undocumented
158763`\spad{coerce(x)} \undocumented
160739`\spad{coerce(s)} returns \spad{s} viewed as an element of \%.
160787`\spad{coerce(poly)} regroups the terms by total degree and forms a series.
160941`\spad{coerce(p)} returns \spad{p} viewed as an algebraic number.
161225`\spad{coerce(p)} converts a univariate polynomial \spad{p} in the variable \spad{var} to a univariate Taylor series in \spad{var}.
161326`\spad{coerce(p)} converts a univariate polynomial \spad{p} in the variable \spad{var} to a univariate Taylor series in \spad{var}.
161421`\spad{coerce(f)} converts a \spadtype{UnivariatePuiseuxSeries} to an \spadtype{ExponentialExpansion}.
161646`\spad{coerce(var)} converts a variable to a Taylor series
161722`\spad{coerce(v)} return \spad{v}
161796`\spad{coerce(var)} converts the series variable \spad{var} into a Laurent series.
161881`\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.
161966`\spad{coerce(var)} converts the series variable \spad{var} into a \indented{1}{Taylor series.}
162050`\spad{coerce(var)} converts the series variable \spad{var} into a Laurent series.
162129`\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.
162208`\spad{coerce(var)} converts the series variable \spad{var} into a \indented{1}{Taylor series.}
162286`\spad{coerce(x)} returns \spad{x} as a skew-polynomial.
162367`\spad{coerce(v)} assumes that it is called with a vector of length equal to the dimension of the algebra,{} then a linear combination with the basis element is formed
162469`\spad{coerce(v)} coerces a vector \spad{v} with entries in \spadtype{Matrix R} as vector over \spadtype{Matrix Fraction Polynomial R}
162580`\spad{coerce(p)} coerces a partition into a list of integers
162631`\axiom{coerce(\spad{x})} returns the element of \axiomType{Magma}(VarSet) corresponding to \axiom{\spad{x}}.
162691`\spad{coerce(m)} converts a matrix of type \spadtype{RectangularMatrix} to a matrix of type \spad{Matrix}.
162753`\spad{coerce(m)} converts a matrix of type \spadtype{SquareMatrix} to a matrix of type \spadtype{Matrix}.
162811`\axiom{coerce(\spad{x})} returns the element of \axiomType{OrderedFreeMonoid}(VarSet) corresponding to \axiom{\spad{x}}.
162883`\axiom{coerce(\spad{x})} returns the element of \axiomType{OrderedFreeMonoid}(VarSet) corresponding to \axiom{\spad{x}} by removing parentheses.
162950`\spad{coerce([l1]*[l2]*...[ln])} returns the word \spad{l1*l2*...*ln},{} where \spad{[l_i]} is the backeted form of the Lyndon word \spad{l_i}.
163043`\spad{coerce(\spad{gi})} returns the indicated graph,{} \spad{\spad{gi}},{} of domain \spadtype{GraphImage} as output of the domain \spadtype{OutputForm}.
163092`\spad{coerce(v)} returns the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport} as output of the domain \spadtype{OutputForm}.
163153`convert back into a \spad{"P"},{} ignoring weights
163230`\spad{coerce(p)} converts back into a Polynomial(\spad{R}),{} ignoring weights
163316`\spad{coerce(x)} \undocumented
163400`\spad{coerce(x)} \undocumented
163474`\spad{coerce(x)} \undocumented
163547`\spad{coerce(x)} \undocumented
163626`\spad{coerce(x)} returns the symbol
163674`\axiom{coerce(\spad{g})} returns the internal representation of \axiom{\spad{g}}.
163766`\axiom{coerce(\spad{p})} returns \axiom{\spad{p}} as a distributed polynomial.
163851`\axiom{coerce(\spad{g})} returns the internal representation of \axiom{\spad{g}}.
163935`\axiom{coerce(\spad{p})} returns \axiom{\spad{p}} as a recursive polynomial.
164018`\spad{coerce A} changes its argument into a \indented{1}{nullary function.}
164069`\spad{coerce(a)} coerces the element \spad{a} of the algebra \spad{A} to an element of the Jordan algebra \spadtype{AssociatedJordanAlgebra}(\spad{R},{}A).
164127`\spad{coerce(a)} coerces the element \spad{a} of the algebra \spad{A} to an element of the Lie algebra \spadtype{AssociatedLieAlgebra}(\spad{R},{}A).
164182`\spad{coerce(c)} returns \spad{c} as a string \spad{s} with the character \spad{c}.
164235`\spad{coerce(col)} converts the column \spad{col} to a column matrix.
164292`\spad{coerce(c)} sets the average shade for the palette to that of the indicated color \spad{c}.
164333`\spad{coerce(u)} transforms \spad{u} into a MachineComplex
164390`\spad{coerce(u)} transforms \spad{u} into a MachineComplex
164449`\spad{coerce(u)} transforms \spad{u} into a MachineComplex
164513`\spad{coerce(u)} transforms \spad{u} into a MachineComplex
164579`\spad{coerce(v)} views a vector as a rank 1 tensor.
164656`\spad{coerce(eq)} \undocumented{}
164770`\spad{coerce(eq)} \undocumented{}
164875`\spad{coerce(eq)} \undocumented{}
164982`\spad{coerce(eq)} \undocumented{}
165096`\spad{coerce(eq)} \undocumented{}
165208`\spad{coerce(eq)} \undocumented{}
165322`\spad{coerce(e)} is never really evaluated. This coercion is used for formal type correctness when a function will not return directly to its caller.
165381`\spad{coerce(e)} \undocumented{}
165485`\spad{coerce(e)} \undocumented{}
165580`\spad{coerce(x)} returns \spad{x} with coefficients in the domain
165654`\spad{coerce(e)} \undocumented{}
165751`\spad{coerce(e)} \undocumented{}
165855`\spad{coerce(e)} \undocumented{}
165957`\spad{coerce(e)} \undocumented{}
166061`\spad{coerce(x)} is the homomorphic image of \spad{x} from {\em F1} in {\em F2}. Thus {\em coerce} is a field homomorphism between the fields extensions {\em F1} and {\em F2} both over ground field {\em GF} (the second argument to the package). Error: if the extension degree of {\em F1} doesn\spad{'t} divide the extension degree of {\em F2}. Note that the other coercion function in the \spadtype{FiniteFieldHomomorphisms} is a left inverse
166061`--.
166126`\spad{coerce(x)} is the homomorphic image of \spad{x} from {\em F2} in {\em F1},{} where {\em coerce} is a field homomorphism between the fields extensions {\em F2} and {\em F1} both over ground field {\em GF} (the second argument to the package). Error: if the extension degree of {\em F2} doesn\spad{'t} divide the extension degree of {\em F1}. Note that the other coercion function in the \spadtype{FiniteFieldHomomorphisms} is a left inve
166126`--rse.
166191`\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}
166254`\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}
166315`\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}
166384`\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}
166445`\spad{coerce(e)} takes an object from \spadtype{FortranCode} and \indented{1}{uses it as the body of an ASP.}
166514`\spad{coerce(fc)} \undocumented{}
166603`\spad{coerce(f)} takes an object from the appropriate instantiation of \spadtype{FortranExpression} and turns it into an ASP.
166701`\spad{coerce(f)} takes an object from the appropriate instantiation of \spadtype{FortranExpression} and turns it into an ASP.
166795`\spad{coerce(f)} takes an object from the appropriate instantiation of \spadtype{FortranExpression} and turns it into an ASP.
166889`\spad{coerce(f)} takes an object from the appropriate instantiation of \spadtype{FortranExpression} and turns it into an ASP.
166984`\spad{coerce(f)} takes an object from the appropriate instantiation of \spadtype{FortranExpression} and turns it into an ASP.
167080`\spad{coerce(t)} creates an element from a scalar type
167137`\spad{coerce(c)} converts sin/cos terms into Fourier Series
167203`\spad{coerce(f)} takes a fraction with numerator and denominator in factored form and creates a partial fraction. It is necessary for the parts to be factored because it is not known in general how to factor elements of \spad{R} and this is needed to decompose into partial fractions.
167271`\spad{coerce(rf)} converts \spad{rf},{} a fraction of polynomial \spad{p} with algebraic number coefficients to \spadtype{Expression Integer}.
167377`\spad{coerce(f)} returns \spad{f} as an element of \%.
167476`\spad{coerce(q)} returns \spad{q} as an element of \%.
167553`\spad{coerce(n)} coerces the integer \spad{n} to an element of the ring.
167607`\spad{coerce(i)} converts the integer \spad{i} to a member of the given domain.
167647`\spad{coerce(i)} returns the element corresponding to \spad{i}
167693`\spad{coerce(polyList)} converts the list of polynomials \spad{polyList} to an ideal.
167771`\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}
167840`\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}
167907`\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}
167982`\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}
168049`\spad{coerce(e)} takes an object from \spadtype{List FortranCode} and \indented{1}{uses it as the body of an ASP.}
168124`\spad{coerce(lfc)} \undocumented{}
168219`\spad{coerce(lls)} coerces a list of cycles {\em lls} to a permutation,{} each cycle being a list with not repetitions,{} is coerced to the permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are mutiplied. Error: if repetitions occur in one cycle.
168275`\spad{coerce(ls)} coerces a list of permutations {\em ls} to the group generated by this list.
168343`\spad{coerce([r_1,{}...,{}r_dim])} allows tensors to be constructed using lists.
168407`\spad{coerce(l)} creates a datalist from \spad{l}
168454`\spad{coerce(l)} makes a database out of a list
168501`\spad{coerce(ls)} coerces a cycle {\em ls},{} \spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur.
168551`\spad{coerce(l)} converts a list \spad{l} to a stream.
168596`\spad{coerce([t_1,{}...,{}t_dim])} allows tensors to be constructed using lists.
168661`\spad{coerce(u)} transforms a MachineInteger into a MachineFloat
168716`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
168819`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
168925`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
169039`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
169148`\spad{coerce(v)} produces an ASP which returns the value of \spad{v}.
169218`\spad{coerce(o)} changes \spad{o} in the standard output format to SCRIPT formula format.
169276`\spad{coerce(o)} changes \spad{o} in the standard output format to TeX format.
169324`\spad{coerce(f)} returns \spad{f} as an Expression(\spad{R}).
169380`\spad{coerce(p)} converts the polynomial \spad{p} with algebraic number coefficients to \spadtype{Expression Integer}.
169476`\spad{coerce(s)} regroups terms of \spad{s} by total degree \indented{1}{and forms a series.}
169539`\spad{coerce(p)} returns \spad{p} as an element of \%.
169628`\spad{coerce(p)} moves from the representation type (PrimitiveArray PrimitiveArray PrimitiveArray \spad{R}) to the domain
169731`\spad{coerce(r)} returns \spad{r} viewed as a rational function over \spad{R}.
169801`\spad{coerce(r)} maps the ring element \spad{r} to a member of the algebra.
169841`\spad{coerce(r)} returns \spad{r} * 1 where 1 is the identity of the left algebra.
169885`\spad{coerce(r)} equals \spad{r*1}.
169926`\spad{coerce(r)} converts coefficients into Fourier Series
169974`\spad{coerce(r)} views \spad{r} as a value in the ordinary differential ring.
170043`\spad{coerce(x)} \undocumented{}
170270`\spad{coerce(x)} \undocumented{}
170450`\spad{coerce(x)} \undocumented{}
170571`\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.
170678`\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.
170783`\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.
170896`\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.
171001`\spad{coerce(e)} takes the component of \spad{e} from \spadtype{List FortranCode} and uses it as the body of the ASP,{} making the declarations in the \spadtype{SymbolTable} component.
171114`\spad{coerce(r)} \undocumented{}
171247`\spad{coerce(x)} \undocumented{}
171563`\spad{coerce(x)} \undocumented{}
171748`\spad{coerce(x)} \undocumented{}
171987`\spad{coerce(s)} creates an object of \spadtype{Any} from the object \spad{s} of type \spad{S}.
172034`\spad{coerce(x)} changes \spad{x} into an object of type \spadtype{None}.
172083`\spad{coerce(s)} provides a direct coercion from an expression \spad{s} of domain \spad{S} to SCRIPT formula format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to SCRIPT formula format.
172153`\spad{coerce(s)} provides a direct coercion from a domain \spad{S} to TeX format. This allows the user to skip the step of first manually coercing the object to standard output format before it is coerced to TeX format.
172203`\spad{coerce(s)} throws all information about \spad{s} away. This coercion allows values of any type to appear in contexts where they will not be used. For example,{} it allows the resolution of different types in the \spad{then} and \spad{else} branches when an \spad{if} is in a context where the resulting value is not used.
172262`\spad{coerce(s)} returns \spad{s},{} viewed as the zero-th order derivative of \spad{s}.
172323`\spad{coerce(a)} transforms a into an element of \%.
172369`\spad{coerce(x)} allows \spadtype{Segment} values to be used as \%.
172427`\spad{coerce(x = a..b)} returns \spad{x = c..d} where \spad{c} and \spad{d} are the numerical values of \spad{a} and \spad{b}.
172522`\spad{coerce(p)} returns \spad{p} viewed as an algebraic number.
172614`\spad{coerce(p)} returns \spad{p} as an element of \%.
172712`\spad{coerce(m)} views a matrix as a rank 2 tensor.
172788`\spad{coerce(s)} converts a string to a file name according to operating system-dependent conventions.
172839`\spad{coerce(s)} transforms the string \spad{s} into an element of FortranScalarType provided \spad{s} is one of "real",{} "double precision",{} "complex",{} "logical",{} "integer",{} "character",{} "REAL",{} "COMPLEX",{} "LOGICAL",{} "INTEGER",{} "CHARACTER",{} "DOUBLE PRECISION"
172891`\spad{coerce(s)} converts \axiom{\spad{s}} into an \axiom{IndexCard}. Warning: if \axiom{\spad{s}} is not of the right format then an error will occur when using it.
172935`\spad{coerce(s)} converts the string \spad{s} to a symbol.
172976`\spad{coerce(s)} transforms the symbol \spad{s} into an element of FortranScalarType provided \spad{s} is one of real,{} complex,{}double precision,{} logical,{} integer,{} character,{} REAL,{} COMPLEX,{} LOGICAL,{} INTEGER,{} CHARACTER,{} DOUBLE PRECISION
173028`\spad{coerce(u)} creates an OpenMath error object of an appropriate type if \axiom{\spad{u}} is one of \axiom{OMParseError},{} \axiom{OMReadError},{} \axiom{OMUnknownCD} or \axiom{OMUnknownSymbol},{} otherwise it raises a runtime error.
173080`\spad{coerce(s)} \undocumented{}
173121`\spad{coerce(s)} converts a variable to a Taylor series
173174`\spad{coerce(f(x))} converts the Laurent series \spad{f(x)} to a Puiseux series.
173258`\spad{coerce(f(x))} converts the Taylor series \spad{f(x)} to a Laurent series.
173342`\spad{coerce(x)} \undocumented{}
173669`\spad{coerce(x)} \undocumented{}
173976`\spad{coerce(f)} converts a Puiseux series to a general power series.
174084`\axiom{coerce(\spad{x})} returns \axiom{\spad{x}} as a Lie polynomial.
174143`\spad{coerce(var)} converts the series variable \spad{var} into a Puiseux series.
174227`\spad{coerce(x)} converts the variable \spad{x} to a univariate polynomial.
174292`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174427`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174542`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174649`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174755`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174858`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
174991`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175097`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175200`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175303`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175405`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175509`\spad{coerce(f)} takes objects from the appropriate instantiation of \spadtype{FortranExpression} and turns them into an ASP.
175613`\spad{coerce(v)} produces an ASP which returns the value of \spad{v}.
175683`\spad{coerce(v)} converts a vector to a member of the algebra by forming a linear combination with the basis element. Note: the vector is assumed to have length equal to the dimension of the algebra.
175768`\spad{coerce(u)} transforms \spad{u} into a COmplex Float
175825`\spad{coerce(x)} \undocumented{}
175919`\spad{coerce(u)} transforms a MachineFloat to a standard Float
175965`\spad{coerce(b)} converts a binary expansion to a rational number.
176026`\spad{coerce(d)} converts a decimal expansion to a rational number.
176088`\spad{coerce(h)} converts a hexadecimal expansion to a rational number.
176154`\spad{coerce(rx)} converts a radix expansion to a rational number.
176218`\spad{coerce(p)} sums up the components of the partial fraction and returns a single fraction.
176276`\spad{coerce(gp)} returns the generators of the group {\em gp}.
176344`\spad{coerce(x)} returns the list of elements in \spad{x}
176391`\spad{coerce(s)} returns the \spadtype{ThreeSpace} \spad{s} to Output format.
176451`\spad{coerce(f)} returns an object of type OutputForm.
176501`\spad{coerce(x)} provides a printable form for \spad{x}
176551`\spad{coerce(x)} \undocumented{}
176617`\spad{coerce(x)} \undocumented{}
176675`\spad{coerce(x)} \undocumented{}
176742`\spad{coerce(x)} \undocumented{}
176800`\spad{coerce(t)} converts a tableau \spad{t} to an output form.
176849`\spad{coerce(v)} coerces void object to outputForm.
176892`\spad{coerce(x)} moves from the domain to the representation type
176995`\spad{coerce(p)} views \spad{p} as a valie in the partial differential ring.
177064`\spad{coerce(d)} converts a decimal expansion to a radix expansion with base 10.
177127`\spad{coerce(h)} converts a hexadecimal expansion to a radix expansion with base 16.
177194`\spad{coerce(b)} converts a binary expansion to a radix expansion with base 2.
177255`\spad{coerce(x)} returns the \spad{s}-expression associated with \spad{x}
177312`\spad{coerce(a)} transforms a into an element of \spad{S}.
177356`\spad{coerce(fn)} produces a string for a file name according to operating system-dependent conventions.
177407`\spad{coerce(x)} returns the symbol associated with \spad{x}
177459`\spad{coerce(x)} returns a table view of \spad{x}
177524`\spad{coerce(x)} \undocumented
177574`\axiom{coerce(\spad{x})} returns \axiom{\spad{x}} as distributed polynomial.
177659`\axiom{coerce(\spad{x})} returns \axiom{\spad{x}} as a recursive polynomial.
177742`\spad{coerce(v)} returns \spad{v}.
177791`\spad{coleman(alpha,{}beta,{}\spad{pi})}: there is a bijection from the set of matrices having nonnegative entries and row sums {\em alpha},{} column sums {\em beta} to the set of {\em Salpha - Sbeta} double cosets of the symmetric group {\em Sn}. ({\em Salpha} is the Young subgroup corresponding to the improper partition {\em alpha}). For a representing element {\em \spad{pi}} of such
177791`-- a double coset,{} coleman(\spad{alpha},{}\spad{beta},{}\spad{pi}) generates the Coleman-matrix corresponding to {\em alpha,{} beta,{} \spad{pi}}. Note: The permutation {\em \spad{pi}} of {\em {1,{}2,{}...,{}n}} has to be given in list form. Note: the inverse of this map is {\em inverseColeman} (if {\em \spad{pi}} is the lexicographical smallest permutation in the coset). For details see James/Kerber.
177978`\axiom{collectQuasiMonic(\spad{ts})} returns the subset of \axiom{\spad{ts}} consisting of the polynomials with initial in \axiom{\spad{R}}.
178190`\axiom{collectUnder(\spad{ps},{}\spad{v})} returns the set consisting of the polynomials of \axiom{\spad{ps}} with main variable less than \axiom{\spad{v}}.
178409`\axiom{collectUpper(\spad{ps},{}\spad{v})} returns the set consisting of the polynomials of \axiom{\spad{ps}} with main variable greater than \axiom{\spad{v}}.
178558`\axiom{collect(\spad{ps},{}\spad{v})} returns the set consisting of the polynomials of \axiom{\spad{ps}} with \axiom{\spad{v}} as main variable.
178632`\spad{colorDef(v,{}c1,{}c2)} sets the range of colors along the colormap so that the lower end of the colormap is defined by \spad{c1} and the top end of the colormap is defined by \spad{c2},{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
178703`\spad{colorFunction(f(z))} specifies the color based upon the \spad{z}-component of three dimensional plots. This option is expressed in the form \spad{colorFunction == f(z)}.
178775`\spad{colorFunction(f(u,{}v))} specifies the color for three dimensional plots as a function based upon the two parametric variables. This option is expressed in the form \spad{colorFunction == f(u,{}v)}.
178859`\spad{colorFunction(f(x,{}y,{}z))} specifies the color for three dimensional plots as a function of \spad{x},{} \spad{y},{} and \spad{z} coordinates. This option is expressed in the form \spad{colorFunction == f(x,{}y,{}z)}.
178955`\spad{color(pt)} returns the fourth element of the point,{} \spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} color to express a fourth dimension.
179005`\spad{color(i)} returns a color of the indicated hue \spad{i}.
179120`\spad{column(m,{}j)} returns the \spad{j}th column of the matrix \spad{m}. Error: if the index outside the proper range.
179200`\spad{column(m,{}j)} returns the \spad{j}th column of \spad{m} error check to determine if index is in proper ranges
179278`\spad{combineFeatureCompatibility(C1,{}C2)} is for interacting attributes
179358`\spad{combineFeatureCompatibility(C1,{}L)} is for interacting attributes
179444`\spad{commaSeparate(l)} creates the form separating the elements of \spad{l} by commas.
179498`\spad{commaSeparate(l)} produces a comma separated string from a list of strings.
179566`\spad{comment(s)} creates a representation of the Strings \spad{s} as a multi-line FORTRAN comment.
179619`\spad{comment(s)} creates a representation of the String \spad{s} as a single FORTRAN comment.
179666`\spad{commonDenominator([q1,{}...,{}qn])} returns a common denominator \spad{d} for \spad{q1},{}...,{}\spad{qn}.
179737`\spad{commonDenominator([q1,{}...,{}qn])} returns a common denominator \spad{d} for \spad{q1},{}...,{}\spad{qn}.
179801`\spad{commonDenominator(q)} returns a common denominator \spad{d} for the elements of \spad{q}.
179877`\spad{commonDenominator(q)} returns a common denominator \spad{d} for the coefficients of \spad{q}.
179963`\spad{common(name,{}contents)} creates a representation a named common block.
180022`\spad{commutative?()} tests if multiplication in the algebra is commutative.
180099`\spad{commutative?()} tests if multiplication in the algebra is commutative.
180173`\spad{commutativeEquality(x,{}y)} returns \spad{true} if \spad{x} and \spad{y} are equal assuming commutativity
180336`\spad{commutator(p,{}q)} computes \spad{inv(p) * inv(q) * p * q}.
180379`\spad{commutator(a,{}b)} returns \spad{a*b-b*a}.
180434`\spad{compBound(p,{}lp)} computes a bound for the coefficients of the solution polynomials. Given a polynomial right hand side \spad{p},{} and a list \spad{lp} of left hand side polynomials. Exported because it depends on the valuation.
180510`\spad{comp(f,{}g,{}x)} is \spad{f(g x)}.
180586`\spad{compactFraction(p)} normalizes the partial fraction \spad{p} to the compact representation. In this form,{} the partial fraction has only one fractional term per prime in the denominator.
180644`\spad{companionBlocks(m,{} v)} returns \spad{[[C_1,{} g_1],{}...,{}[C_k,{} g_k]]} such that each \spad{C_i} is a companion block and \spad{m = diagonal(C_1,{}...,{}C_k)}.
180761`\spad{comparison(op,{} foo?)} attaches foo? as the "\%less?" property to \spad{op}. If \spad{op1} and \spad{op2} have the same name,{} and one of them has a "\%less?" property \spad{f},{} then \spad{f(op1,{} op2)} is called to decide whether \spad{op1 < op2}.
180826`\spad{compdegd should} be local
180961`\spad{compile(f,{} [t1,{}...,{}tn])} forces the interpreter to compile the function \spad{f} with signature \spad{(t1,{}...,{}tn) -> ?}. returns the symbol \spad{f} if successful. Error: if \spad{f} was not defined beforehand in the interpreter,{} or if the \spad{ti}\spad{'s} are not valid types,{} or if the compiler fails.
181019`\spad{compiledFunction(expr,{} x)} returns a function \spad{f: D -> I} defined by \spad{f(x) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spad{D}.
181102`\spad{compiledFunction(expr,{}x,{}y)} returns a function \spad{f: (D1,{} D2) -> I} defined by \spad{f(x,{} y) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spad{(D1,{} D2)}
181253`\spad{complement(u)} returns the complement of the set \spad{u},{} \spadignore{i.e.} the set of all values not in \spad{u}.
181409`\spad{complementaryBasis(b1,{}...,{}bn)} returns the complementary basis \spad{(b1',{}...,{}bn')} of \spad{(b1,{}...,{}bn)}.
181500`\spad{completeEchelonBasis(lv)} completes the basis {\em lv} assumed to be in echelon form of a subspace of {\em R**n} (\spad{n} the length of all the vectors in {\em lv}) with unit vectors to a basis of {\em R**n}. It is assumed that the argument is not an empty vector and that it is not the basis of the 0-subspace. Note: the rows of the result correspond to the vectors of the basis.
181592`\spad{completeEval(upoly,{} lvar,{} lval)} evaluates the polynomial \spad{upoly} with each variable in \spad{lvar} replaced by the corresponding value in lval. Substitutions are done for all variables in \spad{upoly} producing a univariate polynomial over \spad{R}.
181728`\spad{completeHensel(pol,{}lfact,{}prime,{}bound)} lifts \spad{lfact},{} the factorization mod \spad{prime} of \spad{pol},{} to the factorization mod prime**k>bound. Factors are recombined on the way.
181828`\spad{completeHermite} returns a record that contains the Hermite normal form \spad{H} of the matrix and the equivalence matrix \spad{U} such that U*m = \spad{H}
181918`\spad{completeSmith} returns a record that contains the Smith normal form \spad{H} of the matrix and the left and right equivalence matrices \spad{U} and \spad{V} such that U*m*v = \spad{H}
182072`\spad{complete n} is the \spad{n} th complete homogeneous \indented{1}{symmetric function expressed in terms of power sums.} \indented{1}{Alternatively it is the cycle index of the symmetric} \indented{1}{group of degree \spad{n}.}
182161`\spad{complete(st)} causes all entries of 'st' to be computed. this function should only be called on streams which are known to be finite.
182216`\spad{complete(x)} forces the computation of all digits.
182272`\spad{complete(f)} causes all terms of \spad{f} to be computed. Note: this results in an infinite loop if \spad{f} has infinitely many terms.
182340`\spad{complete(x)} causes all entries in \spadvar{\spad{x}} to be computed. Normally entries are only computed as needed. If \spadvar{\spad{x}} is an infinite continued fraction,{} a user-initiated interrupt is necessary to stop the computation.
182393`\spad{complex?(t)} tests whether \spad{t} is equivalent to the FORTRAN type COMPLEX.
182448`\spad{complexEigenvalues(m,{}eps)} computes the eigenvalues of the matrix \spad{m} to precision \spad{eps}. The eigenvalues are expressed as complex floats or complex rational numbers depending on the type of \spad{eps} (float or rational).
182574`\spad{complexEigenvectors(m,{}eps)} returns a list of records each one containing a complex eigenvalue,{} its algebraic multiplicity,{} and a list of associated eigenvectors. All these results are computed to precision \spad{eps} and are expressed as complex floats or complex rational numbers depending on the typ
182574`--e of \spad{eps} (float or rational).
182767`\spad{complexElementary(f)} rewrites \spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.
182845`\spad{complexElementary(f)} rewrites \spad{f} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.
182916`\spad{complexElementary(f,{} x)} rewrites the kernels of \spad{f} involving \spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.
183001`\spad{complexElementary(f,{} x)} rewrites the kernels of \spad{f} involving \spad{x} in terms of the 2 fundamental complex transcendental elementary functions: \spad{log,{} exp}.
183079`\spad{complexExpand(i)} returns the expanded complex function corresponding to \spad{i}.
183166`\spad{complexExpand(i)} returns the expanded complex function corresponding to \spad{i}.
183287`\spad{complexForm(f)} returns \spad{[real f,{} imag f]}.
183380`\spad{complexForm(f)} returns \spad{[real f,{} imag f]}.
183454`\spad{complexIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.
183536`\spad{complexIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.
183673`\spad{complexLimit(f(x),{}x = a)} computes the complex limit \spad{lim(x -> a,{}f(x))}.
183808`\spad{complexLimit(f(x),{}x = a)} computes the complex limit of \spad{f} as its argument \spad{x} approaches \spad{a}.
183972`\spad{complexLimit(f(x),{}x = a)} computes the complex limit of \spad{f} as its argument \spad{x} approaches \spad{a}.
184146`\spad{complexNormalize(f)} rewrites \spad{f} using the least possible number of complex independent kernels.
184223`\spad{complexNormalize(f)} rewrites \spad{f} using the least possible number of complex independent kernels.
184293`\spad{complexNormalize(f,{} x)} rewrites \spad{f} using the least possible number of complex independent kernels involving \spad{x}.
184377`\spad{complexNormalize(f,{} x)} rewrites \spad{f} using the least possible number of complex independent kernels involving \spad{x}.
184454`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
184600`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
184737`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
184870`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
184994`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not constant.
185118`\spad{complexNumericIfCan(x)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
185222`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
185384`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
185537`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
185686`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
185826`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
185966`\spad{complexNumericIfCan(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
186086`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186177`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186302`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186418`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186530`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186633`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186736`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186819`\spad{complexNumeric(x)} returns a complex approximation of \spad{x}.
186879`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
186986`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187127`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187259`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187387`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x}
187506`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187625`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187724`\spad{complexNumeric(x,{} n)} returns a complex approximation of \spad{x} up to \spad{n} decimal places.
187800`\spad{complexRoots(rf,{} eps)} finds all the complex solutions of a univariate rational function with rational number coefficients. The solutions are computed to precision eps.
187920`\spad{complexRoots(lrf,{} lv,{} eps)} finds all the complex solutions of a list of rational functions with rational number coefficients with respect the the variables appearing in \spad{lv}. Each solution is computed to precision eps and returned as list corresponding to the order of variables in \spad{lv}.
188065`\spad{complexSolve(eq,{}eps)} finds all the complex solutions of the equation \spad{eq} of rational functions with rational rational coefficients with respect to all the variables appearing in \spad{eq},{} with precision \spad{eps}.
188217`\spad{complexSolve(p,{}eps)} find all the complex solutions of the rational function \spad{p} with complex rational coefficients with respect to all the variables appearing in \spad{p},{} with precision \spad{eps}.
188359`\spad{complexSolve(leq,{}eps)} finds all the complex solutions to precision \spad{eps} of the system \spad{leq} of equations of rational functions over complex rationals with respect to all the variables appearing in \spad{lp}.
188523`\spad{complexSolve(lp,{}eps)} finds all the complex solutions to precision \spad{eps} of the system \spad{lp} of rational functions over the complex rationals with respect to all the variables appearing in \spad{lp}.
188677`\spad{complexZeros(p)} tries to determine all complex zeros of the polynomial \spad{p} with accuracy given by the package constant {\em globalEps} which you may change by {\em setErrorBound}.
188759`\spad{complexZeros(p,{} eps)} tries to determine all complex zeros of the polynomial \spad{p} with accuracy given by {\em eps}.
188843`\spad{complexZeros(poly,{} eps)} finds the complex zeros of the univariate polynomial \spad{poly} to precision eps with solutions returned as complex floats or rationals depending on the type of eps.
188926`\spad{complex(x,{}y)} constructs \spad{x} + \%i*y.
188977`\spad{component(\spad{gi},{}pt)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color,{} line color and point size are determined by the default functions \spadfun{pointColorDefault},{} \spadfun{lineColorDefault},{} and \spadfun{pointSizeDefault}.
189042`\spad{component(\spad{gi},{}lp,{}pal1,{}pal2,{}p)} sets the components of the graph,{} \spad{\spad{gi}} of the domain \spadtype{GraphImage},{} to the values given. The point list for \spad{\spad{gi}} is set to the list \spad{lp},{} the color of the points in \spad{lp} is set to the palette color \spad{pal1},{} the color of the lines which connect the points \spad{lp} is set to the palette color \spad{
189042`--pal2},{} and the size of the points in \spad{lp} is given by the integer \spad{p}.
189145`\spad{component(\spad{gi},{}pt,{}pal1,{}pal2,{}ps)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color is set to the palette color \spad{pal1},{} line color is set to the palette color \spad{pal2},{} and point size is set to the positive integer \spad{ps}.
189242`\spad{components(s)} takes the \spadtype{ThreeSpace} \spad{s},{} and creates a list containing a unique \spadtype{ThreeSpace} for each single component of \spad{s}. If \spad{s} has no components defined,{} the list returned is empty.
189304`\spad{compose(a,{}b)} composes the power series \spad{a} with the power series \spad{b}.
189391`\spad{compose(p,{}q)} \undocumented
189453`\spad{composite([s1,{}s2,{}...,{}sn])} will create a new \spadtype{ThreeSpace} that is a union of all the components from each \spadtype{ThreeSpace} in the parameter list,{} grouped as a composite.
189692`\spad{composite(f,{} q)} returns \spad{h} if \spad{f} = \spad{h}(\spad{q}),{} and "failed" is no such \spad{h} exists.
189817`\spad{composite(p,{} q)} returns \spad{h} if \spad{p = h(q)},{} and "failed" no such \spad{h} exists.
189922`\spad{composites(s)} takes the \spadtype{ThreeSpace} \spad{s},{} and creates a list containing a unique \spadtype{ThreeSpace} for each single composite of \spad{s}. If \spad{s} has no composites defined (composites need to be explicitly created),{} the list returned is empty. Note that not all the components need to be part of a composite.
189984`\spad{computeBasis }\undocumented
190153`\spad{computeCycleEntry(x,{}cycElt)},{} where \spad{cycElt} is a pointer to a node in the cyclic part of the cyclic stream \spad{x},{} returns a pointer to the first node in the cycle
190221`\spad{computeCycleLength(s)} returns the length of the cycle of a cyclic stream \spad{t},{} where \spad{s} is a pointer to a node in the cyclic part of \spad{t}.
190303`\spad{computeInt(x,{} g,{} a,{} b,{} eval?)} returns the integral of \spad{f} for \spad{x} between a and \spad{b},{} assuming that \spad{g} is an indefinite integral of \spad{f} and \spad{f} has no pole between a and \spad{b}. If \spad{eval?} is \spad{true},{} then \spad{g} can be evaluated safely at \spad{a} and \spad{b},{} provided that they are 
190303`--finite values. Otherwise,{} limits must be computed.
190460`\spad{computePowers()} \undocumented
190739`\spad{concat!(u,{}x)} destructively adds element \spad{x} to the end of \spad{u}.
190801`\spad{concat!(u,{}x)} destructively adds element \spad{x} to the end of \spad{u}. Note: \axiom{concat!(a,{}\spad{x}) = setlast!(a,{}[\spad{x}])}.
190896`\spad{concat!(u,{}v)} destructively concatenates doubly-linked aggregate \spad{v} to the end of doubly-linked aggregate \spad{u}.
190990`\spad{concat!(u,{}v)} destructively appends \spad{v} to the end of \spad{u}. \spad{v} is unchanged
191053`\spad{concat!(u,{}v)} destructively concatenates \spad{v} to the end of \spad{u}. Note: \axiom{concat!(\spad{u},{}\spad{v}) = setlast_!(\spad{u},{}\spad{v})}.
191376`\spad{concat(l)} concatenates a list of aggregates of type \axiomType{Result}
191445`\spad{concat(u)},{} where \spad{u} is a lists of aggregates \axiom{[a,{}\spad{b},{}...,{}\spad{c}]},{} returns a single aggregate consisting of the elements of \axiom{a} followed by those of \spad{b} followed ... by the elements of \spad{c}. Note: \axiom{concat(a,{}\spad{b},{}...,{}\spad{c}) = concat(a,{}concat(\spad{b},{}...,{}\spad{c}))}.
191500`\spad{concat(u)} returns the left-to-right concatentation of the streams in \spad{u}. Note: \spad{concat(u) = reduce(concat,{}u)}.
192315`\spad{concat(a,{}b)} adds two aggregates of type \axiomType{Result}.
192385`\spad{concat(x,{}u)} returns aggregate \spad{u} with additional element at the front. Note: for lists: \axiom{concat(\spad{x},{}\spad{u}) \spad{==} concat([\spad{x}],{}\spad{u})}.
192436`\spad{concat(x,{}u)} returns aggregate consisting of \spad{x} followed by the elements of \spad{u}. Note: if \axiom{\spad{v} = concat(\spad{x},{}\spad{u})} then \axiom{\spad{x} = first \spad{v}} and \axiom{\spad{u} = rest \spad{v}}.
192495`\spad{concat(u,{}x)} returns aggregate \spad{u} with additional element \spad{x} at the end. Note: for lists,{} \axiom{concat(\spad{u},{}\spad{x}) \spad{==} concat(\spad{u},{}[\spad{x}])}
192546`\spad{concat(u,{}v)} returns an aggregate consisting of the elements of \spad{u} followed by the elements of \spad{v}. Note: if \axiom{\spad{w} = concat(\spad{u},{}\spad{v})} then \axiom{\spad{w}.\spad{i} = \spad{u}.\spad{i} for \spad{i} in indices \spad{u}} and \axiom{\spad{w}.(\spad{j} + maxIndex \spad{u}) = \spad{v}.\spad{j} for \spad{j} in indices \spad{v}}.
192598`\spad{concat(u,{}v)} returns an aggregate \spad{w} consisting of the elements of \spad{u} followed by the elements of \spad{v}. Note: \axiom{\spad{v} = rest(\spad{w},{}\#a)}.
192658`\spad{concat(x,{}y)} merges two tables \spad{x} and \spad{y}
192705`\spad{cond(s,{}e)} creates a representation of the FORTRAN expression IF (\spad{s}) THEN \spad{e}.
192752`\spad{cond(s,{}e,{}f)} creates a representation of the FORTRAN expression IF (\spad{s}) THEN \spad{e} ELSE \spad{f}.
192978`\spad{conditionP(mat)},{} given a matrix representing a homogeneous system of equations,{} returns a vector whose characteristic'th powers is a non-trivial solution,{} or "failed" if no such vector exists.
193064`\spad{conditionP(m)} returns a vector of elements,{} not all zero,{} whose \spad{p}\spad{-}th powers (\spad{p} is the characteristic of the domain) are a solution of the homogenous linear system represented by \spad{m},{} or "failed" is there is no such vector.
193191`\axiom{condition(\spad{n})} returns the condition of the node \spad{n}.
193242`\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis
193369`\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis.
193466`\spad{conditionsForIdempotents()} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the fixed \spad{R}-module basis.
193661`\spad{conditionsForIdempotents([v1,{}...,{}vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \spad{R}-module basis \spad{v1},{}...,{}\spad{vn}
193798`\spad{conditionsForIdempotents([v1,{}...,{}vn])} determines a complete list of polynomial equations for the coefficients of idempotents with respect to the \spad{R}-module basis \spad{v1},{}...,{}\spad{vn}.
193906`\axiom{conditions(a)} returns the list of the conditions of the leaves of a
193964`\spad{conical(a,{}b)} transforms from conical coordinates to Cartesian coordinates: \spad{conical(a,{}b)} is a function which will map the point \spad{(lambda,{}mu,{}nu)} to \spad{x = lambda*mu*nu/(a*b)},{} \spad{y = lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))},{} \spad{z = lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))}.
194092`\spad{conjug(x)}should be local but conditional
194310`\spad{conjugate(p)} returns the conjugate partition of a partition \spad{p}
194353`\spad{conjugate(pt)} is the conjugate of the partition \spad{pt}.
194434`\spad{conjugate(x + \%i y)} returns \spad{x} - \%\spad{i} \spad{y}.
194486`\spad{conjugate(o)} negates the imaginary parts \spad{i},{}\spad{j},{}\spad{k},{}\spad{E},{}\spad{I},{}\spad{J},{}\spad{K} of octonian \spad{o}.
194539`\spad{conjugate(q)} negates the imaginary parts of quaternion \spad{q}.
194632`\spad{conjugate(p,{}q)} computes \spad{inv(q) * p * q}; this is 'right action by conjugation'.
194674`\spad{conjugates(lp)} is the stream of conjugates of a stream \indented{1}{of partitions \spad{lp}.}
194772`\spad{connect(v,{}n,{}s)} displays the lines connecting the graph points in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the lines if \spad{s} is "off".
194851`\spad{cons(element,{}u)} appends \spad{element} onto the front of list \spad{u} and returns the new list. This new list and the old one will share some structure.
194889`\spad{cons(a,{}s)} returns a stream whose \spad{first} is \spad{a} and whose \spad{rest} is \spad{s}. Note: \spad{cons(a,{}s) = concat(a,{}s)}.
194929`\spad{consnewpol should} be local
195137`\spad{constDsolve(op,{} g,{} x)} returns \spad{[f,{} [y1,{}...,{}ym]]} where \spad{f} is a particular solution of the equation \spad{op y = g},{} and the \spad{\spad{yi}}\spad{'s} form a basis for the solutions of \spad{op y = 0}.
195232`\spad{const c} is a function which produces \spad{c} when \indented{1}{applied to its argument.}
195285`\spad{constant?(p)} tests if \spad{p} contains no matching variables.
195334`\spad{constant?(p)} tests whether the polynomial \spad{p} belongs to the coefficient ring.
195393`\spad{constant?(x)} returns \spad{true} if \spad{x} is constant.
195450`\spad{constantCoefficientRicDE(op,{} ric)} returns \spad{[[a1,{} L1],{} [a2,{} L2],{} ... ,{} [ak,{} Lk]]} such that any rational solution with no polynomial part of the associated Riccati equation of \spad{op y = 0} must be one of the \spad{ai}\spad{'s} in which case the equation for \spad{z = y e^{-int \spad{ai}}} is \spad{\spad{Li} z = 0}. \spad{ric} is a Riccati equation solver over 
195450`--\spad{F},{} whose input is the associated linear equation.
195567`\spad{constantIfCan(k)} \undocumented
195648`\spad{constantKernel(r)} \undocumented
195714`\spad{constantLeft(f)} is the function \spad{g} \indented{1}{such that \spad{g (a,{}b)= f b}.}
195783`\spad{constantOpIfCan(op)} returns \spad{a} if \spad{op} is the constant nullary operator always returning \spad{a},{} "failed" otherwise.
195892`\spad{constantOperator(a)} returns a nullary operator op such that \spad{op()} always evaluate to \spad{a}.
195986`\spad{constantRight(f)} is the function \spad{g} \indented{1}{such that \spad{g (a,{}b)= f a}.}
196056`\spad{constantToUnaryFunction(s)} is a local function which takes the value of \spad{s},{} which may be a function of a constant,{} and returns a function which always returns the value \spadtype{DoubleFloat} \spad{s}.
196155`\spad{constant(p)} return the constant term of \spad{p}.
196207`\spad{vu(f)} is the function \spad{g} \indented{1}{such that \spad{g a= f ()}.}
196267`\spad{constant(x)} tells the pattern matcher that \spad{x} should match only the symbol \spad{'x} and no other quantity. Error: if \spad{x} is not a symbol.
196326`\spad{constant(x)} tells the pattern matcher that \spad{x} should match only the symbol \spad{'x} and no other quantity.
196402`\spad{constant(x)} returns the constant term of \spad{x}.
196518`\spad{construct([v1,{}e1],{}...,{}[vn,{}en])} returns the match result containing the matches (\spad{v1},{}\spad{e1}),{}...,{}(\spad{vn},{}en).
196605`\axiom{construct(\spad{lvt})} returns the same as \axiom{[construct(\spad{vt}.val,{}\spad{vt}.tower) for \spad{vt} in \spad{lvt}]}
196929`\axiom{construct(\spad{vt})} returns the same as \axiom{construct(\spad{vt}.val,{}\spad{vt}.tower)}
197000`\axiom{construct(\spad{s})} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \axiom{\spad{s}} and no children. Thus,{} if the status of \axiom{\spad{s}} is \spad{false},{} \axiom{[\spad{s}]} represents the starting point of the evaluation \axiom{value(\spad{s})} under the hypothesis \axiom{condition(\spad{s})}.
197068`\spad{construct(lll)} creates a 3-\spad{D} matrix from a List List List \spad{R} \spad{lll}
197144`\spad{construct(l)} is the inverse of fracPart.
197268`\axiom{construct(\spad{x},{}\spad{y},{}...,{}\spad{z})} returns the collection of elements \axiom{\spad{x},{}\spad{y},{}...,{}\spad{z}} ordered as given. Equivalently written as \axiom{[\spad{x},{}\spad{y},{}...,{}\spad{z}]\$\spad{D}},{} where \spad{D} is the domain. \spad{D} may be omitted for those of type List.
197320`\spad{construct(t)} converts an infinite tuple to a stream.
197377`\spad{construct(i,{}e)} \undocumented
197436`\axiom{construct(\spad{x},{}\spad{y})} returns the Lie bracket \axiom{[\spad{x},{}\spad{y}]}.
197528`\axiom{construct(\spad{x},{}\spad{y})} returns the Lie bracket \axiom{[\spad{x},{}\spad{y}]}.
197604`\spad{construct(s,{}t)} makes a form \spad{s:t}
197656`\axiom{construct(\spad{v},{}\spad{t})} returns the same as \axiom{construct(\spad{v},{}\spad{t},{}\spad{false})}
197709`\axiom{construct(\spad{v},{}\spad{lt})} returns the same as \axiom{[construct(\spad{v},{}\spad{t}) for \spad{t} in \spad{lt}]}
197774`\axiom{construct(\spad{x},{}\spad{y})} returns the Lie bracket \axiom{[\spad{x},{}\spad{y}]}.
197850`\axiom{construct(\spad{x},{}\spad{y})} returns the Lie bracket of \axiom{\spad{x}} and \axiom{\spad{y}}.
197900`\axiom{construct(\spad{v},{}\spad{t},{}\spad{b})} returns the non-empty node with value \spad{v},{} condition \spad{t} and flag \spad{b}
197961`\axiom{construct(\spad{v},{}\spad{t},{}\spad{ls})} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \axiom{[\spad{v},{}\spad{t}]\$\spad{S}} and with children list given by \axiom{[[\spad{s}]\$\% for \spad{s} in \spad{ls}]}.
198039`\axiom{construct(\spad{v},{}\spad{t},{}la)} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \axiom{[\spad{v},{}\spad{t}]\$\spad{S}} and with \axiom{la} as children list.
198101`\spad{construct(type,{}dims)} creates an element of FortranType
198218`\spad{construct(type,{}dims)} creates an element of FortranType
198322`\axiom{construct(\spad{v1},{}\spad{t},{}\spad{v2},{}\spad{lt})} creates a splitting tree with value (\spadignore{i.e.} root vertex) given by \axiom{[\spad{v},{}\spad{t}]\$\spad{S}} and with children list given by \axiom{[[[\spad{v},{}\spad{t}]\$\spad{S}]\$\% for \spad{s} in \spad{ls}]}.
198385`\spad{contains?(i,{}f)} returns \spad{true} if \axiom{\spad{f}} is contained within the interval \axiom{\spad{i}},{} \spad{false} otherwise.
198445`\spad{content([f1,{}..,{}fk])} = content of a list of univariate polynonials
198740`\spad{content(p)} gives the \spad{gcd} of the coefficients of polynomial \spad{p}.
198815`\spad{content(l)} returns the \spad{gcd} of all the coefficients of \spad{l}.
199043`\spad{content(p,{}v)} is the \spad{gcd} of the coefficients of the polynomial \spad{p} when \spad{p} is viewed as a univariate polynomial with respect to the variable \spad{v}. Thus,{} for polynomial 7*x**2*y + 14*x*y**2,{} the \spad{gcd} of the coefficients with respect to \spad{x} is 7*y.
199128`\spad{continue(l)} creates a representation of a FORTRAN CONTINUE labelled with \spad{l}
199365`\spad{continuedFraction(x)} converts the \spad{p}-adic rational number \spad{x} to a continued fraction.
199474`\spad{continuedFraction(f)} converts the floating point number \spad{f} to a reduced continued fraction.
199566`\spad{continuedFraction(r)} converts the fraction \spadvar{\spad{r}} with components of type \spad{R} to a continued fraction over \spad{R}.
199637`\spad{continuedFraction(b0,{}a,{}b)} constructs a continued fraction in the following way: if \spad{a = [a1,{}a2,{}...]} and \spad{b = [b1,{}b2,{}...]} then the result is the continued fraction \spad{b0 + a1/(b1 + a2/(b2 + ...))}.
199718`\spad{contractSolve(eq,{}x)} finds the solutions expressed in terms of radicals of the equation of rational functions \spad{eq} with respect to the symbol \spad{x}. The result contains new symbols for common subexpressions in order to reduce the size of the output.
199873`\spad{contractSolve(rf,{}x)} finds the solutions expressed in terms of radicals of the equation \spad{rf} = 0 with respect to the symbol \spad{x},{} where \spad{rf} is a rational function. The result contains new symbols for common subexpressions in order to reduce the size of the output.
200018`\spad{contract(I,{}lvar)} contracts the ideal \spad{I} to the polynomial ring \spad{F[lvar]}.
200413`\spad{contract(t,{}i,{}j)} is the contraction of tensor \spad{t} which sums along the \spad{i}\spad{-}th and \spad{j}\spad{-}th indices. For example,{} if \spad{r = contract(t,{}1,{}3)} for a rank 4 tensor \spad{t},{} then \spad{r} is the rank 2 \spad{(= 4 - 2)} tensor given by \indented{4}{\spad{r(i,{}j) = sum(h=1..dim,{}t(h,{}i,{}h,{}j))}.}
200490`\spad{contract(t,{}i,{}s,{}j)} is the inner product of tenors \spad{s} and \spad{t} which sums along the \spad{k1}\spad{-}th index of \spad{t} and the \spad{k2}\spad{-}th index of \spad{s}. For example,{} if \spad{r = contract(s,{}2,{}t,{}1)} for rank 3 tensors rank 3 tensors \spad{s} and \spad{t},{} then \spad{r} is the rank 4 \spad{(= 3 + 3 - 2)} tensor given by \indented{4}{\spad{r(i,{}j,{}k,{}l) = sum(h=1..dim,{}s(i,{}h
200490`--,{}j)*t(h,{}k,{}l))}.}
200570`\spad{controlPanel(v,{}s)} displays the control panel of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or hides the control panel if \spad{s} is "off".
200638`\spad{controlPanel(v,{}s)} displays the control panel of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or hides the control panel if \spad{s} is "off".
200708`\spad{convergents(x)} returns the stream of the convergents of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.
201091`\spad{convert(cs)} converts the complex expression \spad{cs} to a pattern
201207`\axiom{convert(\spad{lp})} returns the polynomial set whose members are the polynomials of \axiom{\spad{lp}}.
201278`\spad{convert([a1,{}...,{}an])} returns the pattern \spad{[a1,{}...,{}an]}.
203524`\spad{convert(s)} makes \spad{s} into an input form.
203984`\spad{convert(x)} converts a \spadtype{DoubleFloat} \spad{x} to a \spadtype{Float}.
204030`\spad{convert(x)} returns the Lisp atom \spad{x}.
204105`\spad{convert(f1\^e1 ... fm\^em)} returns \spad{(f1)\^e1 ... (fm)\^em} as an element of \%,{} using formal kernels created using a \spadfunFrom{paren}{ExpressionSpace}.
204184`\spad{convert(x)} returns the Lisp atom \spad{x}.
204258`\spad{convert(x)} returns the Lisp atom \spad{x}.
204332`\spad{convert(l)} takes a list of elements,{} \spad{l},{} from the domain Ring and returns the form of point category.
204385`\spad{convert(l)} is a function to convert a \axiomType{Segment OrderedCompletion Float} to a \axiomType{Segment OrderedCompletion DoubleFloat}
204521`\spad{convert([a1,{}...,{}an])} returns the \spad{S}-expression \spad{(a1,{}...,{}an)}.
204600`\spad{convert(q)} converts \spad{q}.
204782`\spad{convert(q)} converts \spad{q}.
204942`\axiom{convert(\spad{p})} returns the same as \axiom{retract(\spad{p})}.
205102`\axiom{convert(\spad{p})} returns the same as \axiom{retract(\spad{p})}.
205252`\axiom{convert(\spad{p})} returns the same as \axiom{retract(\spad{p})}.
205431`\spad{convert(p)} converts \spad{p}.
205545`\axiom{convert(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}},{} otherwise an error is produced.
205858`\spad{convert(i)} creates the segment \spad{i..i}.
205907`\spad{convert(u)} converts \spad{u}.
206053`\spad{convert(st)} returns the members of \spad{st}.
206344`\spad{convert(x)} returns the Lisp atom \spad{x}.
206418`\spad{convert(x)} returns the Lisp atom \spad{x}.
206492`\spad{convert(n)} creates a roman numeral for symbol \spad{n}.
206540`\spad{convert(up)} converts the univariate polynomial \spad{up} to an algebra element,{} reducing by the \spad{definingPolynomial()} if necessary.
206594`\spad{convert([a1,{}..,{}an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed basis.
206652`\spad{convert([a1,{}...,{}an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis.
206721`\spad{convert(a)} transforms a into an element of \spad{S}.
206768`\spad{convert(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.
206826`\spad{convert(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.
206895`\spad{convert(o,{}step)} changes \spad{o} in standard output format to SCRIPT formula format and also adds the given \spad{step} number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \spad{step} numbers.
206962`\spad{convert(o,{}step)} changes \spad{o} in standard output format to TeX format and also adds the given \spad{step} number. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \spad{step} numbers.
207019`\spad{convert(o,{}step,{}type)} changes \spad{o} in standard output format to TeX format and also adds the given \spad{step} number and \spad{type}. This is useful if you want to create equations with given numbers or have the equation numbers correspond to the interpreter \spad{step} numbers.
207087`\spad{coord(p)} specifies a change of coordinates of point \spad{p}. This option is expressed in the form \spad{coord == p}.
207165`\spad{coord }\undocumented
207331`\spad{coord(l,{}p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{coord}. If the option does not exist the value,{} \spad{p} is returned.
207474`\spad{coordinate(c,{}i)} returns a coordinate function for \spad{c} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component \spad{i} of the plane curve is.
207582`\spad{coordinate(c,{}i)} returns a coordinate function of \spad{c} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component,{} \spad{i},{} of the space curve is.
207690`\spad{coordinate(s,{}i)} returns a coordinate function of \spad{s} using 1-based indexing according to \spad{i}. This indicates what the function for the coordinate component,{} \spad{i},{} of the surface is.
208345`\spad{coordinates(p)} specifies a change of coordinate systems of point \spad{p}. This option is expressed in the form \spad{coordinates == p}.
208429`\spad{coordinates([v1,{}...,{}vm])} returns the coordinates of the \spad{vi}\spad{'s} with to the fixed basis. The coordinates of \spad{vi} are contained in the \spad{i}th row of the matrix returned by this function.
208512`\spad{coordinates([v1,{}...,{}vm])} returns the coordinates of the \spad{vi}\spad{'s} with to the fixed basis. The coordinates of \spad{vi} are contained in the \spad{i}th row of the matrix returned by this function.
208582`\spad{coordinates([a1,{}...,{}am])} returns a matrix whose \spad{i}-th row is formed by the coordinates of \spad{\spad{ai}} with respect to the fixed \spad{R}-module basis.
208663`\spad{coordinates(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{F}-vectorspace basis.
208738`\spad{coordinates(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.
208800`\spad{coordinates(a)} returns the coordinates of \spad{a} with respect to the fixed \spad{R}-module basis.
209661`\spad{coordinates(a,{}[v1,{}...,{}vn])} returns the coordinates of \spad{a} with respect to the \spad{R}-module basis \spad{v1},{}...,{}\spad{vn}.
209756`\spad{coordinates([v1,{}...,{}vm],{} basis)} returns the coordinates of the \spad{vi}\spad{'s} with to the basis \spad{basis}. The coordinates of \spad{vi} are contained in the \spad{i}th row of the matrix returned by this function.
209841`\spad{coordinates([a1,{}...,{}am],{}[v1,{}...,{}vn])} returns a matrix whose \spad{i}-th row is formed by the coordinates of \spad{\spad{ai}} with respect to the \spad{R}-module basis \spad{v1},{}...,{}\spad{vn}.
209937`\spad{coordinates(a,{}basis)} returns the coordinates of \spad{a} with respect to the \spad{basis} \spad{basis}.
210014`\spad{coordinates(a,{}[v1,{}...,{}vn])} returns the coordinates of \spad{a} with respect to the \spad{R}-module basis \spad{v1},{}...,{}\spad{vn}.
210102`\spad{copies(i,{}s)} will take a string \spad{s} and create a new string composed of \spad{i} copies of \spad{s}.
210163`\spad{copy!(c,{}a)} copies the matrix \spad{a} into the matrix \spad{c}. Error: if \spad{a} and \spad{c} do not have the same dimensions.
210379`\spad{copyInto!(u,{}v,{}i)} returns aggregate \spad{u} containing a copy of \spad{v} inserted at element \spad{i}.
210782`\spad{copy(p)} returns a recursive copy of \spad{p}.
210821`\axiom{copy(\spad{n})} returns a copy of \spad{n}.
210868`\spad{copy(x)} \undocumented
210922`\spad{copy(u)} returns a top-level (non-recursive) copy of \spad{u}. Note: for collections,{} \axiom{copy(\spad{u}) \spad{==} [\spad{x} for \spad{x} in \spad{u}]}.
210960`\spad{copy(n)} gives a copy of \spad{n}.
211008`\spad{copy(s)} returns a new \spadtype{ThreeSpace} that is an exact copy of \spad{s}.
211058`\spad{copy(op)} returns a copy of \spad{op}.
211100`\spad{corrPoly(u,{}lv,{}lr,{}ln,{}lu,{}t,{}r)} \undocumented
211362`\spad{cos2sec(f)} converts every \spad{cos(u)} appearing in \spad{f} into \spad{1/sec(u)}.
211424`\spad{cosIfCan(z)} returns cos(\spad{z}) if possible,{} and "failed" otherwise.
211504`\spad{cosSinInfo(n)} returns the list of lists of values for \spad{n},{} in the form: \spad{[[cos(n - 1) a,{}sin(n - 1) a],{}...,{}[cos 2 a,{}sin 2 a],{}[cos a,{}sin a]]} where \spad{a = 2 pi/n}. Note: \spad{n} should be greater than 2.
211578`\spad{cos(x)} makes a cos kernel for use in Fourier series
211624`\spad{cos(x)} applies the cosine operator to \spad{x}
211775`\spad{cos(st)} computes cosine of a power series \spad{st}.
211858`\spad{cos(st)} computes cosine of a power series \spad{st}.
211955`\spad{cos(z)} returns the cosine of Laurent series \spad{z}.
212041`\spad{cos(z)} returns the cosine of a Puiseux series \spad{z}.
212136`\spad{cos(x)} returns the cosine of \spad{x}.
212193`\spad{cos(x)} represents the Fortran intrinsic function COS
212273`\spad{cosh2sech(f)} converts every \spad{cosh(u)} appearing in \spad{f} into \spad{1/sech(u)}.
212337`\spad{coshIfCan(z)} returns cosh(\spad{z}) if possible,{} and "failed" otherwise.
212418`\spad{cosh(x)} applies the hyperbolic cosine operator to \spad{x}
212624`\spad{cosh(st)} computes the hyperbolic cosine of a power series \spad{st}.
212708`\spad{cosh(st)} computes the hyperbolic cosine of a power series \spad{st}.
212806`\spad{cosh(z)} returns the hyperbolic cosine of Laurent series \spad{z}.
212893`\spad{cosh(z)} returns the hyperbolic cosine of a Puiseux series \spad{z}.
212989`\spad{cosh(x)} returns the hyperbolic cosine of \spad{x}.
213044`\spad{cosh(x)} represents the Fortran intrinsic function COSH
213125`\spad{cot2tan(f)} converts every \spad{cot(u)} appearing in \spad{f} into \spad{1/tan(u)}.
213187`\spad{cot2trig(f)} converts every \spad{cot(u)} appearing in \spad{f} into \spad{cos(u)/sin(u)}.
213250`\spad{cotIfCan(z)} returns cot(\spad{z}) if possible,{} and "failed" otherwise.
213330`\spad{cot(x)} applies the cotangent operator to \spad{x}
213493`\spad{cot(st)} computes cotangent of a power series \spad{st}.
213576`\spad{cot(st)} computes cotangent of a power series \spad{st}.
213673`\spad{cot(z)} returns the cotangent of Laurent series \spad{z}.
213759`\spad{cot(z)} returns the cotangent of a Puiseux series \spad{z}.
213854`\spad{cot(x)} returns the cotangent of \spad{x}.
213911`\spad{coth2tanh(f)} converts every \spad{coth(u)} appearing in \spad{f} into \spad{1/tanh(u)}.
213975`\spad{coth2trigh(f)} converts every \spad{coth(u)} appearing in \spad{f} into \spad{cosh(u)/sinh(u)}.
214040`\spad{cothIfCan(z)} returns coth(\spad{z}) if possible,{} and "failed" otherwise.
214121`\spad{coth(x)} applies the hyperbolic cotangent operator to \spad{x}
214284`\spad{coth(st)} computes the hyperbolic cotangent of a power series \spad{st}.
214368`\spad{coth(st)} computes the hyperbolic cotangent of a power series \spad{st}.
214466`\spad{coth(z)} returns the hyperbolic cotangent of Laurent series \spad{z}.
214553`\spad{coth(z)} returns the hyperbolic cotangent of a Puiseux series \spad{z}.
214649`\spad{coth(x)} returns the hyperbolic cotangent of \spad{x}.
214704`\spad{countRealRootsMultiple(p)} says how many real roots \spad{p} has,{} counted with multiplicity
214819`\spad{countRealRoots(p)} says how many real roots \spad{p} has
216029`\spad{count(p,{}u)} returns the number of elements \spad{x} in \spad{u} such that \axiom{\spad{p}(\spad{x})} is \spad{true}. For collections,{} \axiom{count(\spad{p},{}\spad{u}) = reduce(+,{}[1 for \spad{x} in \spad{u} | \spad{p}(\spad{x})],{}0)}.
216145`\spad{count(x,{}u)} returns the number of occurrences of \spad{x} in \spad{u}. For collections,{} \axiom{count(\spad{x},{}\spad{u}) = reduce(+,{}[x=y for \spad{y} in \spad{u}],{}0)}.
216274`\spad{countable?(\spad{a})} determines whether \spad{a} is a countable cardinal,{} \spadignore{i.e.} an integer or \spad{Aleph 0}.
216328`\spad{create3Space()} creates a \spadtype{ThreeSpace} object capable of holding point,{} curve,{} mesh components and any combination.
216384`\spad{create3Space(s)} creates a \spadtype{ThreeSpace} object containing objects pre-defined within some \spadtype{SubSpace} \spad{s}.
216453`\spad{createGenericMatrix(m)} creates a square matrix of dimension \spad{k} whose entry at the \spad{i}-th row and \spad{j}-th column is the indeterminate {\em x[i,{}j]} (double subscripted).
216557`\spad{createIrreduciblePoly(n)}\$FFPOLY(\spad{GF}) generates a monic irreducible univariate polynomial of degree \spad{n} over the finite field {\em GF}.
216676`\spad{createLowComplexityNormalBasis(n)} tries to find a a low complexity normal basis of degree {\em n} over {\em GF} and returns its multiplication matrix If no low complexity basis is found it calls \axiomFunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}(\spad{n}) to produce a normal polynomial of degree {\em n} over {
216676`--\em GF}
216854`\spad{createLowComplexityTable(n)} tries to find a low complexity normal basis of degree {\em n} over {\em GF} and returns its multiplication matrix Fails,{} if it does not find a low complexity basis
217004`\spad{createMultiplicationMatrix(m)} forms the multiplication table {\em m} into a matrix over the ground field.
217135`\spad{createMultiplicationTable(f)} generates a multiplication table for the normal basis of the field extension determined by {\em f}. This is needed to perform multiplications between elements represented as coordinate vectors to this basis. See \spadtype{FFNBP},{} \spadtype{FFNBX}.
217356`\spad{createNormalElement()} computes a normal element over the ground field \spad{F},{} that is,{} \spad{a**(q**i),{} 0 <= i < extensionDegree()} is an \spad{F}-basis,{} where \spad{q = size()\$F}. Reference: Such an element exists Lidl/Niederreiter: Theorem 2.35.
217443`\spad{createNormalPoly(n)}\$FFPOLY(\spad{GF}) generates a normal polynomial of degree \spad{n} over the finite field {\em GF}.
217557`\spad{createNormalPrimitivePoly(n)}\$FFPOLY(\spad{GF}) generates a normal and primitive polynomial of degree \spad{n} over the field {\em GF}. Note: this function is equivalent to createPrimitiveNormalPoly(\spad{n})
217742`\spad{createPrimitiveElement()} computes a generator of the (cyclic) multiplicative group of the field.
217806`\spad{createPrimitiveNormalPoly(n)}\$FFPOLY(\spad{GF}) generates a normal and primitive polynomial of degree \spad{n} over the field {\em GF}. polynomial of degree \spad{n} over the field {\em GF}.
217929`\spad{createPrimitivePoly(n)}\$FFPOLY(\spad{GF}) generates a primitive polynomial of degree \spad{n} over the finite field {\em GF}.
218046`\spad{createRandomElement(aG,{}x)} creates a random element of the group algebra generated by {\em aG}.
218145`\spad{createThreeSpace()} creates a \spadtype{ThreeSpace(DoubleFloat)} object capable of holding point,{} curve,{} mesh components and any combination.
218223`\spad{createZechTable(f)} generates a Zech logarithm table for the cyclic group representation of a extension of the ground field by the primitive polynomial {\em f(x)},{} \spadignore{i.e.} \spad{Z(i)},{} defined by {\em x**Z(i) = 1+x**i} is stored at index \spad{i}. This is needed in particular to perform addition of field elements in finite fields represented in this way. See \spadty
218223`--pe{FFCGP},{} \spadtype{FFCGX}.
218387`\spad{credPol }\undocumented
218480`\spad{crest n} is used internally.
218595`\spad{critB }\undocumented
218697`\spad{critBonD }\undocumented
218921`\spad{critMTonD1 }\undocumented
219142`\spad{critM }\undocumented
219232`\spad{critMonD1 }\undocumented
219458`\spad{critT }\undocumented
219603`\spad{critpOrder }\undocumented
219820`\spad{cross(p,{}q)} computes the cross product of the two points \spad{p} and \spad{q} using only the first three coordinates,{} and keeping the color of the first point \spad{p}. The result is returned as a point.
219959`\spad{cross(p,{}q)} computes the cross product of the two points \spad{p} and \spad{q}. Error if the \spad{p} and \spad{q} are not 3 dimensional
220008`vectorProduct(\spad{u},{}\spad{v}) constructs the cross product of \spad{u} and \spad{v}. Error: if \spad{u} and \spad{v} are not of length 3.
220069`\axiom{crushedSet(\spad{lp})} returns \axiom{\spad{lq}} such that \axiom{\spad{lp}} and and \axiom{\spad{lq}} generate the same ideal and no rough basic sets reduce (in the sense of Groebner bases) the other polynomials in \axiom{\spad{lq}}.
220152`\spad{csc2sin(f)} converts every \spad{csc(u)} appearing in \spad{f} into \spad{1/sin(u)}.
220214`\spad{cscIfCan(z)} returns \spad{csc}(\spad{z}) if possible,{} and "failed" otherwise.
220294`\spad{csc(x)} applies the cosecant operator to \spad{x}
220457`\spad{csc(st)} computes cosecant of a power series \spad{st}.
220540`\spad{csc(st)} computes cosecant of a power series \spad{st}.
220637`\spad{csc(z)} returns the cosecant of Laurent series \spad{z}.
220723`\spad{csc(z)} returns the cosecant of a Puiseux series \spad{z}.
220818`\spad{csc(x)} returns the cosecant of \spad{x}.
220875`\spad{csch2sinh(f)} converts every \spad{csch(u)} appearing in \spad{f} into \spad{1/sinh(u)}.
220939`\spad{cschIfCan(z)} returns csch(\spad{z}) if possible,{} and "failed" otherwise.
221020`\spad{csch(x)} applies the hyperbolic cosecant operator to \spad{x}
221183`\spad{csch(st)} computes the hyperbolic cosecant of a power series \spad{st}.
221267`\spad{csch(st)} computes the hyperbolic cosecant of a power series \spad{st}.
221365`\spad{csch(z)} returns the hyperbolic cosecant of Laurent series \spad{z}.
221452`\spad{csch(z)} returns the hyperbolic cosecant of a Puiseux series \spad{z}.
221548`\spad{csch(x)} returns the hyperbolic cosecant of \spad{x}.
221603`\spad{csubst(a,{}b)} is for internal use only
221719`\spad{cubic(u)} \undocumented
221785`\spad{cubic(f,{}g,{}h,{}i)} \undocumented
221856`\spad{cup(s1,{}s2)},{} introduced by Redfield,{} \indented{1}{is the scalar product of two cycle indices,{} in which the} \indented{1}{power sums are retained to produce a cycle index.}
222010`\spad{currentSubProgram()} returns the name of the current subprogram being processed
222068`\spad{curryLeft(f,{}a)} is the function \spad{g} \indented{1}{such that \spad{g b = f(a,{}b)}.}
222136`\spad{curryRight(f,{}b)} is the function \spad{g} such that \indented{1}{\spad{g a = f(a,{}b)}.}
222205`\spad{cu(f,{}a)} is the function \spad{g} \indented{1}{such that \spad{g ()= f a}.}
222264`\spad{curve?(s)} queries whether the \spadtype{ThreeSpace},{} \spad{s},{} is a curve,{} \spadignore{i.e.} has one component,{} a list of list of points,{} and returns \spad{true} if it is,{} or \spad{false} otherwise.
222321`\spad{curveColorPalette(l,{}p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{curveColorPalette}. If the option does not exist the value,{} \spad{p} is returned.
222410`\spad{curveColor(v)} specifies a color,{} \spad{v},{} for 2D graph curves. This option is expressed in the form \spad{curveColor == v}.
222458`\spad{curveColor(p)} specifies a color index for 2D graph curves from the spadcolors palette \spad{p}. This option is expressed in the form \spad{curveColor ==p}.
222508`\spad{curve([p0,{}p1,{}p2,{}...,{}pn])} creates a space curve defined by the list of points \spad{p0} through \spad{pn},{} and returns the \spadtype{ThreeSpace} whose component is the curve.
222571`\spad{curve(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single curve defined by a list of points and if so,{} returns the curve,{} \spadignore{i.e.} list of points. An error is signaled otherwise.
222634`\spad{curve(c1,{}c2)} creates a plane curve from 2 component functions \spad{c1} and \spad{c2}.
222736`\spad{curve(s,{}[[p0],{}[p1],{}...,{}[pn]])} adds a space curve which is a list of points \spad{p0} through \spad{pn} defined by lists of elements from the domain \spad{PointDomain(m,{}R)},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined and \spad{m} is the dimension of the points,{} to the \spadtype{ThreeSpace} \spad{s}.
222801`\spad{curve(s,{}[p0,{}p1,{}...,{}pn])} adds a space curve component defined by a list of points \spad{p0} through \spad{pn},{} to the \spadtype{ThreeSpace} \spad{s}.
222867`\spad{curve(c1,{}c2,{}c3)} creates a space curve from 3 component functions \spad{c1},{} \spad{c2},{} and \spad{c3}.
222987`\spad{cycleElt(s)} returns a pointer to a node in the cycle if the stream \spad{s} is cyclic and returns "failed" if \spad{s} is not cyclic
223169`\spad{cycleEntry(u)} returns the head of a top-level cycle contained in aggregate \spad{u},{} or \axiom{empty()} if none exists.
223376`\spad{cycleLength(u)} returns the length of a top-level cycle contained in aggregate \spad{u},{} or 0 is \spad{u} has no such cycle.
223454`\spad{cyclePartition(p)} returns the cycle structure of a permutation \spad{p} including cycles of length 1 only if \spad{S} is finite.
223514`\spad{cycleRagits(rx)} returns the cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \spad{x = 3/28 = 0.10 714285 714285 ...},{} then \spad{cycleRagits(x) = [7,{}1,{}4,{}2,{}8,{}5]}.
223637`\spad{cycleSplit!(u)} splits the aggregate by dropping off the cycle. The value returned is the cycle entry,{} or nil if none exists. For example,{} if \axiom{\spad{w} = concat(\spad{u},{}\spad{v})} is the cyclic list where \spad{v} is the head of the cycle,{} \axiom{cycleSplit!(\spad{w})} will drop \spad{v} off \spad{w} thus destructively changing \spad{w} to \spad{u},{} and returning \spad{v}.
223842`\spad{cycleTail(u)} returns the last node in the cycle,{} or empty if none exists.
223902`\spad{cycle(ls)} coerces a cycle {\em ls},{} \spadignore{i.e.} a list with not repetitions to a permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list. Error: if repetitions occur.
223959`\spad{cycles(lls)} coerces a list list of cycles {\em lls} to a permutation,{} each cycle being a list with not repetitions,{} is coerced to the permutation,{} which maps {\em ls.i} to {\em ls.i+1},{} indices modulo the length of the list,{} then these permutations are mutiplied. Error: if repetitions occur in one cycle.
224200`\spad{cyclic?(u)} tests if \spad{u} has a cycle.
224258`\spad{cyclic?(t)} tests if \spad{t} is a cyclic tree.
224302`\spad{cyclicCopy(l)} makes a copy of a (possibly) cyclic tree \spad{l}.
224344`\spad{cyclicEntries(t)} returns a list of top-level cycles in tree \spad{t}.
224395`\spad{cyclicEqual?(t1,{} t2)} tests of two cyclic trees have the same structure.
224447`\spad{cyclicGroup([i1,{}...,{}ik])} constructs the cyclic group of order \spad{k} acting on the integers {\em i1},{}...,{}{\em ik}. Note: duplicates in the list will be removed.
224541`\spad{cyclicGroup(n)} constructs the cyclic group of order \spad{n} acting on the integers 1,{}...,{}\spad{n}.
224637`\spad{cyclicParents(t)} returns a list of cycles that are parents of \spad{t}.
224688`\spad{cyclicSubmodule(lm,{}v)} generates a basis as follows. It is assumed that the size \spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an \spad{A}-module in the natural way. cyclicSubmodule(\spad{lm},{}\spad{v}) gener
224688`--ates the \spad{R}-Basis of {\em Av} as described in section 6 of \spad{R}. A. Parker\spad{'s} "The Meat-Axe". Note: in contrast to the description in "The Meat-Axe" and to {\em standardBasisOfCyclicSubmodule} the result is in echelon form.
224813`\spad{cyclic n} is the cycle index of the \indented{1}{cyclic group of degree \spad{n}.}
224900`\spad{cyclotomicDecomposition(n)} \undocumented{}
225019`\spad{cyclotomicFactorization(n)} \undocumented{}
225142`\spad{cyclotomic(n)} \undocumented{}
225242`\spad{cyclotomic(n)} returns the \spad{n}th cyclotomic polynomial \spad{phi[n](x)}. Note: \spad{phi[n](x)} is the factor of \spad{x**n - 1} whose roots are the primitive \spad{n}th roots of unity.
225346`\spad{cyclotomic(n,{}r)} \undocumented
225435`\spad{cylindrical(pt)} transforms \spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \spad{(r,{}theta,{}z)} to \spad{x = r * cos(theta)},{} \spad{y = r * sin(theta)},{} \spad{z}.
225503`\spad{d01ajf(a,{}b,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}f)} is a general-purpose integrator which calculates an approximation to the integral of a function \spad{f}(\spad{x}) over a finite interval [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01ajf}.
225658`\spad{d01akf(a,{}b,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}f)} is an adaptive integrator,{} especially suited to oscillating,{} non-singular integrands,{} which calculates an approximation to the integral of a function \spad{f}(\spad{x}) over a finite interval [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01akf}.
225813`\spad{d01alf(a,{}b,{}npts,{}points,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}f)} is a general purpose integrator which calculates an approximation to the integral of a function \spad{f}(\spad{x}) over a finite interval [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01alf}.
225997`\spad{d01amf(bound,{}inf,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}f)} calculates an approximation to the integral of a function \spad{f}(\spad{x}) over an infinite or semi-infinite interval [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01amf}.
226148`\spad{d01anf(a,{}b,{}omega,{}key,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}g)} calculates an approximation to the sine or the cosine transform of a function \spad{g} over [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01anf}.
226324`\spad{d01apf(a,{}b,{}alfa,{}beta,{}key,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}g)} is an adaptive integrator which calculates an approximation to the integral of a function \spad{g}(\spad{x})\spad{w}(\spad{x}) over a finite interval [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01apf}.
226512`\spad{d01aqf(a,{}b,{}c,{}epsabs,{}epsrel,{}lw,{}liw,{}ifail,{}g)} calculates an approximation to the Hilbert transform of a function \spad{g}(\spad{x}) over [a,{}\spad{b}]: See \downlink{Manual Page}{manpageXXd01aqf}.
226679`\spad{d01asf(a,{}omega,{}key,{}epsabs,{}limlst,{}lw,{}liw,{}ifail,{}g)} calculates an approximation to the sine or the cosine transform of a function \spad{g} over [a,{}infty): See \downlink{Manual Page}{manpageXXd01asf}.
226838`\spad{d01bbf(a,{}b,{}itype,{}n,{}gtype,{}ifail)} returns the weight appropriate to a Gaussian quadrature. The formulae provided are Gauss-Legendre,{} Gauss-Rational,{} Gauss- Laguerre and Gauss-Hermite. See \downlink{Manual Page}{manpageXXd01bbf}.
226947`\spad{d01fcf(ndim,{}a,{}b,{}maxpts,{}eps,{}lenwrk,{}minpts,{}ifail,{}functn)} attempts to evaluate a multi-dimensional integral (up to 15 dimensions),{} with constant and finite limits,{} to a specified relative accuracy,{} using an adaptive subdivision strategy. See \downlink{Manual Page}{manpageXXd01fcf}.
227127`\spad{d01gaf(x,{}y,{}n,{}ifail)} integrates a function which is specified numerically at four or more points,{} over the whole of its specified range,{} using third-order finite-difference formulae with error estimates,{} according to a method due to Gill and Miller. See \downlink{Manual Page}{manpageXXd01gaf}.
227236`\spad{d01gbf(ndim,{}a,{}b,{}maxcls,{}eps,{}lenwrk,{}mincls,{}wrkstr,{}ifail,{}functn)} returns an approximation to the integral of a function over a hyper-rectangular region,{} using a Monte Carlo method. An approximate relative error estimate is also returned. This routine is suitable for low accuracy wo
227236`--rk. See \downlink{Manual Page}{manpageXXd01gbf}.
227437`\spad{d02bbf(xend,{}m,{}n,{}irelab,{}x,{}y,{}tol,{}ifail,{}fcn,{}output)} integrates a system of first-order ordinary differential equations over an interval with suitable initial conditions,{} using a Runge-Kutta-Merson method,{} and returns the solution at points specified by t
227437`--he user. See \downlink{Manual Page}{manpageXXd02bbf}.
227664`\spad{d02bhf(xend,{}n,{}irelab,{}hmax,{}x,{}y,{}tol,{}ifail,{}g,{}fcn)} integrates a system of first-order ordinary differential equations over an interval with suitable initial conditions,{} using a Runge-Kutta-Merson method,{} until a user-specified function of the solution is z
227664`--ero. See \downlink{Manual Page}{manpageXXd02bhf}.
227890`\spad{d02cjf(xend,{}m,{}n,{}tol,{}relabs,{}x,{}y,{}ifail,{}g,{}fcn,{}output)} integrates a system of first-order ordinary differential equations over a range with suitable initial conditions,{} using a variable-order,{} variable-step Adams method unti
227890`--l a user-specified function,{} if supplied,{} of the solution is zero,{} and returns the solution at points specified by the user,{} if desired. See \downlink{Manual Page}{manpageXXd02cjf}.
228146`\spad{d02ejf(xend,{}m,{}n,{}relabs,{}iw,{}x,{}y,{}tol,{}ifail,{}g,{}fcn,{}pederv,{}output)} integrates a stiff system of first-order ordinary differential equations over an interval with suitable initial con
228146`--ditions,{} using a variable-order,{} variable-step method implementing the Backward Differentiation Formulae (\spad{BDF}),{} until a user-specified function,{} if supplied,{} of the solution is zero,{} and returns the solution at points specified by the user,{} if desired. See \downlink{Manual Page}{manpageXXd02ejf}.
228446`\spad{d02gaf(u,{}v,{}n,{}a,{}b,{}tol,{}mnp,{}lw,{}liw,{}x,{}np,{}ifail,{}fcn)} solves the two-point boundary-value problem with assigned boundary values for a system of ordinary differential equations,{} using a deferred correction technique and a Newton iter
228446`--ation. See \downlink{Manual Page}{manpageXXd02gaf}.
228694`\spad{d02gbf(a,{}b,{}n,{}tol,{}mnp,{}lw,{}liw,{}c,{}d,{}gam,{}x,{}np,{}ifail,{}fcnf,{}fcng)} solves a general linear two-point boundary value problem for a system of ordinary differential equations using
228694`-- a deferred correction technique. See \downlink{Manual Page}{manpageXXd02gbf}.
228998`\spad{d02kef(xpoint,{}m,{}k,{}tol,{}maxfun,{}match,{}elam,{}delam,{}hmax,{}maxit,{}ifail,{}coeffn,{}bdyval)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a finite or infinite range,{} using a P
228998`--ruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \downlink{Manual Page}{manpageXXd02kef}. ASP domains \spad{Asp12} and \spad{Asp33} are used to supply default subroutines for the MONIT and REPORT arguments via their \axiomOp{outputAsFortran} operation.
229266`\spad{d02kef(xpoint,{}m,{}k,{}tol,{}maxfun,{}match,{}elam,{}delam,{}hmax,{}maxit,{}ifail,{}coeffn,{}bdyval,{}monit,{}report)} finds a specified eigenvalue of a regular singular second- order Sturm-Liouville system on a fi
229266`--nite or infinite range,{} using a Pruefer transformation and a shooting method. It also reports values of the eigenfunction and its derivatives. Provision is made for discontinuities in the coefficient functions or their derivatives. See \downlink{Manual Page}{manpageXXd02kef}. Files \spad{monit} and \spad{report} will be used to define the subroutines for the MONIT and REPORT arguments. See \downlink{Manual Page}{manpageXXd02gbf}.
229552`\spad{d02raf(n,{}mnp,{}numbeg,{}nummix,{}tol,{}init,{}iy,{}ijac,{}lwork,{}liwork,{}np,{}x,{}y,{}deleps,{}ifail,{}fcn,{}g)} solves the two-point boundary-value problem with general boundary co
229552`--nditions for a system of ordinary differential equations,{} using a deferred correction technique and Newton iteration. See \downlink{Manual Page}{manpageXXd02raf}.
229868`\spad{d03edf(ngx,{}ngy,{}lda,{}maxit,{}acc,{}iout,{}a,{}rhs,{}ub,{}ifail)} solves seven-diagonal systems of linear equations which arise from the discretization of an elliptic partial differential equation on a rectangular region. This routine uses a multigrid technique. See \downlink{Manual Page}{manpageXXd03edf}.
230059`\spad{d03eef(xmin,{}xmax,{}ymin,{}ymax,{}ngx,{}ngy,{}lda,{}scheme,{}ifail,{}pdef,{}bndy)} discretizes a second order elliptic partial differential equation (PDE) on a rectangular region. See \downlink{Manual Page}{manpageXXd03eef}.
230285`\spad{d03faf(xs,{}xf,{}l,{}lbdcnd,{}bdxs,{}bdxf,{}ys,{}yf,{}m,{}mbdcnd,{}bdys,{}bdyf,{}zs,{}zf,{}n,{}nbdcnd,{}bdzs,{
230285`--}bdzf,{}lambda,{}ldimf,{}mdimf,{}lwrk,{}f,{}ifail)} solves the Helmholtz equation in Cartesian co-ordinates in three dimensions using the standard seven-point finite difference approximation. This routine is designed to be particularly efficient on vector processors. See \downlink{Manual Page}{manpageXXd03faf}.
230676`\spad{dAndcExp(v,{}n,{}k)} computes \spad{v**e} interpreting \spad{v} as an element of normal basis field. A divide and conquer algorithm similar to the one from \spad{D}.\spad{R}.Stinson,{} "Some observations on parallel Algorithms for fast exponentiation in \spad{GF}(2^n)",{} Siam \spad{J}. Computation,{} Vol.19,{} No.4,{} \spad{pp}.711-717,{} August 1990 is used. Argument \spad{k} is a
230676`-- parameter of this algorithm.
230792`\spad{dark(c)} sets the shade of the indicated hue of \spad{c} to it\spad{'s} lowest value.
230831`\spad{datalist(l)} creates a datalist from \spad{l}
230880`\spad{ddFact(f,{}p)} computes a distinct degree factorization of the polynomial \spad{f} modulo the prime \spad{p},{} \spadignore{i.e.} such that each factor is a product of irreducibles of the same degrees. The input polynomial \spad{f} is assumed to be square-free modulo \spad{p}.
230987`\spad{debug3D(true)} turns debug mode on; debug3D(\spad{false}) turns debug mode off.
231035`\spad{debug(true)} turns debug mode on \spad{debug(false)} turns debug mode off
231079`\spad{dec(x)} returns \spad{x - 1}.
231126`\spad{decimal(r)} converts a rational number to a decimal expansion.
231189`\spad{declare!(u,{}t)} declares the parameter \spad{u} to have type \spad{t} in the current level of the symbol table.
231261`\spad{declare!(l,{}t,{}tab)} creates new entrys in \spad{tab},{} declaring each of \spad{l} to be of type \spad{t}
231339`\spad{declare!(u,{}t,{}asp)} declares the parameter \spad{u} to have type \spad{t} in \spad{asp}.
231418`\spad{declare!(u,{}t,{}tab)} creates a new entry in \spad{tab},{} declaring \spad{u} to be of type \spad{t}
231490`\spad{declare!(u,{}t,{}asp,{}tab)} declares the parameters \spad{u} of subprogram \spad{asp} to have type \spad{t} in symbol table \spad{tab}.
231578`\spad{declare!(u,{}t,{}asp,{}tab)} declares the parameter \spad{u} of subprogram \spad{asp} to have type \spad{t} in symbol table \spad{tab}.
231660`\spad{declare(t)} returns a name \spad{f} such that \spad{f} has been declared to the interpreter to be of type \spad{t},{} but has not been assigned a value yet. Note: \spad{t} should be created as \spad{devaluate(T)\$Lisp} where \spad{T} is the actual type of \spad{f} (this hack is required for the case where \spad{T} is a mapping type).
231711`\spad{decomposeFunc(func1,{} func2,{} newvar)} returns a function \spad{func3} where \spad{func1} = \spad{func3}(\spad{func2}) and expresses it in the new variable newvar. If there is no solution then \spad{func1} will be returned.
231978`\spad{decompose(up)} \undocumented
232047`\spad{decompose(d)} returns \spad{[id,{} f]} where \spad{d = (id) + div(f)}.
232179`\spad{decompose(f,{} D)} returns \spad{[p,{}n,{}s]} such that \spad{f = p+n+s},{} all the squarefree factors of \spad{denom(n)} are normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} \spad{denom(s)} is special \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and \spad{n} and \spad{s} are proper fractions (no pole at infinity). \spad{D} is the derivation to use.
232314`\spad{decompose(up,{}m,{}n)} \undocumented
232949`\spad{decreasePrecision(n)} decreases the current \spadfunFrom{precision}{FloatingPointSystem} precision by \spad{n} decimal digits.
233065`\axiom{decrease(attributeName)} decreases the value for the effect of the attribute \axiom{attributeName} with all routines. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
233121`\axiom{decrease(routineName,{}attributeName)} decreases the value for the effect of the attribute \axiom{attributeName} with routine \axiom{routineName}. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
233184`\spad{deepCopy(x)} \undocumented
233230`\spad{deepExpand(x)} \undocumented{}
233369`\axiom{deepestInitial(\spad{p})} returns an error if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns the last term of \axiom{iteratedInitials(\spad{p})}.
233508`\axiom{deepestTail(\spad{p})} returns \axiom{0} if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns tail(\spad{p}),{} if \axiom{tail(\spad{p})} belongs to \axiom{\spad{R}} or \axiom{mvar(tail(\spad{p})) < mvar(\spad{p})},{} otherwise returns \axiom{deepestTail(tail(\spad{p}))}.
233578`\spad{defineProperty(s,{}\spad{li},{}p)} defines the component property in the 3 dimensional subspace,{} \spad{s},{} to be that of \spad{p},{} where \spad{p} is of the domain \spadtype{SubSpaceComponentProperty}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component whose property is being defined. The subspace,{} \s
233578`--pad{s},{} is returned with the component property definition.
233681`\spad{definingEquations(s)} returns a list of defining polynomials for equations,{} that is,{} for the Zariski closed part of \spad{s}.
233768`\spad{definingInequation(s)} returns a single defining polynomial for the inequation,{} that is,{} the Zariski open part of \spad{s}.
233934`\spad{definingPolynomial()} returns the polynomial used to define the field extension.
234034`\spad{definingPolynomial()} returns the minimal polynomial which \spad{generator()} satisfies.
234097`\spad{definingPolynomial(f)} returns the defining polynomial of \spad{f} as an element of \spad{F}. Error: if \spad{f} is not a kernel.
234189`\axiom{definingPolynomial(aRoot)} gives a polynomial such that \axiom{definingPolynomial(aRoot).aRoot = 0}
234287`\spad{definingPolynomial(x)} returns an expression \spad{p} such that \spad{p(x) = 0}.
234357`\spad{degreePartition(f)} returns the degree partition (\spadignore{i.e.} the multiset of the degrees of the irreducible factors) of the polynomial \spad{f}.
234469`\spad{degreePartition(ddfactorization)} returns the degree partition of the polynomial \spad{f} modulo \spad{p} where \spad{ddfactorization} is the distinct degree factorization of \spad{f} computed by \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} for some prime \spad{p}.
234596`\axiom{indiceSubResultant(\spad{P},{} \spad{Q},{} \spad{i})} returns a subresultant \axiom{\spad{S}} of degree \axiom{\spad{d}} and carries out the equality \axiom{coef1*P + coef2*Q = S_i}.
234750`\axiom{degreeSubResultant(\spad{P},{} \spad{Q},{} \spad{d})} computes a subresultant of degree \axiom{\spad{d}}.
235305`\spad{degree(df)} returns the homogeneous degree of differential form \spad{df}.
235375`\spad{degree(x)} \undocumented
235434`\spad{degree(p)} returns the homogeneous degree of \spad{p}.
235497`\spad{degree(x)} gives the numbers of 1\spad{'s} in \spad{x},{} \spadignore{i.e.} the number of non-zero exponents in the basis element that \spad{x} represents.
235555`\spad{degree(p)} returns the maximum of the exponents of the terms of \spad{p}.
235607`\spad{degree(g)} names the degree of \spad{g}. The set of all elements of a given degree form an \spad{R}-module.
235654`\spad{degree(f)} returns the exponent of the lowest order term of \spad{f}.
235723`\spad{degree(f(x))} returns the degree of the leading term of the Puiseux series \spad{f(x)},{} which may have zero as a coefficient.
235821`\spad{degree(f(x))} returns the degree of the lowest order term of \spad{f(x)},{} which may have zero as a coefficient.
235909`\axiom{degree(\spad{x})} returns the greatest length of a word in the support of \axiom{\spad{x}}.
235980`\spad{degree(l)} is \spad{n} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
236053`\axiom{degree(\spad{ts})} returns the product of main degrees of the members of \axiom{\spad{ts}}.
236130`\spad{degree(l)} is \spad{n} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
236212`\spad{degree(p)} returns the degree of \spad{p}. \indented{1}{Note that the degree of a word is its length.}
236280`\spad{degree(p)} retuns the number of points moved by the permutation \spad{p}.
236341`\spad{degree(gp)} returns the number of points moved by all permutations of the group {\em gp}.
236407`\spad{degree(a)} returns the degree of minimal polynomial of an element \spad{a} if \spad{a} is algebraic with respect to the ground field \spad{F},{} and \spad{infinity} otherwise.
236488`\spad{degree(a)} returns the degree of the minimal polynomial of an element \spad{a} over the ground field \spad{F}.
237037`\spad{degree(upoly,{} lvar)} returns a list containing the maximum degree for each variable in lvar.
237154`\spad{degree(p,{}lv)} gives the list of degrees of polynomial \spad{p} with respect to each of the variables in the list \spad{lv}.
237250`\spad{degree(p,{} s)} returns the maximum degree of the differential polynomial \spad{p} viewed as a differential polynomial in the differential indeterminate \spad{s} alone.
237338`\spad{degree(p,{}v)} gives the degree of polynomial \spad{p} with respect to the variable \spad{v}.
237422`\spad{delay(f)} creates a stream with a lazy evaluation defined by function \spad{f}. Caution: This function can only be called in compiled code.
237587`\spad{delete!(u,{}i)} destructively deletes the \axiom{\spad{i}}th element of \spad{u}.
237655`\spad{delete!(u,{}i..j)} destructively deletes elements \spad{u}.\spad{i} through \spad{u}.\spad{j}.
237741`\spad{deleteProperty!(op,{} s)} unattaches property \spad{s} from \spad{op}. Argument \spad{op} is modified "in place",{} \spadignore{i.e.} no copy is made.
237801`\spad{deleteRoutine!(R,{}s)} destructively deletes the given routine from the current database of NAG routines
238286`\spad{delete(u,{}i)} returns a copy of \spad{u} with the \axiom{\spad{i}}th element deleted. Note: for lists,{} \axiom{delete(a,{}\spad{i}) \spad{==} concat(a(0..\spad{i} - 1),{}a(\spad{i} + 1,{}..))}.
238343`\spad{delete(u,{}i..j)} returns a copy of \spad{u} with the \axiom{\spad{i}}th through \axiom{\spad{j}}th element deleted. Note: \axiom{delete(a,{}\spad{i}..\spad{j}) = concat(a(0..\spad{i}-1),{}a(\spad{j+1}..))}.
238418`\spad{delta(S,{}k,{}p)} returns the number of elements of \spad{S} which are strictly between \spad{p} and the \spad{k^}{th} element of \spad{S}.
238523`\spad{denomLODE(op,{} g)} returns a polynomial \spad{d} such that any rational solution of \spad{op y = g} is of the form \spad{p/d} for some polynomial \spad{p},{} and "failed",{} if the equation has no rational solution.
238610`\spad{denomLODE(op,{} [g1,{}...,{}gm])} returns a polynomial \spad{d} such that any rational solution of \spad{op y = c1 g1 + ... + cm gm} is of the form \spad{p/d} for some polynomial \spad{p}.
238687`\spad{denomRicDE(op)} returns a polynomial \spad{d} such that any rational solution of the associated Riccati equation of \spad{op y = 0} is of the form \spad{p/d + q'/q + r} for some polynomials \spad{p} and \spad{q} and a reduced \spad{r}. Also,{} \spad{deg(p) < deg(d)} and {\spad{gcd}(\spad{d},{}\spad{q}) = 1}.
238749`\spad{denom(1/d * (f1,{}...,{}fn))} returns \spad{d}.
238803`\spad{denom x} returns the denominator of \spad{x}.
238851`\spad{denom x} returns the denominator of \spad{x}.
238895`\spad{denom(f)} returns the denominator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.
238991`\spad{denom(x)} returns the denominator of the fraction \spad{x}.
239044`\spad{denom(f)} returns the denominator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.
239135`\spad{denom(f)} returns the denominator of \spad{f} viewed as a polynomial in the kernels over \spad{R}.
239346`\spad{denominator(f)} returns the denominator of \spad{f} converted to \%.
239419`\spad{denominator(x)} is the denominator of the fraction \spad{x} converted to \%.
239479`\spad{denominators(x)} returns the stream of denominators of the approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.
239543`\spad{depth(p)} returns the nesting level of \spad{p}.
239599`\spad{depth(s)} returns the number of elements of stack \spad{s}. Note: \axiom{depth(\spad{s}) = \spad{#s}}.
239662`\spad{dequeue! s} destructively extracts the first (top) element from queue \spad{q}. The element previously second in the queue becomes the first element. Error: if \spad{q} is empty.
239711`\spad{dequeue()}\$\spad{D} creates an empty dequeue of type \spad{D}.
239760`\spad{dequeue([x,{}y,{}...,{}z])} creates a dequeue with first (top or front) element \spad{x},{} second element \spad{y},{}...,{}and last (bottom or back) element \spad{z}.
239816`\spad{dequeue([x,{}y,{}...,{}z])} creates a dequeue with first (top or front) element \spad{x},{} second element \spad{y},{}...,{}and last (bottom or back) element \spad{z}.
239863`\spad{deref(n)} is equivalent to \spad{elt(n)}.
239904`\spad{deriv(a)} returns the derivative of the power series with respect to the power series variable. Thus \spad{deriv([a0,{}a1,{}a2,{}...])} returns \spad{[a1,{}2 a2,{}3 a3,{}...]}.
240066`\spad{derivationCoordinates(b,{} ')} returns \spad{M} such that \spad{b' = M b}.
240168`\spad{derivative(op)} returns the value of the "\%diff" property of \spad{op} if it has one,{} and "failed" otherwise.
240272`\spad{derivative(op,{} foo)} attaches foo as the "\%diff" property of \spad{op}. If \spad{op} has an "\%diff" property \spad{f},{} then applying a derivation \spad{D} to \spad{op}(a) returns \spad{f(a) * D(a)}. Argument \spad{op} must be unary.
240362`\spad{derivative(op,{} [foo1,{}...,{}foon])} attaches [\spad{foo1},{}...,{}foon] as the "\%diff" property of \spad{op}. If \spad{op} has an "\%diff" property \spad{[f1,{}...,{}fn]} then applying a derivation \spad{D} to \spad{op(a1,{}...,{}an)} returns \spad{f1(a1,{}...,{}an) * D(a1) + ... + fn(a1,{}...,{}an) * D(an)}.
240464`\spad{destruct(r)} returns the list of matches (var,{} expr) in \spad{r}. Error: if \spad{r} is a failed match.
240550`\spad{destruct((a1,{}...,{}an))} returns the list [\spad{a1},{}...,{}an].
240630`\spad{determinant(m)} returns the determinant of the matrix \spad{m}. an error message is returned if the matrix is not square.
240710`\spad{determinant(m)} returns the determinant of the matrix \spad{m}. an error message is returned if the matrix is not square.
240785`\spad{determinant(m)} returns the determinant of the matrix \spad{m}. Error: if the matrix is not square.
240879`\spad{determinant(m)} returns the determinant of the matrix \spad{m}.
240984`\spad{df2ef(a)} coerces a \axiomType{DoubleFloat} to \axiomType{Expression Float}
241062`\spad{df2fi(n)} is a function to convert a \axiomType{DoubleFloat} to a \axiomType{Fraction Integer}
241140`\spad{df2mf(n)} coerces a \axiomType{DoubleFloat} to \axiomType{MachineFloat}
241213`\spad{df2st(n)} coerces a \axiomType{DoubleFloat} to \axiomType{String}
241285`\spad{df2st(n)} coerces a \axiomType{DoubleFloat} to \axiomType{String}
241352`\spad{df2st(n)} coerces a \axiomType{DoubleFloat} to \axiomType{String}
241411`\spad{dfRange(r)} converts a range including \inputbitmap{\htbmdir{}/plusminus.bitmap} \infty to \axiomType{DoubleFloat} equavalents.
241541`\spad{dflist(l)} returns a list of \axiomType{DoubleFloat} equivalents of list \spad{l}
241669`\spad{diag(f)} is the function \spad{g} \indented{1}{such that \spad{g a = f(a,{}a)}.}
241865`\spad{diagonal?(m)} returns \spad{true} if the matrix \spad{m} is square and diagonal (\spadignore{i.e.} all entries of \spad{m} not on the diagonal are zero) and \spad{false} otherwise.
241929`\spad{diagonal?(m)} returns \spad{true} if the matrix \spad{m} is square and diagonal (\spadignore{i.e.} all entries of \spad{m} not on the diagonal are zero) and \spad{false} otherwise.
242140`\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \spad{l} on the diagonal.
242209`\spad{diagonalMatrix(l)} returns a diagonal matrix with the elements of \spad{l} on the diagonal.
242289`\spad{diagonalMatrix([m1,{}...,{}mk])} creates a block diagonal matrix \spad{M} with block matrices {\em m1},{}...,{}{\em mk} down the diagonal,{} with 0 block matrices elsewhere. More precisly: if \spad{\spad{ri} := nrows \spad{mi}},{} \spad{\spad{ci} := ncols \spad{mi}},{} then \spad{m} is an (\spad{r1+}..\spad{+rk}) by (\spad{c1+}..\spad{+ck}) - matrix with entries \spad{m.i.j = ml.(i-r1-..-r(l-1)).(j-n1-..-n(l-1))},{} if \spad{(r
242289`--1+..+r(l-1)) < i <= r1+..+rl} and \spad{(c1+..+c(l-1)) < i <= c1+..+cl},{} \spad{m.i.j} = 0 otherwise.
242359`\spad{diagonalMatrix(v)} returns a diagonal matrix where the elements of \spad{v} appear on the diagonal.
242414`\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \spad{m}
242558`\spad{diagonalProduct(m)} returns the product of the elements on the diagonal of the matrix \spad{m}.
242700`\spad{diagonal(m)} returns a row consisting of the elements on the diagonal of the matrix \spad{m}.
242770`\spad{diagonals(v,{}s)} displays the diagonals of the polygon outline showing a triangularized surface instead of a quadrilateral surface outline,{} for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or does not display the diagonals if \spad{s} is "off".
242933`\spad{dictionary()}\$\spad{D} creates an empty dictionary of type \spad{D}.
243099`\spad{dictionary([x,{}y,{}...,{}z])} creates a dictionary consisting of entries \axiom{\spad{x},{}\spad{y},{}...,{}\spad{z}}.
243162`\spad{diff(x)} returns the derivation with respect to \spad{x}.
243422`\spad{difference(u,{}x)} returns the set aggregate \spad{u} with element \spad{x} removed. If \spad{u} does not contain \spad{x},{} a copy of \spad{u} is returned. Note: \axiom{difference(\spad{s},{} \spad{x}) = difference(\spad{s},{} {\spad{x}})}.
243474`\spad{difference(u,{}v)} returns the set aggregate \spad{w} consisting of elements in set aggregate \spad{u} but not in set aggregate \spad{v}. If \spad{u} and \spad{v} have no elements in common,{} \axiom{difference(\spad{u},{}\spad{v})} returns a copy of \spad{u}. Note: equivalent to the notation (not currently supported) \axiom{{\spad{x} for \spad{x} in \spad{u} | not member?(\spad{x},{}\spad{v})}}.
243614`\spad{differentialVariables(p)} returns a list of differential indeterminates occurring in a differential polynomial \spad{p}.
244543`\spad{differentiate(x)} returns the derivative of \spad{x}. This function is a simple differential operator where no variable needs to be specified.
244597`\spad{differentiate(v)} returns the derivative of \spad{v}.
244666`\spad{differentiate(f)} returns the derivative of \spad{f}.
248641`\spad{differentiate(ir,{}D)} differentiates \spad{ir} with respect to the derivation \spad{D}.
248705`\spad{differentiate(f,{}n)} creates a form for the \spad{n}th derivative of \spad{f},{} \spadignore{e.g.} \spad{f'},{} \spad{f''},{} \spad{f'''},{} \spad{"f} super \spad{iv}".
248772`\spad{differentiate(ir,{}x)} differentiates \spad{ir} with respect to \spad{x}
248874`\spad{differentiate(f(x),{}x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.
248969`\spad{differentiate(f(x),{}x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.
249064`\spad{differentiate(f(x),{}x)} computes the derivative of \spad{f(x)} with respect to \spad{x}.
249158`\spad{differentiate(f(x),{}x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.
249247`\spad{differentiate(f(x),{}x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.
249336`\spad{differentiate(f(x),{}x)} computes the derivative of \spad{f(x)} with respect to \spad{x}.
249424`\spad{differentiate(x,{} deriv)} differentiates \spad{x} extending the derivation deriv on \spad{R}.
249493`\spad{differentiate(x,{} d)} extends the derivation \spad{d} from UP to \$ and applies it to \spad{x}.
249572`\spad{differentiate(x,{}[s1,{}...sn])} computes successive partial derivatives,{} \spadignore{i.e.} \spad{differentiate(...differentiate(x,{} s1)...,{} sn)}.
249644`\spad{differentiate(x,{} n)} returns the \spad{n}-th derivative of \spad{x}.
249717`\spad{differentiate(v,{} n)} returns the \spad{n}-th derivative of \spad{v}.
249805`\spad{differentiate(f,{} n)} returns the \spad{n}-th derivative of \spad{f}.
249896`\spad{differentiate(x,{}v)} computes the partial derivative of \spad{x} with respect to \spad{v}.
249962`\spad{differentiate(f(x),{}x)} returns the derivative of \spad{f(x)} with respect to \spad{x}.
253659`\spad{differentiate(x,{} deriv,{} n)} differentiate \spad{x} \spad{n} times using a derivation which extends \spad{deriv} on \spad{R}.
253747`\spad{differentiate(p,{} d,{} x')} extends the \spad{R}-derivation \spad{d} to an extension \spad{D} in \spad{R[x]} where \spad{Dx} is given by \spad{x'},{} and returns \spad{Dp}.
253826`\spad{differentiate(x,{} [s1,{}...,{}sn],{} [n1,{}...,{}nn])} computes multiple partial derivatives,{} \spadignore{i.e.}
253923`\spad{differentiate(x,{} s,{} n)} computes multiple partial derivatives,{} \spadignore{i.e.} \spad{n}-th derivative of \spad{x} with respect to \spad{s}.
254008`\spad{digamma(x)} returns the digamma function applied to \spad{x}
254068`\spad{digamma(x)} is the function,{} \spad{psi(x)},{} defined by \indented{2}{\spad{psi(x) = Gamma'(x)/Gamma(x)}.}
254163`\spad{digamma(x)} is the function,{} \spad{psi(x)},{} defined by \indented{2}{\spad{psi(x) = Gamma'(x)/Gamma(x)}.}
254240`\spad{digamma(x)} is the logarithmic derivative of \spad{Gamma(x)} (often written \spad{psi(x)} in the literature).
254295`\spad{digit?(c)} tests if \spad{c} is a digit character,{} \spadignore{i.e.} one of 0..9.
254340`\spad{digit()} returns the class of all characters for which \spadfunFrom{digit?}{Character} is \spad{true}.
254382`\spad{digits()} returns ceiling\spad{'s} precision in decimal digits.
254447`\spad{digits()} returns ceiling\spad{'s} precision in decimal digits.
254508`\spad{digits(d)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{d} digits.
254588`\spad{digits(d)} set the \spadfunFrom{precision}{FloatingPointSystem} to \spad{d} digits.
254701`\spad{digits(x)} returns a stream of \spad{p}-adic digits of \spad{x}.
254768`\spad{dihedralGroup([i1,{}...,{}ik])} constructs the dihedral group of order 2k acting on the integers out of {\em i1},{}...,{}{\em ik}. Note: duplicates in the list will be removed.
254864`\spad{dihedralGroup(n)} constructs the dihedral group of order 2n acting on integers 1,{}...,{}\spad{N}.
254962`\spad{dihedral n} is the cycle index of the \indented{1}{dihedral group of degree \spad{n}.}
255051`\spad{dilog(f)} denotes the dilogarithm
255103`\spad{dilog(x)} returns the dilogarithm of \spad{x},{} \spadignore{i.e.} the integral of \spad{log(x) / (1 - x) dx}.
255160`\spad{dim(c)} sets the shade of a hue,{} \spad{c},{} above dark,{} but below bright.
255198`\spad{dimensionOfIrreducibleRepresentation(lambda)} is the dimension of the ordinary irreducible representation of the symmetric group corresponding to {\em lambda}. Note: the Robinson-Thrall hook formula is implemented.
255449`\spad{dimension()} returns the dimensionality of the vector space.
255507`\spad{dimension()} is the rank of this Lie algebra
255582`\spad{dimension(I)} gives the dimension of the ideal \spad{I}. in the ring \spad{F[lvar]},{} where lvar are the variables appearing in \spad{I}
255659`\spad{dimension(s)} returns the dimension of the point category \spad{s}.
255722`\spad{dimension(I,{}lvar)} gives the dimension of the ideal \spad{I},{} in the ring \spad{F[lvar]}
255812`\spad{dimensionsOf(t)} returns the dimensions of \spad{t}
255883`\spad{dimensionsOf(s,{}m)} \undocumented{}
255974`\spad{dimensionsOf(s,{}m)} \undocumented{}
256061`\spad{dimensions(v,{}x,{}y,{}width,{}height)} sets the position of the upper left-hand corner of the two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} to the window coordinate \spad{x},{} \spad{y},{} and sets the dimensions of the window to that of \spad{width},{} \spad{height}. The new dimensions are not displayed until the funct
256061`--ion \spadfun{makeViewport2D} is executed again for \spad{v}.
256190`\spad{dimensions(v,{}x,{}y,{}width,{}height)} sets the position of the upper left-hand corner of the three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} to the window coordinate \spad{x},{} \spad{y},{} and sets the dimensions of the window to that of \spad{width},{} \spad{height}. The new dimensions are not displayed until the
256190`-- function \spadfun{makeViewport3D} is executed again for \spad{v}.
256321`\spad{dioSolve(u)} computes a basis of all minimal solutions for linear homogeneous Diophantine equation \spad{u},{} then all minimal solutions of inhomogeneous equation
256526`\spad{diophantineSystem(A,{}B)} returns a particular integer solution and an integer basis of the equation \spad{AX = B}.
256651`\spad{directProduct(v)} converts the vector \spad{v} to become a direct product. Error: if the length of \spad{v} is different from dim.
256724`\spad{directSum(a,{}b)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the sums of a solution of \spad{a} by a solution of \spad{b}.
256818`\spad{directSum(a,{}b,{}D)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the sums of a solution of \spad{a} by a solution of \spad{b}. \spad{D} is the derivation to use.
256902`\spad{direction(s)} \undocumented
256960`\spad{directory(f)} returns the directory part of the file name.
257083`\spad{discreteLog(a)} computes the discrete logarithm of \spad{a} with respect to \spad{primitiveElement()} of the field.
257241`\spad{discreteLog(b,{}a)} computes \spad{s} with \spad{b**s = a} if such an \spad{s} exists.
257338`\axiom{discriminantEuclidean(\spad{P})} carries out the equality \axiom{\spad{coef1} * \spad{P} + \spad{coef2} * \spad{D}(\spad{P}) = discriminant(\spad{P})}.
257459`\spad{discriminant()} returns the discriminant of the integral closure of \spad{Z} in the quotient field of the framed algebra \spad{F}.
257579`\spad{discriminant()} = determinant(traceMatrix()).
257635`\spad{discriminant()} = determinant(traceMatrix()).
257871`\axiom{discriminant(\spad{P},{} \spad{Q})} returns the discriminant of \axiom{\spad{P}} and \axiom{\spad{Q}}.
257940`\spad{discriminant([v1,{}..,{}vn])} returns \spad{determinant(traceMatrix([v1,{}..,{}vn]))}.
258007`\spad{discriminant(p)} returns the discriminant of the polynomial \spad{p}.
258166`\spad{discriminant(p,{}v)} returns the disriminant of the polynomial \spad{p} with respect to the variable \spad{v}.
258262`\spad{display(op)} returns the "\%display" property of \spad{op} if it has one attached,{} and "failed" otherwise.
258351`\spad{display(db)} prints a summary line for each entry in \axiom{\spad{db}}.
258396`\spad{display(ic)} prints a summary of the information contained in \axiom{\spad{ic}}.
258439`\spad{display(t)} outputs the formatted code \spad{t} so that each line has length less than or equal to the value set by the system command \spadsyscom{set output length}.
258492`\spad{display(t)} outputs the TeX formatted code \spad{t} so that each line has length less than or equal to the value set by the system command \spadsyscom{set output length}.
258535`\spad{display(op,{} foo)} attaches foo as the "\%display" property of \spad{op}. If \spad{op} has a "\%display" property \spad{f},{} then \spad{op(a1,{}...,{}an)} gets converted to OutputForm as \spad{f(a1,{}...,{}an)}.
258611`\spad{display(op,{} foo)} attaches foo as the "\%display" property of \spad{op}. If \spad{op} has a "\%display" property \spad{f},{} then \spad{op(a)} gets converted to OutputForm as \spad{f(a)}. Argument \spad{op} must be unary.
258681`\spad{display(t,{}width)} outputs the formatted code \spad{t} so that each line has length less than or equal to \spadvar{\spad{width}}.
258742`\spad{display(t,{}width)} outputs the TeX formatted code \spad{t} so that each line has length less than or equal to \spadvar{\spad{width}}.
258793`\spad{distFact(contm,{}unilist,{}plead,{}vl,{}lvar,{}lval)},{} where \spad{contm} is the content of the evaluated polynomial,{} \spad{unilist} is the list of factors of the evaluated polynomial,{} \spad{plead} is the complete factori
258793`--zation of the leading coefficient,{} \spad{vl} is the list of factors of the leading coefficient evaluated,{} \spad{lvar} is the list of variables,{} \spad{lval} is the list of values,{} returns a record giving the list of leading coefficients to impose on the univariate factors,{}
259126`\spad{distance(u,{}v)} returns the path length (an integer) from node \spad{u} to \spad{v}.
259188`\spad{distdfact(p,{}sqfrflag)} produces the complete factorization of the polynomial \spad{p} returning an internal data structure. If argument \spad{sqfrflag} is \spad{true},{} the polynomial is assumed square free.
259359`\spad{distribute(f)} expands all the kernels in \spad{f} that are formally enclosed by a \spadfunFrom{box}{ExpressionSpace} or \spadfunFrom{paren}{ExpressionSpace} expression.
259458`\spad{distribute(f,{} g)} expands all the kernels in \spad{f} that contain \spad{g} in their arguments and that are formally enclosed by a \spadfunFrom{box}{ExpressionSpace} or a \spadfunFrom{paren}{ExpressionSpace} expression.
259511`\spad{x div y} returns the left and right exact quotients of \spad{x} by \spad{y},{} that is \spad{[l,{} r]} such that \spad{x = l * y * r}. "failed" is returned iff \spad{x} is not of the form \spad{l * y * r}.
259595`\spad{f div g} creates the equivalent infix form.
259636`\spad{divergence(vf,{}xlist)} computes the divergence of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in \spad{xlist}.
259722`\spad{divideExponents(p,{}n)} returns a new polynomial resulting from dividing all exponents of the polynomial \spad{p} by the non negative integer \spad{n},{} or "failed" if some exponent is not exactly divisible by \spad{n}.
259828`\spad{divideIfCan!(matrix,{}matrixOut,{}prime,{}n)} attempts to divide the entries of \spad{matrix} by \spad{prime} and store the result in \spad{matrixOut}. If it is successful,{} 1 is returned and if not,{} \spad{prime} is returned. Here both \spad{matrix} and \spad{matrixOut} are \spad{n}-by-\spad{n} upper triangular matrices.
259917`\spad{divideIfCan(f,{}g)} returns quotient and remainder of the division of \spad{f} by \spad{g} or "failed" if it has not succeeded.
260272`\spad{divide(x,{} y)} returns the left and right exact quotients of \spad{x} by \spad{y},{} \spadignore{i.e.} \spad{[l,{} r]} such that \spad{x = l * y * r},{} "failed" if \spad{x} is not of the form \spad{l * y * r}.
260352`\axiom{divide(\spad{F},{}\spad{G})} computes quotient and rest of the exact euclidean division of \axiom{\spad{F}} by \axiom{\spad{G}}.
260455`\spad{divide(x,{}y)} divides \spad{x} by \spad{y} producing a record containing a \spad{quotient} and \spad{remainder},{} where the remainder is smaller (see \spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor \spad{y}.
260534`\spad{divide(a,{}b)} returns a record containing both remainder and quotient.
260616`\spad{divisorCascade(p,{}tp)} assumes that degree of polynomial {\em tp} is smaller than degree of polynomial \spad{p},{} both monic. A sequence of divisions is calculated using the remainder,{} made monic,{} as divisor for the the next division. The result contains also the error of the factorizations,{} \spadignore{i.e.} the norm of the remainder polynomial.
260725`\spad{divisorCascade(p,{}tp)} assumes that degree of polynomial {\em tp} is smaller than degree of polynomial \spad{p},{} both monic. A sequence of divisions are calculated using the remainder,{} made monic,{} as divisor for the the next division. The result contains also the error of the factorizations,{} \spadignore{i.e.} the norm of the remainder polynomial. If {\em info} is {\em true
260725`--},{} then information messages are issued.
260842`\spad{divisor(I)} makes a divisor \spad{D} from an ideal \spad{I}.
260945`\spad{divisor(g)} returns the divisor of the function \spad{g}.
261010`\spad{divisor(a,{} b)} makes the divisor \spad{P:} \spad{(x = a,{} y = b)}. Error: if \spad{P} is singular.
261077`\spad{divisor(a,{} b,{} n)} makes the divisor \spad{nP} where \spad{P:} \spad{(x = a,{} y = b)}. \spad{P} is allowed to be singular if \spad{n} is a multiple of the rank.
261152`\spad{divisor(h,{} d,{} d',{} g,{} r)} returns the sum of all the finite points where \spad{h/d} has residue \spad{r}. \spad{h} must be integral. \spad{d} must be squarefree. \spad{d'} is some derivative of \spad{d} (not necessarily dd/dx). \spad{g = gcd(d,{}discriminant)} contains the ramified zeros of \spad{d}
261228`\spad{divisors(n)} returns a list of the divisors of \spad{n}.
261305`\spad{dmp2rfi(p)} converts \spad{p} to target domain
261399`\spad{dmp2rfi(l)} converts \spad{l} to target domain
261505`\spad{dmp2rfi(m)} converts \spad{m} to target domain
261615`\spad{dmpToHdmp(p)} converts \spad{p} from a \spadtype{DMP} to a \spadtype{HDMP}.
261748`\spad{dmpToP(p)} converts \spad{p} from a \spadtype{DMP} to a \spadtype{POLY}.
261841`\spad{dn(x,{}k)} expands the elliptic function \spad{dn} as a Taylor \indented{1}{series.}
261924`\spad{dom(a)} returns a \spadgloss{LISP} form of the type of the original object that was converted to \spadtype{Any}.
261964`\spad{domainOf(a)} returns a printable form of the type of the original object that was converted to \spadtype{Any}.
262008`\spad{dominantTerm(f(var))} returns the term that dominates the limiting behavior of \spad{f(var)} as \spad{var -> cen+} together with a \spadtype{String} which briefly describes that behavior. The value of the \
262008`--spadtype{String} will be \spad{"zero"} (resp. \spad{"infinity"}) if the term tends to zero (resp. infinity) exponentially and will \spad{"series"} if the term is a Puiseux series.
262303`\spad{dot(f)} creates the form with a one dot overhead.
262341`\spad{dot(p,{}q)} computes the dot product of the two points \spad{p} and \spad{q} using only the first three coordinates,{} and returns the resulting \spadtype{DoubleFloat}.
262469`\spad{dot(f,{}n)} creates the form \spad{f} with \spad{n} dots overhead.
262526`\spad{dot(x,{}y)} computes the inner product of the vectors \spad{x} and \spad{y}.
262595`\spad{dot(x,{}y)} computes the inner product of the two vectors \spad{x} and \spad{y}. Error: if \spad{x} and \spad{y} are not of the same length.
262653`\spad{double?(t)} tests whether \spad{t} is equivalent to the FORTRAN type DOUBLE PRECISION
262707`\spad{doubleComplex?(t)} tests whether \spad{t} is equivalent to the (non-standard) FORTRAN type DOUBLE COMPLEX.
262768`\spad{doubleDisc(u)} \undocumented
262843`\spad{doubleRank(x)} determines the number of linearly independent elements in \spad{b1*x},{}...,{}\spad{x*bn},{} where \spad{b=[b1,{}...,{}bn]} is a basis.
262912`\spad{doubleResultant(f,{} ')} returns \spad{p}(\spad{x}) whose roots are rational multiples of the residues of \spad{f} at all its finite poles. Argument ' is the derivation to use.
262995`\spad{double(i,{} r)} multiplies \spad{r} by \spad{i} using repeated doubling.
263059`\spad{doublyTransitive?(p)} is \spad{true} if \spad{p} is irreducible over over the field \spad{K} generated by its coefficients,{} and if \spad{p(X) / (X - a)} is irreducible over \spad{K(a)} where \spad{p(a) = 0}.
263119`\spad{drawComplexVectorField(f,{}rRange,{}iRange)} draws a complex vector field using arrows on the \spad{x
263119`--y} plane. These vector fields should be viewed from the top by pressing the "XY" translate button on the 3-\spad{d} viewport control panel.\newline Sample call: \indented{3}{\spad{f z == sin z}} \indented{3}{\spad{drawComplexVectorFie
263119`--ld(f,{} -2..2,{} -2..2)}} Parameter descriptions: \indented{2}{\spad{f} : the function to draw} \indented{2}{\spad{rRange} : the range of the real values} \indented{2}{\spad{iRange} : the range of the imaginary values} Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and \axiomFunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each direction.
263283`\spad{drawComplex(f,{}rRange,{}iRange,{}arrows?)} draws a complex function as a height field. It uses the complex norm as the height and the complex argument as the color. It will optionally draw arrows on the surface indicating the direction of the complex value.\newline Sample call: \indented{2}{\spad{f z == exp(1/z)}} \indented{2}{\spad{draw
263283`--Complex(f,{} 0.3..3,{} 0..2*\%\spad{pi},{} false)}} Parameter descriptions: \indented{2}{\spad{f:}\space{2}the function to draw} \indented{2}{\spad{rRange} : the range of the real values} \indented{2}{\spad{iRange} : the range of imaginary values} \indented{2}{\spad{arrows?} : a flag indicating whether to draw the phase arrows for \spad{f}} Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and \axiomFunFrom{setImagSteps}{DrawComplex} to change the number of steps used in each directi
263283`--on.
263444`\spad{drawCurves([[p0],{}[p1],{}...,{}[pn]],{}[options])} creates a \spadtype{TwoDimensionalViewport} from the list of lists of points,{} \spad{p0} throught \spad{pn},{} using the options specified in the list \spad{options}.
263559`\spad{drawCurves([[p0],{}[p1],{}...,{}[pn]],{}ptColor,{}lineColor,{}ptSize,{}[options])} creates a \spadtype{TwoDimensionalViewport} from the list of lists of points,{} \spad{p0} throught \spad{pn},{} using the options specified in the list \spad{options}. The point color is specified by \spad{ptColor},{} the line color is specified by \spad{lineColor},{} an
263559`--d the point size is specified by \spad{ptSize}.
263706`\spad{drawStyle(v,{}s)} displays the surface for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport} in the style of drawing indicated by \spad{s}. If \spad{s} is not a valid drawing style the style is wireframe by default. Possible styles are \spad{"shade"},{} \spad{"solid"} or \spad{"opaque"},{} \spad{"smooth"},{} and \spad{"wireMesh"}.
263773`\spad{drawToScale()} determines whether or not plots are to be drawn to scale.
263828`\spad{drawToScale(true)} causes plots to be drawn to scale. \spad{drawToScale(false)} causes plots to be drawn so that they fill up the viewport window. The default setting is \spad{false}.
263890`\spad{draw(lp)} plots the curve constructed from the list of points \spad{lp}.
263991`\spad{draw(f,{}a..b)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
264120`\spad{draw(f,{}a..b,{}l)} draws the graph of the parametric curve \spad{f} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
264258`\spad{draw(f(x),{}x = a..b)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{f(x)} appears in the title bar.
264354`\spad{draw(lx,{}ly)} plots the curve constructed of points (\spad{x},{}\spad{y}) for \spad{x} in \spad{lx} for \spad{y} in \spad{ly}.
264466`\spad{draw(lp,{}l)} plots the curve constructed from the list of points \spad{lp}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
264584`\spad{draw(curve(f,{}g),{}a..b)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
264735`\spad{draw(curve(f(t),{}g(t)),{}t = a..b)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{(f(t),{}g(t))} appears in the title bar.
264853`\spad{draw(curve(f,{}g,{}h),{}a..b,{}l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
265006`\spad{draw(curve(f(t),{}g(t),{}h(t)),{}t = a..b)} draws the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{h(t)} is the default title.
265126`\spad{draw(f,{}a..b,{}l)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
265272`\spad{draw(f,{}a..b,{}l)} draws the graph of the parametric curve \spad{f} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
265427`\spad{draw(f,{}a..b,{}c..d)} draws the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}.
265585`\spad{draw(f,{}a..b,{}c..d)} draws the graph of the parametric surface \spad{f(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)} The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
265750`\spad{draw(f(x),{}x = a..b,{}l)} draws the graph of \spad{y = f(x)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{f(x)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
265863`\spad{draw(f(x,{}y),{}x = a..b,{}y = c..d)} draws the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{f(x,{}y)} appears in the title bar.
265983`\spad{draw(lx,{}ly,{}lz)} draws the surface constructed by projecting the values in the \axiom{\spad{lz}} list onto the rectangular grid formed by the \axiom{\spad{lx} \spad{X} \spad{ly}}.
266115`\spad{draw(lx,{}ly,{}l)} plots the curve constructed of points (\spad{x},{}\spad{y}) for \spad{x} in \spad{lx} for \spad{y} in \spad{ly}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
266244`\spad{draw(curve(f,{}g),{}a..b,{}l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
266412`\spad{draw(curve(f(t),{}g(t)),{}t = a..b,{}l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{(f(t),{}g(t))} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
266547`\spad{draw(curve(f,{}g,{}h),{}a..b,{}l)} draws the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
266717`\spad{draw(curve(f(t),{}g(t),{}h(t)),{}t = a..b,{}l)} draws the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
266854`\spad{draw(surface(f,{}g,{}h),{}a..b,{}c..d)} draws the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}.
267031`\spad{draw(surface(f(u,{}v),{}g(u,{}v),{}h(u,{}v)),{}u = a..b,{}v = c..d)} draws the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{h(t)} is the default title.
267170`\spad{draw(f,{}a..b,{}c..d,{}l)} draws the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}. and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
267345`\spad{draw(f,{}a..b,{}c..d)} draws the graph of the parametric surface \spad{f(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
267527`\spad{draw(f(x,{}y) = g(x,{}y),{}x,{}y,{}l)} draws the graph of a polynomial equation. The list \spad{l} of draw options must specify a region in the plane in which the curve is to sketched.
267662`\spad{draw(f(x,{}y),{}x = a..b,{}y = c..d,{}l)} draws the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{f(x,{}y)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
267799`\spad{draw(lx,{}ly,{}lz,{}l)} draws the surface constructed by projecting the values in the \axiom{\spad{lz}} list onto the rectangular grid formed by the The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
267948`\spad{draw(surface(f,{}g,{}h),{}a..b,{}c..d)} draws the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; The options contained in the li
267948`--st \spad{l} of the domain \spad{DrawOption} are applied.
268142`\spad{draw(surface(f(u,{}v),{}g(u,{}v),{}h(u,{}v)),{}u = a..b,{}v = c..d,{}l)} draws the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{h(t)} is the default title,{} 
268142`--and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
268298`\spad{droot(l)} should be a non-exported function.
268363`\spad{duplicates?(d)} tests if dictionary \spad{d} has duplicate entries.
268426`\spad{duplicates(d)} returns a list of values which have duplicates in \spad{d}
268523`\spad{e01baf(m,{}x,{}y,{}lck,{}lwrk,{}ifail)} determines a cubic spline to a given set of data. See \downlink{Manual Page}{manpageXXe01baf}.
268650`\spad{e01bef(n,{}x,{}f,{}ifail)} computes a monotonicity-preserving piecewise cubic Hermite interpolant to a set of data points. See \downlink{Manual Page}{manpageXXe01bef}.
268761`\spad{e01bff(n,{}x,{}f,{}d,{}m,{}px,{}ifail)} evaluates a piecewise cubic Hermite interpolant at a set of points. See \downlink{Manual Page}{manpageXXe01bff}.
268920`\spad{e01bgf(n,{}x,{}f,{}d,{}m,{}px,{}ifail)} evaluates a piecewise cubic Hermite interpolant and its first derivative at a set of points. See \downlink{Manual Page}{manpageXXe01bgf}.
269079`\spad{e01bhf(n,{}x,{}f,{}d,{}a,{}b,{}ifail)} evaluates the definite integral of a piecewise cubic Hermite interpolant over the interval [a,{}\spad{b}]. See \downlink{Manual Page}{manpageXXe01bhf}.
269234`\spad{e01daf(mx,{}my,{}x,{}y,{}f,{}ifail)} computes a bicubic spline interpolating surface through a set of data values,{} given on a rectangular grid in the \spad{x}-\spad{y} plane. See \downlink{Manual Page}{manpageXXe01daf}.
269373`\spad{e01saf(m,{}x,{}y,{}f,{}ifail)} generates a two-dimensional surface interpolating a set of scattered data points,{} using the method of Renka and Cline. See \downlink{Manual Page}{manpageXXe01saf}.
269504`\spad{e01sbf(m,{}x,{}y,{}f,{}triang,{}grads,{}px,{}py,{}ifail)} evaluates at a given point the two-dimensional interpolant function computed by E01SAF. See \downlink{Manual Page}{manpageXXe01sbf}.
269695`\spad{e01sef(m,{}x,{}y,{}f,{}nw,{}nq,{}rnw,{}rnq,{}ifail)} generates a two-dimensional surface interpolating a set of scattered data points,{} using a modified Shepard method. See \downlink{Manual Page}{manpageXXe01sef}.
269866`\spad{e01sff(m,{}x,{}y,{}f,{}rnw,{}fnodes,{}px,{}py,{}ifail)} evaluates at a given point the two-dimensional interpolating function computed by E01SEF. See \downlink{Manual Page}{manpageXXe01sff}.
270053`\spad{e02adf(m,{}kplus1,{}nrows,{}x,{}y,{}w,{}ifail)} computes weighted least-squares polynomial approximations to an arbitrary set of data points. See \downlink{Manual Page}{manpageXXe02adf}.
270194`\spad{e02aef(nplus1,{}a,{}xcap,{}ifail)} evaluates a polynomial from its Chebyshev-series representation. See \downlink{Manual Page}{manpageXXe02aef}.
270291`\spad{e02agf(m,{}kplus1,{}nrows,{}xmin,{}xmax,{}x,{}y,{}w,{}mf,{}xf,{}yf,{}lyf,{}ip,{}lwrk,{}liwrk,{}ifail)} computes constrained weighted least-squares polynomial approximations in Chebyshev-series form to an arbitrary set of data points. The values of
270291`-- the approximations and any number of their derivatives can be specified at selected points. See \downlink{Manual Page}{manpageXXe02agf}.
270545`\spad{e02ahf(np1,{}xmin,{}xmax,{}a,{}ia1,{}la,{}iadif1,{}ladif,{}ifail)} determines the coefficients in the Chebyshev-series representation of the derivative of a polynomial given in Chebyshev-series form. See \downlink{Manual Page}{manpageXXe02ahf}.
270686`\spad{e02ajf(np1,{}xmin,{}xmax,{}a,{}ia1,{}la,{}qatm1,{}iaint1,{}laint,{}ifail)} determines the coefficients in the Chebyshev-series representation of the indefinite integral of a polynomial given in Chebyshev-series form. See \downlink{Manual Page}{manpageXXe02ajf}.
270840`\spad{e02akf(np1,{}xmin,{}xmax,{}a,{}ia1,{}la,{}x,{}ifail)} evaluates a polynomial from its Chebyshev-series representation,{} allowing an arbitrary index increment for accessing the array of coefficients. See \downlink{Manual Page}{manpageXXe02akf}.
270977`\spad{e02baf(m,{}ncap7,{}x,{}y,{}w,{}lamda,{}ifail)} computes a weighted least-squares approximation to an arbitrary set of data points by a cubic splines prescribed by the user. Cubic spline can also be carried out. See \downlink{Manual Page}{manpageXXe02baf}.
271130`\spad{e02bbf(ncap7,{}lamda,{}c,{}x,{}ifail)} evaluates a cubic spline representation. See \downlink{Manual Page}{manpageXXe02bbf}.
271247`\spad{e02bcf(ncap7,{}lamda,{}c,{}x,{}left,{}ifail)} evaluates a cubic spline and its first three derivatives from its \spad{B}-spline representation. See \downlink{Manual Page}{manpageXXe02bcf}.
271372`\spad{e02bdf(ncap7,{}lamda,{}c,{}ifail)} computes the definite integral from its \spad{B}-spline representation. See \downlink{Manual Page}{manpageXXe02bdf}.
271477`\spad{e02bef(start,{}m,{}x,{}y,{}w,{}s,{}nest,{}lwrk,{}n,{}lamda,{}ifail,{}wrk,{}iwrk)} computes a cubic spline approximation to an arbitrary set of data points. The knot are located automatically,{} but a single parameter must be specified to control the trade-off between closenes
271477`--s of fit and smoothness of fit. See \downlink{Manual Page}{manpageXXe02bef}.
271702`\spad{e02daf(m,{}px,{}py,{}x,{}y,{}f,{}w,{}mu,{}point,{}npoint,{}nc,{}nws,{}eps,{}lamda,{}ifail)} forms a minimal,{} weighted least-squares bicubic spline surface fit with prescribed knots to a given set of data points. See \downlink{Manual Page}{manpag
271702`--eXXe02daf}.
271956`\spad{e02dcf(start,{}mx,{}x,{}my,{}y,{}f,{}s,{}nxest,{}nyest,{}lwrk,{}liwrk,{}nx,{}lamda,{}ny,{}mu,{}wrk,{}iwrk,{}ifail)} computes a bicubic spline approximation to a set of data values,{} given on a rectangular grid in the \spad{
271956`--x}-\spad{y} plane. The knots of the spline are located automatically,{} but a single parameter must be specified to control the trade-off between closeness of fit and smoothness of fit. See \downlink{Manual Page}{manpageXXe02dcf}.
272233`\spad{e02ddf(start,{}m,{}x,{}y,{}f,{}w,{}s,{}nxest,{}nyest,{}lwrk,{}liwrk,{}nx,{}lamda,{}ny,{}mu,{}wrk,{}ifail)} computes a bicubic spline approximation to a set of scattered data are located automatically,{} but a single parameter mu
272233`--st be specified to control the trade-off between closeness of fit and smoothness of fit. See \downlink{Manual Page}{manpageXXe02ddf}.
272506`\spad{e02def(m,{}px,{}py,{}x,{}y,{}lamda,{}mu,{}c,{}ifail)} calculates values of a bicubic spline representation. See \downlink{Manual Page}{manpageXXe02def}.
272687`\spad{e02dff(mx,{}my,{}px,{}py,{}x,{}y,{}lamda,{}mu,{}c,{}lwrk,{}liwrk,{}ifail)} calculates values of a bicubic spline representation. The spline is evaluated at all points on a rectangular grid. See \downlink{Manual Page}{manpageXXe02dff}.
272893`\spad{e02gaf(m,{}la,{}nplus2,{}toler,{}a,{}b,{}ifail)} calculates an \spad{l} solution to an over-determined system of \indented{22}{1} linear equations. See \downlink{Manual Page}{manpageXXe02gaf}.
273026`\spad{e02zaf(px,{}py,{}lamda,{}mu,{}m,{}x,{}y,{}npoint,{}nadres,{}ifail)} sorts two-dimensional data into rectangular panels. See \downlink{Manual Page}{manpageXXe02zaf}.
273204`\spad{e04dgf(n,{}es,{}fu,{}it,{}lin,{}list,{}ma,{}op,{}pr,{}sta,{}sto,{}ve,{}x,{}ifail,{}objfun)} minimizes an unconstrained nonlinear function of several variables using a pre-conditioned,{} limited memory quasi-Newton conjugate gradient method. First derivatives are req
273204`--uired. The routine is intended for use on large scale problems. See \downlink{Manual Page}{manpageXXe04dgf}.
273439`\spad{e04fdf(m,{}n,{}liw,{}lw,{}x,{}ifail,{}lsfun1)} is an easy-to-use algorithm for finding an unconstrained minimum of a sum of squares of \spad{m} nonlinear functions in \spad{n} variables (m>=n). No derivatives are required. See \downlink{Manual Page}{manpageXXe04fdf}.
273589`\spad{e04gcf(m,{}n,{}liw,{}lw,{}x,{}ifail,{}lsfun2)} is an easy-to-use quasi-Newton algorithm for finding an unconstrained minimum of \spad{m} nonlinear functions in \spad{n} variables (m>=n). First derivatives are required. See \downlink{Manual Page}{manpageXXe04gcf}.
273739`\spad{e04jaf(n,{}ibound,{}liw,{}lw,{}bl,{}bu,{}x,{}ifail,{}funct1)} is an easy-to-use quasi-Newton algorithm for finding a minimum of a function \spad{F}(\spad{x} ,{}\spad{x} ,{}...,{}\spad{x} ),{} subject to fixed upper and \indented{25}{1\space{2}2\space{6}\spad{n}} lower bounds of the independent variables \spad{
273739`--x} ,{}\spad{x} ,{}...,{}\spad{x} ,{} using \indented{43}{1\space{2}2\space{6}\spad{n}} function values only. See \downlink{Manual Page}{manpageXXe04jaf}.
273929`\spad{e04mbf(itmax,{}msglvl,{}n,{}nclin,{}nctotl,{}nrowa,{}a,{}bl,{}bu,{}cvec,{}linobj,{}liwork,{}lwork,{}x,{}ifail)} is an easy-to-use routine for solving linear programming problems,{} or for finding a feasible point for such problems. It is not intended for large spars
273929`--e problems. See \downlink{Manual Page}{manpageXXe04mbf}.
274164`\spad{e04naf(itmax,{}msglvl,{}n,{}nclin,{}nctotl,{}nrowa,{}nrowh,{}ncolh,{}bigbnd,{}a,{}bl,{}bu,{}cvec,{}featol,{}hess,{}cold,{}lpp,{}or
274164`--thog,{}liwork,{}lwork,{}x,{}istate,{}ifail,{}qphess)} is a comprehensive programming (\spad{QP}) or linear programming (\spad{LP}) problems. It is not intended for large sparse problems. See \downlink{Manual Page}{manpageXXe04naf}.
274535`\spad{e04ucf(n,{}nclin,{}ncnln,{}nrowa,{}nrowj,{}nrowr,{}a,{}bl,{}bu,{}liwork,{}lwork,{}sta,{}cra,{}der,{}fea,{}fun,{}hes,{}infb,{}infs,{}linf,{}lint,{}list,{}maji,{}majp,{}mini,{}minp,{}mon,{}nonf,{}opt,{}ste,{}stao,{}stac,{}stoo,{}stoc,{}ve,{}istate,{}cjac,{}clamda,{}r,{}x,{}ifail,{}confun,{}objfun)} is designed to minimize an arbitrary smooth function subject to constraints on the variables,{} linear constraints
274535`--. (E04UCF may be used for unconstrained,{} bound-constrained and linearly constrained optimization.) The user must provide subroutines that define the objective and constraint functions and as many of their first partial derivatives as possible. Unspecified derivatives are approximated by finite differences. All matrices are treated as dense,{} and hence E04UCF is not intended for large sparse problems. See \downlink{Manual Page}{manpageXXe04ucf}.
275124`\spad{e04ycf(job,{}m,{}n,{}fsumsq,{}s,{}lv,{}v,{}ifail)} returns estimates of elements of the variance matrix of the estimated regression coefficients for a nonlinear least squares problem. The estimates are derived from the Jacobian of the function \spad{f}(\spad{x}) at the solution. See \downlink{Manual Page}{manpageXXe04ycf}.
275270`\spad{e(n)} produces the appropriate unit element.
275331`\spad{edf2df(n)} maps \axiomType{Expression DoubleFloat} to \axiomType{DoubleFloat} It is an error if \spad{n} is not coercible to DoubleFloat
275416`\spad{edf2ef(e)} maps \axiomType{Expression DoubleFloat} to \axiomType{Expression Float}
275507`\spad{edf2efi(e)} coerces \axiomType{Expression DoubleFloat} into \axiomType{Expression Fraction Integer}
275611`\spad{edf2fi(n)} maps \axiomType{Expression DoubleFloat} to \axiomType{Fraction Integer} It is an error if \spad{n} is not coercible to Fraction Integer
275702`\spad{ef2edf(f)} is a function to convert an \axiomType{Expression Float} to an \axiomType{Expression DoubleFloat}
275793`\spad{eigenMatrix(m)} returns the matrix \spad{b} such that \spad{b*m*(inverse b)} is diagonal,{} or "failed" if no such \spad{b} exists.
275924`\spad{eigenvalues(m)} returns the eigenvalues of the matrix \spad{m} which are expressible as rational functions over the rational numbers.
276069`\spad{eigenvector(eigval,{}m)} returns the eigenvectors belonging to the eigenvalue \spad{eigval} for the matrix \spad{m}.
276246`\spad{eigenvectors(m)} returns the eigenvalues and eigenvectors for the matrix \spad{m}. The rational eigenvalues and the correspondent eigenvectors are explicitely computed,{} while the non rational ones are given via their minimal polynomial and the corresponding eigenvec
276246`--tors are expressed in terms of a "generic" root of such a polynomial.
276479`\spad{eisensteinIrreducible?(p)} returns \spad{true} if \spad{p} can be shown to be irreducible by Eisenstein\spad{'s} criterion,{} \spad{false} is inconclusive.
276556`\spad{elColumn2!(m,{}a,{}i,{}j)} adds to column \spad{i} a*column(\spad{m},{}\spad{j}) : elementary operation of second kind. (\spad{i} \spad{^=j})
276648`\spad{elRow1!(m,{}i,{}j)} swaps rows \spad{i} and \spad{j} of matrix \spad{m} : elementary operation of first kind
276735`\spad{elRow2!(m,{}a,{}i,{}j)} adds to row \spad{i} a*row(\spad{m},{}\spad{j}) : elementary operation of second kind. (\spad{i} \spad{^=j})
276824`\spad{elem?(ir)} tests if an integration result is elementary over \spad{F?}
276879`\spad{element?(f,{}I)} tests whether the polynomial \spad{f} belongs to the ideal \spad{I}.
276961`\spad{elementary n} is the \spad{n} th elementary symmetric \indented{1}{function expressed in terms of power sums.}
277052`\spad{elements(S)} returns the list of the elements of \spad{S} in increasing order.
277131`\spad{elliptic?(r)} \undocumented{}
277452`\spad{ellipticCylindrical(a)} transforms from elliptic cylindrical coordinates to Cartesian coordinates: \spad{ellipticCylindrical(a)} is a function which will map the point \spad{(u,{}v,{}z)} to \spad{x = a*cosh(u)*cos(v)},{} \spad{y = a*sinh(u)*sin(v)},{} \spad{z}.
277533`\spad{elliptic()} returns \spad{p(x)} if the curve is the elliptic defined by \spad{y**2 = p(x)},{} "failed" otherwise.
277615`\spad{elliptic()} returns \spad{p(x)} if the curve is the elliptic defined by \spad{y**2 = p(x)},{} "failed" otherwise.
277694`\spad{elliptic(a)} transforms from elliptic coordinates to Cartesian coordinates: \spad{elliptic(a)} is a function which will map the point \spad{(u,{}v)} to \spad{x = a*cosh(u)*cos(v)},{} \spad{y = a*sinh(u)*sin(v)}.
277764`\spad{elt(n)} returns the object \spad{n}.
277803`\spad{elt(t)} gives the component of a rank 0 tensor.
279237`\spad{elt(op,{} [a1,{}...,{}an])} returns \spad{op(a1,{}...,{}an)}.
280078`\spad{elt(op,{}l)} creates a form for application of \spad{op} to list of arguments \spad{l}.
280125`\spad{elt(x,{}r)} or \spad{x}.\spad{r} \undocumented
280208`\spad{elt(op,{}[x1,{}...,{}xn])} or \spad{op}([\spad{x1},{}...,{}\spad{xn}]) applies the \spad{n}-ary operator \spad{op} to \spad{x1},{}...,{}\spad{xn}.
280271`\spad{elt(op,{}x)} or \spad{op}(\spad{x}) applies the unary operator \spad{op} to \spad{x}.
280328`\spad{elt(a,{}b)} evaluates the fraction of univariate polynomials \spad{a} with the distinguished variable replaced by \spad{b}.
280441`\spad{elt(a,{}r)} evaluates the fraction of univariate polynomials \spad{a} with the distinguished variable replaced by the constant \spad{r}.
280523`\axiom{\spad{l}."count"} returns the number of elements in \axiom{\spad{l}}.
280586`\spad{elt(u,{}"first")} (also written: \axiom{\spad{u} . first}) is equivalent to first \spad{u}.
280647`\spad{elt(u,{}"last")} (also written: \axiom{\spad{u} . last}) is equivalent to last \spad{u}.
280707`\spad{elt(u,{}"left")} (also written: \axiom{a . left}) is equivalent to \axiom{left(a)}.
280769`\spad{elt(\%,{}"rest")} (also written: \axiom{\spad{u}.rest}) is equivalent to \axiom{rest \spad{u}}.
280830`\spad{elt(a,{}"right")} (also written: \axiom{a . right}) is equivalent to \axiom{right(a)}.
280893`\axiom{\spad{l}.sort} returns \axiom{\spad{l}} with elements sorted. Note: \axiom{\spad{l}.sort = sort(\spad{l})}
280939`\axiom{\spad{l}.unique} returns \axiom{\spad{l}} with duplicates removed. Note: \axiom{\spad{l}.unique = removeDuplicates(\spad{l})}.
280987`\spad{elt(u,{}"value")} (also written: \axiom{a. value}) is equivalent to \axiom{value(a)}.
281043`\spad{elt(qf,{}v)} evaluates the quadratic form \spad{qf} on the vector \spad{v},{} producing a scalar.
281107`\spad{elt(f(x),{}r)} returns the coefficient of the term of degree \spad{r} in \spad{f(x)}. This is the same as the function \spadfun{coefficient}.
281184`\spad{elt(a,{}i)} returns the \spad{i}-th coefficient of \spad{a} with respect to the fixed \spad{R}-module basis.
281249`\spad{elt(t,{}i)} gives a component of a rank 1 tensor.
281312`\spad{elt((a1,{}...,{}an),{} i)} returns \spad{\spad{ai}}.
281389`\spad{elt(t,{}[i1,{}...,{}iN])} gives a component of a rank \spad{N} tensor.
281458`\spad{elt((a1,{}...,{}an),{} [i1,{}...,{}im])} returns \spad{(a_i1,{}...,{}a_im)}.
281541`\spad{elt(s,{}[a1,{}...,{}an])} or \spad{s}([\spad{a1},{}...,{}an]) returns \spad{s} subscripted by \spad{[a1,{}...,{}an]}.
281592`\spad{elt(gp,{}i)} returns the \spad{i}-th generator of the group {\em gp}.
281670`\spad{elt(db,{}q)} returns all elements of \axiom{\spad{db}} which satisfy \axiom{\spad{q}}.
281723`\spad{elt(u,{}i)} (also written: \spad{u} . \spad{i}) returns the element of \spad{u} indexed by \spad{i}. Error: if \spad{i} is not an index of \spad{u}.
281772`\spad{elt(p,{} el)} returns the image of {\em el} under the permutation \spad{p}.
281823`\spad{elt(lib,{}k)} or \spad{lib}.\spad{k} extracts the value corresponding to the key \spad{k} from the library \spad{lib}.
281866`\spad{elt(db,{}s)} returns the \axiom{\spad{s}} field of each element of \axiom{\spad{db}}.
281926`\spad{elt(ic,{}s)} selects a particular field from \axiom{\spad{ic}}. Valid fields are \axiom{name,{} nargs,{} exposed,{} type,{} abbreviation,{} kind,{} origin,{} params,{} condition,{} doc}.
281974`\spad{elt(u,{}i..j)} (also written: \axiom{a(\spad{i}..\spad{j})}) returns the aggregate of elements \axiom{\spad{u}} for \spad{k} from \spad{i} to \spad{j} in that order. Note: in general,{} \axiom{a.\spad{s} = [a.\spad{k} for \spad{i} in \spad{s}]}.
282046`\spad{elt(s,{}t)} returns the concatenation of \spad{s} and \spad{t}. It is provided to allow juxtaposition of strings to work as concatenation. For example,{} \axiom{"smoo" "shed"} returns \axiom{"smooshed"}.
282855`\spad{elt(op,{}x,{}y)} or \spad{op}(\spad{x},{} \spad{y}) applies the binary operator \spad{op} to \spad{x} and \spad{y}.
282915`\spad{elt(u,{} x,{} y)} applies \spad{u} to \spad{x} if \spad{x} is in the domain of \spad{u},{} and returns \spad{y} otherwise. For example,{} if \spad{u} is a polynomial in \axiom{\spad{x}} over the rationals,{} \axiom{elt(\spad{u},{}\spad{n},{}0)} may define the coefficient of \axiom{\spad{x}} to the power \spad{n},{} returning 0 when \spad{n} is out of range.
282974`\spad{elt(f,{}a,{}b)} or \spad{f}(a,{} \spad{b}) returns the value of \spad{f} at the point \spad{(x = a,{} y = b)} if it is not singular.
283037`\spad{elt(r,{}f,{}n)} or \spad{r}(\spad{f},{} \spad{n}) applies the rule \spad{r} to \spad{f} at most \spad{n} times.
283103`\spad{elt(r,{}f,{}n)} or \spad{r}(\spad{f},{} \spad{n}) applies all the rules of \spad{r} to \spad{f} at most \spad{n} times.
283165`\spad{elt(m,{}i,{}j)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m}. Error: if indices are outside the proper ranges.
283248`\spad{elt(m,{}i,{}j)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m} error check to determine if indices are in proper ranges
283329`\spad{elt(t,{}i,{}j)} gives a component of a rank 2 tensor.
283400`\spad{elt(x,{}rowList,{}colList)} returns an \spad{m}-by-\spad{n} matrix consisting of elements of \spad{x},{} where \spad{m = \# rowList} and \spad{n = \# colList}. If \spad{rowList = [i<1>,{}i<2>,{}...,{}i<m>]} and \spad{colList = [j<1>,{}j<2>,{}...,{}j<n>]},{} then the \spad{(k,{}l)}th entry of \spad{elt(x,{}rowList,{}colList)} is \spad{x(i<k>,{}j<l>)}.
283744`\spad{elt(op,{}x,{}y,{}z)} or \spad{op}(\spad{x},{} \spad{y},{} \spad{z}) applies the ternary operator \spad{op} to \spad{x},{} \spad{y} and \spad{z}.
283807`\spad{elt(t,{}i,{}j,{}k)} gives a component of a rank 3 tensor.
283886`\spad{elt(m,{}i,{}j,{}r)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m},{} if \spad{m} has an \spad{i}th row and a \spad{j}th column,{} and returns \spad{r} otherwise.
283971`\spad{elt(m,{}i,{}j,{}r)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m},{} if \spad{m} has an \spad{i}th row and a \spad{j}th column,{} and returns \spad{r} otherwise
284054`\spad{elt(x,{}i,{}j,{}k)} extract an element from the matrix \spad{x}
284283`\spad{elt(op,{}x,{}y,{}z,{}t)} or \spad{op}(\spad{x},{} \spad{y},{} \spad{z},{} \spad{t}) applies the 4-ary operator \spad{op} to \spad{x},{} \spad{y},{} \spad{z} and \spad{t}.
284349`\spad{elt(t,{}i,{}j,{}k,{}l)} gives a component of a rank 4 tensor.
284479`\spad{empty?(s)} returns \spad{true} if the quasialgebraic set \spad{s} has no points,{} and \spad{false} otherwise.
284551`\axiom{empty?(\spad{n})} returns \spad{true} iff the node \spad{n} is \axiom{empty()\$\%}.
284605`\spad{empty?(u)} tests if \spad{u} has 0 elements.
284650`\spad{empty()} creates an empty form.
284688`\spad{empty()} returns the empty quasi-algebraic set
284752`\axiom{empty()} returns the same as \axiom{[empty()\$\spad{V},{}empty()\$\spad{C},{}\spad{false}]\$\%}
284798`\spad{empty()}\$\spad{D} creates an aggregate of type \spad{D} with 0 elements. Note: The {\em \$D} can be dropped if understood by context,{} \spadignore{e.g.} \axiom{u: \spad{D} \spad{:=} empty()}.
284835`\spad{empty()} returns a new,{} empty symbol table
284874`\spad{empty()} creates a new,{} empty symbol table.
284916`\spad{endOfFile?(f)} tests whether the file \spad{f} is positioned after the end of all text. If the file is open for output,{} then this test is always \spad{true}.
284964`\spad{endSubProgram()} asserts that we are no longer processing the current subprogram.
285018`\spad{enqueue!(x,{}q)} inserts \spad{x} into the queue \spad{q} at the back end.
285069`\spad{enterInCache(x,{} f)} enters \spad{x} in the cache,{} calling \spad{f(y)} to determine whether \spad{x} is equal to \spad{y}. It returns \spad{x} with an integer associated with it.
285131`\spad{enterInCache(x,{} f)} enters \spad{x} in the cache,{} calling \spad{f(x,{} y)} to determine whether \spad{x < y (f(x,{}y) < 0),{} x = y (f(x,{}y) = 0)},{} or \spad{x > y (f(x,{}y) > 0)}. It returns \spad{x} with an integer associated with it.
285195`\spad{enterPointData(s,{}[p0,{}p1,{}...,{}pn])} adds a list of points from \spad{p0} through \spad{pn} to the \spadtype{ThreeSpace},{} \spad{s},{} and returns the index,{} to the starting point of the list.
285472`\spad{entries(u)} returns a list of all the entries of aggregate \spad{u} in no assumed order.
285542`\spad{entries(x)} \undocumented{}
286468`\spad{entry?(x,{}u)} tests if \spad{x} equals \axiom{\spad{u} . \spad{i}} for some index \spad{i}.
286601`\spad{entry(n)} \undocumented{}
287430`\spad{enumerate()} returns a vector of all the sets of \spad{M} integers in \spad{1..n}.
287497`\spad{epilogue(t)} extracts the epilogue section of a formatted object \spad{t}.
287559`\spad{epilogue(t)} extracts the epilogue section of a TeX form \spad{t}.
287653`\spad{eq?(u,{}v)} tests if \spad{u} and \spad{v} are same objects.
287698`\spad{eq(s,{} t)} is \spad{true} if EQ(\spad{s},{}\spad{t}) is \spad{true} in Lisp.
287774`\spad{equality(op,{} foo?)} attaches foo? as the "\%equal?" property to \spad{op}. If \spad{op1} and \spad{op2} have the same name,{} and one of them has an "\%equal?" property \spad{f},{} then \spad{f(op1,{} op2)} is called to decide whether \spad{op1} and \spad{op2} should be considered equal.
287837`\spad{equation(a,{}b)} creates an equation.
287882`\spad{equation(v,{}a..b)} creates a segment binding value with variable \spad{v} and segment \spad{a..b}. Note that the interpreter parses \spad{v=a..b} to this form.
287947`\spad{equation(s,{}"a")} creates a new equation.
288004`\spad{erf(f)} denotes the error function
288054`\spad{erf(x)} returns the error function of \spad{x},{} \spadignore{i.e.} \spad{2 / sqrt(\%\spad{pi})} times the integral of \spad{exp(-x**2) dx}.
288109`\spad{errorInfo(u)} returns information about the error \spad{u}.
288166`\spad{errorKind(u)} returns the type of error which \spad{u} represents.
288228`\spad{error(lmsg)} displays error message \spad{lmsg} and terminates.
288284`\spad{error(msg)} displays error message \spad{msg} and terminates.
288334`\spad{error(nam,{}lmsg)} displays error messages \spad{lmsg} preceded by a message containing the name \spad{nam} of the function in which the error is contained.
288397`\spad{error(nam,{}msg)} displays error message \spad{msg} preceded by a message containing the name \spad{nam} of the function in which the error is contained.
288454`\spad{escape()} provides the escape character,{} \spad{_},{} which is used to allow quotes and other characters {\em within} strings.
288492`\spad{euclideanGroebner(lp)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \spad{lp}.
288602`\spad{euclideanGroebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal over a euclidean domain generated by the list of polynomials \spad{lp}. During computation,{} additional information is printed out if infoflag is given as either "info" (for summary information) or "redcrit" (for reduced critical pairs)
288719`\spad{euclideanGroebner(lp,{} "info",{} "redcrit")} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}. If the second argument is \spad{"info"},{} a summary is given of the critical pairs. If the third argument is "redcrit",{} critical pairs are printed.
288843`\spad{euclideanNormalForm(poly,{}gb)} reduces the polynomial \spad{poly} modulo the precomputed groebner basis \spad{gb} giving a canonical representative of the residue class.
289233`\spad{euclideanSize(x)} returns the euclidean size of the element \spad{x}. Error: if \spad{x} is zero.
289302`\spad{eulerE(n,{}r)} \undocumented
289420`\spad{eulerPhi(n)} returns the number of integers between 1 and \spad{n} (including 1) which are relatively prime to \spad{n}. This is the Euler phi function \spad{\phi(n)} is also called the totient function.
289491`\spad{euler(n)} returns the \spad{n}th Euler polynomial \spad{E[n](x)}. Note: Euler polynomials denoted \spad{E(n,{}x)} computed by solving the differential equation \spad{differentiate(E(n,{}x),{}x) = n E(n-1,{}x)} where \spad{E(0,{}x) = 1} and initial condition comes from \spad{E(n) = 2**n E(n,{}1/2)}.
289600`\spad{euler(n)} returns the \spad{n}th Euler number. This is \spad{2^n E(n,{}1/2)},{} where \spad{E(n,{}x)} is the \spad{n}th Euler polynomial.
289709`\spad{eval s} is the sum of the coefficients of a cycle index.
289804`\spad{eval(f)} unquotes all the quoted operators in \spad{f}.
289880`\spad{eval(f,{}s)} evaluates the cycle index \spad{s} by applying \indented{1}{the function \spad{f} to each integer in a monomial partition,{}} \indented{1}{forms their product and sums the results over all monomials.}
291097`\spad{eval(a,{}r)} returns a stream of partial sums of the power series \spad{a} evaluated at the power series variable equal to \spad{r}.
291173`\spad{eval(m,{}x)} returns \spad{(a*x + b)/(c*x + d)} where \spad{m = moebius(a,{}b,{}c,{}d)} (see \spadfunFrom{moebius}{MoebiusTransform}).
291222`\spad{eval(m,{}x)} returns \spad{(a*x + b)/(c*x + d)} where \spad{m = moebius(a,{}b,{}c,{}d)} (see \spadfunFrom{moebius}{MoebiusTransform}).
291311`\spad{eval(f,{} v = g)} returns \spad{f} with \spad{v} replaced by \spad{g}. Error: if \spad{v} is not a symbol.
291435`\spad{eval(f,{} [v1 = g1,{}...,{}vn = gn])} returns \spad{f} with each \spad{vi} replaced by \spad{gi} in parallel,{} \spadignore{i.e.} \spad{vi}\spad{'s} appearing inside the \spad{gi}\spad{'s} are not replaced. Error: if any \spad{vi} is not a symbol.
291565`\spad{eval(f,{}a)} evaluates a power series at a value in the ground ring by returning a stream of partial sums.
291690`\spad{eval(f,{}x = v)} replaces \spad{x} by \spad{v} in \spad{f}.
291742`\spad{eval(f,{} [x1 = v1,{}...,{}xn = vn])} replaces \spad{xi} by \spad{vi} in \spad{f}.
291800`\spad{eval(f,{} [foo1,{}...,{}foon])} unquotes all the \spad{fooi}\spad{'s} in \spad{f}.
291889`\spad{eval(eqn,{} [x1=v1,{} ... xn=vn])} replaces \spad{xi} by \spad{vi} in equation \spad{eqn}.
291980`\spad{eval(p,{} el)} returns the image of {\em el} under the permutation \spad{p}.
292032`\spad{eval(f,{} foo)} unquotes all the foo\spad{'s} in \spad{f}.
292115`\spad{eval(eqn,{} x=f)} replaces \spad{x} by \spad{f} in equation \spad{eqn}.
295890`\spad{eval(p(x,{}y),{} f(x),{} g(x))} returns \spad{p(f(x),{} y * g(x))}.
295976`\spad{eval(f,{} [v1,{}...,{}vn],{} [g1,{}...,{}gn])} returns \spad{f} with each \spad{vi} replaced by \spad{gi} in parallel,{} \spadignore{i.e.} \spad{vi}\spad{'s} appearing inside the \spad{gi}\spad{'s} are not replaced.
296109`\spad{eval(f,{} v,{} g)} returns \spad{f} with \spad{v} replaced by \spad{g}.
296230`\spad{eval(mat,{}symbols,{}values)} evaluates a multivariable matrix at given \spad{values} for each of a list of variables
296378`\spad{eval(f,{} x,{} v)} replaces \spad{x} by \spad{v} in \spad{f}.
296429`\spad{eval(x,{} s,{} f)} replaces every \spad{s(a1,{}..,{}am)} in \spad{x} by \spad{f(a1,{}..,{}am)} for any \spad{a1},{}...,{}\spad{am}.
296502`\spad{eval(x,{} s,{} f)} replaces every \spad{s(a)} in \spad{x} by \spad{f(a)} for any \spad{a}.
296569`\spad{eval(f,{} [x1,{}...,{}xn],{} [v1,{}...,{}vn])} replaces \spad{xi} by \spad{vi} in \spad{f}.
296632`\spad{eval(x,{} [s1,{}...,{}sm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a1,{}...,{}an)} in \spad{x} by \spad{\spad{fi}(a1,{}...,{}an)} for any \spad{a1},{}...,{}\spad{an}.
296717`\spad{eval(x,{} [s1,{}...,{}sm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.
296796`\spad{eval(x,{} [s1,{}...,{}sm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a1,{}...,{}an)} in \spad{x} by \spad{\spad{fi}(a1,{}...,{}an)} for any \spad{a1},{}...,{}\spad{an}.
296874`\spad{eval(x,{} [s1,{}...,{}sm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.
296946`\axiom{eval(\spad{p},{} [\spad{x1},{}...,{}\spad{xn}],{} [\spad{v1},{}...,{}\spad{vn}])} replaces \axiom{\spad{xi}} by \axiom{\spad{vi}} in \axiom{\spad{p}}.
297021`\spad{eval(x,{} s,{} f)} replaces every \spad{s(a1,{}..,{}am)} in \spad{x} by \spad{f(a1,{}..,{}am)} for any \spad{a1},{}...,{}\spad{am}.
297087`\spad{eval(x,{} s,{} f)} replaces every \spad{s(a)} in \spad{x} by \spad{f(a)} for any \spad{a}.
297147`\axiom{eval(\spad{p},{} \spad{x},{} \spad{v})} replaces \axiom{\spad{x}} by \axiom{\spad{v}} in \axiom{\spad{p}}.
297694`\spad{eval(x,{} s,{} f,{} y)} replaces every \spad{s(a)} in \spad{x} by \spad{f(y)} with \spad{y} replaced by \spad{a} for any \spad{a}.
297794`\spad{eval(x,{} [s1,{}...,{}sm],{} [f1,{}...,{}fm],{} y)} replaces every \spad{\spad{si}(a)} in \spad{x} by \spad{\spad{fi}(y)} with \spad{y} replaced by \spad{a} for any \spad{a}.
297906`\spad{eval(x,{} [s1,{}...,{}sm],{} [n1,{}...,{}nm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a1,{}...,{}an)**ni} in \spad{x} by \spad{\spad{fi}(a1,{}...,{}an)} for any \spad{a1},{}...,{}am.
298021`\spad{eval(x,{} [s1,{}...,{}sm],{} [n1,{}...,{}nm],{} [f1,{}...,{}fm])} replaces every \spad{\spad{si}(a)**ni} in \spad{x} by \spad{\spad{fi}(a)} for any \spad{a}.
298130`\spad{eval(x,{} s,{} n,{} f)} replaces every \spad{s(a1,{}...,{}am)**n} in \spad{x} by \spad{f(a1,{}...,{}am)} for any \spad{a1},{}...,{}am.
298227`\spad{eval(x,{} s,{} n,{} f)} replaces every \spad{s(a)**n} in \spad{x} by \spad{f(a)} for any \spad{a}.
298371`\spad{evaluateInverse(x,{}f)} \undocumented
298437`\spad{evaluate(op)} returns the value of the "\%eval" property of \spad{op} if it has one,{} and "failed" otherwise.
298579`\spad{evaluate(op,{} foo)} attaches foo as the "\%eval" property of \spad{op}. If \spad{op} has an "\%eval" property \spad{f},{} then applying \spad{op} to a returns the result of \spad{f(a)}. Argument \spad{op} must be unary.
298667`\spad{evaluate(op,{} foo)} attaches foo as the "\%eval" property of \spad{op}. If \spad{op} has an "\%eval" property \spad{f},{} then applying \spad{op} to \spad{(a1,{}...,{}an)} returns the result of \spad{f(a1,{}...,{}an)}.
298761`\spad{evaluate(op,{} [a1,{}...,{}an])} checks if \spad{op} has an "\%eval" property \spad{f}. If it has,{} then \spad{f(a1,{}...,{}an)} is returned,{} and "failed" otherwise.
298854`\spad{evaluate(f,{} u +-> g u)} attaches the map \spad{g} to \spad{f}. \spad{f} must be a basic operator \spad{g} MUST be additive,{} \spadignore{i.e.} \spad{g(a + b) = g(a) + g(b)} for any \spad{a},{} \spad{b} in \spad{M}. This implies that \spad{g(n a) = n g(a)} for any \spad{a} in \spad{M} and integer \spad{n > 0}.
299013`\spad{even? x} is \spad{true} if \spad{x} is an even integer.
299093`\spad{even?(n)} returns \spad{true} if and only if \spad{n} is even.
299147`\spad{even?(p)} returns \spad{true} if and only if \spad{p} is an even permutation,{} \spadignore{i.e.} {\em sign(p)} is 1.
299196`\spad{evenInfiniteProduct(f(x))} computes \spad{product(n=2,{}4,{}6...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
299287`\spad{evenInfiniteProduct(f(x))} computes \spad{product(n=2,{}4,{}6...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
299376`\spad{evenInfiniteProduct(f(x))} computes \spad{product(n=2,{}4,{}6...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
299463`\spad{evenInfiniteProduct(f(x))} computes \spad{product(n=2,{}4,{}6...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
299544`\spad{evenlambert(st)} computes \spad{f(x**2) + f(x**4) + f(x**6) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f(x)} is a power series with constant coefficient 1,{} then \spad{prod(f(x**(2*n)),{}n=1..infinity) = exp(evenlambert(log(f(x))))}.
299625`\spad{evenlambert(f(x))} returns \spad{f(x^2) + f(x^4) + f(x^6) + ...}. \indented{1}{\spad{f(x)} should have a zero constant coefficient.} \indented{1}{This function is used for computing infinite products.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n=1..infinity,{}f(x^(2*n))) = exp(log(evenlambert(f(x))))}.}
300226`\spad{every?(f,{}u)} tests if \spad{p}(\spad{x}) is \spad{true} for all elements \spad{x} of \spad{u}. Note: for collections,{} \axiom{every?(\spad{p},{}\spad{u}) = reduce(and,{}map(\spad{f},{}\spad{u}),{}\spad{true},{}\spad{false})}.
300332`\spad{exQuo(x,{}y)} \undocumented
300435`\spad{exQuo(x,{}y)} \undocumented
300528`\spad{exQuo(x,{}y)} \undocumented
300762`\axiom{exactQuotient!(\spad{p},{}\spad{r})} replaces \axiom{\spad{p}} by \axiom{exactQuotient(\spad{p},{}\spad{r})}.
300858`\axiom{exactQuotient!(a,{}\spad{b})} replaces \axiom{a} by \axiom{exactQuotient(a,{}\spad{b})}
301095`\axiom{exactQuotient(\spad{p},{}\spad{r})} computes the exact quotient of \axiom{\spad{p}} by \axiom{\spad{r}},{} which is assumed to be a divisor of \axiom{\spad{p}}. No error is returned if this exact quotient fails!
301190`\axiom{exactQuotient(a,{}\spad{b})} computes the exact quotient of \axiom{a} by \axiom{\spad{b}},{} which is assumed to be a divisor of \axiom{a}. No error is returned if this exact quotient fails!
301286`\spad{exists?(f)} tests if the file exists in the file system.
301339`\spad{exp1()} returns the natural log base \spad{2.718281828...}.
301377`\spad{exp1()} returns exp 1: \spad{2.7182818284...}.
301409`\spad{expIfCan(z)} returns exp(\spad{z}) if possible,{} and "failed" otherwise.
301489`\spad{expPot(v,{}e,{}d)} returns the sum from \spad{i = 0} to \spad{e - 1} of \spad{v**(q**i*d)},{} interpreting \spad{v} as an element of a normal basis field and where \spad{q} is the size of the ground field. Note: for a description of the algorithm,{} see \spad{T}.Itoh and \spad{S}.Tsujii,{} "A fast algorithm for computing multiplicative inverses in \spad{GF}(2^m) using normal bases",{} Info
301489`--rmation and Computation 78,{} \spad{pp}.171-177,{} 1988.
301598`\spad{exp(x)} applies the exponential operator to \spad{x}
301647`\axiom{exp(\spad{p})} returns the exponential of \axiom{\spad{p}}.
301727`\spad{exp([i1,{}...in])} returns \spad{u_1\^{i_1} ... u_n\^{i_n}}
301884`\spad{exp(st)} computes the exponential of a power series \spad{st}.
301967`\spad{exp(st)} computes the exponential of a power series \spad{st}.
302064`\spad{exp(z)} returns the exponential of Laurent series \spad{z}.
302150`\spad{exp(z)} returns the exponential of a Puiseux series \spad{z}.
302245`\spad{exp(x)} returns \%\spad{e} to the power \spad{x}.
302299`\spad{exp(x)} represents the Fortran intrinsic function EXP
302379`\axiom{exp(\spad{p},{} \spad{n})} returns the exponential of \axiom{\spad{p}} truncated at order \axiom{\spad{n}}.
302467`\axiom{exp(\spad{p},{}\spad{n})} returns the exponential of \axiom{\spad{p}} (truncated up to order \axiom{\spad{n}}).
302570`\spad{expandLog(f)} converts every \spad{log(a/b)} appearing in \spad{f} into \spad{log(a) - log(b)},{} and every \spad{log(a*b)} into \spad{log(a) + log(b)}..
302634`\spad{expandPower(f)} converts every power \spad{(a/b)**c} appearing in \spad{f} into \spad{a**c * b**(-c)}.
302700`\spad{expandTrigProducts(e)} replaces \axiom{sin(\spad{x})*sin(\spad{y})} by \spad{(cos(x-y)-cos(x+y))/2},{} \axiom{cos(\spad{x})*cos(\spad{y})} by \spad{(cos(x-y)+cos(x+y))/2},{} and \axiom{sin(\spad{x})*cos(\spad{y})} by \spad{(sin(x-y)+sin(x+y))/2}. Note that this operation uses the pattern matcher and so 
302700`--is relatively expensive. To avoid getting into an infinite loop the transformations are applied at most ten times.
302967`\spad{expand(p)} returns \spad{p} in distributed form.
303058`\spad{expand(f)} performs the following expansions on \spad{f:}\begin{items} \item 1. logs of products are expanded into sums of logs,{} \item 2. trigonometric and hyperbolic trigonometric functions of sums are expanded into sums of products of trigonometric and hyperbolic trigonometric functions. \item 3. formal powers of the form \spad{(a/b)**c} are expanded into \spad{a**c * b**(-c)}. \end{items}
303119`\spad{expand(i)} returns the list of possible real functions corresponding to \spad{i}.
303205`\spad{expand(i)} returns the list of possible real functions corresponding to \spad{i}.
303325`\spad{expand(l)} creates a new value of type \spad{L} in which each segment \spad{l..h by k} is replaced with \spad{l,{} l+k,{} ... lN},{} where \spad{lN <= h < lN+k}. For example,{} \spad{expand [1..4,{} 7..9] = [1,{}2,{}3,{}4,{}7,{}8,{}9]}.
303390`\spad{expand(l..h by k)} creates value of type \spad{L} with elements \spad{l,{} l+k,{} ... lN} where \spad{lN <= h < lN+k}. For example,{} \spad{expand(1..5 by 2) = [1,{}3,{}5]}.
303449`\spad{expand(f)} multiplies the unit and factors together,{} yielding an "unfactored" object. Note: this is purposely not called \spadfun{coerce} which would cause the interpreter to do this automatically.
303490`\spad{expand(f,{}n)} \undocumented{}
303596`\spad{expenseOfEvaluationIF(o)} returns the intensity value of the cost of evaluating the input ODE. This is in terms of the number of ``operational units\spad{''}. It returns a value in the range [0,{}1].\newline\indent{20} 400 ``operation units\spad{'
303596`--'} \spad{->} 0.75 \newline 200 ``operation units\spad{''} \spad{->} 0.5 \newline 83 ``operation units\spad{''} \spad{->} 0.25 \newline\indent{15} exponentiation = 4 units ,{} function calls = 10 units.
303850`\spad{expenseOfEvaluation(o)} returns the intensity value of the cost of evaluating the input set of functions. This is in terms of the number of ``operational units\spad{''}. It returns a value in the range [0,{}1].
303975`\spad{expenseOfEvaluation(o)} gives an approximation of the cost of evaluating a list of expressions in terms of the number of basic operations. < 0.3 inexpensive ; 0.5 neutral ; > 0.7 very expensive 400 `operation units' \spad{->} 0.75 200 `operation units' \spad{->} 0.5 83 `operation units' \spad{->} 0.25 \spad{**} = 4 units ,{} function calls = 10 units.
304075`\spad{expextendedint(f,{} ',{} foo,{} g)} returns either \spad{[v,{} c]} such that \spad{f = v' + c g} and \spad{c' = 0},{} or \spad{[v,{} a]} such that \spad{f = g' + a},{} and \spad{a = 0} or \spad{a} has no integral in \spad{F}. Returns "failed" if neither cas
304075`--e can hold. Argument \spad{foo} is a Risch differential equation function on \spad{F}.
304319`\spad{expint(f,{} x)} returns e^{the integral of \spad{f} with respect to \spad{x}}.
304374`\spad{expintegrate(f,{} ',{} foo)} returns \spad{[g,{} a]} such that \spad{f = g' + a},{} and \spad{a = 0} or \spad{a} has no integral in \spad{F}; Argument foo is a Risch differential equation solver on \spad{F}.
304558`\spad{expintfldpoly(p,{} foo)} returns \spad{q} such that \spad{p' = q} or "failed" if no such \spad{q} exists. Argument foo is a Risch differential equation function on \spad{F}.
304733`\spad{explicitEntries?(s)} returns \spad{true} if the stream \spad{s} has explicitly computed entries,{} and \spad{false} otherwise.
304801`\spad{explicitlyEmpty?(s)} returns \spad{true} if the stream is an (explicitly) empty stream. Note: this is a null test which will not cause lazy evaluation.
304997`\spad{explicitlyFinite?(s)} tests if the stream has a finite number of elements,{} and \spad{false} otherwise. Note: for many datatypes,{} \axiom{explicitlyFinite?(\spad{s}) = not possiblyInfinite?(\spad{s})}.
305062`\spad{explimitedint(f,{} ',{} foo,{} [u1,{}...,{}un])} returns \spad{[v,{} [c1,{}...,{}cn],{} a]} such that \spad{ci' = 0},{} \spad{f = v' + a + reduce(+,{}[\spad{ci} * ui'/ui])},{} and \spad{a = 0} or \spad{a} has no integr
305062`--al in \spad{F}. Returns "failed" if no such \spad{v},{} \spad{ci},{} a exist. Argument \spad{foo} is a Risch differential equation function on \spad{F}.
305345`\spad{explogs2trigs(f)} rewrites all the complex logs and exponentials appearing in \spad{f} in terms of trigonometric functions.
305430`\spad{exponent(x)} \undocumented
305485`\spad{exponent(exp(f(x)))} returns \spad{f(x)}
305599`\spad{exponent(x)} returns the \spadfunFrom{exponent}{FloatingPointSystem} part of \spad{x}.
305656`\spad{exponent(u)} returns the exponent of the first factor of \spadvar{\spad{u}},{} or 0 if the factored form consists solely of a unit.
305705`\spad{exponent(u)} returns the exponent of \spad{u}
305755`\spad{exponential1()} \undocumented
305817`\spad{exponentialOrder(exp(c * x **(-n) + ...))} returns \spad{-n}. exponentialOrder(0) returns \spad{0}.
305921`\spad{exponential(f)} \undocumented
305991`\spad{exponential(f(x))} returns \spad{exp(f(x))}. Note: the function does NOT check that \spad{f(x)} has no non-negative terms.
306108`\spad{exponents(x)} converts a domain element into a list of zeros and ones corresponding to the exponents in the basis element that \spad{x} represents.
306164`\axiom{exprHasAlgebraicWeight} looks for algebraic weights giving rise to singularities of the function at the end-points.
306386`\axiom{exprHasLogarithmicWeights} looks for logarithmic weights giving rise to singularities of the function at the end-points.
306585`\axiom{exprHasWeightCosWXorSinWX} looks for trigonometric weights in an expression of the form \axiom{cos \omega \spad{x}} or \axiom{sin \omega \spad{x}},{} returning the value of \omega (\notequal 1) and the operator.
306831`\spad{exprToGenUPS(fcn,{}posCheck?,{}atanFlag)} converts the expression \spad{fcn} to a generalized power series. If \spad{posCheck?} is \spad{true},{} log\spad{'s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag}
306831`-- determines how the case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{"complex"},{} \spad{"real: two sides"},{} \spad{"real: left side"},{} \spad{"real: right side"},{} and \spad{"just do it"}. If \spad{atanFlag} is \spad{"complex"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coef
306831`--ficient of the series expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{"just do it"}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for value
306831`--s to the right. If \spad{atanFlag} is \spad{"real: two sides"},{} no series expansion will be computed. If \spad{atanFlag} is \spad{"real: left side"} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{"real: right side"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} we return a record containing the name of the function that caused the problem and a brief description o
306831`--f the problem. When expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.
306999`\spad{exprToUPS(fcn,{}posCheck?,{}atanFlag)} converts the expression \spad{fcn} to a power series. If \spad{posCheck?} is \spad{true},{} log\spad{'s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed. \spad{atanFlag} determines how th
306999`--e case \spad{atan(f(x))},{} where \spad{f(x)} has a pole,{} will be treated. The possible values of \spad{atanFlag} are \spad{"complex"},{} \spad{"real: two sides"},{} \spad{"real: left side"},{} \spad{"real: right side"},{} and \spad{"just do it"}. If \spad{atanFlag} is \spad{"complex"},{} then no series expansion will be computed because,{} viewed as a function of a complex variable,{} \spad{atan(f(x))} has an essential singularity. Otherwise,{} the sign of the leading coefficient of the ser
306999`--ies expansion of \spad{f(x)} determines the constant coefficient in the series expansion of \spad{atan(f(x))}. If this sign cannot be determined,{} a series expansion is computed only when \spad{atanFlag} is \spad{"just do it"}. When the leading term in the series expansion of \spad{f(x)} is of odd degree (or is a rational degree with odd numerator),{} then the constant coefficient in the series expansion of \spad{atan(f(x))} for values to the left differs from that for values to the right. If
306999`-- \spad{atanFlag} is \spad{"real: two sides"},{} no series expansion will be computed. If \spad{atanFlag} is \spad{"real: left side"} the constant coefficient for values to the left will be used and if \spad{atanFlag} \spad{"real: right side"} the constant coefficient for values to the right will be used. If there is a problem in converting the function to a power series,{} a record containing the name of the function that caused the problem and a brief description of the problem is returned. W
306999`--hen expanding the expression into a series it is assumed that the series is centered at 0. For a series centered at a,{} the user should perform the substitution \spad{x -> x + a} before calling this function.
307164`\spad{exprToXXP(fcn,{}posCheck?)} converts the expression \spad{fcn} to an exponential expansion. If \spad{posCheck?} is \spad{true},{} log\spad{'s} of negative numbers are not allowed nor are \spad{n}th roots of negative numbers with \spad{n} even. If \spad{posCheck?} is \spad{false},{} these are allowed.
307342`\spad{expr(s)} returns \spad{s} as an element of Expr; Error: if \spad{s} is not an atom that also belongs to Expr.
307499`\spad{expressIdealMember([f1,{}...,{}fn],{}h)} returns a representation of \spad{h} as a linear combination of the \spad{fi} or "failed" if \spad{h} is not in the ideal generated by the \spad{fi}.
307593`\spad{exptMod(u,{}k,{}v)} raises the polynomial \spad{u} to the \spad{k}th power modulo the polynomial \spad{v}.
307676`\spad{exptMod(f,{}n,{}g,{}p)} raises the univariate polynomial \spad{f} to the \spad{n}th power modulo the polynomial \spad{g} and the prime \spad{p}.
307758`\spad{expt(r,{} i)} computes r**i by repeated squaring
308346`\spad{exquo(a,{}b)} returns the power series quotient of \spad{a} by \spad{b},{} if the quotient exists,{} and "failed" otherwise
308447`\axiom{\spad{v} exquo \spad{r}} computes the exact quotient of \axiom{\spad{v}} by \axiom{\spad{r}}
308530`\spad{exquo(f,{}g)} creates the equivalent infix form.
308573`\spad{exquo(x,{} r)} returns the exact quotient of \spad{x} by \spad{r},{} or "failed" if \spad{r} does not divide \spad{x} exactly.
308660`\spad{exquo(p,{}r)} returns the exact quotient of polynomial \spad{p} by \spad{r},{} or "failed" if none exists.
308757`\spad{exquo(m,{}r)} computes the exact quotient of the elements of \spad{m} by \spad{r},{} returning \axiom{"failed"} if this is not possible.
308851`\spad{exquo(m,{}r)} computes the exact quotient of the elements of \spad{m} by \spad{r},{} returning \axiom{"failed"} if this is not possible.
308960`\spad{exquo(l,{} a)} returns the exact quotient of \spad{l} by a,{} returning \axiom{"failed"} if this is not possible.
309064`\spad{exquo(a,{}b)} either returns an element \spad{c} such that \spad{c*b=a} or "failed" if no such element can be found.
309127`\spad{exquo(a,{}b)} returns the quotient of \spad{a} and \spad{b},{} or "failed" if \spad{b} is zero or \spad{a} rem \spad{b} is zero.
309194`\axiom{extendIfCan(\spad{ts},{}\spad{p})} returns a triangular set which encodes the simple extension by \axiom{\spad{p}} of the extension of the base field defined by \axiom{\spad{ts}},{} according to the properties of triangular sets of the current domain. If the required properties do not hold then "failed" is returned. This operation encodes in some sense the properties of the triangular sets of the current category
309194`--. Is is used to implement the \axiom{construct} operation to guarantee that every triangular set build from a list of polynomials has the required properties.
309772`\spad{extend(lp,{}lts)} returns the same as \spad{concat([extend(lp,{}ts) for ts in lts])|}
309860`\spad{extend(lp,{}ts)} returns \spad{ts} if \spad{empty? lp} \spad{extend(p,{}ts)} if \spad{lp = [p]} else \spad{extend(first lp,{} extend(rest lp,{} ts))}
309942`\spad{extend(p,{}lts)} returns the same as \spad{concat([extend(p,{}ts) for ts in lts])|}
310024`\spad{extend(p,{}ts)} assumes that \spad{p} is a non-constant polynomial whose main variable is greater than any variable of \spad{ts}. Then it returns a split of Kalkbrener of \spad{ts+p}. This may not be \spad{ts+p} itself,{} if for instance \spad{ts+p} is not a regular triangular set.
310100`\spad{extend(f,{}n)} causes all terms of \spad{f} of degree \spad{<=} \spad{n} to be computed.
310178`\spad{extend(st,{}n)} causes entries to be computed,{} if necessary,{} so that 'st' will have at least \spad{'n'} explicit entries or so that all entries of 'st' will be computed if 'st' is finite with length \spad{<=} \spad{n}.
310239`\spad{extend(x,{}n)} forces the computation of digits up to order \spad{n}.
310301`\spad{extend(x,{}n)} causes the first \spadvar{\spad{n}} entries in the continued fraction \spadvar{\spad{x}} to be computed. Normally entries are only computed as needed.
310360`\spad{extend(x,{}l,{}r)} \undocumented
310415`\spad{extend(f,{}n)} causes all terms of \spad{f} of degree \spad{<= n} to be computed.
310507`\axiom{extend(\spad{ts},{}\spad{p})} returns a triangular set which encodes the simple extension by \axiom{\spad{p}} of the extension of the base field defined by \axiom{\spad{ts}},{} according to the properties of triangular sets of the current category If the required properties do not hold an error is returned.
310660`\spad{extendedEuclidean(x,{}y)} returns a record rec where \spad{rec.coef1*x+rec.coef2*y = rec.generator} and rec.generator is a \spad{gcd} of \spad{x} and \spad{y}. The \spad{gcd} is unique only up to associates if \spadatt{canonicalUnitNormal} is not asserted. \spadfun{principalIdeal} provides a version of this operation which accepts an arbitrary length list of arguments.
310852`\spad{extendedEuclidean(x,{}y,{}z)} either returns a record rec where \spad{rec.coef1*x+rec.coef2*y=z} or returns "failed" if \spad{z} cannot be expressed as a linear combination of \spad{x} and \spad{y}.
310954`\spad{extendedIntegrate(f,{} x,{} g)} returns fractions \spad{[h,{} c]} such that \spad{dc/dx = 0} and \spad{dh/dx = f - cg},{} if \spad{(h,{} c)} exist,{} "failed" otherwise.
311161`\axiom{extendedResultant(a,{}\spad{b})} returns \axiom{[\spad{r},{}ca,{}\spad{cb}]} such that \axiom{\spad{r}} is the resultant of \axiom{a} and \axiom{\spad{b}} and \axiom{\spad{r} = ca * a + \spad{cb} * \spad{b}}
311294`\axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca,{} \spad{cb}]} such that \axiom{\spad{g}} is a \spad{gcd} of \axiom{a} and \axiom{\spad{b}} in \axiom{\spad{R^}(\spad{-1}) \spad{P}} and \axiom{\spad{g} = ca * a + \spad{cb} * \spad{b}}
311428`\axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[ca,{}\spad{cb},{}\spad{r}]} such that \axiom{\spad{r}} is \axiom{subResultantGcd(a,{}\spad{b})} and we have \axiom{ca * a + \spad{cb} * \spad{cb} = \spad{r}} .
311564`\spad{extendedint(f,{} g)} returns fractions \spad{[h,{} c]} such that \spad{c' = 0} and \spad{h' = f - cg},{} if \spad{(h,{} c)} exist,{} "failed" otherwise.
311810`\spad{extensionDegree()} returns the degree of field extension.
311896`\spad{extensionDegree()} returns the degree of the field extension if the extension is algebraic,{} and \spad{infinity} if it is not.
311984`\spad{extensionDegree()} returns the degree of field extension.
312067`\spad{extension(f)} returns the type part of the file name.
312121`\spad{exteriorDifferential(df)} returns the exterior derivative (gradient,{} curl,{} divergence,{} ...) of the differential form \spad{df}.
312200`\spad{external?(u)} returns \spad{true} if \spad{u} is declared to be EXTERNAL
312250`\spad{externalList(tab)} returns a list of all the external symbols in \spad{tab}
312388`\spad{extract!(u)} destructively removes a (random) item from bag \spad{u}.
312435`\spad{extractBottom!(d)} destructively extracts the bottom (back) element from the dequeue \spad{d}. Error: if \spad{d} is empty.
312492`\spad{extractClosed(s)} returns the \spadtype{Boolean} value of the closed property for the indicated 3 dimensional subspace \spad{s}. If the property is closed,{} \spad{True} is returned,{} otherwise \spad{False} is returned.
312548`\axiom{extractIfCan(\spad{x})} searches the item whose key is \axiom{\spad{x}}.
312643`\spad{extractIndex(s)} returns a non negative integer which is the current index of the 3 dimensional subspace \spad{s}.
312709`\spad{extractPoint(s)} returns the point which is given by the current index location into the point data field of the 3 dimensional subspace \spad{s}.
312765`\spad{extractProperty(s)} returns the property of domain \spadtype{SubSpaceComponentProperty} of the indicated 3 dimensional subspace \spad{s}.
312841`\axiom{extractSplittingLeaf(a)} returns the left most leaf (as a tree) whose status is \spad{false} if any,{} else "failed" is returned.
312920`\spad{extractTop!(d)} destructively extracts the top (front) element from the dequeue \spad{d}. Error: if \spad{d} is empty.
312974`\spad{eyeDistance(v,{}d)} sets the distance of the observer from the center of the graph to \spad{d},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
313042`\spad{f01brf(n,{}nz,{}licn,{}lirn,{}pivot,{}lblock,{}grow,{}abort,{}a,{}irn,{}icn,{}ifail)} factorizes a real sparse matrix. The routine either forms the LU factorization of a permutation of the entire matrix,{} or,{} optionally,{} first permutes the matrix to block lower triangular form and then only factorizes 
313042`--the diagonal blocks. See \downlink{Manual Page}{manpageXXf01brf}.
313235`\spad{f01bsf(n,{}nz,{}licn,{}ivect,{}jvect,{}icn,{}ikeep,{}grow,{}eta,{}abort,{}idisp,{}avals,{}ifail)} factorizes a real sparse matrix using the pivotal sequence previously obtained by F01BRF when a matrix of the same sparsity pattern was factorized. See \downlink{Manual Page}{manpageXX
313235`--f01bsf}.
313454`\spad{f01maf(n,{}nz,{}licn,{}lirn,{}abort,{}avals,{}irn,{}icn,{}droptl,{}densw,{}ifail)} computes an incomplete Cholesky factorization of a real sparse symmetric positive-definite matrix A. See \downlink{Manual Page}{manpageXXf01maf}.
313643`\spad{f01mcf(n,{}avals,{}lal,{}nrow,{}ifail)} computes the Cholesky factorization of a real symmetric positive-definite variable-bandwidth matrix. See \downlink{Manual Page}{manpageXXf01mcf}.
313761`\spad{f01qcf(m,{}n,{}lda,{}a,{}ifail)} finds the \spad{QR} factorization of the real \spad{m} by \spad{n} matrix A,{} where m>=n. See \downlink{Manual Page}{manpageXXf01qcf}.
313871`\spad{f01qdf(trans,{}wheret,{}m,{}n,{}a,{}lda,{}zeta,{}ncolb,{}ldb,{}b,{}ifail)} performs one of the transformations See \downlink{Manual Page}{manpageXXf01qdf}.
314052`\spad{f01qef(wheret,{}m,{}n,{}ncolq,{}lda,{}zeta,{}a,{}ifail)} returns the first \spad{ncolq} columns of the real \spad{m} by \spad{m} orthogonal matrix \spad{Q},{} where \spad{Q} is given as the product of Householder transformation matrices. See \downlink{Manual Page}{manpageXXf01qef}.
314197`\spad{f01rcf(m,{}n,{}lda,{}a,{}ifail)} finds the \spad{QR} factorization of the complex \spad{m} by \spad{n} matrix A,{} where m>=n. See \downlink{Manual Page}{manpageXXf01rcf}.
314316`\spad{f01rdf(trans,{}wheret,{}m,{}n,{}a,{}lda,{}theta,{}ncolb,{}ldb,{}b,{}ifail)} performs one of the transformations See \downlink{Manual Page}{manpageXXf01rdf}.
314524`\spad{f01ref(wheret,{}m,{}n,{}ncolq,{}lda,{}theta,{}a,{}ifail)} returns the first \spad{ncolq} columns of the complex \spad{m} by \spad{m} unitary matrix \spad{Q},{} where \spad{Q} is given as the product of Householder transformation matrices. See \downlink{Manual Page}{manpageXXf01ref}.
314687`\spad{f02aaf(ia,{}n,{}a,{}ifail)} calculates all the eigenvalue. See \downlink{Manual Page}{manpageXXf02aaf}.
314778`\spad{f02abf(a,{}ia,{}n,{}iv,{}ifail)} calculates all the eigenvalues of a real symmetric matrix. See \downlink{Manual Page}{manpageXXf02abf}.
314877`\spad{f02adf(ia,{}ib,{}n,{}a,{}b,{}ifail)} calculates all the eigenvalues of Ax=(lambda)\spad{Bx},{} where A is a real symmetric matrix and \spad{B} is a real symmetric positive- definite matrix. See \downlink{Manual Page}{manpageXXf02adf}.
314996`\spad{f02aef(ia,{}ib,{}n,{}iv,{}a,{}b,{}ifail)} calculates all the eigenvalues of Ax=(lambda)\spad{Bx},{} where A is a real symmetric matrix and \spad{B} is a real symmetric positive-definite matrix. See \downlink{Manual Page}{manpageXXf02aef}.
315123`\spad{f02aff(ia,{}n,{}a,{}ifail)} calculates all the eigenvalues of a real unsymmetric matrix. See \downlink{Manual Page}{manpageXXf02aff}.
315214`\spad{f02agf(ia,{}n,{}ivr,{}ivi,{}a,{}ifail)} calculates all the eigenvalues of a real unsymmetric matrix. See \downlink{Manual Page}{manpageXXf02agf}.
315321`\spad{f02ajf(iar,{}iai,{}n,{}ar,{}\spad{ai},{}ifail)} calculates all the eigenvalue. See \downlink{Manual Page}{manpageXXf02ajf}.
315440`\spad{f02akf(iar,{}iai,{}n,{}ivr,{}ivi,{}ar,{}\spad{ai},{}ifail)} calculates all the eigenvalues of a complex matrix. See \downlink{Manual Page}{manpageXXf02akf}.
315575`\spad{f02awf(iar,{}iai,{}n,{}ar,{}\spad{ai},{}ifail)} calculates all the eigenvalues of a complex Hermitian matrix. See \downlink{Manual Page}{manpageXXf02awf}.
315694`\spad{f02axf(ar,{}iar,{}\spad{ai},{}iai,{}n,{}ivr,{}ivi,{}ifail)} calculates all the eigenvalues of a complex Hermitian matrix. See \downlink{Manual Page}{manpageXXf02axf}.
315829`\spad{f02bbf(ia,{}n,{}alb,{}ub,{}m,{}iv,{}a,{}ifail)} calculates selected eigenvalues of a real symmetric matrix by reduction to tridiagonal form,{} bisection and inverse iteration,{} where the selected eigenvalues lie within a given interval. See \downlink{Manual Page}{manpageXXf02bbf}.
315960`\spad{f02bjf(n,{}ia,{}ib,{}eps1,{}matv,{}iv,{}a,{}b,{}ifail)} calculates all the eigenvalues and,{} if required,{} all the eigenvectors of the generalized eigenproblem Ax=(lambda)\spad{Bx} where A and \spad{B} are real,{} square matrices,{} using the \spad{QZ} algorithm. See \downlink{Manual Page}{manpageXXf02bjf}.
316107`\spad{f02fjf(n,{}k,{}tol,{}novecs,{}nrx,{}lwork,{}lrwork,{}liwork,{}m,{}noits,{}x,{}ifail,{}dot,{}image)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \downlink{Manual Page}{manpageXXf02fjf}.
316335`\spad{f02fjf(n,{}k,{}tol,{}novecs,{}nrx,{}lwork,{}lrwork,{}liwork,{}m,{}noits,{}x,{}ifail,{}dot,{}image,{}monit)} finds eigenvalues of a real sparse symmetric or generalized symmetric eigenvalue problem. See \downlink{Manual Page}{manpageXXf02fjf}.
316572`\spad{f02wef(m,{}n,{}lda,{}ncolb,{}ldb,{}wantq,{}ldq,{}wantp,{}ldpt,{}a,{}b,{}ifail)} returns all,{} or part,{} of the singular value decomposition of a general real matrix. See \downlink{Manual Page}{manpageXXf02wef}.
316740`\spad{f02xef(m,{}n,{}lda,{}ncolb,{}ldb,{}wantq,{}ldq,{}wantp,{}ldph,{}a,{}b,{}ifail)} returns all,{} or part,{} of the singular value decomposition of a general complex matrix. See \downlink{Manual Page}{manpageXXf02xef}.
316926`\spad{f04adf(ia,{}b,{}ib,{}n,{}m,{}ic,{}a,{}ifail)} calculates the approximate solution of a set of complex linear equations with multiple right-hand sides,{} using an LU factorization with partial pivoting. See \downlink{Manual Page}{manpageXXf04adf}.
317095`\spad{f04arf(ia,{}b,{}n,{}a,{}ifail)} calculates the approximate solution of a set of real linear equations with a single right-hand side,{} using an LU factorization with partial pivoting. See \downlink{Manual Page}{manpageXXf04arf}.
317222`\spad{f04asf(ia,{}b,{}n,{}a,{}ifail)} calculates the accurate solution of a set of real symmetric positive-definite linear equations with a single right- hand side,{} Ax=b,{} using a Cholesky factorization and iterative refinement. See \downlink{Manual Page}{manpageXXf04asf}.
317349`\spad{f04atf(a,{}ia,{}b,{}n,{}iaa,{}ifail)} calculates the accurate solution of a set of real linear equations with a single right-hand side,{} using an LU factorization with partial pivoting,{} and iterative refinement. See \downlink{Manual Page}{manpageXXf04atf}.
317484`\spad{f04axf(n,{}a,{}licn,{}icn,{}ikeep,{}mtype,{}idisp,{}rhs)} calculates the approximate solution of a set of real sparse linear equations with a single right-hand side,{} Ax=b or \indented{1}{\spad{T}} A \spad{x=b},{} where A has been factorized by F01BRF or F01BSF. See \downlink{Manual Page}{manpageXXf04axf}.
317659`\spad{f04faf(job,{}n,{}d,{}e,{}b,{}ifail)} calculates the approximate solution of a set of real symmetric positive-definite tridiagonal linear equations. See \downlink{Manual Page}{manpageXXf04faf}.
317806`\spad{f04jgf(m,{}n,{}nra,{}tol,{}lwork,{}a,{}b,{}ifail)} finds the solution of a linear least-squares problem,{} Ax=b ,{} where A is a real \spad{m} by \spad{n} (m>=n) matrix and \spad{b} is an \spad{m} element vector. If the matrix of observations is not of full rank,{} then the minimal least-squares solution is returned. See \downlink{Manual Page}{
317806`--manpageXXf04jgf}.
317961`\spad{f04maf(n,{}nz,{}avals,{}licn,{}irn,{}lirn,{}icn,{}wkeep,{}ikeep,{}inform,{}b,{}acc,{}noits,{}ifail)} \spad{e} a sparse symmetric positive-definite system of linear equations,{} Ax=b,{} using a pre-conditioned conjugate gradient method,{}
317961`-- where A has been factorized by F01MAF. See \downlink{Manual Page}{manpageXXf04maf}.
318225`\spad{f04mbf(n,{}b,{}precon,{}shift,{}itnlim,{}msglvl,{}lrwork,{}liwork,{}rtol,{}ifail,{}aprod,{}msolve)} solves a system of real sparse symmetric linear equations using a Lanczos algorithm. See \downlink{Manual Page}{manpageXXf04mbf}.
318460`\spad{f04mcf(n,{}al,{}lal,{}d,{}nrow,{}ir,{}b,{}nrb,{}iselct,{}nrx,{}ifail)} computes the approximate solution of a system of real linear equations with multiple right-hand sides,{} AX=B,{} where A is a symmetric positive-definite variable-bandwidth matrix,{} which has previously been factorized by F01MCF. Rel
318460`--ated systems may also be solved. See \downlink{Manual Page}{manpageXXf04mcf}.
318656`\spad{f04qaf(m,{}n,{}damp,{}atol,{}btol,{}conlim,{}itnlim,{}msglvl,{}lrwork,{}liwork,{}b,{}ifail,{}aprod)} solves sparse unsymmetric equations,{} sparse linear least- squares problems and sparse damped linear least-squares problems,{} using a Lanczos algorithm. See \downlink{Manual P
318656`--age}{manpageXXf04qaf}.
318879`\spad{f07adf(m,{}n,{}lda,{}a)} (DGETRF) computes the LU factorization of a real \spad{m} by \spad{n} matrix. See \downlink{Manual Page}{manpageXXf07adf}.
318964`\spad{f07aef(trans,{}n,{}nrhs,{}a,{}lda,{}ipiv,{}ldb,{}b)} (DGETRS) solves a real system of linear equations with \indented{36}{\spad{T}} multiple right-hand sides,{} AX=B or A \spad{X=B},{} where A has been factorized by F07ADF (DGETRF). See \downlink{Manual Page}{manpageXXf07aef}.
319100`\spad{f07fdf(uplo,{}n,{}lda,{}a)} (DPOTRF) computes the Cholesky factorization of a real symmetric positive-definite matrix. See \downlink{Manual Page}{manpageXXf07fdf}.
319184`\spad{f07fef(uplo,{}n,{}nrhs,{}a,{}lda,{}ldb,{}b)} (DPOTRS) solves a real symmetric positive-definite system of linear equations with multiple right-hand sides,{} AX=B,{} where A has been factorized by F07FDF (DPOTRF). See \downlink{Manual Page}{manpageXXf07fef}.
319304`\spad{f2df(f)} is a function to convert a \axiomType{Float} to a \axiomType{DoubleFloat}
319369`\spad{f2st(n)} coerces a \axiomType{Float} to \axiomType{String}
319429`\spad{fTable(l)} creates a functions table from the elements of \spad{l}.
320286`\spad{factor1(a)} returns the factorisation of a,{} assuming that a has no first-order right factor.
320499`\spad{factorAndSplit(eq)} make the right hand side 0 and factors the new left hand side. Each factor is equated to 0 and put into the resulting list without repetitions.
320576`\spad{factorByRecursion(p)} factors polynomial \spad{p}. This function performs the recursion step for factorPolynomial,{} as defined in \spadfun{PolynomialFactorizationExplicit} category (see \spadfun{factorPolynomial})
320730`\spad{factorByRecursion(p)} factors polynomial \spad{p}. This function performs the recursion step for factorPolynomial,{} as defined in \spadfun{PolynomialFactorizationExplicit} category (see \spadfun{factorPolynomial})
320885`\spad{factorFraction(r)} factors the numerator and the denominator of the polynomial fraction \spad{r}.
321005`\spad{factorGroebnerBasis(basis)} checks whether the \spad{basis} contains reducible polynomials and uses these to split the \spad{basis}.
321122`\spad{factorGroebnerBasis(basis,{}info)} checks whether the \spad{basis} contains reducible polynomials and uses these to split the \spad{basis}. If argument {\em info} is \spad{true},{} information is printed about partial results.
321247`\spad{factorList(u)} returns the list of factors with flags (for use by factoring code).
321364`\spad{factorList(k,{}n,{}m,{}j)} \undocumented
321533`\spad{factorOfDegree(d,{}f)} returns a factor of degree \spad{d} of the factored polynomial \spad{f}. Such a factor shall exist.
321634`\spad{factorOfDegree(d,{}p)} returns a factor of \spad{p} of degree \spad{d}.
321730`\spad{factorOfDegree(d,{}p,{}listOfDegrees)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees}.
321851`\spad{factorOfDegree(d,{}p,{}r)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has at least \spad{r} factors.
321966`\spad{factorOfDegree(d,{}p,{}listOfDegrees,{}r)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees},{} and that \spad{p} has at least \spad{r} factors.
322106`\spad{factorOfDegree(d,{}p,{}listOfDegrees,{}r,{}sqf)} returns a factor of \spad{p} of degree \spad{d} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees},{} and that \spad{p} has at least \spad{r} factors. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors).
322642`\spad{factorPolynomial(p)} returns the factorization into irreducibles of the univariate polynomial \spad{p}.
322780`\spad{factorPolynomial(p)} \undocumented{}
322943`\spad{factorSFBRlcUnit(p)} returns the square free factorization of polynomial \spad{p} (see \spadfun{factorSquareFreeByRecursion}{PolynomialFactorizationByRecursionUnivariate}) in the case where the leading coefficient of \spad{p} is a unit.
323097`\spad{factorSFBRlcUnit(p)} returns the square free factorization of polynomial \spad{p} (see \spadfun{factorSquareFreeByRecursion}{PolynomialFactorizationByRecursionUnivariate}) in the case where the leading coefficient of \spad{p} is a unit.
323263`\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \spad{p}. This functions performs the recursion step for factorSquareFreePolynomial,{} as defined in \spadfun{PolynomialFactorizationExplicit} category (see \spadfun{factorSquareFreePolynomial}).
323427`\spad{factorSquareFreeByRecursion(p)} returns the square free factorization of \spad{p}. This functions performs the recursion step for factorSquareFreePolynomial,{} as defined in \spadfun{PolynomialFactorizationExplicit} category (see \spadfun{factorSquareFreePolynomial}).
324010`\spad{factorSquareFreePolynomial(p)} factors the univariate polynomial \spad{p} into irreducibles where \spad{p} is known to be square free and primitive with respect to its main variable.
324158`\spad{factorSquareFree(p)} factors an extended squareFree polynomial \spad{p} over the rational numbers.
324230`\spad{factorSquareFree(p)} returns the factorization of \spad{p} which is supposed not having any repeated factor (this is not checked).
324306`\spad{factorSquareFree(m)} returns the factorization of \spad{m} square free polynomial
324380`\spad{factorSquareFree(p)} produces the complete factorization of the square free polynomial \spad{p}.
324460`\spad{factorSquareFree(p,{}listOfDegrees)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees}. \spad{f} is supposed not having any repeated factor (this is not checked).
324561`\spad{factorSquareFree(p,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has at least \spad{r} factors. \spad{f} is supposed not having any repeated factor (this is not checked).
324656`\spad{factorSquareFree(p,{}listOfDegrees,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees} and that \spad{p} has at least \spad{r} factors. \spad{f} is supposed not having any repeated factor (this is not checked).
324776`\spad{factorSquareFree(p,{}d,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{d} divides the degree of all factors of \spad{p} and that \spad{p} has at least \spad{r} factors. \spad{f} is supposed not having any repeated factor (this is not checked).
324890`\spad{factor(n)} returns the full factorization of integer \spad{n}
324959`\spad{factor(a)} returns the factorisation of a.
325171`\axiom{factor(\spad{x})} returns the decreasing factorization into Lyndon words.
325249`\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain
325332`\spad{factor(p)} factors the multivariate polynomial \spad{p} with coefficients which are fractions of elements of \spad{R}.
325399`\spad{factor(p)} factors a polynomial with polynomial coefficients.
325476`\spad{factor(p)} factors an extended polynomial \spad{p} over the rational numbers.
325773`\spad{factor(p)} factors the univariate polynomial \spad{p} with coefficients which are fractions of polynomials over \spad{R}.
325919`\spad{factor(p)} returns the factorisation of \spad{p}
326030`\spad{factor(p)} tries to factor \spad{p} into linear factors with error atmost {\em globalEps},{} the internal error bound,{} which can be set by {\em setErrorBound}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization.
326102`\spad{factor(p)} returns the factorization of \spad{p} over the integers.
326168`\spad{factor(m)} returns the factorization of \spad{m}
326232`\spad{factor(\spad{zi})} produces the complete factorization of the complex integer \spad{zi}.
326329`\spad{factor(p)} produces the complete factorization of the polynomial \spad{p}.
326399`\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain
326469`\spad{factor(p)} produces the complete factorization of the multivariate polynomial \spad{p} over a finite field.
326540`\spad{factor(p)} factorizes the polynomial \spad{p} with complex coefficients.
326608`\spad{factor(prf)} factors a polynomial with rational function coefficients.
326697`\spad{factor(p)} factors the multivariate polynomial \spad{p} over its coefficient domain where \spad{p} is represented as a univariate polynomial with multivariate coefficients
326823`\spad{factor(p)} produces the complete factorization of the multivariate polynomial \spad{p} over a finite field. \spad{p} is represented as a univariate polynomial with multivariate coefficients over a finite field.
326950`\spad{factor(p)} returns a prime factorisation of \spad{p} over the field generated by its coefficients.
327004`\spad{factor(p)} returns a prime factorisation of \spad{p}.
327071`\spad{factor(p)} returns a prime factorisation of \spad{p}.
327154`\spad{factor(p)} returns a prime factorisation of \spad{p}.
327242`\spad{factor(x)} returns the factorization of \spad{x} into irreducibles.
327308`\spad{factor(p,{} f)} returns a prime factorisation of \spad{p}; \spad{f} is a factorisation map for elements of UP.
327406`\spad{factor(a,{} zeros)} returns the factorisation of a. \spad{zeros} is a zero finder in \spad{UP}.
327601`\spad{factor(p,{}ufact)} factors the multivariate polynomial \spad{p} by specializing variables and calling the univariate factorizer \spad{ufact}.
327736`\spad{factor(p,{}ufact)} factors the multivariate polynomial \spad{p} by specializing variables and calling the univariate factorizer \spad{ufact}. \spad{p} is represented as a univariate polynomial with multivariate coefficients.
327927`\spad{factor(p,{}listOfDegrees)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees}.
328018`\spad{factor(p,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm and knowing that \spad{p} has at least \spad{r} factors.
328103`\spad{factor(p,{} eps)} tries to factor \spad{p} into linear factors with error atmost {\em eps}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization.
328177`\spad{factor(p,{}lan)} factors the polynomial \spad{p} over the extension generated by the algebraic numbers given by the list \spad{lan}.
328263`\spad{factor(p,{}lan)} factors the polynomial \spad{p} over the extension generated by the algebraic numbers given by the list \spad{lan}. \spad{p} is presented as a univariate polynomial with multivariate coefficients.
328405`\spad{factor(f1,{}p)} returns the list of factors of the univariate polynomial \spad{f1} modulo the integer prime \spad{p}. Error: if \spad{f1} is not square-free modulo \spad{p}.
328482`\spad{factor(p,{} [a1,{}...,{}an])} returns a prime factorisation of \spad{p} over the field generated by its coefficients and \spad{a1},{}...,{}an.
328558`\spad{factor(p,{}listOfDegrees,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{p} has for possible splitting of its degree \spad{listOfDegrees} and that \spad{p} has at least \spad{r} factors.
328668`\spad{factor(p,{}d,{}r)} factorizes the polynomial \spad{p} using the single factor bound algorithm,{} knowing that \spad{d} divides the degree of all factors of \spad{p} and that \spad{p} has at least \spad{r} factors.
328772`\spad{factor(p,{} eps,{} info)} tries to factor \spad{p} into linear factors with error atmost {\em eps}. An overall error bound {\em eps0} is determined and iterated tree-like calls to {\em pleskenSplit} are used to get the factorization. If {\em info} is {\em true},{} then information messages are given.
328854`\spad{factorial(n)} returns the factorial of \spad{n},{} \spadignore{i.e.} \spad{n!}.
328962`\spad{factorial(n)} returns \spad{n!}. this is the product of all integers between 1 and \spad{n} (inclusive). Note: \spad{0!} is defined to be 1.
329025`\spad{factorial(n)} computes the factorial of \spad{n} (denoted in the literature by \spad{n!}) Note: \spad{n! = n (n-1)! when n > 0}; also,{} \spad{0! = 1}.
329088`\spad{factorials(f)} rewrites the permutations and binomials in \spad{f} in terms of factorials.
329147`\spad{factorials(f)} rewrites the permutations and binomials in \spad{f} in terms of factorials.
329206`\spad{factorials(f,{} x)} rewrites the permutations and binomials in \spad{f} involving \spad{x} in terms of factorials.
329272`\spad{factorials(f,{} x)} rewrites the permutations and binomials in \spad{f} involving \spad{x} in terms of factorials.
329338`\spad{factorsOfCyclicGroupSize()} returns the factorization of size()\spad{-1}
329447`\spad{factorsOfDegree(d,{}f)} returns the factors of degree \spad{d} of the factored polynomial \spad{f}.
329555`\spad{factors(a1\^e1,{}...,{}an\^en)} returns \spad{[[a1,{} e1],{}...,{}[an,{} en]]}.
329628`\spad{factors(a1\^e1,{}...,{}an\^en)} returns \spad{[[a1,{} e1],{}...,{}[an,{} en]]}.
329713`\spad{factors(a1\^e1,{}...,{}an\^en)} returns \spad{[[a1,{} e1],{}...,{}[an,{} en]]}.
329805`\spad{factors(u)} returns a list of the factors in a form suitable for iteration. That is,{} it returns a list where each element is a record containing a base and exponent. The original object is the product of all the factors and the unit (which can be extracted by \axiom{unit(\spad{u})}).
329885`\spad{factorset(p)} returns the set of irreducible factors of \spad{p}.
329966`\spad{failed?(r)} tests if \spad{r} is a failed match.
330032`\spad{failed?(r)} tests if \spad{r} is a failed match.
330092`\spad{failed()} returns a failed match.
330150`\spad{failed()} returns a failed match.
330202`\spad{false} is a logical constant.
330237`\spad{ffactor(p)} tries to factor a univariate polynomial \spad{p} over \spad{F}
330326`\axiom{fglmIfCan(\spad{lp})} returns the lexicographical Groebner basis of \axiom{\spad{lp}} by using the {\em FGLM} strategy,{} if \axiom{zeroDimensional?(\spad{lp})} holds .
330526`\axiom{fglmIfCan(\spad{lq1})} returns the lexicographical Groebner basis of \axiom{\spad{lq1}} by using the {\em FGLM} strategy,{} if \axiom{zeroDimensional?(\spad{lq1})} holds.
330632`\spad{fi2df(f)} coerces a \axiomType{Fraction Integer} to \axiomType{DoubleFloat}
330710`\spad{fibonacci(n)} returns the \spad{n}th Fibonacci number. the Fibonacci numbers \spad{F[n]} are defined by \spad{F[0] = F[1] = 1} and \spad{F[n] = F[n-1] + F[n-2]}. The algorithm has running time \spad{O(log(n)^3)}. Reference: Knuth,{} The Art of Computer Programming Vol 2,{} Semi-Numerical Algorithms.
330866`\spad{filename(d,{}n,{}e)} creates a file name with \spad{d} as its directory,{} \spad{n} as its name and \spad{e} as its extension. This is a portable way to create file names. When \spad{d} or \spad{t} is the empty string,{} a default is used.
331106`\spad{fill!(u,{}x)} replaces each entry in aggregate \spad{u} by \spad{x}. The modified \spad{u} is returned as value.
331206`\spad{fill!(m,{}r)} fills \spad{m} with \spad{r}\spad{'s}
331276`\spad{fillPascalTriangle()} fills the stored table.
331342`\spad{filterUntil(p,{}t)} returns \spad{[x for x in t while not p(x)]}.
331407`\spad{filterUntil(p,{}s)} returns \spad{[x0,{}x1,{}...,{}x(n)]} where \spad{s = [x0,{}x1,{}x2,{}..]} and \spad{n} is the smallest index such that \spad{p(xn) = true}.
331465`\spad{filterWhile(p,{}t)} returns \spad{[x for x in t while p(x)]}.
331530`\spad{filterWhile(p,{}s)} returns \spad{[x0,{}x1,{}...,{}x(n-1)]} where \spad{s = [x0,{}x1,{}x2,{}..]} and \spad{n} is the smallest index such that \spad{p(xn) = false}.
331588`\spad{findCycle(n,{}st)} determines if \spad{st} is periodic within \spad{n}.
332075`\spad{find(p,{}u)} returns the first \spad{x} in \spad{u} such that \axiom{\spad{p}(\spad{x})} is \spad{true},{} and "failed" otherwise.
332145`\spad{finite?(\spad{a})} determines whether \spad{a} is a finite cardinal,{} \spadignore{i.e.} an integer.
332196`\spad{finite?(x)} tests if \spad{x} is finite.
332254`\spad{finite?(x)} tests if \spad{x} is finite.
332311`\spad{finiteBasis(d)} returns a basis for \spad{d} as a module over {\em K[x]}.
332380`\spad{finiteBound(l,{}b)} repaces all instances of an infinite entry in \axiom{\spad{l}} by a finite entry \axiom{\spad{b}} or \axiom{\spad{-b}}.
332493`\spad{fintegrate(f,{}v,{}c)} is the integral of \spad{f()} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.} \indented{1}{The evaluation of \spad{f()} is delayed.}
332621`\spad{fintegrate(f,{}v,{}c)} is the integral of \spad{f()} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.} \indented{1}{The evaluation of \spad{f()} is delayed.}
332726`\spad{firstDenom(p)} extracts the denominator of the first fractional term. This returns 1 if there is no fractional part (use \spadfunFrom{wholePart}{PartialFraction} to get the whole part).
332788`\spad{firstNumer(p)} extracts the numerator of the first fractional term. This returns 0 if there is no fractional part (use \spadfunFrom{wholePart}{PartialFraction} to get the whole part).
332840`\spad{firstSubsetGray(n)} creates the first vector {\em ww} to start a loop using {\em nextSubsetGray(ww,{}n)}
332922`\spad{firstUncouplingMatrix(op,{} m)} returns the matrix A such that \spad{A w = (W',{}W'',{}...,{}W^N)} in the corresponding associated equations for right-factors of order \spad{m} of \spad{op}. Returns "failed" if the matrix A has not been precomputed for the particular combination \spad{degree(L),{} m}.
333264`\spad{first([l1]*[l2]*...[ln])} returns the Lyndon word \spad{l1}.
333349`\spad{first(x)} returns the first letter of \spad{x}.
333398`\axiom{first(\spad{x})} returns the first entry of the tree \axiom{\spad{x}}.
333445`\spad{first(u)} returns the first element \spad{x} of \spad{u}. Note: for collections,{} \axiom{first([\spad{x},{}\spad{y},{}...,{}\spad{z}]) = \spad{x}}. Error: if \spad{u} is empty.
333528`\spad{first(u)} returns the first element of \spad{u} (equivalently,{} the value at the current node).
333583`\axiom{first(\spad{ts})} returns the polynomial of \axiom{\spad{ts}} with greatest main variable if \axiom{\spad{ts}} is not empty,{} otherwise returns \axiom{"failed"}.
333788`\spad{first(u,{}n)} returns a copy of the first \spad{n} (\axiom{\spad{n} \spad{>=} 0}) elements of \spad{u}.
333863`\spad{fixPredicate(f)} returns \spad{g} defined by \spad{g}(a) = \spad{f}(a::B).
333947`\spad{fixedDivisor(a)} for \spad{a(x)} in \spad{Z[x]} is the largest integer \spad{f} such that \spad{f} divides \spad{a(x=k)} for all integers \spad{k}. Note: fixed divisor of \spad{a} is \spad{reduce(gcd,{}[a(x=k) for k in 0..degree(a)])}.
334053`\spad{fixedPointExquo(f,{}g)} computes the exact quotient of \spad{f} and \spad{g} using a fixed point computation.
334140`\spad{fixedPoint f} is the fixed point of function \spad{f}. \indented{1}{\spadignore{i.e.} such that \spad{fixedPoint f = f(fixedPoint f)}.}
334196`\spad{fixedPoint(f,{}n)} is the fixed point of function \indented{1}{\spad{f} which is assumed to transform a list of length} \indented{1}{\spad{n}.}
334278`\spad{fixedPoints(p)} returns the points fixed by the permutation \spad{p}.
334345`\spad{flagFactor(base,{}exponent,{}flag)} creates a factored object with a single factor whose \spad{base} is asserted to be properly described by the information \spad{flag}.
334434`\spad{flatten(s)} returns an input form corresponding to \spad{s} with all the nested operations flattened to triples using new local variables. If \spad{s} is a piece of code,{} this speeds up the compilation tremendously later on.
334475`\spad{flexible?()} tests if \spad{2*associator(a,{}b,{}a) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
334549`\spad{flexible?()} tests if \spad{2*associator(a,{}b,{}a) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
334620`\spad{flexibleArray(l)} creates a flexible array from the list of elements \spad{l}
334743`\spad{float?(s)} is \spad{true} if \spad{s} is an atom and belong to \spad{Flt}.
334820`\spad{float(s)} returns \spad{s} as an element of \spad{Flt}; Error: if \spad{s} is not an atom that also belongs to \spad{Flt}.
334952`\spad{float(a,{}e)} returns \spad{a * base() ** e}.
335090`\spad{float(a,{}e,{}b)} returns \spad{a * b ** e}.
335211`\spad{floor(x)} returns the largest integral element below \spad{x}.
335290`\spad{floor x} returns the largest integer \spad{<= x}.
335336`\spad{fmecg(p1,{}e,{}r,{}p2)} finds \spad{X} : \spad{p1} - \spad{r} * X**e * \spad{p2}
335451`\axiom{fmecg(\spad{p1},{}\spad{e},{}\spad{r},{}\spad{p2})} returns \axiom{\spad{p1} - \spad{r} * X**e * \spad{p2}} where \axiom{\spad{X}} is \axiom{monomial(1,{}1)}
335537`\spad{fmecg(p1,{}e,{}r,{}p2)} finds \spad{X} : \spad{p1} - \spad{r} * X**e * \spad{p2}
335749`\spad{fmecg(p1,{}e,{}r,{}p2)} finds \spad{X} : \spad{p1} - \spad{r} * X**e * \spad{p2}
335828`\spad{forLoop(i=1..10,{}c)} creates a representation of a FORTRAN DO loop with \spad{i} ranging over the values 1 to 10.
335907`\spad{forLoop(i=1..10,{}n,{}c)} creates a representation of a FORTRAN DO loop with \spad{i} ranging over the values 1 to 10 by \spad{n}.
336006`\spad{formula(t)} extracts the formula section of a formatted object \spad{t}.
336067`\spad{fortranCarriageReturn()} produces a carriage return on the current Fortran output stream
336128`\spad{fortranCharacter()} returns CHARACTER,{} an element of FortranType
336178`\spad{fortranCompilerName()} returns the name of the currently selected \indented{1}{Fortran compiler}
336245`\spad{fortranComplex()} returns COMPLEX,{} an element of FortranType
336293`\spad{fortranDoubleComplex()} returns DOUBLE COMPLEX,{} an element of FortranType
336347`\spad{fortranDouble()} returns DOUBLE PRECISION,{} an element of FortranType
336394`\spad{fortranInteger()} returns INTEGER,{} an element of FortranType
336442`\spad{fortranLinkerArgs()} returns the current linker arguments
336507`\spad{fortranLiteralLine(s)} writes \spad{s} to the current Fortran output stream,{} followed by a carriage return
336571`\spad{fortranLiteral(s)} writes \spad{s} to the current Fortran output stream
336631`\spad{fortranLogical()} returns LOGICAL,{} an element of FortranType
336679`\spad{fortranReal()} returns REAL,{} an element of FortranType
336724`\spad{fortranTypeOf(u,{}tab)} returns the type of \spad{u} in \spad{tab}
336789`\spad{fortran(fname,{}ftype,{}body)} builds an object of type \axiomType{FortranProgramCategory}. The three arguments specify the name,{} the type and the \spad{body} of the program.
336872`\spad{fprindINFO }\undocumented
337064`\spad{fracPart(f)} returns the list of summands of the fractional part of \spad{f}.
337187`\spad{fractRadix(pre,{}cyc)} creates a fractional radix expansion from a list of prefix ragits and a list of cyclic ragits. For example,{} \spad{fractRadix([1],{}[6])} will return \spad{0.16666666...}.
337265`\spad{fractRagits(rx)} returns the ragits of the fractional part of a radix expansion.
337332`\spad{fractionFreeGauss(m)} performs the fraction free gaussian elimination on the matrix \spad{m}.
337542`\spad{fractionPart(b)} returns the fractional part of a binary expansion.
337609`\spad{fractionPart(d)} returns the fractional part of a decimal expansion.
337677`\spad{fractionPart(h)} returns the fractional part of a hexadecimal expansion.
337749`\spad{fractionPart(rx)} returns the fractional part of a radix expansion.
337819`\spad{fractionPart(x)} returns the fractional part of \spad{x}. \spad{x} = wholePart(\spad{x}) + fractionPart(\spad{x})
337902`\spad{fractionPart x} returns the fractional part of \spad{x}.
338064`\spad{freeOf?(x,{} s)} tests if \spad{x} does not contain any operator whose name is \spad{s}.
338123`\spad{freeOf?(x,{} y)} tests if \spad{x} does not contain any occurrence of \spad{y},{} where \spad{y} is a single kernel.
338178`\spad{frobenius(x)} \undocumented
338253`\spad{front(q)} returns the element at the front of the queue. The queue \spad{q} is unchanged by this operation. Error: if \spad{q} is empty.
338299`\spad{froot(f,{} n)} returns \spad{[m,{}c,{}r]} such that \spad{f**(1/n) = c * r**(1/m)}.
338440`\spad{frst(s)} returns the first element of stream \spad{s}. Caution: this function should only be called after a \spad{empty?} test has been made since there no error check.
338490`\spad{fullDisplay(db)} prints full details of each entry in \axiom{\spad{db}}.
338539`\spad{fullDisplay(ic)} prints all of the information contained in \axiom{\spad{ic}}.
338586`\spad{fullDisplay(db,{}start,{}end )} prints full details of entries in the range \axiom{\spad{start}..end} in \axiom{\spad{db}}.
338667`\spad{fullPartialFraction(f)} returns \spad{[p,{} [[j,{} Dj,{} Hj]...]]} such that \spad{f = p(x) + \sum_{[j,{}Dj,{}Hj] in l} \sum_{Dj(a)=0} Hj(a)/(x - a)\^j}.
338755`\spad{functionIsContinuous
338755`--AtEndPoints(args)} uses power series limits to check for problems at the end points of the range of \spad{args}.
339236`\spad{functionIsFracPolynomial?(args)} tests whether the function can be retracted to \axiomType{Fraction(Polynomial(DoubleFloat))}
339447`\spad{functionIsOscillatory(a)} tests whether the function \spad{a.fn} has many zeros of its derivative.
339639`\spad{function(e,{} foo)} creates a function \spad{foo() == e}.
339697`\spad{function(code,{} [x1,{}...,{}xn],{} f)} returns the input form corresponding to \spad{f(x1,{}...,{}xn) == code}.
339759`\spad{function(e,{} foo,{} [x1,{}...,{}xn])} creates a function \spad{foo(x1,{}...,{}xn) == e}.
339830`\spad{function(e,{} foo,{} x)} creates a function \spad{foo(x) == e}.
339895`\spad{function(e,{} foo,{} x,{} y)} creates a function \spad{foo(x,{} y) = e}.
339967`\spad{gbasis }\undocumented
340076`\spad{gcdPolynomial(p,{}q)} returns the \spad{GCD} of \spad{p} and \spad{q}
341087`\spad{gcdPolynomial(p,{}q)} returns the \spad{gcd} of the univariate polynomials \spad{p} \spad{qnd} \spad{q}.
341243`\spad{gcdPrimitive lp} computes the \spad{gcd} of the list of primitive polynomials \spad{lp}.
341314`\spad{gcdPrimitive(p,{}q)} computes the \spad{gcd} of the primitive polynomials \spad{p} and \spad{q}.
341381`\spad{gcdPrimitive(p,{}q)} computes the \spad{gcd} of the primitive polynomials \spad{p} and \spad{q}.
341532`\spad{gcd([f1,{}..,{}fk])} = \spad{gcd} of the polynomials \spad{fi}.
341576`\spad{gcd(lp)} computes the \spad{gcd} of the list of polynomials \spad{lp}.
341824`\spad{gcd(lp)} computes the \spad{gcd} of the list of polynomials \spad{lp}.
341942`\spad{gcd(l)} returns the common \spad{gcd} of the elements in the list \spad{l}.
341985`\spad{gcd(p,{}q)} computes the \spad{gcd} of the two polynomials \spad{p} and \spad{q}.
342273`\spad{gcd(p,{}q)} computes the \spad{gcd} of the two polynomials \spad{p} and \spad{q}.
342415`\axiom{\spad{gcd}(\spad{P},{} \spad{Q})} returns the \spad{gcd} of \axiom{\spad{P}} and \axiom{\spad{Q}}.
342499`\axiom{\spad{gcd}(\spad{r},{}\spad{p})} returns the \spad{gcd} of \axiom{\spad{r}} and the content of \axiom{\spad{p}}.
342578`\spad{gcd(x,{}y)} returns the greatest common divisor of \spad{x} and \spad{y}.
342618`\spad{gcd(a,{}b)} computes the greatest common divisor of two non negative integers \spad{a} and \spad{b}.
342667`\spad{gcd(a,{}b)} computes the greatest common divisor of two positive integers \spad{a} and \spad{b}.
342713`\spad{gcd(f1,{}f2,{}p)} computes the \spad{gcd} of the univariate polynomials \spad{f1} and \spad{f2} modulo the integer prime \spad{p}.
342783`\spad{gcdcofact([f1,{}..fk])} = \spad{gcd} and cofactors of \spad{k} univariate polynomials.
342839`\spad{gcdcofactprim([f1,{}..fk])} = \spad{gcd} and cofactors of \spad{k} primitive polynomials.
342899`\spad{gcdprim([f1,{}..,{}fk])} = \spad{gcd} of \spad{k} PRIMITIVE univariate polynomials
342947`\spad{gderiv(f,{}[a0,{}a1,{}a2,{}..])} returns \spad{[f(0)*a0,{}f(1)*a1,{}f(2)*a2,{}..]}.
343036`\spad{generalInfiniteProduct(f(x),{}a,{}d)} computes \spad{product(n=a,{}a+d,{}a+2*d,{}...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
343146`\spad{generalInfiniteProduct(f(x),{}a,{}d)} computes \spad{product(n=a,{}a+d,{}a+2*d,{}...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
343254`\spad{generalInfiniteProduct(f(x),{}a,{}d)} computes \spad{product(n=a,{}a+d,{}a+2*d,{}...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
343360`\spad{generalInfiniteProduct(f(x),{}a,{}d)} computes \spad{product(n=a,{}a+d,{}a+2*d,{}...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
343460`\spad{generalLambert(f(x),{}a,{}d)} returns \spad{f(x**a) + f(x**(a + d)) + f(x**(a + 2 d)) + ...}. \spad{f(x)} should have zero constant coefficient and \spad{a} and \spad{d} should be positive.
343560`\spad{generalLambert(f(x),{}a,{}d)} returns \spad{f(x^a) + f(x^(a + d)) + \indented{1}{f(x^(a + 2 d)) + ... }. \spad{f(x)} should have zero constant} \indented{1}{coefficient and \spad{a} and \spad{d} should be positive.}
343651`\spad{generalPosition(I,{}listvar)} perform a random linear transformation on the variables in \spad{listvar} and returns the transformed ideal along with the change of basis matrix.
343792`\spad{generalSqFr(p)} returns the square-free factorisation of polynomial \spad{p},{} a sparse univariate polynomial (sup) over a sup over \spad{F}.
343963`\spad{generalTwoFactor(p)} returns the factorisation of polynomial \spad{p},{} a sparse univariate polynomial (sup) over a sup over \spad{F}.
344139`\spad{generalizedContinuumHypothesisAssumed?()} tests if the hypothesis is currently assumed.
344219`\spad{generalizedContinuumHypothesisAssumed(bool)} is used to dictate whether the hypothesis is to be assumed.
344305`\spad{generalizedEigenvector(eigen,{}m)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{eigen},{} as returned by the function eigenvectors.
344580`\spad{generalizedEigenvector(alpha,{}m,{}k,{}g)} returns the generalized eigenvectors of the matrix relative to the eigenvalue \spad{alpha}. The integers \spad{k} and \spad{g} are respectively the algebraic and the geometric multiplicity of tye eigenvalue \spad{alpha}. \spad{alpha
344580`--} can be either rational or not. In the seconda case apha is the minimal polynomial of the eigenvalue.
344806`\spad{generalizedEigenvectors(m)} returns the generalized eigenvectors of the matrix \spad{m}.
345026`\spad{generalizedInverse(m)} returns the generalized (Moore
345026`--Penrose) inverse of the matrix \spad{m},{} \spadignore{i.e.} the matrix \spad{h} such that m*h*m=h,{} h*m*h=m,{} \spad{m*h} and \spad{h*m} are both symmetric matrices.
345113`\spad{generateIrredPoly(n)} generates an irreducible univariate polynomial of the given degree \spad{n} over the finite field.
345224`\spad{generate(f)} creates an infinite stream all of whose elements are equal to \spad{f()}. Note: \spad{generate(f) = [f(),{}f(),{}f(),{}...]}.
345269`\spad{generate(f,{}s)} returns \spad{[s,{}f(s),{}f(f(s)),{}...]}.
345324`\spad{generate(f,{}x)} creates an infinite stream whose first element is \spad{x} and whose \spad{n}th element (\spad{n > 1}) is \spad{f} applied to the previous element. Note: \spad{generate(f,{}x) = [x,{}f(x),{}f(f(x)),{}...]}.
345372`\spad{generate(numberOfGens,{} maximalWeight)} generates a vector of elements of the form [left,{}weight,{}right] which represents a \spad{P}. Hall basis element for the free lie algebra on \spad{numberOfGens} generators. We only generate those basis elements of weight less than or equal to maximalWeight
345519`\spad{generator()} returns a root of the defining polynomial. This element generates the field as an algebra over the ground field.
345596`\spad{generator()} returns the generator for this domain.
345650`\spad{generator(n)} returns the \spad{n}th multiplicative generator,{} a basis term.
345716`\spad{generator(n)} returns the \spad{n}th basis term for a differential form.
345800`\spad{generator(i)} is the \spad{i}th Hall Basis element
345877`\spad{generator(d)} returns \spad{f} if \spad{(f) = d},{} "failed" if \spad{d} is not principal.
345960`\spad{generators(I)} returns a list of generators for the ideal \spad{I}.
346042`\spad{generators(gp)} returns the generators of the group {\em gp}.
346114`\spad{generic?(p)} tests if \spad{p} is a single matching variable.
346162`\spad{genericLeftDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable
346292`\spad{genericLeftMinimalPolynomial(a)} substitutes the coefficients of {em a} for the generic coefficients in \spad{leftRankPolynomial()}
346457`\spad{genericLeftNorm(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the constant term in \spadfun{leftRankPolynomial} and changes the sign if the degree of this polynomial is odd. This is a form of degree \spad{k}
346581`\spad{genericLeftTraceForm (a,{}b)} is defined to be \spad{genericLeftTrace (a*b)},{} this defines a symmetric bilinear form on the algebra
346713`\spad{genericLeftTrace(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the second highest term in \spadfun{leftRankPolynomial} and changes the sign. \indented{1}{This is a linear form}
346838`\spad{genericPosition(lp,{}lv)} puts a radical zero dimensional ideal in general position,{} for system \spad{lp} in variables \spad{lv}.
347051`\spad{genericRightDiscriminant()} is the determinant of the generic left trace forms of all products of basis element,{} if the generic left trace form is associative,{} an algebra is separable if the generic left discriminant is invertible,{} if it is non-zero,{} there is some ring extension which makes the algebra separable
347182`\spad{genericRightMinimalPolynomial(a)} substitutes the coefficients of \spad{a} for the generic coefficients in \spadfun{rightRankPolynomial}
347348`\spad{genericRightNorm(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the constant term in \spadfun{rightRankPolynomial} and changes the sign if the degree of this polynomial is odd
347473`\spad{genericRightTraceForm (a,{}b)} is defined to be \spadfun{genericRightTrace (a*b)},{} this defines a symmetric bilinear form on the algebra
347606`\spad{genericRightTrace(a)} substitutes the coefficients of \spad{a} for the generic coefficients into the coefficient of the second highest term in \spadfun{rightRankPolynomial} and changes the sign
347732`\spad{generic()} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{\%x1,{}\%x2,{}..}
347804`\spad{generic(s)} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{s1,{}s2,{}..}
347882`\spad{generic(vs)} returns a generic element,{} \spadignore{i.e.} the linear combination of the fixed basis with the symbolic coefficients \spad{vs}; error,{} if the vector of symbols is too short
347968`\spad{generic(ve)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{ve} basis with the symbolic coefficients \spad{\%x1,{}\%x2,{}..}
348050`\spad{generic(s,{}v)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{v} with the symbolic coefficients \spad{s1,{}s2,{}..}
348139`\spad{generic(vs,{}ve)} returns a generic element,{} \spadignore{i.e.} the linear combination of \spad{ve} with the symbolic coefficients \spad{vs} error,{} if the vector of symbols is shorter than the vector of elements
348236`\spad{genus()} returns the genus of one absolutely irreducible component
348315`\spad{genus()} returns the genus of one absolutely irreducible component
348391`\spad{geometric(f)} \undocumented
348472`\spad{getBadValues(p)} returns the list of "bad values" for \spad{p}. Note: \spad{p} is not allowed to match any of its "bad values".
348526`\axiom{getButtonValue(routineName,{}attributeName)} returns the current value for the effect of the attribute \axiom{attributeName} with routine \axiom{routineName}. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
348595`\spad{getCode(f)} returns a Lisp list of strings representing \spad{f} in Fortran notation. This is used by the FortranProgram domain.
348647`\spad{getCurve(t)} returns the \spadtype{PlottableSpaceCurveCategory} representing the parametric curve of the given tube plot \spad{t}.
348698`\spad{getDatabase("char")} returns a list of appropriate entries in the browser database. The legal values for \spad{"char"} are "o" (operations),{} \spad{"k"} (constructors),{} \spad{"d"} (domains),{} \spad{"c"} (categories) or \spad{"p"} (packages).
348770`\spad{getExplanations(R,{}s)} gets the explanations of the output parameters for the given NAG routine.
348840`\spad{getGoodPrime n} returns the smallest prime not dividing \spad{n}
348928`\spad{getGraph(v,{}n)} returns the graph which is of the domain \spadtype{GraphImage} which is located in graph field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of the domain \spadtype{TwoDimensionalViewport}.
349007`\spad{getMatch(var,{} r)} returns the expression that \spad{var} matches in the result \spad{r},{} and "failed" if \spad{var} is not matched in \spad{r}.
349089`\spad{getMeasure(R,{}s)} gets the current value of the maximum measure for the given NAG routine.
349147`\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.
349243`\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.
349348`\spad{getMultiplicationMatrix()} returns the multiplication table in form of a matrix.
349445`\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.
349580`\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.
349724`\spad{getMultiplicationTable()} returns the multiplication table for the normal basis of the field. This table is used to perform multiplications between field elements.
349860`\spad{getOrder()} returns \spad{[[b1,{}...,{}bm],{} [a1,{}...,{}an]]} such that the partial ordering on \spad{S} was given by \spad{setOrder([b1,{}...,{}bm],{}[a1,{}...,{}an])}.
349950`\spad{getPickedPoints(x)} returns a list of small floats for the points the user interactively picked on the viewport for full integration into the system,{} some design issues need to be addressed: \spadignore{e.g.} how to go through the GraphImage interface,{} how to default to graphs,{} etc.
350034`\spad{getRef(f)} returns a reference containing the order to which the terms of \spad{f} have been computed.
350138`\spad{getStream(f)} returns the stream of terms representing the series \spad{f}.
350240`\spad{getVariableOrder()} returns \spad{[[b1,{}...,{}bm],{} [a1,{}...,{}an]]} such that the ordering on the variables was given by \spad{setVariableOrder([b1,{}...,{}bm],{} [a1,{}...,{}an])}.
350346`\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly.
350450`\spad{getZechTable()} returns the zech logarithm table of the field it is used to perform additions in the field quickly.
350566`\spad{getZechTable()} returns the zech logarithm table of the field. This table is used to perform additions in the field quickly.
350660`\spad{gethi(u)} gets the \axiomType{DoubleFloat} equivalent of the second endpoint of the range \axiom{\spad{u}}
350765`\spad{gethi(u)} gets the \axiomType{DoubleFloat} equivalent of the second endpoint of the range \spad{u}
350865`\spad{gethi(x)} gets the \axiomType{DoubleFloat} equivalent of the second endpoint of the range \axiom{\spad{x}}
350957`\spad{getlo(u)} gets the \axiomType{DoubleFloat} equivalent of the first endpoint of the range \axiom{\spad{u}}
351062`\spad{getlo(u)} gets the \axiomType{DoubleFloat} equivalent of the first endpoint of the range \spad{u}
351162`\spad{getlo(x)} gets the \axiomType{DoubleFloat} equivalent of the first endpoint of the range \axiom{\spad{x}}
351254`\spad{goodPoint(p,{} q)} returns an integer a such that a is neither a pole of \spad{p(x,{}y)} nor a branch point of \spad{q(x,{}y) = 0}.
351321`\spad{goodnessOfFit(prob)} is a top level ANNA function to check to goodness of fit of a least squares model as defined within \axiom{\spad{prob}}. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}. It then calls the numerical routine 
351321`--\axiomType{E04YCF} to get estimates of the variance-covariance matrix of the regression coefficients of the least-squares problem. \blankline It thus returns both the results of the optimization and the variance-covariance calculation.
351421`\spad{goodnessOfFit(lf,{}start)} is a top level ANNA function to check to goodness of fit of a least squares model \spadignore{i.e.} the minimization of a set of functions,{} \axiom{\spad{lf}},{} of one or more variables without constraints. \blankline The parameter \axiom{\spad{start}} is a list of the initial guesses of the values of the variables. \blankline It iterates over the \axiom{domains}
351421`-- of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}. It then calls the numerical routine \axiomType{E04YCF} to get estimates of the variance-covariance matrix of the regression coefficients of the least-squares problem. \blankline It thus returns both the results of the optimization and the variance-covariance calculation. goodnessOfFit(\spad{lf},{}\spad{start}) is a top l
351421`--evel function to iterate over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}. It then checks the goodness of fit of the least squares model.
351528`\spad{goto(l)} creates a representation of a FORTRAN GOTO statement
351579`\spad{gradient(v,{}xlist)} computes the gradient,{} the vector of first partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in \spad{xlist}.
351668`\spad{graeffe p} determines \spad{q} such that \spad{q(-z**2) = p(z)*p(-z)}. Note that the roots of \spad{q} are the squares of the roots of \spad{p}.
351731`\spad{gramschmidt(lv)} converts the list of column vectors \spad{lv} into a set of orthogonal column vectors of euclidean length 1 using the Gram-Schmidt algorithm.
351848`\spad{graphCurves([[p0],{}[p1],{}...,{}[pn]])} creates a \spadtype{GraphImage} from the list of lists of points indicated by \spad{p0} through \spad{pn}.
351935`\spad{graphCurves([[p0],{}[p1],{}...,{}[pn]],{}[options])} creates a \spadtype{GraphImage} from the list of lists of points,{} \spad{p0} throught \spad{pn},{} using the options specified in the list \spad{options}.
352039`\spad{graphCurves([[p0],{}[p1],{}...,{}[pn]],{}ptColor,{}lineColor,{}ptSize,{}[options])} creates a \spadtype{GraphImage} from the list of lists of points,{} \spad{p0} throught \spad{pn},{} using the options specified in the list \spad{options}. The graph point color is specified by \spad{ptColor},{} the graph line color is specified by \spad{lineColor},{} and the size
352039`-- of the points is specified by \spad{ptSize}.
352175`\spad{graphImage()} returns an empty graph with 0 point lists of the domain \spadtype{GraphImage}. A graph image contains the graph data component of a two dimensional viewport.
352218`\spad{graphState(v,{}num,{}sX,{}sY,{}dX,{}dY,{}pts,{}lns,{}box,{}axes,{}axesC,{}un,{}unC,{}cP)} sets the state of the characteristics for the graph indicated by \spad{num} in the given two-dimensional viewport \spad{v},{} of domain \spadtype{TwoDimensionalViewport},{} to the values given as parameters. The scaling of 
352218`--the graph in the \spad{x} and \spad{y} component directions is set to be \spad{sX} and \spad{sY}; the window translation in the \spad{x} and \spad{y} component directions is set to be \spad{dX} and \spad{dY}; The graph points,{} lines,{} bounding \spad{box},{} \spad{axes},{} or units will be shown in the viewport if their given parameters \spad{pts},{} \spad{lns},{} \spad{box},{} \spad{axes} or \spad{un} are set to be \spad{1},{} but will not be shown if they are set to \spad{0}. The color of 
352218`--the \spad{axes} and the color of the units are indicated by the palette colors \spad{axesC} and \spad{unC} respectively. To display the control panel when the viewport window is displayed,{} set \spad{cP} to \spad{1},{} otherwise set it to \spad{0}.
352406`\spad{graphStates(v)} returns and shows a listing of a record containing the current state of the characteristics of each of the ten graph records in the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDi
352406`--mensionalViewport}.
352679`\spad{graphs(v)} returns a vector,{} or list,{} which is a union of all the graphs,{} of the domain \spadtype{GraphImage},{} which are allocated for the two-dimensional viewport,{} \spad{v},{} of domain \spadtype{TwoDimensionalViewport}. Those graphs which have no data are labeled "undefined",{} otherwise their contents are shown.
352767`\spad{graphs n} is the cycle index of the group induced on \indented{1}{the edges of a graph by applying the symmetric function to the} \indented{1}{\spad{n} nodes.}
352854`\spad{green()} returns the position of the green hue from total hues.
352887`\spad{groebSolve(lp,{}lv)} reduces the polynomial system \spad{lp} in variables \spad{lv} to triangular form. Algorithm based on groebner bases algorithm with linear algebra for change of ordering. Preprocessing for the general solver. The polynomials in input are of type \spadtype{DMP}.
353065`\spad{groebgen }\undocumented
353243`\spad{groebner?(I)} tests if the generators of the ideal \spad{I} are a Groebner basis.
353320`\spad{groebnerFactorize(listOfPolys)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\em listOfPolys}. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p},{} a new {\em c
353320`--reateGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}.
353435`\spad{groebnerFactorize(listOfPolys,{} info)} returns a list of groebner bases. The union of their solutions is the solution of the system of equations given by {\em listOfPolys}. At each stage the polynomial \spad{p} under consideration (either from the given basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p}
353435`--,{} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}. If {\em info} is \spad{true},{} information is printed about partial results.
353558`\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\em listOfPolys} under the restriction that the polynomials of {\em nonZeroRestrictions} don\spad{'t} vanish. At each stage the polynomial \spad{p} under consideration (either from the given basis or obta
353558`--ined from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p},{} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}.
353684`\spad{groebnerFactorize(listOfPolys,{} nonZeroRestrictions,{} info)} returns a list of groebner basis. The union of their solutions is the solution of the system of equations given by {\em listOfPolys} under the restriction that the polynomials of {\em nonZeroRestrictions} don\spad{'t} vanish. At each stage the polynomial \spad{p} under consideration (either from the giv
353684`--en basis or obtained from a reduction of the next \spad{S}-polynomial) is factorized. For each irreducible factors of \spad{p} a new {\em createGroebnerBasis} is started doing the usual updates with the factor in place of \spad{p}. If argument {\em info} is \spad{true},{} information is printed about partial results.
353818`\spad{groebnerIdeal(polyList)} constructs the ideal generated by the list of polynomials \spad{polyList} which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation.
353903`\axiom{groebner(\spad{lp})} returns the lexicographical Groebner basis of \axiom{\spad{lp}}. If \axiom{\spad{lp}} generates a zero-dimensional ideal then the {\em FGLM} strategy is used,{} otherwise the {\em Sugar} strategy is used.
354086`\axiom{groebner(\spad{lq1})} returns the lexicographical Groebner basis of \axiom{\spad{lq1}}. If \axiom{\spad{lq1}} generates a zero-dimensional ideal then the {\em FGLM} strategy is used,{} otherwise the {\em Sugar} strategy is used.
354175`\spad{groebner(lp)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}.
354262`\spad{groebner(I)} returns a set of generators of \spad{I} that are a Groebner basis for \spad{I}.
354333`\spad{groebner(lp,{} infoflag)} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp}. Argument infoflag is used to get information on the computation. If infoflag is "info",{} then summary information is displayed for each \spad{s}-polynomial generated. If infoflag is "redcrit",{} the reduced critical pairs are displayed. If infoflag is any other string,{} no informat
354333`--ion is printed during computation.
354427`\spad{groebner(lp,{} "info",{} "redcrit")} computes a groebner basis for a polynomial ideal generated by the list of polynomials \spad{lp},{} displaying both a summary of the critical pairs considered (\spad{"info"}) and the result of reducing each critical pair ("redcrit"). If the second or third arguments have any other string value,{} the indicated information is suppressed.
354640`\spad{ground?(p)} tests if polynomial \spad{p} is a member of the coefficient ring.
354705`\spad{ground?(f)} tests if \spad{f} is an element of \spad{R}.
354856`\spad{ground(p)} retracts polynomial \spad{p} to the coefficient ring.
354914`\spad{ground(f)} returns \spad{f} as an element of \spad{R}. An error occurs if \spad{f} is not an element of \spad{R}.
354960`\spad{hMonic }\undocumented
355041`\axiom{\spad{halfExtendedResultant1}(a,{}\spad{b})} returns \axiom{[\spad{r},{}ca]} such that \axiom{extendedResultant(a,{}\spad{b})} returns \axiom{[\spad{r},{}ca,{} \spad{cb}]}
355170`\axiom{\spad{halfExtendedResultant2}(a,{}\spad{b})} returns \axiom{[\spad{r},{}ca]} such that \axiom{extendedResultant(a,{}\spad{b})} returns \axiom{[\spad{r},{}ca,{} \spad{cb}]}
355299`\axiom{\spad{halfExtendedSubResultantGcd1}(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca]} such that \axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca,{} \spad{cb}]}
355429`\axiom{\spad{halfExtendedSubResultantGcd1}(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca]} if \axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca,{}\spad{cb}]} otherwise produces an error.
355561`\axiom{\spad{halfExtendedSubResultantGcd2}(a,{}\spad{b})} returns \axiom{[\spad{g},{}\spad{cb}]} such that \axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca,{} \spad{cb}]}
355691`\axiom{\spad{halfExtendedSubResultantGcd2}(a,{}\spad{b})} returns \axiom{[\spad{g},{}\spad{cb}]} if \axiom{extendedSubResultantGcd(a,{}\spad{b})} returns \axiom{[\spad{g},{}ca,{}\spad{cb}]} otherwise produces an error.
355823`\spad{harmonic(n)} returns the \spad{n}th harmonic number. This is \spad{H[n] = sum(1/k,{}k=1..n)}.
355904`\spad{has?(op,{} s)} tests if property \spad{s} is attached to \spad{op}.
355958`\spad{hasHi(s)} tests whether the segment \spad{s} has an upper bound.
356012`\spad{hasPredicate?(p)} tests if \spad{p} has predicates attached to it.
356065`\spad{hasSolution?(A,{}B)} tests if the linear system \spad{AX = B} has a solution.
356148`\spad{hasSolution?(A,{}B)} tests if the linear system \spad{AX = B} has a solution.
356236`\spad{hasTopPredicate?(p)} tests if \spad{p} has a top-level predicate.
356341`\spad{hash(x)} provides a hashing function for strings
356392`\spad{hash(x)} returns the hash key for \spad{x}
356437`\spad{hash(s)} calculates a hash code for \spad{s}.
356488`\spad{hash(n)} returns the hash code of \spad{n}.
356536`\spad{hasoln(g,{} l)} tests whether the quasi-algebraic set defined by \spad{p} = 0 for \spad{p} in \spad{g} and \spad{q} \spad{^=} 0 for \spad{q} in \spad{l} is empty or not and returns a simplified definition of the quasi-algebraic set
356666`\spad{hclf(x,{} y)} returns the highest common left factor of \spad{x} and \spad{y},{} \spadignore{i.e.} the largest \spad{d} such that \spad{x = d a} and \spad{y = d b}.
356711`\spad{hclf(x,{} y)} returns the highest common left factor of \spad{x} and \spad{y},{} that is the largest \spad{d} such that \spad{x = d a} and \spad{y = d b}.
356763`\spad{hconcat(u)} horizontally concatenates all forms in list \spad{u}.
356811`\spad{hconcat(f,{}g)} horizontally concatenate forms \spad{f} and \spad{g}.
356856`\spad{hcrf(x,{} y)} returns the highest common right factor of \spad{x} and \spad{y},{} \spadignore{i.e.} the largest \spad{d} such that \spad{x = a d} and \spad{y = b d}.
356901`\spad{hcrf(x,{} y)} returns the highest common right factor of \spad{x} and \spad{y},{} that is the largest \spad{d} such that \spad{x = a d} and \spad{y = b d}.
356953`\spad{hdmpToDmp(p)} converts \spad{p} from a \spadtype{HDMP} to a \spadtype{DMP}.
357086`\spad{hdmpToP(p)} converts \spad{p} from a \spadtype{HDMP} to a \spadtype{POLY}.
357321`\axiom{headReduce(\spad{p},{}\spad{ts})} returns a polynomial \axiom{\spad{r}} such that \axiom{headReduce?(\spad{r},{}\spad{ts})} holds and there exists some product \axiom{\spad{h}} of \axiom{initials(\spad{ts})} such that \axiom{\spad{h*p} - \spad{r}} lies in the ideal generated by \axiom{\spad{ts}}.
357387`\axiom{headReduce(a,{}\spad{b})} returns a polynomial \axiom{\spad{r}} such that \axiom{headReduced?(\spad{r},{}\spad{b})} holds and there exists an integer \axiom{\spad{e}} such that \axiom{init(\spad{b})^e a - \spad{r}} is zero modulo \axiom{\spad{b}}.
357528`\spad{headReduced?(ts)} returns \spad{true} iff the head of every element of \axiom{\spad{ts}} is reduced \spad{w}.\spad{r}.\spad{t} to any other element of \axiom{\spad{ts}}.
357827`\axiom{headReduced?(\spad{p},{}\spad{ts})} returns \spad{true} iff the head of \axiom{\spad{p}} is reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ts}}.
357901`\axiom{headReduced?(\spad{q},{}\spad{lp})} returns \spad{true} iff \axiom{headReduced?(\spad{q},{}\spad{p})} holds for every \axiom{\spad{p}} in \axiom{\spad{lp}}.
357986`\axiom{headReduced?(a,{}\spad{b})} returns \spad{true} iff \axiom{degree(head(a),{}mvar(\spad{b})) < mdeg(\spad{b})}.
358154`\axiom{headRemainder(a,{}\spad{ps})} returns \axiom{[\spad{b},{}\spad{r}]} such that the leading monomial of \axiom{\spad{b}} is reduced in the sense of Groebner bases \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ps}} and \axiom{r*a - \spad{b}} lies in the ideal generated by \axiom{\spad{ps}}.
358326`\spad{head(l)} returns the first element of a doubly-linked aggregate \spad{l}. Error: if \spad{l} is empty.
358379`\axiom{head(\spad{p})} returns \axiom{\spad{p}} if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns its leading term (monomial in the AXIOM sense),{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
358442`\spad{heapSort(f,{} agg)} sorts the aggregate agg with the ordering function \spad{f} using the heapsort algorithm.
358518`\spad{heap(ls)} creates a heap of elements consisting of the elements of \spad{ls}.
358559`\spad{height()} returns the height of the display area (an integer).
358663`\spad{height(p)} returns the maximal absolute value of the coefficients of the polynomial \spad{p}.
358734`\spad{height(f)} returns the height of form \spad{f} (an integer).
358780`\spad{height(k)} returns the nesting level of \spad{k}.
358836`\spad{height(d)} returns the number of elements in dequeue \spad{d}. Note: \axiom{height(\spad{d}) = \# \spad{d}}.
358902`\spad{height(f)} returns the highest nesting level appearing in \spad{f}. Constants have height 0. Symbols have height 1. For any operator op and expressions \spad{f1},{}...,{}\spad{fn},{} \spad{op(f1,{}...,{}fn)} has height equal to \spad{1 + max(height(f1),{}...,{}height(fn))}.
358964`\spad{henselFact(p,{}sqf)} returns the factorization of \spad{p},{} the result is a Record such that \spad{contp=}content \spad{p},{} \spad{factors=}List of irreducible factors of \spad{p} with exponent. If \spad{sqf=true} the polynomial is assumed to be square free (\spadignore{i.e.} without repeated factors).
359092`\spad{henselFact(m,{}flag)} returns the factorization of \spad{m},{} FinalFact is a Record \spad{s}.\spad{t}. FinalFact.contp=content \spad{m},{} FinalFact.factors=List of irreducible factors of \spad{m} with exponent ,{} if \spad{flag} =true the polynomial is assumed square free.
359218`\spad{hermiteH(n,{}x)} is the \spad{n}-th Hermite polynomial,{} \spad{H[n](x)}. These are defined by \spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!,{} n = 0..)}.
359300`\spad{hermite(n)} returns the \spad{n}th Hermite polynomial \spad{H[n](x)}. Note: Hermite polynomials,{} denoted \spad{H[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!,{} n=0..infinity)}.
359401`\spad{hermite(m)} returns the Hermite normal form of the matrix \spad{m}.
359459`\spad{hessian(v,{}xlist)} computes the hessian,{} the matrix of second partial derivatives,{} of the scalar field \spad{v},{} \spad{v} a function of the variables listed in \spad{xlist}.
359547`\spad{hexDigit?(c)} tests if \spad{c} is a hexadecimal numeral,{} \spadignore{i.e.} one of 0..9,{} a..\spad{f} or A..\spad{F}.
359595`\spad{hexDigit()} returns the class of all characters for which \spadfunFrom{hexDigit?}{Character} is \spad{true}.
359640`\spad{hex(r)} converts a rational number to a hexadecimal expansion.
359703`\spad{\spad{hi}(s)} returns the second endpoint of \spad{s}. Note: \spad{\spad{hi}(l..h) = h}.
359747`\spad{highCommonTerms(e1 a1 + ... + en an,{} f1 b1 + ... + fm bm)} returns \indented{2}{\spad{reduce(+,{}[max(\spad{ei},{} \spad{fi}) \spad{ci}])}} where \spad{ci} ranges in the intersection of \spad{{a1,{}...,{}an}} and \spad{{b1,{}...,{}bm}}.
359847`\spad{high(s)} returns the second endpoint of \spad{s}. Note: \spad{high(l..h) = h}.
359893`\spad{hitherPlane(v,{}h)} sets the hither clipping plane of the graph to \spad{h},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
359961`\spad{homogeneous?(p)} tests if all of the terms of \spad{p} have the same degree.
360019`\spad{homogeneous?(df)} tests if all of the terms of differential form \spad{df} have the same degree.
360154`\spad{horizConcat(x,{}y)} horizontally concatenates two matrices with an equal number of rows. The entries of \spad{y} appear to the right of the entries of \spad{x}. Error: if the matrices do not have the same number of rows.
360218`\spad{hspace(n)} creates white space of width \spad{n}.
360264`\spad{htrigs(f)} converts all the exponentials in \spad{f} into hyperbolic sines and cosines.
360325`\spad{hue(pt)} returns the third element of the two dimensional point,{} \spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} hue to express a third dimension.
360373`\spad{hue(p)} returns the hue field of the indicated palette \spad{p}.
360411`\spad{hue(c)} returns the hue index of the indicated color \spad{c}.
360449`\spad{hyperelliptic()} returns \spad{p(x)} if the curve is the hyperelliptic defined by \spad{y**2 = p(x)},{} "failed" otherwise.
360536`\spad{hyperelliptic()} returns \spad{p(x)} if the curve is the hyperelliptic defined by \spad{y**2 = p(x)},{} "failed" otherwise.
360620`\spad{hypergeometric0F1(c,{}z)} is the hypergeometric function \spad{0F1(; c; z)}.
360746`\spad{hypergeometric0F1(c,{}z)} is the hypergeometric function \spad{0F1(; c; z)}.
360845`\spad{iCompose(f,{}g)} returns \spad{f(g(x))}. This is an internal function which should only be called for Taylor series \spad{f(x)} and \spad{g(x)} such that the constant coefficient of \spad{g(x)} is zero.
360919`\spad{iExquo(f,{}g,{}taylor?)} is the quotient of the power series \spad{f} and \spad{g}. If \spad{taylor?} is \spad{true},{} then we must have \spad{order(f) >= order(g)}.
361015`\spad{iFTable(l)} creates an intensity-functions table from the elements of \spad{l}.
361381`\spad{id x} is \spad{x}.
361424`\spad{idealSimplify(s)} returns a different and presumably simpler representation of \spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using Buchberger\spad{'s} algorithm.
361498`\spad{ideal([f1,{}...,{}fn])} returns the ideal \spad{(f1,{}...,{}fn)}.
361560`\spad{ideal(polyList)} constructs the ideal generated by the list of polynomials \spad{polyList}.
361637`\spad{ideal(D)} returns the ideal corresponding to a divisor \spad{D}.
361738`\spad{idealiserMatrix(m1,{} m2)} returns the matrix representing the linear conditions on the Ring associatied with an ideal defined by \spad{m1} and \spad{m2}.
361828`\spad{idealiser(m1,{}m2)} computes the order of an ideal defined by \spad{m1} and \spad{m2}
361912`\spad{idealiser(m1,{}m2,{}d)} computes the order of an ideal defined by \spad{m1} and \spad{m2} where \spad{d} is the known part of the denominator
361998`\axiom{identification(\spad{g},{}\spad{h})} returns the list of equations \axiom{g_i = h_i},{} where \axiom{g_i} (resp. \axiom{h_i}) are exponential coordinates of \axiom{\spad{g}} (resp. \axiom{\spad{h}}).
362086`\spad{identityMatrix(n)} create an identity matrix we note that this must be square
362177`\spad{identitySquareMatrix(s,{}p)} \undocumented{}
362274`\spad{iflist2Result(m)} converts a attributes record into a \axiomType{Result}
362432`\spad{ignore?(s)} is \spad{true} if \spad{s} is the string that tells the integrator to assume that the function has no pole in the integration interval.
362502`\spad{iiGamma(x)} should be local but conditional.
362562`\spad{iiabs(x)} should be local but conditional.
362620`\spad{iiacos(x)} should be local but conditional
362672`\spad{iiacosh(x)} should be local but conditional
362725`\spad{iiacot(x)} should be local but conditional
362777`\spad{iiacoth(x)} should be local but conditional
362830`\spad{iiacsc(x)} should be local but conditional
362882`\spad{iiacsch(x)} should be local but conditional
362935`\spad{iiasec(x)} should be local but conditional
362987`\spad{iiasech(x)} should be local but conditional
363040`\spad{iiasin(x)} should be local but conditional
363092`\spad{iiasinh(x)} should be local but conditional
363145`\spad{iiatan(x)} should be local but conditional
363197`\spad{iiatanh(x)} should be local but conditional
363250`\spad{iibinom(l)} should be local but conditional.
363312`\spad{iicos(x)} should be local but conditional
363363`\spad{iicosh(x)} should be local but conditional
363415`\spad{iicot(x)} should be local but conditional
363466`\spad{iicoth(x)} should be local but conditional
363518`\spad{iicsc(x)} should be local but conditional
363569`\spad{iicsch(x)} should be local but conditional
363621`\spad{iidprod(l)} should be local but conditional.
363683`\spad{iidsum(l)} should be local but conditional.
363744`\spad{iiexp(x)} should be local but conditional
363795`\spad{iifact(x)} should be local but conditional.
363850`\spad{iilog(x)} should be local but conditional
363901`\spad{iiperm(l)} should be local but conditional.
363962`\spad{iipow(l)} should be local but conditional.
364022`\spad{iisec(x)} should be local but conditional
364073`\spad{iisech(x)} should be local but conditional
364125`\spad{iisin(x)} should be local but conditional
364176`\spad{iisinh(x)} should be local but conditional
364228`\spad{iisqrt2()} should be local but conditional
364280`\spad{iisqrt3()} should be local but conditional
364332`\spad{iitan(x)} should be local but conditional
364383`\spad{iitanh(x)} should be local but conditional
364435`\spad{imagE(o)} extracts the imaginary \spad{E} part of octonion \spad{o}.
364483`\spad{imagI(o)} extracts the imaginary \spad{I} part of octonion \spad{o}.
364531`\spad{imagI(q)} extracts the imaginary \spad{i} part of quaternion \spad{q}.
364581`\spad{imagJ(o)} extracts the imaginary \spad{J} part of octonion \spad{o}.
364629`\spad{imagJ(q)} extracts the imaginary \spad{j} part of quaternion \spad{q}.
364679`\spad{imagK(o)} extracts the imaginary \spad{K} part of octonion \spad{o}.
364727`\spad{imagK(q)} extracts the imaginary \spad{k} part of quaternion \spad{q}.
364777`\spad{imag(f)} returns the imaginary part of \spad{f} where \spad{f} is a complex function.
364854`\spad{imag(f)} returns the imaginary part of \spad{f} where \spad{f} is a complex function.
364912`\spad{imag(x)} returns imaginary part of \spad{x}.
364958`\spad{imagi(o)} extracts the \spad{i} part of octonion \spad{o}.
365053`\spad{imaginary()} = sqrt(\spad{-1}) = \%\spad{i}.
365103`\spad{imagj(o)} extracts the \spad{j} part of octonion \spad{o}.
365151`\spad{imagk(o)} extracts the \spad{k} part of octonion \spad{o}.
365199`\spad{implies(a,{}b)} returns the logical implication of Boolean \spad{a} and \spad{b}.
365241`\spad{in?(p)} tests whether point \spad{p} is internal to the range [\spad{A..B}]
365318`\spad{in?(p,{}range)} tests whether point \spad{p} is internal to the \spad{range} \spad{range}
365424`\spad{in?(I,{}J)} tests if the ideal \spad{I} is contained in the ideal \spad{J}.
365498`\spad{inGroundField?(a)} tests whether an element \spad{a} is already in the ground field \spad{F}.
365559`\spad{inHallBasis?(numberOfGens,{} leftCandidate,{} rightCandidate,{} left)} tests to see if a new element should be added to the \spad{P}. Hall basis being constructed. The list \spad{[leftCandidate,{}wt,{}rightCandidate]} is included in the basis if in the unique factorization of \spad{rightCandidate},{} we have left factor leftOfRight,{} and leftOfRight \spad{<=} \spad{leftCandidate}
365639`\spad{inR?(p)} tests if \spad{p} is an atom (\spadignore{i.e.} an element of \spad{R}).
365683`\spad{inRadical?(f,{}I)} tests if some power of the polynomial \spad{f} belongs to the ideal \spad{I}.
365767`\spad{inc(x)} returns \spad{x + 1}.
365814`\spad{incr(s)} returns \spad{n},{} where \spad{s} is a segment in which every \spad{n}\spad{-}th element is used. Note: \spad{incr(l..h by n) = n}.
365866`\spad{increasePrecision(n)} increases the current \spadfunFrom{precision}{FloatingPointSystem} by \spad{n} decimal digits.
365982`\axiom{increase(attributeName)} increases the value for the effect of the attribute \axiom{attributeName} with all routines. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
366038`\axiom{increase(routineName,{}attributeName)} increases the value for the effect of the attribute \axiom{attributeName} with routine \axiom{routineName}. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
366101`\spad{incrementBy(n)} produces a function which adds \spad{n} to whatever argument it is given. For example,{} if {\spad{f} \spad{:=} increment(\spad{n})} then \spad{f x} is \spad{x+n}.
366159`\spad{incrementKthElement(S,{}k)} increments the \spad{k^}{th} element of \spad{S},{} and returns "failed" if the result is not a set of \spad{M} integers in \spad{1..n} any more.
366262`\spad{increment()} produces a function which adds \spad{1} to whatever argument it is given. For example,{} if {\spad{f} \spad{:=} increment()} then \spad{f x} is \spad{x+1}.
366501`\spad{index?(i,{}u)} tests if \spad{i} is an index of aggregate \spad{u}.
366633`\spad{index(x)} \undocumented
366686`\spad{index(i)} takes a positive integer \spad{i} less than or equal to \spad{size()} and returns the \spad{i}\spad{-}th element of the set. This operation establishs a bijection between the elements of the finite set and \spad{1..size()}.
366735`\spad{index(n,{}m)} is a index function for vectors of length \spad{n} over the ground field.
366836`\axiom{indiceSubResultant(\spad{P},{} \spad{Q},{} \spad{i})} returns the subresultant \axiom{S_i(\spad{P},{}\spad{Q})} and carries out the equality \axiom{coef1*P + coef2*Q = S_i(\spad{P},{}\spad{Q})}
366990`\axiom{indiceSubResultant(\spad{P},{} \spad{Q},{} \spad{i})} returns the subresultant of indice \axiom{\spad{i}}
367273`\spad{indices(u)} returns a list of indices of aggregate \spad{u} in no particular order.
367343`\spad{indicialEquationAtInfinity op} returns the indicial equation of \spad{op} at infinity.
367459`\spad{indicialEquationAtInfinity op} returns the indicial equation of \spad{op} at infinity.
367578`\spad{indicialEquation(op,{} a)} returns the indicial equation of \spad{op} at \spad{a}.
367645`\spad{indicialEquation(op,{} a)} returns the indicial equation of \spad{op} at \spad{a}.
367713`\spad{indicialEquations op} returns \spad{[[d1,{}e1],{}...,{}[dq,{}eq]]} where the \spad{d_i}\spad{'s} are the affine singularities of \spad{op},{} and the \spad{e_i}\spad{'s} are the indicial equations at each \spad{d_i}.
367812`\spad{indicialEquations op} returns \spad{[[d1,{}e1],{}...,{}[dq,{}eq]]} where the \spad{d_i}\spad{'s} are the affine singularities of \spad{op},{} and the \spad{e_i}\spad{'s} are the indicial equations at each \spad{d_i}.
367912`\spad{indicialEquations(op,{} p)} returns \spad{[[d1,{}e1],{}...,{}[dq,{}eq]]} where the \spad{d_i}\spad{'s} are the affine singularities of \spad{op} above the roots of \spad{p},{} and the \spad{e_i}\spad{'s} are the indicial equations at each \spad{d_i}.
368014`\spad{indicialEquations(op,{} p)} returns \spad{[[d1,{}e1],{}...,{}[dq,{}eq]]} where the \spad{d_i}\spad{'s} are the affine singularities of \spad{op} above the roots of \spad{p},{} and the \spad{e_i}\spad{'s} are the indicial equations at each \spad{d_i}.
368117`\axiom{infLex?(\spad{n1},{}\spad{n2},{}\spad{o1},{}\spad{o2})} returns \spad{true} iff \axiom{\spad{o1}(value(\spad{n1}),{}value(\spad{n2}))} or \axiom{value(\spad{n1}) = value(\spad{n2})} and \axiom{\spad{o2}(condition(\spad{n1}),{}condition(\spad{n2}))}.
368347`\axiom{infRittWu?(\spad{lp1},{}\spad{lp2})} is an internal subroutine,{} exported only for developement.
368433`\axiom{infRittWu?(\spad{lp1},{}\spad{lp2})} is an internal subroutine,{} exported only for developement.
368529`\axiom{infRittWu?(a,{}\spad{b})} returns \spad{true} if \axiom{a} is less than \axiom{\spad{b}} \spad{w}.\spad{r}.\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.
368606`\axiom{infRittWu?(\spad{ts1},{}\spad{ts2})} returns \spad{true} iff \axiom{\spad{ts2}} has higher rank than \axiom{\spad{ts1}} in Wu Wen Tsun sense.
368679`\spad{inf(u)} returns the infinum of \axiom{\spad{u}}.
368725`\spad{infieldIntegrate(f,{} x)} returns a fraction \spad{g} such that \spad{dg/dx = f} if \spad{g} exists,{} "failed" otherwise.
368861`\spad{infieldint(f)} returns \spad{g} such that \spad{g' = f} or "failed" if the integral of \spad{f} is not a rational function.
368957`\spad{infinite?(x)} tests if \spad{x} is infinite.
369017`\spad{infinite?(x)} tests if \spad{x} is +infinity or -infinity,{}
369076`\spad{infiniteProduct(f(x))} computes \spad{product(n=1,{}2,{}3...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
369163`\spad{infiniteProduct(f(x))} computes \spad{product(n=1,{}2,{}3...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
369248`\spad{infiniteProduct(f(x))} computes \spad{product(n=1,{}2,{}3...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
369331`\spad{infiniteProduct(f(x))} computes \spad{product(n=1,{}2,{}3...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
369408`\spad{infinityNorm(f)} returns the maximal absolute value of the coefficients of the polynomial \spad{f}.
369485`\spad{infinity()} returns infinity.
369549`\spad{infinity()} returns infinity.
369601`\spad{infix?(op)} returns \spad{true} if \spad{op} is an infix operator,{} and \spad{false} otherwise.
369647`\spad{infix(f,{}l)} creates a form depicting the \spad{n}-ary application of infix operation \spad{f} to a tuple of arguments \spad{l}.
369696`\spad{infix(op,{} a,{} b)} creates a form which prints as: a \spad{op} \spad{b}.
369742`\axiom{initTable!()} initializes the hash-table.
370006`\spad{init()} chooses an initial object for stepping.
370103`\axiom{init(\spad{p})} returns an error if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns its leading coefficient,{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
370233`\spad{initial(p)} returns the leading coefficient when the differential polynomial \spad{p} is written as a univariate polynomial in its leader.
370304`\spad{initializeGroupForWordProblem(gp)} initializes the group {\em gp} for the word problem. Notes: it calls the other function of this name with parameters 0 and 1: {\em initializeGroupForWordProblem(gp,{}0,{}1)}. Notes: (1) be careful: invoking this routine will destroy the possibly information about your group (but will recompute it again) (2) users need not call this function normally for the soultion of the word problem.
370379`\spad{initializeGroupForWordProblem(gp,{}m,{}n)} initializes the group {\em gp} for the word problem. Notes: (1) with a small integer you get shorter words,{} but the routine takes longer than the standard routine for longer words. (2) be careful: invoking this routine will destroy the possibly stored information about your group (but will recompute it again). (3) users need not call this function normally for th
370379`--e soultion of the word problem.
370610`\axiom{initiallyReduce(\spad{p},{}\spad{ts})} returns a polynomial \axiom{\spad{r}} such that \axiom{initiallyReduced?(\spad{r},{}\spad{ts})} holds and there exists some product \axiom{\spad{h}} of \axiom{initials(\spad{ts})} such that \axiom{\spad{h*p} - \spad{r}} lies in the ideal generated by \axiom{\spad{ts}}.
370681`\axiom{initiallyReduce(a,{}\spad{b})} returns a polynomial \axiom{\spad{r}} such that \axiom{initiallyReduced?(\spad{r},{}\spad{b})} holds and there exists an integer \axiom{\spad{e}} such that \axiom{init(\spad{b})^e a - \spad{r}} is zero modulo \axiom{\spad{b}}.
370832`\spad{initiallyReduced?(ts)} returns \spad{true} iff for every element \axiom{\spad{p}} of \axiom{\spad{ts}} \axiom{\spad{p}} and all its iterated initials are reduced \spad{w}.\spad{r}.\spad{t}. to the other elements of \axiom{\spad{ts}} with the same main variable.
371151`\axiom{initiallyReduced?(\spad{p},{}\spad{ts})} returns \spad{true} iff \axiom{\spad{p}} and all its iterated initials are reduced \spad{w}.\spad{r}.\spad{t}. to the elements of \axiom{\spad{ts}} with the same main variable.
371230`\axiom{initiallyReduced?(\spad{q},{}\spad{lp})} returns \spad{true} iff \axiom{initiallyReduced?(\spad{q},{}\spad{p})} holds for every \axiom{\spad{p}} in \axiom{\spad{lp}}.
371320`\axiom{initiallyReduced?(a,{}\spad{b})} returns \spad{false} iff there exists an iterated initial of \axiom{a} which is not reduced \spad{w}.\spad{r}.\spad{t} \axiom{\spad{b}}.
371469`\axiom{initials(\spad{ts})} returns the list of the non-constant initials of the members of \axiom{\spad{ts}}.
371537`\spad{innerEigenvectors(m,{}eps,{}factor)} computes explicitly the eigenvalues and the correspondent eigenvectors of the matrix \spad{m}. The parameter \spad{eps} determines the type of the output,{} \spad{factor} is the univariate factorizer to \spad{br} used to reduce the characteristi
371537`--c polynomial into irreducible factors.
371756`\spad{innerSolve1(p,{}eps)} returns the list of the zeros of the polynomial \spad{p} with precision \spad{eps}.
371850`\spad{innerSolve1(up,{}eps)} returns the list of the zeros of the univariate polynomial \spad{up} with precision \spad{eps}.
371960`\spad{innerSolve(lnum,{}lden,{}lvar,{}eps)} returns a list of solutions of the system of polynomials \spad{lnum},{} with the side condition that none of the members of \spad{lden} vanish identically on any solution. Each solution is expressed as a list corresponding to the list of variables in \spad{lvar} and with precision specified by \spad{eps}.
372098`\spad{innerint(f,{} x,{} a,{} b,{} ignore?)} should be local but conditional
372322`\spad{input(op)} returns the "\%input" property of \spad{op} if it has one attached,{} "failed" otherwise.
372407`\spad{input(op,{} foo)} attaches foo as the "\%input" property of \spad{op}. If \spad{op} has a "\%input" property \spad{f},{} then \spad{op(a1,{}...,{}an)} gets converted to InputForm as \spad{f(a1,{}...,{}an)}.
372479`\spad{inrootof(p,{} x)} should be a non-exported function.
372562`\spad{insert!(r)} inserts an entry \spad{r} into theIFTable
373414`\spad{insert!(r)} inserts an entry \spad{r} into theIFTable
373774`\axiom{insert!(\spad{x},{}\spad{y})} stores the item whose key is \axiom{\spad{x}} and whose entry is \axiom{\spad{y}}.
373934`\spad{insert!(x,{}u)} inserts item \spad{x} into bag \spad{u}.
373983`\spad{insert!(x,{}b)} inserts element \spad{x} as leaves into binary search tree \spad{b}.
374036`\spad{insert!(x,{}b)} inserts element \spad{x} as leaves into binary tournament \spad{b}.
374197`\spad{insert!(x,{}u,{}i)} destructively inserts \spad{x} into \spad{u} at position \spad{i}.
374267`\spad{insert!(x,{}d,{}n)} destructively inserts \spad{n} copies of \spad{x} into dictionary \spad{d}.
374338`\spad{insert!(v,{}u,{}i)} destructively inserts aggregate \spad{v} into \spad{u} at position \spad{i}.
374409`\spad{insertBottom!(x,{}d)} destructively inserts \spad{x} into the dequeue \spad{d} at the bottom (back) of the dequeue.
374467`\spad{insertMatch(var,{} expr,{} r)} adds the match (\spad{var},{} \spad{expr}) in \spad{r},{} without checking predicates or previous matches for \spad{var}.
374539`\spad{insertRoot!(x,{}b)} inserts element \spad{x} as a root of binary search tree \spad{b}.
374596`\spad{insertTop!(x,{}d)} destructively inserts \spad{x} into the dequeue \spad{d},{} that is,{} at the top (front) of the dequeue. The element previously at the top of the dequeue becomes the second in the dequeue,{} and so on.
375145`\spad{insert(x,{}u,{}i)} returns a copy of \spad{u} having \spad{x} as its \axiom{\spad{i}}th element. Note: \axiom{insert(\spad{x},{}a,{}\spad{k}) = concat(concat(a(0..\spad{k}-1),{}\spad{x}),{}a(\spad{k}..))}.
375204`\spad{insert(v,{}u,{}k)} returns a copy of \spad{u} having \spad{v} inserted beginning at the \axiom{\spad{i}}th element. Note: \axiom{insert(\spad{v},{}\spad{u},{}\spad{k}) = concat( \spad{u}(0..\spad{k}-1),{} \spad{v},{} \spad{u}(\spad{k}..) )}.
375264`\spad{insertionSort! }\undocumented
375334`\spad{insertionSort!(a,{}f)} \undocumented
375481`\spad{inspect(u)} returns an (random) element from a bag.
375527`\spad{intChoose should} be local
375778`\spad{intPatternMatch(f,{} x,{} int,{} pmint)} tries to integrate \spad{f} first by using the integration function \spad{int},{} and then by
375778`-- using the pattern match intetgration function \spad{pmint} on any remaining unintegrable part.
376145`\spad{int(r)} returns [\spad{r},{}\spad{r+1},{}\spad{r+2},{}...],{} where \spad{r} is a ring element.
376210`\spad{int(expr)} creates the form prefixing \spad{expr} with an integral sign.
376248`\spad{int(f,{} x)} returns the integral of \spad{f} with respect to \spad{x}.
376300`\spad{int(expr,{}lowerlimit)} creates the form prefixing \spad{expr} by an integral sign with a \spad{lowerlimit}.
376341`\spad{int(expr,{}lowerlimit,{}upperlimit)} creates the form prefixing \spad{expr} by an integral sign with both a \spad{lowerlimit} and \spad{upperlimit}.
376385`\spad{intcompBasis }\undocumented
376635`\spad{integer?(x)} is \spad{true} if \spad{x} is an integer,{} \spad{false} otherwise.
376693`\spad{integer?(s)} is \spad{true} if \spad{s} is an atom and belong to Int.
376772`\spad{integer?(t)} tests whether \spad{t} is equivalent to the FORTRAN type INTEGER.
376827`\spad{integerBound(p)} returns a lower bound on the negative integer roots of \spad{p},{} and 0 if \spad{p} has no negative integer roots.
376892`\spad{integerIfCan(x)} returns \spad{x} as an integer,{} "failed" if \spad{x} is not an integer.
376970`\spad{integer(x)} returns \spad{x} as an integer; error if \spad{x} is not an integer.
377027`\spad{integer(s)} returns \spad{s} as an element of Int. Error: if \spad{s} is not an atom that also belongs to Int.
377101`\spad{integers(n)} returns \spad{[n,{}n+1,{}n+2,{}...]}.
377251`\spad{integral?()} tests if \spad{f} is integral over \spad{k[x]}.
377463`\spad{integral?(f,{} a)} tests whether \spad{f} is locally integral at \spad{x = a}.
377536`\spad{integral?(f,{} p)} tests whether \spad{f} is locally integral at \spad{p(x) = 0}.
377688`\spad{integralAtInfinity?()} tests if \spad{f} is locally integral at infinity.
377769`\spad{integralBasisAtInfinity()} returns the local integral basis at infinity.
377855`\spad{integralBasis()} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the integral closure of \spad{Z} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{Z}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of th
377855`--e integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
377990`\spad{integralBasis()} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the integral closure of \spad{R} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integral bas
377990`--is is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
378111`\spad{integralBasis()} returns a record \spad{[basis,{}basisDen,{}basisInv] } containing information regarding the integral closure of \spad{R} in the quotient field of the framed algebra \spad{F}. \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If 'basis' is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element o
378111`--f the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of 'basis' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix 'basisInv' contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if 'basisInv' is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
378243`\spad{integralBasis()} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the integral closure of \spad{R} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \spad{i}th element of the integr
378243`--al basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
378370`\spad{integralBasis()} returns the integral basis for the curve.
378446`\spad{integralCoordinates(f)} returns \spad{[[A1,{}...,{}An],{} D]} such that \spad{f = (A1 w1 +...+ An wn) / D} where \spad{(w1,{}...,{}wn)} is the integral basis returned by \spad{integralBasis()}.
378549`\spad{integralDerivationMatrix(d)} extends the derivation \spad{d} from UP to \$ and returns (\spad{M},{} \spad{Q}) such that the i^th row of \spad{M} divided by \spad{Q} form the coordinates of \spad{d(\spad{wi})} with respect to \spad{(w1,{}...,{}wn)} where \spad{(w1,{}...,{}wn)} is the integral basis returned by integralBasis().
378663`\axiom{integralLastSubResultant(\spad{p1},{}\spad{p2},{}\spad{ts})} is an internal subroutine,{} exported only for developement.
378784`\spad{integralMatrixAtInfinity()} returns \spad{M} such that \spad{(v1,{}...,{}vn) = M (1,{} y,{} ...,{} y**(n-1))} where \spad{(v1,{}...,{}vn)} is the local integral basis at infinity returned by \spad{infIntBasis()}.
378881`\spad{integralMatrix()} returns \spad{M} such that \spad{(w1,{}...,{}wn) = M (1,{} y,{} ...,{} y**(n-1))},{} where \spad{(w1,{}...,{}wn)} is the integral basis of \spadfunFrom{integralBasis}{FunctionFieldCategory}.
378968`\spad{integralRepresents([A1,{}...,{}An],{} D)} returns \spad{(A1 w1+...+An wn)/D} where \spad{(w1,{}...,{}wn)} is the integral basis of \spad{integralBasis()}.
379054`\spad{integral(f,{}x)} returns the formal integral of \spad{f} with respect to \spad{x}
379108`\spad{integral(f,{}x = a..b)} denotes the definite integral of \spad{f} with respect to \spad{x} from \spad{a} to \spad{b}.
379181`\spad{integral(f,{}x)} indefinite integral of \spad{f} with respect to \spad{x}.
379243`\spad{integral(f,{}x)} returns the formal integral of \spad{f} with respect to \spad{x}
379330`\spad{integral(f,{} x = a..b)} returns the formal definite integral of \spad{f} \spad{dx} for \spad{x} between \spad{a} and \spad{b}.
379407`\spad{integral(f,{} x)} returns the formal integral of \spad{f} \spad{dx}.
379472`\spad{integrate(f)} returns \spad{g} such that \spad{g' = f}.
379631`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. Warning: function does not check for a term of degree \spad{-1}.
379739`\spad{integrate(IntegrationProblem)} is a top level ANNA function to integrate an expression over a given range or ranges to the required absolute and relative accuracy. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have
379739`-- the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.
379833`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers.
379940`\spad{integrate(p)} integrates the univariate polynomial \spad{p} with respect to its distinguished variable.
380038`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 1. We may integrate a series when we can divide coefficients by rational numbers.
380145`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380251`\spad{integrate(r,{}a)} returns the integral of the power series \spad{a} with respect to the power series variableintegration where \spad{r} denotes the constant of integration. Thus \spad{integrate(a,{}[a0,{}a1,{}a2,{}...]) = [a,{}a0,{}a1/2,{}a2/3,{}...]}.
380365`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380492`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380619`\spad{integrate(f(x),{}x)} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380745`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380866`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
380987`\spad{integrate(f(x),{}x)} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
381107`\spad{integrate(exp,{} [a..b,{}c..d,{}...])} is a top level ANNA function to integrate a multivariate expression,{} {\spad{\tt} \spad{exp}},{} over a given set of ranges. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most approp
381107`--riate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}. \blankline Default values for the absolute and relative error are used.
381231`\spad{integrate(exp,{} a..b)} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range {\spad{\tt} a} to {\spad{\tt} \spad{b}}. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropr
381231`--iate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}. \blankline Default values for the absolute and relative error are used.
381349`\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.
381554`\spad{integrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a real variable.
381637`\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.
381896`\spad{integrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b}. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b}.
382165`\spad{integrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a real variable..
382322`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
382570`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
382788`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
383036`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
383254`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
383501`\spad{integrate(f(x),{}y)} returns an anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{y}.
383718`\spad{integrate(p,{}x)} computes the integral of \spad{p*dx},{} \spadignore{i.e.} integrates the polynomial \spad{p} with respect to the variable \spad{x}.
383805`\spad{integrate(f,{}x)} returns the anti-derivative of the power series \spad{f(x)} with respect to the variable \spad{x} with constant coefficient 1. We may integrate a series when we can divide coefficients by integers.
383921`\spad{integrate(f(x))} returns an anti-derivative of the power series \spad{f(x)} with constant coefficient 0. We may integrate a series when we can divide coefficients by integers.
384047`\spad{integrate(s,{}v,{}c)} is the integral of \spad{s} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.}
384170`\spad{integrate(exp,{} [a..b,{}c..d,{}...],{} epsrel)} is a top level ANNA function to integrate a multivariate expression,{} {\spad{\tt} \spad{exp}},{} over a given set of ranges to the required relative accuracy. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of t
384170`--he) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}. \blankline If epsrel = 0,{} a default absolute accuracy is used.
384300`\spad{integrate(exp,{} a..b,{} epsrel)} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range {\spad{\tt} a} to {\spad{\tt} \spad{b}} to the required relative accuracy. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of th
384300`--e) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}. \blankline If epsrel = 0,{} a default absolute accuracy is used.
384424`\spad{integrate(exp,{} x = a..b,{} "numerical")} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range,{} {\spad{\tt} a} to {\spad{\tt} \spad{b}}. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of 
384424`--the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.\newline \blankline Default values for the absolute and relative error are used. \blankline It is an error of the last argument is not {\spad{\tt} "numerical"}.
384572`\spad{integrate(exp,{} x = a..b,{} numerical)} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range,{} {\spad{\tt} a} to {\spad{\tt} \spad{b}}. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of th
384572`--e) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.\newline \blankline Default values for the absolute and relative error are used. \blankline It is an error if the last argument is not {\spad{\tt} numerical}.
384720`\spad{integrate(f,{} x = a..b,{} "noPole")} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then this function will assume that \spad{f} has no such pole. Error: i
384720`--f \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not "noPole".
384932`\spad{integrate(f,{} x = a..b,{} "noPole")} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then this functio
384932`--n will assume that \spad{f} has no such pole. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not "noPole".
385198`\spad{integrate(f,{} x = a..b,{} "noPole")} returns the integral of \spad{f(x)dx} from a to \spad{b}. If it is not possible to check whether \spad{f} has a pole for \spad{x} between a and \spad{b} (because of parameters),{} then th
385198`--is function will assume that \spad{f} has no such pole. Error: if \spad{f} has a pole for \spad{x} between a and \spad{b} or if the last argument is not "noPole".
385474`\spad{integrate(s,{}v,{}c)} is the integral of \spad{s} with respect \indented{1}{to \spad{v} and having \spad{c} as the constant of integration.}
385574`\spad{integrate(exp,{} [a..b,{}c..d,{}...],{} epsabs,{} epsrel)} is a top level ANNA function to integrate a multivariate expression,{} {\spad{\tt} \spad{exp}},{} over a given set of ranges to the required absolute and relative accuracy. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant inform
385574`--ation of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.
385710`\spad{integrate(exp,{} a..b,{} epsabs,{} epsrel)} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range {\spad{\tt} a} to {\spad{\tt} \spad{b}} to the required absolute and relative accuracy. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant informa
385710`--tion of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.
385840`\spad{integrate(exp,{} [a..b,{}c..d,{}...],{} epsabs,{} epsrel,{} routines)} is a top level ANNA function to integrate a multivariate expression,{} {\spad{\tt} \spad{exp}},{} over a given set of ranges to the required absolute and relative accuracy,{} using the routines available in the RoutinesTable provided. \blankline It iterates over the \axiom{domain
385840`--s} of \axiomType{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.
385990`\spad{integrate(exp,{} a..b,{} epsrel,{} routines)} is a top level ANNA function to integrate an expression,{} {\spad{\tt} \spad{exp}},{} over a given range {\spad{\tt} a} to {\spad{\tt} \spad{b}} to the required absolute and relative accuracy using the routines available in the RoutinesTable provided. \blankline It iterates over the \axiom{domains} of \axiomTy
385990`--pe{NumericalIntegrationCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline It then performs the integration of the given expression on that \axiom{domain}.
386134`\spad{intensity(v,{}i)} sets the intensity of the light source to \spad{i},{} for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
386200`\axiom{interReduce(\spad{lp})} returns \axiom{\spad{lq}} such that \axiom{\spad{lp}} and \axiom{\spad{lq}} generate the same ideal and no polynomial in \axiom{\spad{lq}} is reducuble by the others in the sense of Groebner bases. Since no assumptions are required the result may depend on the ordering the reductions are performed.
386284`\spad{intermediateResultsIF(o)} returns a value corresponding to the required number of intermediate results required and,{} therefore,{} an indication of how much this would affect the step-length of the calculation. It returns a value in the range [0,
386284`--{}1].
386538`\spad{internal?(x)} \undocumented
386590`\spad{internalAugment(lp,{}ts)} returns \spad{ts} if \spad{lp} is empty otherwise returns \spad{internalAugment(rest lp,{} internalAugment(first lp,{} ts))}
386675`\spad{internalAugment(p,{}ts)} assumes that \spad{augment(p,{}ts)} returns a singleton and returns it.
386754`\axiom{internalAugment(\spad{p},{}\spad{ts},{}\spad{b1},{}\spad{b2},{}\spad{b3},{}\spad{b4},{}\spad{b5})} is an internal subroutine,{} exported only for developement.
386871`\axiom{internalAugment(\spad{p},{}\spad{ts},{}\spad{b1},{}\spad{b2},{}\spad{b3},{}\spad{b4},{}\spad{b5})} is an internal subroutine,{} exported only for developement.
387960`\axiom{internalInfRittWu?(\spad{lp1},{}\spad{lp2})} is an internal subroutine,{} exported only for developement.
388054`\axiom{internalInfRittWu?(\spad{lp1},{}\spad{lp2})} is an internal subroutine,{} exported only for developement.
388158`\spad{internalIntegrate0 should} be a local function,{} but is conditional.
388261`\spad{internalIntegrate(f,{} x)} returns the integral of \spad{f(x)dx} where \spad{x} is viewed as a complex variable.
388363`\spad{internalIntegrate(f,{} x)} returns \spad{g} such that \spad{dg/dx = f}.
388503`\axiom{internalLastSubResultant(lpwt,{}\spad{v},{}flag)} is an internal subroutine,{} exported only for developement.
388662`\axiom{internalLastSubResultant(\spad{p1},{}\spad{p2},{}\spad{ts},{}inv?,{}break?)} is an internal subroutine,{} exported only for developement.
388799`\axiom{internalSubPolSet?(\spad{lp1},{}\spad{lp2})} returns \spad{true} iff \axiom{\spad{lp1}} is a sub-set of \axiom{\spad{lp2}} assuming that these lists are sorted increasingly \spad{w}.\spad{r}.\spad{t}. \axiomOpFrom{infRittWu?}{RecursivePolynomialCategory}.
388893`\axiom{internalSubPolSet?(\spad{lp1},{}\spad{lp2})} returns \spad{true} iff \axiom{\spad{lp1}} is a sub-set of \axiom{\spad{lp2}} assuming that these lists are sorted increasingly \spad{w}.\spad{r}.\spad{t}. \axiomOpFrom{infRittWu?}{RecursivePolynomialCategory}.
388997`\axiom{internalSubQuasiComponent?(\spad{ts},{}us)} returns a boolean \spad{b} value if the fact that the regular zero set of \axiom{us} contains that of \axiom{\spad{ts}} can be decided (and in that case \axiom{\spad{b}} gives this inclusion) otherwise returns \axiom{"failed"}.
389105`\axiom{internalSubQuasiComponent?(\spad{ts},{}us)} returns a boolean \spad{b} value if the fact the regular zero set of \axiom{us} contains that of \axiom{\spad{ts}} can be decided (and in that case \axiom{\spad{b}} gives this inclusion) otherwise returns \axiom{"failed"}.
389223`\axiom{internalZeroSetSplit(\spad{lp},{}\spad{b1},{}\spad{b2},{}\spad{b3})} is an internal subroutine,{} exported only for developement.
389332`\axiom{internalZeroSetSplit(\spad{lp},{}\spad{b1},{}\spad{b2},{}\spad{b3})} is an internal subroutine,{} exported only for developement.
389451`\spad{interpolate(lf,{}lg)} \undocumented
389556`\spad{interpolate(u,{}lf,{}lg)} \undocumented
389685`\spad{interpretString(s)} treats a string as a piece of AXIOM input,{} by parsing and interpreting it.
389747`\spad{interpret(f)} passes \spad{f} to the interpreter,{} and transforms the result into an object of type \spad{R}.
389809`\spad{interpret(f)} passes \spad{f} to the interpreter.
389853`\spad{intersect(LI)} computes the intersection of the list of ideals \spad{LI}.
390308`\spad{intersect(lp,{}lts)} returns the same as \spad{concat([intersect(lp,{}ts) for ts in lts])|}
390399`\spad{intersect(lp,{}ts)} returns \spad{lts} a split of Lazard of the intersection of the affine variety associated with \spad{lp} and the regular zero set of \spad{ts}.
390484`\spad{intersect(p,{}lts)} returns the same as \spad{intersect([p],{}lts)}
390569`\spad{intersect(p,{}ts)} returns the same as \spad{intersect([p],{}ts)}
390648`\spad{intersect(u,{}v)} returns the set aggregate \spad{w} consisting of elements common to both set aggregates \spad{u} and \spad{v}. Note: equivalent to the notation (not currently supported) {\spad{x} for \spad{x} in \spad{u} | member?(\spad{x},{}\spad{v})}.
390700`\spad{intersect(I,{}J)} computes the intersection of the ideals \spad{I} and \spad{J}.
390775`\spad{interval(f)} creates a new interval around \spad{f}.
390842`\spad{interval(f)} creates a new interval around \spad{f}.
390893`\spad{interval(inf,{}sup)} creates a new interval,{} either \axiom{[\spad{inf},{}\spad{sup}]} if \axiom{\spad{inf} \spad{<=} \spad{sup}} or \axiom{[\spad{sup},{}in]} otherwise.
391106`\spad{inv x} \undocumented{} See \axiomFunFrom{inv}{DivisionRing}
391184`\spad{inv(x)} \undocumented
391266`\spad{inv(x)} \undocumented
391337`\spad{inv x} returns the multiplicative inverse of \spad{x}. Error: if \spad{x} is 0.
391377`\spad{inv(x)} returns the inverse of \spad{x}.
391410`\spad{inv(o)} returns the inverse of \spad{o} if it exists.
391469`\spad{inv(x)} returns the multiplicative inverse of \spad{x}.
391520`\spad{inverseColeman(alpha,{}beta,{}C)}: there is a bijection from the set of matrices having nonnegative entries and row sums {\em alpha},{} column sums {\em beta} to the set of {\em Salpha - Sbeta} double cosets of the symmetric group {\em Sn}. ({\em Salpha} is the Young subgroup corresponding to the improper partition {\em alpha}). For such a matrix \spad{C},{} inverseColeman
391520`--(\spad{alpha},{}\spad{beta},{}\spad{C}) calculates the lexicographical smallest {\em \spad{pi}} in the corresponding double coset. Note: the resulting permutation {\em \spad{pi}} of {\em {1,{}2,{}...,{}n}} is given in list form. Notes: the inverse of this map is {\em coleman}. For details,{} see James/Kerber.
391646`\spad{inverseIntegralMatrixAtInfinity()} returns \spad{M} such that \spad{M (v1,{}...,{}vn) = (1,{} y,{} ...,{} y**(n-1))} where \spad{(v1,{}...,{}vn)} is the local integral basis at infinity returned by \spad{infIntBasis()}.
391750`\spad{inverseIntegralMatrix()} returns \spad{M} such that \spad{M (w1,{}...,{}wn) = (1,{} y,{} ...,{} y**(n-1))} where \spad{(w1,{}...,{}wn)} is the integral basis of \spadfunFrom{integralBasis}{FunctionFieldCategory}.
391844`\spad{inverseLaplace(f,{} s,{} t)} returns the Inverse Laplace transform of \spad{f(s)} using \spad{t} as the new variable or "failed" if unable to find a closed form.
391939`\spad{inverse(ls)} forms the inverse of a sequence \spad{ls}
391999`\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} "failed" is returned. Error: if the matrix is not square.
392091`\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} "failed" is returned. Error: if the matrix is not square. Note: the result will have entries in the quotient field.
392200`\spad{inverse(m)} returns the inverse of the matrix. If the matrix is not invertible,{} "failed" is returned. Error: if the matrix is not square.
392299`\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} "failed" is returned. Error: if the matrix is not square.
392384`\spad{inverse(m)} returns the inverse of the matrix \spad{m},{} if that matrix is invertible and returns "failed" otherwise.
392480`\spad{inverse(m)} returns the inverse of the matrix \spad{m}. If the matrix is not invertible,{} "failed" is returned. Error: if the matrix is not square.
392549`\spad{invertIfCan(m)} returns the inverse of \spad{m} over \spad{R}
392661`\spad{invertible?(p,{}ts)} returns \spad{true} iff \spad{p} is invertible in the tower associated with \spad{ts}.
392741`\spad{invertible?(p,{}ts)} returns \spad{lbwt} where \spad{lbwt.i} is the result of \spad{invertibleElseSplit?(p,{}lbwt.i.tower)} and the list of the \spad{(lqrwt.i).tower} is a split of Kalkbrener of \spad{ts}.
392848`\spad{invertibleElseSplit?(p,{}ts)} returns \spad{true} (resp. \spad{false}) if \spad{p} is invertible in the tower associated with \spad{ts} or returns a split of Kalkbrener of \spad{ts}.
392953`\spad{invertibleSet(p,{}ts)} returns a split of Kalkbrener of the quotient ideal of the ideal \axiom{\spad{I}} by \spad{p} where \spad{I} is the radical of saturated of \spad{ts}.
393085`\spad{invmod(a,{}b)},{} \spad{0<=a<b>1},{} \spad{(a,{}b)=1} means \spad{1/a mod b}.
393138`\spad{invmultisect(a,{}b,{}st)} substitutes \spad{x**((a+b)*n)} for \spad{x**n} and multiplies by \spad{x**b}.
393236`\spad{invmultisect(a,{}b,{}f(x))} substitutes \spad{x^((a+b)*n)} \indented{1}{for \spad{x^n} and multiples by \spad{x^b}.}
393325`\spad{iomode(f)} returns the status of the file \spad{f}. The input/output status of \spad{f} may be "input",{} "output" or "closed" mode.
393380`\spad{ipow(l)} should be local but conditional.
393439`\axiom{iprint(\spad{s})} prints \axiom{\spad{s}} at the current position of the cursor.
393496`\spad{iroot(p,{} n)} should be a non-exported function.
393583`\spad{irreducible?(p)} tests whether the polynomial \spad{p} is irreducible.
393654`\spad{irreducibleFactor(base,{}exponent)} creates a factored object with a single factor whose \spad{base} is asserted to be irreducible (flag = "irred").
393714`\axiom{irreducibleFactors(\spad{lp})} returns \axiom{\spad{lf}} such that if \axiom{\spad{lp} = [\spad{p1},{}...,{}\spad{pn}]} and \axiom{\spad{lf} = [\spad{f1},{}...,{}\spad{fm}]} then \axiom{p1*p2*...\spad{*pn=0}} means \axiom{f1*f2*...\spad{*fm=0}},{} and the \axiom{\spad{fi}} are irreducible over \axiom{\spad{R}} and are pairwise distinct.
393858`\spad{irreducibleRepresentation(lambda)} is the list of the two irreducible representations corresponding to the partition {\em lambda} in Young\spad{'s} natural form for the following two generators of the symmetric group,{} whose elements permute {\em {1,{}2,{}...,{}n}},{} namely {\em (1 2)} (2-cycle) and {\em (1 2 ... n)} (\spad{n}-cycle).
393957`\spad{irreducibleRepresentation(lambda,{}listOfPerm)} is the list of the irreducible representations corresponding to {\em lambda} in Young\spad{'s} natural form for the list of permutations given by {\em listOfPerm}.
394083`\spad{irreducibleRepresentation(lambda,{}\spad{pi})} is the irreducible representation corresponding to partition {\em lambda} in Young\spad{'s} natural form of the permutation {\em \spad{pi}} in the symmetric group,{} whose elements permute {\em {1,{}2,{}...,{}n}}.
394310`\spad{is?(op(a1,{}...,{}an),{} f)} tests if op = \spad{f}.
394366`\spad{is?(op(a1,{}...,{}an),{} s)} tests if the name of op is \spad{s}.
394415`\spad{is?([e1,{}...,{}en],{} pat)} tests if the list of expressions \spad{[e1,{}...,{}en]} matches the pattern pat.
394493`\spad{is?(expr,{} pat)} tests if the expression \spad{expr} matches the pattern pat.
394565`\spad{is?(x,{} op)} tests if \spad{x} is a kernel and is its operator is op.
394627`\spad{is?(x,{} s)} tests if \spad{x} is a kernel and is the name of its operator is \spad{s}.
394682`\spad{is?(op,{} s)} tests if the name of \spad{op} is \spad{s}.
394735`\spad{isAbsolutelyIrreducible?(aG)} calls {\em isAbsolutelyIrreducible?(aG,{}25)}. Note: the choice of 25 was rather arbitrary.
394839`\spad{isAbsolutelyIrreducible?(aG,{} numberOfTries)} uses Norton\spad{'s} irreducibility test to check for absolute irreduciblity,{} assuming if a one-dimensional kernel is found. As no field extension changes create "new" elements in a one-dimensional space,{} the criterium stays \spad{true} for every extension. The method looks for one-dimensionals only by creating random elements (no finge
394839`--rprints) since a run of {\em meatAxe} would have proved absolute irreducibility anyway.
394951`\spad{isExpt(p)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0},{} "failed" otherwise.
395285`\spad{isExpt(p)} returns \spad{[q,{} n]} if \spad{n > 0} and \spad{p = q ** n},{} and "failed" otherwise.
395382`\spad{isExpt(p)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0}.
395498`\spad{isExpt(p)} returns \spad{[x,{} n]} if polynomial \spad{p} has the form \spad{x**n} and \spad{n > 0}.
395832`\spad{isExpt(p,{}op)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0} and \spad{x = op(a)}.
395957`\spad{isExpt(p,{}f)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0} and \spad{x = f(a)}.
396075`\spad{isList(p)} returns \spad{[a1,{}...,{}an]} if \spad{p = [a1,{}...,{}an]},{} "failed" otherwise.
396230`\spad{isMult(p)} returns \spad{[n,{} x]} if \spad{p = n * x} and \spad{n <> 0}.
396349`\spad{isOp(p)} returns \spad{[op,{} [a1,{}...,{}an]]} if \spad{p = op(a1,{}...,{}an)},{} and "failed" otherwise.
396439`\spad{isOp(p,{} op)} returns \spad{[a1,{}...,{}an]} if \spad{p = op(a1,{}...,{}an)},{} and "failed" otherwise.
396514`\spad{isPlus(p)} returns [\spad{m1},{}...,{}\spad{mn}] if \spad{p = m1 + ... + mn} and \spad{n > 1},{} "failed" otherwise.
396755`\spad{isPlus(p)} returns \spad{[a1,{}...,{}an]} if \spad{n > 1} \indented{1}{and \spad{p = a1 + ... + an},{}} and "failed" otherwise.
396818`\spad{isPlus(p)} returns \spad{[m1,{}...,{}mn]} if \spad{p = m1 +...+ mn} and \spad{n > 1}.
396910`\spad{isPlus(p)} returns \spad{[m1,{}...,{}mn]} if polynomial \spad{p = m1 + ... + mn} and \spad{n >= 2} and each \spad{mi} is a nonzero monomial.
396993`\spad{isPower(p)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0},{} "failed" otherwise.
397203`\spad{isPower(p)} returns \spad{[a,{} b]} if \spad{p = a ** b},{} and "failed" otherwise.
397285`\spad{isPower(p)} returns \spad{[x,{} n]} if \spad{p = x**n} and \spad{n <> 0}.
397389`\spad{isQuotient(p)} returns \spad{[a,{} b]} if \spad{p = a / b},{} and "failed" otherwise.
397469`\spad{isQuotient(expr)} returns the quotient part of the input expression or \spad{"failed"} if the expression is not of that form.
397586`\spad{isTimes(p)} returns \spad{[a1,{}...,{}an]} if \spad{p = a1 ... an} and \spad{n > 1},{} "failed" otherwise.
397830`\spad{isTimes(p)} returns \spad{[a1,{}...,{}an]} if \spad{n > 1} and \spad{p = a1 * ... * an},{} and "failed" otherwise.
397894`\spad{isTimes(p)} returns \spad{[a1,{}...,{}an]} if \spad{p = a1*...*an} and \spad{n > 1}.
397980`\spad{isTimes(p)} returns \spad{[a1,{}...,{}an]} if polynomial \spad{p = a1 ... an} and \spad{n >= 2},{} and,{} for each \spad{i},{} \spad{ai} is either a nontrivial constant in \spad{R} or else of the form \spad{x**e},{} where \spad{e > 0} is an integer and \spad{x} in a member of VarSet.
398139`\spad{isobaric?(p)} returns \spad{true} if every differential monomial appearing in the differential polynomial \spad{p} has same weight,{} and returns \spad{false} otherwise.
398217`\spad{iter(f,{}n,{}x)} applies \spad{f n} times to \spad{x}.
398378`\axiom{iteratedInitials(\spad{p})} returns \axiom{[]} if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns the list of the iterated initials of \axiom{\spad{p}}.
398459`\spad{jacobiIdentity?()} tests if \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors.
398539`\spad{jacobiIdentity?()} tests if \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra. For example,{} this holds for crossed products of 3-dimensional vectors.
398616`\spad{jacobi(a,{}b)} returns the Jacobi symbol \spad{J(a/b)}. When \spad{b} is odd,{} \spad{J(a/b) = product(L(a/p) for p in factor b )}. Note: by convention,{} 0 is returned if \spad{gcd(a,{}b) ^= 1}. Iterative \spad{O(log(b)^2)} version coded by Michael Monagan June 1987.
398693`\spad{jacobian(vf,{}xlist)} computes the jacobian,{} the matrix of first partial derivatives,{} of the vector field \spad{vf},{} \spad{vf} a vector function of the variables listed in \spad{xlist}.
398785`\spad{jacobian(v,{}w)} is a local function to make a jacobian matrix
398905`\spad{janko2 constructs} the janko group acting on the integers 1,{}...,{}100.
398981`\spad{janko2(\spad{li})} constructs the janko group acting on the 100 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 100 different entries
399070`\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \spadignore{i.e.} satisfies the Jordan identity. The property of \spadatt{commutative(\spad{"*"})} follows from by definition.
399152`\spad{jordanAdmissible?()} tests if 2 is invertible in the coefficient domain and the multiplication defined by \spad{(1/2)(a*b+b*a)} determines a Jordan algebra,{} \spadignore{i.e.} satisfies the Jordan identity. The property of \spadatt{commutative(\spad{"*"})} follows from by definition.
399231`\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \spad{(a*b)*a**2 - a*(b*a**2) = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \spad{(A,{}+,{}@)} we can construct a Jordan algebra \spad{(A,{}+,{}*)},{} where \spad{a*b := (a@b+b@a)/2}.
399310`\spad{jordanAlgebra?()} tests if the algebra is commutative,{} characteristic is not 2,{} and \spad{(a*b)*a**2 - a*(b*a**2) = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra (Jordan identity). Example: for every associative algebra \spad{(A,{}+,{}@)} we can construct a Jordan algebra \spad{(A,{}+,{}*)},{} where \spad{a*b := (a@b+b@a)/2}.
399501`\spad{karatsubaDivide(p,{}n)} returns the same as \spad{monicDivide(p,{}monomial(1,{}n))}
399621`\spad{karatsuba(a,{}b)} returns \spad{a*b} by applying Karatsuba\spad{'s} trick once. The other multiplications are performed by calling \spad{*} from \spad{U}.
399705`\spad{karatsuba(a,{}b,{}l,{}k)} returns \spad{a*b} by applying Karatsuba\spad{'s} trick provided that both \spad{a} and \spad{b} have at least \spad{l} terms and \spad{k > 0} holds and by calling \spad{noKaratsuba} otherwise. The other multiplications are performed by recursive calls with the same third argument and \spad{k-1} as fourth argument.
399823`\spad{kernel(x)} returns \spad{x} viewed as a kernel.
399987`\spad{kernel(op,{} [f1,{}...,{}fn])} constructs \spad{op(f1,{}...,{}fn)} without evaluating it.
400053`\spad{kernel(op,{} x)} constructs \spad{op}(\spad{x}) without evaluating it.
400113`\spad{kernel(op,{} [a1,{}...,{}an],{} m)} returns the kernel \spad{op(a1,{}...,{}an)} of nesting level \spad{m}. Error: if \spad{op} is \spad{k}-ary for some \spad{k} not equal to \spad{m}.
400249`\spad{kernels(f)} returns the list of all the top-level kernels appearing in \spad{f},{} but not the ones appearing in the arguments of the top-level kernels.
400371`\spad{key?(k,{}t)} tests if \spad{k} is a key in table \spad{t}.
400435`\spad{key(\spad{gi})} returns the process ID of the given graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.
400478`\spad{key(v)} returns the process ID number of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport}.
400533`\spad{key(v)} returns the process ID number of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
400649`\spad{keys(t)} returns the list the keys in table \spad{t}.
400711`\spad{keys(f)} returns the list of keys of \spad{f}
400898`\spad{keys(tab)} returns the list of keys of \spad{f}
401148`\spad{kmax([k1,{}...,{}kn])} returns the top-level \spad{ki} for integration.
401218`\spad{knownInfBasis(n)} \undocumented{}
401315`\spad{kovacic(a_0,{}a_1,{}a_2)} returns either "failed" or \spad{P}(\spad{u}) such that \spad{\$e^{\int(-a_1/2a_2)} e^{\int u}\$} is a solution of \indented{5}{\spad{a_2 y'' + a_1 y' + a0 y = 0}} whenever \spad{u} is a solution of \spad{P u = 0}. The equation must be already irreducible over the rational functions.
401450`\spad{kovacic(a_0,{}a_1,{}a_2,{}ezfactor)} returns either "failed" or \spad{P}(\spad{u}) such that \spad{\$e^{\int(-a_1/2a_2)} e^{\int u}\$} is a solution of \indented{5}{\spad{\$a_2 y'' + a_1 y' + a0 y = 0\$}} whenever \spad{u} is a solution of \spad{P u = 0}. The equation must be already irreducible over the rational functions. Argument \spad{ezfact
401450`--or} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
401604`\spad{kroneckerDelta()} is the rank 2 tensor defined by \indented{3}{\spad{kroneckerDelta()(i,{}j)}} \indented{6}{\spad{= 1\space{2}if i = j}} \indented{6}{\spad{= 0 if\space{2}i \^= j}}
401669`\spad{ksec(k,{} [k1,{}...,{}kn],{} x)} returns the second top-level \spad{ki} after \spad{k} involving \spad{x}.
401756`\spad{lSpaceBasis(d)} returns a basis for \spad{L(d) = {f | (f) >= -d}} as a module over \spad{K[x]}.
401825`\spad{label(n,{}f)} gives form \spad{f} an equation label \spad{n}.
401868`\spad{lagrange(g)} produces the power series for \spad{f} where \spad{f} is implicitly defined as \spad{f(z) = z*g(f(z))}.
401946`\spad{lagrange(g(x))} produces the Taylor series for \spad{f(x)} \indented{1}{where \spad{f(x)} is implicitly defined as \spad{f(x) = x*g(f(x))}.}
402015`\spad{laguerreL(n,{}x)} is the \spad{n}-th Laguerre polynomial,{} \spad{L[n](x)}. These are defined by \spad{exp(-t*x/(1-t))/(1-t) = sum(L[n](x)*t**n/n!,{} n = 0..)}.
402098`\spad{laguerreL(m,{}n,{}x)} is the associated Laguerre polynomial,{} \spad{L<m>[n](x)}. This is the \spad{m}-th derivative of \spad{L[n](x)}.
402200`\spad{laguerre(n)} returns the \spad{n}th Laguerre polynomial \spad{L[n](x)}. Note: Laguerre polynomials,{} denoted \spad{L[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{exp(x*t/(t-1))/(1-t) = sum(L[n](x)*t**n/n!,{} n=0..infinity)}.
402302`\spad{lambda(code,{} [x1,{}...,{}xn])} returns the input form corresponding to \spad{(x1,{}...,{}xn) +-> code} if \spad{n > 1},{} or to \spad{x1 +-> code} if \spad{n = 1}.
402355`\spad{lambert(st)} computes \spad{f(x) + f(x**2) + f(x**3) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f(x)} is a power series with constant coefficient 1 then \spad{prod(f(x**n),{}n = 1..infinity) = exp(lambert(log(f(x))))}.
402432`\spad{lambert(f(x))} returns \spad{f(x) + f(x^2) + f(x^3) + ...}. \indented{1}{This function is used for computing infinite products.} \indented{1}{\spad{f(x)} should have zero constant coefficient.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n = 1..infinity,{}f(x^n)) = exp(log(lambert(f(x))))}.}
402500`\spad{laplace(f,{} t,{} s)} returns the Laplace transform of \spad{f(t)} using \spad{s} as the new variable. This is \spad{integral(exp(-s*t)*f(t),{} t = 0..\%plusInfinity)}. Returns the formal object \spad{laplace(f,{} t,{} s)} if it cannot compute the transform.
402565`\spad{laplacian(v,{}xlist)} computes the laplacian of the scalar field \spad{v},{} \spad{v} a function of the variables listed in \spad{xlist}.
402647`\spad{largest l} returns the largest element of \spad{l} where the partial ordering induced by setOrder is completed into a total one by the ordering on \spad{S}.
402729`\spad{largest(l,{} fn)} returns the largest element of \spad{l} where the partial ordering induced by setOrder is completed into a total one by \spad{fn}.
402809`\spad{lastSubResultantElseSplit(p1,{}p2,{}ts)} returns either \spad{g} a quasi-monic \spad{gcd} of \spad{p1} and \spad{p2} \spad{w}.\spad{r}.\spad{t}. the \spad{ts} or a split of Kalkbrener of \spad{ts}. This assumes that \spad{p1} and \spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \spad{ts}.
402915`\axiom{lastSubResultantEuclidean(\spad{P},{} \spad{Q})} computes the last non zero subresultant \axiom{\spad{S}} and carries out the equality \axiom{coef1*P + coef2*Q = \spad{S}}.
403048`\axiom{lastSubResultant(a,{}\spad{b})} returns \axiom{resultant(a,{}\spad{b})} if \axiom{a} and \axiom{\spad{b}} has no non-trivial \spad{gcd} in \axiom{\spad{R^}(\spad{-1}) \spad{P}} otherwise the non-zero sub-resultant with smallest index.
403145`\axiom{lastSubResultant(\spad{P},{} \spad{Q})} computes the last non zero subresultant of \axiom{\spad{P}} and \axiom{\spad{Q}}
403226`\axiom{lastSubResultant(a,{}\spad{b})} returns the last non-zero subresultant of \axiom{a} and \axiom{\spad{b}} where \axiom{a} and \axiom{\spad{b}} are assumed to have the same main variable \axiom{\spad{v}} and are viewed as univariate polynomials in \axiom{\spad{v}}.
403325`\spad{lastSubResultant(p1,{}p2,{}ts)} returns \spad{lpwt} such that \spad{lpwt.i.val} is a quasi-monic \spad{gcd} of \spad{p1} and \spad{p2} \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower},{} for every \spad{i},{} and such that the list of the \spad{lpwt.i.tower} is a split of Kalkbrener of \spad{ts}. Moreover,{} if \spad{p1} and \spad{p2} do not have a non-trivial \spad{gcd} \spad{w}.\spad{r}.\s
403325`--pad{t}. \spad{lpwt.i.tower} then \spad{lpwt.i.val} is the resultant of these polynomials \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower}. This assumes that \spad{p1} and \spad{p2} have the same maim variable and that this variable is greater that any variable occurring in \spad{ts}.
403602`\spad{last(l)} returns the last element of a doubly-linked aggregate \spad{l}. Error: if \spad{l} is empty.
403654`\spad{last(u)} resturn the last element of \spad{u}. Note: for lists,{} \axiom{last(\spad{u}) = \spad{u} . (maxIndex \spad{u}) = \spad{u} . (\# \spad{u} - 1)}.
403708`\axiom{last(\spad{ts})} returns the polynomial of \axiom{\spad{ts}} with smallest main variable if \axiom{\spad{ts}} is not empty,{} otherwise returns \axiom{"failed"}.
403918`\spad{last(u,{}n)} returns a copy of the last \spad{n} (\axiom{\spad{n} \spad{>=} 0}) nodes of \spad{u}. Note: \axiom{last(\spad{u},{}\spad{n})} is a list of \spad{n} elements.
404035`\spad{latex(s)} returns a LaTeX-printable output representation of \spad{s}.
404080`\spad{laurentIfCan(f(x))} converts the Puiseux series \spad{f(x)} to a Laurent series if possible. If this is not possible,{} "failed" is returned.
404186`\spad{laurentRep(f(x))} returns \spad{g(x)} where the Puiseux series \spad{f(x) = g(x^r)} is represented by \spad{[r,{}g(x)]}.
404274`\spad{laurent(f)} returns a Laurent expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.
404346`\spad{laurent(x)} returns \spad{x} viewed as a Laurent series.
404422`\spad{laurent(f(x))} converts the Puiseux series \spad{f(x)} to a Laurent series if possible. Error: if this is not possible.
404507`\spad{laurent(f,{}x = a)} expands the expression \spad{f} as a Laurent series in powers of \spad{(x - a)}.
404592`\spad{laurent(f,{}n)} returns a Laurent expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.
404672`\spad{laurent(n,{}f(x))} returns \spad{x**n * f(x)}.
404765`\spad{laurent(n +-> a(n),{}x = a,{}n0..)} returns \spad{sum(n = n0..,{}a(n) * (x - a)**n)}; \spad{laurent(n +-> a(n),{}x = a,{}n0..n1)} returns \spad{sum(n = n0..n1,{}a(n) * (x - a)**n)}.
404883`\spad{laurent(f,{}x = a,{}n)} expands the expression \spad{f} as a Laurent series in powers of \spad{(x - a)}; terms will be computed up to order at least \spad{n}.
404976`\spad{laurent(a(n),{}n,{}x=a,{}n0..)} returns \spad{sum(n = n0..,{}a(n) * (x - a)**n)}; \spad{laurent(a(n),{}n,{}x=a,{}n0..n1)} returns \spad{sum(n = n0..n1,{}a(n) * (x - a)**n)}.
405090`\spad{lazy?(s)} returns \spad{true} if the first node of the stream \spad{s} is a lazy evaluation mechanism which could produce an additional entry to \spad{s}.
405147`\spad{lazyEvaluate(s)} causes one lazy evaluation of stream \spad{s}. Caution: the first node must be a lazy evaluation mechanism (satisfies \spad{lazy?(s) = true}) as there is no error check. Note: a call to this function may or may not produce an explicit first entry
405206`\spad{lazyGintegrate(f,{}r,{}g)} is used for fixed point computations.
405321`\spad{lazyIntegrate(r,{}f)} is a local function used for fixed point computations.
405443`\axiom{lazyIrreducibleFactors(\spad{lp})} returns \axiom{\spad{lf}} such that if \axiom{\spad{lp} = [\spad{p1},{}...,{}\spad{pn}]} and \axiom{\spad{lf} = [\spad{f1},{}...,{}\spad{fm}]} then \axiom{p1*p2*...\spad{*pn=0}} means \axiom{f1*f2*...\spad{*fm=0}},{} and the \axiom{\spad{fi}} are irreducible over \axiom{\spad{R}} and are pairwise distinct. The algor
405443`--ithm tries to avoid factorization into irreducible factors as far as possible and makes previously use of \spad{gcd} techniques over \axiom{\spad{R}}.
405656`\axiom{lazyPquo(a,{}\spad{b})} returns the polynomial \axiom{\spad{q}} such that \axiom{lazyPseudoDivide(a,{}\spad{b})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]}.
405793`\axiom{lazyPquo(a,{}\spad{b},{}\spad{v})} returns the polynomial \axiom{\spad{q}} such that \axiom{lazyPseudoDivide(a,{}\spad{b},{}\spad{v})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]}.
405989`\axiom{lazyPremWithDefault(a,{}\spad{b})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{r}]} such that \axiom{\spad{r} = lazyPrem(a,{}\spad{b})} and \axiom{(c**g)\spad{*r} = prem(a,{}\spad{b})}.
406245`\axiom{lazyPremWithDefault(a,{}\spad{b},{}\spad{v})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{r}]} such that \axiom{\spad{r} = lazyPrem(a,{}\spad{b},{}\spad{v})} and \axiom{(c**g)\spad{*r} = prem(a,{}\spad{b},{}\spad{v})}.
406442`\axiom{lazyPrem(a,{}\spad{b})} returns the polynomial \axiom{\spad{r}} reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{b}} and such that \axiom{\spad{b}} divides \axiom{init(\spad{b})^e a - \spad{r}} where \axiom{\spad{e}} is the number of steps of this pseudo-division.
406579`\axiom{lazyPrem(a,{}\spad{b},{}\spad{v})} returns the polynomial \axiom{\spad{r}} reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{b}} viewed as univariate polynomials in the variable \axiom{\spad{v}} such that \axiom{\spad{b}} divides \axiom{init(\spad{b})^e a - \spad{r}} where \axiom{\spad{e}} is the number of steps of this pseudo-division.
406783`\axiom{lazyPseudoDivide(a,{}\spad{b})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]} such that \axiom{\spad{c^n} * a = \spad{q*b} \spad{+r}} and \axiom{lazyResidueClass(a,{}\spad{b})} returns \axiom{[\spad{r},{}\spad{c},{}\spad{n}]} where \axiom{\spad{n} + \spad{g} = max(0,{} degree(\spad{b}) - degree(a) + 1)}.
406919`\axiom{lazyPseudoDivide(a,{}\spad{b})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]} such that \axiom{[\spad{c},{}\spad{g},{}\spad{r}] = lazyPremWithDefault(a,{}\spad{b})} and \axiom{\spad{q}} is the pseudo-quotient computed in this lazy pseudo-division.
407192`\axiom{lazyPseudoDivide(a,{}\spad{b},{}\spad{v})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]} such that \axiom{\spad{r} = lazyPrem(a,{}\spad{b},{}\spad{v})},{} \axiom{(c**g)\spad{*r} = prem(a,{}\spad{b},{}\spad{v})} and \axiom{\spad{q}} is the pseudo-quotient computed in this lazy pseudo-division.
407333`\axiom{lazyPseudoQuotient(a,{}\spad{b})} returns \axiom{\spad{q}} if \axiom{lazyPseudoDivide(a,{}\spad{b})} returns \axiom{[\spad{c},{}\spad{g},{}\spad{q},{}\spad{r}]}
407411`\axiom{lazyPseudoRemainder(a,{}\spad{b})} returns \axiom{\spad{r}} if \axiom{lazyResidueClass(a,{}\spad{b})} returns \axiom{[\spad{r},{}\spad{c},{}\spad{n}]}. This lazy pseudo-remainder is computed by means of the \axiomOpFrom{fmecg}{NewSparseUnivariatePolynomial} operation.
407612`\axiom{lazyResidueClass(a,{}\spad{b})} returns \axiom{[\spad{r},{}\spad{c},{}\spad{n}]} such that \axiom{\spad{r}} is reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{b}} and \axiom{\spad{b}} divides \axiom{\spad{c^n} * a - \spad{r}} where \axiom{\spad{c}} is \axiom{leadingCoefficient(\spad{b})} and \axiom{\spad{n}} is as small as possible with the previous properties.
407737`\axiom{lazyResidueClass(a,{}\spad{b})} returns \axiom{[\spad{p},{}\spad{q},{}\spad{n}]} where \axiom{\spad{p} / q**n} represents the residue class of \axiom{a} modulo \axiom{\spad{b}} and \axiom{\spad{p}} is reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{b}} and \axiom{\spad{q}} is \axiom{init(\spad{b})}.
407865`\axiom{lazyVariations(\spad{l},{}\spad{s1},{}\spad{sn})} is the number of sign variations in the list of non null numbers [s1::l]\spad{@sn},{}
408061`\spad{lcm(l)} returns the least common multiple of the elements of the list \spad{l}.
408140`\spad{lcm(x,{}y)} returns the least common multiple of \spad{x} and \spad{y}.
408180`\spad{ldf2lst(ln)} coerces a List of \axiomType{DoubleFloat} to \axiomType{List}(\axiomType{String})
408266`\spad{ldf2lst(ln)} coerces a \axiomType{List DoubleFloat} to \axiomType{List String}
408347`\spad{ldf2lst(ln)} coerces a List of \axiomType{DoubleFloat} to \axiomType{List String}
408420`\spad{ldf2vmf(l)} coerces a \axiomType{List DoubleFloat} to \axiomType{List MachineFloat}
408575`\spad{leader(p)} returns the derivative of the highest rank appearing in the differential polynomial \spad{p} Note: an error occurs if \spad{p} is in the ground ring.
408644`\spad{leadingBasisTerm(p)} returns the leading basis term of antisymmetric polynomial \spad{p}.
408701`\spad{leadingBasisTerm(df)} returns the leading basis term of differential form \spad{df}.
408776`\spad{leadingCoefficientRicDE(op)} returns \spad{[[m1,{} p1],{} [m2,{} p2],{} ... ,{} [mk,{} pk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y = 0} must have degree \spad{mj} for some \spad{j},{} and its leading coefficient is then a zero of \spad{pj}. In addition,{}\spad{m1>m2> ... >mk}.
409047`\spad{leadingCoefficient(df)} returns the leading coefficient of differential form \spad{df}.
409142`\spad{leadingCoefficient(p)} returns the leading coefficient of antisymmetric polynomial \spad{p}.
409200`\spad{leadingCoefficient(x)} \undocumented
409281`\spad{leadingCoefficient }\undocumented
409346`\spad{leadingCoefficient(f)} gives the coefficient of \spad{f},{} whose corresponding monoid element is the greatest among all those with non-zero coefficients.
409420`\spad{leadingCoefficient(z)} returns the coefficient of the leading (with respect to the ordering on the indexing set) monomial of \spad{z}. Error: if \spad{z} has no support.
409495`\spad{leadingCoefficient(f)} returns the coefficient of the lowest order term of \spad{f}
409575`\spad{leadingCoefficient(p)} returns the coefficient highest degree term of \spad{p}.
409639`\spad{leadingCoefficient(x)} returns the first coefficient which appears in \spad{ListOfTerms(x)}.
409703`\spad{leadingCoefficient(l)} is \spad{a(n)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
409771`\spad{leadingCoefficient(l)} is \spad{a(n)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
409923`\axiom{leadingCoefficient(\spad{p},{}\spad{v})} returns the leading coefficient of \axiom{\spad{p}},{} where \axiom{\spad{p}} is viewed as A univariate polynomial in \axiom{\spad{v}}.
410002`\spad{leadingExponent(x)} \undocumented
410080`\spad{leadingIdeal(I)} is the ideal generated by the leading terms of the elements of the ideal \spad{I}.
410155`\spad{leadingIndex(x)} \undocumented
410308`\spad{leadingMonomial(f)} gives the monomial of \spad{f} whose corresponding monoid element is the greatest among all those with non-zero coefficients.
410379`\spad{leadingMonomial(x)} \undocumented
410479`\spad{leadingMonomial(x)} returns the first element from \spad{Basis} which appears in \spad{ListOfTerms(x)}.
410544`\spad{leadingMonomial(p)} returns the monomial of \spad{p} with the highest degree.
410606`\spad{leadingMonomial(f)} returns the monomial of \spad{f} of lowest order.
410681`\spad{leadingSupport(z)} returns the index of leading (with respect to the ordering on the indexing set) monomial of \spad{z}. Error: if \spad{z} has no support.
410752`\spad{leadingTerm(x)} returns the first term which appears in \spad{ListOfTerms(x)}.
410998`\spad{leaf?(x)} \undocumented
411046`\spad{leaf?(u)} tests if \spad{u} is a terminal node.
411102`\spad{leastAffineMultiple(f)} computes the least affine polynomial which is divisible by the polynomial \spad{f} over the finite field {\em GF},{} \spadignore{i.e.} a polynomial whose exponents are 0 or a power of \spad{q},{} the size of {\em GF}.
411302`\axiom{leastMonomial(\spad{p})} returns an error if \axiom{\spad{p}} is \axiom{\spad{O}},{} otherwise,{} if \axiom{\spad{p}} belongs to \axiom{\spad{R}} returns \axiom{1},{} otherwise,{} the monomial of \axiom{\spad{p}} with lowest degree,{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
411374`\spad{leastPower(p,{}n)} returns \spad{e},{} where \spad{e} is the smallest integer such that \spad{p **e >= n}
411546`\spad{leaves(t)} returns the list of values in obtained by visiting the nodes of tree \axiom{\spad{t}} in left-to-right order.
411603`\spad{leftAlternative?()} tests if \spad{2*associator(a,{}a,{}b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
411684`\spad{leftAlternative?()} tests if \spad{2*associator(a,{}a,{}b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
411873`\spad{leftCharacteristicPolynomial(a)} returns the characteristic polynomial of the left regular representation of \spad{a} with respect to any basis.
411987`\spad{leftDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(leftTraceMatrix())}.
412058`\spad{leftDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(leftTraceMatrix())}.
412280`\spad{leftDiscriminant([v1,{}...,{}vn])} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj}. Note: the same as \spad{determinant(leftTraceMatrix([v1,{}...,{}vn]))}.
412362`\spad{leftDivide(a,{}b)} returns the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called ``left division\spad{''}.
412461`\spad{leftDivide(a,{}b)} returns the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called ``left division\spad{''}.
412576`\spad{leftDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called ``left division\spad{''}. \spad{\sigma} is the morphism to use.
412708`\spad{leftExactQuotient(a,{}b)} computes the value \spad{q},{} if it exists,{} \indented{1}{such that \spad{a = b*q}.}
412892`\spad{leftExactQuotient(a,{}b)} computes the value \spad{q},{} if it exists,{} \indented{1}{such that \spad{a = b*q}.}
413107`\spad{leftExtendedGcd(a,{}b)} returns \spad{[c,{}d]} such that \spad{g = a * c + b * d = leftGcd(a,{} b)}.
413233`\spad{leftFactorIfCan(f,{}h)} returns the left factor (\spad{g} in \spad{f} = \spad{g} \spad{o} \spad{h}) of the functional decomposition of the polynomial \spad{f} with given \spad{h} or \spad{"failed"} if \spad{g} does not exist.
413338`\spad{leftFactor(p,{}q)} \undocumented
413421`\spad{leftGcd(a,{}b)} computes the value \spad{g} of highest degree such that \indented{3}{\spad{a = aa*g}} \indented{3}{\spad{b = bb*g}} for some values \spad{aa} and \spad{bb}. The value \spad{g} is computed using left-division.
413553`\spad{leftGcd(a,{}b)} computes the value \spad{g} of highest degree such that \indented{3}{\spad{a = g*aa}} \indented{3}{\spad{b = g*bb}} for some values \spad{aa} and \spad{bb}. The value \spad{g} is computed using left-division.
413635`\spad{leftLcm(a,{}b)} computes the value \spad{m} of lowest degree such that \spad{m = a*aa = b*bb} for some values \spad{aa} and \spad{bb}. The value \spad{m} is computed using left-division.
413767`\spad{leftLcm(a,{}b)} computes the value \spad{m} of lowest degree such that \spad{m = aa*a = bb*b} for some values \spad{aa} and \spad{bb}. The value \spad{m} is computed using right-division.
413953`\spad{leftMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of left powers of \spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit.
414081`\spad{leftMult(s,{} a)} returns \spad{s * a} where \spad{*} is the monoid operation,{} which is assumed non-commutative.
414200`\spad{leftNorm(a)} returns the determinant of the left regular representation of \spad{a}.
414266`\spad{leftOne(eq)} divides by the left hand side.
414337`\spad{leftOne(eq)} divides by the left hand side.
414584`\spad{leftPower(a,{}n)} returns the \spad{n}\spad{-}th left power of \spad{a},{} \spadignore{i.e.} \spad{leftPower(a,{}n) := a * leftPower(a,{}n-1)} and \spad{leftPower(a,{}0) := 1}.
414650`\spad{leftPower(a,{}n)} returns the \spad{n}\spad{-}th left power of \spad{a},{} \spadignore{i.e.} \spad{leftPower(a,{}n) := a * leftPower(a,{}n-1)} and \spad{leftPower(a,{}1) := a}.
414705`\spad{leftQuotient(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{q} is returned.
414847`\spad{leftQuotient(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{q} is returned.
414934`\spad{leftRankPolynomial()} returns the left minimimal polynomial of the generic element
415087`\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.
415200`\spad{leftRankPolynomial()} calculates the left minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.
415322`\spad{leftRank(x)} determines the number of linearly independent elements in \spad{x*b1},{}...,{}\spad{x*bn},{} where \spad{b=[b1,{}...,{}bn]} is a basis.
415469`\spad{leftRecip(a)} returns an element,{} which is a left inverse of \spad{a},{} or \spad{"failed"} if there is no unit element,{} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
415574`\spad{leftRecip(a)} returns an element,{} which is a left inverse of \spad{a},{} or \spad{"failed"} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
415721`\spad{leftRegularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \spad{a} with respect to the fixed \spad{R}-module basis.
416000`\spad{leftRegularRepresentation(a,{}[v1,{}...,{}vn])} returns the matrix of the linear map defined by left multiplication by \spad{a} with respect to the \spad{R}-module basis \spad{[v1,{}...,{}vn]}.
416102`\spad{leftRemainder(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{r} is returned.
416246`\spad{leftRemainder(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{r} is returned.
416334`\spad{leftScalarTimes!(c,{}r,{}a)} computes the scalar product \spad{r * a} and stores the result in the matrix \spad{c}. Error: if \spad{a} and \spad{c} do not have the same dimensions.
416436`\spad{leftTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by left trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis.
416514`\spad{leftTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by left trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis.
416757`\spad{leftTraceMatrix([v1,{}...,{}vn])} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the left trace of the product \spad{vi*vj}.
416910`\spad{leftTrace(a)} returns the trace of the left regular representation of \spad{a}.
416977`\spad{leftTrim(s,{}c)} returns \spad{s} with all leading characters \spad{c} deleted. For example,{} \axiom{leftTrim(" abc ",{} char " ")} returns \axiom{"abc "}.
417035`\spad{leftTrim(s,{}cc)} returns \spad{s} with all leading characters in \spad{cc} deleted. For example,{} \axiom{leftTrim("(abc)",{} charClass "()")} returns \axiom{"abc)"}.
417172`\spad{leftUnit()} returns a left unit of the algebra (not necessarily unique),{} or \spad{"failed"} if there is none.
417382`\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \spad{"failed"} if there is none
417506`\spad{leftUnits()} returns the affine space of all left units of the algebra,{} or \spad{"failed"} if there is none.
417643`\spad{leftZero(eq)} subtracts the left hand side.
417706`\axiom{left(\spad{x})} returns left subtree of \axiom{\spad{x}} or error if \axiomOpFrom{retractable?}{LyndonWord}(\axiom{\spad{x}}) is \spad{true}.
417753`\axiom{left(\spad{x})} returns left subtree of \axiom{\spad{x}} or error if \axiomOpFrom{retractable?}{Magma}(\axiom{\spad{x}}) is \spad{true}.
417795`\spad{left(f)} left-justifies form \spad{f} in total space.
417834`\axiom{left(rootChar)} is the left bound of the isolating interval
417926`\spad{left(u)} returns the left child.
417982`\spad{left(f,{}n)} left-justifies form \spad{f} within space of width \spad{n}.
418029`\spad{legendreP(n,{}x)} is the \spad{n}-th Legendre polynomial,{} \spad{P[n](x)}. These are defined by \spad{1/sqrt(1-2*x*t+t**2) = sum(P[n](x)*t**n,{} n = 0..)}.
418145`\spad{legendre(n)} returns the \spad{n}th Legendre polynomial \spad{P[n](x)}. Note: Legendre polynomials,{} denoted \spad{P[n](x)},{} are computed from the two term recurrence. The generating function is: \spad{1/sqrt(1-2*t*x+t**2) = sum(P[n](x)*t**n,{} n=0..infinity)}.
418257`\spad{legendre(a,{}p)} returns the Legendre symbol \spad{L(a/p)}. \spad{L(a/p) = (-1)**((p-1)/2) mod p} (\spad{p} prime),{} which is 0 if \spad{a} is 0,{} 1 if \spad{a} is a quadratic residue \spad{mod p} and \spad{-1} otherwise. Note: because the primality test is expensive,{} if it is known that \spad{p} is prime then use \spad{jacobi(a,{}p)}.
418380`\spad{length(p)} returns the sum of the absolute values of the coefficients of the polynomial \spad{p}.
418451`\spad{length(x)} returns the length of \spad{x}.
418518`\spad{length([l1]*[l2]*...[ln])} returns the length of the word \spad{l1*l2*...*ln}.
418604`\spad{length(x)} returns the number of elements in tuple \spad{x}
418659`\axiom{length(\spad{x})} returns the number of entries in \axiom{\spad{x}}.
418721`\axiom{length(\spad{x})} returns the number of entries in \axiom{\spad{x}}.
418778`\spad{length(q)} returns the number of elements in the queue. Note: \axiom{length(\spad{q}) = \spad{#q}}.
418842`\spad{length(v)} computes the sqrt(dot(\spad{v},{}\spad{v})),{} \spadignore{i.e.} the magnitude
418928`\spad{length(a)} length of \spad{a} in digits.
418978`\spad{lepol }\undocumented
419361`\spad{less?(a,{} b)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder.
419442`\spad{less?(u,{}n)} tests if \spad{u} has less than \spad{n} elements.
419505`\spad{less?(a,{} b,{} fn)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder,{} and returns \spad{fn(a,{} b)} if \spad{a} and \spad{b} are not comparable in that ordering.
419585`\spad{level(s)} returns a non negative integer which is the current level field of the indicated 3 dimensional subspace \spad{s}.
419644`\spad{leviCivitaSymbol()} is the rank \spad{dim} tensor defined by \spad{leviCivitaSymbol()(i1,{}...idim) = +1/0/-1} if \spad{i1,{}...,{}idim} is an even/is nota /is an odd permutation of \spad{minix,{}...,{}minix+dim-1}.
419711`\spad{lexGroebner(lp,{}lv)} computes Groebner basis for the list of polynomials \spad{lp} in lexicographic order. The variables are ordered by their position in the list \spad{lv}.
419809`\axiom{lexTriangular(base,{} norm?)} decomposes the variety associated with \axiom{base} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \axiom{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \axiom{norm?} is \axiom{\spad{true}} then th
419809`--e regular sets are normalized.
419965`\spad{lex(ls)} sorts a list of pairs to lexicographic order
420033`\axiom{lexico(\spad{x},{}\spad{y})} returns \axiom{\spad{true}} iff \axiom{\spad{x}} is smaller than \axiom{\spad{y}} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \axiom{VarSet}.
420090`\axiom{lexico(\spad{x},{}\spad{y})} returns \axiom{\spad{true}} iff \axiom{\spad{x}} is smaller than \axiom{\spad{y}} \spad{w}.\spad{r}.\spad{t}. the lexicographical ordering induced by \axiom{VarSet}. \spad{N}.\spad{B}. This operation does not take into account the tree structure of its arguments. Thus this is not a total ordering.
420142`\spad{lexico(x,{}y)} returns \spad{true} iff \spad{x} is smaller than \spad{y} \spad{w}.\spad{r}.\spad{t}. the pure lexicographical ordering induced by \spad{S}.
420201`\spad{lfextendedint(f,{} x,{} g)} returns functions \spad{[h,{} c]} such that \spad{dh/dx = f - cg},{} if (\spad{h},{} \spad{c}) exist,{} "failed" otherwise.
420312`\spad{lfextlimint(f,{}x,{}k,{}[k1,{}...,{}kn])} returns functions \spad{[h,{} c]} such that \spad{dh/dx = f - c dk/dx}. Value \spad{h} is looked for in a field containing \spad{f} and \spad{k1},{}...,{}\spad{kn} (the \spad{ki}\spad{'s} must be logs).
420445`\spad{lfinfieldint(f,{} x)} returns a function \spad{g} such that \spad{dg/dx = f} if \spad{g} exists,{} "failed" otherwise.
420529`\spad{lfintegrate(f,{} x)} = \spad{g} such that \spad{dg/dx = f}.
420615`\spad{lflimitedint(f,{}x,{}[g1,{}...,{}gn])} returns functions \spad{[h,{}[[\spad{ci},{} \spad{gi}]]]} such that the \spad{gi}\spad{'s} are among \spad{[g1,{}...,{}gn]},{} and \spad{d(h+sum(\spad{ci} log(\spad{gi})))/dx = f},{} if possible,{} "failed" otherwise.
420767`\spad{lfunc(d,{}n)} computes the rank of the \spad{n}th factor in the lower central series of the free \spad{d}-generated free Lie algebra; This rank is \spad{d} if \spad{n} = 1 and binom(\spad{d},{}2) if \spad{n} = 2
420824`\spad{lhs(f)} returns the left side of \spad{f}
420867`\spad{lhs(r)} returns the left hand side of the rule \spad{r}.
420915`\spad{lhs(eqn)} returns the left hand side of equation \spad{eqn}.
420953`\spad{\spad{li}(f)} denotes the logarithmic integral
421002`\spad{\spad{li}(x)} returns the logarithmic integral of \spad{x},{} \spadignore{i.e.} the integral of \spad{dx / log(x)}.
421056`\spad{library(ln)} creates a new library file.
421101`\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition.
421180`\spad{lieAdmissible?()} tests if the algebra defined by the commutators is a Lie algebra,{} \spadignore{i.e.} satisfies the Jacobi identity. The property of anticommutativity follows from definition.
421256`\spad{lieAlgebra?()} tests if the algebra is anticommutative and \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \spad{(A,{}+,{}@)} we can construct a Lie algebra \spad{(A,{}+,{}*)},{} where \spad{a*b := a@b-b@a}.
421332`\spad{lieAlgebra?()} tests if the algebra is anticommutative and \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0} for all \spad{a},{}\spad{b},{}\spad{c} in the algebra (Jacobi identity). Example: for every associative algebra \spad{(A,{}+,{}@)} we can construct a Lie algebra \spad{(A,{}+,{}*)},{} where \spad{a*b := a@b-b@a}.
421476`\spad{lift(x)} return the canonical representative of the equivalence class \spad{x}
421545`\spad{lift(x)} \undocumented
421590`\spad{lift(z)} returns a minimal degree univariate polynomial up such that \spad{z=reduce up}.
421641`\spad{lift(u,{}k)} \undocumented
421799`\spad{lift should} be local
422040`\spad{lifting1(u,{}lv,{}lu,{}lr,{}lp,{}lt,{}ln,{}t,{}r)} \undocumented
422362`\spad{lifting(u,{}lv,{}lu,{}lr,{}lp,{}ln,{}r)} \undocumented
422587`\spad{light(c)} sets the shade of a hue,{} \spad{c},{} to it\spad{'s} highest value.
422627`\spad{lighting(v,{}x,{}y,{}z)} sets the position of the light source to the coordinates \spad{x},{} \spad{y},{} and \spad{z} and displays the graph for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
422704`\spad{limitPlus(f(var))} returns \spad{limit(var -> a+,{}f(var))}.
422807`\spad{limitPlus(f(var))} returns \spad{limit(var -> cen+,{}f(var))}.
422939`\spad{limit(f(x),{}x = a)} computes the real limit \spad{lim(x -> a,{}f(x))}.
423178`\spad{limit(f(x),{}x = a)} computes the real two-sided limit of \spad{f} as its argument \spad{x} approaches \spad{a}.
423505`\spad{limit(f(x),{}x = a)} computes the real two-sided limit of \spad{f} as its argument \spad{x} approaches \spad{a}.
423841`\spad{limit(f(x),{}x=a,{}"left")} computes the left hand real limit \spad{lim(x -> a-,{}f(x))}; \spad{limit(f(x),{}x=a,{}"right")} computes the right hand real limit \spad{lim(x -> a+,{}f(x))}.
423955`\spad{limit(f(x),{}x,{}a,{}"left")} computes the real limit of \spad{f} as its argument \spad{x} approaches \spad{a} from the left; limit(\spad{f}(\spad{x}),{}\spad{x},{}a,{}"right") computes the corresponding limit as \spad{x} approaches \spad{a} from the right.
424134`\spad{limitedIntegrate(f,{} x,{} [g1,{}...,{}gn])} returns fractions \spad{[h,{} [[\spad{ci},{}\spad{gi}]]]} such that the \spad{gi}\spad{'s} are among \spad{[g1,{}...,{}gn]},{} \spad{dci/dx = 0},{} and \spad{d(h + sum(\spad{ci} log(\spa
424134`--d{gi})))/dx = f} if possible,{} "failed" otherwise.
424404`\spad{limitedint(f,{} [g1,{}...,{}gn])} returns fractions \spad{[h,{}[[\spad{ci},{} \spad{gi}]]]} such that the \spad{gi}\spad{'s} are among \spad{[g1,{}...,{}gn]},{} \spad{ci' = 0},{} and \spad{(h+sum(\spad{ci} log(\spad{gi})))' = f},{} if possible,{} "failed" otherwise.
424601`\spad{linGenPos }\undocumented
424792`\spad{linSolve(lp,{}lvar)} finds the solutions of the linear system of polynomials \spad{lp} = 0 with respect to the list of symbols \spad{lvar}.
424962`\spad{lineColorDefault()} returns the default color of lines connecting points in a 2D viewport.
425025`\spad{lineColorDefault(p)} sets the default color of lines connecting points in a 2D viewport to the palette \spad{p}.
425095`\axiom{linear?(\spad{p})} returns \spad{true} iff \axiom{\spad{p}} does not lie in the base ring \axiom{\spad{R}} and has main degree \axiom{1}.
425169`\spad{linear?(e)} tests if \axiom{\spad{e}} is a linear function.
425243`\spad{linear?(l)} returns \spad{true} if all the bounds \spad{l} are either linear or simple.
425425`\spad{linearAssociatedExp(a,{}f)} is linear over {\em F},{} \spadignore{i.e.} for elements {\em a} from {\em \$},{} {\em c,{}d} form {\em F} and {\em f,{}g} univariate polynomials over {\em F} we have \spadfun{linearAssociatedExp}(a,{}cf+dg) equals {\em c} times \spadfun{linearAssociatedExp}(a,{}\spad{f}) plus {\em d} times \spadfun{linearAssociatedExp}(a,{}\spad{g}). Therefore \spadfu
425425`--n{linearAssociatedExp} is defined completely by its action on monomials from {\em F[X]}: \spadfun{linearAssociatedExp}(a,{}monomial(1,{}\spad{k})\spad{\$}SUP(\spad{F})) is defined to be \spadfun{Frobenius}(a,{}\spad{k}) which is {\em a**(q**k)},{} where {\em q=size()\$F}.
425644`\spad{linearAssociatedLog(a)} returns a polynomial {\em g},{} such that \spadfun{linearAssociatedExp}(normalElement(),{}\spad{g}) equals {\em a}.
425878`\spad{linearAssociatedLog(b,{}a)} returns a polynomial {\em g},{} such that the \spadfun{linearAssociatedExp}(\spad{b},{}\spad{g}) equals {\em a}. If there is no such polynomial {\em g},{} then \spadfun{linearAssociatedLog} fails.
426115`\spad{linearAssociatedOrder(a)} retruns the monic polynomial {\em g} of least degree,{} such that \spadfun{linearAssociatedExp}(a,{}\spad{g}) is 0.
426233`\spad{linearlyDependenceOverZ([v1,{}...,{}vn])} returns \spad{[c1,{}...,{}cn]} if \spad{c1*v1 + ... + cn*vn = 0} and not all the \spad{ci}\spad{'s} are 0,{} "failed" if the \spad{vi}\spad{'s} are linearly independent over the integers.
426341`\spad{linearDependence([v1,{}...,{}vn])} returns \spad{[c1,{}...,{}cn]} if \spad{c1*v1 + ... + cn*vn = 0} and not all the \spad{ci}\spad{'s} are 0,{} "failed" if the \spad{vi}\spad{'s} are linearly independent over \spad{S}.
426433`\spad{linearMatrix(l,{}n)} returns a matrix of coefficients of the linear functions in \axiom{\spad{l}}. If \spad{l} is empty,{} the matrix has at least one row.
426549`\spad{linearPart(l)} returns the list of linear functions of \axiom{\spad{l}}.
426654`\axiom{linearPolynomials(\spad{lp})} returns \axiom{\spad{lps},{}nlps} where \axiom{\spad{lps}} is a list of the linear polynomials in \spad{lp},{} and \axiom{nlps} are the other ones.
426777`\spad{linear(u)} \undocumented
426844`\spad{linear(f,{}g)} \undocumented
426912`\spad{linearlyDependent?([v1,{}...,{}vn])} returns \spad{true} if the \spad{vi}\spad{'s} are linearly dependent over \spad{S},{} \spad{false} otherwise.
426988`\spad{linearlyDependentOverZ?([v1,{}...,{}vn])} returns \spad{true} if the \spad{vi}\spad{'s} are linearly dependent over the integers,{} \spad{false} otherwise.
427074`\spad{linears(f,{}p)} returns the product of all the linear factors of \spad{f} modulo \spad{p}. Potentially incorrect result if \spad{f} is not square-free modulo \spad{p}.
427146`\spad{linkToFortran(s,{}l,{}t,{}lv)} \undocumented{}
427252`\spad{linkToFortran(s,{}l,{}ll,{}lv)} \undocumented{}
427428`\spad{linkToFortran(s,{}l,{}ll,{}lv,{}t)} \undocumented{}
427611`\spad{lintgcd([a1,{}..,{}ak])} = \spad{gcd} of a list of integers
427669`\spad{list?(s)} is \spad{true} if \spad{s} is a Lisp list,{} possibly ().
427745`\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \spad{c}.
427837`\spad{listBranches(c)} returns a list of lists of points,{} representing the branches of the curve \spad{c}.
427929`\spad{listConjugateBases(bas,{}q,{}n)} returns the list \spad{[bas,{}bas^Frob,{}bas^(Frob^2),{}...bas^(Frob^(n-1))]},{} where \spad{Frob} raises the coefficients of all polynomials appearing in the basis \spad{bas} to the \spad{q}th power.
428163`\spad{listLoops(t)} returns the list of lists of points,{} or the 'loops',{} of the given tube plot \spad{t}.
428309`\spad{listOfLists(m)} returns the rows of the matrix \spad{m} as a list of lists.
428381`\spad{listOfLists(m)} returns the rows of the matrix \spad{m} as a list of lists.
428468`\spad{listOfLists t} converts a tableau \spad{t} to a list of lists.
428525`\spad{listOfMonoms(l)} returns the list of the monomials forming \spad{l}.
428606`\spad{listRepresentation(p)} produces a representation {\em rep} of the permutation \spad{p} as a list of preimages and images,{} \spad{i}.\spad{e} \spad{p} maps {\em (rep.preimage).k} to {\em (rep.image).k} for all indices \spad{k}.
428699`\spad{listYoungTableaus(lambda)} where {\em lambda} is a proper partition generates the list of all standard tableaus of shape {\em lambda} by means of lattice permutations. The numbers of the lattice permutation are interpreted as column labels. Hence the contents of these lattice permutations are the conjugate of {\em lambda}. Notes: the functions {\em nextLatticePermutation} and {\em makeYoungT
428699`--ableau} are used. The entries are from {\em 0,{}...,{}n-1}.
428847`\spad{list(x)} returns the list of one element \spad{x}.
428891`\spad{list(sy)} takes a scripted symbol and produces a list of the name followed by the scripts.
428932`\spad{listexp }\undocumented
429005`\spad{lists(r)} returns the list of matches that match lists.
429085`\spad{lllip(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of indices to points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise.
429170`\spad{lllp(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of components,{} which are lists of curves,{} which are lists of points,{} and if so,{} returns the list of lists of lists; An error is signaled otherwise.
429244`\spad{llprop(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of curves which are lists of the subspace component properties of the curves,{} and if so,{} returns the list of lists; An error is signaled otherwise.
429331`\spad{lo(s)} returns the first endpoint of \spad{s}. Note: \spad{lo(l..h) = l}.
429375`\spad{localAbs(fcn)} = \spad{abs(fcn)} or \spad{sqrt(fcn**2)} depending on whether or not FE has a function \spad{abs}. This should be a local function,{} but the compiler won\spad{'t} allow it.
429455`\spad{localAbs(fcn)} = \spad{abs(fcn)} or \spad{sqrt(fcn**2)} depending on whether or not FE has a function \spad{abs}. This should be a local function,{} but the compiler won\spad{'t} allow it.
429547`\spad{integralBasis(p)} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the local integral closure of \spad{Z} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{Z}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1.
429547`--.n)},{} then the \spad{i}th element of the integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,
429547`--{} j = 1..n)}.
429694`\spad{integralBasis(p)} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then the \sp
429694`--ad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
429821`\spad{integralBasis(p)} returns a record \spad{[basis,{}basisDen,{}basisInv] } containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of the framed algebra \spad{F}. \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If 'basis' is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n
429821`--)},{} then the \spad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of 'basis' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix 'basisInv' contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if 'basisInv' is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n
429821`--)}.
429959`\spad{integralBasis(p)} returns a record \spad{[basis,{}basisDen,{}basisInv]} containing information regarding the local integral closure of \spad{R} at the prime \spad{p} in the quotient field of \spad{F},{} where \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then t
429959`--he \spad{i}th element of the local integral basis is \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of \spad{basis} contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matrix \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1
429959`--..n)}.
430092`\spad{localReal?(x)} should be local but conditional
430154`\spad{localUnquote(f,{}ls)} is a local function.
430222`\spad{log10()} returns \spad{ln 10}: \spad{2.3025809299...}.
430255`\spad{log10(x)} computes the logarithm with base 10 for \spad{x}.
430296`\spad{log10(x)} computes the logarithm for \spad{x} to base 10.
430331`\spad{log10(x)} represents the Fortran intrinsic function \spad{LOG10}
430413`\spad{log2()} returns \spad{ln 2},{} \spadignore{i.e.} \spad{0.6931471805...}.
430445`\spad{log2(x)} computes the logarithm with base 2 for \spad{x}.
430485`\spad{log2(x)} computes the logarithm for \spad{x} to base 2.
430519`\spad{logGamma(x)} is the natural log of \spad{Gamma(x)}. This can often be computed even if \spad{Gamma(x)} cannot.
430615`\spad{logGamma(x)} is the natural log of \spad{Gamma(x)}. This can often be computed even if \spad{Gamma(x)} cannot.
430693`\spad{logIfCan(z)} returns log(\spad{z}) if possible,{} and "failed" otherwise.
430773`\spad{log(x)} applies the logarithm operator to \spad{x}
430822`\spad{log(f)} returns \spad{[(a1,{}b1),{}...,{}(am,{}bm)]} such that the logarithm of \spad{f} is equal to \spad{a1*log(b1) + ... + am*log(bm)}.
431025`\spad{log(st)} computes the log of a power series.
431108`\spad{log(st)} computes the log of a power series.
431205`\spad{log(z)} returns the logarithm of Laurent series \spad{z}.
431291`\spad{log(z)} returns the logarithm of a Puiseux series \spad{z}.
431386`\axiom{log(\spad{p})} returns the logarithm of \axiom{\spad{p}}.
431466`\spad{log(x)} returns the natural logarithm of \spad{x}.
431520`\spad{log(x)} represents the Fortran intrinsic function LOG
431600`\axiom{log(\spad{p},{} \spad{n})} returns the logarithm of \axiom{\spad{p}} truncated at order \axiom{\spad{n}}.
431688`\axiom{log(\spad{p},{}\spad{n})} returns the logarithm of \axiom{\spad{p}} (truncated up to order \axiom{\spad{n}}).
431791`\spad{logical?(t)} tests whether \spad{t} is equivalent to the FORTRAN type LOGICAL.
431846`\spad{logpart(ir)} returns the logarithmic part of an integration result
432069`\spad{lookup(x)} \undocumented{} See \axiomFunFrom{lookup}{Finite}
432155`\spad{lookup(x)} returns a positive integer such that \spad{x = index lookup x}.
432205`\spad{loopPoints(p,{}n,{}b,{}r,{}lls)} creates and returns a list of points which form the loop with radius \spad{r},{} around the center point indicated by the point \spad{p},{} with the principal normal vector of the space curve at point \spad{p} given by the point(vector) \spad{n},{} and the binormal vector given by the point(vector) \spad{b}
432205`--,{} and a list of lists,{} \spad{lls},{} which is the \spadfun{cosSinInfo} of the number of points defining the loop.
432365`\spad{low(s)} returns the first endpoint of \spad{s}. Note: \spad{low(l..h) = l}.
432410`\spad{lowerCase!(s)} destructively replaces the alphabetic characters in \spad{s} by lower case.
432460`\spad{lowerCase?(c)} tests if \spad{c} is an lower case letter,{} \spadignore{i.e.} one of a..\spad{z}.
432509`\spad{lowerCase()} returns the class of all characters for which \spadfunFrom{lowerCase?}{Character} is \spad{true}.
432601`\spad{lowerCase(s)} returns the string with all characters in lower case.
432650`\spad{lowerCase(c)} converts an upper case letter to the corresponding lower case letter. If \spad{c} is not an upper case letter,{} then it is returned unchanged.
432693`\spad{lowerPolynomial(upoly)} converts \spad{upoly} to be a univariate polynomial over \spad{R}. An error if the coefficients contain variables.
432815`\spad{lp(s)} returns the list of points component which the \spadtype{ThreeSpace},{} \spad{s},{} contains; these points are used by reference,{} \spadignore{i.e.} the component holds indices referring to the points rather than the points themselves. This allows for sharing of the points.
432875`\spad{lprop(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a list of subspace component properties,{} and if so,{} returns the list; An error is signaled otherwise.
432955`\spad{lquo(x,{} s)} returns the exact left quotient of \spad{x} by \spad{s}.
433022`\spad{lquo(x,{} y)} returns the exact left quotient of \spad{x} by \spad{y} \spadignore{i.e.} \spad{q} such that \spad{x = y * q},{} "failed" if \spad{x} is not of the form \spad{y * q}.
433083`\spad{lquo(x,{} y)} returns the exact left quotient of \spad{x} \indented{1}{by \spad{y} that is \spad{q} such that \spad{x = y * q},{}} "failed" if \spad{x} is not of the form \spad{y * q}.
433151`\axiom{lquo(\spad{x},{}\spad{y})} returns the left simplification of \axiom{\spad{x}} by \axiom{\spad{y}}.
433263`\spad{lquo(x,{}w)} returns the left simplification of \spad{x} by the word \spad{w}.
433332`\spad{lquo(x,{}y)} returns the left simplification of \spad{x} by \spad{y}.
433382`\spad{lquo(x,{}v)} returns the left simplification of \spad{x} by the variable \spad{v}.
433432`\axiom{lyndon?(\spad{w})} test if \axiom{\spad{w}} is a Lyndon word.
433510`\axiom{lyndonIfCan(\spad{w})} convert \axiom{\spad{w}} into a Lyndon word.
433603`\axiom{lyndon(\spad{w})} convert \axiom{\spad{w}} into a Lyndon word,{} error if \axiom{\spad{w}} is not a Lyndon word.
433722`\spad{magnitude(v)} computes the sqrt(dot(\spad{v},{}\spad{v})),{} \spadignore{i.e.} the length
433811`\axiom{mainCharacterization(\spad{x})} is the main algebraic quantity of \axiom{\spad{x}} (\axiom{SEG})
434040`\axiom{mainCoefficients(\spad{p})} returns an error if \axiom{\spad{p}} is \axiom{\spad{O}},{} otherwise,{} if \axiom{\spad{p}} belongs to \axiom{\spad{R}} returns [\spad{p}],{} otherwise returns the list of the coefficients of \axiom{\spad{p}},{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
434187`\axiom{mainContent(\spad{p})} returns the content of \axiom{\spad{p}} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \axiom{\spad{R}}.
434273`\axiom{mainDefiningPolynomial(\spad{x})} is the defining polynomial for the main algebraic quantity of \axiom{\spad{x}}
434379`\axiom{mainForm(\spad{x})} is the main algebraic quantity name of \axiom{\spad{x}}
434593`\spad{mainKernel(f)} returns a kernel of \spad{f} with maximum nesting level,{} or if \spad{f} has no kernels (\spadignore{i.e.} \spad{f} is a constant).
434734`\axiom{mainMonomial(\spad{p})} returns an error if \axiom{\spad{p}} is \axiom{\spad{O}},{} otherwise,{} if \axiom{\spad{p}} belongs to \axiom{\spad{R}} returns \axiom{1},{} otherwise,{} \axiom{mvar(\spad{p})} raised to the power \axiom{mdeg(\spad{p})}.
434879`\axiom{mainMonomials(\spad{p})} returns an error if \axiom{\spad{p}} is \axiom{\spad{O}},{} otherwise,{} if \axiom{\spad{p}} belongs to \axiom{\spad{R}} returns [1],{} otherwise returns the list of the monomials of \axiom{\spad{p}},{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
435029`\axiom{mainPrimitivePart(\spad{p})} returns the primitive part of \axiom{\spad{p}} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \axiom{\spad{R}}.
435194`\axiom{mainSquareFreePart(\spad{p})} returns the square free part of \axiom{\spad{p}} viewed as a univariate polynomial in its main variable and with coefficients in the polynomial ring generated by its other variables over \axiom{\spad{R}}.
435287`\axiom{mainValue(\spad{x})} is the expression of \axiom{\spad{x}} in terms of \axiom{SparseUnivariatePolynomial(\$)}
435462`\axiom{mainVariable?(\spad{v},{}\spad{ps})} returns \spad{true} iff \axiom{\spad{v}} is the main variable of some polynomial in \axiom{\spad{ps}}.
435547`\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \spad{f},{} "failed" if \spad{f} has no variables.
435744`\spad{mainVariable(f)} returns the highest variable appearing in the numerator or the denominator of \spad{f},{} "failed" if \spad{f} has no variables.
435841`\spad{mainVariable(p)} returns the biggest variable which actually occurs in the polynomial \spad{p},{} or "failed" if no variables are present. fails precisely if polynomial satisfies ground?
436008`\axiom{mainVariables(\spad{ps})} returns the decreasingly sorted list of the variables which are main variables of some polynomial in \axiom{\spad{ps}}.
436091`\spad{makeCos(e,{}r)} makes a sin expression with given argument and coefficient
436142`\spad{makeCrit }\undocumented
436349`\spad{makeEq(lsol,{}lvar)} returns a list of equations formed by corresponding members of \spad{lvar} and \spad{lsol}.
436463`\spad{makeFR(flist)} turns the final factorization of henselFact into a \spadtype{Factored} object.
436589`\spad{makeFR(unit,{}listOfFactors)} creates a factored object (for use by factoring code).
436704`\spad{makeFloatFunction(expr,{} x)} returns a Lisp function \spad{f: \axiomType{DoubleFloat} -> \axiomType{DoubleFloat}} defined by \spad{f(x) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \axiomType{DoubleFloat}.
436804`\spad{makeFloatFunction(expr,{} x,{} y)} returns a Lisp function \spad{f: (\axiomType{DoubleFloat},{} \axiomType{DoubleFloat}) -> \axiomType{DoubleFloat}} defined by \spad{f(x,{} y) == expr}. Function \spad{f} is compiled and directly applicable to objects of type \spad{(\axiomType{DoubleFloat},{} \axiomType{DoubleFloat})}.
436923`\spad{makeGraphImage(llp)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} with default point size and default point and line colours. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.
437000`\spad{makeGraphImage(\spad{gi})} takes the given graph,{} \spad{\spad{gi}} of the domain \spadtype{GraphImage},{} and sends it\spad{'s} data to the viewport manager where it waits to be included in a two-dimensional viewport window. \spad{\spad{gi}} cannot be an empty graph,{} and it\spad{'s} elements must have been created using the \spadfun{point} or \spadfun{component} functions,{} not by a previous \spadfun{makeGraphImage}.
437049`\spad{makeGraphImage(llp,{}lpal1,{}lpal2,{}lp)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} whose point colors are indicated by the list of palette colors,{} \spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \spad{lpal2}. The paramater \spad{l
437049`--p} is a list of integers which denote the size of the data points. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.
437176`\spad{makeGraphImage(llp,{}lpal1,{}lpal2,{}lp,{}lopt)} returns a graph of the domain \spadtype{GraphImage} which is composed of the points and lines from the list of lists of points,{} \spad{llp},{} whose point colors are indicated by the list of palette colors,{} \spad{lpal1},{} and whose lines are colored according to the list of palette colors,{} \spad{lpal2
437176`--}. The paramater \spad{lp} is a list of integers which denote the size of the data points,{} and \spad{lopt} is the list of draw command options. The graph data is then sent to the viewport manager where it waits to be included in a two-dimensional viewport window.
437320`\spad{makeMulti(l)} returns the element whose list of monomials is \spad{l}.
437398`\spad{makeObject(sp,{}curve(f,{}g,{}h),{}a..b)} returns the space \spad{sp} of the domain \spadtype{ThreeSpace} with the addition of the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
437541`\spad{makeObject(sp,{}curve(f,{}g,{}h),{}a..b)} returns the space \spad{sp} of the domain \spadtype{ThreeSpace} with the addition of the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}.
437699`\spad{makeObject(curve(f(t),{}g(t),{}h(t)),{}t = a..b)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{h(t)} is the default title.
437824`\spad{makeObject(curve(f,{}g,{}h),{}a..b,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
437984`\spad{makeObject(f,{}a..b,{}c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}.
438147`\spad{makeObject(f,{}a..b,{}c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{f(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}.
438317`\spad{makeObject(f(x,{}y),{}x = a..b,{}y = c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{f(x,{}y)} appears as the default title.
438442`\spad{makeObject(curve(f,{}g,{}h),{}a..b,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t),{} y = g(t),{} z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; The options contained in the list \spad{l} of the domain \spad{DrawOption} are a
438442`--pplied.
438617`\spad{makeObject(curve(f(t),{}g(t),{}h(t)),{}t = a..b,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} as \spad{t} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of 
438617`--the domain \spad{DrawOption} are applied.
438759`\spad{makeObject(surface(f,{}g,{}h),{}a..b,{}c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,
438759`--{}d)} to \spad{max(c,{}d)}.
438941`\spad{makeObject(surface(f(u,{}v),{}g(u,{}v),{}h(u,{}v)),{}u = a..b,{}v = c..d)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spa
438941`--d{max(c,{}d)}; \spad{h(t)} is the default title.
439085`\spad{makeObject(f,{}a..b,{}c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)},{} and the options contained in the list \spad{l} of the doma
439085`--in \spad{DrawOption} are applied.
439265`\spad{makeObject(f,{}a..b,{}c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{f(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; The options contained in the list 
439265`--\spad{l} of the domain \spad{DrawOption} are applied.
439452`\spad{makeObject(f(x,{}y),{}x = a..b,{}y = c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,{}y)} as \spad{x} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{y} ranges from \spad{min(c,{}d)} to \spad{max(c,{}d)}; \spad{f(x,{}y)} is the default title,{} and the options contained in the list \spad
439452`--{l} of the domain \spad{DrawOption} are applied.
439594`\spad{makeObject(surface(f,{}g,{}h),{}a..b,{}c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges 
439594`--from \spad{min(c,{}d)} to \spad{max(c,{}d)}. The options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
439793`\spad{makeObject(surface(f(u,{}v),{}g(u,{}v),{}h(u,{}v)),{}u = a..b,{}v = c..d,{}l)} returns a space of the domain \spadtype{ThreeSpace} which contains the graph of the parametric surface \spad{x = f(u,{}v)},{} \spad{y = g(u,{}v)},{} \spad{z = h(u,{}v)} as \spad{u} ranges from \spad{min(a,{}b)} to \spad{max(a,{}b)} and \spad{v} ranges from \spa
439793`--d{min(c,{}d)} to \spad{max(c,{}d)}; \spad{h(t)} is the default title,{} and the options contained in the list \spad{l} of the domain \spad{DrawOption} are applied.
439954`\spad{makeRecord(a,{}b)} creates a record object with type Record(part1:S,{} part2:R),{} where \spad{part1} is \spad{a} and \spad{part2} is \spad{b}.
440026`\spad{makeResult(r1,{}r2)} makes the combined result [\spad{r1},{}\spad{r2}].
440222`\spad{makeSUP(p)} converts the polynomial \spad{p} to be of type SparseUnivariatePolynomial over the same coefficients.
440312`\spad{makeSeries(refer,{}str)} creates a power series from the reference \spad{refer} and the stream \spad{str}.
440453`\spad{makeSin(e,{}r)} makes a sin expression with given argument and coefficient
440504`\spad{makeSketch(p,{}x,{}y,{}a..b,{}c..d)} creates an ACPLOT of the curve \spad{p = 0} in the region {\em a <= x <= b,{} c <= y <= d}. More specifically,{} 'makeSketch' plots a non-singular algebraic curve \spad{p = 0} in an rectangular region {\em xMin <= x <= xMax},{} {\em yMin <= y <= yMax}. The user inputs \spad{makeSketch(p,{}x,{}y,{}xMin..xMax,{}yMin..yMax
440504`--)}. Here \spad{p} is a polynomial in the variables \spad{x} and \spad{y} with integer coefficients (\spad{p} belongs to the domain \spad{Polynomial Integer}). The case where \spad{p} is a polynomial in only one of the variables is allowed. The variables \spad{x} and \spad{y} are input to specify the the coordinate axes. The horizontal axis is the \spad{x}-axis and the vertical axis is the \spad{y}-axis. The rational numbers xMin,{}...,{}yMax specify the boundaries of the region in which the cu
440504`--rve is to be plotted.
440647`\spad{makeTerm(s,{} e)} returns the monomial \spad{s} exponentiated by \spad{e} (\spadignore{e.g.} s^e or \spad{e} * \spad{s}).
440702`\spad{makeUnit()} returns the unit element of the monomial.
440942`\spad{makeVariable(s)} views \spad{s} as a differential indeterminate,{} in such a way that the \spad{n}-th derivative of \spad{s} may be simply referenced as \spad{z}.\spad{n} where \spad{z} :=makeVariable(\spad{s}). Note: In the interpreter,{} \spad{z} is given as an internal map,{} which may be ignored.
441039`\spad{makeVariable(p)} views \spad{p} as an element of a differential ring,{} in such a way that the \spad{n}-th derivative of \spad{p} may be simply referenced as \spad{z}.\spad{n} where \spad{z} \spad{:=} makeVariable(\spad{p}). Note: In the interpreter,{} \spad{z} is given as an internal map,{} which may be ignored.
441160`\spad{makeVariable(s,{} n)} returns the \spad{n}-th derivative of a differential indeterminate \spad{s} as an algebraic indeterminate.
441246`\spad{makeViewport2D(v)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and displays a viewport window on the screen which contains the contents of \spad{v}.
441307`\spad{makeViewport2D(\spad{gi},{}lopt)} creates and displays a viewport window of the domain \spadtype{TwoDimensionalViewport} whose graph field is assigned to be the given graph,{} \spad{\spad{gi}},{} of domain \spadtype{GraphImage},{} and whose options field is set to be the list of options,{} \spad{lopt} of domain \spadtype{DrawOption}.
441393`\spad{makeViewport3D(v)} takes the given three-dimensional viewport,{} \spad{v},{} of the domain \spadtype{ThreeDimensionalViewport} and displays a viewport window on the screen which contains the contents of \spad{v}.
441456`\spad{makeViewport3D(sp,{}lopt)} takes the given space,{} \spad{sp} which is of the domain \spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \spad{sp},{} and whose draw options are indicated by the list \spad{lopt},{} which is a list of options from the domain \spad{DrawOption}.
441557`\spad{makeViewport3D(sp,{}s)} takes the given space,{} \spad{sp} which is of the domain \spadtype{ThreeSpace} and displays a viewport window on the screen which contains the contents of \spad{sp},{} and whose title is given by \spad{s}.
441648`\spad{makeYoungTableau(lambda,{}gitter)} computes for a given lattice permutation {\em gitter} and for an improper partition {\em lambda} the corresponding standard tableau of shape {\em lambda}. Notes: see {\em listYoungTableaus}. The entries are from {\em 0,{}...,{}n-1}.
441823`\spad{makeop should} be local but conditional
441897`\spad{makeprod(a,{}b)} \undocumented
441943`\axiom{makingStats?()} returns \spad{true} iff the statisitics process is running.
442021`\spad{mantissa(x)} returns the mantissa part of \spad{x}.
442078`\spad{mantissa(u)} returns the mantissa of \spad{u}
442607`\spad{map!(f,{}a)} assign \spad{a(i,{}j)} to \spad{f(a(i,{}j))} for all \spad{i,{} j}
442681`\spad{map!(f,{}u)} destructively replaces each element \spad{x} of \spad{u} by \axiom{\spad{f}(\spad{x})}.
442775`\spad{mapBivariate(f,{}p(x,{}y))} applies the function \spad{f} to the coefficients of \spad{p(x,{}y)}.
442912`\spad{mapCoef(f,{} e1 a1 +...+ en an)} returns \spad{f(e1) a1 +...+ f(en) an}.
442981`\spad{mapDown!(t,{}p,{}f)} returns \spad{t} after traversing \spad{t} in "preorder" (node then left then right) fashion replacing the successive interior nodes as follows. The root value \spad{x} is replaced by \spad{q} \spad{:=} \spad{f}(\spad{p},{}\spad{x}). The mapDown!(\spad{l},{}\spad{q},{}\spad{f}) and mapDown!(\spad{r},{}\spad{q},{}\spad{f}) are evaluated for the left and right subtrees \spad{l} and \spad{r} of \spad{t}.
443046`\spad{mapDown!(t,{}p,{}f)} returns \spad{t} after traversing \spad{t} in "preorder" (node then left then right) fashion replacing the successive interior nodes as follows. Let \spad{l} and \spad{r} denote the left and right subtrees of \spad{t}. The root value \spad{x} of \spad{t} is replaced by \spad{p}. Then \spad{f}(value \spad{l},{} value \spad{r},{} \spad{p}),{} where \spad{l} and \spad{r} denote the left and right subtrees o
443046`--f \spad{t},{} is evaluated producing two values \spad{pl} and \spad{pr}. Then \spad{mapDown!(l,{}pl,{}f)} and \spad{mapDown!(l,{}pr,{}f)} are evaluated.
443119`\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.
443180`\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.
443244`\spad{mapExpon(f,{} a1\^e1 ... an\^en)} returns \spad{a1\^f(e1) ... an\^f(en)}.
443399`\spad{mapExponents(fn,{}u)} maps function \spad{fn} onto the exponents of the non-zero monomials of polynomial \spad{u}.
443471`\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.
443521`\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.
443572`\spad{mapGen(f,{} a1\^e1 ... an\^en)} returns \spad{f(a1)\^e1 ... f(an)\^en}.
443631`\spad{mapGen(f,{} e1 a1 +...+ en an)} returns \spad{e1 f(a1) +...+ en f(an)}.
443699`\spad{mapMatrixIfCan(f,{}mat)} applies the function \spad{f} to the coefficients of the entries of \spad{mat} if possible,{} and returns \spad{"failed"} otherwise.
443857`\spad{mapSolve(u,{}f)} \undocumented
443978`\spad{mapUnivariateIfCan(f,{}p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)},{} if possible,{} and returns \spad{"failed"} otherwise.
444124`\spad{mapUnivariate(f,{}p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)}.
444233`\spad{mapUnivariate(f,{}p(x))} applies the function \spad{f} to the coefficients of \spad{p(x)}.
444342`\spad{mapUp!(t,{}f)} traverses balanced binary tree \spad{t} in an "endorder" (left then right then node) fashion returning \spad{t} with the value at each successive interior node of \spad{t} replaced by \spad{f}(\spad{l},{}\spad{r}) where \spad{l} and \spad{r} are the values at the immediate left and right nodes.
444402`\spad{mapUp!(t,{}t1,{}f)} traverses \spad{t} in an "endorder" (left then right then node) fashion returning \spad{t} with the value at each successive interior node of \spad{t} replaced by \spad{f}(\spad{l},{}\spad{r},{}\spad{l1},{}\spad{r1}) where \spad{l} and \spad{r} are the values at the immediate left and right nodes. Values \spad{l1} and \spad{r1} are values at the corresponding nodes of a balanced binary tree \spad{t1},{} of ide
444402`--ntical shape at \spad{t}.
444602`\spad{map(f,{}df)} replaces each coefficient \spad{x} of differential form \spad{df} by \spad{f(x)}.
444709`\spad{map(f,{}p)} \undocumented{}
445058`\spad{map(f,{}p)} changes each coefficient of \spad{p} by the application of \spad{f}.
445109`\spad{map(fn,{}u)} maps function \spad{fn} onto the coefficients of the non-zero monomials of \spad{u}.
445159`\spad{map(fn,{}x)} returns \spad{Sum(fn(r_i) w_i)} if \spad{x} writes \spad{Sum(r_i w_i)}.
445214`\axiom{map(func,{} poly)} creates a new polynomial by applying func to every non-zero coefficient of the polynomial poly.
445353`\spad{map(f,{} p)} lifts \spad{f} to the domain of \spad{p} then applies it to \spad{p}.
445761`\spad{map(f,{}x)} \undocumented
445853`\spad{map(f,{}z)} returns the new element created by applying the function \spad{f} to each component of the direct product element \spad{z}.
445921`\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values.
446024`\spad{map(func,{}frac)} applies the function \spad{func} to the numerator and denominator of the fraction \spad{frac}.
446100`\spad{map(f,{}[x0,{}x1,{}x2,{}...])} returns \spad{[f(x0),{}f(x1),{}f(x2),{}..]}.
446191`\spad{map(fn,{}u)} applies \spad{fn} to each element of list \spad{u} and returns a new list with the results. For example \spad{map(square,{}[1,{}2,{}3]) = [1,{}4,{}9]}.
446255`\spad{map(f,{}a)} applies function \spad{f} to each member of one-dimensional array \spad{a} resulting in a new one-dimensional array over a possibly different underlying domain.
446364`\spad{map(f,{} [(v1,{}a1),{}...,{}(vn,{}an)])} returns the matching result [(\spad{v1},{}\spad{f}(\spad{a1})),{}...,{}(\spad{vn},{}\spad{f}(an))].
446476`\spad{map(f,{}a)} applies function \spad{f} to each member of primitive array \spad{a} resulting in a new primitive array over a possibly different underlying domain.
446570`\spad{map(func,{}frac)} applies the function \spad{func} to the numerator and denominator of \spad{frac}.
446643`\spad{map(f,{}s)} returns a stream whose elements are the function \spad{f} applied to the corresponding elements of \spad{s}. Note: \spad{map(f,{}[x0,{}x1,{}x2,{}...]) = [f(x0),{}f(x1),{}f(x2),{}..]}.
446713`\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values.
446783`\spad{map(f,{} v)} applies the function \spad{f} to every element of the vector \spad{v} producing a new vector containing the values or \spad{"failed"}.
446885`\spad{map(f,{}x)} \undocumented
447009`\spad{map(f,{}x)} \undocumented
447133`\spad{map(f,{}x)} \undocumented
447248`\spad{map(f,{}g(x))} applies the map \spad{f} to the coefficients of \indented{1}{the Taylor series \spad{g(x)}.}
447350`\spad{map(f,{}g(x))} applies the map \spad{f} to the coefficients of the Laurent series \spad{g(x)}.
447535`\spad{map(f,{}g(x))} applies the map \spad{f} to the coefficients of the Puiseux series \spad{g(x)}.
447720`\spad{map(f,{}ire)} \undocumented
447823`\spad{map(f,{} k)} returns \spad{g = op(f(a1),{}...,{}f(an))} where \spad{k = op(a1,{}...,{}an)}.
447894`\spad{map(f,{}ue)} \undocumented
447991`\spad{map(f,{}ufe)} \undocumented
448208`\spad{map(f,{}ure)} \undocumented
448353`\spad{map(fn,{}u)} maps function \spad{fn} onto the coefficients of the non-zero monomials of \spad{u}.
448410`\spad{map(fn,{}u)} maps function \spad{fn} onto the coefficients \indented{1}{of the non-zero monomials of \spad{u}.}
448467`\spad{map(f,{} ex)} evaluates ex,{} applying \spad{f} to values of type \spad{R} in ex.
448522`\spad{map(f,{}a)} returns \spad{b},{} where \spad{b(i,{}j) = a(i,{}j)} for all \spad{i},{} \spad{j}.
448597`\spad{map(f,{}a)} returns \spad{b},{} where \spad{b(i,{}j) = f(a(i,{}j))} for all \spad{i,{} j}
448670`\spad{map(fn,{}x)} returns \spad{Sum(fn(r_i) w_i)} if \spad{x} writes \spad{Sum(r_i w_i)}.
448723`\spad{map(fn,{}u)} maps the function \userfun{\spad{fn}} across the factors of \spadvar{\spad{u}} and creates a new factored object. Note: this clears the information flags (sets them to "nil") because the effect of \userfun{\spad{fn}} is clearly not known in general.
448769`\spad{map(f,{} a)} applies \spad{f} to all the constants in \spad{R} appearing in \spad{a}.
448834`\spad{map(f,{}u)} maps \spad{f} onto the coordinates of \spad{u} to get an element in \spad{AS} via identification of the basis of \spad{AR} as beginning part of the basis of \spad{AS}.
448917`\spad{map(f,{}u)} maps \spad{f} onto real and imaginary parts of \spad{u}.
448990`\spad{map(f,{} e)} applies \spad{f} to all the constants appearing in \spad{e}.
449072`\spad{map(fn,{}u)} is used to apply the function \userfun{\spad{fn}} to every factor of \spadvar{\spad{u}}. The new factored object will have all its information flags set to "nil". This function is used,{} for example,{} to coerce every factor base to another type.
449148`\spad{map(f,{}u)} maps \spad{f} onto the coefficients \spad{f} the element \spad{u} of the monoid ring to create an element of a monoid ring with the same monoid \spad{b}.
449236`\spad{map(f,{}u)} maps \spad{f} onto the component parts of the octonion \spad{u}.
449308`\spad{map(f,{} r)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(infinity) = infinity.
449414`\spad{map(f,{} r)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(plusInfinity) = plusInfinity and that \spad{f}(minusInfinity) = minusInfinity.
449517`\spad{map(f,{}p)} \undocumented
449594`\spad{map(f,{} p)} takes a function \spad{f} from \spad{R} to \spad{S},{} and applies it to each (non-zero) coefficient of a polynomial \spad{p} over \spad{R},{} getting a new polynomial over \spad{S}. Note: since the map is not applied to zero elements,{} it may map zero to zero.
449678`\spad{map(f,{} p)} applies \spad{f} to all the leaves of \spad{p} and returns the result as a pattern over \spad{S}.
449751`\spad{map(f,{} p)} produces a new polynomial as a result of applying the function \spad{f} to every coefficient of the polynomial \spad{p}.
449833`\spad{map(f,{}u)} maps \spad{f} onto the component parts of the quaternion \spad{u}.
449907`\spad{map(f,{}s)} expands the segment \spad{s},{} applying \spad{f} to each value. For example,{} if \spad{s = l..h by k},{} then the list \spad{[f(l),{} f(l+k),{}...,{} f(lN)]} is computed,{} where \spad{lN <= h < lN+k}.
449995`\spad{map(f,{}l..h)} returns a new segment \spad{f(l)..f(h)}.
450068`\spad{map(f,{}v=a..b)} returns the value given by \spad{v=f(a)..f(b)}.
450162`\spad{map(func,{} poly)} creates a new polynomial by applying \spad{func} to every non-zero coefficient of the polynomial poly.
450292`\spad{map(func,{} poly)} creates a new polynomial by applying \spad{func} to every non-zero coefficient of the polynomial poly.
450412`\spad{map(f,{}s)} expands the segment \spad{s},{} applying \spad{f} to each value.
450520`\spad{map(f,{}seg)} returns the new segment obtained by applying \spad{f} to the endpoints of \spad{seg}.
450620`\spad{map(f,{} p)} lifts \spad{f} to \spad{F1} and applies it to \spad{p}.
450721`\spad{map(f,{}d)} \undocumented{}
450870`\spad{map(f,{}i)} \undocumented{}
451009`\spad{map(f,{}m)} applies the function \spad{f} to the elements of the matrix \spad{m}.
451103`\spad{map(f,{}m)} applies the function \spad{f} to the elements of the matrix \spad{m}.
451212`\spad{map(f,{}m)} applies a mapping \spad{f:R1} \spad{->} \spad{R2} onto a matrix \spad{m} in \spad{R1} returning a matrix in \spad{R2}
451297`\spad{map(f,{}p)} \undocumented
451370`\spad{map(f,{}m)} applies the function \spad{f} to the elements of the matrix \spad{m}.
451496`\spad{map(f,{}a)} applies function \spad{f} to each member of aggregate \spad{a} resulting in a new aggregate over a possibly different underlying domain.
451569`\spad{map(f,{}a)} applies function \spad{f} to each member of aggregate \spad{a},{} creating a new aggregate with a possibly different underlying domain.
451639`\spad{map(f,{}eq)} returns an equation where \spad{f} is applied to the sides of \spad{eq}
451715`\spad{map(f,{}l..h by k)} produces a value of type \spad{L} by applying \spad{f} to each of the succesive elements of the segment,{} that is,{} \spad{[f(l),{} f(l+k),{} ...,{} f(lN)]},{} where \spad{lN <= h < lN+k}.
451778`\spad{map(f,{}u)} returns a copy of \spad{u} with each element \spad{x} replaced by \spad{f}(\spad{x}). For collections,{} \axiom{map(\spad{f},{}\spad{u}) = [\spad{f}(\spad{x}) for \spad{x} in \spad{u}]}.
451836`\spad{map(f,{}eqn)} constructs a new equation by applying \spad{f} to both sides of \spad{eqn}.
451882`\spad{map(f,{}t)} replaces the tuple \spad{t} by \spad{[f(x) for x in t]}.
451933`\spad{map(f,{}ts)} does a componentwise conversion of the tensor \spad{ts} to a tensor with components of type \spad{T}.
452060`\spad{map(f,{} k)} returns \spad{op(f(x1),{}...,{}f(xn))} where \spad{k = op(x1,{}...,{}xn)}.
452192`\spad{map(f,{} p,{} k)} uses the property \spad{p} of the operator of \spad{k},{} in order to lift \spad{f} and apply it to \spad{k}.
452460`\spad{map(varmap,{} coefmap,{} p)} takes a \spad{varmap},{} a mapping from the variables of polynomial \spad{p} into \spad{S},{} \spad{coefmap},{} a mapping from coefficients of \spad{p} into \spad{S},{} and \spad{p},{} and produces a member of \spad{S} using the corresponding arithmetic. in \spad{S}
452542`\spad{map(f,{}a,{}b)} \undocumented
452654`\spad{map(f,{}a,{}b)} \undocumented
452752`\spad{map(fn,{}list1,{} u2)} applies the binary function \spad{fn} to corresponding elements of lists \spad{u1} and \spad{u2} and returns a list of the results (in the same order). Thus \spad{map(/,{}[1,{}2,{}3],{}[4,{}5,{}6]) = [1/4,{}2/4,{}1/2]}. The computation terminates when the end of either list is reached. That is,{} the length of the result list is equal to the minimum of the lengths of \spad{u1} and \spad{u2}.
452828`\spad{map(f,{}a,{}b)} \undocumented
452926`\spad{map(f,{}st1,{}st2)} returns the stream whose elements are the function \spad{f} applied to the corresponding elements of \spad{st1} and \spad{st2}. Note: \spad{map(f,{}[x0,{}x1,{}x2,{}..],{}[y0,{}y1,{}y2,{}..]) = [f(x0,{}y0),{}f(x1,{}y1),{}..]}.
453010`\spad{map(fn,{}t1,{}t2)} creates a new table \spad{t} from given tables \spad{t1} and \spad{t2} with elements \spad{fn}(\spad{x},{}\spad{y}) where \spad{x} and \spad{y} are corresponding elements from \spad{t1} and \spad{t2} respectively.
453087`\spad{map(f,{} r,{} i)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(infinity) = \spad{i}.
453215`\spad{map(f,{}a,{}b)} returns \spad{c},{} where \spad{c} is such that \spad{c(i,{}j) = f(a(i,{}j),{}b(i,{}j))} for all \spad{i},{} \spad{j}.
453295`\spad{map(f,{}a,{}b)} returns \spad{c},{} where \spad{c(i,{}j) = f(a(i,{}j),{}b(i,{}j))} for all \spad{i,{} j}
453373`\spad{map(f,{}u,{}v)} returns a new collection \spad{w} with elements \axiom{\spad{z} = \spad{f}(\spad{x},{}\spad{y})} for corresponding elements \spad{x} and \spad{y} from \spad{u} and \spad{v}. Note: for linear aggregates,{} \axiom{\spad{w}.\spad{i} = \spad{f}(\spad{u}.\spad{i},{}\spad{v}.\spad{i})}.
453506`\spad{map(f,{} r,{} p,{} m)} lifts \spad{f} and applies it to \spad{r},{} assuming that \spad{f}(plusInfinity) = \spad{p} and that \spad{f}(minusInfinity) = \spad{m}.
453651`\spad{map(f,{}a,{}b,{}r)} returns \spad{c},{} where \spad{c(i,{}j) = f(a(i,{}j),{}b(i,{}j))} when both \spad{a(i,{}j)} and \spad{b(i,{}j)} exist; else \spad{c(i,{}j) = f(r,{} b(i,{}j))} when \spad{a(i,{}j)} does not exist; else \spad{c(i,{}j) = f(a(i,{}j),{}r)} when \spad{b(i,{}j)} does not exist; otherwise \spad{c(i,{}j) = f(r,{}r)}.
453731`\spad{mapdiv([a0,{}a1,{}..],{}[b0,{}b1,{}..])} returns \spad{[a0/b0,{}a1/b1,{}..]}.
453829`\spad{mapmult([a0,{}a1,{}..],{}[b0,{}b1,{}..])} returns \spad{[a0*b0,{}a1*b1,{}..]}.
453961`\spad{mask(n)} returns \spad{2**n-1} (an \spad{n} bit mask).
454009`\spad{mat(a,{}n)} constructs a one-dimensional matrix of a.
454112`\spad{match?(s,{}t,{}c)} tests if \spad{s} matches \spad{t} except perhaps for multiple and consecutive occurrences of character \spad{c}. Typically \spad{c} is the blank character.
454176`\spad{match(la,{} lb)} creates a map with no default source or target values defined by lists \spad{la} and \spad{lb} of equal length. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length. Note: when this map is applied,{} an error occurs when applied to a value missing from \spad{la}.
454237`\spad{match(la,{} lb,{} f)} creates a map defined by lists \spad{la} and \spad{lb} of equal length. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Argument \spad{f} is used as the function to call when the given function argument is not in \spad{la}. The value returned is \spad{f} applied to that argument.
454305`\spad{match(la,{} lb,{} a)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} where \spad{a} is used as the default source value if the given one is not in \spad{la}. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length.
454363`\spad{match(la,{} lb,{} b)} creates a map defined by lists \spad{la} and \spad{lb} of equal length,{} where \spad{b} is used as the default target value if the given function argument is not in \spad{la}. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Error: if \spad{la} and \spad{lb} are not of equal length.
454426`\spad{match(p,{}s,{}wc)} tests if pattern \axiom{\spad{p}} matches subject \axiom{\spad{s}} where \axiom{\spad{wc}} is a wild card character. If no match occurs,{} the index \axiom{0} is returned; otheriwse,{} the value returned is the first index of the first character in the subject matching the subject (excluding that matched by an initial wild-card). For example,{} \axiom{match("*to*",{}"yorktown",{}\spad{"*"})} returns \axio
454426`--m{5} indicating a successful match starting at index \axiom{5} of \axiom{"yorktown"}.
454500`\spad{match(la,{} lb,{} a,{} f)} creates a map defined by lists \spad{la} and \spad{lb} of equal length. and applies this map to a. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Argument \spad{f} is a default function to call if a is not in \spad{la}. The value returned is then obtained by applying \spad{f} to argument a.
454565`\spad{match(la,{} lb,{} a,{} b)} creates a map defined by lists \spad{la} and \spad{lb} of equal length. and applies this map to a. The target of a source value \spad{x} in \spad{la} is the value \spad{y} with the same index \spad{lb}. Argument \spad{b} is the default target value if a is not in \spad{la}. Error: if \spad{la} and \spad{lb} are not of equal length.
454625`\spad{mathieu11 constructs} the mathieu group acting on the integers 1,{}...,{}11.
454704`\spad{mathieu11(\spad{li})} constructs the mathieu group acting on the 11 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. error,{} if {\em \spad{li}} has less or more than 11 different entries.
454796`\spad{mathieu12 constructs} the mathieu group acting on the integers 1,{}...,{}12.
454875`\spad{mathieu12(\spad{li})} constructs the mathieu group acting on the 12 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed Error: if {\em \spad{li}} has less or more than 12 different entries.
454967`\spad{mathieu22 constructs} the mathieu group acting on the integers 1,{}...,{}22.
455046`\spad{mathieu22(\spad{li})} constructs the mathieu group acting on the 22 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 22 different entries.
455138`\spad{mathieu23 constructs} the mathieu group acting on the integers 1,{}...,{}23.
455217`\spad{mathieu23(\spad{li})} constructs the mathieu group acting on the 23 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 23 different entries.
455309`\spad{mathieu24 constructs} the mathieu group acting on the integers 1,{}...,{}24.
455388`\spad{mathieu24(\spad{li})} constructs the mathieu group acting on the 24 integers given in the list {\em \spad{li}}. Note: duplicates in the list will be removed. Error: if {\em \spad{li}} has less or more than 24 different entries.
455480`\spad{matrixConcat3D(s,{}x,{}y)} concatenates two 3-\spad{D} matrices along a specified axis
455554`\spad{matrixDimensions(x)} returns the dimensions of a matrix
455644`\spad{matrixGcd(mat,{}sing,{}n)} is \spad{gcd(sing,{}g)} where \spad{g} is the \spad{gcd} of the entries of the \spad{n}-by-\spad{n} upper-triangular matrix \spad{mat}.
455795`\spad{matrix(llf)} makes \spad{llf} (a list of lists of forms) into a form which displays as a matrix.
455848`\spad{matrix(l)} converts the list of lists \spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix.
455915`\spad{matrix(l)} converts the list of lists \spad{l} to a matrix,{} where the list of lists is viewed as a list of the rows of the matrix.
455997`\spad{matrix(qf)} creates a square matrix from the quadratic form \spad{qf}.
456061`\spad{maxColIndex(m)} returns the index of the 'last' column of the matrix \spad{m}.
456142`\spad{maxColIndex(m)} returns the index of the 'last' column of the array \spad{m}
456393`\spad{maxIndex(u)} returns the maximum index \spad{i} of aggregate \spad{u}. Note: in general,{} \axiom{maxIndex(\spad{u}) = reduce(max,{}[\spad{i} for \spad{i} in indices \spad{u}])}; if \spad{u} is a list,{} \axiom{maxIndex(\spad{u}) = \#u}.
456479`\spad{maxPoints3D()} returns the maximum number of points in a plot.
456524`\spad{maxPoints()} returns the maximum number of points in a plot
456565`\spad{maxPoints()} returns the maximum number of points in a plot.
456618`\spad{maxPoints()} sets the maximum number of points in a plot.
456678`\spad{maxRowIndex(m)} returns the index of the 'last' row of the matrix \spad{m}.
456759`\spad{maxRowIndex(m)} returns the index of the 'last' row of the array \spad{m}
456838`\spad{max()} returns the maximum floating point number.
456972`\spad{max()} returns the largest single integer.
457056`\spad{max(u)} returns the largest element of aggregate \spad{u}.
457121`\spad{max(q)} returns the maximum element of priority queue \spad{q}.
457210`\spad{max(x,{}y)} returns the maximum of \spad{x} and \spad{y} relative to \spad{"<"}.
457251`\spad{maxdeg(p)} returns the greatest word occurring in the polynomial \spad{p} with a non-zero coefficient. An error is produced if \spad{p} is zero.
457301`\spad{maxdeg(p)} returns the greatest leading word in the support of \spad{p}.
457372`\spad{maximumExponent()} returns the maximum exponent in the model
457427`\spad{maximumExponent(e)} sets the maximum exponent in the model to \spad{e}
457489`\spad{maxint()} returns the maximum integer in the model
457545`\spad{maxint(u)} sets the maximum integer in the model to \spad{u}
457616`\spad{maxrank(r)} returns the maximum rank in the list \spad{r} of regimes
457817`\spad{maxrow(a,{}b,{}c,{}d,{}e)} is an auxiliary function for \spad{mr}
458120`\axiom{mdeg(\spad{p})} returns an error if \axiom{\spad{p}} is \axiom{0},{} otherwise,{} if \axiom{\spad{p}} belongs to \axiom{\spad{R}} returns \axiom{0},{} otherwise,{} returns the degree of \axiom{\spad{p}} in its main variable.
458199`\spad{measure2Result(m)} converts a measure record into a \axiomType{Result}
458323`\spad{measure2Result(m)} converts a measure record into a \axiomType{Result}
458460`\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine for solving the numerical integration problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} of \axiom{category} \axiomType{NumericalIntegrationCategory} in turn to calculate all measures and returns the best \spadignor
458460`--e{i.e.} the name of the most appropriate domain and any other relevant information.
458618`\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} of \axiom{category} \axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to calculate all meas
458618`--ures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes.
458763`\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \axiom{\spad{prob}} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these attributes. \blankl
458763`--ine It calls each \axiom{domain} of \axiom{category} \axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information.
458910`\spad{measure(prob)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} of \axiom{category} \axiomType{PartialDifferentialEquationsSolverCategory} in turn to calculate all measur
458910`--es and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes.
459054`\spad{measure(prob,{}R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical integration problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} listed in \axiom{\spad{R}} of \axiom{category} \axiomType{Numerica
459054`--lIntegrationCategory} in turn to calculate all measures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information.
459226`\spad{measure(prob,{}R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical ODE problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} listed in \axiom{\spad{R}} of \axiom{category} \axiomType{OrdinaryDifferentialEquations
459226`--SolverCategory} in turn to calculate all measures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of ODEs by checking various attributes of the system of ODEs and calculating a measure of compatibility of each routine to these attributes.
459385`\spad{measure(prob,{}R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical optimization problem defined by \axiom{\spad{prob}} by checking various attributes of the functions and calculating a measure of compatibility of each routine to these a
459385`--ttributes. \blankline It calls each \axiom{domain} listed in \axiom{\spad{R}} of \axiom{category} \axiomType{NumericalOptimizationCategory} in turn to calculate all measures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information.
459546`\spad{measure(prob,{}R)} is a top level ANNA function for identifying the most appropriate numerical routine from those in the routines table provided for solving the numerical PDE problem defined by \axiom{\spad{prob}}. \blankline It calls each \axiom{domain} listed in \axiom{\spad{R}} of \axiom{category} \axiomType{PartialDifferentialEquationsSo
459546`--lverCategory} in turn to calculate all measures and returns the best \spadignore{i.e.} the name of the most appropriate domain and any other relevant information. It predicts the likely most effective NAG numerical Library routine to solve the input set of PDEs by checking various attributes of the system of PDEs and calculating a measure of compatibility of each routine to these attributes.
459704`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve an optimization problem. \blankline This method may be either a specific NAG routine or a strategy (such as transforming the funct
459704`--ion from one which is difficult to one which is easier to solve). \blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
459986`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve a problem. \blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is 
459986`--easier to solve). \blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
460234`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve an optimization problem. \blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \blankline It will call whichever agents
460234`-- are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
460410`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve a problem. \blankli
460410`--ne This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one which is easier to solve). \blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
460803`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve a problem. \blankline This method may be either a specific NAG routine or a strategy (such as transforming the function from one which is difficult to one whic
460803`--h is easier to solve). \blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
461056`\spad{measure(R,{}args)} calculates an estimate of the ability of a particular method to solve a problem. \blankline This method may be either a specific NAG routine or a strategy (such as t
461056`--ransforming the function from one which is difficult to one which is easier to solve). \blankline It will call whichever agents are needed to perform analysis on the problem in order to calculate the measure. There is a parameter,{} labelled \axiom{sofar},{} which would contain the best compatibility found so far.
461373`\spad{meatAxe(aG)} calls {\em meatAxe(aG,{}false,{}25,{}7)} returns a 2-list of representations as follows. All matrices of argument \spad{aG} are assumed to be square and of equal size. Then \spad{aG} generates a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an A-module in the usual way. meatAxe(\spad{aG}) creates at most 25 r
461373`--andom elements of the algebra,{} tests them for singularity. If singular,{} it tries at most 7 elements of its kernel to generate a proper submodule. If successful a list which contains first the list of the representations of the submodule,{} then a list of the representations of the factor module is returned. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\spad{'s} irreducibility test can be used either to prove irreducibility or to find the splitting. Notes: the fir
461373`--st 6 tries use Parker\spad{'s} fingerprints. Also,{} 7 covers the case of three-dimensional kernels over the field with 2 elements.
461493`\spad{meatAxe(aG,{} randomElements)} calls {\em meatAxe(aG,{}false,{}6,{}7)},{} only using Parker\spad{'s} fingerprints,{} if {\em randomElemnts} is \spad{false}. If it is \spad{true},{} it calls {\em meatAxe(aG,{}true,{}25,{}7)},{} only using random elements. Note: the choice of 25 was rather arbitrary. Also,{} 7 covers the case of three-dimensional kernels over the field wit
461493`--h 2 elements.
461621`\spad{meatAxe(aG,{} numberOfTries)} calls {\em meatAxe(aG,{}true,{}numberOfTries,{}7)}. Notes: 7 covers the case of three-dimensional kernels over the field with 2 elements.
461757`\spad{meatAxe(aG,{}randomElements,{}numberOfTries,{} maxTests)} returns a 2-list of representations as follows. All matrices of argument \spad{aG} are assumed to be square and of equal size. Then \spad{aG} generates a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an A-module in the usual way. meatAxe(\sp
461757`--ad{aG},{}\spad{numberOfTries},{} maxTests) creates at most {\em numberOfTries} random elements of the algebra,{} tests them for singularity. If singular,{} it tries at most {\em maxTests} elements of its kernel to generate a proper submodule. If successful,{} a 2-list is returned: first,{} a list containing first the list of the representations of the submodule,{} then a list of the representations of the factor module. Otherwise,{} if we know that all the kernel is already scanned,{} Norton\s
461757`--pad{'s} irreducibility test can be used either to prove irreducibility or to find the splitting. If {\em randomElements} is {\em false},{} the first 6 tries use Parker\spad{'s} fingerprints.
461901`\axiom{medial(\spad{ps})} returns the same as \axiom{medialSet(\spad{ps},{}initiallyReduced?,{}initiallyReduce)}.
461987`\axiom{medialSet(\spad{ps},{}redOp?,{}redOp)} returns \axiom{\spad{bs}} a basic set (in Wu Wen Tsun sense \spad{w}.\spad{r}.\spad{t} the reduction-test \axiom{redOp?}) of some set generating the same ideal as \axiom{\spad{ps}} (with rank not higher than any basic set of \axiom{\spad{ps}}),{} if no non-zero constant polynomials appear during the computatioms,{} else \axiom{"failed"} is returned.
461987`-- In the former case,{} \axiom{\spad{bs}} has to be understood as a candidate for being a characteristic set of \axiom{\spad{ps}}. In the original algorithm,{} \axiom{\spad{bs}} is simply a basic set of \axiom{\spad{ps}}.
462097`\spad{member?(p,{} s)} returns \spad{true} is \spad{p} is in \spad{s},{} \spad{false} otherwise.
462461`\spad{member?(pp,{}gp)} answers the question,{} whether the permutation {\em pp} is in the group {\em gp} or not.
462532`\spad{member?(x,{}u)} tests if \spad{x} is a member of \spad{u}. For collections,{} \axiom{member?(\spad{x},{}\spad{u}) = reduce(or,{}[x=y for \spad{y} in \spad{u}],{}\spad{false})}.
462709`\spad{members(u)} returns a list of the consecutive elements of \spad{u}. For collections,{} \axiom{parts([\spad{x},{}\spad{y},{}...,{}\spad{z}]) = (\spad{x},{}\spad{y},{}...,{}\spad{z})}.
462803`\spad{members(ms)} returns a list of the elements of \spad{ms} {\em without} their multiplicity. See also \spadfun{parts}.
462953`\spad{merge!(u,{}v)} destructively merges \spad{u} and \spad{v} in ascending order.
463032`\spad{merge!(q,{}q1)} destructively changes priority queue \spad{q} to include the values from priority queue \spad{q1}.
463223`\spad{merge!(p,{}u,{}v)} destructively merges \spad{u} and \spad{v} using predicate \spad{p}.
463300`\spad{mergeDifference(l1,{}l2)} returns a list of elements in \spad{l1} not present in \spad{l2}. Assumes lists are ordered and all \spad{x} in \spad{l2} are also in \spad{l1}.
463371`\spad{mergeFactors(u,{}v)} is used when the factorizations of \spadvar{\spad{u}} and \spadvar{\spad{v}} are known to be disjoint,{} \spadignore{e.g.} resulting from a content/primitive part split. Essentially,{} it creates a new factored object by multiplying the units together and appending the lists of factors.
463466`\spad{merge(ls)} a list of subspaces,{} \spad{ls},{} into one subspace.
463515`\spad{merge([s1,{}s2,{}...,{}sn])} will create a new \spadtype{ThreeSpace} that has the components of all the ones in the list; Groupings of components into composites are maintained.
463727`\spad{merge(s1,{}s2)} the subspaces \spad{s1} and \spad{s2} into a single subspace.
463773`\spad{merge(u,{}v)} merges \spad{u} and \spad{v} in ascending order. Note: \axiom{merge(\spad{u},{}\spad{v}) = merge(\spad{<=},{}\spad{u},{}\spad{v})}.
463847`\spad{merge(q1,{}q2)} returns combines priority queues \spad{q1} and \spad{q2} to return a single priority queue \spad{q}.
463905`\spad{merge(s1,{}s2)} will create a new \spadtype{ThreeSpace} that has the components of \spad{s1} and \spad{s2}; Groupings of components into composites are maintained.
464159`\spad{merge(p,{}a,{}b)} returns an aggregate \spad{c} which merges \axiom{a} and \spad{b}. The result is produced by examining each element \spad{x} of \axiom{a} and \spad{y} of \spad{b} successively. If \axiom{\spad{p}(\spad{x},{}\spad{y})} is \spad{true},{} then \spad{x} is inserted into the result; otherwise \spad{y} is inserted. If \spad{x} is chosen,{} the next element of \axiom{a} is examined,{} and so on. When all the elemen
464159`--ts of one aggregate are examined,{} the remaining elements of the other are appended. For example,{} \axiom{merge(<,{}[1,{}3],{}[2,{}7,{}5])} returns \axiom{[1,{}2,{}3,{}7,{}5]}.
464231`\spad{mesh?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} is composed of one component,{} a mesh comprising a list of curves which are lists of points,{} or returns \spad{false} if otherwise
464287`\spad{meshFun2Var(f,{}g,{}s1,{}s2,{}l)} \undocumented
464547`\spad{meshPar1Var(s,{}t,{}u,{}f,{}s1,{}l)} \undocumented
464764`\spad{meshPar2Var(f,{}s1,{}s2,{}l)} \undocumented
464961`\spad{meshPar2Var(sp,{}f,{}s1,{}s2,{}l)} \undocumented
465182`\spad{meshPar2Var(f,{}g,{}h,{}j,{}s1,{}s2,{}l)} \undocumented
465520`\spad{mesh([[p0],{}[p1],{}...,{}[pn]])} creates a surface defined by a list of curves which are lists,{} \spad{p0} through \spad{pn},{} of points,{} and returns a \spadtype{ThreeSpace} whose component is the surface.
465588`\spad{mesh(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single surface component defined by a list curves which contain lists of points,{} and if so,{} returns the list of lists of points; An error is signaled otherwise.
465656`\spad{mesh([[p0],{}[p1],{}...,{}[pn]],{} close1,{} close2)} creates a surface defined over a list of curves,{} \spad{p0} through \spad{pn},{} which are lists of points; the booleans \spad{close1} and \spad{close2} indicate how the surface is to be closed: \spad{close1} set to \spad{true} means that each individual list (a curve) is to be closed (that is,{} the last point of the list is to be connected to the first point
465656`--); \spad{close2} set to \spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)); the \spadtype{ThreeSpace} containing this surface is returned.
465740`\spad{mesh(s,{}[ [[r10]...,{}[r1m]],{} [[r20]...,{}[r2m]],{}...,{} [[rn0]...,{}[rnm]] ],{} close1,{} close2)} adds a surface component to the \spadtype{ThreeSpace} \spad{s},{} which is defined over a rectangular domain of size \spad{WxH} where \spad{W} is the number of lists of points from the domain \spad{PointDomain(R)} and \spad{H} is the number of elements in each of those lists; the booleans \spad{close1} and \sp
465740`--ad{close2} indicate how the surface is to be closed: if \spad{close1} is \spad{true} this means that each individual list (a curve) is to be closed (\spadignore{i.e.} the last point of the list is to be connected to the first point); if \spad{close2} is \spad{true},{} this means that the boundary at one end of the surface is to be connected to the boundary at the other end (the boundaries are defined as the first list of points (curve) and the last list of points (curve)).
465826`\spad{mesh(s,{}[ [[r10]...,{}[r1m]],{} [[r20]...,{}[r2m]],{}...,{} [[rn0]...,{}[rnm]] ],{} [props],{} prop)} adds a surface component to the \spadtype{ThreeSpace} \spad{s},{} which is defined over a rectangular domain of size \spad{WxH} where \spad{W} is the number of lists of points from the domain \spad{PointDomain(R)} and \spad{H} is the number of elements in each of those 
465826`--lists; lprops is the list of the subspace component properties for each curve list,{} and prop is the subspace component property by which the points are defined.
465954`\spad{mesh(s,{}[[p0],{}[p1],{}...,{}[pn]],{} close1,{} close2)} adds a surface component to the \spadtype{ThreeSpace},{} which is defined over a list of curves,{} in which each of these curves is a list of points. The boolean arguments \spad{close1} and \spad{close2} indicate how the surface is to be closed. Argument \spad{close1} equal \spad{true} means that each individual list (a curve) is to be closed,{} \spadign
465954`--ore{i.e.} the last point of the list is to be connected to the first point. Argument \spad{close2} equal \spad{true} means that the boundary at one end of the surface is to be connected to the boundary at the other end,{} \spadignore{i.e.} the boundaries are defined as the first list of points (curve) and the last list of points (curve).
466041`\spad{mesh(s,{}[[p0],{}[p1],{}...,{}[pn]],{}[props],{}prop)} adds a surface component,{} defined over a list curves which contains lists of points,{} to the \spadtype{ThreeSpace} \spad{s}; props is a list which contains the subspace component properties for each surface parameter,{} and \spad{prop} is the subspace component property by which the points are defined.
466170`\spad{messagePrint(s)} prints \spad{s} without string quotes. Note: \spad{messagePrint(s)} is equivalent to \spad{print message(s)}.
466223`\spad{message(s)} creates an form with no string quotes from string \spad{s}.
466269`\axiom{middle(rootChar)} is the middle of the isolating interval
466363`\spad{midpoint(int)} returns the midpoint of the interval \spad{int}.
466483`\spad{midpoints(isolist)} returns the list of midpoints for the list of intervals \spad{isolist}.
466616`\axiom{mightHaveRoots(\spad{p},{}\spad{r})} is \spad{false} if \axiom{\spad{p}.\spad{r}} is not 0
466727`\spad{minColIndex(m)} returns the index of the 'first' column of the matrix \spad{m}.
466808`\spad{minColIndex(m)} returns the index of the 'first' column of the array \spad{m}
466887`\spad{minGbasis }\undocumented
467102`\spad{minIndex(u)} returns the minimum index \spad{i} of aggregate \spad{u}. Note: in general,{} \axiom{minIndex(a) = reduce(min,{}[\spad{i} for \spad{i} in indices a])}; for lists,{} \axiom{minIndex(a) = 1}.
467188`\spad{minPoints3D()} returns the minimum number of points in a plot.
467233`\spad{minPoints()} returns the minimum number of points in a plot
467274`\spad{minPoints()} returns the minimum number of points in a plot.
467327`\spad{minPoints()} sets the minimum number of points in a plot.
467387`\spad{minPol }\undocumented
467568`\spad{minPol }\undocumented
467806`\spad{minPoly(k)} returns the defining polynomial of \spad{k}.
467923`\spad{minPoly(k)} returns \spad{p} such that \spad{p(k) = 0}.
468018`\spad{minRowIndex(m)} returns the index of the 'first' row of the matrix \spad{m}.
468099`\spad{minRowIndex(m)} returns the index of the 'first' row of the array \spad{m}
468178`\spad{min()} returns the minimum floating point number.
468312`\spad{min()} returns the smallest single integer.
468396`\spad{min(u)} returns the smallest element of aggregate \spad{u}.
468461`\spad{min(u)} returns the smallest entry in the multiset aggregate \spad{u}.
468552`\spad{min(x,{}y)} returns the minimum of \spad{x} and \spad{y} relative to \spad{"<"}.
468593`\spad{mindegTerm(x)} returns the term whose word is \spad{mindeg(x)}.
468679`\spad{mindeg(p)} returns the smallest word occurring in the polynomial \spad{p} with a non-zero coefficient. An error is produced if \spad{p} is zero.
468729`\spad{mindeg(x)} returns the little word which appears in \spad{x}. Error if \spad{x=0}.
469037`\spad{minimalPolynomial(x)} \undocumented{} See \axiomFunFrom{minimalPolynomial}{FiniteAlgebraicExtensionField}
469149`\spad{minimalPolynomial(a)} returns the minimal polynomial of an element \spad{a} over the ground field \spad{F}.
469250`\spad{minimalPolynomial(a)} returns the minimal polynomial of \spad{a}.
469441`\spad{minimalPolynomial(x,{}n)} computes the minimal polynomial of \spad{x} over the field of extension degree \spad{n} over the ground field \spad{F}.
469572`\spad{minimize(I)} returns a reduced set of generators for \spad{I}.
469712`\spad{minimumDegree(p)} gives the least exponent of a non-zero term of polynomial \spad{p}. Error: if applied to 0.
469777`\spad{minimumDegree(l)} is the smallest \spad{k} such that \spad{a(k) \^= 0} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
469857`\spad{minimumDegree(l)} is the smallest \spad{k} such that \spad{a(k) ^= 0} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
470166`\spad{minimumDegree(p,{} lv)} gives the list of minimum degrees of the polynomial \spad{p} with respect to each of the variables in the list \spad{lv}
470269`\spad{minimumDegree(p,{}v)} gives the minimum degree of polynomial \spad{p} with respect to \spad{v},{} \spadignore{i.e.} viewed a univariate polynomial in \spad{v}
470360`\spad{minimumExponent()} returns the minimum exponent in the model
470415`\spad{minimumExponent(e)} sets the minimum exponent in the model to \spad{e}
470477`\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors. Error: if the matrix is not square.
470549`\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors. Error: if the matrix is not square.
470640`\spad{minordet(m)} computes the determinant of the matrix \spad{m} using minors.
470742`\spad{minrank(r)} returns the minimum rank in the list \spad{r} of regimes
470943`\spad{minset(sl)} returns the sublist of \spad{sl} consisting of the minimal lists (with respect to inclusion) in the list \spad{sl} of lists
471039`\spad{minus!(c,{}a)} computes \spad{-a} and stores the result in the matrix \spad{c}. Error: if a and \spad{c} do not have the same dimensions.
471129`\spad{!minus!(c,{}a,{}b)} computes the matrix difference \spad{a - b} and stores the result in the matrix \spad{c}. Error: if \spad{a},{} \spad{b},{} and \spad{c} do not have the same dimensions.
471229`\spad{minusInfinity()} returns minusInfinity.
471297`\spad{minusInfinity()} returns -infinity.
471353`\axiom{mirror(\spad{g})} is the mirror of the internal representation of \axiom{\spad{g}}.
471415`\axiom{mirror(\spad{x})} returns the reversed word of \axiom{\spad{x}}. That is \axiom{\spad{x}} itself if \axiomOpFrom{retractable?}{Magma}(\axiom{\spad{x}}) is \spad{true} and \axiom{mirror(\spad{z}) * mirror(\spad{y})} if \axiom{\spad{x}} is \axiom{\spad{y*z}}.
471459`\spad{mirror(x)} returns the reversed word of \spad{x}.
471510`\axiom{mirror(\spad{x})} returns \axiom{Sum(r_i mirror(w_i))} if \axiom{\spad{x}} is \axiom{Sum(r_i w_i)}.
471565`\spad{mirror(x)} returns \spad{Sum(r_i mirror(w_i))} if \spad{x} writes \spad{Sum(r_i w_i)}.
471614`\spad{mix(l)} \undocumented
471718`\spad{mkAnswer(r,{}l,{}ne)} creates an integration result from a rational part \spad{r},{} a logarithmic part \spad{l},{} and a non-elementary part \spad{ne}.
471917`\spad{mkIntegral(p(x,{}y))} returns \spad{[c(x),{} q(x,{}z)]} such that \spad{z = c * y} is integral. The algebraic relation between \spad{x} and \spad{y} is \spad{p(x,{} y) = 0}. The algebraic relation between \spad{x} and \spad{z} is \spad{q(x,{} z) = 0}.
472014`\spad{mkPrim(f,{} x)} makes the logs in \spad{f} which are linear in \spad{x} primitive with respect to \spad{x}.
472126`\spad{mkcomm(i)} \undocumented{}
472172`\spad{mkcomm(i,{}j)} \undocumented{}
472216`\spad{modTree(r,{}l)} \undocumented{}
472273`\spad{modifyPointData(v,{}ind,{}pt)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport},{} and places the data point,{} \spad{pt} into the list of points database of \spad{v} at the index location given by \spad{ind}.
472377`\spad{modifyPointData(s,{}i,{}p)} changes the point at the indexed location \spad{i} in the \spadtype{ThreeSpace},{} \spad{s},{} to that of point \spad{p}. This is useful for making changes to a point which has been transformed.
472466`\spad{modifyPoint(s,{}\spad{li},{}i)} replaces an existing point in the 3 dimensional subspace,{} \spad{s},{} with the 4 dimensional point indicated by the index location,{} \spad{i}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \spad{s} is empt
472466`--y,{} otherwise the subspace \spad{s} is returned with the point modification.
472559`\spad{modifyPoint(s,{}\spad{li},{}p)} replaces an existing point in the 3 dimensional subspace,{} \spad{s},{} with the 4 dimensional point,{} \spad{p}. The list of non negative integers,{} \spad{li},{} dictates the path to follow,{} or,{} to look at it another way,{} points to the component in which the existing point is to be modified. An error message occurs if \spad{s} is empty,{} otherwise the subspace \spad{s} is re
472559`--turned with the point modification.
472642`\spad{modifyPoint(s,{}ind,{}p)} modifies the point referenced by the index location,{} \spad{ind},{} by replacing it with the point,{} \spad{p} in the 3 dimensional subspace,{} \spad{s}. An error message occurs if \spad{s} is empty,{} otherwise the subspace \spad{s} is returned with the point modification.
472719`\spad{modularFactor(f)} chooses a "good" prime and returns the factorization of \spad{f} modulo this prime in a form that may be used by \spadfunFrom{completeHensel}{GeneralHenselPackage}. If prime is zero it means that \spad{f} has been proved to be irreducible over the integers or that \spad{f} is a unit (\spadignore{i.e.} 1 or \spad{-1}). \spad{f} shall be primitive (\spadignore{i.e.} content(\spad{p})
472719`--\spad{=1}) and square free (\spadignore{i.e.} without repeated factors).
472818`\spad{modularGcdPrimitive(f1,{}f2)} computes the \spad{gcd} of the two polynomials \spad{f1} and \spad{f2} by modular methods.
472902`\spad{modularGcd(listf)} computes the \spad{gcd} of the list of polynomials \spad{listf} by modular methods.
472977`\spad{moduleSum(m1,{}m2)} returns the sum of two modules in the framed algebra \spad{F}. Each module \spad{\spad{mi}} is represented as follows: \spad{F} is a framed algebra with \spad{R}-module basis \spad{w1,{}w2,{}...,{}wn} and \spad{\spad{mi}} is a record \spad{[basis,{}basisDen,{}basis
472977`--Inv]}. If \spad{basis} is the matrix \spad{(aij,{} i = 1..n,{} j = 1..n)},{} then a basis \spad{v1,{}...,{}vn} for \spad{\spad{mi}} is given by \spad{\spad{vi} = (1/basisDen) * sum(aij * wj,{} j = 1..n)},{} \spadignore{i.e.} the \spad{i}th row of 'basis' contains the coordinates of the \spad{i}th basis vector. Similarly,{} the \spad{i}th row of the matrix \spad{basisInv} contains the coordinates of \spad{\spad{wi}} with respect to the basis \spad{v1,{}...,{}vn}: if \spad{basisInv} is the matri
472977`--x \spad{(bij,{} i = 1..n,{} j = 1..n)},{} then \spad{\spad{wi} = sum(bij * vj,{} j = 1..n)}.
473193`\spad{module(I)} returns \spad{I} viewed has a module over \spad{R}.
473299`\spad{module([f1,{}...,{}fn])} = the module generated by \spad{(f1,{}...,{}fn)} over \spad{R}.
473366`\spad{modulo(x)} returns a,{} where \spad{x = a + b p}.
473426`\spad{modulus()} \undocumented
473472`\spad{modulus()} returns the value of \spad{p}.
473530`\spad{modulus(x)} \undocumented
473617`\spad{modulus(x)} \undocumented
473694`\spad{modulus(x)} \undocumented
473770`\spad{moebiusMu(n)} returns the Moebius function \spad{mu(n)}. \spad{mu(n)} is either \spad{-1},{}0 or 1 as follows: \spad{mu(n) = 0} if \spad{n} is divisible by a square > 1,{} \spad{mu(n) = (-1)^k} if \spad{n} is square-free and has \spad{k} distinct prime divisors.
473842`\spad{moebius(a,{}b,{}c,{}d)} returns \spad{matrix [[a,{}b],{}[c,{}d]]}.
473965`\spad{monic?(p)} tests if \spad{p} is monic (\spadignore{i.e.} leading coefficient equal to 1).
474037`\axiom{monic?(\spad{p})} returns \spad{false} if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns \spad{true} iff \axiom{\spad{p}} is monic as a univariate polynomial in its main variable.
474107`\spad{monicCompleteDecompose(f)} returns a list of factors of \spad{f} for the functional decomposition ([ \spad{f1},{} ...,{} \spad{fn} ] means \spad{f} = \spad{f1} \spad{o} ... \spad{o} \spad{fn}).
474206`\spad{monicDecomposeIfCan(f)} returns a functional decomposition of the monic polynomial \spad{f} of "failed" if it has not found any.
474334`\spad{monicDivide(p,{}q)} divide the polynomial \spad{p} by the monic polynomial \spad{q},{} returning the pair \spad{[quotient,{} remainder]}. Error: if \spad{q} isn\spad{'t} monic.
474534`\spad{monicDivide(a,{}b,{}v)} divides the polynomial a by the polynomial \spad{b},{} with each viewed as a univariate polynomial in \spad{v} returning both the quotient and remainder. Error: if \spad{b} is not monic with respect to \spad{v}.
474640`\spad{monicLeftDivide(a,{}b)} returns the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called ``left division\spad{''}.
474769`\spad{monicLeftDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{}r]} such that \spad{a = b*q + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called ``left division\spad{''}. \spad{\sigma} is the morphism to use.
474983`\axiom{monicModulo(a,{}\spad{b})} returns \axiom{\spad{r}} such that \axiom{\spad{r}} is reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{b}} and \axiom{\spad{b}} divides \axiom{a \spad{-r}} where \axiom{\spad{b}} is monic.
475054`\axiom{monicModulo(a,{}\spad{b})} computes \axiom{a mod \spad{b}},{} if \axiom{\spad{b}} is monic as univariate polynomial in its main variable.
475127`\spad{monicRightDivide(a,{}b)} returns the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called ``right division\spad{''}.
475257`\spad{monicRightDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. \spad{b} must be monic. This process is called ``right division\spad{''}. \spad{\sigma} is the morphism to use.
475404`\spad{monicRightFactorIfCan(f,{}d)} returns a candidate to be the monic right factor (\spad{h} in \spad{f} = \spad{g} \spad{o} \spad{h}) of degree \spad{d} of a functional decomposition of the polynomial \spad{f} or \spad{"failed"} if no such candidate.
475531`\spad{monomRDE(f,{}g,{}D)} returns \spad{[A,{} B,{} C,{} T]} such that \spad{y' + f y = g} has a solution if and only if \spad{y = Q / T},{} where \spad{Q} satisfies \spad{A Q' + B Q = C} and has no normal pole. A and \spad{T} are polynomials and \spad{B} and \spad{C} have no normal poles. \spad{D} is the derivation to use.
475684`\spad{monomRDEsys(f,{}g1,{}g2,{}D)} returns \spad{[A,{} B,{} H,{} C1,{} C2,{} T]} such that \spad{(y1',{} y2') + ((0,{} -f),{} (f,{} 0)) (y1,{}y2) = (g1,{}g2)} has a solution if and only if \spad{y1 = Q1 / T,{} y2 = Q2 / T},{} where \spad{B,{}C1,{}C2,{}Q1,{}Q2} have no normal poles and satisfy A \spad{(Q1',{}
475684`-- Q2') + ((H,{} -B),{} (B,{} H)) (Q1,{}Q2) = (C1,{}C2)} \spad{D} is the derivation to use.
475881`\spad{monom(deg,{}coef)} is a monomial of degree \spad{deg} with coefficient \spad{coef}.
475956`\spad{monom(b,{}r)} returns the element with the single monomial \indented{1}{\spad{b} and coefficient \spad{r}.}
476013`\spad{monom(w,{}r)} returns the product of the word \spad{w} by the coefficient \spad{r}.
476140`\spad{monomial?(f)} tests if \spad{f} is a single monomial.
476217`\spad{monomial?(x)} \undocumented
476279`\spad{monomial?(f)} tests if \spad{f} is a single monomial.
476333`\spad{monomial?(p)} tests if \spad{p} is a single monomial.
476394`\spad{monomial?(x)} returns \spad{true} if \spad{x} contains a single monomial.
476455`\spad{monomial?(x)} returns \spad{true} if \spad{x} is a monomial
476512`\spad{monomialIntPoly(p,{} ')} returns [\spad{q},{} \spad{r}] such that \spad{p = q' + r} and \spad{degree(r) < degree(t')}. Error if \spad{degree(t') < 2}.
476619`\spad{monomialIntegrate(f,{} ')} returns \spad{[ir,{} s,{} p]} such that \spad{f = ir' + s + p} and all the squarefree factors of the denominator of \spad{s} are special \spad{w}.\spad{r}.\spad{t} the derivation '.
476925`\spad{monomial(x,{}n)} \undocumented
476988`\spad{monomial(r,{}m)} creates a scalar multiple of the basis element \spad{m}.
477037`\spad{monomial(r,{}x)} \undocumented
477211`\spad{monomial(a,{}s)} constructs a direct product element with the \spad{s} component set to \spad{a}
477278`\spad{monomial(c,{}[i1,{}i2,{}...,{}iN])} produces the value given by \spad{c*e(i1)*e(i2)*...*e(iN)}.
477354`\spad{monomial(r,{}e)} makes a term from a coefficient \spad{r} and an exponent \spad{e}.
477410`\spad{monomial(c,{}k)} produces \spad{c} times the \spad{k}-th power of the generating operator,{} \spad{monomial(1,{}1)}.
477487`\spad{monomial(c,{}k)} produces \spad{c} times the \spad{k}-th power of the generating operator,{} \spad{monomial(1,{}1)}.
478177`\spad{monomial(a,{}[x1,{}..,{}xk],{}[n1,{}..,{}nk])} computes \spad{a * x1**n1 * .. * xk**nk}.
478267`\spad{monomial(a,{}[x1,{}x2,{}...,{}xk],{}[n1,{}n2,{}...,{}nk])} returns \spad{a * x1^n1 * ... * xk^nk}.
478377`\spad{monomial(a,{}[v1..vn],{}[e1..en])} returns \spad{a*prod(vi**ei)}.
478478`\spad{monomial(a,{}x,{}n)} computes \spad{a*x**n}.
478556`\spad{monomial(a,{}x,{}n)} returns \spad{a*x^n}.
478654`\spad{monomial(a,{}x,{}n)} creates the monomial \spad{a*x**n} where \spad{a} is a polynomial,{} \spad{x} is a variable and \spad{n} is a nonnegative integer.
478809`\spad{monomials(f)} gives the list of all monomials whose sum is \spad{f}.
478864`\spad{monomials(x)} returns the list of \spad{r_i*b_i} whose sum is \spad{x}.
478926`\spad{monomials(p)} returns the list of non-zero monomials of polynomial \spad{p},{} \spadignore{i.e.} \spad{monomials(sum(a_(i) X^(i))) = [a_(1) X^(1),{}...,{}a_(n) X^(n)]}.
479296`\spad{more?(a,{} b)} compares \spad{a} and \spad{b} in the partial ordering induced by setOrder,{} and uses the ordering on \spad{S} if \spad{a} and \spad{b} are not comparable in the partial ordering.
479378`\spad{more?(u,{}n)} tests if \spad{u} has greater than \spad{n} elements.
479441`\axiom{moreAlgebraic?(\spad{ts},{}us)} returns \spad{false} iff \axiom{\spad{ts}} and \axiom{us} are both empty,{} or \axiom{\spad{ts}} has less elements than \axiom{us},{} or some variable is algebraic \spad{w}.\spad{r}.\spad{t}. \axiom{us} and is not \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ts}}.
479521`\axiom{moreAlgebraic?(\spad{ts},{}us)} returns \spad{false} iff \axiom{\spad{ts}} and \axiom{us} are both empty,{} or \axiom{\spad{ts}} has less elements than \axiom{us},{} or some variable is algebraic \spad{w}.\spad{r}.\spad{t}. \axiom{us} and is not \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ts}}.
479611`\spad{morphism(f)} returns the non-invertible morphism given by \spad{f}.
479663`\spad{morphism(f)} returns the morphism given by \spad{f^n(x) = f(x,{}n)}.
479723`\spad{morphism(f,{} g)} returns the invertible morphism given by \spad{f},{} where \spad{g} is the inverse of \spad{f}..
479782`\spad{move(v,{}x,{}y)} displays the two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \spad{x},{} \spad{y}.
479873`\spad{move(v,{}x,{}y)} displays the three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} with the upper left-hand corner of the viewport window at the screen coordinate position \spad{x},{} \spad{y}.
479966`\spad{movedPoints(p)} returns the set of points moved by the permutation \spad{p}.
480020`\spad{movedPoints(gp)} returns the points moved by the group {\em gp}.
480079`\spad{mpsode(r,{}f)} solves the system of differential equations \spad{dy[i]/dx =f[i] [x,{}y[1],{}y[2],{}...,{}y[n]]},{} \spad{y[i](a) = r[i]} for \spad{i} in 1..\spad{n}.
480189`\spad{mr(t)} is an auxiliary function which finds the position of the maximum element of a tableau \spad{t} which is in the lowest row,{} producing a record of results
480330`\spad{mulmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a*b mod p}.
480386`\spad{multMonom(r,{}e,{}x)} \undocumented
480463`\spad{multiEuclideanTree(l,{}r)} \undocumented{}
480612`\spad{multiEuclidean([f1,{}...,{}fn],{}z)} returns a list of coefficients \spad{[a1,{} ...,{} an]} such that \spad{ z / prod \spad{fi} = sum aj/fj}. If no such list of coefficients exists,{} "failed" is returned.
480697`\spad{multinomial(n,{}[m1,{}m2,{}...,{}mk])} returns the multinomial coefficient \spad{n!/(m1! m2! ... mk!)}.
480770`\spad{multiple?(p)} tests if \spad{p} is a single matching variable allowing list matching or multiple term matching in a sum or product.
480819`\spad{multiple(x)} tells the pattern matcher that \spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\spad{x}) tells the pattern matcher that \spad{x} should match a list instead of an element of a list. Error: if \spad{x} is not a symbol.
480878`\spad{multiple(x)} tells the pattern matcher that \spad{x} should preferably match a multi-term quantity in a sum or product. For matching on lists,{} multiple(\spad{x}) tells the pattern matcher that \spad{x} should match a list instead of an element of a list.
480954`\spad{multiplyCoefficients(fn,{}f)} returns the series \spad{sum(fn(n) * an * x^n,{}n = n0..)},{} where \spad{f} is the series \spad{sum(an * x^n,{}n = n0..)}.
481053`\spad{multiplyCoefficients(f,{}sum(n = n0..infinity,{}a[n] * x**n)) = sum(n = 0..infinity,{}f(n) * a[n] * x**n)}. This function is used when Puiseux series are represented by a Laurent series and an exponent.
481151`\spad{multiplyCoefficients(f,{}sum(n = 0..infinity,{}a[n] * x**n))} returns \spad{sum(n = 0..infinity,{}f(n) * a[n] * x**n)}. This function is used when Laurent series are represented by a Taylor series and an order.
481248`\spad{multiplyExponents(f,{}r)} multiplies all exponents of the power series \spad{f} by the positive rational number \spad{r}.
481345`\spad{multiplyExponents(p,{}n)} returns a new polynomial resulting from multiplying all exponents of the polynomial \spad{p} by the non negative integer \spad{n}.
481437`\spad{multiplyExponents(f,{}n)} multiplies all exponents of the power series \spad{f} by the positive integer \spad{n}.
481536`\spad{multisect(a,{}b,{}st)} selects the coefficients of \spad{x**((a+b)*n+a)},{} and changes them to \spad{x**n}.
481631`\spad{multisect(a,{}b,{}f(x))} selects the coefficients of \indented{1}{\spad{x^((a+b)*n+a)},{} and changes this monomial to \spad{x^n}.}
481717`\spad{multiset()}\$\spad{D} creates an empty multiset of domain \spad{D}.
481759`\spad{multiset(ls)} creates a multiset with elements from \spad{ls}.
481808`\spad{multiset(s)} creates a multiset with singleton \spad{s}.
481851`\spad{multivariate(f,{} v)} applies both the numerator and denominator of \spad{f} to \spad{v}.
481972`\spad{multivariate(f,{} v)} applies both the numerator and denominator of \spad{f} to \spad{v}.
482115`\spad{multivariate(sup,{}v)} converts an anonymous univariable polynomial \spad{sup} to a polynomial in the variable \spad{v}.
482216`\spad{multivariate(sup,{}v)} converts an anonymous univariable polynomial \spad{sup} to a polynomial in the variable \spad{v}.
482318`\spad{multivariate(u,{}k,{}f)} \undocumented
482458`\spad{musserTrials()} returns the number of primes that are tried in \spadfun{modularFactor}.
482531`\spad{musserTrials(n)} sets to \spad{n} the number of primes to be tried in \spadfun{modularFactor} and returns the previous value.
482733`\axiom{mvar(\spad{p})} returns an error if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in \axiom{\spad{V}}.
482795`\axiom{mvar(\spad{ps})} returns the main variable of the non constant polynomial with the greatest main variable,{} if any,{} else an error is returned.
482863`\spad{myDegree should} be local
483005`\spad{name(x)} returns the symbol
483055`\spad{name(op(a1,{}...,{}an))} returns the name of op.
483097`\spad{name(x)} returns the symbol
483143`\spad{name(f)} returns the external name of the file \spad{f}.
483194`\spad{name(f)} returns the name part of the file name.
483243`\spad{name(op)} returns the name of \spad{op}.
483289`\spad{name(s)} returns \spad{s} without its scripts.
483364`\spad{nand(a,{}b)} returns the logical {\em nand} of bit aggregates \axiom{a} and \axiom{\spad{b}}.
483408`\spad{nand(a,{}b)} returns the logical negation of \spad{a} and \spad{b}.
483447`\spad{nary?(op)} tests if \spad{op} has arbitrary arity.
483578`\spad{ncols(m)} returns the number of columns in the matrix \spad{m}.
483664`\spad{ncols(m)} returns the number of columns in the array \spad{m}
483796`\spad{negative?(u)} returns \axiom{\spad{true}} if every element of \spad{u} is negative,{} \axiom{\spad{false}} otherwise.
483854`\spad{negative?(x)} tests whether \spad{x} is strictly less than 0.
483998`\axiom{negative?(pol,{}aRoot)} answers if \axiom{pol} interpreted as \axiom{aRoot} is negative
484095`\spad{neglist(l)} returns only the negative elements of the list \spad{l}
484168`\spad{newLine()} sends a new line command to output.
484216`\spad{newReduc()} \undocumented
484273`\spad{newSubProgram(f)} asserts that from now on type declarations are part of subprogram \spad{f}.
484331`\spad{newTypeLists(x)} \undocumented
484388`\spad{new()} returns a new empty match result.
484443`\spad{new()} returns a new empty match result.
484492`\spad{new()} \undocumented
484531`\spad{new()} \undocumented
484582`\spad{new()} create a new,{} empty object. Use \spadfun{setPrologue!},{} \spadfun{setFormula!} and \spadfun{setEpilogue!} to set the various components of this object.
484627`\spad{new()} returns a new symbol whose name starts with \%.
484659`\spad{new()} create a new,{} empty object. Use \spadfun{setPrologue!},{} \spadfun{setTex!} and \spadfun{setEpilogue!} to set the various components of this object.
484694`\spad{new(s)} returns a new symbol whose name starts with \%\spad{s}.
484787`\spad{new(n,{}x)} returns \axiom{fill!(new \spad{n},{}\spad{x})}.
484851`\spad{new(m,{}n,{}r)} is an \spad{m}-by-\spad{n} array all of whose entries are \spad{r}
484954`\spad{new(d,{}pref,{}e)} constructs the name of a new writable file with \spad{d} as its directory,{} \spad{pref} as a prefix of its name and \spad{e} as its extension. When \spad{d} or \spad{t} is the empty string,{} a default is used. An error occurs if a new file cannot be written in the given directory.
485016`\spad{nextColeman(alpha,{}beta,{}C)} generates the next Coleman matrix of column sums {\em alpha} and row sums {\em beta} according to the lexicographical order from bottom-to-top. The first Coleman matrix is achieved by {\em C=new(1,{}1,{}0)}. Also,{} {\em new(1,{}1,{}0)} indicates that \spad{C} is the last Coleman matrix.
485141`\spad{nextIrreduciblePoly(f)} yields the next monic irreducible polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or "failed" if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. Also,{} \spad{f < g} if the number of monomials of \spad{f} is less than
485141`-- this number for \spad{g}. If \spad{f} and \spad{g} have the same number of monomials,{} the lists of exponents are compared lexicographically. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of {\em GF} given by {\em lookup}.
485564`\spad{nextItem(x)} returns the next item,{} or "failed" if domain is exhausted.
485624`\spad{nextLatticePermutation(lambda,{}lattP,{}constructNotFirst)} generates the lattice permutation according to the proper partition {\em lambda} succeeding the lattice permutation {\em lattP} in lexicographical order as long as {\em constructNotFirst} is \spad{true}. If {\em constructNotFirst} is \spad{false},{} the first lattice permutation is returned. The result {\em nil} i
485624`--ndicates that {\em lattP} has no successor.
485750`\spad{nextNormalPoly(f)} yields the next normal polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or "failed" if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. Also,{} \spad{f < g} if the {\em lookup} of the coefficient of the term of degree {\em n-1} o
485750`--f \spad{f} is less than that for \spad{g}. In case these numbers are equal,{} \spad{f < g} if if the number of monomials of \spad{f} is less that for \spad{g} or if the list of exponents of \spad{f} are lexicographically less than the corresponding list for \spad{g}. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of {\em GF} given by {\em lookup}.
485893`\spad{nextNormalPrimitivePoly(f)} yields the next normal primitive polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or "failed" if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. Also,{} \spad{f < g} if the {\em lookup} of the constant term of 
485893`--\spad{f} is less than this number for \spad{g} or if {\em lookup} of the coefficient of the term of degree {\em n-1} of \spad{f} is less than this number for \spad{g}. Otherwise,{} \spad{f < g} if the number of monomials of \spad{f} is less than that for \spad{g} or if the lists of exponents for \spad{f} are lexicographically less than those for \spad{g}. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of t
485893`--he elements of {\em GF} given by {\em lookup}. This operation is equivalent to nextPrimitiveNormalPoly(\spad{f}).
486045`\spad{nextPartition(gamma,{}part,{}number)} generates the partition of {\em number} which follows {\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\em gamma}. the first partition is achieved by {\em part=[]}. Also,{} {\em []} indicates that {\em part} is the last partitio
486045`--n.
486166`\spad{nextPartition(gamma,{}part,{}number)} generates the partition of {\em number} which follows {\em part} according to the right-to-left lexicographical order. The partition has the property that its components do not exceed the corresponding components of {\em gamma}. The first partition is achieved by {\em part=[]}. Also,{} {\em []} indicates that {\em part} is the last partit
486166`--ion.
486289`\spad{nextPrime(n)} returns the smallest prime strictly larger than \spad{n}
486344`\spad{nextPrimitiveNormalPoly(f)} yields the next primitive normal polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or "failed" if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. Also,{} \spad{f < g} if the {\em lookup} of the constant term of 
486344`--\spad{f} is less than this number for \spad{g} or,{} in case these numbers are equal,{} if the {\em lookup} of the coefficient of the term of degree {\em n-1} of \spad{f} is less than this number for \spad{g}. If these numbers are equals,{} \spad{f < g} if the number of monomials of \spad{f} is less than that for \spad{g},{} or if the lists of exponents for \spad{f} are lexicographically less than those for \spad{g}. If these lists are also equal,{} the lists of coefficients are coefficients a
486344`--ccording to the lexicographic ordering induced by the ordering of the elements of {\em GF} given by {\em lookup}. This operation is equivalent to nextNormalPrimitivePoly(\spad{f}).
486496`\spad{nextPrimitivePoly(f)} yields the next primitive polynomial over a finite field {\em GF} of the same degree as \spad{f} in the following order,{} or "failed" if there are no greater ones. Error: if \spad{f} has degree 0. Note: the input polynomial \spad{f} is made monic. Also,{} \spad{f < g} if the {\em lookup} of the constant term of \spad{f} is less th
486496`--an this number for \spad{g}. If these values are equal,{} then \spad{f < g} if if the number of monomials of \spad{f} is less than that for \spad{g} or if the lists of exponents of \spad{f} are lexicographically less than the corresponding list for \spad{g}. If these lists are also equal,{} the lists of coefficients are compared according to the lexicographic ordering induced by the ordering of the elements of {\em GF} given by {\em lookup}.
486642`\spad{nextSublist(n,{}k)} returns a list of \spad{k}-subsets of {1,{} ...,{} \spad{n}}.
486749`\spad{nextSubsetGray(ww,{}n)} returns a vector {\em vv} whose components have the following meanings:\begin{items} \item {\em vv.1}: a vector of length \spad{n} whose entries are 0 or 1. This \indented{3}{can be interpreted as a code for a subset of the set 1,{}...,{}\spad{n};} \indented{3}{{\em vv.1} differs from {\em ww.1} by exactly one entry;} \item {\em vv.2.1} is the number of the entry of {\e
486749`--m vv.1} which \indented{3}{will be changed next time;} \item {\em vv.2.1 = n} means that {\em vv.1} is the last subset; \indented{3}{trying to compute nextSubsetGray(\spad{vv}) if {\em vv.2.1 = n}} \indented{3}{will produce an error!} \end{items} The other components of {\em vv.2} are needed to compute nextSubsetGray efficiently. Note: this is an implementation of [Williamson,{} Topic II,{} 3.54,{} \spad{p}. 112] for the special case {\em r1 = r2 = ... = rn = 2}; Note: nextSubsetGray produces 
486749`--a side-effect,{} \spadignore{i.e.} {\em nextSubsetGray(vv)} and {\em vv := nextSubsetGray(vv)} will have the same effect.
486854`\spad{next(l)} returns the doubly-linked aggregate beginning with its next element. Error: if \spad{l} has no next element. Note: \axiom{next(\spad{l}) = rest(\spad{l})} and \axiom{previous(next(\spad{l})) = \spad{l}}.
486907`\axiom{\spad{nextsousResultant2}(\spad{P},{} \spad{Q},{} \spad{Z},{} \spad{s})} returns the subresultant \axiom{\spad{S_}{\spad{e}-1}} where \axiom{\spad{P} ~ \spad{S_d},{} \spad{Q} = \spad{S_}{\spad{d}-1},{} \spad{Z} = S_e,{} \spad{s} = \spad{lc}(\spad{S_d})}
486997`\axiom{\spad{nextsubResultant2}(\spad{p},{}\spad{q},{}\spad{z},{}\spad{s})} is the multivariate version of the operation \axiomOpFrom{\spad{next_sousResultant2}}{PseudoRemainderSequence} from the \axiomType{PseudoRemainderSequence} constructor.
487103`\spad{nilFactor(base,{}exponent)} creates a factored object with a single factor with no information about the kind of \spad{base} (flag = "nil").
487155`\spad{nil()} returns the empty list.
487188`\spad{nlde(u)} solves a first order non-linear differential equation described by \spad{u} of the form \spad{[[b<0,{}0>,{}b<0,{}1>,{}...],{}[b<1,{}0>,{}b<1,{}1>,{}.],{}...]}. the differential equation has the form \spad{y' = sum(i=0 to infinity,{}j=0 to infinity,{}b<i,{}j>*(x**i)*(y**j))}.
487303`\spad{noKaratsuba(a,{}b)} returns \spad{a*b} without using Karatsuba\spad{'s} trick at all.
487385`\spad{noLinearFactor?(p)} returns \spad{true} if \spad{p} can be shown to have no linear factor by a theorem of Lehmer,{} \spad{false} else. \spad{I} insist on the fact that \spad{false} does not mean that \spad{p} has a linear factor.
487625`\spad{node?(u,{}v)} tests if node \spad{u} is contained in node \spad{v} (either as a child,{} a child of a child,{} etc.).
487702`\axiom{nodeOf?(\spad{s},{}a)} returns \spad{true} iff some node of \axiom{a} is equal to \axiom{\spad{s}}
487776`\spad{node(left,{}v,{}right)} creates a binary tree with value \spad{v},{} a binary tree \spad{left},{} and a binary tree \spad{right}.
488002`\spad{nodes(u)} returns a list of all of the nodes of aggregate \spad{u}.
488059`\spad{nonLinearPart(l)} returns the list of non-linear functions of \axiom{\spad{l}}.
488167`\spad{nonQsign(r)} \undocumented
488235`\spad{nonSingularModel(u)} returns the equations in \spad{u1},{}...,{}un of an affine non-singular model for the curve.
488332`\spad{nonSingularModel(u)} returns the equations in \spad{u1},{}...,{}un of an affine non-singular model for the curve.
488438`\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.
488531`\spad{noncommutativeJordanAlgebra?()} tests if the algebra is flexible and Jordan admissible.
488660`\spad{nor(a,{}b)} returns the logical {\em nor} of bit aggregates \axiom{a} and \axiom{\spad{b}}.
488703`\spad{nor(a,{}b)} returns the logical negation of \spad{a} or \spad{b}.
488741`\spad{normDeriv2 should} be local
488870`\spad{normFactors(x)} \undocumented
488954`\axiom{normInvertible?(\spad{p},{}\spad{ts})} is an internal subroutine,{} exported only for developement.
489339`\spad{norm(p)} determines sum of absolute values of coefficients Note: this function depends on \spadfunFrom{abs}{Complex}.
489398`\spad{norm(I)} returns the norm of the ideal \spad{I}.
489451`\spad{norm(f)} returns the norm of the module \spad{f}.
489508`\spad{norm q} returns the norm of \spad{q},{} \spadignore{i.e.} the product of all the conjugates of \spad{q}.
489578`\spad{norm(a)} computes the norm of \spad{a} with respect to the field considered as an algebra with 1 over the ground field \spad{F}.
489638`\spad{norm(x)} returns \spad{x} * conjugate(\spad{x})
489684`\spad{norm(a)} returns the determinant of the regular representation of \spad{a} with respect to any basis.
489735`\spad{norm(o)} returns the norm of an octonion,{} equal to the sum of the squares of its coefficients.
489782`\spad{norm(q)} computes the norm of \spad{q} (the sum of the squares of the components).
489831`\spad{norm x} returns the same as absolute value.
489949`\spad{norm(p,{}k)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernel \spad{k}
490065`\spad{norm(p,{}l)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernels \spad{l}
490187`\spad{norm(f,{}p)} returns the \spad{lp} norm of the polynomial \spad{f}.
490272`\spad{norm(x,{}n)} \undocumented{} See \axiomFunFrom{norm}{FiniteAlgebraicExtensionField}
490367`\spad{norm(f,{}k)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernel \spad{k}
490427`\spad{norm(f,{}l)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernels \spad{l}
490493`\spad{norm(p,{}k)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernel \spad{k}
490604`\spad{norm(p,{}l)} computes the norm of the polynomial \spad{p} with respect to the extension generated by kernels \spad{l}
490721`\spad{norm(f,{}k)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernel \spad{k}
490776`\spad{norm(f,{}l)} computes the norm of the algebraic number \spad{f} with respect to the extension generated by kernels \spad{l}
490837`\spad{norm(a,{}d)} computes the norm of \spad{a} with respect to the field of extension degree \spad{d} over the ground field of size. Error: if \spad{d} does not divide the extension degree of \spad{a}. Note: norm(a,{}\spad{d}) = reduce(*,{}[a**(\spad{q**}(d*i)) for \spad{i} in 0..\spad{n/d}])
490927`\spad{normal01()} \undocumented
491051`\spad{normal?(f)} tests whether the polynomial \spad{f} over a finite field is normal,{} \spadignore{i.e.} its roots are linearly independent over the field.
491148`\spad{normal?(x)} \undocumented{} See \axiomFunFrom{normal?}{FiniteAlgebraicExtensionField}
491227`\spad{normal?(a)} tests whether the element \spad{a} is normal over the ground field \spad{F},{} \spadignore{i.e.} \spad{a**(q**i),{} 0 <= i <= extensionDegree()-1} is an \spad{F}-basis,{} where \spad{q = size()\$F}. Implementation according to Lidl/Niederreiter: Theorem 2.39.
491309`\spad{normalDenom(f,{} D)} returns the product of all the normal factors of \spad{denom(f)}. \spad{D} is the derivation to use.
491392`\spad{normalDeriv(poly,{}i)} computes the \spad{i}th derivative of \spad{poly} divided by i!.
491518`\spad{normalElement()} returns a element,{} normal over the ground field \spad{F},{} \spadignore{i.e.} \spad{a**(q**i),{} 0 <= i < extensionDegree()} is an \spad{F}-basis,{} where \spad{q = size()\$F}. At the first call,{} the element is computed by \spadfunFrom{createNormalElement}{FiniteAlgebraicExtensionField} then cached in a global variable. On subsequent calls,{} the element is retrieved by referencing the global var
491518`--iable.
491599`\spad{normalElement(n)} \undocumented{} See \axiomFunFrom{normalElement}{FiniteAlgebraicExtensionField}
491692`\spad{normalForm(poly,{}gb)} reduces the polynomial \spad{poly} modulo the precomputed groebner basis \spad{gb} giving a canonical representative of the residue class.
491794`\spad{normalForm(M,{} sig,{} der)} returns \spad{[R,{} A,{} A^{-1}]} such that the pseudo-linear operator whose matrix in the basis \spad{y} is \spad{M} had matrix \spad{R} in the basis \spad{z = A y}. \spad{der} is a \spad{sig}-derivation.
491928`\spad{normal(f,{}g)} \undocumented
491999`\spad{normalise(v)} returns the column vector \spad{v} divided by its euclidean norm; when possible,{} the vector \spad{v} is expressed in terms of radicals.
492190`\spad{normalizeAtInfinity(v)} makes \spad{v} normal at infinity.
492282`\axiom{normalizeIfCan(\spad{ts})} returns \axiom{\spad{ts}} in an normalized shape if \axiom{\spad{ts}} is zero-dimensional.
492359`\spad{normalize(f)} rewrites \spad{f} using the least possible number of real algebraically independent kernels.
492430`\spad{normalize(x)} normalizes \spad{x} at current precision.
492469`\spad{normalize(f,{} x)} rewrites \spad{f} using the least possible number of real algebraically independent kernels involving \spad{x}.
492547`\axiom{normalize(\spad{p},{}\spad{ts})} normalizes \axiom{\spad{p}} \spad{w}.\spad{r}.\spad{t} \spad{ts}.
492709`\axiom{normalized?(\spad{ts})} returns \spad{true} iff for every axiom{\spad{p}} in axiom{\spad{ts}} we have \axiom{normalized?(\spad{p},{}us)} where \axiom{us} is \axiom{collectUnder(\spad{ts},{}mvar(\spad{p}))}.
493004`\axiom{normalized?(\spad{p},{}\spad{ts})} returns \spad{true} iff \axiom{\spad{p}} and all its iterated initials have degree zero \spad{w}.\spad{r}.\spad{t}. the main variables of the polynomials of \axiom{\spad{ts}}
493077`\axiom{normalized?(\spad{q},{}\spad{lp})} returns \spad{true} iff \axiom{normalized?(\spad{q},{}\spad{p})} holds for every \axiom{\spad{p}} in \axiom{\spad{lp}}.
493161`\axiom{normalized?(a,{}\spad{b})} returns \spad{true} iff \axiom{a} and its iterated initials have degree zero \spad{w}.\spad{r}.\spad{t}. the main variable of \axiom{\spad{b}}
493239`\axiom{normalizedAssociate(\spad{p},{}\spad{ts})} returns a normalized polynomial \axiom{\spad{n}} \spad{w}.\spad{r}.\spad{t}. \spad{ts} such that \axiom{\spad{n}} and \axiom{\spad{p}} are associates \spad{w}.\spad{r}.\spad{t} \spad{ts} and assuming that \axiom{\spad{p}} is invertible \spad{w}.\spad{r}.\spad{t} \spad{ts}.
493316`\spad{normalizedDivide(n,{}d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \spadignore{e.g.} positive remainders
493417`\spad{normalizedDivide(n,{}d)} returns a normalized quotient and remainder such that consistently unique representatives for the residue class are chosen,{} \spadignore{e.g.} positive remainders
493587`\spad{not f} creates the equivalent prefix form.
493625`\spad{not(b)} returns the logical {\em not} of bit aggregate \axiom{\spad{b}}.
493665`\spad{not n} returns the negation of \spad{n}.
493700`\spad{not(n)} returns the bit-by-bit logical {\em not} of the single integer \spad{n}.
493741`\spad{notelem(ir)} returns the non-elementary part of an integration result
493825`\spad{npcoef }\undocumented
494137`\spad{nrows(m)} returns the number of rows in the matrix \spad{m}.
494223`\spad{nrows(m)} returns the number of rows in the array \spad{m}
494307`\spad{nsqfree should} be local
494512`\spad{nthCoef(x,{} n)} returns the coefficient of the n^th term of \spad{x}.
494581`\spad{nthExpon(l,{} n)} returns the exponent of the n^th monomial of \spad{l}.
494642`\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \spad{x}.
494700`\spad{nthExpon(x,{} n)} returns the exponent of the n^th monomial of \spad{x}.
494770`\spad{nthExpon(x,{} n)} returns the exponent of the \spad{n-th} monomial of \spad{x}.
494847`\spad{nthExponent(u,{}n)} returns the exponent of the \spad{n}th factor of \spadvar{\spad{u}}. If \spadvar{\spad{n}} is not a valid index for a factor (for example,{} less than 1 or too big),{} 0 is returned.
494907`\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \spad{x}.
494960`\spad{nthFactor(x,{} n)} returns the factor of the n^th monomial of \spad{x}.
495014`\spad{nthFactor(l,{} n)} returns the factor of the n^th monomial of \spad{l}.
495076`\spad{nthFactor(x,{} n)} returns the factor of the \spad{n-th} monomial of \spad{x}.
495137`\spad{nthFactor(u,{}n)} returns the base of the \spad{n}th factor of \spadvar{\spad{u}}. If \spadvar{\spad{n}} is not a valid index for a factor (for example,{} less than 1 or too big),{} 1 is returned. If \spadvar{\spad{u}} consists only of a unit,{} the unit is returned.
495189`\spad{nthFactor(x,{} n)} returns the factor of the n^th term of \spad{x}.
495260`\spad{nthFlag(u,{}n)} returns the information flag of the \spad{n}th factor of \spadvar{\spad{u}}. If \spadvar{\spad{n}} is not a valid index for a factor (for example,{} less than 1 or too big),{} "nil" is returned.
495344`\spad{nthFractionalTerm(p,{}n)} extracts the \spad{n}th fractional term from the partial fraction \spad{p}. This returns 0 if the index \spad{n} is out of range.
495412`\spad{nthRootIfCan(z,{}n)} returns the \spad{n}th root of \spad{z} if possible,{} and "failed" otherwise.
495515`\spad{nthRoot(f,{} n)} returns \spad{(p,{} r,{} [r1,{}...,{}rm])} such that the \spad{n}th-root of \spad{f} is equal to \spad{r * \spad{p}th-root(r1 * ... * rm)},{} where \spad{r1},{}...,{}\spad{rm} are distinct factors of \spad{f},{} each of which has an exponent smaller than \spad{p} in \spad{f}.
495756`\spad{nthRoot(x,{}n)} returns the \spad{n}th root of \spad{x}.
495811`\spad{nthr(p,{}n)} should be local but conditional
495941`\spad{null?(s)} is \spad{true} if \spad{s} is the \spad{S}-expression ().
496017`\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.
496139`\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.
496278`\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.
496380`\spad{nullSpace(m)} returns a basis for the null space of the matrix \spad{m}.
496467`\spad{nullSpace(m)}+ returns a basis for the null space of the matrix \spad{m}.
496569`\spad{null(u)} tests if list \spad{u} is the empty list.
496610`\spad{nullary?(op)} tests if \spad{op} is nullary.
496661`\spad{nullary A} changes its argument into a \indented{1}{nullary function.}
496713`\spad{nullity(m)} returns the mullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.
496806`\spad{nullity(m)} returns the mullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.
496915`\spad{nullity(m)} returns the nullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.
497009`\spad{nullity(m)} returns the nullity of the matrix \spad{m}. This is the dimension of the null space of the matrix \spad{m}.
497118`\spad{numFunEvals3D()} returns the number of points computed.
497165`\spad{numFunEvals()} returns the number of points computed
497208`\spad{number?(f)} tests if \spad{f} is rational
497279`\spad{numberOfChildren(x)} \undocumented
497349`\spad{numberOfComponents()} returns the number of absolutely irreducible components.
497441`\spad{numberOfComponents()} returns the number of absolutely irreducible components.
497530`\spad{numberOfComponents(s)} returns the number of distinct object components in the indicated \spadtype{ThreeSpace},{} \spad{s},{} such as points,{} curves,{} polygons,{} and constructs.
497610`\spad{numberOfComposites(s)} returns the number of supercomponents,{} or composites,{} in the \spadtype{ThreeSpace},{} \spad{s}; Composites are arbitrary groupings of otherwise distinct and unrelated components; A \spadtype{ThreeSpace} need not have any composites defined at all and,{} outside of the requirement that no component can belong to more than one composite at a time,{} the definition and interpretation of composi
497610`--tes are unrestricted.
497690`\spad{numberOfComputedEntries(st)} returns the number of explicitly computed entries of stream \spad{st} which exist immediately prior to the time this function is called.
497776`\spad{numberOfCycles(p)} returns the number of non-trivial cycles of the permutation \spad{p}.
497845`\spad{numberOfDivisors(n)} returns the number of integers between 1 and \spad{n} (inclusive) which divide \spad{n}. The number of divisors of \spad{n} is often denoted by \spad{tau(n)}.
497924`\spad{numberOfFactors(ddfactorization)} returns the number of factors of the polynomial \spad{f} modulo \spad{p} where \spad{ddfactorization} is the distinct degree factorization of \spad{f} computed by \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} for some prime \spad{p}.
498041`\spad{numberOfFactors(u)} returns the number of factors in \spadvar{\spad{u}}.
498108`\spad{numberOfFractionalTerms(p)} computes the number of fractional terms in \spad{p}. This returns 0 if there is no fractional part.
498179`\spad{numberOfHues()} returns the number of total hues,{} set in totalHues.
498232`\spad{numberOfImproperPartitions(n,{}m)} computes the number of partitions of the nonnegative integer \spad{n} in \spad{m} nonnegative parts with regarding the order (improper partitions). Example: {\em numberOfImproperPartitions (3,{}3)} is 10,{} since {\em [0,{}0,{}3],{} [0,{}1,{}2],{} [0,{}2,{}1],{} [0,{}3,{}0],{} [1,{}0,{}2],{} [1,{}1,{}1],{} [1,{}2,{}0],{} [2,{}0,{}1],{} [2,{}1,{}0],{} [3,{}0,{}
498232`--0]} are the possibilities. Note: this operation has a recursive implementation.
498336`\spad{numberOfIrreduciblePoly(n)}\$FFPOLY(\spad{GF}) yields the number of monic irreducible univariate polynomials of degree \spad{n} over the finite field {\em GF}.
498442`\spad{numberOfMonomials(f)} is the number of non-zero coefficients with respect to the canonical basis.
498515`\spad{numberOfMonomials(p)} gives the number of non-zero monomials in polynomial \spad{p}.
498601`\spad{numberOfMonomials(x)} returns the number of monomials of \spad{x}.
498681`\spad{numberOfNormalPoly(n)}\$FFPOLY(\spad{GF}) yields the number of normal polynomials of degree \spad{n} over the finite field {\em GF}.
498782`\spad{numberOfOperations(ode)} counts additions,{} multiplications,{} exponentiations and function calls in the input set of expressions.
498971`\spad{numberOfPrimitivePoly(n)}\$FFPOLY(\spad{GF}) yields the number of primitive polynomials of degree \spad{n} over the finite field {\em GF}.
499303`\spad{numer x} returns the numerator of \spad{x}.
499351`\spad{numer x} returns the numerator of \spad{x}.
499395`\spad{numer(f)} returns the numerator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.
499491`\spad{numer(1/d * (f1,{}...,{}fn))} = the vector \spad{[f1,{}...,{}fn]}.
499553`\spad{numer(x)} returns the numerator of the fraction \spad{x}.
499606`\spad{numer(f)} returns the numerator of \spad{f} viewed as a polynomial in the kernels over \spad{Z}.
499697`\spad{numer(f)} returns the numerator of \spad{f} viewed as a polynomial in the kernels over \spad{R} if \spad{R} is an integral domain. If not,{} then numer(\spad{f}) = \spad{f} viewed as a polynomial in the kernels over \spad{R}.
499894`\spad{numerator(f)} returns the numerator of \spad{f} converted to \%.
499955`\spad{numerator(x)} is the numerator of the fraction \spad{x} converted to \%.
500013`\spad{numerators(x)} returns the stream of numerators of the approximants of the continued fraction \spadvar{\spad{x}}. If the continued fraction is finite,{} then the stream will be finite.
500075`\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
500196`\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
500304`\spad{numericIfCan(x)} returns a real approximation of \spad{x},{} or "failed" if \axiom{\spad{x}} is not a constant.
500392`\spad{numericIfCan(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
500529`\spad{numericIfCan(x,{}n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
500653`\spad{numericIfCan(x,{}n)} returns a real approximation of \spad{x} up to \spad{n} decimal places,{} or "failed" if \axiom{\spad{x}} is not a constant.
500757`\spad{numeric(x)} returns a real approximation of \spad{x}.
500857`\spad{numeric(x)} returns a real approximation of \spad{x}.
500944`\spad{numeric(x)} returns a real approximation of \spad{x}.
501011`\spad{numeric(x)} returns a real approximation of \spad{x}.
501055`\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.
501171`\spad{numeric(x,{}n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.
501274`\spad{numeric(x,{}n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.
501357`\spad{numeric(x,{} n)} returns a real approximation of \spad{x} up to \spad{n} decimal places.
501417`\spad{numericalIntegration(args,{}hints)} performs the integration of the function given the strategy or method returned by \axiomFun{measure}.
501623`\spad{numericalIntegration(args,{}hints)} performs the integration of the function given the strategy or method returned by \axiomFun{measure}.
501834`\spad{numericalOptimization(args)} performs the optimization of the function given the strategy or method returned by \axiomFun{measure}.
502081`\spad{numericalOptimization(args)} performs the optimization of the function given the strategy or method returned by \axiomFun{measure}.
502222`\spad{obj(a)} essentially returns the original object that was converted to \spadtype{Any} except that the type is forced to be \spadtype{None}.
502255`\spad{objectOf(a)} returns a printable form of the original object that was converted to \spadtype{Any}.
502299`\spad{objects(s)} returns the \spadtype{ThreeSpace},{} \spad{s},{} in the form of a 3D object record containing information on the number of points,{} curves,{} polygons and constructs comprising the \spadtype{ThreeSpace}..
502467`\spad{oblateSpheroidal(a)} transforms from oblate spheroidal coordinates to Cartesian coordinates: \spad{oblateSpheroidal(a)} is a function which will map the point \spad{(\spad{xi},{}eta,{}phi)} to \spad{x = a*sinh(\spad{xi})*sin(eta)*cos(phi)},{} \spad{y = a*sinh(\spad{xi})*sin(eta)*sin(phi)},{} \spad{z = a*cosh(\spad{xi})*cos(eta)}.
502545`\spad{ocf2ocdf(a)} is a function to convert an \axiomType{OrderedCompletion Float} to an \axiomType{OrderedCompletion DoubleFloat}
502652`\spad{octon(qe,{}qE)} constructs an octonion from two quaternions using the relation {\em O = Q + QE}.
502718`\spad{octon(re,{}\spad{ri},{}rj,{}rk,{}rE,{}rI,{}rJ,{}rK)} constructs an octonion from scalars.
502827`\spad{odd? x} is \spad{true} if \spad{x} is an odd integer.
502906`\spad{odd?(n)} returns \spad{true} if and only if \spad{n} is odd.
502959`\spad{odd?(p)} returns \spad{true} if and only if \spad{p} is an odd permutation \spadignore{i.e.} {\em sign(p)} is {\em -1}.
503007`\spad{oddInfiniteProduct(f(x))} computes \spad{product(n=1,{}3,{}5...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
503097`\spad{oddInfiniteProduct(f(x))} computes \spad{product(n=1,{}3,{}5...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
503185`\spad{oddInfiniteProduct(f(x))} computes \spad{product(n=1,{}3,{}5...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
503271`\spad{oddInfiniteProduct(f(x))} computes \spad{product(n=1,{}3,{}5...,{}f(x**n))}. The series \spad{f(x)} should have constant coefficient 1.
503351`\spad{oddintegers(n)} returns \spad{[n,{}n+2,{}n+4,{}...]}.
503436`\spad{oddlambert(st)} computes \spad{f(x) + f(x**3) + f(x**5) + ...} if \spad{st} is a stream representing \spad{f(x)}. This function is used for computing infinite products. If \spad{f}(\spad{x}) is a power series with constant coefficient 1 then \spad{prod(f(x**(2*n-1)),{}n=1..infinity) = exp(oddlambert(log(f(x))))}.
503516`\spad{oddlambert(f(x))} returns \spad{f(x) + f(x^3) + f(x^5) + ...}. \indented{1}{\spad{f(x)} should have a zero constant coefficient.} \indented{1}{This function is used for computing infinite products.} \indented{1}{If \spad{f(x)} is a Taylor series with constant term 1,{} then} \indented{1}{\spad{product(n=1..infinity,{}f(x^(2*n-1)))=exp(log(oddlambert(f(x))))}.}
503587`\spad{ode1(f,{}c)} is the solution to \spad{y' = f(y)} such that \spad{y(a) = c}.
503671`\spad{ode2(f,{}c0,{}c1)} is the solution to \spad{y'' = f(y,{}y')} such that \spad{y(a) = c0} and \spad{y'(a) = c1}.
503764`\spad{ode(f,{}cl)} is the solution to \spad{y<n>=f(y,{}y',{}..,{}y<n-1>)} such that \spad{y<i>(a) = cl.i} for \spad{i} in 1..\spad{n}.
503859`\spad{omError(k,{}l)} creates an instance of OpenMathError.
504067`\spad{one?(a)} tests whether \spad{a} is the unit 1.
504114`\spad{one?(x)} tests if \spad{x} is equal to 1.
504154`\spad{one?(I)} tests whether the ideal \spad{I} is the unit ideal,{} \spadignore{i.e.} contains 1.
504226`\spad{oneDimensionalArray(l)} creates an array from a list of elements \spad{l}
504297`\spad{oneDimensionalArray(n,{}s)} creates an array from \spad{n} copies of element \spad{s}
504381`\spad{op(p)} creates a value in \$ equal to \spad{p} in \spad{P}.
504443`\spad{open?(t)} tests whether the given tube plot \spad{t} is open.
504493`\spad{open(s)} returns the file \spad{s} open for input.
504544`\spad{open(s,{}mode)} returns a file \spad{s} open for operation in the indicated mode: "input" or "output".
504602`\spad{operation(f)} returns the name of the operation represented by \spad{f}.
504933`\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}. Error: if \spad{op} is not an algebraic operator,{} that is,{} an \spad{n}th root or implicit algebraic operator.
505010`\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}; error if \spad{op} is not a combinatorial operator.
505091`\spad{operator(p)} returns an elementary operator with the same symbol as \spad{p}
505169`\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \spad{F}; error if \spad{op} is not a special function operator
505254`\spad{operator(op)} returns the Liouvillian operator based on \spad{op}
505333`\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \%.
505476`\spad{operator(s)} returns an operator with name \spad{s},{} with the appropriate semantics if \spad{s} is known. If \spad{s} is not known,{} the result has no semantics.
505539`\spad{operator(op(a1,{}...,{}an))} returns the operator op.
505592`\spad{operator(op)} returns a copy of \spad{op} with the domain-dependent properties appropriate for \%.
505662`\spad{operator(f)} makes \spad{f} into an operator with arbitrary arity.
505712`\spad{operator(f,{} n)} makes \spad{f} into an \spad{n}-ary operator.
505845`\spad{operators(f)} returns all the basic operators appearing in \spad{f},{} no matter what their levels are.
505960`\spad{opeval should} be local but conditional
506022`\spad{optAttributes(o)} is a function for supplying a list of attributes of an optimization problem.
506334`\spad{optimize(prob)} is a top level ANNA function to minimize a function or a set of functions with any constraints as defined within \axiom{\spad{prob}}. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}.
506429`\spad{optimize(f,{}start)} is a top level ANNA function to minimize a function,{} \axiom{\spad{f}},{} of one or more variables without constraints. \blankline The parameter \axiom{\spad{start}} is a list of the initial guesses of the values of the variables. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best 
506429`--\axiom{measure} and then optimize the function on that \axiom{domain}.
506525`\spad{optimize(lf,{}start)} is a top level ANNA function to minimize a set of functions,{} \axiom{\spad{lf}},{} of one or more variables without constraints \spadignore{i.e.} a least-squares problem. \blankline The parameter \axiom{\spad{start}} is a list of the initial guesses of the values of the variables. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} t
506525`--o get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}.
506627`\spad{optimize(prob,{}routines)} is a top level ANNA function to minimize a function or a set of functions with any constraints as defined within \axiom{\spad{prob}}. \blankline It iterates over the \axiom{domains} listed in \axiom{\spad{routines}} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the functio
506627`--n on that \axiom{domain}.
506736`\spad{optimize(f,{}start,{}lower,{}upper)} is a top level ANNA function to minimize a function,{} \axiom{\spad{f}},{} of one or more variables with simple constraints. The bounds on the variables are defined in \axiom{\spad{lower}} and \axiom{\spad{upper}}. \blankline The parameter \axiom{\spad{start}} is a list of the initial guesses of the value
506736`--s of the variables. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}.
506894`\spad{optimize(f,{}start,{}lower,{}cons,{}upper)} is a top level ANNA function to minimize a function,{} \axiom{\spad{f}},{} of one or more variables with the given constraints. \blankline These constraints may be simple constraints on the variables in which case \axiom{\spad{cons}} would be an empty list and the bounds on 
506894`--those variables defined in \axiom{\spad{lower}} and \axiom{\spad{upper}},{} or a mixture of simple,{} linear and non-linear constraints,{} where \axiom{\spad{cons}} contains the linear and non-linear constraints and the bounds on these are added to \axiom{\spad{upper}} and \axiom{\spad{lower}}. \blankline The parameter \axiom{\spad{start}} is a list of the initial guesses of the values of the variables. \blankline It iterates over the \axiom{domains} of \axiomType{NumericalOptimizationCategory
506894`--} to get the name and other relevant information of the best \axiom{measure} and then optimize the function on that \axiom{domain}.
507076`\spad{option?()} is not to be used at the top level; option? internally returns \spad{true} for drawing options which are indicated in a draw command,{} or \spad{false} for those which are not.
507136`\spad{option(l,{}s)} determines whether the indicated drawing option,{} \spad{s},{} is contained in the list of drawing options,{} \spad{l},{} which is defined by the draw command.
507226`\spad{option()} is not to be used at the top level; option determines internally which drawing options are indicated in a draw command.
507297`\spad{optional?(p)} tests if \spad{p} is a single matching variable which can match an identity.
507346`\spad{optional(x)} tells the pattern matcher that \spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation). Error: if \spad{x} is not a symbol.
507405`\spad{optional(x)} tells the pattern matcher that \spad{x} can match an identity (0 in a sum,{} 1 in a product or exponentiation)..
507481`\spad{options(v)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and returns a list containing the draw options from the domain \spadtype{DrawOption} for \spad{v}.
507549`\spad{options(v)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport} and returns a list of all the draw options from the domain \spad{DrawOption} which are being used by \spad{v}.
507619`\spad{options(v,{}lopt)} takes the given two-dimensional viewport,{} \spad{v},{} of the domain \spadtype{TwoDimensionalViewport} and returns \spad{v} with it\spad{'s} draw options modified to be those which are indicated in the given list,{} \spad{lopt} of domain \spadtype{DrawOption}.
507690`\spad{options(v,{}lopt)} takes the viewport,{} \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport} and sets the draw options being used by \spad{v} to those indicated in the list,{} \spad{lopt},{} which is a list of options from the domain \spad{DrawOption}.
507763`\spad{optpair(l)} returns \spad{l} has the form \spad{[a,{} b]} and a is optional,{} and "failed" otherwise.
507833`\spad{f or g} creates the equivalent infix form.
507873`\spad{a or b} returns the logical {\em or} of bit aggregates \axiom{a} and \axiom{\spad{b}}.
507915`\spad{a or b} returns the logical inclusive {\em or} of Boolean \spad{a} and \spad{b}.
507952`\spad{orbit(gp,{}ls)} returns the orbit of the ordered list {\em ls} under the group {\em gp}. Note: return type is \spad{L} \spad{L} \spad{S} temporarily because FSET \spad{L} \spad{S} has an error.
508019`\spad{orbit(p,{} el)} returns the orbit of {\em el} under the permutation \spad{p},{} \spadignore{i.e.} the set which is given by applications of the powers of \spad{p} to {\em el}.
508077`\spad{orbit(gp,{}el)} returns the orbit of the element {\em el} under the group {\em gp},{} \spadignore{i.e.} the set of all points gained by applying each group element to {\em el}.
508132`\spad{orbit(gp,{}els)} returns the orbit of the unordered set {\em els} under the group {\em gp}.
508197`\spad{orbits(gp)} returns the orbits of the group {\em gp},{} \spadignore{i.e.} it partitions the (finite) of all moved points.
508256`\spad{ord(c)} provides an integral code corresponding to the character \spad{c}. It is always \spad{true} that \spad{char ord c = c}.
508380`\spad{order(x)} \undocumented
508478`\spad{order(f)} \undocumented
508599`\spad{order(f)} \undocumented
508879`\spad{order(x)} \undocumented
508937`\spad{order(x)} returns the order of a power series \spad{x},{} \indented{1}{\spadignore{i.e.} the degree of the first non-zero term of the series.}
509006`\spad{order(f)} is the degree of the lowest order non-zero term in \spad{f}. This will result in an infinite loop if \spad{f} has no non-zero terms.
509080`\spad{order x} is the order of magnitude of \spad{x}. Note: \spad{base ** order x <= |x| < base ** (1 + order x)}.
509134`\spad{order(p)} returns the order of the differential polynomial \spad{p},{} which is the maximum number of differentiations of a differential indeterminate,{} among all those appearing in \spad{p}.
509219`\spad{order(v)} returns \spad{n} if \spad{v} is the \spad{n}-th derivative of any differential indeterminate.
509296`\spad{order(x)} returns the exponent of the highest power of \spad{p} dividing \spad{x}.
509365`\spad{order(p)} returns the order of a permutation \spad{p} as a group element.
509425`\spad{order(gp)} returns the order of the group {\em gp}.
509490`\spad{order(a)} computes the order of an element in the multiplicative group of the field. Error: if \spad{a} is 0.
509579`\spad{order(b)} computes the order of an element \spad{b} in the multiplicative group of the field. Error: if \spad{b} equals 0.
509801`\spad{order(x,{}n)} returns the minimum of \spad{n} and the order of \spad{x}.
509889`\spad{order(f,{}n) = min(m,{}n)},{} where \spad{m} is the degree of the lowest order non-zero term in \spad{f}.
509969`\spad{order(p,{}s)} returns the order of the differential polynomial \spad{p} in differential indeterminate \spad{s}.
510056`\spad{order(f,{}x)} returns the order of \spad{f} viewed as a series in \spad{x} may result in an infinite loop if \spad{f} has no non-zero terms.
510148`\spad{order(p,{} q)} returns the largest \spad{n} such that \spad{q**n} divides polynomial \spad{p} \spadignore{i.e.} the order of \spad{p(x)} at \spad{q(x)=0}.
510249`\spad{order(f,{}u,{}g)} \undocumented
510365`\spad{order(f,{}x,{}n)} returns \spad{min(n,{}order(f,{}x))}.
510476`\spad{orthonormalBasis(m)} returns the orthogonal matrix \spad{b} such that \spad{b*m*(inverse b)} is diagonal. Error: if \spad{m} is not a symmetric matrix.
510662`\spad{outerProduct(u,{}v)} constructs the matrix whose (\spad{i},{}\spad{j})\spad{'}th element is \spad{u}(\spad{i})\spad{*v}(\spad{j}).
510737`\spad{outlineRender(v,{}s)} displays the polygon outline showing either triangularized surface or a quadrilateral surface outline depending on the whether the \spadfun{diagonals} function has been set,{} for the given three-dimensional viewport \spad{v} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or does not display the polygon outline if \spad{s} is "off".
510808`\axiom{outputArgs(\spad{s1},{}\spad{s2},{}\spad{p},{}\spad{ts})} is an internal subroutine,{} exported only for developement.
510893`\spad{outputAsFortran()} generates the default code for \spadtype{ASP12}.
510944`\spad{outputAsFortran()} generates the default code for \spadtype{ASP29}.
510995`\spad{outputAsFortran()} generates the default code for \spadtype{ASP33}.
511046`\spad{outputAsFortran(fn)} \undocumented{}
511108`\spad{outputAsFortran(l)} sends (for each expression in the list \spad{l}) output in FORTRAN format to the destination defined by \spadsyscom{set output fortran}.
511184`\spad{outputAsFortran(o)} sends output \spad{o} in FORTRAN format.
511254`\axiom{outputAsFortran(\spad{u})} translates \axiom{\spad{u}} into a legal FORTRAN subprogram.
511318`\spad{outputAsFortran(v,{}o)} sends output \spad{v} = \spad{o} in FORTRAN format to the destination defined by \spadsyscom{set output fortran}.
511395`\spad{outputAsScript(l)} sends (for each expression in the list \spad{l}) output in Script Formula Formatter format to the destination defined. by \spadsyscom{set output forumula}.
511470`\spad{outputAsScript(o)} sends output \spad{o} in Script Formula Formatter format to the destination defined by \spadsyscom{set output formula}.
511539`\spad{outputAsTex(l)} sends (for each expression in the list \spad{l}) output in Tex format to the destination as defined by \spadsyscom{set output tex}.
511611`\spad{outputAsTex(o)} sends output \spad{o} in Tex format to the destination defined by \spadsyscom{set output tex}.
511677`\spad{outputFixed()} sets the output mode to fixed point notation; the output will contain a decimal point.
511718`\spad{outputFixed(n)} sets the output mode to fixed point notation,{} with \spad{n} digits displayed after the decimal point.
511777`\spad{outputFloating()} sets the output mode to floating (scientific) notation,{} \spadignore{i.e.} \spad{mantissa * 10 exponent} is displayed as \spad{0.mantissa E exponent}.
511821`\spad{outputFloating(n)} sets the output mode to floating (scientific) notation with \spad{n} significant digits displayed after the decimal point.
511883`\spad{outputForm(sf)} creates an form for small float \spad{sf}.
511937`\spad{outputForm(n)} creates an form for integer \spad{n}.
511987`\spad{outputForm(s)} creates an form for string \spad{s}.
512036`\spad{outputForm(s)} creates an form for symbol \spad{s}.
512085`\spad{outputForm(p,{}var)} converts the SparseUnivariatePolynomial \spad{p} to an output form (see \spadtype{OutputForm}) printed as a polynomial in the output form variable.
512168`\spad{outputForm(p,{} x)} returns the output form of \spad{p} using \spad{x} for the otherwise anonymous variable.
512267`\spad{outputForm(l,{} fop,{} fexp,{} unit)} converts the monoid element represented by \spad{l} to an \spadtype{OutputForm}. Argument unit is the output form for the \spadignore{unit} of the monoid (\spadignore{e.g.} 0 or 1),{} \spad{fop(a,{} b)} is the output form for the monoid operation applied to \spad{a} and \spad{b} (\spadignore{e.g.} \spad{a + b},{} \spa
512267`--d{a * b},{} \spad{ab}),{} and \spad{fexp(a,{} n)} is the output form for the exponentiation operation applied to \spad{a} and \spad{n} (\spadignore{e.g.} \spad{n a},{} \spad{n * a},{} \spad{a ** n},{} \spad{a\^n}).
512411`\spad{outputGeneral()} sets the output mode (default mode) to general notation; numbers will be displayed in either fixed or floating (scientific) notation depending on the magnitude.
512454`\spad{outputGeneral(n)} sets the output mode to general notation with \spad{n} significant digits displayed.
512515`\spad{outputList(l)} displays the concatenated components of the list \spad{l} on the ``algebra output\spad{''} stream,{} as defined by \spadsyscom{set output algebra}; quotes are stripped from strings.
512572`\spad{outputMeasure(n)} rounds \spad{n} to 3 decimal places and outputs it as a string
512641`\spad{outputSpacing(n)} inserts a space after \spad{n} (default 10) digits on output; outputSpacing(0) means no spaces are inserted.
512702`\spad{output(x)} displays the output form \spad{x} on the ``algebra output\spad{''} stream,{} as defined by \spadsyscom{set output algebra}.
512756`\spad{output(s)} displays the string \spad{s} on the ``algebra output\spad{''} stream,{} as defined by \spadsyscom{set output algebra}.
512806`\spad{output(n,{}st)} computes and displays the first \spad{n} entries of \spad{st}.
512874`\spad{output(s,{}x)} displays the string \spad{s} followed by the form \spad{x} on the ``algebra output\spad{''} stream,{} as defined by \spadsyscom{set output algebra}.
512935`\spad{over(f,{}g)} creates a form for the vertical fraction of \spad{f} over \spad{g}.
512977`\spad{overbar(f)} creates the form \spad{f} with an overbar.
513019`\spad{overlabel(x,{}f)} creates the form \spad{f} with \spad{"x} overbar" over the top.
513066`\spad{overlap(x,{} y)} returns \spad{[l,{} m,{} r]} such that \spad{x = l * m},{} \spad{y = m * r} and \spad{l} and \spad{r} have no overlap,{} \spadignore{i.e.} \spad{overlap(l,{} r) = [l,{} 1,{} r]}.
513137`\spad{overlap(x,{} y)} returns \spad{[l,{} m,{} r]} such that \spad{x = l * m} and \spad{y = m * r} hold and such that \spad{l} and \spad{r} have no overlap,{} that is \spad{overlap(l,{} r) = [l,{} 1,{} r]}.
513215`\spad{overset?(s,{}sl)} returns \spad{true} if \spad{s} properly a sublist of a member of \spad{sl}; otherwise it returns \spad{false}
513315`\spad{pToDmp(p)} converts \spad{p} from a \spadtype{POLY} to a \spadtype{DMP}.
513408`\spad{pToHdmp(p)} converts \spad{p} from a \spadtype{POLY} to a \spadtype{HDMP}.
513513`\spad{pack!(f)} reorganizes the file \spad{f} on disk to recover unused space.
513565`\spad{pack!(f)} reorganizes the file \spad{f} on disk to recover unused space.
513602`\spad{packageCall(f)} returns the input form corresponding to \spad{f}\$\spad{R}.
513671`\spad{pade(nd,{}dd,{}s)} computes the quotient of polynomials (if it exists) with numerator degree at most \spad{nd} and denominator degree at most \spad{dd} which matches the series \spad{s} to order \spad{nd + dd}.
513845`\spad{pade(nd,{}dd,{}ns,{}ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).
513966`\spad{pade(nd,{}dd,{}ns,{}ds)} computes the approximant as a quotient of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).
514171`\spad{padecf(nd,{}dd,{}ns,{}ds)} computes the approximant as a continued fraction of polynomials (if it exists) for arguments \spad{nd} (numerator degree of approximant),{} \spad{dd} (denominator degree of approximant),{} \spad{ns} (numerator series of function),{} and \spad{ds} (denominator series of function).
514303`\spad{padicFraction(q)} expands the fraction \spad{p}-adically in the primes \spad{p} in the denominator of \spad{q}. For example,{} \spad{padicFraction(3/(2**2)) = 1/2 + 1/(2**2)}. Use \spadfunFrom{compactFraction}{PartialFraction} to return to compact form.
514359`\spad{padicallyExpand(p,{}x)} is a utility function that expands the second argument \spad{x} \spad{``p}-adically\spad{''} in the first.
514445`\spad{pair?(s)} is \spad{true} if \spad{s} has is a non-null Lisp list.
514521`\spad{palgLODE0(op,{} g,{} x,{} y,{} d,{} p)} returns the solution of \spad{op f = g}. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2y(x)\^2 = P(x)}.
514735`\spad{palgLODE0(op,{}g,{}x,{}y,{}z,{}t,{}c)} returns the solution of \spad{op f = g} Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{f(x,{}y)dx = c f(t,{}y) dy}; \spad{c} and \spad{t} are rational functions of \spad{y}.
514969`\spad{palgLODE(op,{} g,{} kx,{} y,{} x)} returns the solution of \spad{op f = g}. \spad{y} is an algebraic function of \spad{x}.
515161`\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} d,{} p)} returns a function \spad{z(x,{}y)} such that \spad{dz/dx + n * df/dx z(x,{}y) = g(x,{}y)} if such a \spad{z} exists,{} and "failed" otherwise. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2y(x)\^2 = P(x)}. Argument \spad{foo},{} called by \spad{foo(a,{} b,{} x)},
515161`--{} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}.
515321`\spad{palgRDE0(f,{} g,{} x,{} y,{} foo,{} t,{} c)} returns a function \spad{z(x,{}y)} such that \spad{dz/dx + n * df/dx z(x,{}y) = g(x,{}y)} if such a \spad{z} exists,{} and "failed" otherwise. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{f(x,{}y)dx = c f(t,{}y) dy}; \spad{c} and \spad{t} are ration
515321`--al functions of \spad{y}. Argument \spad{foo},{} called by \spad{foo(a,{} b,{} x)},{} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}.
515501`\spad{palgRDE(nfp,{} f,{} g,{} x,{} y,{} foo)} returns a function \spad{z(x,{}y)} such that \spad{dz/dx + n * df/dx z(x,{}y) = g(x,{}y)} if such a \spad{z} exists,{} "failed" otherwise; \spad{y} is an algebraic function of \spad{x}; \spad{foo(a,{} b,{} x)} is a function that solves \spad{du/dx + n * da/dx u(x) = u(x)} for an unknown \spad{u(x)} not involving \spad{y}. \sp
515501`--ad{nfp} is \spad{n * df/dx}.
515634`\spad{palgextint0(f,{} x,{} y,{} g,{} d,{} p)} returns functions \spad{[h,{} c]} such that \spad{dh/dx = f(x,{}y) - c g},{} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2 y(x)\^2 = P(x)},{} or "failed" if no such functions exist.
515789`\spad{palgextint0(f,{} x,{} y,{} g,{} z,{} t,{} c)} returns functions \spad{[h,{} d]} such that \spad{dh/dx = f(x,{}y) - d g},{} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{f(x,{}y)dx = c f(t,{}y) dy},{} and \spad{c} and \spad{t} are rational functions of \spad{y}. Argument \spad{z} is a dummy variable not
515789`-- appearing in \spad{f(x,{}y)}. The operation returns "failed" if no such functions exist.
515964`\spad{palgextint(f,{} x,{} y,{} g)} returns functions \spad{[h,{} c]} such that \spad{dh/dx = f(x,{}y) - c g},{} where \spad{y} is an algebraic function of \spad{x}; returns "failed" if no such functions exist.
516090`\spad{palginfieldint(f,{} d)} returns an algebraic function \spad{g} such that \spad{dg = f} if such a \spad{g} exists,{} "failed" otherwise. Argument \spad{f} must be a pure algebraic function.
516186`\spad{palgint0(f,{} x,{} y,{} d,{} p)} returns the integral of \spad{f(x,{}y)dx} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2 y(x)\^2 = P(x)}.
516315`\spad{palgint0(f,{} x,{} y,{} z,{} t,{} c)} returns the integral of \spad{f(x,{}y)dx} where \spad{y} is an algebraic function of \spad{x} satisfying \spad{f(x,{}y)dx = c f(t,{}y) dy}; \spad{c} and \spad{t} are rational functions of \spad{y}. Argument \spad{z} is a dummy variable not appearing in \spad{f(x,{}y)}.
516464`\spad{palgint(f,{} x,{} y)} returns the integral of \spad{f(x,{}y)dx} where \spad{y} is an algebraic function of \spad{x}.
516564`\spad{palgintegrate(f,{} d)} integrates \spad{f} with respect to the derivation \spad{d}. Argument \spad{f} must be a pure algebraic function.
516662`\spad{palglimint0(f,{} x,{} y,{} [u1,{}...,{}un],{} d,{} p)} returns functions \spad{[h,{}[[\spad{ci},{} \spad{ui}]]]} such that the \spad{ui}\spad{'s} are among \spad{[u1,{}...,{}un]} and \spad{d(h + sum(\spad{ci} log(\spad{ui})))/dx = f(x,{}y)} if such functions exist,{} and "failed" otherwise. Argument \sp
516662`--ad{y} is an algebraic function of \spad{x} satisfying \spad{d(x)\^2y(x)\^2 = P(x)}.
516859`\spad{palglimint0(f,{} x,{} y,{} [u1,{}...,{}un],{} z,{} t,{} c)} returns functions \spad{[h,{}[[\spad{ci},{} \spad{ui}]]]} such that the \spad{ui}\spad{'s} are among \spad{[u1,{}...,{}un]} and \spad{d(h + sum(\spad{ci} log(\spad{ui})))/dx = f(x,{}y)} if such functions exist,{} and "failed
516859`--" otherwise. Argument \spad{y} is an algebraic function of \spad{x} satisfying \spad{f(x,{}y)dx = c f(t,{}y) dy}; \spad{c} and \spad{t} are rational functions of \spad{y}.
517076`\spad{palglimint(f,{} x,{} y,{} [u1,{}...,{}un])} returns functions \spad{[h,{}[[\spad{ci},{} \spad{ui}]]]} such that the \spad{ui}\spad{'s} are among \spad{[u1,{}...,{}un]} and \spad{d(h + sum(\spad{ci} log(\spad{ui})))/dx = f(x,{}y)} if such functions exist,{} "failed" otherwise; \spad{y} is an algebraic function of \spad{x}.
517244`\spad{parabolicCylindrical(pt)} transforms \spad{pt} from parabolic cylindrical coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{}v,{}z)} to \spad{x = 1/2*(u**2 - v**2)},{} \spad{y = u*v},{} \spad{z}.
517321`\spad{parabolic(pt)} transforms \spad{pt} from parabolic coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{}v)} to \spad{x = 1/2*(u**2 - v**2)},{} \spad{y = u*v}.
517387`\spad{paraboloidal(pt)} transforms \spad{pt} from paraboloidal coordinates to Cartesian coordinates: the function produced will map the point \spad{(u,{}v,{}phi)} to \spad{x = u*v*cos(phi)},{} \spad{y = u*v*sin(phi)},{} \spad{z = 1/2 * (u**2 - v**2)}.
517456`\spad{parametersOf(tab)} returns a list of all the symbols declared in \spad{tab}
517514`\spad{parametric? determines} whether it is a parametric plot?
517607`\spad{paren(lf)} creates the form separating the elements of \spad{lf} by commas and encloses the result in parentheses.
517695`\spad{paren(f)} creates the form enclosing \spad{f} in parentheses.
517735`\spad{paren([f1,{}...,{}fn])} returns \spad{(f1,{}...,{}fn)}. This prevents the \spad{fi} from being evaluated when operators are applied to them,{} and makes them applicable to a unary operator. For example,{} \spad{atan(paren [x,{} 2])} returns the formal kernel \spad{atan((x,{} 2))}.
517786`\spad{paren(f)} returns (\spad{f}). This prevents \spad{f} from being evaluated when operators are applied to it. For example,{} \spad{log(1)} returns 0,{} but \spad{log(paren 1)} returns the formal kernel log((1)).
517831`\spad{parent(s)} returns the subspace which is the parent of the indicated 3 dimensional subspace \spad{s}. If \spad{s} is the top level subspace an error message is returned.
517875`\spad{partialDenominators(x)} extracts the denominators in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{}a2,{}a3,{}...],{} [b1,{}b2,{}b3,{}...])},{} then \spad{partialDenominators(x) = [b1,{}b2,{}b3,{}...]}.
517946`\spad{partialFraction(rf,{} var)} returns the partial fraction decomposition of the rational function \spad{rf} with respect to the variable var.
518040`\spad{partialFraction(numer,{}denom)} is the main function for constructing partial fractions. The second argument is the denominator and should be factored.
518109`\spad{partialFraction(num,{} facdenom,{} var)} returns the partial fraction decomposition of the rational function whose numerator is \spad{num} and whose factored denominator is \spad{facdenom} with respect to the variable var.
518217`\spad{partialNumerators(x)} extracts the numerators in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{}a2,{}a3,{}...],{} [b1,{}b2,{}b3,{}...])},{} then \spad{partialNumerators(x) = [a1,{}a2,{}a3,{}...]}.
518286`\spad{partialQuotients(x)} extracts the partial quotients in \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{}a2,{}a3,{}...],{} [b1,{}b2,{}b3,{}...])},{} then \spad{partialQuotients(x) = [b0,{}b1,{}b2,{}b3,{}...]}.
518354`\spad{particularSolution(u)} \undocumented
518427`\spad{particularSolution(A,{}B)} finds a particular solution of the linear system \spad{AX = B}.
518528`\spad{particularSolution(A,{}B)} finds a particular solution of the linear system \spad{AX = B}.
518640`\spad{particularSolution(op,{} g,{} [f1,{}...,{}fm],{} I)} returns a particular solution \spad{h} of the equation \spad{op y = g} where \spad{[f1,{}...,{}fm]} are linearly independent and \spad{op(\spad{fi})=0}. The value "failed" is returned if no particular solution is found. Note: the method of variations of parameters is used.
518733`\spad{partition(\spad{li})} converts a list of integers \spad{li} to a partition
518787`\spad{partition(n)} returns the number of partitions of the integer \spad{n}. This is the number of distinct ways that \spad{n} can be written as a sum of positive integers.
518850`\spad{partitions(n)} is the stream of all partitions of \spad{n}.
518934`\spad{partitions(p,{}l)} is the stream of all \indented{1}{partitions whose number of} \indented{1}{parts and largest part are no greater than \spad{p} and \spad{l}.}
519026`\spad{partitions(p,{}l,{}n)} is the stream of partitions \indented{1}{of \spad{n} whose number of parts is no greater than \spad{p}} \indented{1}{and whose largest part is no greater than \spad{l}.}
519403`\spad{parts(m)} returns a list of the elements of \spad{m} in row major order
519476`\spad{parts(u)} returns a list of the consecutive elements of \spad{u}. For collections,{} \axiom{parts([\spad{x},{}\spad{y},{}...,{}\spad{z}]) = (\spad{x},{}\spad{y},{}...,{}\spad{z})}.
519568`\spad{pascalTriangle(n,{}r)} returns the binomial coefficient \spad{C(n,{}r)=n!/(r! (n-r)!)} and stores it in a table to prevent recomputation.
519653`\spad{pastel(c)} sets the shade of a hue,{} \spad{c},{} above bright,{} but below light.
519694`\spad{patternMatchTimes(lsubj,{} lpat,{} res,{} match)} matches the product of patterns \spad{reduce(*,{}lpat)} to the product of subjects \spad{reduce(*,{}lsubj)}; \spad{r} contains the previous matches and match is a pattern-matching function on \spad{P}.
520149`\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches. Note: this function handles type towers by changing the predicates and calling the matching function provided by \spad{A}.
520268`\spad{patternMatch(cexpr,{} pat,{} res)} matches the pattern \spad{pat} to the complex expression \spad{cexpr}. res contains the variables of \spad{pat} which are already matched and their matches.
520428`\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches.
520552`\spad{patternMatch(n,{} pat,{} res)} matches the pattern \spad{pat} to the integer \spad{n}; res contains the variables of \spad{pat} which are already matched and their matches.
520696`\spad{patternMatch(f(e1,{}...,{}en),{} pat,{} res)} matches the pattern \spad{pat} to \spad{f(e1,{}...,{}en)}; res contains the variables of \spad{pat} which are already matched and their matches.
520819`\spad{patternMatch(l,{} pat,{} res)} matches the pattern \spad{pat} to the list \spad{l}; res contains the variables of \spad{pat} which are already matched and their matches.
520955`\spad{patternMatch(p,{} pat,{} res)} matches the pattern \spad{pat} to the polynomial \spad{p}; res contains the variables of \spad{pat} which are already matched and their matches.
521114`\spad{patternMatch(a/b,{} pat,{} res)} matches the pattern \spad{pat} to the quotient \spad{a/b}; res contains the variables of \spad{pat} which are already matched and their matches.
522009`\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}; res contains the variables of \spad{pat} which are already matched and their matches (necessary for recursion).
522137`\spad{patternMatch(expr,{} pat,{} res)} matches the pattern \spad{pat} to the expression \spad{expr}. res contains the variables of \spad{pat} which are already matched and their matches (necessary for recursion). Initially,{} res is just the result of \spadfun{new} which is an empty list of matches.
522251`\spad{patternMatch(p,{} pat,{} res,{} vmatch)} matches the pattern \spad{pat} to the polynomial \spad{p}. \spad{res} contains the variables of \spad{pat} which are already matched and their matches; vmatch is the matching function to use on the variables.
522448`\spad{patternMatch(lsubj,{} lpat,{} op,{} res,{} match)} matches the list of patterns \spad{lpat} to the list of subjects \spad{lsubj},{} allowing for commutativity; \spad{op} is the operator such that \spad{op}(\spad{lpat}) should match \spad{op}(\spad{lsubj}) at the end,{} \spad{r} contains the prev
522448`--ious matches,{} and match is a pattern-matching function on \spad{P}.
522653`\spad{patternVariable(x,{} c?,{} o?,{} m?)} creates a pattern variable \spad{x},{} which is constant if \spad{c? = true},{} optional if \spad{o? = true},{} and multiple if \spad{m? = true}.
522731`\spad{pattern(r)} returns the pattern corresponding to the left hand side of the rule \spad{r}.
522795`\spad{pdct(a1**n1 a2**n2 ...)} returns \spad{n1! * a1**n1 * n2! * a2**n2 * ...}. This function is used in the package \spadtype{CycleIndicators}.
522838`\spad{pdf2df(p)} coerces a \axiomType{Polynomial DoubleFloat} to \axiomType{DoubleFloat}. It is an error if \axiom{\spad{p}} is not retractable to DoubleFloat.
522923`\spad{pdf2ef(p)} coerces a \axiomType{Polynomial DoubleFloat} to \axiomType{Expression Float}
523014`\spad{perfectNthPower?(n,{}r)} returns \spad{true} if \spad{n} is an \spad{r}th power and \spad{false} otherwise
523093`\spad{perfectNthRoot(n)} returns \spad{[x,{}r]},{} where \spad{n = x\^r} and \spad{r} is the largest integer such that \spad{n} is a perfect \spad{r}th power
523186`\spad{perfectNthRoot(n,{}r)} returns the \spad{r}th root of \spad{n} if \spad{n} is an \spad{r}th power and returns "failed" otherwise
523273`\spad{perfectSqrt(n)} returns the square root of \spad{n} if \spad{n} is a perfect square and returns "failed" otherwise
523338`\spad{perfectSquare?(n)} returns \spad{true} if \spad{n} is a perfect square and \spad{false} otherwise
523396`\spad{permanent(x)} computes the permanent of a square matrix \spad{x}. The {\em permanent} is equivalent to the \spadfun{determinant} except that coefficients have no change of sign. This function is much more difficult to compute than the {\em determinant}. The formula used is by \spad{H}.\spad{J}. Ryser,{} improved by [Nijenhuis and Wilf,{} \spad{Ch}. 19]. Note: permanent(\spad{x}) choose one of three algorithms,{} depending on the underl
523396`--ying ring \spad{R} and on \spad{n},{} the number of rows (and columns) of \spad{x:}\begin{items} \item 1. if 2 has an inverse in \spad{R} we can use the algorithm of \indented{3}{[Nijenhuis and Wilf,{} \spad{ch}.19,{}\spad{p}.158]; if 2 has no inverse,{}} \indented{3}{some modifications are necessary:} \item 2. if {\em n > 6} and \spad{R} is an integral domain with characteristic \indented{3}{different from 2 (the algorithm works if and only 2 is not a} \indented{3}{zero-divisor of \spad{R} an
523396`--d {\em characteristic()\$R ^= 2},{}} \indented{3}{but how to check that for any given \spad{R} ?),{}} \indented{3}{the local function {\em permanent2} is called;} \item 3. else,{} the local function {\em permanent3} is called \indented{3}{(works for all commutative rings \spad{R}).} \end{items}
523458`\spad{permutationGroup(ls)} coerces a list of permutations {\em ls} to the group generated by this list.
523536`\spad{permutationRepresentation(\spad{pi},{}n)} returns the matrix {\em (deltai,{}\spad{pi}(i))} (Kronecker delta) if the permutation {\em \spad{pi}} is in list notation and permutes {\em {1,{}2,{}...,{}n}}.
523635`\spad{permutationRepresentation([pi1,{}...,{}pik],{}n)} returns the list of matrices {\em [(deltai,{}pi1(i)),{}...,{}(deltai,{}pik(i))]} if the permutations {\em pi1},{}...,{}{\em pik} are in list notation and are permuting {\em {1,{}2,{}...,{}n}}.
523746`\spad{permutationRepresentation([pi1,{}...,{}pik],{}n)} returns the list of matrices {\em [(deltai,{}pi1(i)),{}...,{}(deltai,{}pik(i))]} (Kronecker delta) for the permutations {\em pi1,{}...,{}pik} of {\em {1,{}2,{}...,{}n}}.
523872`\spad{permutationRepresentation(\spad{pi},{}n)} returns the matrix {\em (deltai,{}\spad{pi}(i))} (Kronecker delta) for a permutation {\em \spad{pi}} of {\em {1,{}2,{}...,{}n}}.
523986`\spad{permutation(n,{} r)} returns the number of permutations of \spad{n} objects taken \spad{r} at a time,{} \spadignore{i.e.} \spad{n!/}(\spad{n}-\spad{r})!.
524102`\spad{permutation(n)} returns \spad{!P(n,{}r) = n!/(n-r)!}. This is the number of permutations of \spad{n} objects taken \spad{r} at a time.
524169`\spad{permutation(n,{} m)} returns the number of permutations of \spad{n} objects taken \spad{m} at a time. Note: \spad{permutation(n,{}m) = n!/(n-m)!}.
524237`\spad{permutations(n)} is the stream of permutations \indented{1}{formed from \spad{1,{}2,{}3,{}...,{}n}.}
524323`\spad{perspective(v,{}s)} displays the graph in perspective if \spad{s} is "on",{} or does not display perspective if \spad{s} is "off" for the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport}.
524392`\spad{phiCoord(pt)} returns the third element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical coordinate system.
524445`\spad{physicalLength!(x,{}n)} changes the physical length of \spad{x} to be \spad{n} and returns the new array.
524578`\spad{physicalLength(x)} returns the number of elements \spad{x} can accomodate before growing
524725`\spad{\spad{pi}()} returns the \spad{pi} operator
524865`\spad{\spad{pi}()} returns the constant \spad{pi}.
524920`\spad{\spad{pi}(x)} represents the NAG Library function X01AAF which returns \indented{1}{an approximation to the value of \spad{pi}}
524997`\spad{\spad{pi}()} returns the symbolic \%\spad{pi}.
525024`\spad{pile(l)} creates the form consisting of the elements of \spad{l} which displays as a pile,{} \spadignore{i.e.} the elements begin on a new line and are indented right to the same margin.
525142`\spad{plenaryPower(a,{}n)} is recursively defined to be \spad{plenaryPower(a,{}n-1)*plenaryPower(a,{}n-1)} for \spad{n>1} and \spad{a} for \spad{n=1}.
525219`\spad{pleskenSplit(poly,{} eps)} determines a start polynomial {\em start}\\ by using "startPolynomial then it increases the exponent \spad{n} of {\em start ** n mod poly} to get an approximate factor of {\em poly},{} in general of degree "degree \spad{poly} \spad{-1"}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough.
525299`\spad{pleskenSplit(poly,{}eps,{}info)} determines a start polynomial {\em start} by using "startPolynomial then it increases the exponent \spad{n} of {\em start ** n mod poly} to get an approximate factor of {\em poly},{} in general of degree "degree \spad{poly} \spad{-1"}. Then a divisor cascade is calculated and the best splitting is chosen,{} as soon as the error is small enough. If {\em info} is {\em true},{} th
525299`--en information messages are issued.
525387`\spad{plotPolar(f)} plots the polar curve \spad{r = f(theta)} as theta ranges over the interval \spad{[0,{}2*\%\spad{pi}]}; this is the same as the parametric curve \spad{x = f(t) * cos(t)},{} \spad{y = f(t) * sin(t)}.
525449`\spad{plotPolar(f,{}a..b)} plots the polar curve \spad{r = f(theta)} as theta ranges over the interval \spad{[a,{}b]}; this is the same as the parametric curve \spad{x = f(t) * cos(t)},{} \spad{y = f(t) * sin(t)}.
525532`\spad{plotPolar(f,{}theta)} plots the graph of \spad{r = f(theta)} as \spad{theta} ranges from 0 to 2 \spad{pi}
525591`\spad{plotPolar(f,{}theta,{}seg)} plots the graph of \spad{r = f(theta)} as \spad{theta} ranges over an interval
525671`\spad{plot(f,{}a..b)} plots the function \spad{f(x)} on the interval \spad{[a,{}b]}.
525749`\spad{plot([f1,{}...,{}fm],{}a..b)} plots the functions \spad{y = f1(x)},{}...,{} \spad{y = fm(x)} on the interval \spad{a..b}.
525833`\spad{plot(x,{}r)} \undocumented
525889`\spad{plot(x,{}r)} \undocumented
525943`\spad{plot(f,{}g,{}a..b)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{}b]}.
526048`\spad{plot(f,{}a..b,{}c..d)} plots the function \spad{f(x)} on the interval \spad{[a,{}b]}; \spad{y}-range of \spad{[c,{}d]} is noted in Plot object.
526147`\spad{plot([f1,{}...,{}fm],{}a..b,{}c..d)} plots the functions \spad{y = f1(x)},{}...,{} \spad{y = fm(x)} on the interval \spad{a..b}; \spad{y}-range of \spad{[c,{}d]} is noted in Plot object.
526252`\spad{plot(fcn,{}x,{}seg)} plots the graph of \spad{y = f(x)} on a interval
526327`\spad{plot(f,{}g,{}t,{}seg)} plots the graph of \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over an interval.
526404`\spad{plot(f,{}g,{}h,{}a..b)} plots {/emx = \spad{f}(\spad{t}),{} \spad{y} = \spad{g}(\spad{t}),{} \spad{z} = \spad{h}(\spad{t})} as \spad{t} ranges over {/em[a,{}\spad{b}]}.
526565`\spad{plot(f,{}g,{}a..b,{}c..d,{}e..f)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{}b]}; \spad{x}-range of \spad{[c,{}d]} and \spad{y}-range of \spad{[e,{}f]} are noted in Plot object.
526712`\spad{plot(f1,{}f2,{}f3,{}f4,{}x,{}y,{}z,{}w)} \undocumented
526936`\spad{plus!(c,{}a,{}b)} computes the matrix sum \spad{a + b} and stores the result in the matrix \spad{c}. Error: if \spad{a},{} \spad{b},{} and \spad{c} do not have the same dimensions.
527035`\spad{plusInfinity()} returns plusIinfinity.
527102`\spad{plusInfinity()} returns +infinity.
527157`\spad{plus(x,{} y)} returns \spad{x + y} where \spad{+} is the monoid operation,{} which is assumed commutative.
527210`\spad{plus(x,{}y)} adds two matrices,{} term by term we note that they must be the same size
527278`\spad{plus(s,{} e,{} x)} returns \spad{e * s + x} where \spad{+} is the monoid operation,{} which is assumed commutative.
527332`\spad{pmComplexintegrate(f,{} x)} returns either "failed" or \spad{[g,{}h]} such that \spad{integrate(f,{}x) = g + integrate(h,{}x)}. It only looks for special complex integrals that pmintegrate does not return.
527563`\spad{pmintegrate(f,{} x)} returns either "failed" or \spad{[g,{}h]} such that \spad{integrate(f,{}x) = g + integrate(h,{}x)}.
527787`\spad{pmintegrate(f,{} x = a..b)} returns the integral of \spad{f(x)dx} from a to \spad{b} if it can be found by the built-in pattern matching rules.
528021`\spad{po(q)} creates a value in \spad{P} equal to \spad{q} in \$.
528083`\spad{point?(s)} queries whether the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single component which is a point and returns the boolean result.
528140`\spad{pointColorDefault()} returns the default color of points in a 2D viewport.
528204`\spad{pointColorDefault(p)} sets the default color of points in a 2D viewport to the palette \spad{p}.
528275`\spad{pointColorPalette(l,{}p)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{pointColorPalette}. If the option does not exist the value,{} \spad{p} is returned.
528364`\spad{pointColor(v)} specifies a color,{} \spad{v},{} for 2D graph points. This option is expressed in the form \spad{pointColor == v}.
528412`\spad{pointColor(p)} specifies a color index for 2D graph points from the spadcolors palette \spad{p}. This option is expressed in the form \spad{pointColor == p}.
528462`\spad{pointData(s)} returns the list of points from the point data field of the 3 dimensional subspace \spad{s}.
528521`\spad{pointLists(\spad{gi})} returns the list of lists of points which compose the given graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.
528594`\spad{pointPlot(f,{}g,{}h,{}a..b)} plots {/emx = \spad{f}(\spad{t}),{} \spad{y} = \spad{g}(\spad{t}),{} \spad{z} = \spad{h}(\spad{t})} as \spad{t} ranges over {/em[a,{}\spad{b}]}.
528686`\spad{pointPlot(t +-> (f(t),{}g(t)),{}a..b)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{}b]}.
528776`\spad{pointPlot(t +-> (f(t),{}g(t)),{}a..b,{}c..d,{}e..f)} plots the parametric curve \spad{x = f(t)},{} \spad{y = g(t)} as \spad{t} ranges over the interval \spad{[a,{}b]}; \spad{x}-range of \spad{[c,{}d]} and \spad{y}-range of \spad{[e,{}f]} are noted in Plot object.
528908`\spad{pointPlot(f,{}x,{}y,{}z,{}w)} \undocumented
529063`\spad{pointSizeDefault()} returns the default size of the points in a 2D viewport.
529134`\spad{pointSizeDefault(i)} sets the default size of the points in a 2D viewport to \spad{i}.
529220`\spad{point(l)} returns a point category defined by a list \spad{l} of elements from the domain \spad{R}.
529271`\spad{point(p)} returns a \spadtype{ThreeSpace} object which is composed of one component,{} the point \spad{p}.
529328`\spad{point(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of only a single point and if so,{} returns the point. An error is signaled otherwise.
529385`\spad{point(s,{}[x,{}y,{}z])} adds a point component defined by a list of elements which are from the \spad{PointDomain(R)} to the \spadtype{ThreeSpace},{} \spad{s},{} where \spad{R} is the \spadtype{Ring} over which the point elements are defined.
529444`\spad{point(s,{}i)} adds a point component which is placed into a component list of the \spadtype{ThreeSpace},{} \spad{s},{} at the index given by \spad{i}.
529514`\spad{point(s,{}p)} adds a point component defined by the point,{} \spad{p},{} specified as a list from \spad{List(R)},{} to the \spadtype{ThreeSpace},{} \spad{s},{} where \spad{R} is the \spadtype{Ring} over which the point is defined.
529574`\spad{point(\spad{gi},{}pt,{}pal)} modifies the graph \spad{\spad{gi}} of the domain \spadtype{GraphImage} to contain one point component,{} \spad{pt} whose point color is set to be the palette color \spad{pal},{} and whose line color and point size are determined by the default functions \spadfun{lineColorDefault} and \spadfun{pointSizeDefault}.
529643`\spad{point(x1,{}x2,{}x3,{}c)} creates and returns a point from the three specified coordinates \spad{x1},{} \spad{x2},{} \spad{x3},{} and also a fourth coordinate,{} \spad{c},{} which is generally used to specify the color of the point.
529747`\spad{points(v,{}n,{}s)} displays the points of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the points if \spad{s} is "off".
529825`\spad{poisson(f)} \undocumented
529904`\spad{polCase(contprod,{} numFacts,{} evallcs)},{} where \spad{contprod} is the product of the content of the leading coefficient of the polynomial to be factored with the content of the evaluated polynomial,{} \spad{numFacts} is the number of factors of the leadingCoefficient,{} and evallcs is the list of the evaluated factors of the leadingCoefficient,{} returns \spad{true} if the factors of the leading C
529904`--oefficient can be distributed with this valuation.
530001`\spad{pol(v)} turns the vector \spad{[v0,{}...,{}vn]} into the polynomial \spad{v0+v1*x+ ... + vn*x**n}.
530170`\spad{polarCoordinates(x)} returns (\spad{r},{} phi) such that \spad{x} = \spad{r} * exp(\%\spad{i} * phi).
530310`\spad{polar(pt)} transforms \spad{pt} from polar coordinates to Cartesian coordinates: the function produced will map the point \spad{(r,{}theta)} to \spad{x = r * cos(theta)} ,{} \spad{y = r * sin(theta)}.
530372`\spad{pole?(x)} tests if the series \spad{x} has a pole. \indented{1}{Note: this is \spad{false} when \spad{x} is a Taylor series.}
530430`\spad{pole?(f)} determines if the power series \spad{f} has a pole.
530500`\spad{polyPart(f)} returns the polynomial part of \spad{f}.
530567`\spad{polyRDE(a,{} B,{} C,{} n,{} D)} returns either: 1. \spad{[Q,{} b]} such that \spad{degree(Q) <= n} and \indented{3}{\spad{a Q'+ B Q = C} if \spad{b = true},{} \spad{Q} is a partial solution} \indented{3}{otherwise.} 2. \spad{[B1,{} C1,{} m,{} \alpha,{} \beta]} such that any polynomial solution \indented{3}{of degree at most \spad{n}
530567`-- of \spad{A Q' + BQ = C} must be of the form} \indented{3}{\spad{Q = \alpha H + \beta} where \spad{degree(H) <= m} and} \indented{3}{\spad{H} satisfies \spad{H' + B1 H = C1}.} \spad{D} is the derivation to use.
530734`\spad{polyRicDE(op,{} zeros)} returns \spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{} Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y=0} must be one of the \spad{pi}\spad{'s} (up to the constant coefficient),{} in which case the equation for \spad{z=y e^{-int p}} is \spad{\spad{Li} z =0}. \spad{zeros} is a zero finder in \spad{UP}.
530833`\spad{polyRicDE(op,{} zeros)} returns \spad{[[p1,{} L1],{} [p2,{} L2],{} ... ,{} [pk,{}Lk]]} such that the polynomial part of any rational solution of the associated Riccati equation of \spad{op y = 0} must be one of the \spad{pi}\spad{'s} (up to the constant coefficient),{} in which case the equation for \spad{z 
530833`--= y e^{-int p}} is \spad{\spad{Li} z = 0}. \spad{zeros} is a zero finder in \spad{UP}.
531025`\spad{polygamma(x,{}y)} returns the polygamma function applied to \spad{x} and \spad{y}
531089`\spad{polygamma(n,{} x)} is the \spad{n}-th derivative of \spad{digamma(x)}.
531205`\spad{polygamma(n,{} x)} is the \spad{n}-th derivative of \spad{digamma(x)}.
531303`\spad{polygamma(k,{}x)} is the \spad{k-th} derivative of \spad{digamma(x)},{} (often written \spad{psi(k,{}x)} in the literature).
531363`\spad{polygon?(s)} returns \spad{true} if the \spadtype{ThreeSpace} \spad{s} contains a single polygon component,{} or \spad{false} otherwise.
531422`\spad{polygon([p0,{}p1,{}...,{}pn])} creates a polygon defined by a list of points,{} \spad{p0} through \spad{pn},{} and returns a \spadtype{ThreeSpace} whose component is the polygon.
531487`\spad{polygon(s)} checks to see if the \spadtype{ThreeSpace},{} \spad{s},{} is composed of a single polygon component defined by a list of points,{} and if so,{} returns the list of points; An error is signaled otherwise.
531552`\spad{polygon(s,{}[[r0],{}[r1],{}...,{}[rn]])} adds a polygon component defined by a list of points \spad{r0} through \spad{rn},{} which are lists of elements from the domain \spad{PointDomain(m,{}R)} to the \spadtype{ThreeSpace} \spad{s},{} where \spad{m} is the dimension of the points and \spad{R} is the \spadtype{Ring} over which the points are defined.
531619`\spad{polygon(s,{}[p0,{}p1,{}...,{}pn])} adds a polygon component defined by a list of points,{} \spad{p0} throught \spad{pn},{} to the \spadtype{ThreeSpace} \spad{s}.
531687`\spad{polynomialZeros(fn,{}var,{}range)} calculates the real zeros of the polynomial which are contained in the given interval. It returns a list of points (\axiomType{Doublefloat}) for which the univariate polynomial \spad{fn} is zero.
531845`\spad{polynomial(f,{}k)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.
531955`\spad{polynomial(f,{}k)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.
532059`\spad{polynomial(f,{}k1,{}k2)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.
532188`\spad{polynomial(f,{}k1,{}k2)} returns a polynomial consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.
532311`\spad{polyred(u)} \undocumented
532442`\spad{pomopo!(p1,{}r,{}e,{}p2)} returns \spad{p1 + monomial(e,{}r) * p2} and may use \spad{p1} as workspace. The constaant \spad{r} is assumed to be nonzero.
532509`\spad{pop!(s)} returns the top element \spad{x},{} destructively removing \spad{x} from \spad{s}. Note: Use \axiom{top(\spad{s})} to obtain \spad{x} without removing it from \spad{s}. Error: if \spad{s} is empty.
532554`\spad{popFortranOutputStack()} pops the Fortran output stack
532625`\spad{position!(f,{} i)} sets the current byte-position to \spad{i}.
532694`\spad{position(x)} returns the integer \spad{n} associated to \spad{x}.
532754`\spad{position(f)} returns the current byte-position in the file \spad{f}.
533205`\spad{position(p,{}a)} returns the index \spad{i} of the first \spad{x} in \axiom{a} such that \axiom{\spad{p}(\spad{x})} is \spad{true},{} and \axiom{minIndex(a) - 1} if there is no such \spad{x}.
533280`\spad{position(x,{}a)} returns the index \spad{i} of the first occurrence of \spad{x} in a,{} and \axiom{minIndex(a) - 1} if there is no such \spad{x}.
533568`\spad{position(cc,{}t,{}i)} returns the position \axiom{\spad{j} \spad{>=} \spad{i}} in \spad{t} of the first character belonging to \spad{cc}.
533644`\spad{position(x,{}a,{}n)} returns the index \spad{i} of the first occurrence of \spad{x} in \axiom{a} where \axiom{\spad{i} \spad{>=} \spad{n}},{} and \axiom{minIndex(a) - 1} if no such \spad{x} is found.
533734`\spad{position(s,{}t,{}i)} returns the position \spad{j} of the substring \spad{s} in string \spad{t},{} where \axiom{\spad{j} \spad{>=} \spad{i}} is required.
533902`\spad{positive?(u)} returns \axiom{\spad{true}} if every element of \spad{u} is positive,{} \axiom{\spad{false}} otherwise.
533960`\spad{positive?(x)} tests whether \spad{x} is strictly greater than 0.
534104`\axiom{positive?(pol,{}aRoot)} answers if \axiom{pol} interpreted as \axiom{aRoot} is positive
534201`\spad{positiveRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{0 <= r < b} and \spad{r == a rem b}.
534265`\spad{positiveSolve(lp)} returns the same as \spad{positiveSolve(lp,{}false,{}false)}.
534391`\spad{positiveSolve(ts)} returns the points of the regular set of \spad{ts} with (real) strictly positive coordinates.
534516`\spad{positiveSolve(lp)} returns the same as \spad{positiveSolve(lp,{}info?,{}false)}.
534650`\spad{positiveSolve(lp,{}info?,{}lextri?)} returns the set of the points in the variety associated with \spad{lp} whose coordinates are (real) strictly positive. Moreover,{} if \spad{info?} is \spad{true} then some information is displayed during decomposition into regular chains. If \spad{lextri?} is \spad{true} then the lexTriangular algorithm is called from th
534650`--e \spadtype{LexTriangularPackage} constructor (see \axiomOpFrom{zeroSetSplit}{LexTriangularPackage}(\spad{lp},{}\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \axiomOpFrom{zeroSetSplit}{RegularChain} from \spadtype{RegularChain}. WARNING: For each set of coordinates given by \spad{positiveSolve(lp,{}info?,{}lextri?)} the ordering of the indeterminates is reversed \spad{w}.\spad{r}.\spad{t}. \spad{ls}.
534920`\spad{possiblyInfinite?(s)} tests if the stream \spad{s} could possibly have an infinite number of elements. Note: for many datatypes,{} \axiom{possiblyInfinite?(\spad{s}) = not explictlyFinite?(\spad{s})}.
534985`\axiom{possiblyNewVariety?(newlp,{}\spad{llp})} returns \spad{true} iff for every \axiom{\spad{lp}} in \axiom{\spad{llp}} certainlySubVariety?(newlp,{}\spad{lp}) does not hold.
535091`\spad{postfix(op,{} a)} creates a form which prints as: a \spad{op}.
535136`\spad{pow()} \undocumented
535193`\spad{power!(a,{}b,{}c,{}m,{}n)} computes \spad{m} \spad{**} \spad{n} and stores the result in \spad{a}. The matrices \spad{b} and \spad{c} are used to store intermediate results. Error: if \spad{a},{} \spad{b},{} \spad{c},{} and \spad{m} are not square and of the same dimensions.
535322`\spad{powerAssociative?()} tests if all subalgebras generated by a single element are associative.
535401`\spad{powerSum n} is the \spad{n} th power sum symmetric \indented{1}{function.}
535490`\spad{power(a,{}f)} returns the power series \spad{f} raised to the power \spad{a}.
535579`\spad{powern(r,{}f)} raises power series \spad{f} to the power \spad{r}.
535706`\spad{powers(\spad{li})} returns a list of 2-element lists. For each 2-element list,{} the first element is an entry of \spad{li} and the second element is the multiplicity with which the first element occurs in \spad{li}. There is a 2-element list for each value occurring in \spad{l}.
535825`\spad{powmod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a**b mod p}.
535942`\axiom{pquo(a,{}\spad{b})} computes the pseudo-quotient of \axiom{a} by \axiom{\spad{b}},{} both viewed as univariate polynomials in the main variable of \axiom{\spad{b}}.
536071`\axiom{pquo(a,{}\spad{b},{}\spad{v})} computes the pseudo-quotient of \axiom{a} by \axiom{\spad{b}},{} both viewed as univariate polynomials in \axiom{\spad{v}}.
536139`\spad{pr2dmp(p)} converts \spad{p} to target domain
536222`\spad{precision()} returns the precision in digits base.
536286`\spad{precision()} returns the number of digits in the model
536343`\spad{precision(n)} set the precision in the base to \spad{n} decimal digits.
536459`\spad{precision(p)} sets the number of digits in the model to \spad{p}
536531`\spad{predicate(p)} returns the predicate attached to \spad{p},{} the constant function \spad{true} if \spad{p} has no predicates attached to it.
536605`\spad{predicates(p)} returns \spad{[p1,{}...,{}pn]} such that the predicate attached to \spad{p} is \spad{p1} and ... and \spad{pn}.
536709`\spad{prefix?(s,{}t)} tests if the string \spad{s} is the initial substring of \spad{t}. Note: \axiom{prefix?(\spad{s},{}\spad{t}) \spad{==} reduce(and,{}[\spad{s}.\spad{i} = \spad{t}.\spad{i} for \spad{i} in 0..maxIndex \spad{s}])}.
536764`\spad{prefixRagits(rx)} returns the non-cyclic part of the ragits of the fractional part of a radix expansion. For example,{} if \spad{x = 3/28 = 0.10 714285 714285 ...},{} then \spad{prefixRagits(x)=[1,{}0]}.
536830`\spad{prefix(f,{}l)} creates a form depicting the \spad{n}-ary prefix application of \spad{f} to a tuple of arguments given by list \spad{l}.
536941`\axiom{prem(a,{}\spad{b})} computes the pseudo-remainder of \axiom{a} by \axiom{\spad{b}},{} both viewed as univariate polynomials in the main variable of \axiom{\spad{b}}.
537070`\axiom{prem(a,{}\spad{b},{}\spad{v})} computes the pseudo-remainder of \axiom{a} by \axiom{\spad{b}},{} both viewed as univariate polynomials in \axiom{\spad{v}}.
537138`\axiom{prepareDecompose(\spad{lp},{}\spad{lts},{}\spad{b1},{}\spad{b2})} is an internal subroutine,{} exported only for developement.
537286`\axiom{prepareDecompose(\spad{lp},{}\spad{lts},{}\spad{b1},{}\spad{b2})} is an internal subroutine,{} exported only for developement.
537444`\axiom{prepareSubResAlgo(\spad{p1},{}\spad{p2},{}\spad{ts})} is an internal subroutine,{} exported only for developement.
537564`\axiom{pre_process(\spad{lp},{}\spad{b1},{}\spad{b2})} is an internal subroutine,{} exported only for developement.
537682`\axiom{pre_process(\spad{lp},{}\spad{b1},{}\spad{b2})} is an internal subroutine,{} exported only for developement.
537810`\spad{presub(f,{}n)} creates a form for \spad{f} presubscripted by \spad{n}.
537854`\spad{presuper(f,{}n)} creates a form for \spad{f} presuperscripted by \spad{n}.
537900`\spad{prevPrime(n)} returns the largest prime strictly smaller than \spad{n}
537955`\spad{previous(l)} returns the doubly-link list beginning with its previous element. Error: if \spad{l} has no previous element. Note: \axiom{next(previous(\spad{l})) = \spad{l}}.
538093`\axiom{primPartElseUnitCanonical!(\spad{p})} replaces \axiom{\spad{p}} by \axiom{primPartElseUnitCanonical(\spad{p})}.
538279`\axiom{primPartElseUnitCanonical(\spad{p})} returns \axiom{primitivePart(\spad{p})} if \axiom{\spad{R}} is a \spad{gcd}-domain,{} otherwise \axiom{unitCanonical(\spad{p})}.
538384`\spad{primaryDecomp(I)} returns a list of primary ideals such that their intersection is the ideal \spad{I}.
538911`\spad{prime?(\spad{zi})} tests if the complex integer \spad{zi} is prime.
538989`\spad{prime?(n)} returns \spad{true} if \spad{n} is prime and \spad{false} if not. The algorithm used is Rabin\spad{'s} probabilistic primality test (reference: Knuth Volume 2 Semi Numerical Algorithms). If \spad{prime? n} returns \spad{false},{} \spad{n} is proven composite. If \spad{prime? n} returns \spad{true},{} prime? may be in error however,{} the probability of error is very low. and is zero below 25*10**9 (due to a result of Pomerance e
538989`--t al),{} below 10**12 and 10**13 due to results of Pinch,{} and below 341550071728321 due to a result of Jaeschke. Specifically,{} this implementation does at least 10 pseudo prime tests and so the probability of error is \spad{< 4**(-10)}. The running time of this method is cubic in the length of the input \spad{n},{} that is \spad{O( (log n)**3 )},{} for \spad{n<10**20}. beyond that,{} the algorithm is quartic,{} \spad{O( (log n)**4 )}. Two improvements due to Davenport have been incorporate
538989`--d which catches some trivial strong pseudo-primes,{} such as [Jaeschke,{} 1991] 1377161253229053 * 413148375987157,{} which the original algorithm regards as prime
539047`\spad{prime?(I)} tests if the ideal \spad{I} is prime.
539265`\spad{prime?(x)} tests if \spad{x} can never be written as the product of two non-units of the ring,{} \spadignore{i.e.} \spad{x} is an irreducible element.
539326`\spad{primeFactor(base,{}exponent)} creates a factored object with a single factor whose \spad{base} is asserted to be prime (flag = "prime").
539442`\spad{primeFrobenius(a)} returns \spad{a ** p} where \spad{p} is the characteristic.
539588`\spad{primeFrobenius(a,{}s)} returns \spad{a**(p**s)} where \spad{p} is the characteristic.
539672`\spad{prime(f)} creates the form \spad{f} followed by a suffix prime (single quote).
539712`\spad{prime(f,{}n)} creates the form \spad{f} followed by \spad{n} primes.
539771`\spad{primes(a,{}b)} returns a list of all primes \spad{p} with \spad{a <= p <= b}
539831`\spad{primextendedint(f,{} ',{} foo,{} g)} returns either \spad{[v,{} c]} such that \spad{f = v' + c g} and \spad{c' = 0},{} or \spad{[v,{} a]} such that \spad{f = g' + a},{} and \spad{a = 0} or \spad{a} has no integral in UP. Returns "failed" if neither case can
539831`-- hold. Argument \spad{foo} is an extended integration function on \spad{F}.
540075`\spad{primextintfrac(f,{} ',{} g)} returns \spad{[v,{} c]} such that \spad{f = v' + c g} and \spad{c' = 0}. Error: if \spad{degree numer f >= degree denom f} or if \spad{degree numer g >= degree denom g} or if \spad{denom g} is not squarefree.
540238`\spad{primintegrate(f,{} ',{} foo)} returns \spad{[g,{} a]} such that \spad{f = g' + a},{} and \spad{a = 0} or \spad{a} has no integral in UP. Argument foo is an extended integration function on \spad{F}.
540422`\spad{primintfldpoly(p,{} ',{} t')} returns \spad{q} such that \spad{p' = q} or "failed" if no such \spad{q} exists. Argument \spad{t'} is the derivative of the primitive generating the extension.
540614`\spad{primitive?(f)} tests whether the polynomial \spad{f} over a finite field is primitive,{} \spadignore{i.e.} all its roots are primitive.
540714`\spad{primitive?(b)} tests whether the element \spad{b} is a generator of the (cyclic) multiplicative group of the field,{} \spadignore{i.e.} is a primitive element. Implementation Note: see \spad{ch}.IX.1.3,{} th.2 in \spad{D}. Lipson.
540773`\spad{primitiveElement()} returns a primitive element stored in a global variable in the domain. At first call,{} the primitive element is computed by calling \spadfun{createPrimitiveElement}.
540831`\spad{primitiveElement([a1,{}...,{}an])} returns \spad{[a,{} [q1,{}...,{}qn],{} q]} such that then \spad{k(a1,{}...,{}an) = k(a)},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.
541002`\spad{primitiveElement([p1,{}...,{}pn],{} [a1,{}...,{}an])} returns \spad{[[c1,{}...,{}cn],{} [q1,{}...,{}qn],{} q]} such that then \spad{k(a1,{}...,{}an) = k(a)},{} where \spad{a = a1 c1 + ... + an cn},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The \spad{pi}\spad{'s} are the defining polynomials for
541002`-- the \spad{ai}\spad{'s}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.
541192`\spad{primitiveElement(a1,{} a2)} returns \spad{[a,{} q1,{} q2,{} q]} such that \spad{k(a1,{} a2) = k(a)},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The minimal polynomial for \spad{a2} may involve \spad{a1},{} but the minimal polynomial for \spad{a1} may not invo
541192`--lve \spad{a2}; This operations uses \spadfun{resultant}.
541419`\spad{primitiveElement([p1,{}...,{}pn],{} [a1,{}...,{}an],{} a)} returns \spad{[[c1,{}...,{}cn],{} [q1,{}...,{}qn],{} q]} such that then \spad{k(a1,{}...,{}an) = k(a)},{} where \spad{a = a1 c1 + ... + an cn},{} \spad{\spad{ai} = \spad{qi}(a)},{} and \spad{q(a) = 0}. The \spad{pi}\spad{'s} are the defining pol
541419`--ynomials for the \spad{ai}\spad{'s}. This operation uses the technique of \spadglossSee{groebner bases}{Groebner basis}.
541616`\spad{primitiveElement(p1,{} a1,{} p2,{} a2)} returns \spad{[c1,{} c2,{} q]} such that \spad{k(a1,{} a2) = k(a)} where \spad{a = c1 a1 + c2 a2,{} and q(a) = 0}. The \spad{pi}\spad{'s} are the defining polynomials for the \spad{ai}\spad{'s}. The \spad{p2} may involve \spad{a1},{} but \spad{p1} must not involve \spad{a2}. This operation use
541616`--s \spadfun{resultant}.
541858`\spad{primitiveMonomials(p)} gives the list of monomials of the polynomial \spad{p} with their coefficients removed. Note: \spad{primitiveMonomials(sum(a_(i) X^(i))) = [X^(1),{}...,{}X^(n)]}.
542006`\axiom{primitivePart!(\spad{p})} replaces \axiom{\spad{p}} by its primitive part.
542356`\spad{primitivePart(p)} returns the unit normalized form of polynomial \spad{p} divided by the content of \spad{p}.
542438`\spad{primitivePart(f)} removes the content of the denominator and the common content of the numerator of \spad{f}.
542508`\spad{primitivePart(p)} returns the unitCanonical associate of the polynomial \spad{p} with its content divided out.
542592`\spad{primitivePart(l)} returns \spad{l0} such that \spad{l = a * l0} for some a in \spad{R},{} and \spad{content(l0) = 1}.
542752`\spad{primitivePart(p,{} q)} reduces the coefficient of \spad{p} modulo \spad{q},{} takes the primitive part of the result,{} and ensures that the leading coefficient of that result is monic.
542839`\spad{primitivePart(p,{}v)} returns the unitCanonical associate of the polynomial \spad{p} with its content with respect to the variable \spad{v} divided out.
542930`\spad{primlimintfrac(f,{} ',{} [u1,{}...,{}un])} returns \spad{[v,{} [c1,{}...,{}cn]]} such that \spad{ci' = 0} and \spad{f = v' + +/[\spad{ci} * ui'/ui]}. Error: if \spad{degree numer f >= degree denom f}.
543146`\spad{primlimitedint(f,{} ',{} foo,{} [u1,{}...,{}un])} returns \spad{[v,{} [c1,{}...,{}cn],{} a]} such that \spad{ci' = 0},{} \spad{f = v' + a + reduce(+,{}[\spad{ci} * ui'/ui])},{} and \spad{a = 0} or \spad{a} has no integ
543146`--ral in UP. Returns "failed" if no such \spad{v},{} \spad{ci},{} a exist. Argument \spad{foo} is an extended integration function on \spad{F}.
543429`\spad{prinb }\undocumented
543583`\spad{principal?(D)} tests if the argument is the divisor of a function.
543745`\spad{principalIdeal([f1,{}...,{}fn])} returns a record whose generator component is a generator of the ideal generated by \spad{[f1,{}...,{}fn]} whose coef component satisfies \spad{generator = sum (input.i * coef.i)}
543842`\spad{prindINFO }\undocumented
544025`\spad{prinpolINFO }\undocumented
544117`\spad{prinshINFO }\undocumented
544202`\spad{printCode(f)} prints out \spad{f} in FORTRAN notation.
544249`\spad{printHeader()} produces the FORTRAN header for the current subprogram in the global symbol table on the current FORTRAN output stream.
544299`\spad{printHeader(f)} produces the FORTRAN header for subprogram \spad{f} in the global symbol table on the current FORTRAN output stream.
544355`\spad{printHeader(f,{}tab)} produces the FORTRAN header for subprogram \spad{f} in symbol table \spad{tab} on the current FORTRAN output stream.
544414`\axiom{printInfo!(\spad{x},{}\spad{y})} initializes the mesages to be printed when manipulating items from the hash-table. If a key is retrieved then \axiom{\spad{x}} is displayed. If an item is stored then \axiom{\spad{y}} is displayed.
544758`\spad{printStatement(l)} creates a representation of a PRINT statement.
544822`\axiom{printStats!()} prints the statistics.
544896`\spad{printTypes(tab)} produces FORTRAN type declarations from \spad{tab},{} on the current FORTRAN output stream
544951`\spad{printTypes(tab)} produces FORTRAN type declarations from \spad{tab},{} on the current FORTRAN output stream
544999`\spad{print(u)} prints the form \spad{u}.
545041`\spad{print(o)} writes the output form \spad{o} on standard output using the two-dimensional formatter.
545093`\axiom{printingInfo?()} returns \spad{true} iff messages are printed when manipulating items from the hash-table.
545172`\axiom{probablyZeroDim?(\spad{lp})} returns \spad{true} iff the number of polynomials in \axiom{\spad{lp}} is not smaller than the number of variables occurring in these polynomials.
545261`\spad{problemPoints(f,{}var,{}range)} returns a list of possible problem points by looking at the zeros of the denominator of the function \spad{f} if it can be retracted to \axiomType{Polynomial(DoubleFloat)}.
545411`\spad{problemPoints(f,{}var,{}range)} returns a list of possible problem points by looking at the zeros of the denominator of the function if it can be retracted to \axiomType{Polynomial DoubleFloat}.
545548`\spad{processTemplate(tp)} processes the template \spad{tp},{} writing the result to the current FORTRAN output stream.
545615`\spad{processTemplate(tp,{}fn)} processes the template \spad{tp},{} writing the result out to \spad{fn}.
545691`\spad{prod(expr)} creates the form prefixing \spad{expr} by a capital \spad{pi}.
545730`\spad{prod(expr,{}lowerlimit)} creates the form prefixing \spad{expr} by a capital \spad{pi} with a \spad{lowerlimit}.
545772`\spad{prod(expr,{}lowerlimit,{}upperlimit)} creates the form prefixing \spad{expr} by a capital \spad{pi} with both a \spad{lowerlimit} and \spad{upperlimit}.
545817`\spad{product(f(n),{} n = a..b)} returns \spad{f}(a) * ... * \spad{f}(\spad{b}) as a formal product.
545891`\spad{product(f(n),{} n)} returns the formal product \spad{P}(\spad{n}) which verifies \spad{P}(\spad{n+1})\spad{/P}(\spad{n}) = \spad{f}(\spad{n}).
545954`\spad{product(f(n),{} n = a..b)} returns \spad{f}(a) * ... * \spad{f}(\spad{b}) as a formal product.
546029`\spad{product(f(n),{} n)} returns the formal product \spad{P}(\spad{n}) which verifies \spad{P}(\spad{n+1})\spad{/P}(\spad{n}) = \spad{f}(\spad{n}).
546092`\spad{product(a,{}b)} is the degree-preserving \spad{R}-linear product: \blankline \indented{2}{\spad{degree product(a,{}b) = degree a + degree b}} \indented{2}{\spad{product(a1+a2,{}b) = product(a1,{}b) + product(a2,{}b)}} \indented{2}{\spad{product(a,{}b1+b2) = product(a,{}b1) + product(a,{}b2)}} \indented{2}{\spad{product(r*a,{}b) = product(a,{}r*b) = r*product(a,{}b)}} \indented{2}{\spad{product(a,{}product(b,{}c)) = product(product(a,{}b),{}c)}}
546145`\spad{product(s,{}t)} is the outer product of the tensors \spad{s} and \spad{t}. For example,{} if \spad{r = product(s,{}t)} for rank 2 tensors \spad{s} and \spad{t},{} then \spad{r} is a rank 4 tensor given by \indented{4}{\spad{r(i,{}j,{}k,{}l) = s(i,{}j)*t(k,{}l)}.}
546208`\axiom{product(a,{}\spad{b},{}\spad{n})} returns \axiom{a*b} (truncated up to order \axiom{\spad{n}}).
546286`\spad{prolateSpheroidal(a)} transforms from prolate spheroidal coordinates to Cartesian coordinates: \spad{prolateSpheroidal(a)} is a function which will map the point \spad{(\spad{xi},{}eta,{}phi)} to \spad{x = a*sinh(\spad{xi})*sin(eta)*cos(phi)},{} \spad{y = a*sinh(\spad{xi})*sin(eta)*sin(phi)},{} \spad{z = a*cosh(\spad{xi})*cos(eta)}.
546365`\spad{prologue(t)} extracts the prologue section of a formatted object \spad{t}.
546427`\spad{prologue(t)} extracts the prologue section of a TeX form \spad{t}.
546479`\spad{properties(op)} returns the list of all the properties currently attached to \spad{op}.
546553`\spad{property(op,{} s)} returns the value of property \spad{s} if it is attached to \spad{op},{} and "failed" otherwise.
546824`\axiom{pseudoDivide(\spad{P},{}\spad{Q})} computes the pseudoDivide of \axiom{\spad{P}} by \axiom{\spad{Q}}.
546940`\spad{pseudoDivide(p,{}q)} returns \spad{[c,{} q,{} r]},{} when \spad{p' := p*lc(q)**(deg p - deg q + 1) = c * p} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p' = s q + r}.
547069`\axiom{pseudoDivide(a,{}\spad{b})} computes \axiom{[pquo(a,{}\spad{b}),{}prem(a,{}\spad{b})]},{} both polynomials viewed as univariate polynomials in the main variable of \axiom{\spad{b}},{} if \axiom{\spad{b}} is not a constant polynomial.
547241`\spad{pseudoQuotient(p,{}q)} returns \spad{r},{} the quotient when \spad{p' := p*lc(q)**(deg p - deg q + 1)} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p' = s q + r}.
547335`\spad{pseudoRemainder(p,{}q)} = \spad{r},{} for polynomials \spad{p} and \spad{q},{} returns the remainder when \spad{p' := p*lc(q)**(deg p - deg q + 1)} is pseudo right-divided by \spad{q},{} \spadignore{i.e.} \spad{p' = s q + r}.
547409`\spad{psolve(c)} solves the homogeneous linear system \spad{c} \spad{z} = 0 for all possible ranks of the matrix \spad{c}
547655`\spad{psolve(c,{}w)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w}
547910`\spad{psolve(c,{}w)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and indeterminate right hand side \spad{w}
548169`\spad{psolve(c)} solves the homogeneous linear system \spad{c} \spad{z} = 0 for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c}
548431`\spad{psolve(c,{}s)} solves \spad{c} \spad{z} = 0 for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes
548523`\spad{psolve(c,{}w,{}k)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and given right hand side vector \spad{w}
548794`\spad{psolve(c,{}w,{}s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and given right hand side vector \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes
548895`\spad{psolve(c,{}w,{}k)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and indeterminate right hand side \spad{w}
549170`\spad{psolve(c,{}w,{}s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks of the matrix \spad{c} and indeterminate right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes
549275`\spad{psolve(c,{}k,{}s)} solves \spad{c} \spad{z} = 0 for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c},{} writes the results to a file named \spad{s},{} and returns the number of regimes
549383`\spad{psolve(c,{}w,{}k,{}s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and given right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes
549500`\spad{psolve(c,{}w,{}k,{}s)} solves \spad{c} \spad{z} = \spad{w} for all possible ranks \spad{>=} \spad{k} of the matrix \spad{c} and indeterminate right hand side \spad{w},{} writes the results to a file named \spad{s},{} and returns the number of regimes
549621`\spad{ptFunc(a,{}b,{}c,{}d)} is an internal function exported in order to compile packages.
549898`\spad{ptree(s)} is a leaf? pendant tree
549941`\spad{ptree(x,{}y)} \undocumented
549988`\spad{puiseux(f)} returns a Puiseux expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.
550060`\spad{puiseux(x)} returns \spad{x} viewed as a Puiseux series.
550136`\spad{puiseux(f,{}x = a)} expands the expression \spad{f} as a Puiseux series in powers of \spad{(x - a)}.
550221`\spad{puiseux(f,{}n)} returns a Puiseux expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.
550311`\spad{puiseux(r,{}f(x))} returns \spad{f(x^r)}.
550414`\spad{puiseux(f,{}x = a,{}n)} expands the expression \spad{f} as a Puiseux series in powers of \spad{(x - a)}; terms will be computed up to order at least \spad{n}.
550517`\spad{puiseux(n +-> a(n),{}x = a,{}r0..,{}r)} returns \spad{sum(n = r0,{}r0 + r,{}r0 + 2*r...,{} a(n) * (x - a)**n)}; \spad{puiseux(n +-> a(n),{}x = a,{}r0..r1,{}r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)**n)}.
550673`\spad{puiseux(a(n),{}n,{}x = a,{}r0..,{}r)} returns \spad{sum(n = r0,{}r0 + r,{}r0 + 2*r...,{} a(n) * (x - a)**n)}; \spad{puiseux(a(n),{}n,{}x = a,{}r0..r1,{}r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)**n)}.
550815`\spad{pureLex(v1,{}v2)} return \spad{true} if the vector \spad{v1} is less than the vector \spad{v2} in the lexicographic ordering.
550973`\spad{purelyAlgebraic?(ts)} returns \spad{true} iff for every algebraic variable \spad{v} of \spad{ts} we have \spad{algebraicCoefficients?(t_v,{}ts_v_-)} where \spad{ts_v} is \axiomOpFrom{select}{TriangularSetCategory}(\spad{ts},{}\spad{v}) and \spad{ts_v_-} is \axiomOpFrom{collectUnder}{TriangularSetCategory}(\spad{ts},{}\spad{v}).
551138`\spad{purelyAlgebraic?(p,{}ts)} returns \spad{true} iff every variable of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.
551320`\spad{purelyAlgebraicLeadingMonomial?(p,{}ts)} returns \spad{true} iff the main variable of any non-constant iterarted initial of \spad{p} is algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}.
551507`\spad{purelyTranscendental?(p,{}ts)} returns \spad{true} iff every variable of \spad{p} is not algebraic \spad{w}.\spad{r}.\spad{t}. \spad{ts}
551597`\spad{push!(x,{}s)} pushes \spad{x} onto stack \spad{s},{} \spadignore{i.e.} destructively changing \spad{s} so as to have a new first (top) element \spad{x}. Afterwards,{} pop!(\spad{s}) produces \spad{x} and pop!(\spad{s}) produces the original \spad{s}.
551645`\spad{pushFortranOutputStack(f)} pushes \spad{f} onto the Fortran output stack
551725`\spad{pushFortranOutputStack(f)} pushes \spad{f} onto the Fortran output stack
551803`\spad{pushdown(p,{}lv)} \undocumented{}
551872`\spad{pushdown(p,{}v)} \undocumented{}
551935`\spad{pushdown(prf,{}var)} pushes all top level occurences of the variable \spad{var} into the coefficient domain for the polynomial \spad{prf}.
552019`\spad{pushdterm(monom,{}var)} pushes all top level occurences of the variable \spad{var} into the coefficient domain for the monomial \spad{monom}.
552132`\spad{pushucoef(upoly,{}var)} converts the anonymous univariate polynomial \spad{upoly} to a polynomial in \spad{var} over rational functions.
552255`\spad{pushuconst(r,{}var)} takes a rational function and raises all occurances of the variable \spad{var} to the polynomial level.
552361`\spad{pushup(p,{}lv)} \undocumented{}
552428`\spad{pushup(p,{}v)} \undocumented{}
552489`\spad{pushup(prf,{}var)} raises all occurences of the variable \spad{var} in the coefficients of the polynomial \spad{prf} back to the polynomial level.
552571`\spad{putColorInfo(llp,{}lpal)} takes a list of list of points,{} \spad{llp},{} and returns the points with their hue and shade components set according to the list of palette colors,{} \spad{lpal}.
552688`\spad{putGraph(v,{}\spad{gi},{}n)} sets the graph field indicated by \spad{n},{} of the indicated two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} to be the graph,{} \spad{\spad{gi}} of domain \spadtype{GraphImage}. The contents of viewport,{} \spad{v},{} will contain \spad{\spad{gi}} when the function \spadfun{makeViewport2D} is called to create the an updated viewport \sp
552688`--ad{v}.
552772`\spad{qPot(v,{}e)} computes \spad{v**(q**e)},{} interpreting \spad{v} as an element of normal basis field,{} \spad{q} the size of the ground field. This is done by a cyclic \spad{e}-shift of the vector \spad{v}.
552913`\spad{qelt(u,{} x)} applies \axiom{\spad{u}} to \axiom{\spad{x}} without checking whether \axiom{\spad{x}} is in the domain of \axiom{\spad{u}}. If \axiom{\spad{x}} is not in the domain of \axiom{\spad{u}} a memory-access violation may occur. If a check on whether \axiom{\spad{x}} is in the domain of \axiom{\spad{u}} is required,{} use the function \axiom{elt}.
552970`\spad{qelt(m,{}i,{}j)} returns the element in the \spad{i}th row and \spad{j}th column of the matrix \spad{m}. Note: there is NO error check to determine if indices are in the proper ranges.
553054`\spad{qelt(m,{}i,{}j)} returns the element in the \spad{i}th row and \spad{j}th column of the array \spad{m} NO error check to determine if indices are in proper ranges
553136`\spad{qfactor(p)} tries to factor \spad{p} over fractions of integers,{} returning "failed" if it cannot
553284`\spad{qinterval(inf,{}sup)} creates a new interval \axiom{[\spad{inf},{}\spad{sup}]},{} without checking the ordering on the elements.
553338`\spad{qqq(n,{}s,{}st)} is used internally.
553495`\spad{qroot(f,{} n)} returns \spad{[m,{}c,{}r]} such that \spad{f**(1/n) = c * r**(1/m)}.
553697`\spad{qsetelt!(u,{}x,{}y)} sets the image of \axiom{\spad{x}} to be \axiom{\spad{y}} under \axiom{\spad{u}},{} without checking that \axiom{\spad{x}} is in the domain of \axiom{\spad{u}}. If such a check is required use the function \axiom{setelt}.
553796`\spad{qsetelt!(m,{}i,{}j,{}r)} sets the element in the \spad{i}th row and \spad{j}th column of \spad{m} to \spad{r} NO error check to determine if indices are in proper ranges
553884`\spad{quadratic?(e)} tests if \axiom{\spad{e}} is a quadratic function.
553961`\spad{quadraticForm(m)} creates a quadratic form from a symmetric,{} square matrix \spad{m}.
554032`\spad{quadraticNorm(f)} returns the \spad{l2} norm of the polynomial \spad{f}.
554110`\spad{quadratic(u)} \undocumented
554180`\spad{quadratic(f,{}g,{}h)} \undocumented
554253`\spad{quartic(u)} \undocumented
554321`\spad{quartic(f,{}g,{}h,{}i,{}j)} \undocumented
554396`\spad{quasiAlgebraicSet(pl,{}q)} returns the quasi-algebraic set with defining equations \spad{p} = 0 for \spad{p} belonging to the list \spad{pl},{} and defining inequation \spad{q} \spad{^=} 0.
554587`\axiom{quasiComponent(\spad{ts})} returns \axiom{[\spad{lp},{}\spad{lq}]} where \axiom{\spad{lp}} is the list of the members of \axiom{\spad{ts}} and \axiom{\spad{lq}}is \axiom{initials(\spad{ts})}.
554760`\axiom{quasiMonic?(\spad{p})} returns \spad{false} if \axiom{\spad{p}} belongs to \axiom{\spad{R}},{} otherwise returns \spad{true} iff the initial of \axiom{\spad{p}} lies in the base ring \axiom{\spad{R}}.
554835`\axiom{quasiMonicPolynomials(\spad{lp})} returns \axiom{qmps,{}nqmps} where \axiom{qmps} is a list of the quasi-monic polynomials in \axiom{\spad{lp}} and \axiom{nqmps} are the other ones.
554962`\spad{quasiRegular?(x)} return \spad{true} if \spad{constant(p)} is zero.
555025`\spad{quasiRegular?(x)} return \spad{true} if \spad{constant(x)} is zero.
555086`\spad{quasiRegular(x)} return \spad{x} minus its constant term.
555143`\spad{quasiRegular(x)} return \spad{x} minus its constant term.
555198`\spad{quatern(r,{}i,{}j,{}k)} constructs a quaternion from scalars.
555256`\spad{queue([x,{}y,{}...,{}z])} creates a queue with first (top) element \spad{x},{} second element \spad{y},{}...,{}and last (bottom) element \spad{z}.
555299`\spad{quickSort(f,{} agg)} sorts the aggregate agg with the ordering function \spad{f} using the quicksort algorithm.
555376`\spad{quoByVar(a0 + a1 x + a2 x**2 + ...)} returns \spad{a1 + a2 x + a3 x**2 + ...} Thus,{} this function substracts the constant term and divides by the series variable. This function is used when Laurent series are represented by a Taylor series and an order.
555531`\spad{f quo g} creates the equivalent infix form.
555572`\spad{x quo y} is the same as \spad{divide(x,{}y).quotient}. See \spadfunFrom{divide}{EuclideanDomain}.
555618`\spad{a quo b} returns the quotient of \spad{a} and \spad{b},{} forgetting the remainder.
555667`\spad{quote()} provides the string quote character,{} \spad{"}.
555704`\spad{quote(f)} creates the form \spad{f} with a prefix quote.
555744`\spad{quoted?(p)} tests if \spad{p} is of the form \spad{'s} for a symbol \spad{s}.
555791`\spad{quotedOperators(r)} returns the list of operators on the right hand side of \spad{r} that are considered quoted,{} that is they are not evaluated during any rewrite,{} but just applied formally to their arguments.
555862`\spad{quotientByP(x)} returns \spad{b},{} where \spad{x = a + b p}.
555921`\spad{quotient(I,{}f)} computes the quotient of the ideal \spad{I} by the principal ideal generated by the polynomial \spad{f},{} \spad{(I:(f))}.
555998`\spad{quotient(I,{}J)} computes the quotient of the ideals \spad{I} and \spad{J},{} \spad{(I:J)}.
556072`\spad{rCoord(pt)} returns the first element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system.
556123`\spad{radPoly(p(x,{} y))} returns \spad{[c(x),{} n]} if \spad{p} is of the form \spad{y**n - c(x)},{} "failed" otherwise.
556250`\spad{radicalEigenvalues(m)} computes the eigenvalues of the matrix \spad{m}; when possible,{} the eigenvalues are expressed in terms of radicals.
556370`\spad{radicalEigenvector(c,{}m)} computes the eigenvector(\spad{s}) of the matrix \spad{m} corresponding to the eigenvalue \spad{c}; when possible,{} values are expressed in terms of radicals.
556518`\spad{radicalEigenvectors(m)} computes the eigenvalues and the corresponding eigenvectors of the matrix \spad{m}; when possible,{} values are expressed in terms of radicals.
556712`\spad{radicalOfLeftTraceForm()} returns basis for null space of \spad{leftTraceMatrix()},{} if the algebra is associative,{} alternative or a Jordan algebra,{} then this space equals the radical (maximal nil ideal) of the algebra.
556781`\spad{radicalRoots(rf,{}x)} finds the roots expressed in terms of radicals of the rational function \spad{rf} with respect to the symbol \spad{x}.
556885`\spad{radicalRoots(lrf,{}lvar)} finds the roots expressed in terms of radicals of the list of rational functions \spad{lrf} with respect to the list of symbols \spad{lvar}.
557007`\spad{radicalSimplify(s)} returns a different and presumably simpler representation of \spad{s} with the defining polynomials for the equati
557007`--ons forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using using groebner basis of radical ideals
557374`\spad{radicalSolve(eq)} finds the solutions expressed in terms of radicals of the equation of rational functions \spad{eq} with respect to the unique symbol \spad{x} appearing in \spad{eq}.
557491`\spad{radicalSolve(rf)} finds the solutions expressed in terms of radicals of the equation \spad{rf} = 0,{} where \spad{rf} is a univariate rational function.
557598`\spad{radicalSolve(leq)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \spad{leq} with respect to the unique symbol \spad{x} appearing in \spad{leq}.
557727`\spad{radicalSolve(lrf)} finds the solutions expressed in terms of radicals of the system of equations \spad{lrf} = 0,{} where \spad{lrf} is a system of univariate rational functions.
557846`\spad{radicalSolve(eq,{}x)} finds the solutions expressed in terms of radicals of the equation of rational functions \spad{eq} with respect to the symbol \spad{x}.
557970`\spad{radicalSolve(rf,{}x)} finds the solutions expressed in terms of radicals of the equation \spad{rf} = 0 with respect to the symbol \spad{x},{} where \spad{rf} is a rational function.
558084`\spad{radicalSolve(leq,{}lvar)} finds the solutions expressed in terms of radicals of the system of equations of rational functions \spad{leq} with respect to the list of symbols \spad{lvar}.
558226`\spad{radicalSolve(lrf,{}lvar)} finds the solutions expressed in terms of radicals of the system of equations \spad{lrf} = 0 with respect to the list of symbols \spad{lvar},{} where \spad{lrf} is a list of rational functions.
558358`\spad{radical(I)} returns the radical of the ideal \spad{I}.
558722`\spad{radix(x,{}b)} converts \spad{x} to a radix expansion in base \spad{b}.
558790`\spad{raisePolynomial(rpoly)} converts \spad{rpoly} from a univariate polynomial over \spad{r} to be a univariate polynomial with polynomial coefficients.
558912`\spad{ramified?(a)} tests whether \spad{x = a} is ramified.
558982`\spad{ramified?(p)} tests whether \spad{p(x) = 0} is ramified.
559053`\spad{ramifiedAtInfinity?()} tests if infinity is ramified.
559132`\spad{ran(k)} computes a random integer between \spad{-k} and \spad{k} as a member of \spad{R}.
559192`\spad{randnum()} is a random number between 0 and size().
559245`\spad{randnum(n)} is a random number between 0 and \spad{n}.
559305`\spad{randomLC(n,{}x)} should be local but conditional.
559388`\spad{randomR()} should be local but conditional
559454`\spad{randomR produces} a random element of \spad{R}
559531`\spad{randomR()} produces a random element of \spad{R}
559754`\spad{random()} returns a random element from the set.
559789`\spad{random()} creates a random element.
559837`\spad{random()} returns a random fraction.
559916`\spad{random(n)}\$FFPOLY(\spad{GF}) generates a random monic polynomial of degree \spad{n} over the finite field {\em GF}.
560020`\spad{random(n)} creates a vector over the ground field with random entries.
560106`\spad{random(gp)} returns a random product of maximal 20 generators of the group {\em gp}. Note: {\em random(gp)=random(gp,{}20)}.
560168`\spad{random(a)} creates a random element from 0 to \spad{n-1}.
560218`\spad{random(n)} returns a random integer from 0 to \spad{n-1}.
560256`\spad{random(n)} returns a random integer from 0 to \spad{n-1}.
560305`\spad{random(m,{}n)}\$FFPOLY(\spad{GF}) generates a random monic polynomial of degree \spad{d} over the finite field {\em GF},{} \spad{d} between \spad{m} and \spad{n}.
560425`\spad{random(gp,{}i)} returns a random product of maximal \spad{i} generators of the group {\em gp}.
560495`\spad{rangeIsFinite(args)} tests the endpoints of \spad{args.range} for infinite end points.
560896`\spad{rangePascalTriangle()} returns the maximal number of lines stored.
560977`\spad{rangePascalTriangle(n)} sets the maximal number of lines which are stored and returns the previous value.
561076`\spad{range([l])} provides a user-specified range \spad{l}. This option is expressed in the form \spad{range == [l]}.
561134`\spad{range([i])} provides a user-specified range \spad{i}. This option is expressed in the form \spad{range == [i]}.
561204`\spad{ranges(\spad{gi})} returns the list of ranges of the point components from the indicated graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.
561263`\spad{ranges(l)} provides a list of user-specified ranges \spad{l}. This option is expressed in the form \spad{ranges == l}.
561322`\spad{ranges(l,{}r)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{ranges}. If the option does not exist the value,{} \spad{r} is returned.
561426`\spad{ranges(\spad{gi},{}lr)} modifies the list of ranges for the given graph,{} \spad{\spad{gi}} of the domain \spadtype{GraphImage},{} to be that of the list of range segments,{} \spad{lr},{} and returns the new range list for \spad{\spad{gi}}.
561562`\spad{rank()} returns the rank of the algebra.
561625`\spad{rank()} returns the rank of the algebra as \spad{R}-module.
561699`\spad{rank(m)} returns the rank of the matrix \spad{m}.
561789`\spad{rank(m)} returns the rank of the matrix \spad{m}.
561895`\spad{rank(m)} returns the rank of the matrix \spad{m}.
561986`\spad{rank(m)} returns the rank of the matrix \spad{m}.
562092`\spad{rank(t)} returns the tensorial rank of \spad{t} (that is,{} the number of indices). This is the same as the graded module degree.
562165`\spad{rank(A,{}B)} computes the rank of the complete matrix \spad{(A|B)} of the linear system \spad{AX = B}.
562251`\spad{rank(A,{}B)} computes the rank of the complete matrix \spad{(A|B)} of the linear system \spad{AX = B}.
562342`\spad{rarrow(f,{}g)} creates a form for the mapping \spad{f -> g}.
562386`\spad{ratDenom(f)} rationalizes the denominators appearing in \spad{f} by moving all the algebraic quantities into the numerators.
562444`\spad{ratDenom(f,{} a)} removes \spad{a} from the denominators in \spad{f} if \spad{a} is an algebraic kernel.
562504`\spad{ratDenom(f,{} [a1,{}...,{}an])} removes the \spad{ai}\spad{'s} which are algebraic kernels from the denominators in \spad{f}.
562570`\spad{ratDenom(f,{} [a1,{}...,{}an])} removes the \spad{ai}\spad{'s} which are algebraic from the denominators in \spad{f}.
562644`\spad{ratDsolve(op,{} g)} returns \spad{["failed",{} []]} if the equation \spad{op y = g} has no rational solution. Otherwise,{} it returns \spad{[f,{} [y1,{}...,{}ym]]} where \spad{f} is a particular rational solution and the \spad{yi}\spad{'s} form a basis for the rational solutions of the homogeneous equation.
562826`\spad{ratDsolve(op,{} [g1,{}...,{}gm])} returns \spad{[[h1,{}...,{}hq],{} M]} such that any rational solution of \spad{op y = c1 g1 + ... + cm gm} is of the form \spad{d1 h1 + ... + dq hq} where \spad{M [d1,{}...,{}dq,{}c1,{}...,{}cm] = 0}.
562988`\spad{ratDsolve(op,{} g)} returns \spad{["failed",{} []]} if the equation \spad{op y = g} has no rational solution. Otherwise,{} it returns \spad{[f,{} [y1,{}...,{}ym]]} where \spad{f} is a particular rational solution and the \spad{yi}\spad{'s} form a basis for the rational solutions of the homogeneous equation.
563173`\spad{ratDsolve(op,{} [g1,{}...,{}gm])} returns \spad{[[h1,{}...,{}hq],{} M]} such that any rational solution of \spad{op y = c1 g1 + ... + cm gm} is of the form \spad{d1 h1 + ... + dq hq} where \spad{M [d1,{}...,{}dq,{}c1,{}...,{}cm] = 0}.
563338`\spad{ratPoly(f)} returns a polynomial \spad{p} such that \spad{p} has no algebraic coefficients,{} and \spad{p(f) = 0}.
563645`\spad{rational?(x)} returns \spad{true} if \spad{x} is a rational number,{} \spad{false} otherwise.
563705`\spad{rational?(x)} tests if \spad{x} is a rational number.
563788`\spad{rational?(n)} tests if \spad{n} is a rational number (see \spadtype{Fraction Integer}).
563846`\spad{rational?(o)} tests if \spad{o} is rational,{} \spadignore{i.e.} that all seven imaginary parts are 0.
563930`\spad{rational?(q)} returns {\it \spad{true}} if all the imaginary parts of \spad{q} are zero and the real part can be converted into a rational number,{} and {\it \spad{false}} otherwise.
564016`\spad{rational?(u)} tests if \spadvar{\spad{u}} is actually a rational number (see \spadtype{Fraction Integer}).
564092`\spad{rational?(x)} tests if \spad{x} is a finite rational number.
564178`\spad{rational?(x)} tests if \spad{x} is a finite rational number.
564263`\spad{rationalApproximation(f,{} n)} computes a rational approximation \spad{r} to \spad{f} with relative error \spad{< 10**(-n)}.
564354`\spad{rationalApproximation(f,{} n)} computes a rational approximation \spad{r} to \spad{f} with relative error \spad{< 10**(-n)}.
564439`\spad{rationalApproximation(f,{} n,{} b)} computes a rational approximation \spad{r} to \spad{f} with relative error \spad{< b**(-n)} (that is,{} \spad{|(r-f)/f| < b**(-n)}).
564549`\spad{rationalApproximation(f,{} n,{} b)} computes a rational approximation \spad{r} to \spad{f} with relative error \spad{< b**(-n)},{} that is \spad{|(r-f)/f| < b**(-n)}.
564653`\spad{rationalFunction(f,{}k)} returns a rational function consisting of the sum of all terms of \spad{f} of degree \spad{<=} \spad{k}.
564787`\spad{rationalFunction(f,{}k1,{}k2)} returns a rational function consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.
565271`\spad{rationalIfCan(x)} returns \spad{x} as a rational number,{} "failed" if \spad{x} is not a rational number.
565361`\spad{rationalIfCan(x)} returns \spad{x} as a rational number,{} or "failed" if \spad{x} is not a rational number.
565474`\spad{rationalIfCan(n)} creates a rational number,{} or returns "failed" if this is not possible.
565562`\spad{rationalIfCan(o)} returns the real part if all seven imaginary parts are 0,{} and "failed" otherwise.
565676`\spad{rationalIfCan(q)} returns \spad{q} as a rational number,{} or "failed" if this is not possible. Note: if \spad{rational?(q)} is \spad{true},{} the conversion can be done and the rational number will be returned.
565792`\spad{rationalIfCan(u)} returns a rational number if \spad{u} really is one,{} and "failed" otherwise.
565898`\spad{rationalIfCan(x)} returns \spad{x} as a finite rational number if it is one,{} "failed" otherwise.
566014`\spad{rationalIfCan(x)} returns \spad{x} as a finite rational number if it is one and "failed" otherwise.
566129`\spad{rationalPoint?(a,{} b)} tests if \spad{(x=a,{}y=b)} is on the curve.
566209`\spad{rationalPoint?(a,{} b)} tests if \spad{(x=a,{}y=b)} is on the curve.
566286`\spad{rationalPoints()} returns the list of all the affine rational points.
566369`\spad{rationalPoints()} returns the list of all the affine rational points.
566462`\spad{rationalPower(f(x))} returns \spad{r} where the Puiseux series \spad{f(x) = g(x^r)}.
566825`\spad{rational(x)} returns \spad{x} as a rational number; error if \spad{x} is not a rational number.
566894`\spad{rational(x)} returns \spad{x} as a rational number. Error: if \spad{x} is not a rational number.
566986`\spad{rational(n)} creates a rational number (see \spadtype{Fraction Integer})..
567053`\spad{rational(o)} returns the real part if all seven imaginary parts are 0. Error: if \spad{o} is not rational.
567146`\spad{rational(q)} tries to convert \spad{q} into a rational number. Error: if this is not possible. If \spad{rational?(q)} is \spad{true},{} the conversion will be done and the rational number returned.
567241`\spad{rational(u)} assumes spadvar{\spad{u}} is actually a rational number and does the conversion to rational number (see \spadtype{Fraction Integer}).
567326`\spad{rational(x)} returns \spad{x} as a finite rational number. Error: if \spad{x} is not a rational number.
567421`\spad{rational(x)} returns \spad{x} as a finite rational number. Error: if \spad{x} cannot be so converted.
567515`\spad{ratpart(ir)} returns the rational part of an integration result
567566`\spad{ravel(t)} produces a list of components from a tensor such that \indented{2}{\spad{unravel(ravel(t)) = t}.}
567629`\spad{rdHack1(v,{}u,{}n)} \undocumented
567717`\spad{rdregime(s)} reads in a list from a file with name \spad{s}
567961`\spad{read!(f)} extracts a value from file \spad{f}. The state of \spad{f} is modified so a subsequent call to \spadfun{read!} will return the next element.
568010`\spad{readIfCan!(f)} returns a value from the file \spad{f},{} if possible. If \spad{f} is not open for reading,{} or if \spad{f} is at the end of file then \spad{"failed"} is the result.
568067`\spad{readIfCan!(f)} returns a value from the file \spad{f},{} if possible. If \spad{f} is not open for reading,{} or if \spad{f} is at the end of file then \spad{"failed"} is the result.
568139`\spad{readIfCan!(f)} returns a string of the contents of a line from file \spad{f},{} if possible. If \spad{f} is not readable or if it is positioned at the end of file,{} then \spad{"failed"} is returned.
568202`\spad{readLine!(f)} returns a string of the contents of a line from the file \spad{f}.
568248`\spad{readLineIfCan!(f)} returns a string of the contents of a line from file \spad{f},{} if possible. If \spad{f} is not readable or if it is positioned at the end of file,{} then \spad{"failed"} is returned.
568315`\spad{readable?(f)} tests if the named file exist and can it be opened for reading.
568370`\spad{real?(f)} returns \spad{true} if \spad{f = real f}.
568442`\spad{real?(f)} returns \spad{true} if \spad{f = real f}.
568507`\spad{real?(t)} tests whether \spad{t} is equivalent to the FORTRAN type REAL.
568559`\spad{realEigenvalues(m,{}eps)} computes the eigenvalues of the matrix \spad{m} to precision \spad{eps}. The eigenvalues are expressed as floats or rational numbers depending on the type of \spad{eps} (float or rational).
568661`\spad{realEigenvectors(m,{}eps)} returns a list of records each one containing a real eigenvalue,{} its algebraic multiplicity,{} and a list of associated eigenvectors. All these results are computed to precision \spad{eps} as floats or rational numbers depending on the type of \spad{eps} .
568821`\spad{realElementary(f)} rewrites \spad{f} in terms of the 4 fundamental real transcendental elementary functions: \spad{log,{} exp,{} tan,{} atan}.
568897`\spad{realElementary(f,{}x)} rewrites the kernels of \spad{f} involving \spad{x} in terms of the 4 fundamental real transcendental elementary functions: \spad{log,{} exp,{} tan,{} atan}.
568980`\spad{realRoots(rf,{} eps)} finds the real zeros of a univariate rational function with precision given by eps.
569076`\spad{realRoots(lp,{}lv,{}eps)} computes the list of the real solutions of the list \spad{lp} of rational functions with rational coefficients with respect to the variables in \spad{lv},{} with precision \spad{eps}. Each solution is expressed as a list of numbers in order corresponding to the variables in \spad{lv}.
569197`\spad{realSolve(lp)} returns the same as \spad{realSolve(ts,{}false,{}false,{}false)}
569319`\spad{realSolve(ts)} returns the set of the points in the regular zero set of \spad{ts} whose coordinates are all real. WARNING: For each set of coordinates given by \spad{realSolve(ts)} the ordering of the indeterminates is reversed \spad{w}.\spad{r}.\spad{t}. \spad{ls}.
569440`\spad{realSolve(ts,{}info?)} returns the same as \spad{realSolve(ts,{}info?,{}false,{}false)}.
569570`\spad{realSolve(lp,{}lv,{}eps)} = compute the list of the real solutions of the list \spad{lp} of polynomials with integer coefficients with respect to the variables in \spad{lv},{} with precision \spad{eps}.
569677`\spad{realSolve(ts,{}info?,{}check?)} returns the same as \spad{realSolve(ts,{}info?,{}check?,{}false)}.
569815`\spad{realSolve(ts,{}info?,{}check?,{}lextri?)} returns the set of the points in the variety associated with \spad{lp} whose coordinates are all real. Moreover,{} if \spad{info?} is \spad{true} then some information is displayed during decomposition into regular chains. If \spad{check?} is \spad{true} then the result is checked. If \spad{lextri?} is \spad{tru
569815`--e} then the lexTriangular algorithm is called from the \spadtype{LexTriangularPackage} constructor (see \axiomOpFrom{zeroSetSplit}{LexTriangularPackage}(\spad{lp},{}\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \axiomOpFrom{zeroSetSplit}{RegularChain} from \spadtype{RegularChain}. WARNING: For each set of coordinates given by \spad{realSolve(ts,{}info?,{}check?,{}lextri?)} the ordering of the indeterminates is reversed \spad{w
569815`--}.\spad{r}.\spad{t}. \spad{ls}.
569961`\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \spad{pol}.
570074`\spad{realZeros(pol)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \spad{pol}.
570188`\spad{realZeros(pol,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \spad{pol}.
570319`\spad{realZeros(pol,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \spad{pol}.
570451`\spad{realZeros(pol,{} range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \spad{pol} which lie in the interval expressed by the record range.
570619`\spad{realZeros(pol,{} range)} returns a list of isolating intervals for all the real zeros of the univariate polynomial \spad{pol} which lie in the interval expressed by the record range.
570788`\spad{realZeros(pol,{} int,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \spad{pol} which lie in the interval expressed by the record \spad{int}.
570974`\spad{realZeros(pol,{} int,{} eps)} returns a list of intervals of length less than the rational number eps for all the real roots of the polynomial \spad{pol} which lie in the interval expressed by the record \spad{int}.
571161`\spad{real(f)} returns the real part of \spad{f} where \spad{f} is a complex function.
571238`\spad{real(f)} returns the real part of \spad{f} where \spad{f} is a complex function.
571296`\spad{real(x)} returns real part of \spad{x}.
571342`\spad{real(o)} extracts real part of octonion \spad{o}.
571389`\spad{real(q)} extracts the real part of quaternion \spad{q}.
571438`\spad{recip()} returns \spad{matrix [[0,{}1],{}[1,{}0]]} representing the map \spad{x -> 1 / x}.
571839`\spad{recip(a)} returns the power series reciprocal of \spad{a},{} or "failed" if not possible.
571930`\spad{recip(x)} \undocumented
572030`\spad{recip(x)} \undocumented
572119`\spad{recip(m)} = recip() * \spad{m}
572168`\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \spad{a},{} or \spad{"failed"} if there is no unit element,{} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
572269`\spad{recip(a)} returns an element,{} which is both a left and a right inverse of \spad{a},{} or \spad{"failed"} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
572328`\spad{recip(x)} tries to compute the multiplicative inverse for \spad{x} or "failed" if it cannot find the inverse (see unitsKnown).
572380`\spad{recip(x)} computes the multiplicative inverse of \spad{x} or "failed" if \spad{x} is not invertible.
572554`\axiom{recip(\spad{p},{}\spad{ts})} returns the inverse of \axiom{\spad{p}} \spad{w}.\spad{r}.\spad{t} \spad{ts} assuming that \axiom{\spad{p}} is invertible \spad{w}.\spad{r}.\spad{t} \spad{ts}.
572635`\axiom{recip(pol,{}aRoot)} tries to inverse \axiom{pol} interpreted as \axiom{aRoot}
572744`\spad{reciprocalPolynomial(p)} calulates a polynomial which has exactly the inverses of the non-zero roots of \spad{p} as roots,{} and the same number of 0-roots.
572820`\spad{recolor()},{} uninteresting to top level user; exported in order to compile package.
573030`\spad{recoverAfterFail(routs,{}routineName,{}ifailValue)} acts on the instructions given by the ifail list
573119`\spad{rectangularMatrix(m)} converts a matrix of type \spadtype{Matrix} to a matrix of type \spad{RectangularMatrix}.
573192`\spad{recur(g)} is the function \spad{h} such that \indented{1}{\spad{h(n,{}x)= g(n,{}g(n-1,{}..g(1,{}x)..))}.}
573286`\spad{recur(n,{}g,{}x)} is \spad{g(n,{}g(n-1,{}..g(1,{}x)..))}.
573390`\spad{redPo }\undocumented
573503`\spad{redPol }\undocumented
573595`\spad{red()} returns the position of the red hue from total hues.
573626`\spad{redmat(m,{}g)} returns a matrix whose entries are those of \spad{m} modulo the ideal generated by the groebner basis \spad{g}
573723`\spad{redpps(s,{}g)} returns the simplified form of \spad{s} after reducing modulo a groebner basis \spad{g}
574072`\spad{reduceBasisAtInfinity(b1,{}...,{}bn)} returns \spad{(x**i * bj)} for all \spad{i},{}\spad{j} such that \spad{x**i*bj} is locally integral at infinity.
574237`\axiom{reduceByQuasiMonic(\spad{p},{}\spad{ts})} returns the same as \axiom{remainder(\spad{p},{}collectQuasiMonic(\spad{ts})).polnum}.
574311`\spad{reduceLODE(op,{} g)} returns \spad{[m,{} v]} such that any solution in \spad{A} of \spad{op z = g} is of the form \spad{z = (z_1,{}...,{}z_m) . (b_1,{}...,{}b_m)} where the \spad{b_i's} are the basis of \spad{A} over \spad{F} returned by \spadfun{basis}() from \spad{A},{} and the \spad{z_i's} satisfy the differential system \spad{M.z = v}.
574404`\spad{reduce(f)} produces the equivalence class of \spad{f} in the residue ring
574650`\spad{reduce(x)} \undocumented
574770`\spad{reduce(p)} \undocumented{}
574968`\spad{reduce(f)} simplifies all the unreduced algebraic numbers present in \spad{f} by applying their defining relations.
575019`\spad{reduce(frac)} converts the fraction \spad{frac} to an algebra element.
575110`\spad{reduce(up)} converts the univariate polynomial \spad{up} to an algebra element,{} reducing by the \spad{definingPolynomial()} if necessary.
575163`\spad{reduce(D)} converts \spad{D} to some reduced form (the reduced forms can be differents in different implementations).
575228`\spad{reduce(f)} simplifies all the unreduced algebraic numbers present in \spad{f} by applying their defining relations.
575274`\spad{reduce(f)} simplifies all the unreduced algebraic quantities present in \spad{f} by applying their defining relations.
575573`\spad{reduce(r,{}m)} \undocumented
575661`\spad{reduce(r,{}m)} \undocumented
575739`\spad{reduce(r,{}m)} \undocumented
575816`\spad{reduce(f,{}u)} reduces the binary operation \spad{f} across \spad{u}. For example,{} if \spad{u} is \axiom{[\spad{x},{}\spad{y},{}...,{}\spad{z}]} then \axiom{reduce(\spad{f},{}\spad{u})} returns \axiom{\spad{f}(..\spad{f}(\spad{f}(\spad{x},{}\spad{y}),{}...),{}\spad{z})}. Note: if \spad{u} has one element \spad{x},{} \axiom{reduce(\spad{f},{}\spad{u})} returns \spad{x}. Error: if \spad{u} is empty.
576144`\spad{reduce(func,{}vec,{}ident)} combines the elements in \spad{vec} using the binary function \spad{func}. Argument \spad{ident} is returned if the vector is empty.
576235`\spad{reduce(fn,{}u,{}ident)} successively uses the binary function \spad{fn} on the elements of list \spad{u} and the result of previous applications. \spad{ident} is returned if the \spad{u} is empty. Note the order of application in the following examples: \spad{reduce(fn,{}[1,{}2,{}3],{}0) = fn(3,{}fn(2,{}fn(1,{}0)))} and \spad{reduce(*,{}[2,{}3],{}1) = 3 * (2 * 1)}.
576300`\spad{reduce(f,{}a,{}r)} applies function \spad{f} to each successive element of the one-dimensional array \spad{a} and an accumulant initialized to \spad{r}. For example,{} \spad{reduce(_+\$Integer,{}[1,{}2,{}3],{}0)} does \spad{3+(2+(1+0))}. Note: third argument \spad{r} may be regarded as the identity element for the function \spad{f}.
576395`\spad{reduce(f,{}a,{}r)} applies function \spad{f} to each successive element of the primitive array \spad{a} and an accumulant initialized to \spad{r}. For example,{} \spad{reduce(_+\$Integer,{}[1,{}2,{}3],{}0)} does \spad{3+(2+(1+0))}. Note: third argument \spad{r} may be regarded as the identity element for the function \spad{f}.
576480`\spad{reduce(func,{}vec,{}ident)} combines the elements in \spad{vec} using the binary function \spad{func}. Argument \spad{ident} is returned if \spad{vec} is empty.
576549`\spad{reduce(f,{}m,{}r)} returns a matrix \spad{n} where \spad{n[i,{}j] = f(m[i,{}j],{}r)} for all indices \spad{i} and \spad{j}.
576652`\spad{reduce(f,{}m,{}r)} returns a matrix \spad{n} where \spad{n[i,{}j] = f(m[i,{}j],{}r)} for all indices spad{\spad{i}} and \spad{j}.
576770`\spad{reduce(f,{}a,{}r)} applies function \spad{f} to each successive element of the aggregate \spad{a} and an accumulant initialized to \spad{r}. For example,{} \spad{reduce(_+\$Integer,{}[1,{}2,{}3],{}0)} does \spad{3+(2+(1+0))}. Note: third argument \spad{r} may be regarded as the identity element for the function \spad{f}.
576850`\spad{reduce(f,{}a,{}r)} applies function \spad{f} to each successive element of the aggregate \spad{a} and an accumulant initialised to \spad{r}. For example,{} \spad{reduce(_+\$Integer,{}[1,{}2,{}3],{}0)} does a \spad{3+(2+(1+0))}. Note: third argument \spad{r} may be regarded as an identity element for the function.
576927`\spad{reduce(f,{}u,{}x)} reduces the binary operation \spad{f} across \spad{u},{} where \spad{x} is the identity operation of \spad{f}. Same as \axiom{reduce(\spad{f},{}\spad{u})} if \spad{u} has 2 or more elements. Returns \axiom{\spad{f}(\spad{x},{}\spad{y})} if \spad{u} has one element \spad{y},{} \spad{x} if \spad{u} is empty. For example,{} \axiom{reduce(+,{}\spad{u},{}0)} returns the sum of the elements of \sp
576927`--ad{u}.
577015`\spad{reduce(b,{}f,{}u)},{} where \spad{u} is a finite stream \spad{[x0,{}x1,{}...,{}xn]},{} returns the value \spad{r(n)} computed as follows: \spad{r0 = f(x0,{}b),{} r1 = f(x1,{}r0),{}...,{} r(n) = f(xn,{}r(n-1))}.
577417`\spad{reduce(f,{}u,{}x,{}z)} reduces the binary operation \spad{f} across \spad{u},{} stopping when an "absorbing element" \spad{z} is encountered. As for \axiom{reduce(\spad{f},{}\spad{u},{}\spad{x})},{} \spad{x} is the identity operation of \spad{f}. Same as \axiom{reduce(\spad{f},{}\spad{u},{}\spad{x})} when \spad{u} contains no element \spad{z}. Thus the third argument \spad{x} is retur
577417`--ned when \spad{u} is empty.
577531`\axiom{reduce(\spad{p},{}\spad{ts},{}redOp,{}redOp?)} returns a polynomial \axiom{\spad{r}} such that \axiom{redOp?(\spad{r},{}\spad{p})} holds for every \axiom{\spad{p}} of \axiom{\spad{ts}} and there exists some product \axiom{\spad{h}} of the initials of the members of \axiom{\spad{ts}} such that \axiom{\spad{h*p} - \spad{r}} lies in the ideal generated by \axiom{\spad{ts}}. The operation \axiom{redOp} must satisfy
577531`-- the following conditions. For every \axiom{\spad{p}} and \axiom{\spad{q}} we have \axiom{redOp?(redOp(\spad{p},{}\spad{q}),{}\spad{q})} and there exists an integer \axiom{\spad{e}} and a polynomial \axiom{\spad{f}} such that \axiom{init(\spad{q})^e*p = \spad{f*q} + redOp(\spad{p},{}\spad{q})}.
577765`\axiom{reduced?(\spad{q},{}\spad{lp})} returns \spad{true} iff \axiom{reduced?(\spad{q},{}\spad{p})} holds for every \axiom{\spad{p}} in \axiom{\spad{lp}}.
577846`\axiom{reduced?(a,{}\spad{b})} returns \spad{true} iff \axiom{degree(a,{}mvar(\spad{b})) < mdeg(\spad{b})}.
578003`\axiom{reduced?(\spad{p},{}\spad{ts},{}redOp?)} returns \spad{true} iff \axiom{\spad{p}} is reduced \spad{w}.\spad{r}.\spad{t}. in the sense of the operation \axiom{redOp?},{} that is if for every \axiom{\spad{t}} in \axiom{\spad{ts}} \axiom{redOp?(\spad{p},{}\spad{t})} holds.
578088`\spad{reducedContinuedFraction(b0,{}b)} constructs a continued fraction in the following way: if \spad{b = [b1,{}b2,{}...]} then the result is the continued fraction \spad{b0 + 1/(b1 + 1/(b2 + ...))}. That is,{} the result is the same as \spad{continuedFraction(b0,{}[1,{}1,{}1,{}...],{}[b1,{}b2,{}b3,{}...])}.
578166`\spad{reducedDiscriminant(up)} \undocumented
578254`\spad{reducedForm(x)} puts the continued fraction \spadvar{\spad{x}} in reduced form,{} \spadignore{i.e.} the function returns an equivalent continued fraction of the form \spad{continuedFraction(b0,{}[1,{}1,{}1,{}...],{}[b1,{}b2,{}b3,{}...])}.
578310`\spad{reducedQPowers(f)} generates \spad{[x,{}x**q,{}x**(q**2),{}...,{}x**(q**(n-1))]} reduced modulo \spad{f} where \spad{q = size()\$GF} and \spad{n = degree f}.
579425`\spad{reducedSystem(A)} returns a matrix \spad{B} such that \spad{A x = 0} and \spad{B x = 0} have the same solutions in \spad{R}.
580945`\spad{reducedSystem(A,{} v)} returns a matrix \spad{B} and a vector \spad{w} such that \spad{A x = v} and \spad{B x = w} have the same solutions in \spad{R}.
581062`\spad{reduction(p,{}prime)} reduces the polynomial \spad{p} modulo \spad{prime} of \spad{R}. Note: this function is exported only because it\spad{'s} conditional.
581115`\spad{reduction(f,{}p)} reduces the coefficients of the polynomial \spad{f} modulo the prime \spad{p}.
581185`\spad{reduction(u,{}pol)} computes the symmetric reduction of \spad{u} mod \spad{pol}
581382`\spad{reductum(p)},{} where \spad{p} is an antisymmetric polynomial,{} returns \spad{p} minus the leading term of \spad{p} if \spad{p} has at least two terms,{} and 0 otherwise.
581431`\spad{reductum(df)},{} where \spad{df} is a differential form,{} returns \spad{df} minus the leading term of \spad{df} if \spad{df} has two or more terms,{} and 0 otherwise.
581498`\spad{reductum(x)} \undocumented
581570`\spad{reductum(x)} \undocumented
581626`\spad{reductum(f)} is \spad{f} minus its leading monomial.
581691`\spad{reductum(p)} returns \spad{p} minus its leading term. An error is produced if \spad{p} is zero.
581744`\spad{reductum(u)} returns \spad{u} minus its leading monomial returns zero if handed the zero element.
581799`\spad{reductum(x)} returns \spad{x} minus its leading term.
581854`\spad{reductum(z)} returns a new element created by removing the leading coefficient/support pair from the element \spad{z}. Error: if \spad{z} has no support.
581920`\spad{reductum(l)} is \spad{l - monomial(a(n),{}n)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
581979`\spad{reductum(l)} is \spad{l - monomial(a(n),{}n)} if \indented{2}{\spad{l = sum(monomial(a(i),{}i),{} i = 0..n)}.}
582112`\axiom{reductum(\spad{p},{}\spad{v})} returns the reductum of \axiom{\spad{p}},{} where \axiom{\spad{p}} is viewed as a univariate polynomial in \axiom{\spad{v}}.
582181`\spad{ref(n)} creates a pointer (reference) to the object \spad{n}.
582220`\spad{refine(x)} \undocumented
582257`\spad{refine(p)} performs a refinement on the plot \spad{p}
582292`\axiom{refine(rootChar)} shrinks isolating interval around \axiom{rootChar}
582380`\spad{refine(u,{}fn)} is used to apply the function \userfun{\spad{fn}} to each factor of \spadvar{\spad{u}} and then build a new factored object from the results. For example,{} if \spadvar{\spad{u}} were created by calling \spad{nilFactor(10,{}2)} then \spad{refine(u,{}factor)} would create a factored object equal to that created by \spad{factor(100)} or \spad{primeFactor(2,{}2) * primeFactor(5,{}2)}.
582474`\spad{refine(p,{}x)} \undocumented{}
582540`\spad{refine(x,{}r)} \undocumented
582598`\spad{refine(x,{}r)} \undocumented
582654`\spad{refine(pol,{} int,{} eps)} refines the interval \spad{int} containing exactly one root of the univariate polynomial \spad{pol} to size less than the rational number eps.
582831`\spad{refine(pol,{} int,{} eps)} refines the interval \spad{int} containing exactly one root of the univariate polynomial \spad{pol} to size less than the rational number eps.
583009`\spad{refine(pol,{} int,{} range)} takes a univariate polynomial \spad{pol} and and isolating interval \spad{int} containing exactly one real root of \spad{pol}; the operation returns an isolating interval which is contained within range,{} or "failed" if no such isolating int
583009`--erval exists.
583239`\spad{refine(pol,{} int,{} range)} takes a univariate polynomial \spad{pol} and and isolating interval \spad{int} which must contain exactly one real root of \spad{pol},{} and returns an isolating interval which is contained within range,{} or "failed" if no such isolating in
583239`--terval exists.
583470`\spad{regime(y,{}c,{} w,{} p,{} r,{} rm,{} m)} returns a regime,{} a list of polynomials specifying the consistency conditi
583470`--ons,{} a particular solution and basis representing the general solution of the parametric linear system \spad{c} \spad{z} = \spad{w} on that regime. The regime returned depends on the subdeterminant \spad{y}.det and the row and column indices. The solutions are simplified using the assumption that the system has rank \spad{r} and maximum rank \spad{rm}. The list \spad{p} represents a list of list of factors of polynomials in a groebner basis of the ideal generated by higher order subdetermina
583470`--nts,{} and ius used for the simplification. The mode \spad{m} distinguishes the cases when the system is homogeneous,{} or the right hand side is arbitrary,{} or when there is no new right hand side variables.
583854`\spad{region(v,{}n,{}s)} displays the bounding box of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the bounding box if \spad{s} is "off".
584001`\spad{regularRepresentation(a)} returns the matrix of the linear map defined by left multiplication by \spad{a} with respect to the fixed basis.
584235`\spad{regularRepresentation(a,{}basis)} returns the matrix of the linear map defined by left multiplication by \spad{a} with respect to the \spad{basis} \spad{basis}.
584322`\spad{reindex(t,{}[i1,{}...,{}idim])} permutes the indices of \spad{t}. For example,{} if \spad{r = reindex(t,{} [4,{}1,{}2,{}3])} for a rank 4 tensor \spad{t},{} then \spad{r} is the rank for tensor given by \indented{4}{\spad{r(i,{}j,{}k,{}l) = t(l,{}i,{}j,{}k)}.}
584396`\spad{relationsIdeal(polyList)} returns the ideal of relations among the polynomials in \spad{polyList}.
584572`\axiom{relativeApprox(\spad{n},{}\spad{p})} gives a relative approximation of \axiom{\spad{n}} that has precision \axiom{\spad{p}}
584650`\axiom{relativeApprox(exp,{}\spad{c},{}\spad{p}) = a} is relatively close to exp as a polynomial in \spad{c} ip to precision \spad{p}
584771`\axiom{approximate(term,{}root,{}prec)} gives an approximation of \axiom{term} over \axiom{root} with precision \axiom{prec}
584883`\spad{relerror(x,{}y)} computes the absolute value of \spad{x - y} divided by \spad{y},{} when \spad{y \^= 0}.
585015`\spad{f rem g} creates the equivalent infix form.
585056`\spad{x rem y} is the same as \spad{divide(x,{}y).remainder}. See \spadfunFrom{divide}{EuclideanDomain}.
585102`\spad{a rem b} returns the remainder of \spad{a} and \spad{b}.
585246`\axiom{remainder(a,{}\spad{ps})} returns \axiom{[\spad{c},{}\spad{b},{}\spad{r}]} such that \axiom{\spad{b}} is fully reduced in the sense of Groebner bases \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ps}},{} \axiom{r*a - \spad{c*b}} lies in the ideal generated by \axiom{\spad{ps}}. Furthermore,{} if \axiom{\spad{R}} is a \spad{gcd}-domain,{} \axiom{\spad{b}} is primitive.
585942`\axiom{remove!(\spad{s},{}a)} replaces a by remove(\spad{s},{}a)
586011`\spad{remove!(p,{}d)} destructively changes dictionary \spad{d} by removeing all entries \spad{x} such that \axiom{\spad{p}(\spad{x})} is \spad{true}.
586113`\spad{remove!(p,{}u)} destructively removes all elements \spad{x} of \spad{u} such that \axiom{\spad{p}(\spad{x})} is \spad{true}.
586186`\spad{remove!(k,{}t)} searches the table \spad{t} for the key \spad{k} removing (and return) the entry if there. If \spad{t} has no such key,{} \axiom{remove!(\spad{k},{}\spad{t})} returns "failed".
586267`\spad{remove!(x,{}d)} destructively changes dictionary \spad{d} by removing all entries \spad{y} such that \axiom{\spad{y} = \spad{x}}.
586358`\spad{remove!(x,{}u)} destructively removes all values \spad{x} from \spad{u}.
586438`\spad{remove!(p,{}ms,{}number)} removes destructively at most \spad{number} copies of elements \spad{x} such that \spad{p(x)} is \spadfun{\spad{true}} if \spad{number} is positive,{} all of them if \spad{number} equals zero,{} and all but at most \spad{-number} if \spad{number} is negative.
586502`\spad{remove!(x,{}ms,{}number)} removes destructively at most \spad{number} copies of element \spad{x} if \spad{number} is positive,{} all of them if \spad{number} equals zero,{} and all but at most \spad{-number} if \spad{number} is negative.
586555`\spad{removeConstantTerm(f,{} x)} returns \spad{f} minus any additive constant with respect to \spad{x}.
586645`\spad{removeCosSq(f)} converts every \spad{cos(u)**2} appearing in \spad{f} into \spad{1 - sin(x)**2},{} and also reduces higher powers of \spad{cos(u)} with that formula.
586711`\spad{removeCoshSq(f)} converts every \spad{cosh(u)**2} appearing in \spad{f} into \spad{1 - sinh(x)**2},{} and also reduces higher powers of \spad{cosh(u)} with that formula.
586832`\spad{removeDuplicates!(u)} destructively removes duplicates from \spad{u}.
586920`\spad{removeDuplicates!(d)} destructively removes any duplicate values in dictionary \spad{d}.
587095`\spad{removeDuplicates(u)} returns a copy of \spad{u} with all duplicates removed.
587207`\axiom{removeIrreducibleRedundantFactors(\spad{lp},{}\spad{lq})} returns the same as \axiom{irreducibleFactors(concat(\spad{lp},{}\spad{lq}))} assuming that \axiom{irreducibleFactors(\spad{lp})} returns \axiom{\spad{lp}} up to replacing some polynomial \axiom{\spad{pj}} in \axiom{\spad{lp}} by some polynomial \axiom{\spad{qj}} associated 
587207`--to \axiom{\spad{pj}}.
587374`\axiom{removeRedundantFactorsInContents(\spad{lp},{}\spad{lf})} returns \axiom{newlp} where \axiom{newlp} is obtained from \axiom{\spad{lp}} by removing in the content of every polynomial of \axiom{\spad{lp}} any non trivial factor of any polynomial \axiom{\spad{f}} in \axiom{\spad{lf}}. Moreover,{} squares over \axiom{\spad{R}} are first removed in the content of every polyn
587374`--omial of \axiom{\spad{lp}}.
587503`\axiom{removeRedundantFactorsInPols(\spad{lp},{}\spad{lf})} returns \axiom{newlp} where \axiom{newlp} is obtained from \axiom{\spad{lp}} by removing in every polynomial \axiom{\spad{p}} of \axiom{\spad{lp}} any non trivial factor of any polynomial \axiom{\spad{f}} in \axiom{\spad{lf}}. Moreover,{} squares over \axiom{\spad{R}} are first removed in every polynomial \axiom{\spad{lp
587503`--}}.
587628`\axiom{removeRedundantFactors(\spad{lp})} returns \axiom{\spad{lq}} such that if \axiom{\spad{lp} = [\spad{p1},{}...,{}\spad{pn}]} and \axiom{\spad{lq} = [\spad{q1},{}...,{}\spad{qm}]} then the product \axiom{p1*p2*...\spad{*pn}} vanishes iff the product \axiom{q1*q2*...\spad{*qm}} vanishes,{} and the product of degrees of the \axiom{\spad{qi}} is not greater than the one of the \axiom{\spad{pj}},{} and no po
587628`--lynomial in \axiom{\spad{lq}} divides another polynomial in \axiom{\spad{lq}}. In particular,{} polynomials lying in the base ring \axiom{\spad{R}} are removed. Moreover,{} \axiom{\spad{lq}} is sorted \spad{w}.\spad{r}.\spad{t} \axiom{infRittWu?}. Furthermore,{} if \spad{R} is \spad{gcd}-domain,{} the polynomials in \axiom{\spad{lq}} are pairwise without common non trivial factor.
587723`\axiom{removeRedundantFactors(\spad{lp},{}\spad{lq})} returns the same as \axiom{removeRedundantFactors(concat(\spad{lp},{}\spad{lq}))} assuming that \axiom{removeRedundantFactors(\spad{lp})} returns \axiom{\spad{lp}} up to replacing some polynomial \axiom{\spad{pj}} in \axiom{\spad{lp}} by some polynomial \axiom{\spad{qj}} associated to \axiom{\spad{pj}}.
587826`\axiom{removeRedundantFactors(\spad{lp},{}\spad{q})} returns the same as \axiom{removeRedundantFactors(cons(\spad{q},{}\spad{lp}))} assuming that \axiom{removeRedundantFactors(\spad{lp})} returns \axiom{\spad{lp}} up to replacing some polynomial \axiom{\spad{pj}} in \axiom{\spad{lp}} by some some polynomial \axiom{\spad{qj}} associated to \axiom{\spad{pj}}.
587923`\axiom{removeRedundantFactors(\spad{p},{}\spad{q})} returns the same as \axiom{removeRedundantFactors([\spad{p},{}\spad{q}])}
588014`\axiom{removeRedundantFactors(\spad{lp},{}\spad{lq},{}remOp)} returns the same as \axiom{concat(remOp(removeRoughlyRedundantFactorsInPols(\spad{lp},{}\spad{lq})),{}\spad{lq})} assuming that \axiom{remOp(\spad{lq})} returns \axiom{\spad{lq}} up to similarity.
588136`\axiom{removeRoughlyRedundantFactorsInContents(\spad{lp},{}\spad{lf})} returns \axiom{newlp}where \axiom{newlp} is obtained from \axiom{\spad{lp}} by removing in the content of every polynomial of \axiom{\spad{lp}} any occurence of a polynomial \axiom{\spad{f}} in \axiom{\spad{lf}}. Moreover,{} squares over \axiom{\spad{R}} are first removed in the content of every pol
588136`--ynomial of \axiom{\spad{lp}}.
588272`\axiom{removeRoughlyRedundantFactorsInPol(\spad{p},{}\spad{lf})} returns the same as removeRoughlyRedundantFactorsInPols([\spad{p}],{}\spad{lf},{}\spad{true})
588375`\axiom{removeRoughlyRedundantFactorsInPols(\spad{lp},{}\spad{lf})} returns \axiom{newlp}where \axiom{newlp} is obtained from \axiom{\spad{lp}} by removing in every polynomial \axiom{\spad{p}} of \axiom{\spad{lp}} any occurence of a polynomial \axiom{\spad{f}} in \axiom{\spad{lf}}. This may involve a lot of exact-quotients computations.
588491`\axiom{removeRoughlyRedundantFactorsInPols(\spad{lp},{}\spad{lf},{}opt)} returns the same as \axiom{removeRoughlyRedundantFactorsInPols(\spad{lp},{}\spad{lf})} if \axiom{opt} is \axiom{\spad{false}} and if the previous operation does not return any non null and constant polynomial,{} else return \axiom{[1]}.
588615`\spad{removeSinSq(f)} converts every \spad{sin(u)**2} appearing in \spad{f} into \spad{1 - cos(x)**2},{} and also reduces higher powers of \spad{sin(u)} with that formula.
588681`\spad{removeSinhSq(f)} converts every \spad{sinh(u)**2} appearing in \spad{f} into \spad{1 - cosh(x)**2},{} and also reduces higher powers of \spad{sinh(u)} with that formula.
588748`\axiom{removeSquaresIfCan(\spad{lp})} returns \axiom{removeDuplicates [squareFreePart(\spad{p})\$\spad{P} for \spad{p} in \spad{lp}]} if \axiom{\spad{R}} is \spad{gcd}-domain else returns \axiom{\spad{lp}}.
588839`\axiom{removeSuperfluousCases(llpwt)} is an internal subroutine,{} exported only for developement.
588983`\axiom{removeSuperfluousCases(llpwt)} is an internal subroutine,{} exported only for developement.
589137`\axiom{removeSuperfluousQuasiComponents(\spad{lts})} removes from \axiom{\spad{lts}} any \spad{ts} such that \axiom{subQuasiComponent?(\spad{ts},{}us)} holds for another \spad{us} in \axiom{\spad{lts}}.
589239`\axiom{removeSuperfluousQuasiComponents(\spad{lts})} removes from \axiom{\spad{lts}} any \spad{ts} such that \axiom{subQuasiComponent?(\spad{ts},{}us)} holds for another \spad{us} in \axiom{\spad{lts}}.
589414`\axiom{removeZero(\spad{p},{}\spad{ts})} returns \axiom{0} if \axiom{\spad{p}} reduces to \axiom{0} by pseudo-division \spad{w}.\spad{r}.\spad{t} \axiom{\spad{ts}} otherwise returns a polynomial \axiom{\spad{q}} computed from \axiom{\spad{p}} by removing any coefficient in \axiom{\spad{p}} reducing to \axiom{0}.
589584`\spad{removeZeroes(x)} removes leading zeroes from the representation of the \spad{p}-adic rational \spad{x}. A \spad{p}-adic rational is represented by (1) an exponent and (2) a \spad{p}-adic integer which may have leading zero digits. When the \spad{p}-adic integer has a leading zero digit,{} a 'leading zero' is removed from the \spad{p}-adic rational as follows: the number is rewritten by increasing the exponent by 1 and dividing 
589584`--the \spad{p}-adic integer by \spad{p}. Note: \spad{removeZeroes(f)} removes all leading zeroes from \spad{f}.
589654`\spad{removeZeroes(f(x))} removes leading zeroes from the representation of the Laurent series \spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and dividing t
589654`--he Taylor series by its variable. Note: \spad{removeZeroes(f)} removes all leading zeroes from \spad{f}
589863`\spad{removeZeroes(n,{}x)} removes up to \spad{n} leading zeroes from the \spad{p}-adic rational \spad{x}.
589941`\spad{removeZeroes(n,{}f(x))} removes up to \spad{n} leading zeroes from the Laurent series \spad{f(x)}. A Laurent series is represented by (1) an exponent and (2) a Taylor series which may have leading zero coefficients. When the Taylor series has a leading zero coefficient,{} the 'leading zero' is removed from the Laurent series as follows: the series is rewritten by increasing the exponent by 1 and divid
589941`--ing the Taylor series by its variable.
590258`\axiom{remove(\spad{s},{}a)} returns the splitting tree obtained from a by removing every sub-tree \axiom{\spad{b}} such that \axiom{value(\spad{b})} and \axiom{\spad{s}} have the same value,{} condition and status.
590326`\spad{remove(p,{}u)} returns a copy of \spad{u} removing all elements \spad{x} such that \axiom{\spad{p}(\spad{x})} is \spad{true}. Note: \axiom{remove(\spad{p},{}\spad{u}) \spad{==} [\spad{x} for \spad{x} in \spad{u} | not \spad{p}(\spad{x})]}.
590417`\spad{remove(f,{}st)} returns a stream consisting of those elements of stream \spad{st} which do not satisfy the predicate \spad{f}. Note: \spad{remove(f,{}st) = [x for x in st | not f(x)]}.
590483`\spad{remove(x,{}u)} returns a copy of \spad{u} with all elements \axiom{\spad{y} = \spad{x}} removed. Note: \axiom{remove(\spad{y},{}\spad{c}) \spad{==} [\spad{x} for \spad{x} in \spad{c} | \spad{x} \spad{^=} \spad{y}]}.
590587`\spad{remove(p,{}ms,{}number)} removes at most \spad{number} copies of elements \spad{x} such that \spad{p(x)} is \spadfun{\spad{true}} if \spad{number} is positive,{} all of them if \spad{number} equals zero,{} and all but at most \spad{-number} if \spad{number} is negative.
590650`\spad{remove(x,{}ms,{}number)} removes at most \spad{number} copies of element \spad{x} if \spad{number} is positive,{} all of them if \spad{number} equals zero,{} and all but at most \spad{-number} if \spad{number} is negative.
590702`\axiom{rename!(\spad{x},{}name)} changes the way \axiom{\spad{x}} is printed
590760`\axiom{rename(\spad{x},{}name)} gives a new number that prints as name
590817`\spad{reopen!(f,{}mode)} returns a file \spad{f} reopened for operation in the indicated mode: "input" or "output". \spad{reopen!(f,{}"input")} will reopen the file \spad{f} for input.
590876`\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial
590961`\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial
591055`\spad{reorder(p,{} perm)} applies the permutation perm to the variables in a polynomial and returns the new correctly ordered polynomial
591151`\spad{repSq(v,{}e)} computes \spad{v**e} by repeated squaring,{} interpreting \spad{v} as an element of a normal basis field.
591250`\spad{repeatUntilLoop(s,{}c)} creates a repeat ... until loop in FORTRAN.
591308`\spad{repeating?(l,{}s)} returns \spad{true} if a stream \spad{s} is periodic with period \spad{l},{} and \spad{false} otherwise.
591383`\spad{repeating(l)} is a repeating stream whose period is the list \spad{l}.
591431`\spad{replaceKthElement(S,{}k,{}p)} replaces the \spad{k^}{th} element of \spad{S} by \spad{p},{} and returns "failed" if the result is not a set of \spad{M} integers in \spad{1..n} any more.
591548`\spad{replace(s,{}i..j,{}t)} replaces the substring \axiom{\spad{s}(\spad{i}..\spad{j})} of \spad{s} by string \spad{t}.
591624`\spad{representationType()} returns the type of the representation,{} one of: \spad{prime},{} \spad{polynomial},{} \spad{normal},{} or \spad{cyclic}.
592007`\spad{represents([a1,{}..,{}an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed basis.
592081`\spad{represents([a1,{}..,{}an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed basis.
592142`\spad{represents([a1,{}...,{}an])} returns \spad{a1*v1 + ... + an*vn},{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed \spad{R}-module basis.
592683`\spad{represents([a1,{}..,{}an],{}[v1,{}..,{}vn])} returns \spad{a1*v1 + ... + an*vn}.
592759`\spad{represents([a1,{}...,{}am],{}[v1,{}...,{}vm])} returns the linear combination \spad{a1*vm + ... + an*vm}.
592846`\spad{represents([A0,{}...,{}A(n-1)],{}D)} returns \spad{(A0 + A1 y +...+ A(n-1)*y**(n-1))/D}.
592924`\spad{represents([A0,{}...,{}A(n-1)],{}D)} returns \spad{(A0 + A1 y +...+ A(n-1)*y**(n-1))/D}.
593002`\spad{reseed(n)} restarts the random number generator at \spad{n}.
593058`\axiom{resetAttributeButtons()} resets the Attribute buttons to a neutral level.
593120`\spad{resetBadValues(p)} initializes the list of "bad values" for \spad{p} to \spad{[]}. Note: \spad{p} is not allowed to match any of its "bad values".
593169`\spad{resetNew()} resets the internals counters that new() and new(\spad{s}) use to return distinct symbols every time.
593208`\spad{resetVariableOrder()} cancels any previous use of setVariableOrder and returns to the default system ordering.
593278`\spad{reset(v)} sets the current state of the graph characteristics of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} back to their initial settings.
593332`\spad{reset(v)} sets the current state of the graph characteristics of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} back to their initial settings.
593388`\spad{reshape(l,{}p)} \undocumented
593470`\spad{reshape(lt,{}ts)} organizes the list of components \spad{lt} into a tensor with the same shape as \spad{ts}.
593602`\spad{resize(v,{}w,{}h)} displays the two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with a width of \spad{w} and a height of \spad{h},{} keeping the upper left-hand corner position unchanged.
593689`\spad{resize(v,{}w,{}h)} displays the three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} with a width of \spad{w} and a height of \spad{h},{} keeping the upper left-hand corner position unchanged.
593947`\axiom{rest(\spad{x})} return \axiom{\spad{x}} without the first entry or error if \axiomOpFrom{retractable?}{Magma}(\axiom{\spad{x}}) is \spad{true}.
593989`\spad{rest(x)} returns \spad{x} except the first letter.
594038`\spad{rest([l1]*[l2]*...[ln])} returns the list \spad{l2,{} .... ln}.
594106`\axiom{rest(\spad{ts})} returns the polynomials of \axiom{\spad{ts}} with smaller main variable than \axiom{mvar(\spad{ts})} if \axiom{\spad{ts}} is not empty,{} otherwise returns "failed"
594181`\spad{rest(u)} returns an aggregate consisting of all but the first element of \spad{u} (equivalently,{} the next node of \spad{u}).
594372`\spad{rest(u,{}n)} returns the \axiom{\spad{n}}th (\spad{n} \spad{>=} 0) node of \spad{u}. Note: \axiom{rest(\spad{u},{}0) = \spad{u}}.
594446`\spad{restorePrecision()} \undocumented{}
594508`\axiom{result(a)} where \axiom{\spad{ls}} is the leaves list of \axiom{a} returns \axiom{[[value(\spad{s}),{}condition(\spad{s})]\$\spad{VT} for \spad{s} in \spad{ls}]} if the computations are terminated in \axiom{a} else an error is produced.
594582`\axiom{resultantEuclidean(\spad{P},{}\spad{Q})} carries out the equality \axiom{coef1*P + coef2*Q = resultant(\spad{P},{}\spad{Q})}
594702`\axiom{resultantEuclidean_naif(\spad{P},{}\spad{Q})} returns the extended resultant of \axiom{\spad{P}} and \axiom{\spad{Q}} computed by means of the naive algorithm.
594826`\axiom{resultantReduitEuclidean(\spad{P},{}\spad{Q})} returns the "reduce resultant" and carries out the equality \axiom{coef1*P + coef2*Q = resultantReduit(\spad{P},{}\spad{Q})}.
594974`\axiom{resultantReduit(\spad{P},{}\spad{Q})} returns the "reduce resultant" of \axiom{\spad{P}} and \axiom{\spad{Q}}.
595067`\axiom{resultant(\spad{P},{} \spad{Q})} returns the resultant of \axiom{\spad{P}} and \axiom{\spad{Q}}
595138`\spad{resultant(p,{}q)} returns the resultant of the polynomials \spad{p} and \spad{q}.
595227`\axiom{resultant(a,{}\spad{b})} computes the resultant of \axiom{a} and \axiom{\spad{b}} where \axiom{a} and \axiom{\spad{b}} are assumed to have the same main variable \axiom{\spad{v}} and are viewed as univariate polynomials in \axiom{\spad{v}}.
595388`\spad{resultant(p,{}q,{}v)} returns the resultant of the polynomials \spad{p} and \spad{q} with respect to the variable \spad{v}.
595484`\axiom{resultantEuclidean_naif(\spad{P},{}\spad{Q})} returns the resultant of \axiom{\spad{P}} and \axiom{\spad{Q}} computed by means of the naive algorithm.
596652`\spad{retractIfCan(x)} \undocumented
600926`\spad{retractIfCan(a)} tries change \spad{a} into an object of type \spad{S}. If it can,{} then such an object is returned. Otherwise,{} "failed" is returned.
600995`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
601086`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
601233`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
601326`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
601477`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
601593`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
601694`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
601851`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
601954`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
602115`\axiom{retractIfCan(\spad{lp})} returns an element of the domain whose elements are the members of \axiom{\spad{lp}} if such an element exists,{} otherwise \axiom{"failed"} is returned.
602208`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602313`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602420`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602535`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602652`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602757`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602864`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
602955`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
603102`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
603283`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
603376`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
603547`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
603747`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
603898`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
604106`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
604332`\axiom{retractIfCan(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if all its variables belong to \axiom{\spad{V}}.
604531`\spad{retractIfCan(e)} takes \spad{e} and tries to transform it into a FortranExpression \indented{1}{checking that it is one of the given basic symbols} \indented{1}{or subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
604640`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
604745`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
604852`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
604967`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
605084`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
605189`\spad{retractIfCan(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
605296`\spad{retractIfCan(a)} transforms a into an element of \spad{S} if possible. Returns "failed" if a cannot be made into an element of \spad{S}.
608714`\spad{retract(a)} tries to convert \spad{a} into an object of type \spad{S}. If possible,{} it returns the object. Error: if no such retraction is possible.
608762`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
608832`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
608958`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
609030`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
609160`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
609255`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
609335`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
609471`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
609553`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
609693`\axiom{retract(\spad{lp})} returns an element of the domain whose elements are the members of \axiom{\spad{lp}} if such an element exists,{} otherwise an error is produced.
609765`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
609849`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
609935`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610029`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610125`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610209`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610295`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610365`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
610491`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
610651`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
610723`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
610873`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
611052`\spad{retract(e)} takes \spad{e} and transforms it into a \indented{1}{FortranExpression checking that it contains no non-Fortran} \indented{1}{functions,{} and that it only contains the given basic symbols} \indented{1}{and subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
611182`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
611369`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
611574`\axiom{retract(\spad{p})} returns \axiom{\spad{p}} as an element of the current domain if \axiom{retractIfCan(\spad{p})} does not return "failed",{} otherwise an error is produced.
611752`\spad{retract(e)} takes \spad{e} and transforms it into a FortranExpression \indented{1}{checking that it is one of the given basic symbols} \indented{1}{or subscripted symbols which correspond to scalar and array} \indented{1}{parameters respectively.}
611840`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
611924`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
612010`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
612104`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
612200`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
612284`\spad{retract(e)} tries to convert \spad{e} into an ASP,{} checking that \indented{1}{legal Fortran-77 is produced.}
612370`\spad{retract(x)} \undocumented{}
612687`\spad{retract(x)} \undocumented{}
612927`\spad{retract(a)} transforms a into an element of \spad{S} if possible. Error: if a cannot be made into an element of \spad{S}.
612974`\spad{retract(x)} \undocumented{}
613302`\spad{retract(x)} \undocumented{}
613610`\spad{retractable?(p)} tests if \spad{p} is a 0-form,{} \spadignore{i.e.} if degree(\spad{p}) = 0.
613668`\spad{retractable?(df)} tests if differential form \spad{df} is a 0-form,{} \spadignore{i.e.} if degree(\spad{df}) = 0.
613744`\axiom{retractable?(\spad{x})} tests if \axiom{\spad{x}} is a tree with only one entry.
613804`\axiom{retractable?(\spad{x})} tests if \axiom{\spad{x}} is a tree with only one entry.
613859`\spad{retractable?([l1]*[l2]*...[ln])} returns \spad{true} iff \spad{n} equals \spad{1}.
613940`\spad{retractable?(a)} tests if \spad{a} can be converted into an object of type \spad{S}.
613999`\spad{returnType!(t)} declares that the return type of he current subprogram in the global symbol table is \spad{t}.
614089`\spad{returnType!(f,{}t)} declares that the return type of subprogram \spad{f} in the global symbol table is \spad{t}.
614186`\spad{returnType!(f,{}t,{}tab)} declares that the return type of subprogram \spad{f} in symbol table \spad{tab} is \spad{t}.
614286`\spad{returnTypeOf(f,{}tab)} returns the type of the object returned by \spad{f}
614382`\spad{returns()} creates a representation of a FORTRAN RETURN statement.
614423`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614490`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614548`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614608`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614675`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614740`\spad{returns(e)} creates a representation of a FORTRAN RETURN statement with a returned value.
614912`\spad{reverse!(l)} reverses the list of monomials forming \spad{l},{} destroying the element \spad{l}.
614966`\spad{reverse!(d)} destructively replaces \spad{d} by its reverse dequeue,{} \spadignore{i.e.} the top (front) element is now the bottom (back) element,{} and so on.
615018`\spad{reverse!(u)} returns \spad{u} with its elements in reverse order.
615110`\spad{reverseLex(v1,{}v2)} return \spad{true} if the vector \spad{v1} is less than the vector \spad{v2} in the ordering which is total degree refined by the reverse lexicographic ordering.
615243`\spad{reverse(p)} returns the reverse polynomial of \spad{p}.
615311`\spad{reverse(l)} reverses the list of monomials forming \spad{l}. This has some effect if the monoid is non-abelian,{} \spadignore{i.e.} \spad{reverse(a1\^e1 ... an\^en) = an\^en ... a1\^e1} which is different.
615364`\spad{reverse(a)} returns a copy of \axiom{a} with elements in reverse order.
615420`\spad{revert(a)} computes the inverse of a power series \spad{a} with respect to composition. the series should have constant coefficient 0 and first order coefficient 1.
615496`\spad{revert(f(x))} returns a Taylor series \spad{g(x)} such that \spad{f(g(x)) = g(f(x)) = x}. Series \spad{f(x)} should have constant coefficient 0 and 1st order coefficient 1.
615662`\axiom{rewriteIdealWithHeadRemainder(\spad{lp},{}\spad{cs})} returns \axiom{\spad{lr}} such that the leading monomial of every polynomial in \axiom{\spad{lr}} is reduced in the sense of Groebner bases \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{cs}} and \axiom{(\spad{lp},{}\spad{cs})} and \axiom{(\spad{lr},{}\spad{cs})} generate the same ideal in \axiom{(\spad{R})^(\spad{-1}) \spad{P}
615662`--}.
615785`\axiom{rewriteIdealWithQuasiMonicGenerators(\spad{lp},{}redOp?,{}redOp)} returns \axiom{\spad{lq}} where \axiom{\spad{lq}} and \axiom{\spad{lp}} generate the same ideal in \axiom{\spad{R^}(\spad{-1}) \spad{P}} and \axiom{\spad{lq}} has rank not higher than the one of \axiom{\spad{lp}}. Moreover,{} \axiom{\spad{lq}} is computed by reducing \axiom{\spad{lp}} \spad{w}.\spad{
615785`--r}.\spad{t}. some basic set of the ideal generated by the quasi-monic polynomials in \axiom{\spad{lp}}.
616013`\axiom{rewriteIdealWithRemainder(\spad{lp},{}\spad{cs})} returns \axiom{\spad{lr}} such that every polynomial in \axiom{\spad{lr}} is fully reduced in the sense of Groebner bases \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{cs}} and \axiom{(\spad{lp},{}\spad{cs})} and \axiom{(\spad{lr},{}\spad{cs})} generate the same ideal in \axiom{(\spad{R})^(\spad{-1}) \spad{P}}.
616132`\axiom{rewriteSetByReducingWithParticularGenerators(\spad{lp},{}pred?,{}redOp?,{}redOp)} returns \axiom{\spad{lq}} where \axiom{\spad{lq}} is computed by the following algorithm. Chose a basic set \spad{w}.\spad{r}.\spad{t}. the reduction-test \axiom{redOp?} among the polynomials satisfying property \axiom{pred?},{} if it is empty then leave,{} else r
616132`--educe the other polynomials by this basic set \spad{w}.\spad{r}.\spad{t}. the reduction-operation \axiom{redOp}. Repeat while another basic set with smaller rank can be computed. See code. If \axiom{pred?} is \axiom{quasiMonic?} the ideal is unchanged.
616398`\axiom{rewriteSetWithReduction(\spad{lp},{}\spad{ts},{}redOp,{}redOp?)} returns a list \axiom{\spad{lq}} of polynomials such that \axiom{[reduce(\spad{p},{}\spad{ts},{}redOp,{}redOp?) for \spad{p} in \spad{lp}]} and \axiom{\spad{lp}} have the same zeros inside the regular zero set of \axiom{\spad{ts}}. Moreover,{} for every polynomial \axiom{\spad{q}} in \axiom{\spad{lq}} and every polynom
616398`--ial \axiom{\spad{t}} in \axiom{\spad{ts}} \axiom{redOp?(\spad{q},{}\spad{t})} holds and there exists a polynomial \axiom{\spad{p}} in the ideal generated by \axiom{\spad{lp}} and a product \axiom{\spad{h}} of \axiom{initials(\spad{ts})} such that \axiom{\spad{h*p} - \spad{r}} lies in the ideal generated by \axiom{\spad{ts}}. The operation \axiom{redOp} must satisfy the following conditions. For every \axiom{\spad{p}} and \axiom{\spad{q}} we have \axiom{redOp?(redOp(\spad{p},{}\spad{q}),{}\spad
616398`--{q})} and there exists an integer \axiom{\spad{e}} and a polynomial \axiom{\spad{f}} such that \axiom{init(\spad{q})^e*p = \spad{f*q} + redOp(\spad{p},{}\spad{q})}.
616513`\spad{rhs(f)} returns the right side of \spad{f}
616556`\spad{rhs(r)} returns the right hand side of the rule \spad{r}.
616604`\spad{rhs(eqn)} returns the right hand side of equation \spad{eqn}.
616642`\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}.
616789`\spad{ricDsolve(op)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}.
616939`\spad{ricDsolve(op,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
617105`\spad{ricDsolve(op,{} zeros)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. \spad{zeros} is a zero finder in \spad{UP}.
617235`\spad{ricDsolve(op,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
617404`\spad{ricDsolve(op,{} zeros)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. \spad{zeros} is a zero finder in \spad{UP}.
617537`\spad{ricDsolve(op,{} zeros,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. \spad{zeros} is a zero finder in \spad{UP}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
617686`\spad{ricDsolve(op,{} zeros,{} ezfactor)} returns the rational solutions of the associated Riccati equation of \spad{op y = 0}. \spad{zeros} is a zero finder in \spad{UP}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
617838`\spad{ridHack1(i,{}j,{}k,{}l)} \undocumented
617931`\spad{rightAlternative?()} tests if \spad{2*associator(a,{}b,{}b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
618013`\spad{rightAlternative?()} tests if \spad{2*associator(a,{}b,{}b) = 0} for all \spad{a},{} \spad{b} in the algebra. Note: we only can test this; in general we don\spad{'t} know whether \spad{2*a=0} implies \spad{a=0}.
618204`\spad{rightCharacteristicPolynomial(a)} returns the characteristic polynomial of the right regular representation of \spad{a} with respect to any basis.
618319`\spad{rightDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(rightTraceMatrix())}.
618391`\spad{rightDiscriminant()} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis. Note: the same as \spad{determinant(rightTraceMatrix())}.
618616`\spad{rightDiscriminant([v1,{}...,{}vn])} returns the determinant of the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj}. Note: the same as \spad{determinant(rightTraceMatrix([v1,{}...,{}vn]))}.
618699`\spad{rightDivide(a,{}b)} returns the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called ``right division\spad{''}.
618815`\spad{rightDivide(a,{} b,{} sigma)} returns the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. This process is called ``right division\spad{''}. \spad{\sigma} is the morphism to use.
619040`\spad{rightExactQuotient(a,{}b)} computes the value \spad{q},{} if it exists such that \spad{a = q*b}.
619257`\spad{rightExtendedGcd(a,{}b)} returns \spad{[c,{}d]} such that \spad{g = c * a + d * b = rightGcd(a,{} b)}.
619384`\spad{rightFactorCandidate(p,{}n)} \undocumented
619477`\spad{rightFactorIfCan(f,{}d,{}c)} returns a candidate to be the right factor (\spad{h} in \spad{f} = \spad{g} \spad{o} \spad{h}) of degree \spad{d} with leading coefficient \spad{c} of a functional decomposition of the polynomial \spad{f} or \spad{"failed"} if no such candidate.
619667`\spad{rightGcd(a,{}b)} computes the value \spad{g} of highest degree such that \indented{3}{\spad{a = aa*g}} \indented{3}{\spad{b = bb*g}} for some values \spad{aa} and \spad{bb}. The value \spad{g} is computed using right-division.
619816`\spad{rightLcm(a,{}b)} computes the value \spad{m} of lowest degree such that \spad{m = a*aa = b*bb} for some values \spad{aa} and \spad{bb}. The value \spad{m} is computed using left-division.
620004`\spad{rightMinimalPolynomial(a)} returns the polynomial determined by the smallest non-trivial linear combination of right powers of \spad{a}. Note: the polynomial never has a constant term as in general the algebra has no unit.
620133`\spad{rightMult(a,{} s)} returns \spad{a * s} where \spad{*} is the monoid operation,{} which is assumed non-commutative.
620254`\spad{rightNorm(a)} returns the determinant of the right regular representation of \spad{a}.
620321`\spad{rightOne(eq)} divides by the right hand side.
620393`\spad{rightOne(eq)} divides by the right hand side.
620644`\spad{rightPower(a,{}n)} returns the \spad{n}\spad{-}th right power of \spad{a},{} \spadignore{i.e.} \spad{rightPower(a,{}n) := rightPower(a,{}n-1) * a} and \spad{rightPower(a,{}0) := 1}.
620711`\spad{rightPower(a,{}n)} returns the \spad{n}\spad{-}th right power of \spad{a},{} \spadignore{i.e.} \spad{rightPower(a,{}n) := rightPower(a,{}n-1) * a} and \spad{rightPower(a,{}1) := a}.
620838`\spad{rightQuotient(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{q} is returned.
620926`\spad{rightRankPolynomial()} returns the right minimimal polynomial of the generic element
621080`\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.
621194`\spad{rightRankPolynomial()} calculates the right minimal polynomial of the generic element in the algebra,{} defined by the same structural constants over the polynomial ring in symbolic coefficients with respect to the fixed basis.
621317`\spad{rightRank(x)} determines the number of linearly independent elements in \spad{b1*x},{}...,{}\spad{bn*x},{} where \spad{b=[b1,{}...,{}bn]} is a basis.
621466`\spad{rightRecip(a)} returns an element,{} which is a right inverse of \spad{a},{} or \spad{"failed"} if there is no unit element,{} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
621572`\spad{rightRecip(a)} returns an element,{} which is a right inverse of \spad{a},{} or \spad{"failed"} if such an element doesn\spad{'t} exist or cannot be determined (see unitsKnown).
621721`\spad{rightRegularRepresentation(a)} returns the matrix of the linear map defined by right multiplication by \spad{a} with respect to the fixed \spad{R}-module basis.
622003`\spad{rightRegularRepresentation(a,{}[v1,{}...,{}vn])} returns the matrix of the linear map defined by right multiplication by \spad{a} with respect to the \spad{R}-module basis \spad{[v1,{}...,{}vn]}.
622178`\spad{rightRemainder(a,{}b)} computes the pair \spad{[q,{}r]} such that \spad{a = q*b + r} and the degree of \spad{r} is less than the degree of \spad{b}. The value \spad{r} is returned.
622267`\spad{rightScalarTimes!(c,{}a,{}r)} computes the scalar product \spad{a * r} and stores the result in the matrix \spad{c}. Error: if \spad{a} and \spad{c} do not have the same dimensions.
622370`\spad{rightTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis.
622449`\spad{rightTraceMatrix()} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj},{} where \spad{v1},{}...,{}\spad{vn} are the elements of the fixed \spad{R}-module basis.
622695`\spad{rightTraceMatrix([v1,{}...,{}vn])} is the \spad{n}-by-\spad{n} matrix whose element at the \spad{i}\spad{-}th row and \spad{j}\spad{-}th column is given by the right trace of the product \spad{vi*vj}.
622850`\spad{rightTrace(a)} returns the trace of the right regular representation of \spad{a}.
622918`\spad{rightTrim(s,{}c)} returns \spad{s} with all trailing occurrences of \spad{c} deleted. For example,{} \axiom{rightTrim(" abc ",{} char " ")} returns \axiom{" abc"}.
622977`\spad{rightTrim(s,{}cc)} returns \spad{s} with all trailing occurences of characters in \spad{cc} deleted. For example,{} \axiom{rightTrim("(abc)",{} charClass "()")} returns \axiom{"(abc"}.
623116`\spad{rightUnit()} returns a right unit of the algebra (not necessarily unique),{} or \spad{"failed"} if there is none.
623328`\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \spad{"failed"} if there is none
623453`\spad{rightUnits()} returns the affine space of all right units of the algebra,{} or \spad{"failed"} if there is none.
623591`\spad{rightZero(eq)} subtracts the right hand side.
623655`\axiom{right(\spad{x})} returns right subtree of \axiom{\spad{x}} or error if \axiomOpFrom{retractable?}{LyndonWord}(\axiom{\spad{x}}) is \spad{true}.
623703`\axiom{right(\spad{x})} returns right subtree of \axiom{\spad{x}} or error if \axiomOpFrom{retractable?}{Magma}(\axiom{\spad{x}}) is \spad{true}.
623746`\spad{right(f)} right-justifies form \spad{f} in total space.
623786`\axiom{right(rootChar)} is the right bound of the isolating interval
623879`\spad{right(a)} returns the right child.
623936`\spad{right(f,{}n)} right-justifies form \spad{f} within space of width \spad{n}.
623984`\spad{rischDE(n,{} f,{} g,{} x,{} lim,{} ext)} returns \spad{[y,{} h,{} b]} such that \spad{dy/dx + n df/dx y = h} and \spad{b := h = g}. The equation \spad{dy/dx + n df/dx y = g} has no solution if \spad{h \~~= g} (\spad{y} is a partial solution in that case). Not
623984`--es: \spad{lim} is a limited integration function,{} and ext is an extended integration function.
624226`\spad{rischDEsys(n,{} f,{} g_1,{} g_2,{} x,{}lim,{}ext)} returns \spad{y_1.y_2} such that \spad{(dy1/dx,{}dy2/dx) + ((0,{} - n df/dx),{}(n df/dx,{}0)) (y1,{}y2) = (g1,{}g2)} if \spad{y_1,{}y_2} exist,{} "failed" otherwise. \spad{lim} is a limited integration functi
624226`--on,{} \spad{ext} is an extended integration function.
624468`\spad{rischNormalize(f,{} x)} returns \spad{[g,{} [k1,{}...,{}kn],{} [h1,{}...,{}hn]]} such that \spad{g = normalize(f,{} x)} and each \spad{\spad{ki}} was rewritten as \spad{\spad{hi}} during the normalization.
624598`\spad{rk4(y,{}n,{}x1,{}h,{}derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation {\em dy/dx = f(y,{}x)} of \spad{n} variables,{} where \spad{y} is an \spad{n}-vector. Argument \spad{y} is a vector of initial conditions of length \spad{n} which upon exit contains the solution at \spad{x1 + h},{} \spad{n} is the nu
624598`--mber of dependent variables,{} \spad{x1} is the initial point,{} \spad{h} is the step size,{} and \spad{derivs} is a function which computes the right hand side of the ordinary differential equation. For details,{} see \spadtype{NumericalOrdinaryDifferentialEquations}.
624739`\spad{rk4(y,{}n,{}x1,{}h,{}derivs,{}t1,{}t2,{}t3,{}t4)} is the same as \spad{rk4(y,{}n,{}x1,{}h,{}derivs)} except that you must provide 4 scratch arrays \spad{t1}-\spad{t4} of size \spad{n}. For details,{} see \con{NumericalOrdinaryDifferentialEquations}.
624936`\spad{rk4a(y,{}n,{}x1,{}x2,{}eps,{}h,{}ns,{}derivs)} is a driver function for the numerical integration of an ordinary differential equation {\em dy/dx = f(y,{}x)} of \spad{n} variables,{} where \spad{y} is an \spad{n}-vector using a 4-th order Runge-Kutta method. For details,{} see \con{NumericalOrdinaryDifferentialEquations}.
625098`\spad{rk4f(y,{}n,{}x1,{}x2,{}ns,{}derivs)} uses a 4-th order Runge-Kutta method to numerically integrate the ordinary differential equation {\em dy/dx = f(y,{}x)} of \spad{n} variables,{} where \spad{y} is an \spad{n}-vector. Starting with \spad{y} at \spad{x1},{} this function uses \spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance t
625098`--he solution vector to \spad{x2} and return the values in \spad{y}. For details,{} see \con{NumericalOrdinaryDifferentialEquations}.
625248`\spad{rk4qc(y,{}n,{}x1,{}step,{}eps,{}yscal,{}derivs,{}t1,{}t2,{}t3,{}t4,{}t5,{}t6,{}t7)} is a subfunction for the numerical integration of an ordinary differential equation {\em dy/dx = f(y,{}x)} of \spad{n} var
625248`--iables,{} where \spad{y} is an \spad{n}-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \spad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details,{} see \con{NumericalOrdinaryDifferentialEquations}.
625543`\spad{rk4qc(y,{}n,{}x1,{}step,{}eps,{}yscal,{}derivs)} is a subfunction for the numerical integration of an ordinary differential equation {\em dy/dx = f(y,{}x)} of \spad{n} variables,{} where \spad{y} is an \spad{n}-vector using a 4-th order Runge-Kutta method. This function takes a 5-th order Runge-Kutta \sp
625543`--ad{step} with monitoring of local truncation to ensure accuracy and adjust stepsize. For details,{} see \con{NumericalOrdinaryDifferentialEquations}.
625739`\spad{roman(n)} creates a roman numeral for \spad{n}.
625786`\spad{roman(n)} creates a roman numeral for symbol \spad{n}.
625832`\spad{romberg(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the romberg method to numerically integrate function \spadvar{\spad{fn}} over the closed interval \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \sp
625832`--ad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
625997`\spad{rombergo(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the romberg method to numerically integrate function \spad{fn} over the open interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nm
625997`--ax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
626163`\spad{root?(x)} \undocumented
626211`\spad{rootBound(p)} returns a bound on the largest norm of the complex roots of \spad{p}.
626291`\spad{rootKerSimp(op,{}f,{}n)} should be local but conditional.
626478`\spad{rootNormalize(f,{} k)} returns \spad{f} rewriting either \spad{k} which must be an \spad{n}th-root in terms of radicals already in \spad{f},{} or some radicals in \spad{f} in terms of \spad{k}.
626563`\spad{rootOfIrreduciblePoly(f)} computes one root of the monic,{} irreducible polynomial \spad{f},{} which degree must divide the extension degree of {\em F} over {\em GF},{} \spadignore{i.e.} \spad{f} splits into linear factors over {\em F}.
627041`\spad{rootOf(p)} returns \spad{y} such that \spad{p(y) = 0}. Error: if \spad{p} has more than one variable \spad{y}.
627108`\spad{rootOf(p)} returns \spad{y} such that \spad{p(y) = 0}.
627191`\spad{rootOf(p)} returns \spad{y} such that \spad{p(y) = 0}. Error: if \spad{p} has more than one variable \spad{y}.
627326`\spad{rootOf(p,{} y)} returns \spad{y} such that \spad{p(y) = 0}. The object returned displays as \spad{'y}.
627814`\axiom{rootOf(pol,{}\spad{n})} creates the \spad{n}th root for the order of \axiom{pol} and gives it unique name
627920`\spad{rootOf(p,{} y)} returns \spad{y} such that \spad{p(y) = 0}. The object returned displays as \spad{'y}.
628010`\axiom{rootOf(pol,{}\spad{n})} gives the \spad{n}th root for the order of the Real Closure
628128`\spad{rootOf(p,{}y)} returns \spad{y} such that \spad{p(y) = 0}. The object returned displays as \spad{'y}.
628315`\axiom{rootOf(pol,{}\spad{n},{}name)} creates the \spad{n}th root for the order of \axiom{pol} and names it \axiom{name}
628432`\spad{rootPoly(g,{} n)} returns \spad{[m,{} c,{} P]} such that \spad{c * g ** (1/n) = P ** (1/m)} thus if \spad{y**n = g},{} then \spad{z**m = P} where \spad{z = c * y}.
628584`\spad{rootPower(f)} transforms every radical power of the form \spad{(a**(1/n))**m} into a simpler form if \spad{m} and \spad{n} have a common factor.
628736`\spad{rootProduct(f)} combines every product of the form \spad{(a**(1/n))**m * (a**(1/s))**t} into a single power of a root of \spad{a},{} and transforms every radical power of the form \spad{(a**(1/n))**m} into a simpler form.
628890`\spad{rootRadius(p)} calculates the root radius of \spad{p} with a maximal error quotient of {\em 1+globalEps},{} where {\em globalEps} is the internal error bound,{} which can be set by {\em setErrorBound}.
628955`\spad{rootRadius(p,{}errQuot)} calculates the root radius of \spad{p} with a maximal error quotient of {\em errQuot}.
629022`\spad{rootSimp(f)} transforms every radical of the form \spad{(a * b**(q*n+r))**(1/n)} appearing in \spad{f} into \spad{b**q * (a * b**r)**(1/n)}. This transformation is not in general valid for all complex numbers \spad{b}.
629173`\spad{rootSplit(f)} transforms every radical of the form \spad{(a/b)**(1/n)} appearing in \spad{f} into \spad{a**(1/n) / b**(1/n)}. This transformation is not in general valid for all complex numbers \spad{a} and \spad{b}.
629232`\spad{root(f)} creates a form for the square root of form \spad{f}.
629271`\spad{root(f,{}n)} creates a form for the \spad{n}th root of form \spad{f}.
629313`\spad{root(f,{}a)} returns a root of the polynomial \spad{f}. Argument \spad{a} must be a root of \spad{f} \spad{(mod p)}.
629811`\spad{rootsOf(p)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. Note: the returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values. Error: if \spad{p} has more than one variable \spad{y}.
629885`\spad{rootsOf(p)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. Note: the returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
629975`\spad{rootsOf(p,{} y)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}; Note: the returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values. Error: if \spad{p} has more than one variable \spad{y}.
630322`\spad{rootsOf(p,{} y)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}; The returned roots display as \spad{'y1},{}...,{}\spad{'yn}. Note: the returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
630419`\spad{rootsOf(p,{} y)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}; The returned roots display as \spad{'y1},{}...,{}\spad{'yn}. Note: the returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
630499`\spad{rotate! q} rotates queue \spad{q} so that the element at the front of the queue goes to the back of the queue. Note: rotate! \spad{q} is equivalent to enqueue!(dequeue!(\spad{q})).
630548`\spad{rotate(v,{}th,{}phi)} rotates the graph to the longitudinal view angle \spad{th} radians and the latitudinal view angle \spad{phi} radians for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
630617`\spad{rotate(v,{}th,{}phi)} rotates the graph to the longitudinal view angle \spad{th} degrees and the latitudinal view angle \spad{phi} degrees for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}. The new rotation position is not displayed until the function \spadfun{makeViewport3D} is executed again for \spad{v}.
630762`\axiom{roughBase?(\spad{ps})} returns \spad{true} iff for every pair \axiom{{\spad{p},{}\spad{q}}} of polynomials in \axiom{\spad{ps}} their leading monomials are relatively prime.
630858`\axiom{roughBasicSet(\spad{lp})} returns the smallest (with Ritt-Wu ordering) triangular set contained in \axiom{\spad{lp}}.
631087`\axiom{roughEqualIdeals?(\spad{ps1},{}\spad{ps2})} returns \spad{true} iff it can proved that \axiom{\spad{ps1}} and \axiom{\spad{ps2}} generate the same ideal in \axiom{(\spad{R})^(\spad{-1}) \spad{P}} without computing Groebner bases.
631271`\axiom{roughSubIdeal?(\spad{ps1},{}\spad{ps2})} returns \spad{true} iff it can proved that all polynomials in \axiom{\spad{ps1}} lie in the ideal generated by \axiom{\spad{ps2}} in \axiom{\axiom{(\spad{R})^(\spad{-1}) \spad{P}}} without computing Groebner bases.
631451`\axiom{roughUnitIdeal?(\spad{ps})} returns \spad{true} iff \axiom{\spad{ps}} contains some non null element lying in the base ring \axiom{\spad{R}}.
631595`\spad{round x} computes the integer closest to \spad{x}.
631641`\spad{routines()} initialises a database of known NAG routines
631685`\spad{rowEchLocal(m,{}p)} computes a modular row-echelon form of \spad{m},{} finding an appropriate modulus over a local ring where \spad{p} is the only prime.
631768`\spad{rowEch(m)} computes a modular row-echelon form of \spad{m},{} finding an appropriate modulus.
631844`\spad{rowEchelonLocal(m,{} d,{} p)} computes the row-echelon form of \spad{m} concatenated with \spad{d} times the identity matrix over a local ring where \spad{p} is the only prime.
631933`\spad{rowEchelon(m)} returns the row echelon form of the matrix \spad{m}. the result will have entries in the quotient field.
632029`\spad{rowEchelon(m)} returns the row echelon form of the matrix \spad{m}.
632108`\spad{rowEchelon(m)} returns the row echelon form of the matrix \spad{m}.
632204`\spad{rowEchelon(m)} returns the row echelon form of the matrix \spad{m}.
632286`\spad{rowEchelon(m)} returns the row echelon form of the matrix \spad{m}.
632383`\spad{rowEchelon(m,{} d)} computes a modular row-echelon form mod \spad{d} of \indented{3}{[\spad{d}\space{5}]} \indented{3}{[\space{2}\spad{d}\space{3}]} \indented{3}{[\space{4}. ]} \indented{3}{[\space{5}\spad{d}]} \indented{3}{[\space{3}\spad{M}\space{2}]} where \spad{M = m mod d}.
632537`\spad{row(m,{}i)} returns the \spad{i}th row of the matrix \spad{m}. Error: if the index is outside the proper range.
632614`\spad{row(m,{}i)} returns the \spad{i}th row of \spad{m} error check to determine if index is in proper ranges
632689`\spad{rquo(x,{} s)} returns the exact right quotient of \spad{x} by \spad{s}.
632756`\spad{rquo(x,{} y)} returns the exact right quotient of \spad{x} by \spad{y} \spadignore{i.e.} \spad{q} such that \spad{x = q * y},{} "failed" if \spad{x} is not of the form \spad{q * y}.
632817`\spad{rquo(x,{} y)} returns the exact right quotient of \spad{x} by \spad{y} that is \spad{q} such that \spad{x = q * y},{} "failed" if \spad{x} is not of the form \spad{q * y}.
632885`\axiom{rquo(\spad{x},{}\spad{y})} returns the right simplification of \axiom{\spad{x}} by \axiom{\spad{y}}.
632997`\spad{rquo(x,{}w)} returns the right simplification of \spad{x} by \spad{w}.
633066`\spad{rquo(x,{}y)} returns the right simplification of \spad{x} by \spad{y}.
633116`\spad{rquo(x,{}v)} returns the right simplification of \spad{x} by the variable \spad{v}.
633166`\spad{rroot(f,{} n)} returns \spad{[m,{}c,{}r]} such that \spad{f**(1/n) = c * r**(1/m)}.
633291`\spad{rspace(n,{}m)} creates rectangular white space,{} \spad{n} wide by \spad{m} high.
633345`\spad{rst(s)} returns a pointer to the next node of stream \spad{s}. Caution: this function should only be called after a \spad{empty?} test has been made since there no error check.
633395`\spad{rubiksGroup constructs} the permutation group representing Rubic\spad{'s} Cube acting on integers {\em 10*i+j} for {\em 1 <= i <= 6},{} {\em 1 <= j <= 8}. The faces of Rubik\spad{'s} Cube are labelled in the obvious way Front,{} Right,{} Up,{} Down,{} Left,{} Back and numbered from 1 to 6 in this given ordering,{} the pieces on each face (except the unmoveable center piece) are clockwise numbered from 1 to 8 starting
633395`-- with the piece in the upper left corner. The moves of the cube are represented as permutations on these pieces,{} represented as a two digit integer {\em ij} where \spad{i} is the numer of theface (1 to 6) and \spad{j} is the number of the piece on this face. The remaining ambiguities are resolved by looking at the 6 generators,{} which represent a 90 degree turns of the faces,{} or from the following pictorial description. Permutation group representing Rubic\spad{'s} Cube acting on integers
633395`-- 10*i+j for 1 \spad{<=} \spad{i} \spad{<=} 6,{} 1 \spad{<=} \spad{j} \spad{<=8}. \blankline\begin{verbatim}Rubik's Cube:   +
633395`--
633395`---+ +
633395`-- B   where: marks Side # :               / U   /|/              /     / |         F(ront)    <->    1      L 
633395`-->  +
633395`--
633395`---+ R|         R(ight)    <->    2             |     |  +         U(p)       <->    3             |  F  | /          D(own)     <->    4             |     |/           L(eft)     <->    5             +
633395`--
633395`---+            B(ack)     <->    
633395`--6                ^                |                DThe Cube's surface:                               The pieces on each side            +
633395`---+              (except the unmoveable center            |567|              piece) are clockwise numbered            |4U8|              from 1 to 8 starting with the            |321|              piece in the upper left        +
633395`---+
633395`---+
633395`---+          corner (see figure on the        |781|123|345|          left).  The moves of the cube        |
633395`--6L2|8F4|2R6|          are represented as        |543|765|187|          permutations on these pieces.        +
633395`---+
633395`---+
633395`---+          Each of the pieces is            |123|              represented as a two digit            |8D4|              integer ij where i is the            |765|              # of the side ( 1 to 6 for            +
633395`---+              F to B (see table above ))            |567|              and j is the # of the piece.            |4B8|            |321|            +
633395`--
633395`---+\end{verbatim}
633476`\spad{rule(f,{} g)} creates the rewrite rule: \spad{f == eval(g,{} g is f)},{} with left-hand side \spad{f} and right-hand side \spad{g}.
633527`\spad{rule(f,{} g,{} [f1,{}...,{}fn])} creates the rewrite rule \spad{f == eval(eval(g,{} g is f),{} [f1,{}...,{}fn])},{} that is a rule with left-hand side \spad{f} and right-hand side \spad{g}; The symbols \spad{f1},{}...,{}\spad{fn} are the operators that are considered quoted,{} that is they are not evaluated during any rewrite,{} but just applied formally to their arguments.
633591`\spad{rules(r)} returns the rules contained in \spad{r}.
633663`\spad{ruleset([r1,{}...,{}rn])} creates the rule set \spad{{r1,{}...,{}rn}}.
633737`\spad{rur(lp)} returns the same as \spad{rur(lp,{}true)}
633913`\spad{rur(lp,{}univ?)} returns a rational univariate representation of \spad{lp}. This assumes that \spad{lp} defines a regular triangular \spad{ts} whose associated variety is zero-dimensional over \spad{R}. \spad{rur(lp,{}univ?)} returns a list of items \spad{[u,{}lc]} where \spad{u} is an irreducible univariate polynom
633913`--ial and each \spad{c} in \spad{lc} involves two variables: one from \spad{ls},{} called the coordinate of \spad{c},{} and an extra variable which represents any root of \spad{u}. Every root of \spad{u} leads to a tuple of values for the coordinates of \spad{lc}. Moreover,{} a point \spad{x} belongs to the variety associated with \spad{lp} iff there exists an item \spad{[u,{}lc]} in \spad{rur(lp,{}univ?)} and a root \spad{r} of \spad{u} such that \spad{x} is given by the tuple of values for the
633913`-- coordinates of \spad{lc} evaluated at \spad{r}. If \spad{univ?} is \spad{true} then each polynomial \spad{c} will have a constant leading coefficient \spad{w}.\spad{r}.\spad{t}. its coordinate. See the example which illustrates the \spadtype{ZeroDimensionalSolvePackage} package constructor.
634097`\spad{rur(ts,{}univ?)} returns a rational univariate representation of \spad{ts}. This assumes that the lowest polynomial in \spad{ts} is a variable \spad{v} which does not occur in the other polynomials of \spad{ts}. This variable will be used to define the simple algebraic extension over which these other polynomials will be rewritten as univariate polynomials with degree one. If \spad{univ?} is \spad
634097`--{true} then these polynomials will have a constant initial.
634198`\spad{rur(lp,{}univ?,{}check?)} returns the same as \spad{rur(lp,{}true)}. Moreover,{} if \spad{check?} is \spad{true} then the result is checked.
634390`\spad{s01eaf(z,{}ifail)} S01EAF evaluates the exponential function exp(\spad{z}) ,{} for complex \spad{z}. See \downlink{Manual Page}{manpageXXs01eaf}.
634477`\spad{s13aaf(x,{}ifail)} returns the value of the exponential integral \indented{1}{\spad{E} (\spad{x}),{} via the routine name.} \indented{2}{1} See \downlink{Manual Page}{manpageXXs13aaf}.
634555`\spad{s13acf(x,{}ifail)} returns the value of the cosine integral See \downlink{Manual Page}{manpageXXs13acf}.
634633`\spad{s13adf(x,{}ifail)} returns the value of the sine integral See \downlink{Manual Page}{manpageXXs13adf}.
634711`\spad{s14aaf(x,{}ifail)} returns the value of the Gamma function (Gamma)(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs14aaf}.
634789`\spad{s14abf(x,{}ifail)} returns a value for the log,{} \spad{ln}(Gamma(\spad{x})),{} via the routine name. See \downlink{Manual Page}{manpageXXs14abf}.
634867`\spad{s14baf(a,{}x,{}tol,{}ifail)} computes values for the incomplete gamma functions \spad{P}(a,{}\spad{x}) and \spad{Q}(a,{}\spad{x}). See \downlink{Manual Page}{manpageXXs14baf}.
634969`\spad{s15adf(x,{}ifail)} returns the value of the complementary error function,{} erfc(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs15adf}.
635047`\spad{s15aef(x,{}ifail)} returns the value of the error function erf(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs15aef}.
635125`\spad{s17acf(x,{}ifail)} returns the value of the Bessel Function \indented{1}{\spad{Y} (\spad{x}),{} via the routine name.} \indented{2}{0} See \downlink{Manual Page}{manpageXXs17acf}.
635203`\spad{s17adf(x,{}ifail)} returns the value of the Bessel Function \indented{1}{\spad{Y} (\spad{x}),{} via the routine name.} \indented{2}{1} See \downlink{Manual Page}{manpageXXs17adf}.
635281`\spad{s17aef(x,{}ifail)} returns the value of the Bessel Function \indented{1}{\spad{J} (\spad{x}),{} via the routine name.} \indented{2}{0} See \downlink{Manual Page}{manpageXXs17aef}.
635359`\spad{s17aff(x,{}ifail)} returns the value of the Bessel Function \indented{1}{\spad{J} (\spad{x}),{} via the routine name.} \indented{2}{1} See \downlink{Manual Page}{manpageXXs17aff}.
635437`\spad{s17agf(x,{}ifail)} returns a value for the Airy function,{} \spad{Ai}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs17agf}.
635515`\spad{s17ahf(x,{}ifail)} returns a value of the Airy function,{} \spad{Bi}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs17ahf}.
635593`\spad{s17ajf(x,{}ifail)} returns a value of the derivative of the Airy function \spad{Ai}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs17ajf}.
635671`\spad{s17akf(x,{}ifail)} returns a value for the derivative of the Airy function \spad{Bi}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs17akf}.
635749`\spad{s17dcf(fnu,{}z,{}n,{}scale,{}ifail)} returns a sequence of values for the Bessel functions \indented{1}{\spad{Y}\space{6}(\spad{z}) for complex \spad{z},{} non-negative (nu) and \spad{n=0},{}1,{}...,{}\spad{N}-1,{}} \indented{2}{(nu)\spad{+n}} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs17dcf}.
635863`\spad{s17def(fnu,{}z,{}n,{}scale,{}ifail)} returns a sequence of values for the Bessel functions \indented{1}{\spad{J}\space{6}(\spad{z}) for complex \spad{z},{} non-negative (nu) and \spad{n=0},{}1,{}...,{}\spad{N}-1,{}} \indented{2}{(nu)\spad{+n}} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs17def}.
635977`\spad{s17dgf(deriv,{}z,{}scale,{}ifail)} returns the value of the Airy function \spad{Ai}(\spad{z}) or its derivative Ai'(\spad{z}) for complex \spad{z},{} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs17dgf}.
636078`\spad{s17dhf(deriv,{}z,{}scale,{}ifail)} returns the value of the Airy function \spad{Bi}(\spad{z}) or its derivative Bi'(\spad{z}) for complex \spad{z},{} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs17dhf}.
636179`\spad{s17dlf(m,{}fnu,{}z,{}n,{}scale,{}ifail)} returns a sequence of values for the Hankel functions \indented{2}{(1)\space{11}(2)} \indented{1}{\spad{H}\space{6}(\spad{z}) or \spad{H}\space{6}(\spad{z}) for complex \spad{z},{} non-negative (nu) and} \indented{2}{(nu)\spad{+n}\space{8}(nu)\spad{+n}} \spad{n=0},{}1,{}...,{}\spad{N}-1,{} with an option for exponential scaling. See \do
636179`--wnlink{Manual Page}{manpageXXs17dlf}.
636301`\spad{s18acf(x,{}ifail)} returns the value of the modified Bessel Function \indented{1}{\spad{K} (\spad{x}),{} via the routine name.} \indented{2}{0} See \downlink{Manual Page}{manpageXXs18acf}.
636379`\spad{s18adf(x,{}ifail)} returns the value of the modified Bessel Function \indented{1}{\spad{K} (\spad{x}),{} via the routine name.} \indented{2}{1} See \downlink{Manual Page}{manpageXXs18adf}.
636457`\spad{s18aef(x,{}ifail)} returns the value of the modified Bessel Function \indented{1}{\spad{I} (\spad{x}),{} via the routine name.} \indented{2}{0} See \downlink{Manual Page}{manpageXXs18aef}.
636535`\spad{s18aff(x,{}ifail)} returns a value for the modified Bessel Function \indented{1}{\spad{I} (\spad{x}),{} via the routine name.} \indented{2}{1} See \downlink{Manual Page}{manpageXXs18aff}.
636613`\spad{s18dcf(fnu,{}z,{}n,{}scale,{}ifail)} returns a sequence of values for the modified Bessel functions \indented{1}{\spad{K}\space{6}(\spad{z}) for complex \spad{z},{} non-negative (nu) and} \indented{2}{(nu)\spad{+n}} \spad{n=0},{}1,{}...,{}\spad{N}-1,{} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs18dcf}.
636727`\spad{s18def(fnu,{}z,{}n,{}scale,{}ifail)} returns a sequence of values for the modified Bessel functions \indented{1}{\spad{I}\space{6}(\spad{z}) for complex \spad{z},{} non-negative (nu) and} \indented{2}{(nu)\spad{+n}} \spad{n=0},{}1,{}...,{}\spad{N}-1,{} with an option for exponential scaling. See \downlink{Manual Page}{manpageXXs18def}.
636841`\spad{s19aaf(x,{}ifail)} returns a value for the Kelvin function ber(\spad{x}) via the routine name. See \downlink{Manual Page}{manpageXXs19aaf}.
636919`\spad{s19abf(x,{}ifail)} returns a value for the Kelvin function bei(\spad{x}) via the routine name. See \downlink{Manual Page}{manpageXXs19abf}.
636997`\spad{s19acf(x,{}ifail)} returns a value for the Kelvin function ker(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs19acf}.
637075`\spad{s19adf(x,{}ifail)} returns a value for the Kelvin function kei(\spad{x}) via the routine name. See \downlink{Manual Page}{manpageXXs19adf}.
637153`\spad{s20acf(x,{}ifail)} returns a value for the Fresnel Integral \spad{S}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs20acf}.
637231`\spad{s20adf(x,{}ifail)} returns a value for the Fresnel Integral \spad{C}(\spad{x}),{} via the routine name. See \downlink{Manual Page}{manpageXXs20adf}.
637309`\spad{s21baf(x,{}y,{}ifail)} returns a value of an elementary integral,{} which occurs as a degenerate case of an elliptic integral of the first kind,{} via the routine name. See \downlink{Manual Page}{manpageXXs21baf}.
637399`\spad{s21bbf(x,{}y,{}z,{}ifail)} returns a value of the symmetrised elliptic integral of the first kind,{} via the routine name. See \downlink{Manual Page}{manpageXXs21bbf}.
637501`\spad{s21bcf(x,{}y,{}z,{}ifail)} returns a value of the symmetrised elliptic integral of the second kind,{} via the routine name. See \downlink{Manual Page}{manpageXXs21bcf}.
637603`\spad{s21bdf(x,{}y,{}z,{}r,{}ifail)} returns a value of the symmetrised elliptic integral of the third kind,{} via the routine name. See \downlink{Manual Page}{manpageXXs21bdf}.
637717`\spad{sPol }\undocumented
637858`\spad{safeCeiling(x)} returns the integer which is greater than any integer with the same floating point number representation.
637947`\spad{safeFloor(x)} returns the integer which is lower or equal to the largest integer which has the same floating point number representation.
638034`\spad{safetyMargin()} returns the number of low weight digits we do not trust in the floating point representation (used by \spadfun{safeCeiling}).
638134`\spad{safetyMargin(n)} sets to \spad{n} the number of low weight digits we do not trust in the floating point representation and returns the previous value (for use by \spadfun{safeCeiling}).
638361`\spad{sample yields} a value of type \%
638403`\spad{sample yields} a value of type \%
638441`\spad{sample yields} a value of type \%
638476`\spad{sample()} returns an object of type \%.
638533`\spad{sample()} returns a sample of \%
638568`\spad{satisfy?(v,{} p)} returns \spad{f}(\spad{v}) where \spad{f} is the predicate attached to \spad{p}.
638638`\spad{satisfy?([v1,{}...,{}vn],{} p)} returns \spad{f(v1,{}...,{}vn)} where \spad{f} is the top-level predicate attached to \spad{p}.
638714`\spad{satisfy?(r,{} p)} returns \spad{true} if the matches satisfy the top-level predicate of \spad{p},{} \spad{false} if they don\spad{'t},{} and "failed" if not enough variables of \spad{p} are matched in \spad{r} to decide.
638802`\spad{saturate(I,{}f)} is the saturation of the ideal \spad{I} with respect to the multiplicative set generated by the polynomial \spad{f}.
638879`\spad{saturate(I,{}f,{}lvar)} is the saturation with respect to the prime principal ideal which is generated by \spad{f} in the polynomial ring \spad{F[lvar]}.
638969`\spad{save()} creates a representation of a SAVE statement.
639007`\spad{sayLength(l)} returns the length of a list of strings \spad{l} as an integer.
639070`\spad{sayLength(s)} returns the length of a string \spad{s} as an integer.
639127`\spad{say(l)} sends a list of strings \spad{l} to output.
639181`\spad{say(s)} sends a string \spad{s} to output.
639229`\spad{scalarMatrix(r)} returns an \spad{n}-by-\spad{n} matrix with \spad{r}\spad{'s} on the diagonal and zeroes elsewhere.
639378`\spad{scalarMatrix(n,{}r)} returns an \spad{n}-by-\spad{n} matrix with \spad{r}\spad{'s} on the diagonal and zeroes elsewhere.
639458`\spad{scalarTypeOf(t)} returns the FORTRAN data type of \spad{t}
639544`\spad{scaleRoots(p,{}c)} returns the polynomial which has \spad{c} times the roots of \spad{p}.
639617`\spad{scale(k)} returns \spad{matrix [[k,{}0],{}[0,{}1]]} representing the map \spad{x -> k * x}.
639665`\spad{scale(m,{}h)} returns \spad{scale(h) * m} (see \spadfunFrom{shift}{MoebiusTransform}).
639716`\spad{scale(v,{}n,{}sx,{}sy)} displays the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} scaled by the factor \spad{sx} in the \spad{x}-coordinate direction and by the factor \spad{sy} in the \spad{y}-coordinate direction.
639798`\spad{scanOneDimSubspaces(basis,{}n)} gives a canonical representative of the {\em n}\spad{-}th one-dimensional subspace of the vector space generated by the elements of {\em basis},{} all from {\em R**n}. The coefficients of the representative are of shape {\em (0,{}...,{}0,{}1,{}*,{}...,{}*)},{} {\em *} in \spad{R}. If the size of \spad{R} is \spad{q},{} then there are {\em 
639798`--(q**n-1)/(q-1)} of them. We first reduce \spad{n} modulo this number,{} then find the largest \spad{i} such that {\em +/[q**i for i in 0..i-1] <= n}. Subtracting this sum of powers from \spad{n} results in an \spad{i}-digit number to \spad{basis} \spad{q}. This fills the positions of the stars.
639926`\spad{scan(func,{}vec,{}ident)} creates a new vector whose elements are the result of applying reduce to the binary function \spad{func},{} increasing initial subsequences of the vector \spad{vec},{} and the element \spad{ident}.
640034`\spad{scan(fn,{}u,{}ident)} successively uses the binary function \spad{fn} to reduce more and more of list \spad{u}. \spad{ident} is returned if the \spad{u} is empty. The result is a list of the reductions at each step. See \spadfun{reduce} for more information. Examples: \spad{scan(fn,{}[1,{}2],{}0) = [fn(2,{}fn(1,{}0)),{}fn(1,{}0)]} and \spad{scan(*,{}[2,{}3],{}1) = [2 * 1,{} 3 * (2 * 1)]}.
640103`\spad{scan(f,{}a,{}r)} successively applies \spad{reduce(f,{}x,{}r)} to more and more leading sub-arrays \spad{x} of one-dimensional array \spad{a}. More precisely,{} if \spad{a} is \spad{[a1,{}a2,{}...]},{} then \spad{scan(f,{}a,{}r)} returns \spad{[reduce(f,{}[a1],{}r),{}reduce(f,{}[a1,{}a2],{}r),{}...]}.
640217`\spad{scan(f,{}a,{}r)} successively applies \spad{reduce(f,{}x,{}r)} to more and more leading sub-arrays \spad{x} of primitive array \spad{a}. More precisely,{} if \spad{a} is \spad{[a1,{}a2,{}...]},{} then \spad{scan(f,{}a,{}r)} returns \spad{[reduce(f,{}[a1],{}r),{}reduce(f,{}[a1,{}a2],{}r),{}...]}.
640316`\spad{scan(func,{}vec,{}ident)} creates a new vector whose elements are the result of applying reduce to the binary function \spad{func},{} increasing initial subsequences of the vector \spad{vec},{} and the element \spad{ident}.
640391`\spad{scan(f,{}a,{}r)} successively applies \spad{reduce(f,{}x,{}r)} to more and more leading sub-aggregates \spad{x} of aggregrate \spad{a}. More precisely,{} if \spad{a} is \spad{[a1,{}a2,{}...]},{} then \spad{scan(f,{}a,{}r)} returns \spad{[reduce(f,{}[a1],{}r),{}reduce(f,{}[a1,{}a2],{}r),{}...]}.
640469`\spad{scan(f,{}a,{}r)} successively applies \spad{reduce(f,{}x,{}r)} to more and more leading sub-aggregates \spad{x} of aggregate \spad{a}. More precisely,{} if \spad{a} is \spad{[a1,{}a2,{}...]},{} then \spad{scan(f,{}a,{}r)} returns \spad {[reduce(f,{}[a1],{}r),{}reduce(f,{}[a1,{}a2],{}r),{}...]}.
640544`\spad{scan(b,{}h,{}[x0,{}x1,{}x2,{}...])} returns \spad{[y0,{}y1,{}y2,{}...]},{} where \spad{y0 = h(x0,{}b)},{} \spad{y1 = h(x1,{}y0)},{}\spad{...} \spad{yn = h(xn,{}y(n-1))}.
640619`\axiom{schema(\spad{P},{}\spad{Q})} returns the list of degrees of non zero subresultants of \axiom{\spad{P}} and \axiom{\spad{Q}}.
640710`\spad{schwerpunkt(p)} determines the 'Schwerpunkt' of the roots of the polynomial \spad{p} of degree \spad{n},{} \spadignore{i.e.} the center of gravity,{} which is {\em coeffient of \spad{x**(n-1)}} divided by {\em n times coefficient of \spad{x**n}}.
640785`\spad{screenResolution3D()} returns the screen resolution for a 3d graph.
640837`\spad{screenResolution()} returns the screen resolution
640885`\spad{screenResolution()} returns the screen resolution \spad{n}.
640945`\spad{screenResolution(n)} sets the screen resolution to \spad{n}.
641012`\spad{script(s,{} [a,{}b,{}c,{}d,{}e])} returns \spad{s} with subscripts a,{} superscripts \spad{b},{} pre-superscripts \spad{c},{} pre-subscripts \spad{d},{} and argument-scripts \spad{e}. Omitted components are taken to be empty. For example,{} \spad{script(s,{} [a,{}b,{}c])} is equivalent to \spad{script(s,{}[a,{}b,{}c,{}[],{}[]])}.
641072`\spad{script(s,{} [a,{}b,{}c,{}d,{}e])} returns \spad{s} with subscripts a,{} superscripts \spad{b},{} pre-superscripts \spad{c},{} pre-subscripts \spad{d},{} and argument-scripts \spad{e}.
641229`\spad{scripted?(s)} is \spad{true} if \spad{s} has been given any scripts.
641274`\spad{scripts(s)} returns all the scripts of \spad{s}.
641429`\spad{scripts(f,{} [sub,{} super,{} presuper,{} presub])} \indented{1}{creates a form for \spad{f} with scripts on all 4 corners.}
641480`\spad{sdf2lst(ln)} coerces a Stream of \axiomType{DoubleFloat} to \axiomType{List}(\axiomType{String})
641568`\spad{sdf2lst(ln)} coerces a \axiomType{Stream DoubleFloat} to \axiomType{String}
641651`\spad{sdf2lst(ln)} coerces a Stream of \axiomType{DoubleFloat} to \axiomType{List String}
641726`\spad{se2rfi(l)} converts \spad{l} to target domain
641835`\spad{search(k,{}t)} searches the table \spad{t} for the key \spad{k},{} returning the entry stored in \spad{t} for key \spad{k}. If \spad{t} has no such key,{} \axiom{search(\spad{k},{}\spad{t})} returns "failed".
641915`\spad{sec2cos(f)} converts every \spad{sec(u)} appearing in \spad{f} into \spad{1/cos(u)}.
641977`\spad{secIfCan(z)} returns sec(\spad{z}) if possible,{} and "failed" otherwise.
642057`\spad{sec(x)} applies the secant operator to \spad{x}
642220`\spad{sec(st)} computes secant of a power series \spad{st}.
642303`\spad{sec(st)} computes secant of a power series \spad{st}.
642400`\spad{sec(z)} returns the secant of Laurent series \spad{z}.
642486`\spad{sec(z)} returns the secant of a Puiseux series \spad{z}.
642581`\spad{sec(x)} returns the secant of \spad{x}.
642638`\spad{sech2cosh(f)} converts every \spad{sech(u)} appearing in \spad{f} into \spad{1/cosh(u)}.
642702`\spad{sechIfCan(z)} returns sech(\spad{z}) if possible,{} and "failed" otherwise.
642783`\spad{sech(x)} applies the hyperbolic secant operator to \spad{x}
642946`\spad{sech(st)} computes the hyperbolic secant of a power series \spad{st}.
643030`\spad{sech(st)} computes the hyperbolic secant of a power series \spad{st}.
643128`\spad{sech(z)} returns the hyperbolic secant of Laurent series \spad{z}.
643215`\spad{sech(z)} returns the hyperbolic secant of a Puiseux series \spad{z}.
643311`\spad{sech(x)} returns the hyperbolic secant of \spad{x}.
643419`\spad{second(u)} returns the second element of \spad{u}. Note: \axiom{second(\spad{u}) = first(rest(\spad{u}))}.
643475`\spad{seed()} returns the current seed value.
643525`\spad{segment(l)} is an alternate way to construct the segment \spad{l..}.
643575`\spad{segment(segb)} returns the segment from the right hand side of the \spadtype{SegmentBinding}. For example,{} if \spad{segb} is \spad{v=a..b},{} then \spad{segment(segb)} returns \spad{a..b}.
643632`\spad{segment(i,{}j)} is an alternate way to create the segment \spad{i..j}.
643794`\spad{select!(p,{}d)} destructively changes dictionary \spad{d} by removing all entries \spad{x} such that \axiom{\spad{p}(\spad{x})} is not \spad{true}.
643896`\spad{select!(p,{}u)} destructively changes \spad{u} by keeping only values \spad{x} such that \axiom{\spad{p}(\spad{x})}.
643969`\axiom{selectAndPolynomials(lpred?,{}\spad{ps})} returns \axiom{\spad{gps},{}\spad{bps}} where \axiom{\spad{gps}} is a list of the polynomial \axiom{\spad{p}} in \axiom{\spad{ps}} such that \axiom{pred?(\spad{p})} holds for every \axiom{pred?} in \axiom{lpred?} and \axiom{\spad{bps}} are the other ones.
644114`\spad{selectFiniteRoutines(R)} chooses only those routines from the database which are designed for use with finite expressions
644172`\spad{selectIntegrationRoutines(R)} chooses only those routines from the database which are for integration
644235`\spad{selectMultiDimensionalRoutines(R)} chooses only those routines from the database which are designed for use with multi-dimensional expressions
644303`\spad{selectNonFiniteRoutines(R)} chooses only those routines from the database which are designed for use with non-finite expressions.
644364`\spad{selectODEIVPRoutines(R)} chooses only those routines from the database which are for the solution of ODE\spad{'s}
644422`\spad{selectOptimizationRoutines(R)} chooses only those routines from the database which are for integration
644486`\axiom{selectOrPolynomials(lpred?,{}\spad{ps})} returns \axiom{\spad{gps},{}\spad{bps}} where \axiom{\spad{gps}} is a list of the polynomial \axiom{\spad{p}} in \axiom{\spad{ps}} such that \axiom{pred?(\spad{p})} holds for some \axiom{pred?} in \axiom{lpred?} and \axiom{\spad{bps}} are the other ones.
644630`\spad{selectPDERoutines(R)} chooses only those routines from the database which are for the solution of PDE\spad{'s}
644685`\axiom{selectPolynomials(pred?,{}\spad{ps})} returns \axiom{\spad{gps},{}\spad{bps}} where \axiom{\spad{gps}} is a list of the polynomial \axiom{\spad{p}} in \axiom{\spad{ps}} such that \axiom{pred?(\spad{p})} holds and \axiom{\spad{bps}} are the other ones.
644821`\spad{selectSumOfSquaresRoutines(R)} chooses only those routines from the database which are designed for use with sums of squares
645151`\spad{select(x,{}n)} returns the \spad{n}-th element of tuple \spad{x}. tuples are 0-based
645208`\spad{select(p,{}u)} returns a copy of \spad{u} containing only those elements such \axiom{\spad{p}(\spad{x})} is \spad{true}. Note: \axiom{select(\spad{p},{}\spad{u}) \spad{==} [\spad{x} for \spad{x} in \spad{u} | \spad{p}(\spad{x})]}.
645299`\spad{select(f,{}st)} returns a stream consisting of those elements of stream \spad{st} satisfying the predicate \spad{f}. Note: \spad{select(f,{}st) = [x for x in st | f(x)]}.
645365`\spad{select(p,{}t)} returns \spad{[x for x in t | p(x)]}.
645425`\axiom{select(\spad{ts},{}\spad{v})} returns the polynomial of \axiom{\spad{ts}} with \axiom{\spad{v}} as main variable,{} if any.
645503`\spad{selectfirst(x)} \undocumented
645550`\spad{selectsecond(x)} \undocumented
645598`\axiom{indiceSubResultant(\spad{P},{} \spad{Q},{} \spad{i})} returns a subresultant \axiom{\spad{S}} of degree \axiom{\spad{d}} and carries out the equality \axiom{...\spad{P} + coef2*Q = S_i}. Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
645745`\axiom{discriminantEuclidean(\spad{P})} carries out the equality \axiom{...\spad{P} + \spad{coef2} * \spad{D}(\spad{P}) = discriminant(\spad{P})}. Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
645859`\axiom{semiIndiceSubResultantEuclidean(\spad{P},{} \spad{Q},{} \spad{i})} returns the subresultant \axiom{S_i(\spad{P},{}\spad{Q})} and carries out the equality \axiom{...\spad{P} + coef2*Q = S_i(\spad{P},{}\spad{Q})} Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
646006`\axiom{semiLastSubResultantEuclidean(\spad{P},{} \spad{Q})} computes the last non zero subresultant \axiom{\spad{S}} and carries out the equality \axiom{...\spad{P} + coef2*Q = \spad{S}}. Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
646132`\axiom{\spad{semiResultantEuclidean1}(\spad{P},{}\spad{Q})} carries out the equality \axiom{\spad{coef1}.\spad{P} + ? \spad{Q} = resultant(\spad{P},{}\spad{Q})}.
646246`\axiom{\spad{semiResultantEuclidean2}(\spad{P},{}\spad{Q})} carries out the equality \axiom{...\spad{P} + coef2*Q = resultant(\spad{P},{}\spad{Q})}. Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
646360`\axiom{resultantEuclidean_naif(\spad{P},{}\spad{Q})} returns the semi-extended resultant of \axiom{\spad{P}} and \axiom{\spad{Q}} computed by means of the naive algorithm.
646477`\axiom{semiResultantReduitEuclidean(\spad{P},{}\spad{Q})} returns the "reduce resultant" and carries out the equality \axiom{...\spad{P} + coef2*Q = resultantReduit(\spad{P},{}\spad{Q})}.
646618`\axiom{\spad{semiSubResultantGcdEuclidean1}(\spad{P},{}\spad{Q})} carries out the equality \axiom{coef1*P + ? \spad{Q} = \spad{+/-} S_i(\spad{P},{}\spad{Q})} where the degree (not the indice) of the subresultant \axiom{S_i(\spad{P},{}\spad{Q})} is the smaller as possible.
646735`\axiom{\spad{semiSubResultantGcdEuclidean2}(\spad{P},{}\spad{Q})} carries out the equality \axiom{...\spad{P} + coef2*Q = \spad{+/-} S_i(\spad{P},{}\spad{Q})} where the degree (not the indice) of the subresultant \axiom{S_i(\spad{P},{}\spad{Q})} is the smaller as possible. Warning: \axiom{degree(\spad{P}) \spad{>=} degree(\spad{Q})}.
646852`\spad{semicolonSeparate(l)} creates the form separating the elements of \spad{l} by semicolons.
646978`\spad{separant(p)} returns the partial derivative of the differential polynomial \spad{p} with respect to its leader.
647050`\spad{separateDegrees(p)} splits the square free polynomial \spad{p} into factors each of which is a product of irreducibles of the same degree.
647161`\spad{separateFactors(lfact)} takes the list produced by \spadfunFrom{separateDegrees}{DistinctDegreeFactorization} and produces the complete list of factors.
647278`\spad{separateFactors(ddl,{} p)} refines the distinct degree factorization produced by \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer} to give a complete list of factors.
647400`\spad{separate(x)} \undocumented
647517`\spad{separate(s)} makes each of the components of the \spadtype{SubSpace},{} \spad{s},{} into a list of separate and distinct subspaces and returns the list.
647662`\spad{separate(p,{} q)} returns \spad{[a,{} b]} such that polynomial \spad{p = a b} and \spad{a} is relatively prime to \spad{q}.
647777`\spad{sequences([l0,{}l1,{}l2,{}..,{}ln])} is the set of \indented{1}{all sequences formed from} \spad{l0} 0\spad{'s},{}\spad{l1} 1\spad{'s},{}\spad{l2} 2\spad{'s},{}...,{}\spad{ln} \spad{n}\spad{'s}.
647866`\spad{sequences(l1,{}l2)} is the stream of all sequences that \indented{1}{can be composed from the multiset defined from} \indented{1}{two lists of integers \spad{l1} and \spad{l2}.} \indented{1}{For example,{}the pair \spad{([1,{}2,{}4],{}[2,{}3,{}5])} represents} \indented{1}{multi-set with 1 \spad{2},{} 2 \spad{3}\spad{'s},{} and 4 \spad{5}\spad{'s}.}
647969`\spad{seriesSolve(eq,{}y,{}x=a,{} y a = b)} returns a Taylor series solution of \spad{eq} around \spad{x} = a with initial condition \spad{y(a) = b}. Note: \spad{eq} must be of the form \spad{f(x,{} y x) y'(x) + g(x,{} y x) = h(x,{} y x)}.
648082`\spad{seriesSolve(eq,{}y,{} x=a,{} b)} is equivalent to \spad{seriesSolve(eq,{} y,{} x=a,{} y a = b)}.
648185`\spad{seriesSolve(eq,{}y,{}x=a,{}[b0,{}...,{}b(n-1)])} returns a Taylor series solution of \spad{eq} around \spad{x = a} with initial conditions \spad{y(a) = b0},{} \spad{y'(a) = b1},{} \spad{y''(a) = b2},{} ...,{}\spad{y(n-1)(a) = b(n-1)} \spad{eq} must be of the form \spad{f(x,{} y x,{} y'(x),{}...,{} y(n-1)(x)) y(n)(x) + g(x,{}y x,{}y'(x),{}...,{}y(n-1)(x)) = h(x,{}y x,{} y'(x),{}...,{} y(n-1
648185`--)(x))}.
648294`\spad{seriesSolve(eq,{} y,{} x = a,{} y a = b)} is equivalent to \spad{seriesSolve(eq=0,{} y,{} x=a,{} y a = b)}.
648397`\spad{seriesSolve(eq,{} y,{} x = a,{} b)} is equivalent to \spad{seriesSolve(eq = 0,{} y,{} x = a,{} y a = b)}.
648490`\spad{seriesSolve(eq,{} y,{} x = a,{} [b0,{}...,{}bn])} is equivalent to \spad{seriesSolve(eq = 0,{} y,{} x = a,{} [b0,{}...,{}b(n-1)])}.
648589`\spad{seriesSolve([eq1,{}...,{}eqn],{}[y1,{}...,{}yn],{}x = a,{}[y1 a = b1,{}...,{}yn a = bn])} returns a taylor series solution of \spad{[eq1,{}...,{}eqn]} around \spad{x = a} with initial conditions \spad{\spad{yi}(a) = \spad{bi}}. Note: eqi must be of the form \spad{\spad{fi}(x,{} y1 x,{} y2 x,{}...,{} yn x) y1'(x) + \spad{gi}(x,{} y1 x,{} y2 x,{}...,{} yn x) = h(x,{} y1
648589`-- x,{} y2 x,{}...,{} yn x)}.
648720`\spad{seriesSolve([eq1,{}...,{}eqn],{} [y1,{}...,{}yn],{} x=a,{} [b1,{}...,{}bn])} is equivalent to \spad{seriesSolve([eq1,{}...,{}eqn],{} [y1,{}...,{}yn],{} x = a,{} [y1 a = b1,{}...,{} yn a = bn])}.
648841`\spad{seriesSolve([eq1,{}...,{}eqn],{} [y1,{}...,{}yn],{} x = a,{}[y1 a = b1,{}...,{} yn a = bn])} is equivalent to \spad{seriesSolve([eq1=0,{}...,{}eqn=0],{} [y1,{}...,{}yn],{} x = a,{} [y1 a = b1,{}...,{} yn a = bn])}.
648962`\spad{seriesSolve([eq1,{}...,{}eqn],{} [y1,{}...,{}yn],{} x=a,{} [b1,{}...,{}bn])} is equivalent to \spad{seriesSolve([eq1=0,{}...,{}eqn=0],{} [y1,{}...,{}yn],{} x=a,{} [b1,{}...,{}bn])}.
649073`\spad{seriesToOutputForm(st,{}refer,{}var,{}cen,{}r)} prints the series \spad{f((var - cen)^r)}.
649260`\spad{series(s)} creates a power series from a stream of \indented{1}{ring elements.} \indented{1}{For univariate series types,{} the stream \spad{s} should be a stream} \indented{1}{of Taylor coefficients. For multivariate series types,{} the} \indented{1}{stream \spad{s} should be a stream of forms the \spad{n}th element} \indented{1}{of which is a} \indented{1}{form of degree \spad{n} in the power series variables.}
649324`\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents.
649423`\spad{series(f)} returns a series expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.
649494`\spad{series([a0,{}a1,{}a2,{}...])} is the Taylor series \spad{a0 + a1 x + a2 x**2 + ...}.
649571`\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents.
649669`\spad{series(st)} creates a series from a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents.
649777`\spad{series(x)} returns \spad{x} viewed as a series.
649852`\spad{series(n +-> a(n),{}x = a)} returns \spad{sum(n = 0..,{}a(n)*(x-a)**n)}.
649943`\spad{series(f,{}x = a)} expands the expression \spad{f} as a series in powers of (\spad{x} - a).
650027`\spad{series(f,{}n)} returns a series expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.
650116`\spad{series(n,{}st)} creates a series from a common denomiator and a stream of non-zero terms,{} where a term is an exponent-coefficient pair. The terms in the stream should be ordered by increasing order of exponents and \spad{n} should be a common denominator for the exponents in the stream of terms.
650243`\spad{series(n +-> a(n),{}x = a,{}n0..)} returns \spad{sum(n = n0..,{}a(n) * (x - a)**n)}; \spad{series(n +-> a(n),{}x = a,{}n0..n1)} returns \spad{sum(n = n0..n1,{}a(n) * (x - a)**n)}.
650360`\spad{series(f,{}x = a,{}n)} expands the expression \spad{f} as a series in powers of (\spad{x} - a); terms will be computed up to order at least \spad{n}.
650462`\spad{series(a(n),{}n,{}x = a)} returns \spad{sum(n = 0..,{}a(n)*(x-a)**n)}.
650549`\spad{series(n +-> a(n),{}x = a,{}r0..,{}r)} returns \spad{sum(n = r0,{}r0 + r,{}r0 + 2*r...,{} a(n) * (x - a)**n)}; \spad{series(n +-> a(n),{}x = a,{}r0..r1,{}r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)**n)}.
650704`\spad{series(a(n),{}n,{}x=a,{}n0..)} returns \spad{sum(n = n0..,{}a(n) * (x - a)**n)}; \spad{series(a(n),{}n,{}x=a,{}n0..n1)} returns \spad{sum(n = n0..n1,{}a(n) * (x - a)**n)}.
650817`\spad{series(a(n),{}n,{}x = a,{}r0..,{}r)} returns \spad{sum(n = r0,{}r0 + r,{}r0 + 2*r...,{} a(n) * (x - a)**n)}; \spad{series(a(n),{}n,{}x = a,{}r0..r1,{}r)} returns \spad{sum(n = r0 + k*r while n <= r1,{} a(n) * (x - a)**n)}.
650958`\spad{setAdaptive3D(true)} turns adaptive plotting on; setAdaptive3D(\spad{false}) turns adaptive plotting off.
651012`\spad{setAdaptive(true)} turns adaptive plotting on \spad{setAdaptive(false)} turns adaptive plotting off
651062`\axiom{setAttributeButtonStep(\spad{n})} sets the value of the steps for increasing and decreasing the button values. \axiom{\spad{n}} must be greater than 0 and less than 1. The preset value is 0.5.
651131`\axiom{setButtonValue(attributeName,{}\spad{n})} sets the value of all buttons of attribute \spad{attributeName} to \spad{n}. \spad{n} must be in the range [0..1]. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
651199`\axiom{setButtonValue(attributeName,{}routineName,{}\spad{n})} sets the value of the button of attribute \spad{attributeName} to routine \spad{routineName} to \spad{n}. \spad{n} must be in the range [0..1]. \blankline \axiom{attributeName} should be one of the values "stiffness",{} "stability",{} "accuracy",{} "expense" or "functionEvaluations".
651274`\spad{setClipValue(x)} sets to \spad{x} the maximum value to plot when drawing complex functions. Returns \spad{x}.
651340`\spad{setClosed(t,{}b)} declares the given tube plot \spad{t} to be closed if \spad{b} is \spad{true},{} or if \spad{b} is \spad{false},{} \spad{t} is set to be open.
651483`\spad{setColumn!(m,{}j,{}v)} sets to \spad{j}th column of \spad{m} to \spad{v}
651568`\axiom{setCondition!(\spad{n},{}\spad{t})} returns \spad{n} whose condition has been replaced by \spad{t} if it is not empty,{} else an error is produced.
651626`\spad{setDifference(u1,{}u2)} returns a list of the elements of \spad{u1} that are not also in \spad{u2}. The order of elements in the resulting list is unspecified.
651692`\axiom{setEmpty!(\spad{n})} replaces \spad{n} by \axiom{empty()\$\%}.
651744`\spad{setEpilogue!(t,{}strings)} sets the epilogue section of a formatted object \spad{t} to \spad{strings}.
651823`\spad{setEpilogue!(t,{}strings)} sets the epilogue section of a TeX form \spad{t} to \spad{strings}.
651892`\spad{setErrorBound(eps)} changes the internal error bound,{} by default being {\em 10 ** (-3)} to \spad{eps},{} if \spad{R} is a member in the category \spadtype{QuotientFieldCategory Integer}. The internal {\em globalDigits} is set to {\em ceiling(1/r)**2*10} being {\em 10**7} by default.
651959`\spad{setFieldInfo(m,{}p)} initializes the field arithmetic,{} where \spad{m} is the multiplication table and \spad{p} is the respective normal element of the ground field \spad{GF}.
652083`\spad{setFormula!(t,{}strings)} sets the formula section of a formatted object \spad{t} to \spad{strings}.
652161`\spad{setImagSteps(i)} sets to \spad{i} the number of steps to use in the imaginary direction when drawing complex functions. Returns \spad{i}.
652219`\spad{setIntersection(u1,{}u2)} returns a list of the elements that lists \spad{u1} and \spad{u2} have in common. The order of elements in the resulting list is unspecified.
652287`\spad{setLabelValue(i)} resets the counter which produces labels to \spad{i}
652358`\spad{setLegalFortranSourceExtensions(l)} \undocumented{}
652448`\spad{setMaxPoints3D(i)} sets the maximum number of points in a plot to \spad{i}.
652503`\spad{setMaxPoints(i)} sets the maximum number of points in a plot to \spad{i}
652554`\spad{setMinPoints3D(i)} sets the minimum number of points in a plot to \spad{i}.
652609`\spad{setMinPoints(i)} sets the minimum number of points in a plot to \spad{i}
652660`\spad{setOfMinN([a_1,{}...,{}a_m])} returns the set {\spad{a_1},{}...,{}a_m}. Error if {\spad{a_1},{}...,{}a_m} is not a set of \spad{M} integers in \spad{1..n}.
652740`\spad{setOrder([a1,{}...,{}an])} defines a partial ordering on \spad{S} given \spad{by:} \indented{3}{(1)\space{2}\spad{a1 < a2 < ... < an}.} \indented{3}{(2)\space{2}\spad{b < \spad{ai}\space{3}for i = 1..n} and \spad{b} not among the \spad{ai}\spad{'s}.} \indented{3}{(3)\space{2}undefined on \spad{(b,{} c)} if neither is among the \spad{ai}\spad{'s}.}
652809`\spad{setOrder([b1,{}...,{}bm],{} [a1,{}...,{}an])} defines a partial ordering on \spad{S} given \spad{by:} \indented{3}{(1)\space{2}\spad{b1 < b2 < ... < bm < a1 < a2 < ... < an}.} \indented{3}{(2)\space{2}\spad{bj < c < \spad{ai}}\space{2}for \spad{c} not among the \spad{ai}\spad{'s} and \spad{bj}\spad{'s}.} \indented{3}{(3)\space{2}undefined on \spad{(c,{}d)} if neither is among the \spad{ai}\spad{'s},{}\spad{bj}\spad{'s}.}
652886`\spad{setPoly(x)} \undocumented
652935`\spad{setPosition(x,{} n)} associates the integer \spad{n} to \spad{x}.
653003`\spad{setPredicates(p,{} [p1,{}...,{}pn])} attaches the predicate \spad{p1} and ... and \spad{pn} to \spad{p}.
653061`\spad{setPrologue!(t,{}strings)} sets the prologue section of a formatted object \spad{t} to \spad{strings}.
653140`\spad{setPrologue!(t,{}strings)} sets the prologue section of a TeX form \spad{t} to \spad{strings}.
653209`\spad{setProperties(op,{} l)} sets the property list of \spad{op} to \spad{l}. Argument \spad{op} is modified "in place",{} \spadignore{i.e.} no copy is made.
653289`\spad{setProperty(op,{} s,{} v)} attaches property \spad{s} to \spad{op},{} and sets its value to \spad{v}. Argument \spad{op} is modified "in place",{} \spadignore{i.e.} no copy is made.
653350`\spad{setRealSteps(i)} sets to \spad{i} the number of steps to use in the real direction when drawing complex functions. Returns \spad{i}.
653486`\spad{setRow!(m,{}i,{}v)} sets to \spad{i}th row of \spad{m} to \spad{v}
653568`\spad{setScreenResolution3D(i)} sets the screen resolution for a 3d graph to \spad{i}.
653630`\spad{setScreenResolution(i)} sets the screen resolution to \spad{i}
653688`\axiom{setStatus!(\spad{n},{}\spad{b})} returns \spad{n} whose status has been replaced by \spad{b} if it is not empty,{} else an error is produced.
653749`\spad{setStatus(s,{}t)} returns the same representation for \spad{s},{} but asserts the following: if \spad{t} is \spad{true},{} then \spad{s} is empty,{} if \spad{t} is \spad{false},{} then \spad{s} is non-empty,{} and if \spad{t} = "failed",{} then no assertion is made (that is,{} "don\spad{'t} know"). Note: for internal use only,{} with care.
653843`\spad{setTex!(t,{}strings)} sets the TeX section of a TeX form \spad{t} to \spad{strings}.
653907`\spad{setTopPredicate(x,{} [a1,{}...,{}an],{} f)} returns \spad{x} with the top-level predicate set to \spad{f(a1,{}...,{}an)}.
653974`\spad{setUnion(u1,{}u2)} appends the two lists \spad{u1} and \spad{u2},{} then removes all duplicates. The order of elements in the resulting list is unspecified.
654035`\axiom{setValue!(\spad{n},{}\spad{v})} returns \spad{n} whose value has been replaced by \spad{v} if it is not empty,{} else an error is produced.
654089`\spad{setVariableOrder([a1,{}...,{}an])} defines an ordering on the variables given by \spad{a1 > a2 > ... > an > other variables}.
654169`\spad{setVariableOrder([b1,{}...,{}bm],{} [a1,{}...,{}an])} defines an ordering on the variables given by \spad{b1 > b2 > ... > bm >} other variables \spad{> a1 > a2 > ... > an}.
654306`\spad{set()}\$\spad{D} creates an empty set aggregate of type \spad{D}.
654398`\spad{set([x,{}y,{}...,{}z])} creates a set aggregate containing items \spad{x},{}\spad{y},{}...,{}\spad{z}.
654513`\spad{setchildren!(u,{}v)} replaces the current children of node \spad{u} with the members of \spad{v} in left-to-right order.
654615`\spad{setelt!(x,{}i,{}j,{}k,{}s)} (or \spad{x}.\spad{i}.\spad{j}.k:=s) sets a specific element of the array to some value of type \spad{R}
654730`\spad{setelt(n,{}m)} changes the value of the object \spad{n} to \spad{m}.
655773`\spad{setelt(u,{}"first",{}x)} (also written: \axiom{\spad{u}.first \spad{:=} \spad{x}}) is equivalent to \axiom{setfirst!(\spad{u},{}\spad{x})}.
655874`\spad{setelt(u,{}"last",{}x)} (also written: \axiom{\spad{u}.last \spad{:=} \spad{b}}) is equivalent to \axiom{setlast!(\spad{u},{}\spad{v})}.
655974`\spad{setelt(a,{}"left",{}b)} (also written \axiom{a . left \spad{:=} \spad{b}}) is equivalent to \axiom{setleft!(a,{}\spad{b})}.
656077`\spad{setelt(u,{}"rest",{}v)} (also written: \axiom{\spad{u}.rest \spad{:=} \spad{v}}) is equivalent to \axiom{setrest!(\spad{u},{}\spad{v})}.
656179`\spad{setelt(a,{}"right",{}b)} (also written \axiom{\spad{b} . right \spad{:=} \spad{b}}) is equivalent to \axiom{setright!(a,{}\spad{b})}.
656283`\spad{setelt(a,{}"value",{}x)} (also written \axiom{a . value \spad{:=} \spad{x}}) is equivalent to \axiom{setvalue!(a,{}\spad{x})}
656379`\spad{setelt(u,{}x,{}y)} sets the image of \spad{x} to be \spad{y} under \spad{u},{} assuming \spad{x} is in the domain of \spad{u}. Error: if \spad{x} is not in the domain of \spad{u}.
656476`\spad{setelt(t,{}k,{}e)} (also written \axiom{\spad{t}.\spad{k} \spad{:=} \spad{e}}) is equivalent to \axiom{(insert([\spad{k},{}\spad{e}],{}\spad{t}); \spad{e})}.
656545`\spad{lib.k := v} saves the value \spad{v} in the library \spad{lib}. It can later be extracted using the key \spad{k}.
656595`\spad{setelt(u,{}i..j,{}x)} (also written: \axiom{\spad{u}(\spad{i}..\spad{j}) \spad{:=} \spad{x}}) destructively replaces each element in the segment \axiom{\spad{u}(\spad{i}..\spad{j})} by \spad{x}. The value \spad{x} is returned. Note: \spad{u} is destructively change so that \axiom{\spad{u}.\spad{k} \spad{:=} \spad{x} for \spad{k} in \spad{i}..\spad{j}}; its length remains unchanged.
656858`\spad{setelt(m,{}i,{}j,{}r)} sets the element in the \spad{i}th row and \spad{j}th column of \spad{m} to \spad{r} error check to determine if indices are in proper ranges
656944`\spad{setelt(x,{}rowList,{}colList,{}y)} destructively alters the matrix \spad{x}. If \spad{y} is \spad{m}-by-\spad{n},{} \spad{rowList = [i<1>,{}i<2>,{}...,{}i<m>]} and \spad{colList = [j<1>,{}j<2>,{}...,{}j<n>]},{} then \spad{x(i<k>,{}j<l>)} is set to \spad{y(k,{}l)} for \spad{k = 1,{}...,{}m} and \spad{l = 1,{}...,{}n}.
657031`\spad{setfirst!(u,{}x)} destructively changes the first element of a to \spad{x}.
657184`\spad{setlast!(u,{}x)} destructively changes the last element of \spad{u} to \spad{x}.
657279`\spad{setleaves!(t,{} ls)} sets the leaves of \spad{t} in left-to-right order to the elements of \spad{ls}.
657343`\spad{setleft!(a,{}b)} sets the left child of \axiom{a} to be \spad{b}.
657441`\spad{setnext!(u,{}v)} destructively sets the next node of doubly-linked aggregate \spad{u} to \spad{v},{} returning \spad{v}.
657536`\spad{setprevious!(u,{}v)} destructively sets the previous node of doubly-linked aggregate \spad{u} to \spad{v},{} returning \spad{v}.
657635`\spad{setref(n,{}m)} same as \spad{setelt(n,{}m)}.
657679`\spad{setrest!(u,{}v)} destructively changes the rest of \spad{u} to \spad{v}.
657776`\spad{setrest!(x,{}n,{}y)} sets rest(\spad{x},{}\spad{n}) to \spad{y}. The function will expand cycles if necessary.
657829`\spad{setright!(a,{}x)} sets the right child of \spad{t} to be \spad{x}.
658005`\spad{setsubMatrix(x,{}i1,{}j1,{}y)} destructively alters the matrix \spad{x}. Here \spad{x(i,{}j)} is set to \spad{y(i-i1+1,{}j-j1+1)} for \spad{i = i1,{}...,{}i1-1+nrows y} and \spad{j = j1,{}...,{}j1-1+ncols y}.
658145`\spad{setvalue!(u,{}x)} sets the value of node \spad{u} to \spad{x}.
658236`\spad{sh(x,{}n)} returns the shuffle power of \spad{x} to the \spad{n}.
658322`\spad{sh(x,{}y)} returns the shuffle-product of \spad{x} by \spad{y}. This multiplication is associative and commutative.
658392`\spad{shade(pt)} returns the fourth element of the two dimensional point,{} \spad{pt},{} although no assumptions are made with regards as to how the components of higher dimensional points are interpreted. This function is defined for the convenience of the user using specifically,{} shade to express a fourth dimension.
658442`\spad{shade(p)} returns the shade index of the indicated palette \spad{p}.
658484`\spad{shallowCopy(x)} \undocumented
658533`\spad{shallowExpand(x)} \undocumented{}
658606`\spad{shanksDiscLogAlgorithm(b,{}a,{}p)} computes \spad{s} with \spad{b**s = a} for assuming that \spad{a} and \spad{b} are elements in a 'small' cyclic group of order \spad{p} by Shank\spad{'s} algorithm. Note: this is a subroutine of the function \spadfun{discreteLog}.
658732`\spad{shellSort(f,{} agg)} sorts the aggregate agg with the ordering function \spad{f} using the shellSort algorithm.
658889`\spad{shiftLeft(p,{}n)} returns \spad{p * monomial(1,{}n)}
659054`\spad{shiftRight(p,{}n)} returns \spad{monicDivide(p,{}monomial(1,{}n)).quotient}
659139`\spad{shiftRoots(p,{}c)} returns the polynomial which has for roots \spad{c} added to the roots of \spad{p}.
659212`\spad{shift(k)} returns \spad{matrix [[1,{}k],{}[0,{}1]]} representing the map \spad{x -> x + k}.
659260`\spad{shift(m,{}h)} returns \spad{shift(h) * m} (see \spadfunFrom{shift}{MoebiusTransform}).
659311`\spad{shift(x,{}n)} adds \spad{n} to the exponent of float \spad{x}.
659354`\spad{shift(a,{}i)} shift \spad{a} by \spad{i} bits.
659410`\spad{shift(a,{}i)} shift \spad{a} by \spad{i} digits.
659462`\spad{showAll?()} returns \spad{true} if all computed entries of streams will be displayed.
659525`\spad{showAllElements(s)} creates an output form which displays all computed elements.
659600`\spad{showArrayValues(true)} forces the values of array components to be \indented{1}{displayed rather than just their types.}
659656`\spad{showAttributes(x)} \undocumented{}
660510`\spad{showClipRegion(v,{}s)} displays the clipping region of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or does not display the region if \spad{s} is "off".
660582`\spad{showFortranOutputStack()} returns the Fortran output stack
660663`\spad{showIntensityFunctions(k)} returns the entries in the table of intensity functions \spad{k}.
661033`\spad{showRegion(v,{}s)} displays the bounding box of the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} if \spad{s} is "on",{} or does not display the box if \spad{s} is "off".
661101`\spad{showScalarValues(true)} forces the values of scalar components to be \indented{1}{displayed rather than just their types.}
661158`\spad{showTheFTable()} returns the current table of functions.
661219`\spad{showTheIFTable()} returns the current table of intensity functions.
661282`\spad{showTheRoutinesTable()} returns the current table of NAG routines.
661338`\spad{showTheSymbolTable()} returns the current symbol table.
661393`\spad{showTypeInOutput(bool)} affects the way objects of \spadtype{Any} are displayed. If \spad{bool} is \spad{true} then the type of the original object that was converted to \spadtype{Any} will be printed. If \spad{bool} is \spad{false},{} it will not be printed.
661446`\spad{show(v,{}n,{}s)} displays the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the graph if \spad{s} is "off".
661522`\spad{shrinkable(b)} sets the shrinkable attribute of flexible arrays to \spad{b} and returns the previous value
661649`\spad{shuffle(l1,{}l2)} forms the stream of all shuffles of \spad{l1} \indented{1}{and \spad{l2},{} \spadignore{i.e.} all sequences that can be formed from} \indented{1}{merging \spad{l1} and \spad{l2}.}
661750`\spad{shufflein(l,{}st)} maps shuffle(\spad{l},{}\spad{u}) on to all \indented{1}{members \spad{u} of \spad{st},{} concatenating the results.}
661861`\spad{signAround(u,{}i,{}f)} \undocumented
661973`\spad{signAround(u,{}r,{}f)} \undocumented
662079`\spad{signAround(u,{}r,{}i,{}f)} \undocumented
662193`\spad{sign(r)} \undocumented
662300`\spad{sign(f)} returns the sign of \spad{f} if it is constant everywhere.
662376`\spad{sign f} returns the sign of \spad{f} if it is constant everywhere.
662470`\spad{sign(x)} is 1 if \spad{x} is positive,{} \spad{-1} if \spad{x} is negative,{} 0 if \spad{x} equals 0.
662515`\spad{sign(p)} returns the signum of the permutation \spad{p},{} \spad{+1} or \spad{-1}.
662563`\axiom{sign(pol,{}aRoot)} gives the sign of \axiom{pol} interpreted as \axiom{aRoot}
662655`\spad{sign(f,{} x,{} a)} returns the sign of \spad{f} as \spad{x} nears \spad{a},{} from both sides if \spad{a} is finite.
662759`\spad{sign(f,{} x,{} a)} returns the sign of \spad{f} as \spad{x} approaches \spad{a},{} from both sides if \spad{a} is finite.
662903`\spad{sign(f,{} x,{} a,{} s)} returns the sign of \spad{f} as \spad{x} nears \spad{a} from below if \spad{s} is "left",{} or above if \spad{s} is "right".
662995`\spad{sign(f,{} x,{} a,{} s)} returns the sign of \spad{f} as \spad{x} nears \spad{a} from the left (below) if \spad{s} is the string \spad{"left"},{} or from the right (above) if \spad{s} is the string \spad{"right"}.
663127`\spad{simpleBounds?(l)} returns \spad{true} if the list of expressions \spad{l} are simple.
663213`\spad{simplifyExp(f)} converts every product \spad{exp(a)*exp(b)} appearing in \spad{f} into \spad{exp(a+b)}.
663279`\spad{simplifyLog(f)} converts every \spad{log(a) - log(b)} appearing in \spad{f} into \spad{log(a/b)},{} every \spad{log(a) + log(b)} into \spad{log(a*b)} and every \spad{n*log(a)} into \spad{log(a^n)}.
663345`simplifyPower?(\spad{f},{}\spad{n}) \undocumented{}
663425`\spad{simplify(s)} returns a different and presumably simpler representation of \spad{s} with the defining polynomials for the equations forming a groebner basis,{} and the defining polynomial for the inequation reduced with respect to the basis,{} using a heuristic algorithm based on factoring.
663547`\spad{simplify(an)} applies simplifications to \spad{an}
663647`\spad{simplify(f)} performs the following simplifications on \spad{f:}\begin{items} \item 1. rewrites trigs and hyperbolic trigs in terms of \spad{sin} ,{}\spad{cos},{} \spad{sinh},{} \spad{cosh}. \item 2. rewrites \spad{sin**2} and \spad{sinh**2} in terms of \spad{cos} and \spad{cosh},{} \item 3. rewrites \spad{exp(a)*exp(b)} as \spad{exp(a+b)}. \item 4. rewrites \spad{(a**(1/n))**m * (a**(1/s))**t} as a single power of a single radical of
663647`-- \spad{a}. \end{items}
663710`\spad{simpson(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the simpson method to numerically integrate function \spad{fn} over the closed interval \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nmax}. 
663710`--The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
663875`\spad{simpsono(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the simpson method to numerically integrate function \spad{fn} over the open interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin} to \spad{nm
663875`--ax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
664042`\spad{sin2csc(f)} converts every \spad{sin(u)} appearing in \spad{f} into \spad{1/csc(u)}.
664105`\spad{sin?(x)} returns \spad{true} if term is a sin,{} otherwise \spad{false}
664159`\spad{sinIfCan(z)} returns sin(\spad{z}) if possible,{} and "failed" otherwise.
664240`\spad{sin(x)} makes a sin kernel for use in Fourier series
664287`\spad{sin(x)} applies the sine operator to \spad{x}
664439`\spad{sin(st)} computes sine of a power series \spad{st}.
664523`\spad{sin(st)} computes sine of a power series \spad{st}.
664621`\spad{sin(z)} returns the sine of Laurent series \spad{z}.
664708`\spad{sin(z)} returns the sine of a Puiseux series \spad{z}.
664804`\spad{sin(x)} returns the sine of \spad{x}.
664862`\spad{sin(x)} represents the Fortran intrinsic function SIN
664943`\spad{sincos(st)} returns a record containing the sine and cosine of a power series \spad{st}.
665059`\spad{singRicDE(op,{} ezfactor)} returns \spad{[[f1,{}L1],{} [f2,{}L2],{}...,{} [fk,{}Lk]]} such that the singular \spad{++} part of any rational solution of the associated Riccati equation of \spad{op y = 0} must be one of the \spad{fi}\spad{'s} (up to the constant coefficient),{} in which case the
665059`-- equation for \spad{z = y e^{-int \spad{ai}}} is \spad{\spad{Li} z = 0}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
665267`\spad{singRicDE(op,{} zeros,{} ezfactor)} returns \spad{[[f1,{} L1],{} [f2,{} L2],{} ... ,{} [fk,{} Lk]]} such that the singular part of any rational solution of the associated Riccati equation of \spad{op y=0} must be one of the \spad{fi}\spad{'s} (up to the constant coefficient),{} in which case the equation for \spad{z=y e^{-int p}} is \spad{
665267`--\spad{Li} z=0}. \spad{zeros(C(x),{}H(x,{}y))} returns all the \spad{P_i(x)}\spad{'s} such that \spad{H(x,{}P_i(x)) = 0 modulo C(x)}. Argument \spad{ezfactor} is a factorisation in \spad{UP},{} not necessarily into irreducibles.
665428`\spad{singleFactorBound(p,{}r)} returns a bound on the infinite norm of the factor of \spad{p} with smallest Bombieri\spad{'s} norm. \spad{p} shall be of degree higher or equal to 2.
665517`\spad{singleFactorBound(p,{}r)} returns a bound on the infinite norm of the factor of \spad{p} with smallest Bombieri\spad{'s} norm. \spad{r} is a lower bound for the number of factors of \spad{p}. \spad{p} shall be of degree higher or equal to 2.
665625`\spad{singular?(a)} tests whether \spad{x = a} is singular.
665696`\spad{singular?(p)} tests whether \spad{p(x) = 0} is singular.
665768`\spad{singularAtInfinity?()} tests if there is a singularity at infinity.
665848`\spad{singularitiesOf(args)} returns a list of potential singularities of the function within the given range
666049`\spad{singularitiesOf(e,{}vars,{}range)} returns a list of points (\axiomType{Doublefloat}) at which a NAG fortran version of \spad{e} will most likely produce an error. This includes those points which evaluate to 0/0.
666210`\spad{singularitiesOf(v,{}vars,{}range)} returns a list of points (\axiomType{Doublefloat}) at which a NAG fortran version of \spad{v} will most likely produce an error. This includes those points which evaluate to 0/0.
666379`\spad{sinh2csch(f)} converts every \spad{sinh(u)} appearing in \spad{f} into \spad{1/csch(u)}.
666444`\spad{sinhIfCan(z)} returns sinh(\spad{z}) if possible,{} and "failed" otherwise.
666526`\spad{sinh(x)} applies the hyperbolic sine operator to \spad{x}
666733`\spad{sinh(st)} computes the hyperbolic sine of a power series \spad{st}.
666818`\spad{sinh(st)} computes the hyperbolic sine of a power series \spad{st}.
666917`\spad{sinh(z)} returns the hyperbolic sine of Laurent series \spad{z}.
667005`\spad{sinh(z)} returns the hyperbolic sine of a Puiseux series \spad{z}.
667102`\spad{sinh(x)} returns the hyperbolic sine of \spad{x}.
667158`\spad{sinh(x)} represents the Fortran intrinsic function SINH
667240`\spad{sinhcosh(st)} returns a record containing the hyperbolic sine and cosine of a power series \spad{st}.
667660`\spad{size?(u,{}n)} tests if \spad{u} has exactly \spad{n} elements.
667778`\spad{sizeLess?(x,{}y)} tests whether \spad{x} is strictly smaller than \spad{y} with respect to the \spadfunFrom{euclideanSize}{EuclideanDomain}.
667836`\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size.
667936`\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: the time of multiplication of field elements depends on this size.
668045`\spad{sizeMultiplication()} returns the number of entries in the multiplication table of the field. Note: The time of multiplication of field elements depends on this size.
668135`\spad{sizeMultiplication(m)} returns the number of entries of the multiplication table {\em m}.
668267`\spad{sizePascalTriangle()} returns the number of entries currently stored in the table.
668615`\spad{size()} is the base of the random number generator
668666`\spad{size()} returns the number of elements in the set.
668716`\spad{size(x)} returns the number of monomials in \spad{x}.
668774`\spad{size(x)} returns the number of monomials in \spad{x}.
668833`\spad{size(l)} returns the number of monomials forming \spad{l}.
668900`\spad{size(x)} returns the number of monomials in \spad{x}.
668966`\spad{size(x)} returns the number of terms in \spad{x}. mapGen(\spad{f},{} \spad{a1}\spad{\^}\spad{e1} ... an\spad{\^}en) returns \spad{f(a1)\^e1 ... f(an)\^en}.
669042`The size of the isolating interval
669135`\spad{skewSFunction(li1,{}li2)} is the \spad{S}-function \indented{1}{of the partition difference \spad{li1 - li2}} \indented{1}{expressed in terms of power sum symmetric functions.}
669250`\spad{slash(f,{}g)} creates a form for the horizontal fraction of \spad{f} over \spad{g}.
669294`\spad{slex(ls)} sorts the argument sequence \spad{ls},{} then zips (see \spadfunFrom{map}{\spad{ListFunctions3}}) the original argument sequence with the sorted result to a list of pairs
669358`\spad{smith(m)} returns the Smith Normal form of the matrix \spad{m}.
669415`\spad{sn(x,{}k)} expands the elliptic function \spad{sn} as a Taylor \indented{1}{series.}
669499`\spad{sncndn(s,{}c)} is used internally.
669611`\spad{socf2socdf(a)} is a function to convert a \axiomType{Segment OrderedCompletion Float} to a \axiomType{Segment OrderedCompletion DoubleFloat}
669739`\spad{solid?(x)} \undocumented
669801`\spad{solid(x,{}b)} \undocumented
669870`\spad{solve1(pol,{} eps)} finds the roots of the univariate polynomial polynomial \spad{pol} to precision eps. If \spad{K} is \spad{Fraction Integer} then only the real roots are returned,{} if \spad{K} is \spad{Complex Fraction Integer} then all roots are found.
669971`\spad{solveInField(lp)} finds the solution of the list \spad{lp} of rational functions with respect to all the symbols appearing in \spad{lp}.
670093`\spad{solveInField(lp,{}lv)} finds the solutions of the list \spad{lp} of rational functions with respect to the list of symbols \spad{lv}.
670228`\spad{solveInField(m,{} v,{} solve)} returns \spad{[[v_1,{}...,{}v_m],{} v_p]} such that the solutions in \spad{F} of the system \spad{m x = v} are \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are constants,{} and the \spad{v_i's} form a basis for the solutions of \spad{m x = 0}. Argument \sp
670228`--ad{solve} is a function for solving a single linear ordinary differential equation in \spad{F}.
670428`\spad{solveLinearPolynomialEquationByFractions([f1,{} ...,{} fn],{} g)} (where the \spad{fi} are relatively prime to each other) returns a list of \spad{ai} such that \spad{g/prod \spad{fi} = sum ai/fi} or returns "failed" if no such exists.
670644`\spad{solveLinearPolynomialEquationByRecursion([p1,{}...,{}pn],{}p)} returns the list of polynomials \spad{[q1,{}...,{}qn]} such that \spad{sum qi/pi = p / prod \spad{pi}},{} a recursion step for solveLinearPolynomialEquation as defined in \spadfun{PolynomialFactorizationExplicit} 
670644`--category (see \spadfun{solveLinearPolynomialEquation}). If no such list of \spad{qi} exists,{} then "failed" is returned.
670870`\spad{solveLinearPolynomialEquationByRecursion([p1,{}...,{}pn],{}p)} returns the list of polynomials \spad{[q1,{}...,{}qn]} such that \spad{sum qi/pi = p / prod \spad{pi}},{} a recursion step for solveLinearPolynomialEquation as defined in \spadfun{PolynomialFactorizationExplicit}
670870`-- category (see \spadfun{solveLinearPolynomialEquation}). If no such list of \spad{qi} exists,{} then "failed" is returned.
671097`\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \spad{fi} are relatively prime to each other) returns a list of \spad{ai} such that \spad{g/prod \spad{fi} = sum ai/fi} or returns "failed" if no such list of \spad{ai}\spad{'s} exists.
671236`\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} where (\spad{fi} relatively prime to each other) returns a list of \spad{ai} such that \spad{g} = sum \spad{ai} prod \spad{fj} (\spad{j} \spad{\=} \spad{i}) or equivalently g/prod \spad{fj} = sum (ai/fi) or returns "failed" if n
671236`--o such list exists
671455`\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \spad{fi} are relatively prime to each other) returns a list of \spad{ai} such that \spad{g/prod \spad{fi} = sum ai/fi} or returns "failed" if no such list of \spad{ai}\spad{'s} exists.
672443`\spad{solveLinearPolynomialEquation([f1,{} ...,{} fn],{} g)} (where the \spad{fi} are relatively prime to each other) returns a list of \spad{ai} such that \spad{g/prod \spad{fi} = sum ai/fi} or returns "failed" if no such list of \spad{ai}\spad{'s} exists.
672644`\spad{solveLinear([v1,{}...,{}vn],{} u)} returns \spad{[c1,{}...,{}cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} "failed" if no such \spad{ci}\spad{'s} exist in the quotient field of \spad{S}.
672761`\spad{solveLinear([v1,{}...,{}vn],{} u)} returns \spad{[c1,{}...,{}cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} "failed" if no such \spad{ci}\spad{'s} exist in \spad{S}.
672863`\spad{solveLinearlyOverQ([v1,{}...,{}vn],{} u)} returns \spad{[c1,{}...,{}cn]} such that \spad{c1*v1 + ... + cn*vn = u},{} "failed" if no such rational numbers \spad{ci}\spad{'s} exist.
672981`\spad{solveRetract(lp,{}lv)} finds the solutions of the list \spad{lp} of rational functions with respect to the list of symbols \spad{lv}. The function tries to retract all the coefficients of the equations to \spad{Q} before solving if possible.
673116`\spad{solve(xmin,{}ymin,{}xmax,{}ymax,{}ngx,{}ngy,{}pde,{}bounds,{}st,{}tol)} is a top level ANNA function to solve numerically a system of partial differential equations. This is defined as a list of coefficients (\axiom{\spad{pde}}),{} a grid (\axiom{\spad{xmin}},{} \axiom{\spad{ymin}},{} \axiom{\sp
673116`--ad{xmax}},{} \axiom{\spad{ymax}},{} \axiom{\spad{ngx}},{} \axiom{\spad{ngy}}),{} the boundary values (\axiom{\spad{bounds}}) and a tolerance requirement (\axiom{\spad{tol}}). There is also a parameter (\axiom{\spad{st}}) which should contain the value "elliptic" if the PDE is known to be elliptic,{} or "unknown" if it is uncertain. This causes the routine to check whether the PDE is elliptic. \blankline The method used to perform the numerical process will be one of the routines contained in t
673116`--he NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine. \blankline \spad{**} At the moment,{} only Second Order Elliptic Partial Differential Equations are solved \spad{**}
673322`\spad{solve(lp)} finds the solution in the algebraic closure of \spad{R} of the list \spad{lp} of rational functions with respect to all the symbols appearing in \spad{lp}.
673437`\spad{solve(u)} \undocumented
673504`\spad{solve(eq)} finds the solutions of the equation \spad{eq} where \spad{eq} is an equation of functions of type Expression(\spad{R}) with respect to the unique symbol \spad{x} appearing in \spad{eq}.
673603`\spad{solve(eq)} finds the solutions of the equation \spad{eq} with respect to the unique variable appearing in \spad{eq}.
673723`\spad{solve(expr)} finds the solutions of the equation \spad{expr} = 0 where \spad{expr} is a function of type Expression(\spad{R}) with respect to the unique symbol \spad{x} appearing in eq.
673812`\spad{solve(p)} finds the solution of a rational function \spad{p} = 0 with respect to the unique variable appearing in \spad{p}.
673922`\spad{solve(le)} finds the solutions of the list \spad{le} of equations of rational functions with respect to all symbols appearing in \spad{le}.
674054`\spad{solve(lp)} finds the solutions of the list \spad{lp} of rational functions with respect to all symbols appearing in \spad{lp}.
674176`\spad{solve(odeProblem)} is a top level ANNA function to solve numerically a system of ordinary differential equations \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}],{} together with starting values for \spad{X} and \spad{Y}[1]..\spad{Y}[\spad{n}] (called the initial conditions),{} a final value of \spad{X},{} an accu
674176`--racy requirement and any intermediate points at which the result is required. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The fun
674176`--ction predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
674267`\spad{solve(PDEProblem)} is a top level ANNA function to solve numerically a system of partial differential equations. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE\spad{'s} and calculating a measure of compatibility of each rou
674267`--tine to these attributes. \blankline It then calls the resulting `best' routine. \blankline \spad{**} At the moment,{} only Second Order Elliptic Partial Differential Equations are solved \spad{**}
674357`\spad{solve(lp,{}lv)} finds the solutions in the algebraic closure of \spad{R} of the list \spad{lp} of rational functions with respect to the list of symbols \spad{lv}.
674485`\spad{solve(p,{}eps)} finds the real zeroes of a univariate rational polynomial \spad{p} with precision \spad{eps}.
674574`\spad{solve(p,{}eps)} finds the real zeroes of a univariate integer polynomial \spad{p} with precision \spad{eps}.
674653`\spad{solve(eq,{}x)} finds the solutions of the equation \spad{eq} where \spad{eq} is an equation of functions of type Expression(\spad{R}) with respect to the symbol \spad{x}.
674759`\spad{solve(eq,{}eps)} finds all of the real solutions of the univariate equation \spad{eq} of rational functions with respect to the unique variables appearing in \spad{eq},{} with precision \spad{eps}.
674884`\spad{solve(eq,{}v)} finds the solutions of the equation \spad{eq} with respect to the variable \spad{v}.
675011`\spad{solve(expr,{}x)} finds the solutions of the equation \spad{expr} = 0 with respect to the symbol \spad{x} where \spad{expr} is a function of type Expression(\spad{R}).
675107`\spad{solve(p,{}eps)} finds all of the real solutions of the univariate rational function \spad{p} with rational coefficients with respect to the unique variable appearing in \spad{p},{} with precision \spad{eps}.
675222`\spad{solve(p,{}v)} solves the equation \spad{p=0},{} where \spad{p} is a rational function with respect to the variable \spad{v}.
675339`\spad{solve(leqs,{} lvar)} returns a list of solutions to the list of equations \spad{leqs} with respect to the list of symbols lvar.
675463`\spad{solve(leq,{}eps)} finds all of the real solutions of the system \spad{leq} of equationas of rational functions with respect to all the variables appearing in \spad{lp},{} with precision \spad{eps}.
675600`\spad{solve(le,{}lv)} finds the solutions of the list \spad{le} of equations of rational functions with respect to the list of symbols \spad{lv}.
675745`\spad{solve(lp,{}eps)} finds all of the real solutions of the system \spad{lp} of rational functions over the rational numbers with respect to all the variables appearing in \spad{lp},{} with precision \spad{eps}.
675872`\spad{solve(lp,{}lv)} finds the solutions of the list \spad{lp} of rational functions with respect to the list of symbols \spad{lv}.
676007`\spad{solve(A,{}LB)} finds a particular soln of the systems \spad{AX = B} and a basis of the associated homogeneous systems \spad{AX = 0} where \spad{B} varies in the list of column vectors \spad{LB}.
676164`\spad{solve(A,{}B)} finds a particular solution of the system \spad{AX = B} and a basis of the associated homogeneous system \spad{AX = 0}.
676309`\spad{solve(A,{}B)} finds a particular solution of the system \spad{AX = B} and a basis of the associated homogeneous system \spad{AX = 0}.
676433`\spad{solve(A,{}LB)} finds a particular soln of the systems \spad{AX = B} and a basis of the associated homogeneous systems \spad{AX = 0} where \spad{B} varies in the list of column vectors \spad{LB}.
676569`\spad{solve(A,{}LB)} finds a particular soln of the systems \spad{AX = B} and a basis of the associated homogeneous systems \spad{AX = 0} where \spad{B} varies in the list of column vectors \spad{LB}.
676722`\spad{solve(m,{} x)} returns a basis for the solutions of \spad{D y = m y}. \spad{x} is the dependent variable.
676828`\spad{solve(A,{}B)} finds a particular solution of the system \spad{AX = B} and a basis of the associated homogeneous system \spad{AX = 0}.
676969`\spad{solve(odeProblem,{}R)} is a top level ANNA function to solve numerically a system of ordinary differential equations \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}],{} together with starting values for \spad{X} and \spad{Y}[1]..\spad{Y}[\spad{n}] (called the initial conditions),{} a final value of \
676969`--spad{X},{} an accuracy requirement and any intermediate points at which the result is required. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will 
676969`--be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
677074`\spad{solve(PDEProblem,{}routines)} is a top level ANNA function to solve numerically a system of partial differential equations. \blankline The method used to perform the numerical process will be one of the \spad{routines} contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of PDE\spad{'s} and calculating a meas
677074`--ure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine. \blankline \spad{**} At the moment,{} only Second Order Elliptic Partial Differential Equations are solved \spad{**}
677178`\spad{solve(m,{} v,{} solve)} returns \spad{[[v_1,{}...,{}v_m],{} v_p]} such that the solutions in \spad{F} of the system \spad{D x = m x + v} are \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are constants,{} and the \spad{v_i's} form a basis for the solutions of \spad{D x = m x}. Argument \spad{solve} is 
677178`--a function for solving a single linear ordinary differential equation in \spad{F}.
677364`\spad{solve(eq,{} y,{} x)} returns either a solution of the ordinary differential equation \spad{eq} or "failed" if no non-trivial solution can be found; If the equation is linear ordinary,{} a solution is of the form \spad{[h,{} [b1,{}...,{}bm]]} where \spad{h} is a particular solution and \spad{[b1,{}...bm]} are linearly independent solutions of the associated 
677364`--homogenuous equation \spad{f(x,{}y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; If the equation is of the form {dy/dx = \spad{f}(\spad{x},{}\spad{y})},{} a solution is of the form \spad{h(x,{}y)} where \spad{h(x,{}y) = c} is a first integral of the equation for any constant \spad{c}; error if the equation is not one of those 2 forms.
677507`\spad{solve(eq,{} y,{} x)} returns either a solution of the ordinary differential equation \spad{eq} or "failed" if no non-trivial solution can be found; If the equation is linear ordinary,{} a solution is of the form \spad{[h,{} [b1,{}...,{}bm]]} where \spad{h} is a particular solution and and \spad{[b1,{}...bm]} are linearly independent solutions of the associated homoge
677507`--nuous equation \spad{f(x,{}y) = 0}; A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; If the equation is of the form {dy/dx = \spad{f}(\spad{x},{}\spad{y})},{} a solution is of the form \spad{h(x,{}y)} where \spad{h(x,{}y) = c} is a first integral of the equation for any constant \spad{c}.
677640`\spad{solve(op,{} g,{} x)} returns either a solution of the ordinary differential equation \spad{op y = g} or "failed" if no non-trivial solution can be found; When found,{} the solution is returned in the form \spad{[h,{} [b1,{}...,{}bm]]} where \spad{h} is a particular solution and and \spad{[b1,{}...bm]} are linearly independent solutions of the associated homogenuous equation \sp
677640`--ad{op y = 0}. A full basis for the solutions of the homogenuous equation is not always returned,{} only the solutions which were found; \spad{x} is the dependent variable.
677762`\spad{solve([eq_1,{}...,{}eq_n],{} [y_1,{}...,{}y_n],{} x)} returns either "failed" or,{} if the equations form a fist order linear system,{} a solution of the form \spad{[y_p,{} [b_1,{}...,{}b_n]]} where \spad{h_p} is a particular solution and \spad{[b_1,{}...b_m]} are linearly independent solutions of the associated homogenuous system.
677762`-- error if the equations do not form a first order linear system
677931`\spad{solve([eq_1,{}...,{}eq_n],{} [y_1,{}...,{}y_n],{} x)} returns either "failed" or,{} if the equations form a fist order linear system,{} a solution of the form \spad{[y_p,{} [b_1,{}...,{}b_n]]} where \spad{h_p} is a particular solution and \spad{[b_1,{}...b_m]} are linearly independent solutions of the associated homogenuous system. error if 
677931`--the equations do not form a first order linear system
678090`\spad{solve(m,{} v,{} x)} returns \spad{[v_p,{} [v_1,{}...,{}v_m]]} such that the solutions of the system \spad{D y = m y + v} are \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are constants,{} and the \spad{v_i's} form a basis for the solutions of \spad{D y = m y}. \spad{x} is the dependent variable.
678241`\spad{solve(M(x,{}y),{} N(x,{}y),{} y,{} x)} returns \spad{F(x,{}y)} such that \spad{F(x,{}y) = c} for a constant \spad{c} is a first integral of the equation \spad{M(x,{}y) dx + N(x,{}y) dy = 0},{} or "failed" if no first-integral can be found.
678342`\spad{solve(eq,{} y,{} x = a,{} [y0,{}...,{}ym])} returns either the solution of the initial value problem \spad{eq,{} y(a) = y0,{} y'(a) = y1,{}...} or "failed" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \spad{dy/dx = f(x,{}y)}.
678463`\spad{solve(eq,{} y,{} x = a,{} [y0,{}...,{}ym])} returns either the solution of the initial value problem \spad{eq,{} y(a) = y0,{} y'(a) = y1,{}...} or "failed" if the solution cannot be found; error if the equation is not one linear ordinary or of the form \spad{dy/dx = f(x,{}y)}.
678574`\spad{solve(f,{}xStart,{}xEnd,{}yInitial)} is a top level ANNA function to solve numerically a system of ordinary differential equations \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}],{} together with a starting value for \spad{X} and \spad{Y}[1]..\spad{Y}[\spad{n}] (called the initial co
678574`--nditions) and a final value of \spad{X}. A default value is used for the accuracy requirement. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will b
678574`--e one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
678695`\spad{solve(op,{} g,{} x,{} a,{} [y0,{}...,{}ym])} returns either the solution of the initial value problem \spad{op y = g,{} y(a) = y0,{} y'(a) = y1,{}...} or "failed" if the solution cannot be found; \spad{x} is the dependent variable.
678794`\spad{solve(f,{}xStart,{}xEnd,{}yInitial,{}tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations,{} \axiom{\spad{f}},{} \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}] from \axiom{\spad{xStart}} to \axiom{\spad{xEnd}} with the initial val
678794`--ues for \spad{Y}[1]..\spad{Y}[\spad{n}] (\axiom{\spad{yInitial}}) to a tolerance \axiom{\spad{tol}}. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process 
678794`--will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
678921`\spad{solve(f,{}xStart,{}xEnd,{}yInitial,{}G,{}tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations,{} \axiom{\spad{f}},{} \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}] from \axiom{\spad{xStart}} to \axiom{\spad{xEnd}
678921`--} with the initial values for \spad{Y}[1]..\spad{Y}[\spad{n}] (\axiom{\spad{yInitial}}) to a tolerance \axiom{\spad{tol}}. The calculation will stop if the function \spad{G}(\spad{X},{}\spad{Y}[1],{}..,{}\spad{Y}[\spad{n}]) evaluates to zero before \spad{X} = \spad{xEnd}. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain 
678921`--of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
679066`\spad{solve(f,{}xStart,{}xEnd,{}yInitial,{}intVals,{}tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations,{} \axiom{\spad{f}},{} \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}] from \axiom{\spad{xStart}} to \axiom{\spad{xEnd}
679066`--} with the initial values for \spad{Y}[1]..\spad{Y}[\spad{n}] (\axiom{\spad{yInitial}}) to a tolerance \axiom{\spad{tol}}. The values of \spad{Y}[1]..\spad{Y}[\spad{n}] will be output for the values of \spad{X} in \axiom{\spad{intVals}}. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to
679066`-- be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
679205`\spad{solve(f,{}xStart,{}xEnd,{}yInitial,{}G,{}intVals,{}tol)} is a top level ANNA function to solve numerically a system of ordinary differential equations,{} \axiom{\spad{f}},{} \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}] from \axiom{\spad{xStart}}
679205`-- to \axiom{\spad{xEnd}} with the initial values for \spad{Y}[1]..\spad{Y}[\spad{n}] (\axiom{\spad{yInitial}}) to a tolerance \axiom{\spad{tol}}. The values of \spad{Y}[1]..\spad{Y}[\spad{n}] will be output for the values of \spad{X} in \axiom{\spad{intVals}}. The calculation will stop if the function \spad{G}(\spad{X},{}\spad{Y}[1],{}..,{}\spad{Y}[\spad{n}]) evaluates to zero before \spad{X} = \spad{xEnd}. \blankline It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquati
679205`--onsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most effective routine by checking various attributes of the system of ODE\spad{'s} and 
679205`--calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
679362`\spad{solve(f,{}xStart,{}xEnd,{}yInitial,{}G,{}intVals,{}epsabs,{}epsrel)} is a top level ANNA function to solve numerically a system of ordinary differential equations,{} \axiom{\spad{f}},{} \spadignore{i.e.} equations for the derivatives \spad{Y}[1]'..\spad{Y}[\spad{n}]' defined in terms of \spad{X},{}\spad{Y}[1]..\spad{Y}[\spad{n}] from \ax
679362`--iom{\spad{xStart}} to \axiom{\spad{xEnd}} with the initial values for \spad{Y}[1]..\spad{Y}[\spad{n}] (\axiom{\spad{yInitial}}) to an absolute error requirement \axiom{\spad{epsabs}} and relative error \axiom{\spad{epsrel}}. The values of \spad{Y}[1]..\spad{Y}[\spad{n}] will be output for the values of \spad{X} in \axiom{\spad{intVals}}. The calculation will stop if the function \spad{G}(\spad{X},{}\spad{Y}[1],{}..,{}\spad{Y}[\spad{n}]) evaluates to zero before \spad{X} = \spad{xEnd}. \blankli
679362`--ne It iterates over the \axiom{domains} of \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in the table of routines \axiom{\spad{R}} to get the name and other relevant information of the the (domain of the) numerical routine likely to be the most appropriate,{} \spadignore{i.e.} have the best \axiom{measure}. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. The function predicts the likely most eff
679362`--ective routine by checking various attributes of the system of ODE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine.
679525`\spad{solve(xmin,{}ymin,{}xmax,{}ymax,{}ngx,{}ngy,{}pde,{}bounds,{}st)} is a top level ANNA function to solve numerically a system of partial differential equations. This is defined as a list of coefficients (\axiom{\spad{pde}}),{} a grid (\axiom{\spad{xmin}},{} \axiom{\spad{ymin}},{} \axiom{\spad{xmax}},{} \axiom
679525`--{\spad{ymax}},{} \axiom{\spad{ngx}},{} \axiom{\spad{ngy}}) and the boundary values (\axiom{\spad{bounds}}). A default value for tolerance is used. There is also a parameter (\axiom{\spad{st}}) which should contain the value "elliptic" if the PDE is known to be elliptic,{} or "unknown" if it is uncertain. This causes the routine to check whether the PDE is elliptic. \blankline The method used to perform the numerical process will be one of the routines contained in the NAG numerical Library. Th
679525`--e function predicts the likely most effective routine by checking various attributes of the system of PDE\spad{'s} and calculating a measure of compatibility of each routine to these attributes. \blankline It then calls the resulting `best' routine. \blankline \spad{**} At the moment,{} only Second Order Elliptic Partial Differential Equations are solved \spad{**}
679718`\spad{solveid(h,{}table)} computes the coefficients of the extended euclidean algorithm for a list of polynomials whose tablePow is \spad{table} and with right side \spad{h}.
679809`\spad{someBasis()} returns some \spad{R}-module basis.
680033`\spad{sort!(u)} returns \spad{u} with its elements in ascending order.
680340`\spad{sort!(p,{}u)} returns \spad{u} with its elements ordered by \spad{p}.
680445`\spad{sortConstraints(args)} uses a simple bubblesort on the list of constraints using the degree of the expression
680445`-- on which to sort. Of course,{} it must match the bounds to the constraints.
680887`\spad{sort(lp)} sorts a list of permutations {\em lp} according to cycle structure first according to length of cycles,{} second,{} if \spad{S} has \spadtype{Finite} or \spad{S} has \spadtype{OrderedSet} according to lexicographical order of entries in cycles of equal length.
680943`\spad{sort(u)} returns an \spad{u} with elements in ascending order. Note: \axiom{sort(\spad{u}) = sort(\spad{<=},{}\spad{u})}.
681175`\spad{sort(p,{}a)} returns a copy of \axiom{a} sorted using total ordering predicate \spad{p}.
681244`\axiom{sort(\spad{v},{}\spad{ps})} returns \axiom{us,{}\spad{vs},{}\spad{ws}} such that \axiom{us} is \axiom{collectUnder(\spad{ps},{}\spad{v})},{} \axiom{\spad{vs}} is \axiom{collect(\spad{ps},{}\spad{v})} and \axiom{\spad{ws}} is \axiom{collectUpper(\spad{ps},{}\spad{v})}.
681521`\spad{sorted?(u)} tests if the elements of \spad{u} are in ascending order.
681818`\spad{sorted?(p,{}a)} tests if \axiom{a} is sorted according to predicate \spad{p}.
681895`\spad{space()} provides the blank character.
681933`\spad{space(l)} takes a list of draw options,{} \spad{l},{} and checks to see if it contains the option \spad{space}. If the the option doesn\spad{'t} exist,{} then an empty space is returned.
682019`\spad{space specifies} the space into which we will draw. If none is given then a new space is created.
682081`\spad{sparsityIF(m)} calculates the sparsity of a jacobian matrix
682165`\spad{specialTrigs(x,{}l)} should be local but conditional
682274`\spad{spherical(pt)} transforms \spad{pt} from spherical coordinates to Cartesian coordinates: the function produced will map the point \spad{(r,{}theta,{}phi)} to \spad{x = r*sin(phi)*cos(theta)},{} \spad{y = r*sin(phi)*sin(theta)},{} \spad{z = r*cos(phi)}.
682402`\spad{split!(u,{}n)} splits \spad{u} into two aggregates: \axiom{\spad{v} = rest(\spad{u},{}\spad{n})} and \axiom{\spad{w} = first(\spad{u},{}\spad{n})},{} returning \axiom{\spad{v}}. Note: afterwards \axiom{rest(\spad{u},{}\spad{n})} returns \axiom{empty()}.
682503`\spad{splitConstant(f,{} x)} returns \spad{[c,{} g]} such that \spad{f = c * g} and \spad{c} does not involve \spad{t}.
682598`\spad{splitDenominator([q1,{}...,{}qn])} returns \spad{[[p1,{}...,{}pn],{} d]} such that \spad{\spad{qi} = pi/d} and \spad{d} is a common denominator for the \spad{qi}\spad{'s}.
682687`\spad{splitDenominator([q1,{}...,{}qn])} returns \spad{[[p1,{}...,{}pn],{} d]} such that \spad{\spad{qi} = pi/d} and \spad{d} is a common denominator for the \spad{qi}\spad{'s}.
682769`\spad{splitDenominator(q)} returns \spad{[p,{} d]} such that \spad{q = p/d} and \spad{d} is a common denominator for the elements of \spad{q}.
682871`\spad{splitDenominator(q)} returns \spad{[p,{} d]} such that \spad{q = p/d} and \spad{d} is a common denominator for the coefficients of \spad{q}.
682976`\spad{splitDenominator(op,{} [g1,{}...,{}gm])} returns \spad{op0,{} [h1,{}...,{}hm]} such that the equations \spad{op y = c1 g1 + ... + cm gm} and \spad{op0 y = c1 h1 + ... + cm hm} have the same solutions.
683094`\spad{splitLinear(f)} splits the linear part from an expression which it returns.
683189`\axiom{splitNodeOf!(\spad{l},{}a,{}\spad{ls})} returns \axiom{a} where the children list of \axiom{\spad{l}} has been set to \axiom{[[\spad{s}]\$\% for \spad{s} in \spad{ls} | not nodeOf?(\spad{s},{}a)]}. Thus,{} if \axiom{\spad{l}} is not a node of \axiom{a},{} this latter splitting tree is unchanged.
683273`\axiom{splitNodeOf!(\spad{l},{}a,{}\spad{ls},{}sub?)} returns \axiom{a} where the children list of \axiom{\spad{l}} has been set to \axiom{[[\spad{s}]\$\% for \spad{s} in \spad{ls} | not subNodeOf?(\spad{s},{}a,{}sub?)]}. Thus,{} if \axiom{\spad{l}} is not a node of \axiom{a},{} this latter splitting tree is unchanged.
683372`\spad{splitSquarefree(p,{} D)} returns \spad{[n_1 n_2\^2 ... n_m\^m,{} s_1 s_2\^2 ... s_q\^q]} such that \spad{p = n_1 n_2\^2 ... n_m\^m s_1 s_2\^2 ... s_q\^q},{} each \spad{n_i} is normal \spad{w}.\spad{r}.\spad{t}. \spad{D} and each \spad{s_i} is special \spad{w}.\spad{r}.\spad{t} \spad{D}. \spad{D} is the derivation to use.
683496`\spad{split(u(x) + sum_{P(a)=0} Q(a,{}x))} returns \spad{u(x) + sum_{P1(a)=0} Q(a,{}x) + ... + sum_{Pn(a)=0} Q(a,{}x)} where \spad{P1},{}...,{}\spad{Pn} are the factors of \spad{P}.
683595`\spad{split(u(x) + sum_{P(a)=0} Q(a,{}x))} returns \spad{u(x) + sum_{P1(a)=0} Q(a,{}x) + ... + sum_{Pn(a)=0} Q(a,{}x)} where \spad{P1},{}...,{}\spad{Pn} are the factors of \spad{P}.
683738`\spad{split(p)} returns a prime factorisation of \spad{p} over its splitting field.
683792`\spad{split(p,{} D)} returns \spad{[n,{}s]} such that \spad{p = n s},{} all the squarefree factors of \spad{n} are normal \spad{w}.\spad{r}.\spad{t}. \spad{D},{} and \spad{s} is special \spad{w}.\spad{r}.\spad{t}. \spad{D}. \spad{D} is the derivation to use.
683886`\spad{split(aG,{} vector)} returns a subalgebra \spad{A} of all square matrix of dimension \spad{n} as a list of list of matrices,{} generated by the list of matrices \spad{aG},{} where \spad{n} denotes both the size of vector as well as the dimension of each of the square matrices. {\em V R} is an A-module in the natural way. split(\spad{aG},{} vector) then checks whether the cyclic submodule g
683886`--enerated by {\em vector} is a proper submodule of {\em V R}. If successful,{} it returns a two-element list,{} which contains first the list of the representations of the submodule,{} then the list of the representations of the factor module. If the vector generates the whole module,{} a one-element list of the old representation is given. Note: a later version this should call the other split.
683996`\spad{split(aG,{}submodule)} uses a proper \spad{submodule} of {\em R**n} to create the representations of the \spad{submodule} and of the factor module.
684114`\spad{split(x,{}b)} splits binary tree \spad{b} into two trees,{} one with elements greater than \spad{x},{} the other with elements less than \spad{x}.
684190`\spad{split(s,{}c)} returns a list of substrings delimited by character \spad{c}.
684252`\spad{split(s,{}cc)} returns a list of substrings delimited by characters in \spad{cc}.
684319`\spad{sqfrFactor(base,{}exponent)} creates a factored object with a single factor whose \spad{base} is asserted to be square-free (flag = "sqfr").
684373`\spad{sqfree(p)} returns the product of square free factors of \spad{p}
684632`\axiom{sqrt(\spad{x})} is \axiom{\spad{x} \spad{**} (1/2)}
684692`\axiom{sqrt(\spad{x})} is \axiom{\spad{x} \spad{**} (1/2)}
684742`\spad{sqrt(x)} returns the square root of \spad{x}.
684787`\axiom{sqrt(\spad{x})} is \axiom{\spad{x} \spad{**} (1/2)}
684832`\spad{sqrt(x)} represents the Fortran intrinsic function SQRT
684974`\spad{sqrt(b,{}a)} returns a square root of \spad{b}. Argument \spad{a} is a square root of \spad{b} \spad{(mod p)}.
685035`\axiom{sqrt(\spad{x},{}\spad{n})} is \axiom{\spad{x} \spad{**} (1/n)}
685232`\spad{square?(m)} returns \spad{true} if \spad{m} is a square matrix (\spadignore{i.e.} if \spad{m} has the same number of rows as columns) and \spad{false} otherwise.
685295`\spad{square?(m)} returns \spad{true} if \spad{m} is a square matrix (\spadignore{i.e.} if \spad{m} has the same number of rows as columns) and \spad{false} otherwise.
685373`\axiom{squareFreeFactors(\spad{p})} returns the square-free factors of \axiom{\spad{p}} over \axiom{\spad{R}}
685474`\axiom{squareFreeLexTriangular(base,{} norm?)} decomposes the variety associated with \axiom{base} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a re
685474`--gular set in in the output. Note that \axiom{base} needs to be a lexicographical Groebner basis of a zero-dimensional ideal. If \axiom{norm?} is \axiom{\spad{true}} then the regular sets are normalized.
685781`\spad{squareFreePart(p)} returns a polynomial which has the same irreducible factors as the univariate polynomial \spad{p},{} but each factor has multiplicity one.
686047`\spad{squareFreePart(p)} returns product of all the irreducible factors of polynomial \spad{p} each taken with multiplicity one.
686133`\spad{squareFreePart(x)} returns a product of prime factors of \spad{x} each taken with multiplicity one.
686198`\spad{squareFreePart(p,{}ts)} returns \spad{lpwt} such that \spad{lpwt.i.val} is a square-free polynomial \spad{w}.\spad{r}.\spad{t}. \spad{lpwt.i.tower},{} this polynomial being associated with \spad{p} modulo \spad{lpwt.i.tower},{} for every \spad{i}. Moreover,{} the list of the \spad{lpwt.i.tower} is a split of Kalkbrener of \spad{ts}. WARNING: This assumes that \spad{p} is a non-constant polynomi
686198`--al such that if \spad{p} is added to \spad{ts},{} then the resulting set is a regular triangular set.
686441`\spad{squareFreePolynomial(p)} returns the square-free factorization of the univariate polynomial \spad{p}.
686584`\spad{squareFreePolynomial(p)} \undocumented{}
686752`\spad{squareFreePrim(p)} compute the square free decomposition of a primitive multivariate polynomial \spad{p}.
686832`\spad{squareFree(n)} returns the square free factorization of integer \spad{n}
686906`\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \spad{p}.
686982`\spad{squareFree(p)} returns the square-free factorization of the polynomial \spad{p}. Each factor has no repeated roots,{} and the factors are pairwise relatively prime.
687061`\spad{squareFree(p)} computes the square-free factorization of the univariate polynomial \spad{p}. Each factor has no repeated roots,{} and the factors are pairwise relatively prime.
687392`\spad{squareFree(p)} returns the square-free factorization of the univariate polynomial \spad{p} with coefficients which are fractions of polynomials over \spad{R}. Each factor has no repeated roots and the factors are pairwise relatively prime.
687543`\spad{squareFree(p)} computes the square free decomposition of a multivariate polynomial \spad{p} presented as a univariate polynomial with multivariate coefficients.
687675`\spad{squareFree(ts)} returns the square-free factorization of \spad{ts}. Moreover,{} each factor is a Lazard triangular set and the decomposition is a Kalkbrener split of \spad{ts},{} which is enough here for the matter of solving zero-dimensional algeb
687675`--raic systems. WARNING: \spad{ts} is not checked to be zero-dimensional.
687929`\spad{squareFree(p)} returns the square free factorization of the polynomial \spad{p}.
688021`\spad{squareFree(x)} returns the square-free factorization of \spad{x} \spadignore{i.e.} such that the factors are pairwise relatively prime and each has multiple prime factors.
688092`\spad{squareMatrix(m)} converts a matrix of type \spadtype{Matrix} to a matrix of type \spadtype{SquareMatrix}.
688212`\spad{squareTop(m)} returns an \spad{n}-by-\spad{n} matrix consisting of the first \spad{n} rows of the \spad{m}-by-\spad{n} matrix \spad{m}. Error: if \spad{m < n}.
688272`\spad{stFunc1(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user.
688380`\spad{stFunc2(f)} is a local function exported due to compiler problem. This function is of no interest to the top-level user.
688505`\spad{stFuncN(f)} is a local function xported due to compiler problem. This function is of no interest to the top-level user.
688625`\spad{stack([x,{}y,{}...,{}z])} creates a stack with first (top) element \spad{x},{} second element \spad{y},{}...,{}and last element \spad{z}.
688669`\spad{standardBasisOfCyclicSubmodule(lm,{}v)} returns a matrix as follows. It is assumed that the size \spad{n} of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra,{} say \spad{A},{} of the algebra of all square matrices of dimension \spad{n}. {\em V R} is an \spad{A}-module in the natural way. standardBasisOfCyclicS
688669`--ubmodule(\spad{lm},{}\spad{v}) calculates a matrix whose non-zero column vectors are the \spad{R}-Basis of {\em Av} achieved in the way as described in section 6 of \spad{R}. A. Parker\spad{'s} "The Meat-Axe". Note: in contrast to {\em cyclicSubmodule},{} the result is not in echelon form.
688802`\spad{startPolynomial(p)} uses the ideas of Schoenhage\spad{'s} variant of Graeffe\spad{'s} method to construct circles which separate roots to get a good start polynomial,{} \spadignore{i.e.} one whose image under the Chinese Remainder Isomorphism has both entries of norm smaller and greater or equal to 1. In case the roots are found during internal calculations. The corresponding factors are in {
688802`--\em factors} which are otherwise 1.
688909`\axiom{startStats!(\spad{x})} initializes the statisitics process and sets the comments to display when statistics are printed
688990`\axiom{startTableGcd!(\spad{s1},{}\spad{s2},{}\spad{s3})} is an internal subroutine,{} exported only for developement.
689080`\axiom{startTableGcd!(\spad{s1},{}\spad{s2},{}\spad{s3})} is an internal subroutine,{} exported only for developement.
689180`\axiom{startTableGcd!(\spad{s1},{}\spad{s2},{}\spad{s3})} is an internal subroutine,{} exported only for developement.
689388`\axiom{startTableInvSet!(\spad{s1},{}\spad{s2},{}\spad{s3})} is an internal subroutine,{} exported only for developement.
689602`\axiom{status(\spad{n})} returns the status of the node \spad{n}.
689657`\spad{status(s)} returns \spad{true} if the quasi-algebraic set is empty,{} \spad{false} if it is not,{} and "failed" if not yet known
689746`\spad{stiffnessAndStabilityFactor(me)} calculates the stability and stiffness factor of a system of first-order differential equations (by evaluating the maximum difference in the real parts of the negative eigenvalues of the jacobian of the system for which \spad{O}(10) equates to mildly stiff wheras stiffness ratios of \spad{O}(10^6) are not uncommon) and w
689746`--hether the system is likely to show any oscillations (identified by the closeness to the imaginary axis of the complex eigenvalues of the jacobian).
689893`\spad{stiffnessAndStabilityOfODEIF(ode)} calculates the intensity values of stiffness of a system of first-order differential equations (by evaluating the maximum difference in the real parts of the n
689893`--egative eigenvalues of the jacobian of the system for which \spad{O}(10) equates to mildly stiff wheras stiffness ratios of \spad{O}(10^6) are not uncommon) and whether the system is likely to show any oscillations (identified by the closeness to the imaginary axis of the complex eigenvalues of the jacobian). \blankline It returns two values in the range [0,{}1].
690201`\spad{stirling1(n,{}m)} returns the Stirling number of the first kind denoted \spad{S[n,{}m]}.
690267`\spad{stirling2(n,{}m)} returns the Stirling number of the second kind denoted \spad{SS[n,{}m]}.
690333`\spad{stopMusserTrials()} returns the bound on the number of factors for which \spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \spad{2**stopMusserTrials()} trials.
690411`\spad{stopMusserTrials(n)} sets to \spad{n} the bound on the number of factors for which \spadfun{modularFactor} stops to look for an other prime. You will have to remember that the step of recombining the extraneous factors may take up to \spad{2**n} trials. Returns the previous value.
690504`\axiom{stopTableGcd!()} is an internal subroutine,{} exported only for developement.
690573`\axiom{stopTableGcd!()} is an internal subroutine,{} exported only for developement.
690652`\axiom{stopTableGcd!()} is an internal subroutine,{} exported only for developement.
690818`\axiom{stopTableInvSet!()} is an internal subroutine,{} exported only for developement.
690990`\spad{stop()} creates a representation of a STOP statement.
692621`\spad{string?(s)} is \spad{true} if \spad{s} is an atom and belong to \spad{Str}.
692700`\spad{string(f)} creates \spad{f} with string quotes.
692742`\spad{string(i)} returns the decimal representation of \spad{i} in a string
692793`\spad{string(s)} returns \spad{s} as an element of \spad{Str}. Error: if \spad{s} is not an atom that also belongs to \spad{Str}.
692867`\spad{string(s)} converts the symbol \spad{s} to a string. Error: if the symbol is subscripted.
692909`\spad{stripCommentsAndBlanks(s)} treats \spad{s} as a piece of AXIOM input,{} and removes comments,{} and leading and trailing blanks.
692982`\spad{strongGenerators(gp)} returns strong generators for the group {\em gp}.
693128`\axiom{stronglyReduce(\spad{p},{}\spad{ts})} returns a polynomial \axiom{\spad{r}} such that \axiom{stronglyReduced?(\spad{r},{}\spad{ts})} holds and there exists some product \axiom{\spad{h}} of \axiom{initials(\spad{ts})} such that \axiom{\spad{h*p} - \spad{r}} lies in the ideal generated by \axiom{\spad{ts}}.
693272`\axiom{stronglyReduced?(\spad{ts})} returns \spad{true} iff every element of \axiom{\spad{ts}} is reduced \spad{w}.\spad{r}.\spad{t} to any other element of \axiom{\spad{ts}}.
693424`\axiom{stronglyReduced?(\spad{p},{}\spad{ts})} returns \spad{true} iff \axiom{\spad{p}} is reduced \spad{w}.\spad{r}.\spad{t}. \axiom{\spad{ts}}.
693503`\spad{structuralConstants()} calculates the structural constants \spad{[(gammaijk) for k in 1..rank()]} defined by \spad{\spad{vi} * vj = gammaij1 * v1 + ... + gammaijn * vn},{} where \spad{v1},{}...,{}\spad{vn} is the fixed \spad{R}-module basis.
693594`\spad{structuralConstants()} calculates the structural constants \spad{[(gammaijk) for k in 1..rank()]} defined by \spad{\spad{vi} * vj = gammaij1 * v1 + ... + gammaijn * vn},{} where \spad{v1},{}...,{}\spad{vn} is the fixed \spad{R}-module basis.
693874`\spad{structuralConstants(basis)} takes the \spad{basis} of a matrix algebra,{} \spadignore{e.g.} the result of \spadfun{basisOfCentroid} and calculates the structural constants. Note,{} that the it is not checked,{} whether \spad{basis} really is a \spad{basis} of a matrix algebra.
693976`\spad{structuralConstants([v1,{}v2,{}...,{}vm])} calculates the structural constants \spad{[(gammaijk) for k in 1..m]} defined by \spad{\spad{vi} * vj = gammaij1 * v1 + ... + gammaijm * vm},{} where \spad{[v1,{}...,{}vm]} is an \spad{R}-module basis of a subalgebra.
694078`\spad{structuralConstants(ls,{}mt)} determines the structural constants of an algebra with generators \spad{ls} and multiplication table \spad{mt},{} the entries of which must be given as linear polynomials in the indeterminates given by \spad{ls}. The result is in particular useful \indented{1}{as fourth argument for \spadtype{AlgebraGivenByStructuralC
694078`--onstants}} \indented{1}{and \spadtype{GenericNonAssociativeAlgebra}.}
694231`\spad{structuralConstants(ls,{}mt)} determines the structural constants of an algebra with generators \spad{ls} and multiplication table \spad{mt},{} the entries of which must be given as linear polynomials in the indeterminates given by \spad{ls}. The result is in particular useful \indented{1}{as fourth argument for \spadtype{AlgebraGivenByStructuralConstants}} \indented
694231`--{1}{and \spadtype{GenericNonAssociativeAlgebra}.}
694364`\spad{sts2stst(v,{}s)} is used internally.
694476`\axiom{sturmSequence(\spad{p}) = sylvesterSequence(\spad{p},{}\spad{p'})}
694579`\axiom{sturmVariationsOf(\spad{l})} is the number of sign variations in the list of numbers \spad{l},{} note that the first term counts as a sign
694723`\spad{style(s)} specifies the drawing style in which the graph will be plotted by the indicated string \spad{s}. This option is expressed in the form \spad{style == s}.
694768`\spad{style(l,{}s)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{style}. If the option does not exist the value,{} \spad{s} is returned.
694844`\axiom{subCase?(\spad{lpwt1},{}\spad{lpwt2})} is an internal subroutine,{} exported only for developement.
694971`\axiom{subCase?(\spad{lpwt1},{}\spad{lpwt2})} is an internal subroutine,{} exported only for developement.
695108`\spad{subHeight(f)} returns the height of form \spad{f} below the base line.
695245`\spad{subMatrix(x,{}i1,{}i2,{}j1,{}j2)} extracts the submatrix \spad{[x(i,{}j)]} where the index \spad{i} ranges from \spad{i1} to \spad{i2} and the index \spad{j} ranges from \spad{j1} to \spad{j2}.
695337`\axiom{subNode?(\spad{n1},{}\spad{n2},{}\spad{o2})} returns \spad{true} iff \axiom{value(\spad{n1}) = value(\spad{n2})} and \axiom{\spad{o2}(condition(\spad{n1}),{}condition(\spad{n2}))}
695412`\axiom{subNodeOf?(\spad{s},{}a,{}sub?)} returns \spad{true} iff for some node \axiom{\spad{n}} in \axiom{a} we have \axiom{\spad{s} = \spad{n}} or \axiom{status(\spad{n})} and \axiom{subNode?(\spad{s},{}\spad{n},{}sub?)}.
695505`\axiom{subPolSet?(\spad{lp1},{}\spad{lp2})} returns \spad{true} iff \axiom{\spad{lp1}} is a sub-set of \axiom{\spad{lp2}}.
695592`\axiom{subPolSet?(\spad{lp1},{}\spad{lp2})} returns \spad{true} iff \axiom{\spad{lp1}} is a sub-set of \axiom{\spad{lp2}}.
695689`\axiom{subQuasiComponent?(\spad{ts},{}lus)} returns \spad{true} iff \axiom{subQuasiComponent?(\spad{ts},{}us)} holds for one \spad{us} in \spad{lus}.
695780`\axiom{subQuasiComponent?(\spad{ts},{}lus)} returns \spad{true} iff \axiom{subQuasiComponent?(\spad{ts},{}us)} holds for one \spad{us} in \spad{lus}.
695881`\axiom{subQuasiComponent?(\spad{ts},{}us)} returns \spad{true} iff \axiomOpFrom{internalSubQuasiComponent?}{QuasiComponentPackage} returs \spad{true}.
695966`\axiom{subQuasiComponent?(\spad{ts},{}us)} returns \spad{true} iff \axiomOpFrom{internalSubQuasiComponent?(\spad{ts},{}us)}{QuasiComponentPackage} returs \spad{true}.
696061`\axiom{subResultantChain(a,{}\spad{b})},{} where \axiom{a} and \axiom{\spad{b}} are not contant polynomials with the same main variable,{} returns the subresultant chain of \axiom{a} and \axiom{\spad{b}}.
696168`\axiom{subResultantGcdEuclidean(\spad{P},{}\spad{Q})} carries out the equality \axiom{coef1*P + coef2*Q = \spad{+/-} S_i(\spad{P},{}\spad{Q})} where the degree (not the indice) of the subresultant \axiom{S_i(\spad{P},{}\spad{Q})} is the smaller as possible.
696292`\axiom{subResultantGcd(\spad{P},{} \spad{Q})} returns the \spad{gcd} of two primitive polynomials \axiom{\spad{P}} and \axiom{\spad{Q}}.
696373`\axiom{subResultantGcd(a,{}\spad{b})} computes a \spad{gcd} of \axiom{a} and \axiom{\spad{b}} where \axiom{a} and \axiom{\spad{b}} are assumed to have the same main variable \axiom{\spad{v}} and are viewed as univariate polynomials in \axiom{\spad{v}} with coefficients in the fraction field of the polynomial ring generated by their other variables over \axiom{\spad{R}}.
696472`\spad{subResultantGcd(p,{}q)} computes the \spad{gcd} of the polynomials \spad{p} and \spad{q} using the SubResultant \spad{GCD} algorithm.
696568`\axiom{subResultantsChain(a,{}\spad{b})} returns the list of the non-zero sub-resultants of \axiom{a} and \axiom{\spad{b}} sorted by increasing degree.
696674`\spad{subSet(n,{}m,{}k)} calculates the {\em k}\spad{-}th {\em m}-subset of the set {\em 0,{}1,{}...,{}(n-1)} in the lexicographic order considered as a decreasing map from {\em 0,{}...,{}(m-1)} into {\em 0,{}...,{}(n-1)}. See \spad{S}.\spad{G}. Williamson: Theorem 1.60. Error: if not {\em (0 <= m <= n and 0 < = k < (n choose m))}.
696773`\axiom{subTriSet?(\spad{ts},{}us)} returns \spad{true} iff \axiom{\spad{ts}} is a sub-set of \axiom{us}.
696850`\axiom{subTriSet?(\spad{ts},{}us)} returns \spad{true} iff \axiom{\spad{ts}} is a sub-set of \axiom{us}.
696937`\spad{sub(f,{}n)} creates a form for \spad{f} subscripted by \spad{n}.
696979`\spad{submod(a,{}b,{}p)},{} \spad{0<=a,{}b<p>1},{} means \spad{a-b mod p}.
697036`\spad{subresultantSequence(p1,{}p2)} computes the (standard) subresultant sequence of \spad{p1} and \spad{p2}
697184`\spad{subresultantVector(p,{} q)} returns \spad{[p0,{}...,{}pn]} where \spad{pi} is the \spad{i}-th subresultant of \spad{p} and \spad{q}. In particular,{} \spad{p0 = resultant(p,{} q)}.
697272`\spad{subscript(s,{} [a1,{}...,{}an])} returns \spad{s} subscripted by \spad{[a1,{}...,{}an]}.
697330`\spad{subscriptedVariables(e)} \undocumented{}
697491`\spad{subset?(u,{}v)} tests if \spad{u} is a subset of \spad{v}. Note: equivalent to \axiom{reduce(and,{}{member?(\spad{x},{}\spad{v}) for \spad{x} in \spad{u}},{}\spad{true},{}\spad{false})}.
697547`\spad{subspace()} \undocumented
697592`\spad{subspace(s)} returns the \spadtype{SubSpace} which holds all the point information in the \spadtype{ThreeSpace},{} \spad{s}.
697658`\spad{subspace(v)} returns the contents of the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport},{} as a subspace of the domain \spad{ThreeSpace}.
697737`\spad{subspace(v,{}sp)} places the contents of the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport},{} in the subspace \spad{sp},{} which is of the domain \spad{ThreeSpace}.
698047`\spad{subst(f,{} k = g)} replaces the kernel \spad{k} by \spad{g} formally in \spad{f}.
698106`\spad{subst(f,{} [k1 = g1,{}...,{}kn = gn])} replaces the kernels \spad{k1},{}...,{}\spad{kn} by \spad{g1},{}...,{}\spad{gn} formally in \spad{f}.
698171`\spad{subst(eq1,{}eq2)} substitutes \spad{eq2} into both sides of \spad{eq1} the \spad{lhs} of \spad{eq2} should be a kernel
698370`\spad{subst(f,{} [k1...,{}kn],{} [g1,{}...,{}gn])} replaces the kernels \spad{k1},{}...,{}\spad{kn} by \spad{g1},{}...,{}\spad{gn} formally in \spad{f}.
698442`\spad{substitute(x,{}y,{}d)} replace \spad{x}\spad{'s} with \spad{y}\spad{'s} in dictionary \spad{d}.
698504`\spad{substring?(s,{}t,{}i)} tests if \spad{s} is a substring of \spad{t} beginning at index \spad{i}. Note: \axiom{substring?(\spad{s},{}\spad{t},{}0) = prefix?(\spad{s},{}\spad{t})}.
698636`\spad{subtractIfCan(x,{} y)} returns an element \spad{z} such that \spad{z+y=x} or "failed" if no such element exists.
698719`\spad{suchThat(p,{} f)} makes a copy of \spad{p} and adds the predicate \spad{f} to the copy,{} which is returned.
698804`\spad{suchThat(p,{} [f1,{}...,{}fn])} makes a copy of \spad{p} and adds the predicate \spad{f1} and ... and \spad{fn} to the copy,{} which is returned.
698895`\spad{suchThat(x,{} foo)} attaches the predicate foo to \spad{x}; error if \spad{x} is not a symbol.
698976`\spad{suchThat(x,{} [f1,{} f2,{} ...,{} fn])} attaches the predicate \spad{f1} and \spad{f2} and ... and \spad{fn} to \spad{x}. Error: if \spad{x} is not a symbol.
699063`\spad{suchThat(x,{} foo)} attaches the predicate foo to \spad{x}.
699150`\spad{suchThat(x,{} [f1,{} f2,{} ...,{} fn])} attaches the predicate \spad{f1} and \spad{f2} and ... and \spad{fn} to \spad{x}.
699243`\spad{suchThat(p,{} [a1,{}...,{}an],{} f)} returns a copy of \spad{p} with the top-level predicate set to \spad{f(a1,{}...,{}an)}.
699347`\spad{suchThat(r,{} [a1,{}...,{}an],{} f)} returns the rewrite rule \spad{r} with the predicate \spad{f(a1,{}...,{}an)} attached to it.
699434`\spad{suffix?(s,{}t)} tests if the string \spad{s} is the final substring of \spad{t}. Note: \axiom{suffix?(\spad{s},{}\spad{t}) \spad{==} reduce(and,{}[\spad{s}.\spad{i} = \spad{t}.(\spad{n} - \spad{m} + \spad{i}) for \spad{i} in 0..maxIndex \spad{s}])} where \spad{m} and \spad{n} denote the maxIndex of \spad{s} and \spad{t} respectively.
699490`\spad{sumOfDivisors(n)} returns the sum of the integers between 1 and \spad{n} (inclusive) which divide \spad{n}. The sum of the divisors of \spad{n} is often denoted by \spad{sigma(n)}.
699567`\spad{sumOfKthPowerDivisors(n,{}k)} returns the sum of the \spad{k}th powers of the integers between 1 and \spad{n} (inclusive) which divide \spad{n}. the sum of the \spad{k}th powers of the divisors of \spad{n} is often denoted by \spad{sigma_k(n)}.
699671`\spad{sumOfSquares(f)} returns either an expression for which the square is the original function of "failed".
699783`\spad{sumSquares(p)} construct \spad{a} and \spad{b} such that \spad{a**2+b**2} is equal to the integer prime \spad{p},{} and otherwise returns an error. It will succeed if the prime number \spad{p} is 2 or congruent to 1 mod 4.
699863`\spad{sum(expr)} creates the form prefixing \spad{expr} by a capital sigma.
699902`\spad{sum(p(n),{} n)} returns \spad{P(n)},{} the indefinite sum of \spad{p(n)} with respect to upward difference on \spad{n},{} \spadignore{i.e.} \spad{P(n+1) - P(n) = a(n)}.
699976`\spad{sum(expr,{}lowerlimit)} creates the form prefixing \spad{expr} by a capital sigma with a \spad{lowerlimit}.
700018`\spad{sum(f(n),{} n = a..b)} returns \spad{f}(a) + \spad{f}(\spad{a+1}) + ... + \spad{f}(\spad{b}).
700084`\spad{sum(a(n),{} n)} returns A(\spad{n}) such that A(\spad{n+1}) - A(\spad{n}) = a(\spad{n}).
700139`\spad{sum(f(n),{} n = a..b)} returns \spad{f(a) + f(a+1) + ... f(b)}.
700293`\spad{sum(a(n),{} n)} returns \spad{A} which is the indefinite sum of \spad{a} with respect to upward difference on \spad{n},{} \spadignore{i.e.} \spad{A(n+1) - A(n) = a(n)}.
700414`\spad{sum(f(n),{} n = a..b)} returns \spad{f(a) + f(a+1) + ... f(b)}.
700527`\spad{sum(a(n),{} n)} returns \spad{A} which is the indefinite sum of \spad{a} with respect to upward difference on \spad{n},{} \spadignore{i.e.} \spad{A(n+1) - A(n) = a(n)}.
700617`\spad{sum(p(n),{} n = a..b)} returns \spad{p(a) + p(a+1) + ... + p(b)}.
700702`\spad{sum(expr,{}lowerlimit,{}upperlimit)} creates the form prefixing \spad{expr} by a capital sigma with both a \spad{lowerlimit} and \spad{upperlimit}.
700747`\spad{summation(f(n),{} n = a..b)} returns \spad{f}(a) + ... + \spad{f}(\spad{b}) as a formal sum.
700824`\spad{summation(f(n),{} n)} returns the formal sum \spad{S}(\spad{n}) which verifies \spad{S}(\spad{n+1}) - \spad{S}(\spad{n}) = \spad{f}(\spad{n}).
700890`\spad{summation(f(n),{} n = a..b)} returns \spad{f}(a) + ... + \spad{f}(\spad{b}) as a formal sum.
700968`\spad{summation(f(n),{} n)} returns the formal sum \spad{S}(\spad{n}) which verifies \spad{S}(\spad{n+1}) - \spad{S}(\spad{n}) = \spad{f}(\spad{n}).
701034`\axiom{supDimElseRittWu(\spad{ts},{}us)} returns \spad{true} iff \axiom{\spad{ts}} has less elements than \axiom{us} otherwise if \axiom{\spad{ts}} has higher rank than \axiom{us} \spad{w}.\spad{r}.\spad{t}. Riit and Wu ordering.
701118`\axiom{supDimElseRittWu(\spad{ts},{}us)} returns \spad{true} iff \axiom{\spad{ts}} has less elements than \axiom{us} otherwise if \axiom{\spad{ts}} has higher rank than \axiom{us} \spad{w}.\spad{r}.\spad{t}. Riit and Wu ordering.
701285`\axiom{supRittWu?(a,{}\spad{b})} returns \spad{true} if \axiom{a} is greater than \axiom{\spad{b}} \spad{w}.\spad{r}.\spad{t}. the Ritt and Wu Wen Tsun ordering using the refinement of Lazard.
701363`\spad{sup(u)} returns the supremum of \axiom{\spad{u}}.
701410`\spad{sup(x,{}y)} returns the least element from which both \spad{x} and \spad{y} can be subtracted.
701465`\spad{superHeight(f)} returns the height of form \spad{f} above the base line.
701517`\spad{super(f,{}n)} creates a form for \spad{f} superscripted by \spad{n}.
701561`\spad{superscript(s,{} [a1,{}...,{}an])} returns \spad{s} superscripted by \spad{[a1,{}...,{}an]}.
701621`\spad{supersub(a,{}[sub1,{}super1,{}sub2,{}super2,{}...])} creates a form with each subscript aligned under each superscript.
701674`\spad{surface(c1,{}c2,{}c3)} creates a surface from 3 parametric component functions \spad{c1},{} \spad{c2},{} and \spad{c3}.
701864`\spad{swap!(u,{}i,{}j)} interchanges elements \spad{i} and \spad{j} of aggregate \spad{u}. No meaningful value is returned.
702047`\spad{swapColumns!(m,{}i,{}j)} interchanges the \spad{i}th and \spad{j}th columns of \spad{m}. This destructively alters the matrix.
702197`\spad{swapRows!(m,{}i,{}j)} interchanges the \spad{i}th and \spad{j}th rows of \spad{m}. This destructively alters the matrix.
702273`\spad{swap(p(x,{}y))} returns \spad{p}(\spad{y},{}\spad{x}).
702353`\spad{swap(eq)} interchanges left and right hand side of equation \spad{eq}.
702394`\spad{sylvesterMatrix(p,{}q)} returns the Sylvester matrix for the two polynomials \spad{p} and \spad{q}.
702465`\axiom{sylvesterSequence(\spad{p},{}\spad{q})} is the negated remainder sequence of \spad{p} and \spad{q} divided by the last computed term
702580`\spad{symFunc([r1,{}...,{}rn])} returns the vector of the elementary symmetric functions in the \spad{\spad{ri}'s}: \spad{[r1 + ... + rn,{} r1 r2 + ... + r(n-1) rn,{} ...,{} r1 r2 ... rn]}.
702646`\spad{symFunc(r,{} n)} returns the vector of the elementary symmetric functions in \spad{[r,{}r,{}...,{}r]} \spad{n} times.
702722`\spad{symbol?(p)} tests if \spad{p} is a symbol.
702770`\spad{symbol?(s)} is \spad{true} if \spad{s} is an atom and belong to \spad{Sym}.
702849`\spad{symbolIfCan(k)} returns \spad{k} viewed as a symbol if \spad{k} is a symbol,{} and "failed" otherwise.
702915`\spad{symbolTableOf(f,{}tab)} returns the symbol table of \spad{f}
702984`\spad{symbolTable(l)} creates a symbol table from the elements of \spad{l}.
703072`\spad{symbol(s)} returns \spad{s} as an element of \spad{Sym}. Error: if \spad{s} is not an atom that also belongs to \spad{Sym}.
703285`\spad{symmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and symmetric (\spadignore{i.e.} \spad{m[i,{}j] = m[j,{}i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.
703351`\spad{symmetric?(m)} returns \spad{true} if the matrix \spad{m} is square and symmetric (\spadignore{i.e.} \spad{m[i,{}j] = m[j,{}i]} for all \spad{i} and \spad{j}) and \spad{false} otherwise.
703552`\spad{symmetricDifference(u,{}v)} returns the set aggregate of elements \spad{x} which are members of set aggregate \spad{u} or set aggregate \spad{v} but not both. If \spad{u} and \spad{v} have no elements in common,{} \axiom{symmetricDifference(\spad{u},{}\spad{v})} returns a copy of \spad{u}. Note: \axiom{symmetricDifference(\spad{u},{}\spad{v}) = union(difference(\spad{u},{}\spad{v}),{}difference(\spad{v},{}\spad{u}))}
703615`\spad{symmetricGroup(\spad{li})} constructs the symmetric group acting on the integers in the list {\em \spad{li}},{} generators are the cycle given by {\em \spad{li}} and the 2-cycle {\em (\spad{li}.1,{}\spad{li}.2)}. Note: duplicates in the list will be removed.
703713`\spad{symmetricGroup(n)} constructs the symmetric group {\em Sn} acting on the integers 1,{}...,{}\spad{n},{} generators are the {\em n}-cycle {\em (1,{}...,{}n)} and the 2-cycle {\em (1,{}2)}.
703813`\spad{symmetricPower(a,{}n)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the products of \spad{n} solutions of \spad{a}.
703929`\spad{symmetricPower(a,{}n,{}D)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the products of \spad{n} solutions of \spad{a}. \spad{D} is the derivation to use.
704036`\spad{symmetricProduct(a,{}b)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the products of a solution of \spad{a} by a solution of \spad{b}.
704138`\spad{symmetricProduct(a,{}b,{}D)} computes an operator \spad{c} of minimal order such that the nullspace of \spad{c} is generated by all the products of a solution of \spad{a} by a solution of \spad{b}. \spad{D} is the derivation to use.
704291`\spad{symmetricRemainder(a,{}b)} (where \spad{b > 1}) yields \spad{r} where \spad{ -b/2 <= r < b/2 }.
704438`\spad{symmetricSquare(a)} computes \spad{symmetricProduct(a,{}a)} using a more efficient method.
704536`\spad{symmetricTensors(la,{}n)} applies to each \spad{m}-by-\spad{m} square matrix in the list {\em la} the irreducible,{} polynomial representation of the general linear group {\em GLm} which corresponds to the partition {\em (n,{}0,{}...,{}0)} of \spad{n}. Error: if the matrices in {\em la} are not square matrices. Note: this corresponds to the symmetrization of the representation with the triv
704536`--ial representation of the symmetric group {\em Sn}. The carrier spaces of the representation are the symmetric tensors of the \spad{n}-fold tensor product.
704645`\spad{symmetricTensors(a,{}n)} applies to the \spad{m}-by-\spad{m} square matrix {\em a} the irreducible,{} polynomial representation of the general linear group {\em GLm} which corresponds to the partition {\em (n,{}0,{}...,{}0)} of \spad{n}. Error: if {\em a} is not a square matrix. Note: this corresponds to the symmetrization of the representation with the trivial representation of the symmetric group {\e
704645`--m Sn}. The carrier spaces of the representation are the symmetric tensors of the \spad{n}-fold tensor product.
704742`\spad{systemCommand(cmd)} takes the string \spadvar{\spad{cmd}} and passes it to the runtime environment for execution as a system command. Although various things may be printed,{} no usable value is returned.
704805`\spad{systemSizeIF(ode)} returns the intensity value of the size of the system of ODEs. 20 equations corresponds to the neutral value. It returns a value in the range [0,{}1].
705051`\spad{tRange(p)} returns the range of the parameter in a parametric plot \spad{p}.
705107`\spad{tRange(p)} returns the range of the parameter in a parametric plot \spad{p}
705161`\spad{tValues(p)} returns a list of lists of the values of the parameter for which a point is computed,{} one list for each curve in the plot \spad{p}.
705221`\spad{t(n)} \undocumented
705295`\spad{tab1(lp)} creates a tableau from a list of pairs \spad{lp}
705371`\spad{tab(ls)} creates a tableau from \spad{ls} by first creating a list of pairs using \spadfunFrom{slex}{TableauBumpers},{} then creating a tableau using \spadfunFrom{\spad{tab1}}{TableauBumpers}.
705437`\spad{tableForDiscreteLogarithm(a,{}n)} returns a table of the discrete logarithms of \spad{a**0} up to \spad{a**(n-1)} which,{} called with key \spad{lookup(a**i)} returns \spad{i} for \spad{i} in \spad{0..n-1}. Error: if not called for prime divisors of order of \indented{7}{multiplicative group.}
705551`\spad{tablePow(maxdeg,{}prime,{}lpol)} constructs the table with the coefficients of the Extended Euclidean Algorithm for \spad{lpol}. Here the right side is \spad{x**k},{} for \spad{k} less or equal to \spad{maxdeg}. The operation returns "failed" when the elements are not coprime modulo \spad{prime}.
705709`\spad{table()}\$\spad{T} creates an empty table of type \spad{T}.
705846`\spad{table([x,{}y,{}...,{}z])} creates a table consisting of entries \axiom{\spad{x},{}\spad{y},{}...,{}\spad{z}}.
705933`\spad{tableau(ll)} converts a list of lists \spad{ll} to a tableau.
706144`\spad{tail(l)} returns the doubly-linked aggregate \spad{l} starting at its second element. Error: if \spad{l} is empty.
706198`\axiom{tail(\spad{p})} returns its reductum,{} where \axiom{\spad{p}} is viewed as a univariate polynomial in its main variable.
706262`\spad{tail(u)} returns the last node of \spad{u}. Note: if \spad{u} is \axiom{shallowlyMutable},{} \axiom{setrest(tail(\spad{u}),{}\spad{v}) = concat(\spad{u},{}\spad{v})}.
706318`\spad{tan2cot(f)} converts every \spad{tan(u)} appearing in \spad{f} into \spad{1/cot(u)}.
706381`\spad{tan2trig(f)} converts every \spad{tan(u)} appearing in \spad{f} into \spad{sin(u)/cos(u)}.
706445`\spad{tanAn(a,{} n)} returns \spad{P(x)} such that if \spad{a = tan(u)} then \spad{P(tan(u/n)) = 0}.
706538`\spad{tanIfCan(z)} returns tan(\spad{z}) if possible,{} and "failed" otherwise.
706619`\spad{tanNa(a,{} n)} returns \spad{f(a)} such that if \spad{a = tan(u)} then \spad{f(a) = tan(n * u)}.
706676`\spad{tanQ(q,{}a)} is a local function with a conditional implementation.
706761`\spad{tanSum([a1,{}...,{}an])} returns \spad{f(a1,{}...,{}an)} such that if \spad{\spad{ai} = tan(\spad{ui})} then \spad{f(a1,{}...,{}an) = tan(u1 + ... + un)}.
706817`\spad{tan(x)} applies the tangent operator to \spad{x}
707023`\spad{tan(st)} computes tangent of a power series \spad{st}.
707107`\spad{tan(st)} computes tangent of a power series \spad{st}.
707205`\spad{tan(z)} returns the tangent of Laurent series \spad{z}.
707292`\spad{tan(z)} returns the tangent of a Puiseux series \spad{z}.
707388`\spad{tan(x)} returns the tangent of \spad{x}.
707446`\spad{tan(x)} represents the Fortran intrinsic function TAN
707527`\spad{tanh2coth(f)} converts every \spad{tanh(u)} appearing in \spad{f} into \spad{1/coth(u)}.
707592`\spad{tanh2trigh(f)} converts every \spad{tanh(u)} appearing in \spad{f} into \spad{sinh(u)/cosh(u)}.
707658`\spad{tanhIfCan(z)} returns tanh(\spad{z}) if possible,{} and "failed" otherwise.
707740`\spad{tanh(x)} applies the hyperbolic tangent operator to \spad{x}
707947`\spad{tanh(st)} computes the hyperbolic tangent of a power series \spad{st}.
708032`\spad{tanh(st)} computes the hyperbolic tangent of a power series \spad{st}.
708131`\spad{tanh(z)} returns the hyperbolic tangent of Laurent series \spad{z}.
708219`\spad{tanh(z)} returns the hyperbolic tangent of a Puiseux series \spad{z}.
708316`\spad{tanh(x)} returns the hyperbolic tangent of \spad{x}.
708372`\spad{tanh(x)} represents the Fortran intrinsic function TANH
708454`\spad{tanintegrate(f,{} ',{} foo)} returns \spad{[g,{} a]} such that \spad{f = g' + a},{} and \spad{a = 0} or \spad{a} has no integral in \spad{F}; Argument foo is a Risch differential system solver on \spad{F}.
708630`\spad{taylorIfCan(f(x))} converts the Laurent series \spad{f(x)} to a Taylor series,{} if possible. If this is not possible,{} "failed" is returned.
708736`\spad{taylorQuoByVar(a0 + a1 x + a2 x**2 + ...)} returns \spad{a1 + a2 x + a3 x**2 + ...}
708814`\spad{taylorRep(f(x))} returns \spad{g(x)},{} where \spad{f = x**n * g(x)} is represented by \spad{[n,{}g(x)]}.
708902`\spad{taylor(f)} returns a Taylor expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable.
708974`\spad{taylor(x)} returns \spad{x} viewed as a Taylor series.
709050`\spad{taylor(f(x))} converts the Laurent series \spad{f}(\spad{x}) to a Taylor series,{} if possible. Error: if this is not possible.
709135`\spad{taylor(n +-> a(n),{}x = a)} returns \spad{sum(n = 0..,{}a(n)*(x-a)**n)}.
709227`\spad{taylor(f,{}x = a)} expands the expression \spad{f} as a Taylor series in powers of \spad{(x - a)}.
709312`\spad{taylor(f,{}n)} returns a Taylor expansion of the expression \spad{f}. Note: \spad{f} should have only one variable; the series will be expanded in powers of that variable and terms will be computed up to order at least \spad{n}.
709403`\spad{taylor(n +-> a(n),{}x = a,{}n0..)} returns \spad{sum(n=n0..,{}a(n)*(x-a)**n)}; \spad{taylor(n +-> a(n),{}x = a,{}n0..n1)} returns \spad{sum(n = n0..,{}a(n)*(x-a)**n)}.
709532`\spad{taylor(f,{}x = a)} expands the expression \spad{f} as a Taylor series in powers of \spad{(x - a)}; terms will be computed up to order at least \spad{n}.
709636`\spad{taylor(a(n),{}n,{}x = a)} returns \spad{sum(n = 0..,{}a(n)*(x-a)**n)}.
709724`\spad{taylor(a(n),{}n,{}x = a,{}n0..)} returns \spad{sum(n = n0..,{}a(n)*(x-a)**n)}; \spad{taylor(a(n),{}n,{}x = a,{}n0..n1)} returns \spad{sum(n = n0..,{}a(n)*(x-a)**n)}.
709849`\spad{tensorProduct([a1,{}...ak])} calculates the list of Kronecker products of each matrix {\em \spad{ai}} with itself for {1 \spad{<=} \spad{i} \spad{<=} \spad{k}}. Note: If the list of matrices corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the representation with itself.
709939`\spad{tensorProduct(a)} calculates the Kronecker product of the matrix {\em a} with itself.
710017`\spad{tensorProduct([a1,{}...,{}ak],{}[b1,{}...,{}bk])} calculates the list of Kronecker products of the matrices {\em \spad{ai}} and {\em \spad{bi}} for {1 \spad{<=} \spad{i} \spad{<=} \spad{k}}. Note: If each list of matrices corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the two representations.
710123`\spad{tensorProduct(a,{}b)} calculates the Kronecker product of the matrices {\em a} and \spad{b}. Note: if each matrix corresponds to a group representation (repr. of generators) of one group,{} then these matrices correspond to the tensor product of the two representations.
710211`\spad{terms(f)} gives the list of non-zero coefficients combined with their corresponding basis element as records. This is the internal representation.
710283`\spad{terms(e1 a1 + ... + en an)} returns \spad{[[a1,{} e1],{}...,{}[an,{} en]]}.
710367`\spad{terms(f(x))} returns a stream of non-zero terms,{} where a a term is an exponent-coefficient pair. The terms in the stream are ordered by increasing order of exponents.
710467`\spad{testDim(lp,{}lv)} tests if the polynomial system \spad{lp} in variables \spad{lv} is zero dimensional.
710675`\spad{testModulus(p,{}lp)} returns \spad{true} if the the prime \spad{p} is valid for the list of polynomials \spad{lp},{} \spadignore{i.e.} preserves the degree and they remain relatively prime.
710742`\spad{test(b)} returns \spad{b} and is provided for compatibility with the new compiler.
710784`\spad{tex(t)} extracts the TeX section of a TeX form \spad{t}.
710832`\spad{thetaCoord(pt)} returns the second element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a spherical or a cylindrical coordinate system.
710940`\spad{third(u)} returns the third element of \spad{u}. Note: \axiom{third(\spad{u}) = first(rest(rest(\spad{u})))}.
710996`\spad{times!(c,{}a,{}b)} computes the matrix product \spad{a * b} and stores the result in the matrix \spad{c}. Error: if \spad{a},{} \spad{b},{} and \spad{c} do not have compatible dimensions.
711097`\spad{times(p,{} q,{} sigma,{} delta)} returns \spad{p * q}. \spad{\sigma} and \spad{\delta} are the maps to use.
711191`\spad{title(s)} specifies a title for a plot by the indicated string \spad{s}. This option is expressed in the form \spad{title == s}.
711236`\spad{title(l,{}s)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{title}. If the option does not exist the value,{} \spad{s} is returned.
711312`\spad{title(v,{}s)} changes the title which is shown in the two-dimensional viewport window,{} \spad{v} of domain \spadtype{TwoDimensionalViewport}.
711374`\spad{title(v,{}s)} changes the title which is shown in the three-dimensional viewport window,{} \spad{v} of domain \spadtype{ThreeDimensionalViewport}.
711438`\spad{toScale(b)} specifies whether or not a plot is to be drawn to scale; if \spad{b} is \spad{true} it is drawn to scale,{} if \spad{b} is \spad{false} it is not. This option is expressed in the form \spad{toScale == b}.
711486`\spad{toScale(l,{}b)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{toScale}. If the option does not exist the value,{} \spad{b} is returned.
711566`\spad{top!(d)} returns the element at the top (front) of the dequeue.
711614`\spad{topFortranOutputStack()} returns the top element of the Fortran output stack
711688`\spad{topPredicate(x)} returns \spad{[[a1,{}...,{}an],{} f]} where the top-level predicate of \spad{x} is \spad{f(a1,{}...,{}an)}. Note: \spad{n} is 0 if \spad{x} has no top-level predicate.
711767`\spad{top(s)} returns the top element \spad{x} from \spad{s}; \spad{s} remains unchanged. Note: Use \axiom{pop!(\spad{s})} to obtain \spad{x} and remove it from \spad{s}.
711812`\spad{toroidal(a)} transforms from toroidal coordinates to Cartesian coordinates: \spad{toroidal(a)} is a function which will map the point \spad{(u,{}v,{}phi)} to \spad{x = a*sinh(v)*cos(phi)/(cosh(v)-cos(u))},{} \spad{y = a*sinh(v)*sin(phi)/(cosh(v)-cos(u))},{} \spad{z = a*sin(u)/(cosh(v)-cos(u))}.
711883`\spad{torsion?(f)} \undocumented
711981`\spad{torsion?(f)} \undocumented
712098`\spad{torsionIfCan(f)}\\ undocumented
712252`\spad{torsionIfCan(f)} \undocumented
712425`\axiom{toseInvertible?(\spad{p1},{}\spad{p2},{}\spad{ts})} has the same specifications as \axiomOpFrom{invertible?}{RegularTriangularSetCategory}.
712515`\axiom{toseInvertible?(\spad{p1},{}\spad{p2},{}\spad{ts})} has the same specifications as \axiomOpFrom{invertible?}{RegularTriangularSetCategory}.
712632`\axiom{toseInvertibleSet(\spad{p1},{}\spad{p2},{}\spad{ts})} has the same specifications as \axiomOpFrom{invertibleSet}{RegularTriangularSetCategory}.
712725`\axiom{toseLastSubResultant(\spad{p1},{}\spad{p2},{}\spad{ts})} has the same specifications as \axiomOpFrom{lastSubResultant}{RegularTriangularSetCategory}.
712843`\axiom{toseSquareFreePart(\spad{p},{}\spad{ts})} has the same specifications as \axiomOpFrom{squareFreePart}{RegularTriangularSetCategory}.
713116`\spad{totalDegree(p)} returns the largest sum over all monomials of all exponents of a monomial.
713399`\spad{totalDegree(p,{} lv)} returns the maximum sum (over all monomials of polynomial \spad{p}) of the variables in the list \spad{lv}.
713495`\spad{totalDifferential(x)} returns the total differential (gradient) form for element \spad{x}.
713590`\spad{totalGroebner(lp,{}lv)} computes Groebner basis for the list of polynomials \spad{lp} with the terms ordered first by total degree and then refined by reverse lexicographic ordering. The variables are ordered by their position in the list \spad{lv}.
713691`\spad{totalLex(v1,{}v2)} return \spad{true} if the vector \spad{v1} is less than the vector \spad{v2} in the ordering which is total degree refined by lexicographic ordering.
713771`\spad{totalfract(prf)} takes a polynomial whose coefficients are themselves fractions of polynomials and returns a record containing the numerator and denominator resulting from putting \spad{prf} over a common denominator.
713895`\spad{totolex }\undocumented
714105`\spad{tower(f)} returns all the kernels appearing in \spad{f},{} no matter what their levels are.
714165`\spad{trace2PowMod(u,{}k,{}v)} produces the sum of \spad{u**(2**i)} for \spad{i} running from 1 to \spad{k} all computed modulo the polynomial \spad{v}.
714254`\spad{traceMatrix()} is the \spad{n}-by-\spad{n} matrix ( \spad{Tr(\spad{vi} * vj)} ),{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed basis.
714318`\spad{traceMatrix()} is the \spad{n}-by-\spad{n} matrix ( \spad{Tr(\spad{vi} * vj)} ),{} where \spad{v1},{} ...,{} \spad{vn} are the elements of the fixed basis.
714517`\spad{traceMatrix([v1,{}..,{}vn])} is the \spad{n}-by-\spad{n} matrix ( \spad{Tr}(\spad{vi} * \spad{vj}) )
714592`\spad{tracePowMod(u,{}k,{}v)} produces the sum of \spad{u**(q**i)} for \spad{i} running and \spad{q=} size \spad{F}
714844`\spad{trace(a)} computes the trace of \spad{a} with respect to the field considered as an algebra with 1 over the ground field \spad{F}.
714906`\spad{trace(a)} returns the trace of the regular representation of \spad{a} with respect to any basis.
714959`\spad{trace(m)} returns the trace of the matrix \spad{m}. this is the sum of the elements on the diagonal of the matrix \spad{m}.
715099`\spad{trace(x,{}n)} \undocumented{} See \axiomFunFrom{trace}{FiniteAlgebraicExtensionField}
715196`\spad{trace(a,{}d)} computes the trace of \spad{a} with respect to the field of extension degree \spad{d} over the ground field of size \spad{q}. Error: if \spad{d} does not divide the extension degree of \spad{a}. Note: \spad{trace(a,{}d) = reduce(+,{}[a**(q**(d*i)) for i in 0..n/d])}.
715288`\spad{trailingCoefficient }\undocumented
715443`\spad{transcendenceDegree()} returns the transcendence degree of the field extension,{} 0 if the extension is algebraic.
715648`\spad{transcendent?(a)} tests whether an element \spad{a} is transcendent with respect to the ground field \spad{F}.
716351`\spad{transform }\undocumented
716495`\spad{translate(v,{}dx,{}dy)} sets the horizontal viewport offset to \spad{dx} and the vertical viewport offset to \spad{dy},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
716568`\spad{translate(v,{}n,{}dx,{}dy)} displays the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} translated by \spad{dx} in the \spad{x}-coordinate direction from the center of the viewport,{} and by \spad{dy} in the \spad{y}-coordinate direction from the center. Setting \spad{dx} and \spad{dy} to \spad{0} places the center of the graph
716568`-- at the center of the viewport.
716767`\spad{transpose(m)} returns the transpose of the matrix \spad{m}.
716822`\spad{transpose(r)} converts the row \spad{r} to a row matrix.
716883`\spad{transpose(m)} returns the transpose of the matrix \spad{m}.
716943`\spad{transpose(t)} exchanges the first and last indices of \spad{t}. For example,{} if \spad{r = transpose(t)} for a rank 4 tensor \spad{t},{} then \spad{r} is the rank 4 tensor given by \indented{4}{\spad{r(i,{}j,{}k,{}l) = t(l,{}j,{}k,{}i)}.}
717006`\spad{transpose(t,{}i,{}j)} exchanges the \spad{i}\spad{-}th and \spad{j}\spad{-}th indices of \spad{t}. For example,{} if \spad{r = transpose(t,{}2,{}3)} for a rank 4 tensor \spad{t},{} then \spad{r} is the rank 4 tensor given by \indented{4}{\spad{r(i,{}j,{}k,{}l) = t(i,{}k,{}j,{}l)}.}
717085`\spad{trapezoidal(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the trapezoidal method to numerically integrate function \spadvar{\spad{fn}} over the closed interval \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{
717085`--nmin} to \spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
717255`\spad{trapezoidalo(fn,{}a,{}b,{}epsrel,{}epsabs,{}nmin,{}nmax)} uses the trapezoidal method to numerically integrate function \spad{fn} over the open interval from \spad{a} to \spad{b},{} with relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},{} with the refinement levels for convergence checking vary from \spad{nmin}
717255`-- to \spad{nmax}. The value returned is a record containing the value of the integral,{} the estimate of the error in the computation,{} the total number of function evaluations,{} and either a boolean value which is \spad{true} if the integral was computed within the user specified error criterion. See \spadtype{NumericalQuadrature} for details.
717426`\spad{traverse(s,{}\spad{li})} follows the branch list of the 3 dimensional subspace,{} \spad{s},{} along the path dictated by the list of non negative integers,{} \spad{li},{} which points to the component which has been traversed to. The subspace,{} \spad{s},{} is returned,{} where \spad{s} is now the subspace pointed to by \spad{li}.
717498`\spad{tree(ls)} creates a tree from a list of elements of \spad{s}.
717540`\spad{tree(nd)} creates a tree with value \spad{nd},{} and no children
717576`\spad{tree(nd,{}ls)} creates a tree with value \spad{nd},{} and children \spad{ls}.
717621`\spad{triangSolve(lp)} returns the same as \spad{triangSolve(lp,{}false,{}false)}
717734`\spad{triangSolve(lp,{}info?)} returns the same as \spad{triangSolve(lp,{}false)}
717855`\spad{triangSolve(lp,{}info?,{}lextri?)} decomposes the variety associated with \axiom{\spad{lp}} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \axiom{\spad{lp}} needs to generate a zero-dimensional ideal. If \axiom{\spad{lp}} is not zero-dimensional then the result is only a decomposition of its
717855`-- zero-set in the sense of the closure (\spad{w}.\spad{r}.\spad{t}. Zarisky topology). Moreover,{} if \spad{info?} is \spad{true} then some information is displayed during the computations. See \axiomOpFrom{zeroSetSplit}{RegularTriangularSetCategory}(\spad{lp},{}\spad{true},{}\spad{info?}). If \spad{lextri?} is \spad{true} then the lexTriangular algorithm is called from the \spadtype{LexTriangularPackage} constructor (see \axiomOpFrom{zeroSetSplit}{LexTriangularPackage}(\spad{lp},{}\spad{false}
717855`--)). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \axiomOpFrom{zeroSetSplit}{RegularChain} from \spadtype{RegularChain}.
718057`\axiom{triangular?(\spad{ps})} returns \spad{true} iff \axiom{\spad{ps}} is a triangular set,{} \spadignore{i.e.} two distinct polynomials have distinct main variables and no constant lies in \axiom{\spad{ps}}.
718155`\spad{triangularSystems(lf,{}lv)} solves the system of equations defined by \spad{lf} with respect to the list of symbols \spad{lv}; the system of equations is obtaining by equating to zero the list of rational functions \spad{lf}. The output is a list of solutions where each solution is expressed as a "reduced" triangular system of polynomials.
718282`\spad{triangulate(M,{}v)} returns \spad{A,{}[[C_1,{}g_1,{}L_1,{}h_1],{}...,{}[C_k,{}g_k,{}L_k,{}h_k]]} such that under the change of variable \spad{y = A z},{} the first order linear system \spad{D y = M y + v} is uncoupled as \spad{D z_i = C_i z_i + g_i} and each \spad{C_i} is a companion matrix corresponding to the scalar equation \spad{L_i z_j = h_i}.
718427`\spad{triangulate(m,{} v)} returns \spad{[m_0,{} v_0]} such that \spad{m_0} is upper triangular and the system \spad{m_0 x = v_0} is equivalent to \spad{m x = v}.
718537`\spad{trigs2explogs(f,{} [k1,{}...,{}kn],{} [x1,{}...,{}xm])} rewrites all the trigonometric functions appearing in \spad{f} and involving one of the \spad{\spad{xi}'s} in terms of complex logarithms and exponentials. A kernel of the form \spad{tan(u)} is expressed using \spad{exp(u)**2} if it is one of the \spad{\spad{ki}'s},{} in terms of \spad{exp(2*u)} otherwise.
718645`\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \spad{f} in terms of trigonometric functions.
718712`\spad{trigs(f)} rewrites all the complex logs and exponentials appearing in \spad{f} in terms of trigonometric functions.
718879`\spad{trim(s,{}c)} returns \spad{s} with all characters \spad{c} deleted from right and left ends. For example,{} \axiom{trim(" abc ",{} char " ")} returns \axiom{"abc"}.
718934`\spad{trim(s,{}cc)} returns \spad{s} with all characters in \spad{cc} deleted from right and left ends. For example,{} \axiom{trim("(abc)",{} charClass "()")} returns \axiom{"abc"}.
719069`\axiom{trivialIdeal?(\spad{ps})} returns \spad{true} iff \axiom{\spad{ps}} does not contain non-zero elements.
719148`\spad{trueEqual(x,{}y)} tries to determine if the two numbers are equal
719211`\spad{true} is a logical constant.
719246`\axiom{trunc(\spad{p},{}\spad{n})} returns the polynomial \axiom{\spad{p}} truncated at order \axiom{\spad{n}}.
719320`\spad{trunc(p,{}n)} returns the polynomial \spad{p} truncated at order \spad{n}.
719437`\spad{truncate x} returns the integer between \spad{x} and 0 closest to \spad{x}.
719487`\spad{truncate(f,{}k)} returns a (finite) power series consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.
719568`\spad{truncate(f,{}k1,{}k2)} returns a (finite) power series consisting of the sum of all terms of \spad{f} of degree \spad{d} with \spad{k1 <= d <= k2}.
719655`\spad{tryFunctionalDecomposition?()} returns \spad{true} if factorizers try functional decomposition of polynomials before factoring them.
719736`\spad{tryFunctionalDecomposition(b)} chooses whether factorizers have to look for functional decomposition of polynomials (\spad{true}) or not (\spad{false}). Returns the previous value.
719823`\spad{tubePlot(f,{}g,{}h,{}colorFcn,{}a..b,{}r,{}n)} puts a tube of radius \spad{r}(\spad{t}) with \spad{n} points on each circle about the curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} for \spad{t} in \spad{[a,{}b]}. The tube is considered to be open.
720029`\spad{tubePlot(f,{}g,{}h,{}colorFcn,{}a..b,{}r,{}n)} puts a tube of radius \spad{r} with \spad{n} points on each circle about the curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} for \spad{t} in \spad{[a,{}b]}. The tube is considered to be open.
720220`\spad{tubePlot(f,{}g,{}h,{}colorFcn,{}a..b,{}r,{}n,{}s)} puts a tube of radius \spad{r(t)} with \spad{n} points on each circle about the curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} for \spad{t} in \spad{[a,{}b]}. If \spad{s} = "closed",{} the tube is considered to be closed; if 
720220`--\spad{s} = "open",{} the tube is considered to be open.
720433`\spad{tubePlot(f,{}g,{}h,{}colorFcn,{}a..b,{}r,{}n,{}s)} puts a tube of radius \spad{r} with \spad{n} points on each circle about the curve \spad{x = f(t)},{} \spad{y = g(t)},{} \spad{z = h(t)} for \spad{t} in \spad{[a,{}b]}. If \spad{s} = "closed",{} the tube is considered to be closed; if \spad{s} = "open",
720433`--{} the tube is considered to be open.
720631`\spad{tubePointsDefault()} returns the number of points to be used when creating the circle to be used in creating a 3D tube plot.
720704`\spad{tubePointsDefault(i)} sets the number of points to use when creating the circle to be used in creating a 3D tube plot to \spad{i}.
720792`\spad{tubePoints(n)} specifies the number of points,{} \spad{n},{} defining the circle which creates the tube around a 3D curve,{} the default is 6. This option is expressed in the form \spad{tubePoints == n}.
720851`\spad{tubePoints(l,{}n)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{tubePoints}. If the option does not exist the value,{} \spad{n} is returned.
720950`\spad{tubeRadiusDefault()} returns the radius used for a 3D tube plot.
721019`\spad{tubeRadiusDefault(r)} sets the default radius for a 3D tube plot to \spad{r}.
721093`\spad{tubeRadius(r)} specifies a radius,{} \spad{r},{} for a tube plot around a 3D curve; is expressed in the form \spad{tubeRadius == 4}.
721142`\spad{tubeRadius(l,{}n)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{tubeRadius}. If the option does not exist the value,{} \spad{n} is returned.
721221`\spad{tube(c,{}r,{}n)} creates a tube of radius \spad{r} around the curve \spad{c}.
721309`\spad{tube(c,{}ll,{}b)} creates a tube of the domain \spadtype{TubePlot} from a space curve \spad{c} of the category \spadtype{PlottableSpaceCurveCategory},{} a list of lists of points (loops) \spad{ll} and a boolean \spad{b} which if \spad{true} indicates a closed tube,{} or if \spad{false} an open tube.
721396`\spad{twist(f)} is the function \spad{g} \indented{1}{such that \spad{g (a,{}b)= f(b,{}a)}.}
721461`\spad{twoFactor(p,{}n)} returns the factorisation of polynomial \spad{p},{} a sparse univariate polynomial (sup) over a sup over \spad{F}. Also,{} \spad{p} is assumed primitive and square-free and \spad{n} is the degree of the inner variable of \spad{p} (maximum of the degrees of the coefficients of \spad{p}).
721639`\spad{typeList(t,{}tab)} returns a list of all the objects of type \spad{t} in \spad{tab}
721775`\spad{typeLists(tab)} returns a list of lists of types of objects in \spad{tab}
721900`\spad{unary?(op)} tests if \spad{op} is unary.
721950`\spad{unaryFunction(a)} is a local function
722029`\spad{uncouplingMatrices(M)} returns \spad{[A_1,{}...,{}A_n]} such that if \spad{y = [y_1,{}...,{}y_n]} is a solution of \spad{y' = M y},{} then \spad{[\$y_j',{}y_j'',{}...,{}y_j^{(n)}\$] = \$A_j y\$} for all \spad{j}\spad{'s}.
722191`\spad{unexpand(p)} returns \spad{p} in recursive form.
722285`\spad{uniform01()} \undocumented
722345`\spad{uniform(s)} \undocumented
722427`\spad{uniform(s)} \undocumented
722489`\spad{uniform(f,{}g)} \undocumented
722746`\spad{union(l1,{} l2)} returns set-theoretic union of \spad{l1} and \spad{l2}.
722932`\spad{union(a,{} b)} makes the set-union of two match results.
722989`\spad{union(x,{}u)} returns the set aggregate \spad{u} with the element \spad{x} added. If \spad{u} already contains \spad{x},{} \axiom{union(\spad{x},{}\spad{u})} returns a copy of \spad{u}.
723037`\spad{union(u,{}x)} returns the set aggregate \spad{u} with the element \spad{x} added. If \spad{u} already contains \spad{x},{} \axiom{union(\spad{u},{}\spad{x})} returns a copy of \spad{u}.
723085`\spad{union(u,{}v)} returns the set aggregate of elements which are members of either set aggregate \spad{u} or \spad{v}.
723181`\spad{unit?(x)} tests whether \spad{x} is a unit,{} \spadignore{i.e.} is invertible.
723320`\spad{unitCanonical(x)} returns \spad{unitNormal(x).canonical}.
723616`\spad{unitNormal(x)} tries to choose a canonical element from the associate class of \spad{x}. The attribute canonicalUnitNormal,{} if asserted,{} means that the "canonical" element is the same across all associates of \spad{x} if \spad{unitNormal(x) = [u,{}c,{}a]} then \spad{u*c = x},{} \spad{a*u = 1}.
723705`\spad{unitNormalize(u)} normalizes the unit part of the factorization. For example,{} when working with factored integers,{} this operation will ensure that the bases are all positive integers.
723755`\spad{unitVector(x)} \undocumented
723830`\spad{unitVector(p)} creates the unit vector of the point \spad{p} and returns the result as a point. Note: \spad{unitVector(p) = p/|p|}.
723911`\spad{unitVector(n)} produces a vector with 1 in position \spad{n} and zero elsewhere.
724069`\spad{unit()} returns a unit of the algebra (necessarily unique),{} or \spad{"failed"} if there is none.
724168`\spad{unit(lf)} will mark off the units according to the indicated list \spad{lf}. This option is expressed in the form \spad{unit == [f1,{}f2]}.
724217`\spad{unit(u)} extracts the unit part of the factorization.
724257`\spad{unitsColorDefault()} returns the default color of the unit ticks in a 2D viewport.
724322`\spad{unitsColorDefault(p)} sets the default color of the unit ticks in a 2D viewport to the palette \spad{p}.
724394`\spad{units(\spad{gi})} returns the list of unit increments for the \spad{x} and \spad{y} axes of the indicated graph,{} \spad{\spad{gi}},{} of the domain \spadtype{GraphImage}.
724444`\spad{units(l,{}u)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{unit}. If the option does not exist the value,{} \spad{u} is returned.
724530`\spad{units(\spad{gi},{}lu)} modifies the list of unit increments for the \spad{x} and \spad{y} axes of the given graph,{} \spad{\spad{gi}} of the domain \spadtype{GraphImage},{} to be that of the list of unit increments,{} \spad{lu},{} and returns the new list of units for \spad{\spad{gi}}.
724592`\spad{units(v,{}n,{}c)} displays the units of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} with the units color set to the given palette color \spad{c}.
724671`\spad{units(v,{}n,{}s)} displays the units of the graph in field \spad{n} of the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} if \spad{s} is "on",{} or does not display the units if \spad{s} is "off".
724749`\axiom{univariate?(\spad{p})} returns \spad{true} iff \axiom{\spad{p}} involves one and only one variable.
724828`\spad{univariatePolynomial(f,{}k)} returns a univariate polynomial \indented{1}{consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.}
724963`\spad{univariatePolynomial(f,{}k)} returns a univariate polynomial \indented{1}{consisting of the sum of all terms of \spad{f} of degree \spad{<= k}.}
725092`\axiom{univariatePolynomialsGcds(\spad{lp})} returns \axiom{\spad{lg}} where \axiom{\spad{lg}} is a list of the gcds of every pair in \axiom{\spad{lp}} of univariate polynomials in the same main variable.
725207`\axiom{univariatePolynomialsGcds(\spad{lp},{}opt)} returns the same as \axiom{univariatePolynomialsGcds(\spad{lp})} if \axiom{opt} is \axiom{\spad{false}} and if the previous operation does not return any non null and constant polynomial,{} else return \axiom{[1]}.
725330`\axiom{univariatePolynomials(\spad{lp})} returns \axiom{ups,{}nups} where \axiom{ups} is a list of the univariate polynomials,{} and \axiom{nups} are the other ones.
725458`\spad{univariateSolve(lp)} returns the same as \spad{univariateSolve(lp,{}false,{}false,{}false)}.
725639`\spad{univariateSolve(ts)} returns a univariate representation of \spad{ts}. See \axiomOpFrom{rur}{RationalUnivariateRepresentationPackage}(\spad{lp},{}\spad{true}).
725819`\spad{univariateSolve(lp,{}info?)} returns the same as \spad{univariateSolve(lp,{}info?,{}false,{}false)}.
726008`\spad{univariateSolve(lp,{}info?,{}check?)} returns the same as \spad{univariateSolve(lp,{}info?,{}check?,{}false)}.
726205`\spad{univariateSolve(lp,{}info?,{}check?,{}lextri?)} returns a univariate representation of the variety associated with \spad{lp}. Moreover,{} if \spad{info?} is \spad{true} then some information is displayed during the decomposition into regular chains. If \spad{check?} is \spad{true} then the result
726205`-- is checked. See \axiomOpFrom{rur}{RationalUnivariateRepresentationPackage}(\spad{lp},{}\spad{true}). If \spad{lextri?} is \spad{true} then the lexTriangular algorithm is called from the \spadtype{LexTriangularPackage} constructor (see \axiomOpFrom{zeroSetSplit}{LexTriangularPackage}(\spad{lp},{}\spad{false})). Otherwise,{} the triangular decomposition is computed directly from the input system by using the \axiomOpFrom{zeroSetSplit}{RegularChain} from \spadtype{RegularChain}.
726410`\spad{univariate(p)} converts the multivariate polynomial \spad{p},{} which should actually involve only one variable,{} into a univariate polynomial in that variable,{} whose coefficients are in the ground ring. Error: if polynomial is genuinely multivariate
726503`\spad{univariate(f,{} v)} returns \spad{f} viewed as a univariate rational function in \spad{v}.
726718`\spad{univariate(f,{} v)} returns \spad{f} viewed as a univariate rational function in \spad{v}.
726860`\spad{univariate(p,{} x)} converts the polynomial \spad{p} to a one of type \spad{UnivariatePolynomial(x,{}Polynomial(R))},{} ie. as a member of \spad{R[...][x]}.
726991`\spad{univariate(f,{} k)} returns \spad{f} viewed as a univariate fraction in \spad{k}.
727113`\spad{univariate(p,{}v)} converts the multivariate polynomial \spad{p} into a univariate polynomial in \spad{v},{} whose coefficients are still multivariate polynomials (in all the other variables).
727214`\spad{univariate(f,{} x,{} p)} returns \spad{f} viewed as a univariate polynomial in \spad{x},{} using the side-condition \spad{p(x) = 0}.
727354`\spad{univariate(f,{}k,{}k,{}p)} \undocumented
727531`\spad{univcase should} be local
727657`\spad{universe()}\$\spad{D} returns the universal set for finite set aggregate \spad{D}.
727812`\spad{unmakeSUP(sup)} converts \spad{sup} of type \spadtype{SparseUnivariatePolynomial(R)} to be a member of the given type. Note: converse of makeSUP.
727905`\spad{unparse(f)} returns a string \spad{s} such that the parser would transform \spad{s} to \spad{f}. Error: if \spad{f} is not the parsed form of a string.
727951`\axiom{unprotectedRemoveRedundantFactors(\spad{p},{}\spad{q})} returns the same as \axiom{removeRedundantFactors(\spad{p},{}\spad{q})} but does assume that neither \axiom{\spad{p}} nor \axiom{\spad{q}} lie in the base ring \axiom{\spad{R}} and assumes that \axiom{infRittWu?(\spad{p},{}\spad{q})} holds. Moreover,{} if \axiom{\spad{R}} is \spad{gcd}-domain,{} then \axiom{\spad{p}} and \axiom{\spad{q}} ar
727951`--e assumed to be square free.
728054`\spad{unrankImproperPartitions0(n,{}m,{}k)} computes the {\em k}\spad{-}th improper partition of nonnegative \spad{n} in \spad{m} nonnegative parts in reverse lexicographical order. Example: {\em [0,{}0,{}3] < [0,{}1,{}2] < [0,{}2,{}1] < [0,{}3,{}0] < [1,{}0,{}2] < [1,{}1,{}1] < [1,{}2,{}0] < [2,{}0,{}1] < [2,{}1,{}0] < [3,{}0,{}0]}. Error: if \spad{k} is negative or too big. Note: count
728054`--ing of subtrees is done by \spadfunFrom{numberOfImproperPartitions}{SymmetricGroupCombinatoricFunctions}.
728172`\spad{unrankImproperPartitions1(n,{}m,{}k)} computes the {\em k}\spad{-}th improper partition of nonnegative \spad{n} in at most \spad{m} nonnegative parts ordered as follows: first,{} in reverse lexicographically according to their non-zero parts,{} then according to their positions (\spadignore{i.e.} lexicographical order using {\em subSet}: {\em [3,{}0,{}0] < [0,{}3,{}0] < [0,{}0,{}3]
728172`-- < [2,{}1,{}0] < [2,{}0,{}1] < [0,{}2,{}1] < [1,{}2,{}0] < [1,{}0,{}2] < [0,{}1,{}2] < [1,{}1,{}1]}). Note: counting of subtrees is done by {\em numberOfImproperPartitionsInternal}.
728290`\spad{unravel(t)} produces a tensor from a list of components such that \indented{2}{\spad{unravel(ravel(t)) = t}.}
728356`\spad{untab(lp,{}llp)} is an auxiliary function which unbumps a tableau \spad{llp},{} using \spad{lp} to accumulate pairs
728447`\spad{unvectorise(v)} returns the polynomial which has for coefficients the entries of \spad{v} in the increasing order.
728527`\spad{unvectorise(vect,{} var,{} n)} returns \spad{vect(1) + vect(2)*var + ... + vect(n+1)*var**(n)} where \spad{vect} is the vector of the coefficients of the polynomail ,{} \spad{var} the new variable and \spad{n} the degree.
729205`\spad{updatD }\undocumented
729496`\spad{updatF }\undocumented
729690`\axiom{updateStatus!(a)} returns a where the status of the vertices are updated to satisfy the "termination condition".
729747`\spad{update(v,{}gr,{}n)} drops the graph \spad{gr} in slot \spad{n} of viewport \spad{v}. The graph \spad{gr} must have been transmitted already and acquired an integer key.
729830`\spad{upperCase!(s)} destructively replaces the alphabetic characters in \spad{s} by upper case characters.
729881`\spad{upperCase?(c)} tests if \spad{c} is an upper case letter,{} \spadignore{i.e.} one of A..\spad{Z}.
729931`\spad{upperCase()} returns the class of all characters for which \spadfunFrom{upperCase?}{Character} is \spad{true}.
730024`\spad{upperCase(s)} returns the string with all characters in upper case.
730074`\spad{upperCase(c)} converts a lower case letter to the corresponding upper case letter. If \spad{c} is not a lower case letter,{} then it is returned unchanged.
730118`\spad{useEisensteinCriterion?()} returns \spad{true} if factorizers check Eisenstein\spad{'s} criterion before factoring.
730195`\spad{useEisensteinCriterion(b)} chooses whether factorizers check Eisenstein\spad{'s} criterion before factoring: \spad{true} for using it,{} \spad{false} else. Returns the previous value.
730278`\spad{useNagFunctions()} indicates whether NAG functions are being used \indented{1}{for mathematical and machine constants.}
730374`\spad{useNagFunctions(v)} sets the flag which controls whether NAG functions \indented{1}{are being used for mathematical and machine constants.\space{2}The previous} \indented{1}{value is returned.}
730477`\spad{useSingleFactorBound?()} returns \spad{true} if algorithm with single factor bound is used for factorization,{} \spad{false} for algorithm with overall bound.
730552`\spad{useSingleFactorBound(b)} chooses the algorithm to be used by the factorizers: \spad{true} for algorithm with single factor bound,{} \spad{false} for algorithm with overall bound. Returns the previous value.
730633`\spad{userOrdered?()} tests if the partial ordering induced by \spadfunFrom{setOrder}{UserDefinedPartialOrdering} is not empty.
730703`\axiom{usingTable?()} returns \spad{true} iff the hash-table is used
730781`\spad{validExponential([k1,{}...,{}kn],{}f,{}x)} returns \spad{g} if \spad{exp(f)=g} and \spad{g} involves only \spad{k1...kn},{} and "failed" otherwise.
730999`\axiom{value(\spad{n})} returns the value of the node \spad{n}.
731047`\spad{value(x)} returns the integer associated with \spad{x}
731093`\spad{value(u)} returns the value of the node \spad{u}.
731144`\spad{value(q)} returns the value (\spadignore{i.e.} right hand side) of \axiom{\spad{q}}.
731192`\spad{var1StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\spadignore{e.g.} \spad{x=0}..10)).
731264`\spad{var1StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \spad{i} (a free variable is considered defined when its range is specified (\spadignore{e.g.} \spad{x=0}..10)).
731351`\spad{var1Steps(n)} indicates the number of subdivisions,{} \spad{n},{} of the first range variable. This option is expressed in the form \spad{var1Steps == n}.
731409`\spad{var1Steps(l,{}n)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{var1Steps}. If the option does not exist the value,{} \spad{n} is returned.
731507`\spad{var2StepsDefault()} is the current setting for the number of steps to take when creating a 3D mesh in the direction of the first defined free variable (a free variable is considered defined when its range is specified (\spadignore{e.g.} \spad{x=0}..10)).
731579`\spad{var2StepsDefault(i)} sets the number of steps to take when creating a 3D mesh in the direction of the first defined free variable to \spad{i} (a free variable is considered defined when its range is specified (\spadignore{e.g.} \spad{x=0}..10)).
731666`\spad{var2Steps(n)} indicates the number of subdivisions,{} \spad{n},{} of the second range variable. This option is expressed in the form \spad{var2Steps == n}.
731724`\spad{var2Steps(l,{}n)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{var2Steps}. If the option does not exist the value,{} \spad{n} is returned.
731822`\spad{varList(x)} returns the list of variables of \spad{x}.
731880`\axiom{varList(\spad{g})} returns the list of variables of \axiom{\spad{g}}.
731954`\axiom{varList(\spad{x})} returns the list of distinct entries of \axiom{\spad{x}}.
732015`\axiom{varList(\spad{x})} returns the list of distinct entries of \axiom{\spad{x}}.
732071`\spad{varList([l1]*[l2]*...[ln])} returns the list of variables in the word \spad{l1*l2*...*ln}.
732153`\axiom{varList(\spad{x})} returns the list of distinct entries of \axiom{\spad{x}}.
732220`\spad{varList(x)} returns the list of variables which appear in \spad{x}.
732277`\spad{varList(e,{}n)} returns a list of \axiom{\spad{n}} indexed variables with name as in \axiom{\spad{e}}.
732376`\spad{varList(s,{}n)} \undocumented{}
732458`\spad{variable()} returns the symbol
732507`\spad{variable(s)} returns a member of the variable set or failed
732594`\spad{variable(v)} returns \spad{s} if \spad{v} is any derivative of the differential indeterminate \spad{s}.
732658`\spad{variable(f)} returns the (unique) power series variable of the power series \spad{f}.
732737`\spad{variable(q)} returns the variable (\spadignore{i.e.} left hand side) of \axiom{\spad{q}}.
732788`\spad{variable(segb)} returns the variable from the left hand side of the \spadtype{SegmentBinding}. For example,{} if \spad{segb} is \spad{v=a..b},{} then \spad{variable(segb)} returns \spad{v}.
732843`\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \spad{f}.
733245`\spad{variables(upoly)} returns the list of variables for the coefficients of \spad{upoly}.
733341`\spad{variables(p)} returns the list of matching variables appearing in \spad{p}.
733392`\spad{variables(f)} returns the list of variables appearing in the numerator or the denominator of \spad{f}.
733477`\spad{variables(args)} returns the list of variables in \axiom{\spad{args}.\spad{lfn}}
733600`\spad{variables(f)} returns the list of all the variables of \spad{f}.
733661`\spad{variables(e)} return a list of all the variables in \spad{e}.
733758`\spad{variables(f)} returns a list of the variables occuring in the power series \spad{f}.
733835`\spad{variables(p)} returns the list of those variables actually appearing in the polynomial \spad{p}.
733910`\axiom{variables(\spad{ps})} returns the decreasingly sorted list of the variables which are variables of some polynomial in \axiom{\spad{ps}}.
733990`\spad{variationOfParameters(op,{} g,{} [f1,{}...,{}fm])} returns \spad{[u1,{}...,{}um]} such that a particular solution of the equation \spad{op y = g} is \spad{f1 int(u1) + ... + fm int(um)} where \spad{[f1,{}...,{}fm]} are linearly independent and \spad{op(\spad{fi})=0}. The value "failed" is returned if \spad{m < n} and no particular solution is found.
734088`\spad{vark([f1,{}...,{}fn],{}x)} returns the set-theoretic union of \spad{(varselect(f1,{}x),{}...,{}varselect(fn,{}x))}.
734164`\spad{varselect([k1,{}...,{}kn],{} x)} returns the \spad{ki} which involve \spad{x}.
734253`\spad{vconcat(u)} vertically concatenates all forms in list \spad{u}.
734302`\spad{vconcat(f,{}g)} vertically concatenates forms \spad{f} and \spad{g}.
734348`\spad{vector(l)} converts the list \spad{l} to a vector.
734482`\spad{vectorise(p,{} n)} returns \spad{[a0,{}...,{}a(n-1)]} where \spad{p = a0 + a1*x + ... + a(n-1)*x**(n-1)} + higher order terms. The degree of polynomial \spad{p} can be different from \spad{n-1}.
734574`\spad{vedf2vef(v)} maps \axiomType{Vector Expression DoubleFloat} to \axiomType{Vector Expression Float}
734742`\spad{vertConcat(x,{}y)} vertically concatenates two matrices with an equal number of columns. The entries of \spad{y} appear below of the entries of \spad{x}. Error: if the matrices do not have the same number of columns.
734806`\spad{viewDefaults()} resets all the default graphics settings.
734863`\spad{viewDeltaXDefault()} returns the current default horizontal offset from the center of the viewport window.
734931`\spad{viewDeltaXDefault(dx)} sets the current default horizontal offset from the center of the viewport window to be \spad{dx} and returns \spad{dx}.
735004`\spad{viewDeltaYDefault()} returns the current default vertical offset from the center of the viewport window.
735072`\spad{viewDeltaYDefault(dy)} sets the current default vertical offset from the center of the viewport window to be \spad{dy} and returns \spad{dy}.
735145`\spad{viewPhiDefault()} returns the current default latitudinal view angle in radians.
735210`\spad{viewPhiDefault(p)} sets the current default latitudinal view angle in radians to the value \spad{p} and returns \spad{p}.
735280`\spad{viewPosDefault()} returns the default \spad{X} and \spad{Y} position of a viewport window unless overriden explicityly,{} newly created viewports will have this \spad{X} and \spad{Y} coordinate.
735359`\spad{viewPosDefault([x,{}y])} sets the default \spad{X} and \spad{Y} position of a viewport window unless overriden explicityly,{} newly created viewports will have th \spad{X} and \spad{Y} coordinates \spad{x},{} \spad{y}.
735462`\spad{viewSizeDefault()} returns the default viewport width and height.
735539`\spad{viewSizeDefault([w,{}h])} sets the default viewport width to \spad{w} and height to \spad{h}.
735637`\spad{viewThetaDefault()} returns the current default longitudinal view angle in radians.
735704`\spad{viewThetaDefault(t)} sets the current default longitudinal view angle in radians to the value \spad{t} and returns \spad{t}.
735776`\spad{viewWriteAvailable()} returns a list of available methods for writing,{} such as BITMAP,{} POSTSCRIPT,{} etc.
735847`\spad{viewWriteDefault()} returns the list of things to write in a viewport data file; a viewAlone file is always generated.
735916`\spad{viewWriteDefault(l)} sets the default list of things to write in a viewport data file to the strings in \spad{l}; a viewAlone file is always genereated.
735997`\spad{viewZoomDefault()} returns the current default graph scaling value.
736063`\spad{viewZoomDefault(s)} sets the current default graph scaling value to \spad{s} and returns \spad{s}.
736134`\spad{viewpoint(vp)} creates a viewpoint data structure corresponding to the list of values. The values are interpreted as [theta,{} phi,{} scale,{} scaleX,{} scaleY,{} scaleZ,{} deltaX,{} deltaY]. This option is expressed in the form \spad{viewpoint == ls}.
736331`\spad{viewpoint(v)} returns the current viewpoint setting of the given viewport,{} \spad{v}. This function is useful in the situation where the user has created a viewport,{} proceeded to interact with it via the control panel and desires to save the values of the viewpoint as the default setting
736331`--s for another viewport to be created using the system.
736542`\spad{viewpoint(l,{}ls)} takes the list of draw options,{} \spad{l},{} and checks the list to see if it contains the option \spad{vi
736542`--ewpoint}. IF the option does not exist,{} the value \spad{ls} is returned.
736918`\spad{viewpoint(v,{}viewpt)} sets the viewpoint for the viewport. The viewport record consists of the latitudal and longitudal angles,{} the zoom factor,{} the \spad{X},{} \spad{Y},{} and \spad{Z} scales,{} and the \spad{X} and \spad{Y} displacements.
737134`\spad{viewpoint(v,{}th,{}phi)} sets the longitudinal view angle to \spad{th} radians and the latitudinal view angle to \spad{phi} radians for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until the function \spadfun{makeViewport3D} is executed again for \spad{v}.
737207`\spad{viewpoint(v,{}rotx,{}roty,{}rotz)} sets the rotation about the \spad{x}-axis to be \spad{rotx} radians,{} sets the rotation about the \spad{y}-axis to be \spad{roty} radians,{} and sets the rotation about the \spad{z}-axis to be \spad{rotz} radians,{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport} and displays \spad{v} with the new view position.
737286`\spad{viewpoint(v,{}th,{}phi,{}s,{}dx,{}dy)} sets the longitudinal view angle to \spad{th} radians,{} the latitudinal view angle to \spad{phi} radians,{} the scale factor to \spad{s},{} the horizontal viewport offset to \spad{dx},{} and the vertical viewport offset to \spad{dy} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed until
737286`-- the function \spadfun{makeViewport3D} is executed again for \spad{v}.
737377`\spad{viewpoint(v,{}th,{}phi,{}s,{}dx,{}dy)} sets the longitudinal view angle to \spad{th} degrees,{} the latitudinal view angle to \spad{phi} degrees,{} the scale factor to \spad{s},{} the horizontal viewport offset to \spad{dx},{} and the vertical viewport offset to \spad{dy} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}. The new viewpoint position is not displayed u
737377`--ntil the function \spadfun{makeViewport3D} is executed again for \spad{v}.
737472`\spad{viewport2D()} returns an undefined two-dimensional viewport of the domain \spadtype{TwoDimensionalViewport} whose contents are empty.
737528`\spad{viewport3D()} returns an undefined three-dimensional viewport of the domain \spadtype{ThreeDimensionalViewport} whose contents are empty.
737586`\spad{virtualDegree }\undocumented
737689`\spad{void()} produces a void object.
737721`\spad{vspace(n)} creates white space of height \spad{n}.
737768`\spad{weakBiRank(x)} determines the number of linearly independent elements in the \spad{bi*x*bj},{} \spad{i,{}j=1,{}...,{}n},{} where \spad{b=[b1,{}...,{}bn]} is a basis.
737838`\spad{weierstrass(v,{}ts)} where \spad{v} is a variable and \spad{ts} is \indented{1}{a TaylorSeries,{} impements the Weierstrass Preparation} \indented{1}{Theorem. The result is a list of TaylorSeries that} \indented{1}{are the coefficients of the equivalent series.}
738097`\spad{weight(p)} returns the maximum weight of all differential monomials appearing in the differential polynomial \spad{p}.
738184`\spad{weight(v)} returns the weight of the derivative \spad{v}.
738263`\spad{weight(op)} returns the weight attached to \spad{op}.
738409`\spad{weight(op,{} n)} attaches the weight \spad{n} to \spad{op}.
738473`\spad{weight(p,{} s)} returns the maximum weight of all differential monomials appearing in the differential polynomial \spad{p} when \spad{p} is viewed as a differential polynomial in the differential indeterminate \spad{s} alone.
738562`\spad{weighted(l)} \undocumented
738745`\spad{weights(p)} returns a list of weights of differential monomials appearing in differential polynomial \spad{p}.
738931`\spad{weights(p,{} s)} returns a list of weights of differential monomials appearing in the differential polynomial \spad{p} when \spad{p} is viewed as a differential polynomial in the differential indeterminate \spad{s} alone.
739027`\spad{whatInfinity(x)} returns 0 if \spad{x} is finite,{} 1 if \spad{x} is +infinity,{} and \spad{-1} if \spad{x} is -infinity.
739096`\spad{whileLoop(s,{}c)} creates a while loop in FORTRAN.
739149`\spad{wholePart x} returns the integer part of \spad{x}.
739205`\spad{wholePart(x)} extracts the whole part of \spadvar{\spad{x}}. That is,{} if \spad{x = continuedFraction(b0,{} [a1,{}a2,{}a3,{}...],{} [b1,{}b2,{}b3,{}...])},{} then \spad{wholePart(x) = b0}.
739259`\spad{wholePart(p)} extracts the whole part of the partial fraction \spad{p}.
739311`\spad{wholePart(x)} returns the whole part of the fraction \spad{x} \spadignore{i.e.} the truncated quotient of the numerator by the denominator.
739391`\spad{wholeRadix(l)} creates an integral radix expansion from a list of ragits. For example,{} \spad{wholeRadix([1,{}3,{}4])} will return \spad{134}.
739456`\spad{wholeRagits(rx)} returns the ragits of the integer part of a radix expansion.
739522`\spad{width()} returns the width of the display area (an integer).
739566`\spad{width(f)} returns the width of form \spad{f} (an integer).
739612`\spad{width(u)} returns \axiom{sup(\spad{u}) - inf(\spad{u})}.
739661`\spad{withPredicates(p,{} [p1,{}...,{}pn])} makes a copy of \spad{p} and attaches the predicate \spad{p1} and ... and \spad{pn} to the copy,{} which is returned.
739721`\spad{wordInGenerators(p,{}gp)} returns the word for the permutation \spad{p} in the original generators of the group {\em gp},{} represented by the indices of the list,{} given by {\em generators}.
739819`\spad{wordInStrongGenerators(p,{}gp)} returns the word for the permutation \spad{p} in the strong generators of the group {\em gp},{} represented by the indices of the list,{} given by {\em strongGenerators}.
739923`\spad{wordsForStrongGenerators(gp)} returns the words for the strong generators of the group {\em gp} in the original generators of {\em gp},{} represented by their indices in the list,{} given by {\em generators}.
740020`\spad{wreath(s1,{}s2)} is the cycle index of the wreath product \indented{1}{of the two groups whose cycle indices are \spad{s1} and} \indented{1}{\spad{s2}.}
740178`\spad{writable?(f)} tests if the named file be opened for writing. The named file need not already exist.
740234`\spad{write!(f,{}s)} puts the value \spad{s} into the file \spad{f}. The state of \spad{f} is modified so subsequents call to \spad{write!} will append one after another.
740287`\spad{writeLine!(f)} finishes the current line in the file \spad{f}. An empty string is returned. The call \spad{writeLine!(f)} is equivalent to \spad{writeLine!(f,{}"")}.
740335`\spad{writeLine!(f,{}s)} writes the contents of the string \spad{s} and finishes the current line in the file \spad{f}. The value of \spad{s} is returned.
740390`\spad{write(v,{}s)} takes the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data files for \spad{v}.
740454`\spad{write(v,{}s)} takes the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data file for \spad{v}.
740520`\spad{write(v,{}s,{}lf)} takes the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data files for \spad{v} and the optional file types indicated by the list \spad{lf}.
740597`\spad{write(v,{}s,{}f)} takes the given two-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{TwoDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data files for \spad{v} and an optional file type \spad{f}.
740668`\spad{write(v,{}s,{}lf)} takes the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data file for \spad{v} and the optional file types indicated by the list \spad{lf}.
740747`\spad{write(v,{}s,{}f)} takes the given three-dimensional viewport,{} \spad{v},{} which is of domain \spadtype{ThreeDimensionalViewport},{} and creates a directory indicated by \spad{s},{} which contains the graph data file for \spad{v} and an optional file type \spad{f}.
740820`\spad{wronskianMatrix([f1,{}...,{}fn])} returns the \spad{n x n} matrix \spad{m} whose i^th row is \spad{[f1^(i-1),{}...,{}fn^(i-1)]}.
740889`\spad{wronskianMatrix([f1,{}...,{}fn],{} q,{} D)} returns the \spad{q x n} matrix \spad{m} whose i^th row is \spad{[f1^(i-1),{}...,{}fn^(i-1)]}.
740977`\spad{wrregime(l,{}s)} writes a list of regimes to a file named \spad{s} and returns the number of regimes written
741230`\spad{xCoord(pt)} returns the first element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system.
741282`\spad{xRange(c)} returns the range of the \spad{x}-coordinates of the points on the curve \spad{c}.
741359`\spad{xRange(c)} returns the range of the \spad{x}-coordinates of the points on the curve \spad{c}.
741436`\spad{xn(n)} returns the polynomial \spad{x**n-1}.
741542`\spad{xor(a,{}b)} returns the logical {\em exclusive-or} of bit aggregates \axiom{a} and \axiom{\spad{b}}.
741586`\spad{xor(a,{}b)} returns the logical exclusive {\em or} of Boolean \spad{a} and \spad{b}.
741625`\spad{xor(n,{}m)} returns the bit-by-bit logical {\em xor} of the single integers \spad{n} and \spad{m}.
741670`\spad{yCoord(pt)} returns the second element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian coordinate system.
741815`\spad{yCoordinates(f)} returns \spad{[[A1,{}...,{}An],{} D]} such that \spad{f = (A1 + A2 y +...+ An y**(n-1)) / D}.
741912`\spad{yRange(c)} returns the range of the \spad{y}-coordinates of the points on the curve \spad{c}.
741989`\spad{yRange(c)} returns the range of the \spad{y}-coordinates of the points on the curve \spad{c}.
742066`\spad{yellow()} returns the position of the yellow hue from total hues.
742101`\spad{youngGroup([n1,{}...,{}nk])} constructs the direct product of the symmetric groups {\em Sn1},{}...,{}{\em Snk}.
742195`\spad{youngGroup(lambda)} constructs the direct product of the symmetric groups given by the parts of the partition {\em lambda}.
742285`\spad{zCoord(pt)} returns the third element of the point,{} \spad{pt},{} although no assumptions are made as to the coordinate system being used. This function is defined for the convenience of the user dealing with a Cartesian or a cylindrical coordinate system.
742337`\spad{zRange(c)} returns the range of the \spad{z}-coordinates of the points on the curve \spad{c}.
742414`\spad{zag(f,{}g)} creates a form for the continued fraction form for \spad{f} over \spad{g}.
742842`\spad{zero?(x)} tests if \spad{x} is equal to 0.
742891`\spad{zero?(I)} tests whether the ideal \spad{I} is the zero ideal
743055`\axiom{zero?(pol,{}aRoot)} answers if \axiom{pol} interpreted as \axiom{aRoot} is \axiom{0}
743149`\spad{zeroDim?(I)} tests if the ideal \spad{I} is zero dimensional,{} \spadignore{i.e.} all its associated primes are maximal,{} in the ring \spad{F[lvar]},{} where lvar are the variables appearing in \spad{I}
743226`\spad{zeroDim?(I,{}lvar)} tests if the ideal \spad{I} is zero dimensional,{} \spadignore{i.e.} all its associated primes are maximal,{} in the ring \spad{F[lvar]}
743316`\spad{zeroDimPrimary?(I)} tests if the ideal \spad{I} is 0-dimensional primary.
743544`\spad{zeroDimPrime?(I)} tests if the ideal \spad{I} is a 0-dimensional prime.
743770`\axiom{zeroDimensional?(\spad{lp})} returns \spad{true} iff \axiom{\spad{lp}} generates a zero-dimensional ideal \spad{w}.\spad{r}.\spad{t}. the variables involved in \axiom{\spad{lp}}.
743905`\axiom{zeroDimensional?(\spad{lq1})} returns \spad{true} iff \axiom{\spad{lq1}} generates a zero-dimensional ideal \spad{w}.\spad{r}.\spad{t}. the variables of \axiom{\spad{ls}}.
743991`\spad{zeroMatrix(i,{}j,{}k)} create a matrix with all zero terms
744117`\spad{zeroMatrix(s,{}p,{}q)} uses loop variables in the Fortran,{} \spad{I1} and \spad{I2}
744225`\spad{zeroMatrix(s,{}b,{}d)} in this version gives the user control over names of Fortran variables used in loops.
744735`\spad{zeroOf(p)} returns \spad{y} such that \spad{p(y) = 0}. If possible,{} \spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity. Error: if \spad{p} has more than one variable \spad{y}.
744803`\spad{zeroOf(p)} returns \spad{y} such that \spad{p(y) = 0}; if possible,{} \spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity.
744887`\spad{zeroOf(p)} returns \spad{y} such that \spad{p(y) = 0}. The value \spad{y} is expressed in terms of radicals if possible,{}and otherwise as an implicit algebraic quantity. Error: if \spad{p} has more than one variable.
745207`\spad{zeroOf(p,{} y)} returns \spad{y} such that \spad{p(y) = 0}; if possible,{} \spad{y} is expressed in terms of radicals. Otherwise it is an implicit algebraic quantity which displays as \spad{'y}.
745298`\spad{zeroOf(p,{} y)} returns \spad{y} such that \spad{p(y) = 0}. The value \spad{y} is expressed in terms of radicals if possible,{}and otherwise as an implicit algebraic quantity which displays as \spad{'y}.
745372`\axiom{zeroSetSplitIntoTriangularSystems(\spad{lp})} returns a list of triangular systems \axiom{[[\spad{ts1},{}\spad{qs1}],{}...,{}[\spad{tsn},{}\spad{qsn}]]} such that the zero set of \axiom{\spad{lp}} is the union of the closures of the \axiom{W_i} where \axiom{W_i} consists of the zeros of \axiom{\spad{ts}} which do not cancel any polynomial in \axiom{qsi}.
745499`\axiom{zeroSetSplit(\spad{lp})} returns a list \axiom{\spad{lts}} of triangular sets such that the zero set of \axiom{\spad{lp}} is the union of the closures of the regular zero sets of the members of \axiom{\spad{lts}}.
745578`\axiom{zeroSetSplit(\spad{lp},{} norm?)} decomposes the variety associated with \axiom{\spad{lp}} into regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in in the output. Note that \axiom{\spad{lp}} needs to generate a zero-dimensional ideal. If \axiom{norm?} is \axiom{\spad{true}} then the regular sets ar
745578`--e normalized.
745734`\axiom{zeroSetSplit(\spad{lp},{} norm?)} decomposes the variety associated with \axiom{\spad{lp}} into square-free regular chains. Thus a point belongs to this variety iff it is a regular zero of a regular set in
745734`-- in the output. Note that \axiom{\spad{lp}} needs to generate a zero-dimensional ideal. If \axiom{norm?} is \axiom{\spad{true}} then the regular sets are normalized.
746030`\axiom{zeroSetSplit(\spad{lp},{}clos?)} has the same specifications as \axiomOpFrom{zeroSetSplit(\spad{lp},{}clos?)}{RegularTriangularSetCategory}.
746125`\spad{zeroSetSplit(lp,{}clos?)} returns \spad{lts} a split of Kalkbrener of the radical ideal associated with \spad{lp}. If \spad{clos?} is \spad{false},{} it is also a decomposition of the variety associated with \spad{lp} into the regular zero set of the \spad{ts} in \spad{lts} (or,{} in other words,{} a split of Lazard of this variety). See the example illustrating the \spadtype{RegularTriangularSet} constru
746125`--ctor for more explanations about decompositions by means of regular triangular sets.
746219`\spad{zeroSetSplit(lp,{}clos?,{}info?)} returns a list \spad{lts} of regular chains such that the union of the closures of their regular zero sets equals the affine variety associated with \spad{lp}. Moreover,{} if \spad{clos?} is \spad{false} then the union of the regular zero set of the \spad{ts} (for \spad{ts} in \spad{lts}) equals this variety. If \spad{info?} i
746219`--s \spad{true} then some information is displayed during the computations. See \axiomOpFrom{zeroSetSplit}{RegularTriangularSet}.
746359`\axiom{zeroSetSplit(\spad{lp},{}clos?,{}info?)} has the same specifications as \axiomOpFrom{zeroSetSplit}{RegularTriangularSetCategory}. Moreover,{} if \axiom{clos?} then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \axiom{info?} then do print messages during the computations.
746453`\axiom{zeroSetSplit(\spad{lp},{}clos?,{}info?)} has the same specifications as \axiomOpFrom{zeroSetSplit}{RegularTriangularSetCategory} from \spadtype{RegularTriangularSetCategory} Moreover,{} if \axiom{clos?} then solves in the sense of the Zariski closure else solves in the sense of the regular zeros. If \axiom{info?} then do print messages during the computations.
746557`\axiom{zeroSetSplit(\spad{lp},{}\spad{b1},{}\spad{b2}.\spad{b3},{}\spad{b4})} is an internal subroutine,{} exported only for developement.
746667`\axiom{zeroSetSplit(\spad{lp},{}\spad{b1},{}\spad{b2}.\spad{b3},{}\spad{b4})} is an internal subroutine,{} exported only for developement.
746787`\spad{zeroSquareMatrix(s,{}p)} \undocumented{}
746881`\spad{zeroVector(s,{}p)} \undocumented{}
747028`\spad{zero(n)} creates a zero vector of length \spad{n}.
747197`\spad{zero(m,{}n)} returns an \spad{m}-by-\spad{n} zero matrix.
747692`\spad{zerosOf(p)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. The \spad{yi}\spad{'s} are expressed in radicals if possible. Otherwise they are implicit algebraic quantities. The returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values. Error: if \spad{p} has more than one variable \spad{y}.
747767`\spad{zerosOf(p)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. The \spad{yi}\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities. The returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
747858`\spad{zerosOf(p)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. The \spad{yi}\spad{'s} are expressed in radicals if possible. The returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values. Error: if \spad{p} has more than one variable.
748206`\spad{zerosOf(p,{} y)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. The \spad{yi}\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities which display as \spad{'yi}. The returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
748304`\spad{zerosOf(p,{} y)} returns \spad{[y1,{}...,{}yn]} such that \spad{p(\spad{yi}) = 0}. The \spad{yi}\spad{'s} are expressed in radicals if possible,{} and otherwise as implicit algebraic quantities which display as \spad{'yi}. The returned symbols \spad{y1},{}...,{}\spad{yn} are bound in the interpreter to respective root values.
748385`\spad{zerosOf(e,{}vars,{}range)} returns a list of points (\axiomType{Doublefloat}) at which a NAG fortran version of \spad{e} will most likely produce an error.
748538`\spad{zoom(x,{}r)} \undocumented
748593`\spad{zoom(v,{}s)} sets the graph scaling factor to \spad{s},{} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
748655`\spad{zoom(x,{}r,{}s)} \undocumented
748731`\spad{zoom(x,{}r,{}s,{}t)} \undocumented
748830`\spad{zoom(v,{}sx,{}sy,{}sz)} sets the graph scaling factors for the \spad{x}-coordinate axis to \spad{sx},{} the \spad{y}-coordinate axis to \spad{sy} and the \spad{z}-coordinate axis to \spad{sz} for the viewport \spad{v},{} which is of the domain \spadtype{ThreeDimensionalViewport}.
748945`\spad{x~=y} tests if \spad{x} and \spad{y} are not equal.
749025`\spad{~(x)} returns the logical complement of \spad{x}.
749057`\spad{~ n} returns the bit-by-bit logical {\em not } of the single integer \spad{n}.
749180`AlgebraPackage assembles a variety of useful functions for general algebras.
749278`This package provides algebraic functions over an integral domain.
749367`algebraic Hermite redution.
749564`This package provides functions for integrating a function on an algebraic curve.
749806`This package provides functions for the integration of algebraic integrands over transcendental functions.
749919`AlgebraicManipulations provides functions to simplify and expand expressions involving algebraic operators.
750385`\spadtype{AnyFunctions1} implements several utility functions for working with \spadtype{Any}. These functions are used to go back and forth between objects of \spadtype{Any} and objects of other types.
750433`This package apply rewrite rules to expressions,{} calling the pattern matcher.
750546`\spad{ApplyUnivariateSkewPolynomial} (internal) allows univariate skew polynomials to be applied to appropriate modules.
750674`\spadtype{AssociatedEquations} provides functions to compute the associated equations needed for factoring operators
750793`Attaching predicates to symbols for pattern matching. Date Created: 21 Mar 1989 Date Last Updated: 23 May 1990
750846`This package provides balanced factorisations of polynomials.
750960`This package exports functions to set some commonly used properties of operators,{} including properties which contain functions.
751025`\spadtype{BezoutMatrix} contains functions for computing resultants and discriminants using Bezout matrices.
751206`\spadtype{BoundIntegerRoots} provides functions to find lower bounds on the integer roots of a polynomial.
751313`\indented{1}{Author: Frederic Lehobey,{} James \spad{H}. Davenport} Date Created: 28 June 1994 Date Last Updated: 11 July 1997 Basic Operations: brillhartIrreducible? Related Domains: Also See: AMS Classifications: Keywords: factorization Examples: References: [1] John Brillhart,{} Note on Irreducibility Testing,{} Mathematics of Computation,{} vol. 35,{} num. 35,{} Oct. 1980,{} 1379-1381 [2] James Davenport,{} On Brillh
751313`--art Irreducibility. To appear. [3] John Brillhart,{} On the Euler and Bernoulli polynomials,{} \spad{J}. Reine Angew. Math.,{} \spad{v}. 234,{} (1969),{} \spad{pp}. 45-64
751397`This package \undocumented{}
751456`This package provides functions to enable conversion of tensors given conversion of the components.
751593`Tools to send a point to infinity on an algebraic curve.
751759`This package implements characteristicPolynomials for monogenic algebras using resultants
751923`This package provides a characteristicPolynomial function for any matrix over a commutative ring.
752003`\indented{1}{Author: Clifton Williamson} Date Created: 9 August 1993 Date Last Updated: 3 December 1993 Basic Operations: chineseRemainder,{} factorList Related Domains: PAdicWildFunctionFieldIntegralBasis(\spad{K},{}\spad{R},{}UP,{}\spad{F}) Also See: WildFunctionFieldIntegralBasis,{} FunctionFieldIntegralBasis AMS Classifications: Keyword
752003`--s: function field,{} finite field,{} integral basis Examples: References: Description:
752169`CoerceVectorMatrixPackage: an unexposed,{} technical package for data conversions
752240`Provides combinatorial functions over an integral domain.
752336`CommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain.
752458`This package exports the elementary operators,{} with some semantics already attached to them. The semantics that is attached here is not dependent on the set in which the operators will be applied.
752505`A package for swapping the order of two variables in a tower of two UnivariatePolynomialCategory extensions.
753216`\spadtype{ComplexRootFindingPackage} provides functions to find all roots of a polynomial \spad{p} over the complex number by using Plesken\spad{'s} idea to calculate in the polynomial ring modulo \spad{f} and employing the Chinese Remainder Theorem. In this first version,{} the precision (see \spadfunFrom{digits}{Float}) is not increased when this is necessary to avoid rounding errors
753216`--. Hence it is the user\spad{'s} responsibility to increase the precision if necessary. Note also,{} if this package is called with \spadignore{e.g.} \spadtype{Fraction Integer},{} the precise calculations could require a lot of time. Also note that evaluating the zeros is not necessarily a good check whether the result is correct: already evaluation can cause rounding errors.
753453`\spadtype{ComplexTrigonometricManipulations} provides function that compute the real and imaginary parts of complex functions.
753586`Solution of linear ordinary differential equations,{} constant coefficient case.
753755`CoordinateSystems provides coordinate transformation functions for plotting. Functions in this package return conversion functions which take points expressed in other coordinate systems and return points with the corresponding Cartesian coordinates.
753822`Enumeration by cycle indices.
753867`This package provides tools for working with cyclic streams.
753954`This package \undocumented{}
754013`\spadtype{DefiniteIntegrationTools} provides common tools used by the definite integration of both rational and elementary functions.
754138`This package \undocumented{}
754229`any solution of a homogeneous linear Diophantine equation can be represented as a sum of minimal solutions,{} which form a "basis" (a minimal solution cannot be represented as a nontrivial sum of solutions) in the case of an inhomogeneous linear Diophantine equation,{} each solution is the sum of a inhomogeneous solution and any number of homogeneous solutions therefore,{} it suffices to compute two sets: \indented{3}{1. all minimal inhomogeneous so
754229`--lutions} \indented{3}{2. all minimal homogeneous solutions} the algorithm implemented is a completion procedure,{} which enumerates all solutions in a recursive depth-first-search it can be seen as finding monotone paths in a graph for more details see Reference
754440`DisplayPackage allows one to print strings in a nice manner,{} including highlighting substrings.
754485`Package for the factorization of a univariate polynomial with coefficients in a finite field. The algorithm used is the "distinct degree" algorithm of Cantor-Zassenhaus,{} modified to use trace instead of the norm and a table for computing Frobenius as suggested by Naudin and Quitte .
754600`This package provides special functions for double precision real and complex floating point.
754657`This package provides functions for computing the residues of a function on an algebraic curve.
754883`Hack for the draw interface. DrawNumericHack provides a "coercion" from something of the form \spad{x = a..b} where \spad{a} and \spad{b} are formal expressions to a binding of the form \spad{x = c..d} where \spad{c} and \spad{d} are the numerical values of \spad{a} and \spad{b}. This "coercion" fails if \spad{a} and \spad{b} contains symbolic variables,{} but is meant for expressions involving \%\spad{pi}.
755048`This is a package for the exact computation of eigenvalues and eigenvectors. This package can be made to work for matrices with coefficients which are rational functions over a ring where we can factor polynomials. Rational eigenvalues are always explicitly computed while the non-rational ones are expressed in terms of their minimal polynomial.
755098`\spadtype{ElementaryFunctionDefiniteIntegration} provides functions to compute definite integrals of elementary functions.
755242`\spad{ElementaryFunctionLODESolver} provides the top-level functions for finding closed form solutions of linear ordinary differential equations and initial value problems.
755425`\spad{ElementaryFunctionODESolver} provides the top-level functions for finding closed form solutions of ordinary differential equations and initial value problems.
755556`This package provides functions to determine the sign of an elementary function around a point or infinity.
755676`ElementaryFunctionStructurePackage provides functions to test the algebraic independence of various elementary functions,{} using the Risch structure theorem (real and complex versions). It also provides transformations on elementary functions which are not considered simplifications.
755809`Provides elementary functions over an integral domain.
755909`This package provides functions for integration,{} limited integration,{} extended integration and the risch differential equation for elemntary functions.
756022`\indented{1}{Risch differential equation,{} elementary case.} Author: Manuel Bronstein Date Created: 12 August 1992 Date Last Updated: 17 August 1992 Keywords: elementary,{} function,{} integration.
756144`\indented{1}{Risch differential equation,{} elementary case.} Author: Manuel Bronstein Date Created: 1 February 1988 Date Last Updated: 2 November 1995 Keywords: elementary,{} function,{} integration.
756259`The elliptic functions \spad{sn},{} \spad{sc} and \spad{dn} are expanded as Taylor series.
756389`This package provides operations for mapping the sides of equations.
756450`ErrorFunctions implements error functions callable from the system interpreter. Typically,{} these functions would be called in user functions. The simple forms of the functions take one argument which is either a string (an error message) or a list of strings which all together make up a message. The list can contain formatting codes (see below). The more sophisticated versions takes two arguments where the first argument is the name of the function from which
756450`-- the error was invoked and the second argument is either a string or a list of strings,{} as above. When you use the one argument version in an interpreter function,{} the system will automatically insert the name of the function as the new first argument. Thus in the user interpreter function \indented{2}{\spad{f x == if x < 0 then error "negative argument" else x}} the call to error will actually be of the form \indented{2}{\spad{error("f",{}"negative argument")}} because the interpreter wil
756450`--l have created a new first argument. \blankline Formatting codes: error messages may contain the following formatting codes (they should either start or end a string or else have blanks around them): \indented{3}{\spad{\%l}\space{6}start a new line} \indented{3}{\spad{\%b}\space{6}start printing in a bold font (where available)} \indented{3}{\spad{\%d}\space{6}stop\space{2}printing in a bold font (where available)} \indented{3}{\spad{ \%ceon}\space{2}start centering message lines} \indented{3}
756450`--{\spad{\%ceoff}\space{2}stop\space{2}centering message lines} \indented{3}{\spad{\%rjon}\space{3}start displaying lines "ragged left"} \indented{3}{\spad{\%rjoff}\space{2}stop\space{2}displaying lines "ragged left"} \indented{3}{\spad{\%i}\space{6}indent\space{3}following lines 3 additional spaces} \indented{3}{\spad{\%u}\space{6}unindent following lines 3 additional spaces} \indented{3}{\spad{\%xN}\space{5}insert \spad{N} blanks (eg,{} \spad{\%x10} inserts 10 blanks)} \blankline
756493`\spadtype{EuclideanGroebnerBasisPackage} computes groebner bases for polynomial ideals over euclidean domains. The basic computation provides a distinguished set of generators for these ideals. This basis allows an easy test for membership: the operation \spadfun{euclideanNormalForm} returns zero on ideal members.
756493`-- The string "info" and "redcrit" can be given as additional args to provide incremental information during the computation. If "info" is given,{} \indented{1}{a computational summary is given for each \spad{s}-polynomial. If "redcrit"} is given,{} the reduced critical pairs are printed. The term ordering is determined by the polynomial type used. Suggested types include \spadtype{DistributedMultivariatePolynomial},{} \spadtype{HomogeneousDistributedMultivariatePolynomial},{} \spadtype{GeneralD
756493`--istributedMultivariatePolynomial}.
756686`This package is to be used in conjuction with \indented{12}{the CycleIndicators package. It provides an evaluation} \indented{12}{function for SymmetricPolynomials.}
757090`Lifting of maps to Expressions. Date Created: 16 Jan 1989 Date Last Updated: 22 Jan 1990
757167`This package allows a map from any expression space into any object to be lifted to a kernel over the expression set,{} using a given property of the operator of the kernel.
757246`This package allows a mapping \spad{E} \spad{->} \spad{F} to be lifted to a kernel over \spad{E}; This lifting can fail if the operator of the kernel cannot be applied in \spad{F}; Do not use this package with \spad{E} = \spad{F},{} since this may drop some properties of the operators.
757336`Taylor series solutions of explicit ODE\spad{'s}.
757437`\spadtype{ExpressionToOpenMath} provides support for converting objects of type \spadtype{Expression} into OpenMath.
757508`This package provides functions to convert functional expressions to power series.
757638`\indented{1}{Author: Clifton \spad{J}. Williamson} Date Created: Bastille Day 1989 Date Last Updated: 5 June 1990 Keywords: Examples: Package for constructing tubes around 3-dimensional parametric curves.
757688`This is just an interface between several packages and domains. The goal is to compute lexicographical Groebner bases of sets of polynomial with type \spadtype{Polynomial R} by the {\em FGLM} algorithm if this is possible (\spadignore{i.e.} if the input system generates a zero-dimensional ideal).
757764`\spadtype{FactoredFunctionUtilities} implements some utility functions for manipulating factored objects.
757836`\spadtype{FactoredFunctions2} contains functions that involve factored objects whose underlying domains may not be the same. For example,{} \spadfun{map} might be used to coerce an object of type \spadtype{Factored(Integer)} to \spadtype{Factored(Complex(Integer))}.
757917`computes various functions on factored arguments.
757983`This package provides utilities used by the factorizers which operate on polynomials represented as univariate polynomials with multivariate coefficients.
758117`\indented{1}{Finds the order of a divisor over a finite field} Author: Manuel Bronstein Date Created: 1988 Date Last Updated: 11 Jul 1990
758311`\indented{1}{Lift a map to finite divisors.} Author: Manuel Bronstein Date Created: 1988 Date Last Updated: 19 May 1993
758665`FiniteFieldFunctions(\spad{GF}) is a package with functions concerning finite extension fields of the finite ground field {\em GF},{} \spadignore{e.g.} Zech logarithms.
758735`FiniteFieldHomomorphisms(\spad{F1},{}\spad{GF},{}\spad{F2}) exports coercion functions of elements between the fields {\em F1} and {\em F2},{} which both must be finite simple algebraic extensions of the finite ground field {\em GF}.
758891`\spad{FiniteFieldPolynomialPackage2}(\spad{F},{}\spad{GF}) exports some functions concerning finite fields,{} which depend on a finite field {\em GF} and an algebraic extension \spad{F} of {\em GF},{} \spadignore{e.g.} a zero of a polynomial over {\em GF} in \spad{F}.
759018`This package provides a number of functions for generating,{} counting and testing irreducible,{} normal,{} primitive,{} random polynomials over finite fields.
759266`\spad{FiniteLinearAggregateFunctions2} provides functions involving two FiniteLinearAggregates where the underlying domains might be different. An example of this might be creating a list of rational numbers by mapping a function across a list of integers where the function divides each integer by 1000.
759403`This package exports 3 sorting algorithms which work over FiniteLinearAggregates.
759507`\spad{FiniteSetAggregateFunctions2} provides functions involving two finite set aggregates where the underlying domains might be different. An example of this is to create a set of rational numbers by mapping a function across a set of integers,{} where the function divides each integer by 1000.
759786`\spadtype{FortranCodePackage1} provides some utilities for producing useful objects in FortranCode domain. The Package may be used with the FortranCode domain and its \spad{printCode} or possibly via an outputAsFortran. (The package provides items of use in connection with ASPs in the AXIOM-NAG link and,{} where appropriate,{} naming accords with that in IRENA.) The easy-to-use functions use Fortran loop variables \spad{I1},{} \spad{I2},{} and it is users
759786`--' responsibility to check that this is sensible. The advanced functions use SegmentBinding to allow users control over Fortran loop variable names.
759835`Code to manipulate Fortran Output Stack
759887`provides an interface to the boot code for calling Fortran
759929`This package extends a map between integral domains to a map between Fractions over those domains by applying the map to the numerators and denominators.
760012`\indented{1}{Lifting of morphisms to fractional ideals.} Author: Manuel Bronstein Date Created: 1 Feb 1989 Date Last Updated: 27 Feb 1990 Keywords: ideal,{} algebra,{} module.
760329`\spad{FramedNonAssociativeAlgebraFunctions2} implements functions between two framed non associative algebra domains defined over different rings. The function map is used to coerce between algebras over different domains having the same structural constants.
760508`Lifts a map from rings to function fields over them.
760911`In this package \spad{R} is a Euclidean domain and \spad{F} is a framed algebra over \spad{R}. The package provides functions to compute the integral closure of \spad{R} in the quotient field of \spad{F}. It is assumed that \spad{char(R/P) = char(R)} for any prime \spad{P} of \spad{R}. A typical instance of this is when \spad{R = K[x]} and \spad{F} is a func
760911`--tion field over \spad{R}.
761059`Attaching assertions to symbols for pattern matching; Date Created: 21 Mar 1989 Date Last Updated: 23 May 1990
761149`Attaching predicates to symbols for pattern matching. Date Created: 21 Mar 1989 Date Last Updated: 23 May 1990
761255`\spadtype{FunctionSpaceComplexIntegration} provides functions for the indefinite integration of complex-valued functions.
761391`This package allows a mapping \spad{R} \spad{->} \spad{S} to be lifted to a mapping from a function space over \spad{R} to a function space over \spad{S}.
761521`\spadtype{FunctionSpaceIntegration} provides functions for the indefinite integration of real-valued functions.
761649`FunctionsSpacePrimitiveElement provides functions to compute primitive elements in functions spaces.
761760`This package provides function which replaces transcendental kernels in a function space by random integers. The correspondence between the kernels and the integers is fixed between calls to new().
761854`computes sums of top-level expressions.
761959`This package converts expressions in some function space to exponential expansions.
762113`This package converts expressions in some function space to power series in a variable \spad{x} with coefficients in that function space. The function \spadfun{exprToUPS} converts expressions to power series whose coefficients do not contain the
762113`-- variable \spad{x}. The function \spadfun{exprToGenUPS} converts functional expressions to power series whose coefficients may involve functions of \spad{log(x)}.
762376`\indented{1}{Used internally by IR2F} Author: Manuel Bronstein Date Created: 12 May 1988 Date Last Updated: 22 September 1993 Keywords: function,{} space,{} polynomial,{} factoring
762535`Provides some special functions over an integral domain.
762636`\spadtype{GaloisGroupFactorizationUtilities} provides functions that will be used by the factorizer.
762782`\spadtype{GaloisGroupFactorizer} provides functions to factor resolvents.
762875`\spadtype{GaloisGroupPolynomialUtilities} provides useful functions for univariate polynomials which should be added to \spadtype{UnivariatePolynomialCategory} or to \spadtype{Factored} (July 1994).
762984`\spadtype{GaloisGroupUtilities} provides several useful functions.
763042`Package for the factorization of complex or gaussian integers.
763102`\indented{1}{Author : \spad{P}.Gianni.} January 1990 The equation \spad{Af+Bg=h} and its generalization to \spad{n} polynomials is solved for solutions over the \spad{R},{} euclidean domain. A table containing the solutions of \spad{Af+Bg=x**k} is used. The operations are performed modulus a prime which are in principle big enough,{} but the solutions are tested and,{} in case of failure,{} a hensel liftin
763102`--g process is used to get to the right solutions. It will be used in the factorization of multivariate polynomials over finite field,{} with \spad{R=F[x]}.
763201`\indented{1}{Description} This package provides operations for the factorization of univariate polynomials with integer coefficients. The factorization is done by "lifting" the finite "berlekamp's" factorization
763264`\indented{1}{Author : \spad{P}.Gianni} General Hensel Lifting Used for Factorization of bivariate polynomials over a finite field.
763376`This package provides operations for \spad{GCD} computations on polynomials
763546`\indented{2}{This is the top level package for doing multivariate factorization} over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.
763732`\spadtype{GenerateUnivariatePowerSeries} provides functions that create power series from explicit formulas for their \spad{n}th coefficient.
763861`This internal package rationalises integrands on curves of the form: \indented{2}{\spad{y\^2 = a x\^2 + b x + c}} \indented{2}{\spad{y\^2 = (a x + b) / (c x + d)}} \indented{2}{\spad{f(x,{} y) = 0} where \spad{f} has degree 1 in \spad{x}} The rationalization is done for integration,{} limited integration,{} extended integration and the risch differential equation.
763981`Gosper\spad{'s} summation algorithm.
764171`TwoDimensionalPlotSettings sets global flags and constants for 2-dimensional plotting.
764216`GrayCode provides a function for efficiently running through all subsets of a finite set,{} only changing one element by another one.
764252`\spadtype{GroebnerFactorizationPackage} provides the function groebnerFactor" which uses the factorization routines of \Language{} to factor each polynomial under consideration while doing the groebner basis algorithm. Then it writes the ideal as an intersection of ideals determined by the irreducible factors.
764252`-- Note that the whole ring may occur as well as other redundancies. We also use the fact,{} that from the second factor on we can assume that the preceding factors are not equal to 0 and we divide all polynomials under considerations by the elements of this list of "nonZeroRestrictions". The result is a list of groebner bases,{} whose union of solutions of the corresponding systems of equations is the solution of the system of equation corresponding to the input list. The term ordering is deter
764252`--mined by the polynomial type used. Suggested types include \spadtype{DistributedMultivariatePolynomial},{} \spadtype{HomogeneousDistributedMultivariatePolynomial},{} \spadtype{GeneralDistributedMultivariatePolynomial}.
764449`\indented{1}{Author:} Date Created: Date Last Updated: Keywords: Description This package provides low level tools for Groebner basis computations
764630`\spadtype{GroebnerPackage} computes groebner bases for polynomial ideals. The basic computation provides a distinguished set of generators for polynomial ideals over fields. This basis allows an easy test for membership: the operation \spadfun{normalForm} returns zero on ideal members. When the provided coefficient domain,{} Dom,{} is not 
764630`--a field,{} the result is equivalent to considering the extended ideal with \spadtype{Fraction(Dom)} as coefficients,{} but considerably more efficient since all calculations are performed in Dom. Additional argument "info" and "redcrit" can be given to provide incremental information during computation. Argument "info" produces a computational summary for each \spad{s}-polynomial. Argument "redcrit" prints out the reduced critical pairs. The term ordering is determined by the polynomial type u
764630`--sed. Suggested types include \spadtype{DistributedMultivariatePolynomial},{} \spadtype{HomogeneousDistributedMultivariatePolynomial},{} \spadtype{GeneralDistributedMultivariatePolynomial}.
764797`\indented{1}{Author : \spad{P}.Gianni,{} Summer \spad{'88},{} revised November \spad{'89}} Solve systems of polynomial equations using Groebner bases Total order Groebner bases are computed and then converted to lex ones This package is mostly intended for internal use.
764884`\indented{1}{Author : Larry Lambe} Date Created : August 1988 Date Last Updated : March 9 1990 Related Constructors: OrderedSetInts,{} Commutator,{} FreeNilpotentLie AMS Classification: Primary 17B05,{} 17B30; Secondary 17A50 Keywords: free Lie algebra,{} Hall basis,{} basic commutators Description : Generate a basis for the free Lie algebra on \spad{n} generators over a ring \spad{R} with identity up to basic commutators of length \spad{c} using the algorithm of \spad
764884`--{P}. Hall as given in Serre\spad{'s} book Lie Groups \spad{
764884`--} Lie Algebras
764919`This package provides the functions for the heuristic integer \spad{gcd}. Geddes\spad{'s} algorithm,{}for univariate polynomials with integer coefficients
764996`\indented{2}{This package provides functions for the primary decomposition of} polynomial ideals over the rational numbers. The ideals are members of the \spadtype{PolynomialIdeals} domain,{} and the polynomial generators are required to be from the \spadtype{DistributedMultivariatePolynomial} domain.
765093`This package provides operations to create incrementing functions.
765160`This package computes infinite products of univariate Taylor series over an integral domain of characteristic 0.
765305`This package computes infinite products of univariate Taylor series over an arbitrary finite field.
765499`This package computes infinite products of univariate Taylor series over a field of prime order.
765627`Functions defined on streams with entries in two sets.
765696`Functions defined on streams with entries in two sets.
765774`Default infinity signatures for the interpreter; Date Created: 4 Oct 1989 Date Last Updated: 4 Oct 1989
765978`InnerCommonDenominator provides functions to compute the common denominator of a finite linear aggregate of elements of the quotient field of an integral domain.
766135`\spadtype{InnerMatrixLinearAlgebraFunctions} is an internal package which provides standard linear algebra functions on domains in \spad{MatrixCategory}
766305`\spadtype{InnerMatrixQuotientFieldFunctions} provides functions on matrices over an integral domain which involve the quotient field of that integral domain. The functions rowEchelon and inver
766305`--se return matrices with entries in the quotient field.
766906`InnerNormalBasisFieldFunctions(\spad{GF}) (unexposed): This package has functions used by every normal basis finite field extension domain.
767174`Find the sign of a polynomial around a point or infinity.
767265`tools for the summation packages.
767398`This package provides transformations from trigonometric functions to exponentials and logarithms,{} and back. \spad{F} and \spad{FG} should be the same type of function space.
767563`Tools for manipulating input forms.
767620`This package provides functions to lookup bits in integers
767737`\indented{1}{This Package contains basic methods for integer factorization.} The factor operation employs trial division up to 10,{}000. It then tests to see if \spad{n} is a perfect power before using Pollards rho method. Because Pollards method may fail,{} the result of factor may contain composite factors. We should also employ Lenstra\spad{'s} eliptic curve method.
767817`Test for linear dependence over the integers.
767961`The \spadtype{IntegerPrimesPackage} implements a modification of Rabin\spad{'s} probabilistic primality test and the utility functions \spadfun{nextPrime},{} \spadfun{prevPrime} and \spadfun{primes}.
768033`Provides integer testing and retraction functions. Date Created: March 1990 Date Last Updated: 9 April 1991
768106`The \spadtype{IntegerRoots} package computes square roots and \indented{2}{\spad{n}th roots of integers efficiently.}
768169`This package provides the implementation for the \spadfun{solveLinearPolynomialEquation} operation over the integers. It uses a lifting technique from the package GenExEuclid
768236`IntegralBasisPolynomialTools provides functions for \indented{1}{mapping functions on the coefficients of univariate and bivariate} \indented{1}{polynomials.}
768388`This package contains functions used in the packages FunctionFieldIntegralBasis and NumberFieldIntegralBasis.
768527`\indented{1}{Internally used by the integration packages} Author: Manuel Bronstein Date Created: 1987 Date Last Updated: 12 August 1992 Keywords: integration.
768599`\indented{2}{This package allows a sum of logs over the roots of a polynomial} \indented{2}{to be expressed as explicit logarithms and arc tangents,{} provided} \indented{2}{that the indexing polynomial can be factored into quadratics.} Date Created: 21 August 1988 Date Last Updated: 4 October 1993
768680`This package allows a sum of logs over the roots of a polynomial to be expressed as explicit logarithms and arc tangents,{} provided that the indexing polynomial can be factored into quadratics.
768809`\indented{1}{Tools for the integrator} Author: Manuel Bronstein Date Created: 25 April 1990 Date Last Updated: 9 June 1993 Keywords: elementary,{} function,{} integration.
768893`A package to print strings without line-feed nor carriage-return.
768944`\indented{1}{An internal package for computing the rational univariate representation} \indented{1}{of a zero-dimensional algebraic variety given by a square-free} \indented{1}{triangular set.} \indented{1}{The main operation is \axiomOpFrom{rur}{InternalRationalUn
768944`--ivariateRepresentationPackage}.} \indented{1}{It is based on the {\em generic} algorithm description in [1]. \newline References:} [1] \spad{D}. LAZARD "Solving Zero-dimensional Algebraic Systems" \indented{4}{Journal of Symbolic Computation,{} 1992,{} 13,{} 117-131}
769187`This package computes the inverse Laplace Transform.
769317`IrrRepSymNatPackage contains functions for computing the ordinary irreducible representations of symmetric groups on \spad{n} letters {\em {1,{}2,{}...,{}n}} in Young\spad{'s} natural form and their dimensions. These representations can be labelled by number partitions of \spad{n},{} \spadignore{i.e.} a weakly decreasing sequence of integers summing up to \spad{n},{} \spadignore{e.g.} {\em [3,{}3,{}3,{}1]} labels an irreducible representation for \spad{n} e
769317`--quals 10. Note: whenever a \spadtype{List Integer} appears in a signature,{} a partition required.
769364`This package exports the function generateIrredPoly that computes a monic irreducible polynomial of degree \spad{n} over a finite field.
769443`This package exports some auxiliary functions on kernels
769518`\spadtype{Kovacic} provides a modified Kovacic\spad{'s} algorithm for solving explicitely irreducible 2nd order linear ordinary differential equations.
769627`This package computes the forward Laplace Transform.
769749`A package for solving polynomial systems by means of Lazard triangular sets [1]. This package provides two operations. One for solving in the sense of the regular zeros,{} and the other for solving in the sense of the Zariski closure. Both produce square-free reg
769749`--ular sets. Moreover,{} the decompositions do not contain any redundant component. However,{} only zero-dimensional regular sets are normalized,{} since normalization may be time consumming in positive dimension. The decomposition process is that of [2].\newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991} \indented{1}{[2] \spad{M}. MORENO MAZA "A new algorithm for computing t
769749`--riangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
769994`Package for leading coefficient determination in the lifting step. Package working for every \spad{R} euclidean with property \spad{"F"}.
770146`A package for solving polynomial systems with finitely many solutions. The decompositions are given by means of regular triangular sets. The computations use lexicographical Groebner bases. The main operations are \axiomOpFrom{lexTriangular}{LexTriangularPackage} and \axiomOpFrom{squareFreeLexTriangular}{LexTriangularPackage}. The second one provide decompositions by means of square-free regular triangular sets. Both are 
770146`--based on the {\em lexTriangular} method described in [1]. They differ from the algorithm described in [2] by the fact that multiciplities of the roots are not kept. With the \axiomOpFrom{squareFreeLexTriangular}{LexTriangularPackage} operation all multiciplities are removed. With the other operation some multiciplities may remain. Both operations admit an optional argument to produce normalized triangular sets. \newline
770229`\indented{1}{Given a Groebner basis \spad{B} with respect to the total degree ordering for} a zero-dimensional ideal \spad{I},{} compute a Groebner basis with respect to the lexicographical ordering by using linear algebra.
770307`Test for linear dependence.
770404`\spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a factorizer for linear ordinary differential operators whose coefficients are rational functions.
770535`\spad{LinearOrdinaryDifferentialOperatorsOps} provides symmetric products and sums for linear ordinary differential operators.
770664`Given a PolynomialFactorizationExplicit ring,{} this package provides a defaulting rule for the \spad{solveLinearPolynomialEquation} operation,{} by moving into the field of fractions,{} and solving it there via the \spad{multiEuclidean} operation.
770764`This package solves linear system in the matrix form \spad{AX = B}. It is essentially a particular instantiation of the package \spadtype{LinearSystemMatrixPackage} for Matrix and Vector. This package\spad{'s} existence makes it easier to use \spadfun{solve} in the AXIOM interpreter.
770827`This package solves linear system in the matrix form \spad{AX = B}.
771006`this package finds the solutions of linear systems presented as a list of polynomials.
771158`This package provides liouvillian functions over an integral domain.
771432`\indented{1}{Utilities for MPolyCat} Author: Manuel Bronstein Date Created: 1987 Date Last Updated: 28 March 1990 (\spad{PG})
771657`This package \undocumented
771896`\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are polynomials over some ring \spad{R} over which we can factor. It is used internally by packages such as the solve package which need to work with polynomials in a specific set of variables with coefficients which are polynom
771896`--ials in all the other variables.
772069`\indented{3}{This package exports a factor operation for multivariate polynomials} with coefficients which are rational functions over some ring \spad{R} over which we can factor. It is used internally by packages such as primary decomposition which need to work with polynomials with rational function coefficient
772069`--s,{} \spadignore{i.e.} themselves fractions of polynomials.
772263`\indented{1}{MRationalFactorize contains the factor function for multivariate} polynomials over the quotient field of a ring \spad{R} such that the package MultivariateFactorize can factor multivariate polynomials over \spad{R}.
772428`transforms top-level objects into compiled functions.
772544`MakeFloatCompiledFunction transforms top-level objects into compiled Lisp functions whose arguments are Lisp floats. This by-passes the \Language{} compiler and interpreter,{} thereby gaining several orders of magnitude.
772627`transforms top-level objects into interpreter functions.
772696`MakeRecord is used internally by the interpreter to create record types which are used for doing parallel iterations on streams.
772754`transforms top-level objects into compiled functions.
772856`various Currying operations.
772916`various Currying operations.
772992`various Currying operations.
773084`various Currying operations.
773158`various Currying operations.
773248`various Currying operations.
773354`\spadtype{MatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \spadfun{map} and \spadfun{reduce}.
773645`MatrixCommonDenominator provides functions to compute the common denominator of a matrix of elements of the quotient field of an integral domain.
773745`\spadtype{MatrixLinearAlgebraFunctions} provides functions to compute inverses and canonical forms.
773919`This package exports tools for merging lists
773972`\indented{1}{<description of package>} Author: Jim Wen Date Created: \spad{??} Date Last Updated: October 1991 by Jon Steinbach Keywords: Examples: References:
774038`This package supports factorization and gcds of univariate polynomials over the integers modulo different primes. The inputs are given as polynomials over the integers with the prime passed explicitly as an extra argument.
774140`\indented{1}{Modular hermitian row reduction.} Author: Manuel Bronstein Date Created: 22 February 1989 Date Last Updated: 24 November 1993 Keywords: matrix,{} reduction.
774218`\spad{MonoidRingFunctions2} implements functions between two monoid rings defined with the same monoid over different rings.
774293`Tools for handling monomial extensions.
774395`\spadtype{MoreSystemCommands} implements an interface with the system command facility. These are the commands that are issued from source files or the system interpreter and they start with a close parenthesis,{} \spadignore{e.g.} \spadsyscom{what} commands.
774444`Package for factorization of multivariate polynomials over finite fields.
774597`\indented{1}{\spadtype{MultiVariableCalculusFunctions} Package provides several} \indented{1}{functions for multivariable calculus.} These include gradient,{} hessian and jacobian,{} divergence and laplacian. Various forms for banded and sparse storage of matrices are included.
774785`Lifting of a map through 2 levels of polynomials.
775213`This package provides the functions for the multivariate "lifting",{} using an algorithm of Paul Wang. This package will work for every euclidean domain \spad{R} which has property \spad{F},{} \spadignore{i.e.} there exists a factor operation in \spad{R[x]}.
775357`Author : \spad{P}.Gianni This package provides the functions for the computation of the square free decomposition of a multivariate polynomial. It uses the package GenExEuclid for the resolution of the equation \spad{Af + Bg = h} and its generalization to \spad{n} polynomials over an integral domain and the package \spad{MultivariateLifting} for the "multi
775357`--variate" lifting.
775507`Support functions for the NAG Library Link functions
775557`Package for the determination of the coefficients in the lifting process. Used by \spadtype{MultivariateLifting}. This package will work for every euclidean domain \spad{R} which has property \spad{F},{} \spadignore{i.e.} there exists a factor operation in \spad{R[x]}.
775724`This package uses the NAG Library to compute \begin{items} \item eigenvalues and eigenvectors of a matrix \item eigenvalues and eigenvectors of generalized matrix eigenvalue problems \item singular values and singular vectors of a matrix. \end{items} See \downlink{Manual Page}{\spad{manpageXXf02}}.
775769`This package uses the NAG Library to find a function which approximates a set of data points. Typically the data contain random errors,{} as of experimental measurement,{} which need to be smoothed out. To seek an approximation to the data,{} it is first necessary to specify for the approximating function a mathematical form (a polynomial,{} for example) which contains a number of unspecified coefficients: the appropriate fitting routine then derives for th
775769`--e coefficients the values which provide the best fit of that particular form. The package deals mainly with curve and surface fitting (\spadignore{i.e.} fitting with functions of one and of two variables) when a polynomial or a cubic spline is used as the fitting function,{} since these cover the most common needs. However,{} fitting with other functions and/or more variables can be undertaken by means of general linear or nonlinear routines (some of which are contained in other packages) depe
775769`--nding on whether the coefficients in the function occur linearly or nonlinearly. Cases where a graph rather than a set of data points is given can be treated simply by first reading a suitable set of points from the graph. The package also contains routines for evaluating,{} differentiating and integrating polynomial and spline curves and surfaces,{} once the numerical values of their coefficients have been determined. See \downlink{Manual Page}{\spad{manpageXXe02}}.
775816`This package uses the NAG Library to calculate the numerical value of definite integrals in one or more dimensions and to evaluate weights and abscissae of integration rules. See \downlink{Manual Page}{\spad{manpageXXd01}}.
775867`This package uses the NAG Library to calculate the interpolation of a function of one or two variables. When provided with the value of the function (and possibly one or more of its lowest-order derivatives) at each of a number of values of the variable(\spad{s}),{} the routines provide either an interpolating function or an interpolated value. For some of the interpolating functions,{} there are supporting routines to evaluate,{} differentiate or int
775867`--egrate them. See \downlink{Manual Page}{\spad{manpageXXe01}}.
775920`This package uses the NAG Library to compute matrix factorizations,{} and to solve systems of linear equations following the matrix factorizations. See \downlink{Manual Page}{\spad{manpageXXf07}}.
775959`This package uses the NAG Library to solve the matrix equation \axiom{AX=B},{} where \axiom{\spad{B}} may be a single vector or a matrix of multiple right-hand sides. The matrix \axiom{A} may be real,{} complex,{} symmetric,{} Hermitian positive- definite,{} or sparse. It may also be rectangular,{} in which case a least-squares solution is obtained. See \downlink{Manual Page}{\spad{manpageXXf04}}.
776020`This package uses the NAG Library to provide facilities for matrix factorizations and associated transformations. See \downlink{Manual Page}{\spad{manpageXXf01}}.
776076`This package uses the NAG Library to perform optimization. An optimization problem involves minimizing a function (called the objective function) of several variables,{} possibly subject to restrictions on the values of the variables defined by a set of constraint functions. The routines in the NAG Foundation Library are concerned with function minimization only,{} since the problem of maximizing a given function can be transformed into a minimization 
776076`--problem simply by multiplying the function by \spad{-1}. See \downlink{Manual Page}{\spad{manpageXXe04}}.
776128`This package uses the NAG Library to calculate the numerical solution of ordinary differential equations. There are two main types of problem,{} those in which all boundary conditions are specified at one point (initial-value problems),{} and those in which the boundary conditions are distributed between two or more points (boundary- value problems and eigenvalue problems). Routines are available for initial-value problems,{} two-point
776128`-- boundary-value problems and Sturm-Liouville eigenvalue problems. See \downlink{Manual Page}{\spad{manpageXXd02}}.
776197`This package uses the NAG Library to solve partial differential equations. See \downlink{Manual Page}{\spad{manpageXXd03}}.
776265`This package uses the NAG Library to compute the zeros of a polynomial with real or complex coefficients. See \downlink{Manual Page}{\spad{manpageXXc02}}.
776320`This package uses the NAG Library to calculate real zeros of continuous real functions of one or more variables. (Complex equations must be expressed in terms of the equivalent larger system of real equations.) See \downlink{Manual Page}{\spad{manpageXXc05}}.
776371`This package uses the NAG Library to calculate the discrete Fourier transform of a sequence of real or complex data values,{} and applies it to calculate convolutions and correlations. See \downlink{Manual Page}{\spad{manpageXXc06}}.
776426`This package uses the NAG Library to compute some commonly occurring physical and mathematical functions. See \downlink{Manual Page}{manpageXXs}.
776480`This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from sparse univariate polynomial over \spad{R} to a sparse univariate polynomial over \spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.
776564`This package provides a division and related operations for \spadtype{MonogenicLinearOperator}\spad{s} over a \spadtype{Field}. Since the multiplication is in general non-commutative,{} these operations all have left- and right-hand versions. This package provides the operations based on left-division.
776661`NonLinearFirstOrderODESolver provides a function for finding closed form first integrals of nonlinear ordinary differential equations of order 1.
776793`NonLinearSolvePackage is an interface to \spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving. The solutions are given in the algebraic closure of \spad{R} whenever possible.
776862`\spadtype{NoneFunctions1} implements functions on \spadtype{None}. It particular it includes a particulary dangerous coercion from any other type to \spadtype{None}.
777085`This package \undocumented
777310`A package for computing normalized assocites of univariate polynomials with coefficients in a tower of simple extensions of a field.\newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991} \indented{1}
777310`--{[2] \spad{M}. MORENO MAZA and \spad{R}. RIOBOO "Computations of \spad{gcd} over} \indented{5}{algebraic towers of simple extensions" In proceedings of \spad{AAECC11}} \indented{5}{Paris,{} 1995.} \indented{1}{[3] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \spad{P}.etM. Curie,{} Paris,{} 1997.}
777500`In this package \spad{F} is a framed algebra over the integers (typically \spad{F = Z[a]} for some algebraic integer a). The package provides functions to compute the integral closure of \spad{Z} in the quotient quotient field of \spad{F}.
777628`NumberFormats provides function to format and read arabic and roman numbers,{} to convert numbers to strings and to read floating-point numbers.
777671`This package provides polynomials as functions on a ring.
777822`\spadtype{NumericContinuedFraction} provides functions \indented{2}{for converting floating point numbers to continued fractions.}
777965`\indented{1}{Author: Clifton \spad{J}. Williamson} Date Created: Bastille Day 1989 Date Last Updated: 5 June 1990 Keywords: Examples: Package for constructing tubes around 3-dimensional parametric curves.
778045`Numeric provides real and complex numerical evaluation functions for various symbolic types.
778106`This package is a suite of functions for the numerical integration of an ordinary differential equation of \spad{n} variables: \blankline \indented{8}{\center{dy/dx = \spad{f}(\spad{y},{}\spad{x})\space{5}\spad{y} is an \spad{n}-vector}} \blankline \par All the routines are based on a 4-th order Runge-Kutta kernel. These routines generally have as arguments: \spad{n},{} the number of dependent variables; \spad{x1},{} the initial point; 
778106`--\spad{h},{} the step size; \spad{y},{} a vector of initial conditions of length \spad{n} which upon exit contains the solution at \spad{x1 + h}; \spad{derivs},{} a function which computes the right hand side of the ordinary differential equation: \spad{derivs(dydx,{}y,{}x)} computes \spad{dydx},{} a vector which contains the derivative information. \blankline \par In order of increasing complexity:\begin{items} \blankline \item \spad{rk4(y,{}n,{}x1,{}h,{}derivs)} advances the solution vector t
778106`--o \spad{x1 + h} and return the values in \spad{y}. \blankline \item \spad{rk4(y,{}n,{}x1,{}h,{}derivs,{}t1,{}t2,{}t3,{}t4)} is the same as \spad{rk4(y,{}n,{}x1,{}h,{}derivs)} except that you must provide 4 scratch arrays \spad{t1}-\spad{t4} of size \spad{n}. \blankline \item Starting with \spad{y} at \spad{x1},{} \spad{rk4f(y,{}n,{}x1,{}x2,{}ns,{}derivs)} uses \spad{ns} fixed steps of a 4-th order Runge-Kutta integrator to advance the solution vector to \spad{x2} and return the values in \spad
778106`--{y}. Argument \spad{x2},{} is the final point,{} and \spad{ns},{} the number of steps to take. \blankline \item \spad{rk4qc(y,{}n,{}x1,{}step,{}eps,{}yscal,{}derivs)} takes a 5-th order Runge-Kutta step with monitoring of local truncation to ensure accuracy and adjust stepsize. The function takes two half steps and one full step and scales the difference in solutions at the final point. If the error is within \spad{eps},{} the step is taken and the result is returned. If the error is not withi
778106`--n \spad{eps},{} the stepsize if decreased and the procedure is tried again until the desired accuracy is reached. Upon input,{} an trial step size must be given and upon return,{} an estimate of the next step size to use is returned as well as the step size which produced the desired accuracy. The scaled error is computed as \center{\spad{error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))}} and this is compared against \spad{eps}. If this is greater than \spad{eps},{} the step size is reduced
778106`-- accordingly to \center{\spad{hnew = 0.9 * hdid * (error/eps)**(-1/4)}} If the error criterion is satisfied,{} then we check if the step size was too fine and return a more efficient one. If \spad{error > \spad{eps} * (6.0E-04)} then the next step size should be \center{\spad{hnext = 0.9 * hdid * (error/\spad{eps})\spad{**}(\spad{-1/5})}} Otherwise \spad{hnext = 4.0 * hdid} is returned. A more detailed discussion of this and related topics can be found in the book "Numerical Recipies" by \spad
778106`--{W}.Press,{} \spad{B}.\spad{P}. Flannery,{} \spad{S}.A. Teukolsky,{} \spad{W}.\spad{T}. Vetterling published by Cambridge University Press. Argument \spad{step} is a record of 3 floating point numbers \spad{(try ,{} did ,{} next)},{} \spad{eps} is the required accuracy,{} \spad{yscal} is the scaling vector for the difference in solutions. On input,{} \spad{step.try} should be the guess at a step size to achieve the accuracy. On output,{} \spad{step.did} contains the step size which achieved th
778106`--e accuracy and \spad{step.next} is the next step size to use. \blankline \item \spad{rk4qc(y,{}n,{}x1,{}step,{}eps,{}yscal,{}derivs,{}t1,{}t2,{}t3,{}t4,{}t5,{}t6,{}t7)} is the same as \spad{rk4qc(y,{}n,{}x1,{}step,{}eps,{}yscal,{}derivs)} except that the user must provide the 7 scratch arrays \spad{t1-t7} of size \spad{n}. \blankline \item \spad{rk4a(y,{}n,{}x1,{}x2,{}eps,{}h,{}ns,{}derivs)} is a driver program which uses \spad{rk4qc} to integrate \spad{n} ordinary differential equations start
778106`--ing at \spad{x1} to \spad{x2},{} keeping the local truncation error to within \spad{eps} by changing the local step size. The scaling vector is defined as \center{\spad{yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny}} where \spad{y(i)} is the solution at location \spad{x},{} \spad{dydx} is the ordinary differential equation\spad{'s} right hand side,{} \spad{h} is the current step size and \spad{tiny} is 10 times the smallest positive number representable. The user must supply an estimate for a t
778106`--rial step size and the maximum number of calls to \spad{rk4qc} to use. Argument \spad{x2} is the final point,{} \spad{eps} is local truncation,{} \spad{ns} is the maximum number of call to \spad{rk4qc} to use. \end{items}
778174`This suite of routines performs numerical quadrature using algorithms derived from the basic trapezoidal rule. Because the error term of this rule contains only even powers of the step size (for open and closed versions),{} fast convergence can be obtained if the integrand is sufficiently smooth. \blankline Each routine returns a Record of type TrapAns,{} which contains\indent{3} \newline value (\spadtype{Float}):\tab{20} estimate of the integral \newlin
778174`--e error (\spadtype{Float}):\tab{20} estimate of the error in the computation \newline totalpts (\spadtype{Integer}):\tab{20} total number of function evaluations \newline success (\spadtype{Boolean}):\tab{20} if the integral was computed within the user specified error criterion \indent{0}\indent{0} To produce this estimate,{} each routine generates an internal sequence of sub-estimates,{} denoted by {\em S(i)},{} depending on the routine,{} to which the various convergence criteria are applie
778174`--d. The user must supply a relative accuracy,{} \spad{eps_r},{} and an absolute accuracy,{} \spad{eps_a}. Convergence is obtained when either \center{\spad{ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))}} \center{or \spad{ABS(S(i) - S(i-1)) < eps_a}} are \spad{true} statements. \blankline The routines come in three families and three flavors: \newline\tab{3} closed:\tab{20}romberg,{}\tab{30}simpson,{}\tab{42}trapezoidal \newline\tab{3} open: \tab{20}rombergo,{}\tab{30}simpsono,{}\tab{42}trapezoidalo 
778174`--\newline\tab{3} adaptive closed:\tab{20}aromberg,{}\tab{30}asimpson,{}\tab{42}atrapezoidal \par The {\em S(i)} for the trapezoidal family is the value of the integral using an equally spaced absicca trapezoidal rule for that level of refinement. \par The {\em S(i)} for the simpson family is the value of the integral using an equally spaced absicca simpson rule for that level of refinement. \par The {\em S(i)} for the romberg family is the estimate of the integral using an equally spaced absicc
778174`--a romberg method. For the \spad{i}\spad{-}th level,{} this is an appropriate combination of all the previous trapezodial estimates so that the error term starts with the \spad{2*(i+1)} power only. \par The three families come in a closed version,{} where the formulas include the endpoints,{} an open version where the formulas do not include the endpoints and an adaptive version,{} where the user is required to input the number of subintervals over which the appropriate closed family integrator
778174`-- will apply with the usual convergence parmeters for each subinterval. This is useful where a large number of points are needed only in a small fraction of the entire domain. \par Each routine takes as arguments: \newline \spad{f}\tab{10} integrand \newline a\tab{10} starting point \newline \spad{b}\tab{10} ending point \newline \spad{eps_r}\tab{10} relative error \newline \spad{eps_a}\tab{10} absolute error \newline \spad{nmin} \tab{10} refinement level when to start checking for convergence 
778174`--(> 1) \newline \spad{nmax} \tab{10} maximum level of refinement \par The adaptive routines take as an additional parameter \newline \spad{nint}\tab{10} the number of independent intervals to apply a closed \indented{1}{family integrator of the same name.} \par Notes: \newline Closed family level \spad{i} uses \spad{1 + 2**i} points. \newline Open family level \spad{i} uses \spad{1 + 3**i} points.
778224`\spadtype{ODEIntegration} provides an interface to the integrator. This package is intended for use by the differential equations solver but not at top-level.
778343`\spad{ODETools} provides tools for the linear ODE solver.
778449`\spad{OctonionCategoryFunctions2} implements functions between two octonion domains defined over different rings. The function map is used to coerce between octonion types.
778594`\indented{1}{This package provides tools for operating on one-dimensional arrays} with unary and binary functions involving different underlying types
778670`Lifting of maps to one-point completions. Date Created: 4 Oct 1989 Date Last Updated: 4 Oct 1989
778760`\spadtype{OpenMathPackage} provides some simple utilities to make reading OpenMath objects easier.
778804`\spadtype{OpenMathServerPackage} provides the necessary operations to run AXIOM as an OpenMath server,{} reading/writing objects to/from a port. Please note the facilities available here are very basic. The idea is that a user calls \spadignore{e.g.} \axiom{Omserve(4000,{}60)} and then another process sends OpenMath objects to port 4000 and reads the result.
778857`This package exports tools to create AXIOM Library information databases.
778903`Lifting of maps to ordered completions. Date Created: 4 Oct 1989 Date Last Updated: 4 Oct 1989
778992`\indented{3}{This package provides ordering functions on vectors which} are suitable parameters for OrderedDirectProduct.
779088`This package provides orthogonal polynomials as functions on a ring.
779166`OutPackage allows pretty-printing from programs.
779206`In this package \spad{K} is a finite field,{} \spad{R} is a ring of univariate polynomials over \spad{K},{} and \spad{F} is a monogenic algebra over \spad{R}. We require that \spad{F} is monogenic,{} \spadignore{i.e.} that \spad{F = K[x,{}y]/(f(x,{}y))},{} because the integral basis algorithm used will factor the pol
779206`--ynomial \spad{f(x,{}y)}. The package provides a function to compute the integral closure of \spad{R} in the quotient field of \spad{F} as well as a function to compute a "local integral basis" at a specific prime.
779396`\indented{1}{This package computes reliable Pad&ea. approximants using} a generalized Viskovatov continued fraction algorithm. Authors: Trager,{}Burge,{} Hassner & Watt. Date Created: April 1987 Date Last Updated: 12 April 1990 Keywords: Pade,{} series Examples: References: \indented{2}{"Pade Approximants,{} Part I: Basic Theory",{} Baker & Graves-Morris.}
779478`\indented{1}{This package computes reliable Pad&ea. approximants using} a generalized Viskovatov continued fraction algorithm. Authors: Burge,{} Hassner & Watt. Date Created: April 1987 Date Last Updated: 12 April 1990 Keywords: Pade,{} series Examples: References: \indented{2}{"Pade Approximants,{} Part I: Basic Theory",{} Baker & Graves-Morris.}
779610`This package implements fixed-point computations on streams.
779680`Author: William Sit,{} spring 89
779867`This package \undocumented
779949`This package \undocumented
780031`This package \undocumented
780110`The package \spadtype{PartialFractionPackage} gives an easier to use interfact the domain \spadtype{PartialFraction}. The user gives a fraction of polynomials,{} and a variable and the package converts it to the proper datatype for the \spadtype{PartialFraction} domain.
780190`PartitionsAndPermutations contains functions for generating streams of integer partitions,{} and streams of sequences of integers composed from a multi-set.
780247`Tools for patterns.
780319`Lifts maps to patterns.
780398`Attaching assertions to symbols for pattern matching. Date Created: 21 Mar 1989 Date Last Updated: 23 May 1990
780449`This package provides pattern matching functions on function spaces.
780578`This package provides pattern matching functions on integers.
780660`\spadtype{PatternMatchIntegration} provides functions that use the pattern matcher to find some indefinite and definite integrals involving special functions and found in the litterature.
780776`This package provides pattern matching functions on kernels.
780867`This package provides pattern matching functions on lists.
780984`This package provides pattern matching functions on polynomials.
781163`This packages provides tools for matching recursively in type towers.
781279`This package provides pattern matching functions on quotients.
781417`Lifts maps to pattern matching results.
781522`This package provides pattern matching functions on symbols.
781583`This package provides tools for the pattern matcher.
781685`This package provides the top-level pattern macthing functions.
781827`Permanent implements the functions {\em permanent},{} the permanent for square matrices.
781903`PermutationGroupExamples provides permutation groups for some classes of groups: symmetric,{} alternating,{} dihedral,{} cyclic,{} direct products of cyclic,{} which are in fact the finite abelian groups of symmetric groups called Young subgroups. Furthermore,{} Rubik\spad{'s} group as permutation group of 48 integers and a list of sporadic simple groups derived from the atlas of finite groups.
781954`\indented{1}{Provides a coercion from the symbolic fractions in \%\spad{pi} with} integer coefficients to any Expression type. Date Created: 21 Feb 1990 Date Last Updated: 21 Feb 1990
782020`\spad{PlotFunctions1} provides facilities for plotting curves where functions \spad{SF} \spad{->} \spad{SF} are specified by giving an expression
782090`This package exports plotting tools
782233`This package provides function for testing whether a divisor on a curve is a torsion divisor.
782448`\indented{1}{Utilities for PFOQ and PFO} Author: Manuel Bronstein Date Created: 25 Aug 1988 Date Last Updated: 11 Jul 1990
782611`This package provides function for testing whether a divisor on a curve is a torsion divisor.
782834`Package with the conversion functions among different kind of polynomials
782899`Groebner functions for \spad{P} \spad{F} \indented{2}{This package is an interface package to the groebner basis} package which allows you to compute groebner bases for polynomials in either lexicographic ordering or total degree ordering refined by reverse lex. The input is the ordinary polynomial type which is internally converted to a type with the required ordering. The resulting grobner basis is converted back to ordinary polynomials. The orderi
782899`--ng among the variables is controlled by an explicit list of variables which is passed as a second argument. The coefficient domain is allowed to be any \spad{gcd} domain,{} but the groebner basis is computed as if the polynomials were over a field.
782953`This package provides a coerce from polynomials over algebraic numbers to \spadtype{Expression AlgebraicNumber}.
783008`This package provides a very general map function,{} which given a set \spad{S} and polynomials over \spad{R} with maps from the variables into \spad{S} and the coefficients into \spad{S},{} maps polynomials into \spad{S}. \spad{S} is assumed to support \spad{+},{} \spad{*} and \spad{**}.
783182`This package transforms multivariate polynomials or fractions into univariate polynomials or fractions,{} and back.
783351`This package \undocumented
783443`This package \undocumented
783540`\indented{1}{PolynomialFactorizationByRecursionUnivariate} \spad{R} is a \spadfun{PolynomialFactorizationExplicit} domain,{} \spad{S} is univariate polynomials over \spad{R} We are interested in handling SparseUnivariatePolynomials over \spad{S},{} is a variable we shall call \spad{z}
783685`PolynomialFactorizationByRecursion(\spad{R},{}\spad{E},{}\spad{VarSet},{}\spad{S}) is used for factorization of sparse univariate polynomials over a domain \spad{S} of multivariate polynomials over \spad{R}.
783871`\indented{2}{This package takes a mapping between coefficient rings,{} and lifts} it to a mapping between polynomials over those rings.
784074`This package exports interpolation algorithms
784185`This package exports interpolation algorithms
784316`computes \spad{n}-th roots of quotients of multivariate polynomials
784475`This package provides modest routines for polynomial system solving. The aim of many of the operations of this package is to remove certain factors in some polynomials in order to avoid unnecessary computations in algorithms involving splitting techniques by partial factorization.
784635`This package factors the formulas out of the general solve code,{} allowing their recursive use over different domains. Care is taken to introduce few radicals so that radical extension domains can more easily simplify the results.
784747`This package computes square-free decomposition of multivariate polynomials over a coefficient ring which is an arbitrary \spad{gcd} domain. The requirement on the coefficient domain guarantees that the \spadfun{content} can be removed so that factors will be primitive as well as square-free. Over an infinite ring of finite characteristic,{}it may not 
784747`--be possible to guarantee that the factors are square-free.
784901`This package is primarily to help the interpreter do coercions. It allows you to view a polynomial as a univariate polynomial in one of its variables with coefficients which are again a polynomial in all the other variables.
784982`PowerSeriesLimitPackage implements limits of expressions in one or more variables as one of the variables approaches a limiting value. Included are two-sided limits,{} left- and right- hand limits,{} and limits at plus or minus infinity.
785101`\spadtype{PrecomputedAssociatedEquations} stores some generic precomputations which speed up the computations of the associated equations needed for factoring operators.
785232`\indented{1}{This package provides tools for operating on primitive arrays} with unary and binary functions involving different underlying types
785304`PrimitiveElement provides functions to compute primitive elements in algebraic extensions.
785369`\spad{PrimitiveRatDE} provides functions for in-field solutions of linear \indented{1}{ordinary differential equations,{} in the transcendental case.} \indented{1}{The derivation to use is given by the parameter \spad{L}.}
785586`In-field solution of Riccati equations,{} primitive case.
785804`PrintPackage provides a print function for output forms.
785845`PseudoLinearNormalForm provides a function for computing a block-companion form for pseudo-linear operators.
785907`This package contains some functions: \axiomOpFrom{discriminant}{PseudoRemainderSequence},{} \axiomOpFrom{resultant}{PseudoRemainderSequence},{} \axiomOpFrom{subResultantGcd}{PseudoRemainderSequence},{} \axiomOpFrom{chainSubResultants}{PseudoRemainderSequence},{} \axiomOpFrom{degreeSubResultant}{PseudoRemainderSequence},{} \axiomOpFrom{lastSubResultant}{PseudoRemainderSequence},{} \axiomOpFrom{
785907`--resultantEuclidean}{PseudoRemainderSequence},{} \axiomOpFrom{subResultantGcdEuclidean}{PseudoRemainderSequence},{} \axiomOpFrom{\spad{semiSubResultantGcdEuclidean1}}{PseudoRemainderSequence},{} \axiomOpFrom{\spad{semiSubResultantGcdEuclidean2}}{PseudoRemainderSequence},{} etc. This procedures are coming from improvements of the subresultants algorithm. \indented{2}{Version : 7} \indented{2}{References : Lionel Ducos "Optimizations of the subresultant algorithm"} \indented{2}{to appear in the J
785907`--ournal of Pure and Applied Algebra.} \indented{2}{Author : Ducos Lionel \axiom{Lionel.Ducos@mathlabo.univ-poitiers.\spad{fr}}}
786018`This package provides functions for integration,{} limited integration,{} extended integration and the risch differential equation for pure algebraic integrands.
786143`In-field solution of an linear ordinary differential equation,{} pure algebraic case.
786338`This package \undocumented{}
786493`\spadtype{QuasiAlgebraicSet2} adds a function \spadfun{radicalSimplify} which uses \spadtype{IdealDecompositionPackage} to simplify the representation of a quasi-algebraic set. A quasi-algebraic set is the intersection of a Zariski closed set,{} defined as the common zeros of a given list of polynomials (the defining polynomials for equations),{} and a principal Zariski open set,{} defined as the complement of the
786493`-- common zeros of a polynomial \spad{f} (the defining polynomial for the inequation). Quasi-algebraic sets are implemented in the domain \spadtype{QuasiAlgebraicSet},{} where two simplification routines are provided: \spadfun{idealSimplify} and \spadfun{simplify}. The function \spadfun{radicalSimplify} is added for comparison study only. Because the domain \spadtype{IdealDecompositionPackage} provides facilities for computing with radical ideals,{} it is necessary to restrict the ground ring to
786493`-- the domain \spadtype{Fraction Integer},{} and the polynomial ring to be of type \spadtype{DistributedMultivariatePolynomial}. The routine \spadfun{radicalSimplify} uses these to compute groebner basis of radical ideals and is inefficient and restricted when compared to the two in \spadtype{QuasiAlgebraicSet}.
786584`A package for removing redundant quasi-components and redundant branches when decomposing a variety by means of quasi-components of regular triangular sets. \newline References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic systems of} \indented{5}{positive dimension" Discr. App. Math. 33:1
786584`--47-160,{}1991} \indented{1}{[2] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \spad{P}.etM. Curie,{} Paris,{} 1997.} \indented{1}{[3] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
786776`\spadtype{QuaternionCategoryFunctions2} implements functions between two quaternion domains. The function \spadfun{map} is used by the system interpreter to coerce between quaternion types.
786928`This package extends a function between integral domains to a mapping between their quotient fields.
787085`Package for the computation of eigenvalues and eigenvectors. This package works for matrices with coefficients which are rational functions over the integers. (see \spadtype{Fraction Polynomial Integer}). The eigenvalues and eigenvectors are expressed in terms of radicals.
787131`This package tries to find solutions expressed in terms of radicals for systems of equations of rational functions with coefficients in an integral domain \spad{R}.
787210`This package provides tools for creating radix expansions.
787255`This package exports random distributions
787365`This package exports integer distributions
787421`Random number generators \indented{2}{All random numbers used in the system should originate from} \indented{2}{the same generator.\space{2}This package is intended to be the source.}
787563`\spadtype{RationalFunctionDefiniteIntegration} provides functions to compute definite integrals of rational functions.
787767`\spadtype{RationalFunctionFactorizer} contains the factor function (called factorFraction) which factors fractions of polynomials by factoring the numerator and denominator. Since any non zero fraction is a unit the usual factor operation will just return the original fraction.
787843`This package provides functions for the integration of rational functions.
787926`Computation of limits for rational functions.
787997`Find the sign of a rational function around a point or infinity.
788059`Computes sums of rational functions.
788134`Utilities that provide the same top-level manipulations on fractions than on polynomials.
788193`This package provides functions for the base case of the Risch algorithm.
788300`\spad{RationalLODE} provides functions for in-field solutions of linear \indented{1}{ordinary differential equations,{} in the rational case.}
788400`rational number testing and retraction functions. Date Created: March 1990 Date Last Updated: 9 April 1991
788484`In-field solution of Riccati equations,{} rational case.
788587`\indented{1}{A package for computing the rational univariate representation} \indented{1}{of a zero-dimensional algebraic variety given by a regular} \indented{1}{triangular set. This package is essentially an interface for the} \spadtype{InternalRationalUnivariateRepresentationPackage} constructor. It is used in the \spadtype{ZeroDimensionalSolvePackage} for solving polynomial systems with fi
788587`--nitely many solutions.
788699`\axiomType{RealPolynomialUtilitiesPackage} provides common functions used by interval coding.
788839`\indented{1}{This package provides numerical solutions of systems of polynomial} equations for use in ACPLOT.
788887`\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the rational numbers to arbitrary user-specified precision. The results are returned as a list of isolating intervals,{} expressed as records with "left" and "right" rational number components.
788985`\indented{2}{This package provides functions for finding the real zeros} of univariate polynomials over the integers to arbitrary user-specified precision. The results are returned as a list of isolating intervals which are expressed as records with "left" and "right" rational number components.
789071`\spadtype{RectangularMatrixCategoryFunctions2} provides functions between two matrix domains. The functions provided are \
789071`--spadfun{map} and \spadfun{reduce}.
789457`Elimination of an algebraic from the coefficentss of a linear ordinary differential equation.
789674`\indented{1}{Finds the order of a divisor over a finite field} Author: Manuel Bronstein Date Created: 1988 Date Last Updated: 8 November 1994
789881`\spadtype{ReductionOfOrder} provides functions for reducing the order of linear ordinary differential equations once some solutions are known.
789989`A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are proposed: in the sense of Zariski closure (like in Kalkbrener\spad{'s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard methods). This algorithm is valid for n
789989`--ay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \spad{TS} and the packages \axiomType{QCMPACK}(\spad{R},{}\spad{E},{}\spad{V},{}\spad{P},{}\spad{TS}) and \axiomType{RSETGCD}(\spad{R},{}\spad{E},{}\spad{V},{}\spad{P},{}\sp
789989`--ad{TS}). The same way it does not care about the way univariate polynomial \spad{gcd} (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these \spad{gcd} need to have invertible initials (normalized or not). WARNING. There is no need for a user to call diectly any operation of this package since they can be accessed by the domain \axiom{\spad{TS}}. Thus,{} the operations of this package are not documented.\newline Refe
789989`--rences : \indented{1}{[1] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
790190`An internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field.\newline References : \indented{1}{[1] \spad{M}. MORENO MAZA and \spad{R}. RIOBOO "Computations of \spad{gcd} over} \indented{5}{algebraic towers of simple extensions
790190`--" In proceedings of \spad{AAECC11}} \indented{5}{Paris,{} 1995.} \indented{1}{[2] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \spad{P}.etM. Curie,{} Paris,{} 1997.} \indented{1}{[3] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
790391`Implements multiplication by repeated addition
790460`Implements exponentiation by repeated squaring
790529`\spad{RepresentationPackage1} provides functions for representation theory for finite groups and algebras. The package creates permutation representations and uses tensor products and its symmetric and antisymmetric components to create new representations of larger degree from given ones. Note: instead of having parameters from \spadtype{Permutation} this package allows list notation of permutations as well: \spadignore{e.g.} \spad{[1,{}4,{}3,{}2
790529`--]} denotes permutes 2 and 4 and fixes 1 and 3.
790586`\spad{RepresentationPackage2} provides functions for working with modular representations of finite groups and algebra. The routines in this package are created,{} using ideas of \spad{R}. Parker,{} (the meat-Axe) to get smaller representations from bigger ones,{} \spadignore{i.e.} finding sub- and factormodules,{} or to show,{} that such the representations are irreducible. Note: most functions are randomized functions of Las Vegas type \spadigno
790586`--re{i.e.} every answer is correct,{} but with small probability the algorithm fails to get an answer.
790643`This package provides coercions for the special types \spadtype{Exit} and \spadtype{Void}.
790705`RetractSolvePackage is an interface to \spadtype{SystemSolvePackage} that attempts to retract the coefficients of the equations before solving.
790987`\spadtype{ScriptFormulaFormat1} provides a utility coercion for changing to SCRIPT formula format anything that has a coercion to the standard output format.
791053`This package provides operations for mapping functions onto \spadtype{SegmentBinding}\spad{s}.
791125`This package provides operations for mapping functions onto segments.
791364`\indented{1}{Package to allow simplify to be called on AlgebraicNumbers} by converting to EXPR(INT)
791431`\spadtype{SmithNormalForm} is a package which provides some standard canonical forms for matrices.
791591`This package exports sorting algorithnms
791684`\indented{1}{Cache of elements in a set} Author: Manuel Bronstein Date Created: 31 Oct 1988 Date Last Updated: 14 May 1991 \indented{2}{A sorted cache of a cachable set \spad{S} is a dynamic structure that} \indented{2}{keeps the elements of \spad{S} sorted and assigns an integer to each} \indented{2}{element of \spad{S} once it is in the cache. This way,{} equality and ordering} \indented{2}{on \spad{S} are tested directly on the integers associate
791684`--d with the elements} \indented{2}{of \spad{S},{} once they have been entered in the cache.}
791739`This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from sparse univariate polynomial over \spad{R} to a sparse univariate polynomial over \spad{S}. Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.
791819`SpecialOutputPackage allows FORTRAN,{} Tex and \indented{2}{Script Formula Formatter output from programs.}
791870`\indented{2}{A internal package for removing redundant quasi-components and redundant} \indented{2}{branches when decomposing a variety by means of quasi-components} \indented{2}{of regular triangular sets. \newline} References : \indented{1}{[1] \spad{D}. LAZARD "A new method for solving algebraic system
791870`--s of} \indented{5}{positive dimension" Discr. App. Math. 33:147-160,{}1991} \indented{5}{Tech. Report (PoSSo project)} \indented{1}{[2] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \spad{P}.etM. Curie,{} Paris,{} 1997.} \indented{1}{[3] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. 
791870`--Rep. 4/98.}
792072`A package providing a new algorithm for solving polynomial systems by means of regular chains. Two ways of solving are provided: in the sense of Zariski closure (like in Kalkbrener\spad{'s} algorithm) or in the sense of the regular zeros (like in Wu,{} Wang or Lazard- Moreno methods). T
792072`--his algorithm is valid for nay type of regular set. It does not care about the way a polynomial is added in an regular set,{} or how two quasi-components are compared (by an inclusion-test),{} or how the invertibility test is made in the tower of simple extensions associated with a regular set. These operations are realized respectively by the domain \spad{TS} and the packages \spad{QCMPPK(R,{}E,{}V,{}P,{}TS)} and \spad{RSETGCD(R,{}E,{}V,{}P,{}TS)}. The same way it does not care about the way 
792072`--univariate polynomial gcds (with coefficients in the tower of simple extensions associated with a regular set) are computed. The only requirement is that these gcds need to have invertible initials (normalized or not). WARNING. There is no need for a user to call diectly any operation of this package since they can be accessed by the domain \axiomType{\spad{TS}}. Thus,{} the operations of this package are not documented.\newline References : \indented{1}{[1] \spad{M}. MORENO MAZA "A new algori
792072`--thm for computing triangular} \indented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
792293`A internal package for computing gcds and resultants of univariate polynomials with coefficients in a tower of simple extensions of a field. There is no need to use directly this package since its main operations are available from \spad{TS}. \newline References : \indented{1}{[1] \spad{M}. MORENO
792293`-- MAZA and \spad{R}. RIOBOO "Computations of \spad{gcd} over} \indented{5}{algebraic towers of simple extensions" In proceedings of \spad{AAECC11}} \indented{5}{Paris,{} 1995.} \indented{1}{[2] \spad{M}. MORENO MAZA "Calculs de pgcd au-dessus des tours} \indented{5}{d'extensions simples et resolution des systemes d'equations} \indented{5}{algebriques" These,{} Universite \spad{P}.etM. Curie,{} Paris,{} 1997.} \indented{1}{[3] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \ind
792293`--ented{5}{decomposition of algebraic varieties" NAG Tech. Rep. 4/98.}
792503`This package provides standard arithmetic operations on matrices. The functions in this package store the results of computations in existing matrices,{} rather than creating new matrices. This package works only for matrices of type Matrix and uses the internal representation of this type.
792573`Functions defined on streams with entries in one set.
792627`Functions defined on streams with entries in two sets.
792690`Functions defined on streams with entries in three sets.
792762`This package computes infinite products of Taylor series over an integral domain of characteristic 0. Here Taylor series are represented by streams of Taylor coefficients.
792845`StreamTaylorSeriesOperations implements Taylor series arithmetic,{} where a Taylor series is represented by a stream of its coefficients.
792912`StreamTranscendentalFunctionsNonCommutative implements transcendental functions on Taylor series over a non-commutative ring,{} where a Taylor series is represented by a stream of its coefficients.
793017`StreamTranscendentalFunctions implements transcendental functions on Taylor series,{} where a Taylor series is represented by a stream of its coefficients.
793106`StructuralConstantsPackage provides functions creating structural constants from a multiplication tables or a basis of a matrix algebra and other useful functions in this context.
793169`This package produces functions for counting etc. real roots of univariate polynomials in \spad{x} over \spad{R},{} which must be an OrderedIntegralDomain
793250`This package computes the subresultants of two polynomials which is needed for the `Lazard Rioboo' enhancement to Tragers integrations formula For efficiency reasons this has been rewritten to call Lionel Ducos package which is currently the best one. \blankline
793357`\indented{1}{SupFractionFactorize} contains the factor function for univariate polynomials over the quotient field of a ring \spad{S} such that the package MultivariateFactorize works for \spad{S}
793500`Computes all the symmetric functions in \spad{n} variables.
793556`SymmetricGroupCombinatoricFunctions contains combinatoric functions concerning symmetric groups and representation theory: list young tableaus,{} improper partitions,{} subsets bijection of Coleman.
793619`SystemODESolver provides tools for triangulating and solving some systems of linear ordinary differential equations.
793786`TableauBumpers implements the Schenstead-Knuth correspondence between sequences and pairs of Young tableaux. The 2 Young tableaux are represented as a single tableau with pairs as components.
793846`\axiom{TabulatedComputationPackage(Key ,{}Entry)} provides some modest support for dealing with operations with type \axiom{Key \spad{->} Entry}. The result of such operations can be stored and retrieved with this package by using a hash-table. The user does not need to worry about the management of this hash-table. However,{} onnly one hash-table is built by calling \axiom{TabulatedComputationPackage(Key ,
793846`--{}Entry)}.
793944`Expands tangents of sums and scalar products.
793999`This package provides functions for template manipulation
794046`\spadtype{TexFormat1} provides a utility coercion for changing to TeX format anything that has a coercion to the standard output format.
794098`Tools for the sign finding utilities.
794149`TopLevelDrawFunctionsForAlgebraicCurves provides top level functions for drawing non-singular algebraic curves.
794272`TopLevelDrawFunctionsForCompiledFunctions provides top level functions for drawing graphics of expressions.
794345`TopLevelDrawFunctionsForPoints provides top level functions for drawing curves and surfaces described by sets of points.
794405`TopLevelDrawFunctions provides top level functions for drawing graphics of expressions.
794533`This package finds the function \spad{func3} where \spad{func1} and \spad{func2} \indented{1}{are given and\space{2}\spad{func1} = \spad{func3}(\spad{func2}) .\space{2}If there is no solution then} \indented{1}{function \spad{func1} will be returned.} \indented{1}{An example would be\space{2}\spad{func1:= 8*X**3+32*X**2-14*X ::EXPR INT} and} \indented{1}{\spad{func2:=2*X ::EXPR INT} convert them via univariate} \indented{
794533`--1}{to FRAC SUP EXPR INT and then the solution is \spad{func3:=X**3+X**2-X}} \indented{1}{of type FRAC SUP EXPR INT}
794616`This package tries to find solutions of equations of type Expression(\spad{R}). This means expressions involving transcendental,{} exponential,{} logarithmic and nthRoot functions. After trying to transform different kernels to one kernel by applying several rules,{} it calls zerosOf for the SparseUnivariatePolynomial in the remaining kernel. For example the expression \spad{sin(x)*cos(x)-2} will be transformed to \indented{3}{\spad
794616`--{-2 tan(x/2)**4 -2 tan(x/2)**3 -4 tan(x/2)**2 +2 tan(x/2) -2}} by using the function normalize and then to \indented{3}{\spad{-2 tan(x)**2 + tan(x) -2}} with help of subsTan. This function tries to express the given function in terms of \spad{tan(x/2)} to express in terms of \spad{tan(x)} . Other examples are the expressions \spad{sqrt(x+1)+sqrt(x+7)+1} or \indented{1}{\spad{sqrt(sin(x))+1} .}
794688`Hermite integration,{} transcendental case.
794800`This package provides functions for the transcendental case of the Risch algorithm.
794902`TranscendentalManipulations provides functions to simplify and expand expressions involving transcendental operators.
795016`\indented{1}{Risch differential equation system,{} transcendental case.} Author: Manuel Bronstein Date Created: 17 August 1992 Date Last Updated: 3 February 1994
795131`\indented{1}{Risch differential equation,{} transcendental case.} Author: Manuel Bronstein Date Created: Jan 1988 Date Last Updated: 2 November 1995
795239`This package provides functions that compute "fraction-free" inverses of upper and lower triangular matrices over a integral domain. By "fraction-free inverses" we mean the following: given a matrix \spad{B} with entries in \spad{R} and an element \spad{d} of \spad{R} such that \spad{d} * inv(\spad{B}) also has entries in \spad{R},{} w
795239`--e return \spad{d} * inv(\spad{B}). Thus,{} it is not necessary to pass to the quotient field in any of our computations.
795410`\spadtype{TrigonometricManipulations} provides transformations from trigonometric functions to complex exponentials and logarithms,{} and back.
795531`Tools for constructing tubes around 3-dimensional parametric curves.
795576`\indented{1}{The purpose of this package is to provide reasonable plots of} functions with singularities.
795630`A basic package for the factorization of bivariate polynomials over a finite field. The functions here represent the base step for the multivariate factorizer.
795695`\spad{RUTSodetools} provides tools to interface with the series \indented{1}{ODE solver when presented with linear ODEs.}
795878`Package for the factorization of univariate polynomials with integer coefficients. The factorization is done by "lifting" (HENSEL) the factorization over a finite field.
795969`Mapping package for univariate Laurent series \indented{2}{This package allows one to apply a function to the coefficients of} \indented{2}{a univariate Laurent series.}
796130`Mapping from polynomials over \spad{R} to polynomials over \spad{S} given a map from \spad{R} to \spad{S} assumed to send zero to zero.
796293`UnivariatePolynomialCommonDenominator provides functions to compute the common denominator of the coefficients of univariate polynomials over the quotient field of a \spad{gcd} domain.
796446`UnivariatePolynomialDecompositionPackage implements functional decomposition of univariate polynomial with coefficients in an \spad{IntegralDomain} of \spad{CharacteristicZero}.
796585`UnivariatePolynomialDivisionPackage provides a division for non monic univarite polynomials with coefficients in an \spad{IntegralDomain}.
796707`This package lifts a mapping from coefficient rings \spad{R} to \spad{S} to a mapping from \spadtype{UnivariatePolynomial}(\spad{x},{}\spad{R}) to \spadtype{UnivariatePolynomial}(\spad{y},{}\spad{S}). Note that the mapping is assumed to send zero to zero,{} since it will only be applied to the non-zero coefficients of the polynomial.
796802`This package implements Karatsuba\spad{'s} trick for multiplying (large) univariate polynomials. It could be improved with a version doing the work on place and also with a special case for squares. We've done this in Basicmath,{} but we believe that this out of the scope of AXIOM.
796916`This package provides for square-free decomposition of univariate polynomials over arbitrary rings,{} \spadignore{i.e.} a partial factorization such that each factor is a product of irreducibles with multiplicity one and the factors are pairwise relatively prime. If the ring has characteristic zero,{} the result is guaranteed to satisfy this condition. If the ring is an infin
796916`--ite ring of finite characteristic,{} then it may not be possible to decide when polynomials contain factors which are \spad{p}th powers. In this case,{} the flag associated with that polynomial is set to "nil" (meaning that that polynomials are not guaranteed to be square-free).
797046`Mapping package for univariate Puiseux series. This package allows one to apply a function to the coefficients of a univariate Puiseux series.
797208`\spad{UnivariateSkewPolynomialCategoryOps} provides products and \indented{1}{divisions of univariate skew polynomials.}
797323`Mapping package for univariate Taylor series. \indented{2}{This package allows one to apply a function to the coefficients of} \indented{2}{a univariate Taylor series.}
797513`\indented{1}{This package provides Taylor series solutions to regular} linear or non-linear ordinary differential equations of arbitrary order.
797656`This package provides operations for mapping functions onto segments.
797729`Provides functions to force a partial ordering on any set.
797797`This packages provides functions to allow the user to select the ordering on the variables and operators for displaying polynomials,{} fractions and expressions. The ordering affects the display only and not the computations.
797909`ViewportDefaultsPackage describes default and user definable values for graphics
797959`ViewportPackage provides functions for creating GraphImages and TwoDimensionalViewports from lists of lists of points.
798002`This package implements the Weierstrass preparation theorem \spad{f} or multivariate power series. weierstrass(\spad{v},{}\spad{p}) where \spad{v} is a variable,{} and \spad{p} is a TaylorSeries(\spad{R}) in which the terms of lowest degree \spad{s} must include c*v**s where \spad{c} is a constant,{}\spad{s>0},{} is a list of TaylorSeries coefficients A[\spad{i}] of the equivalent polynomial A = A[0] + A[1]\spad{*v} + A[2]\spad{*v**2} + ... + A[
798002`--\spad{s}-1]*v**(\spad{s}-1) + v**s such that p=A*B ,{} \spad{B} being a TaylorSeries of minimum degree 0
798061`In this package \spad{K} is a finite field,{} \spad{R} is a ring of univariate polynomials over \spad{K},{} and \spad{F} is a framed algebra over \spad{R}. The package provides a function to compute the integral closure of \spad{R} in the quotient field of \spad{F} as well as a function to compute a "local integral basis" at
798061`-- a specific prime.
798243`This package provides computations of logarithms and exponentials for polynomials in non-commutative variables. \newline Author: Michel Petitot (petitot@lifl.\spad{fr}).
798375`A package for computing symbolically the complex and real roots of zero-dimensional algebraic systems over the integer or rational numbers. Complex roots are given by means of univariate representations of irreducible regular chains. Real roots are given by means of tuples of coordinates lying in the \spadtype{RealClosure} of the coefficient ring. This constructor takes three argumen
798375`--ts. The first one \spad{R} is the coefficient ring. The second one \spad{ls} is the list of variables involved in the systems to solve. The third one must be \spad{concat(ls,{}s)} where \spad{s} is an additional symbol used for the univariate representations. WARNING: The third argument is not checked. All operations are based on triangular decompositions. The default is to compute these decompositions directly from the input system by using the \spadtype{RegularChain} domain constructor. The 
798375`--lexTriangular algorithm can also be used for computing these decompositions (see the \spadtype{LexTriangularPackage} package constructor). For that purpose,{} the operations \axiomOpFrom{univariateSolve}{ZeroDimensionalSolvePackage},{} \axiomOpFrom{realSolve}{ZeroDimensionalSolvePackage} and \axiomOpFrom{positiveSolve}{ZeroDimensionalSolvePackage} admit an optional argument. \newline Author: Marc Moreno Maza.
798703`The class of abelian groups,{} \spadignore{i.e.} additive monoids where each element has an additive inverse. \blankline
798763`The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with an additive identity element. \blankline
798825`Abelian monoid ring elements (not necessarily of finite support) of this ring are of the form formal SUM (r_i * e_i) where the r_i are coefficents and the e_i,{} elements of the ordered abelian monoid,{} are thought of as exponents or monomials. The monomials commute with each other,{} and with the coefficients (which themselves may or may not be commutative). See \spadtype{FiniteAbelianMonoidRing} f
798825`--or the case of finite support a useful common model for polynomials and power series. Conceptually at least,{} only the non-zero terms are ever operated on.
798930`the class of all additive (commutative) semigroups,{} \spadignore{i.e.} a set with a commutative and associative operation \spadop{+}. \blankline
798997`The notion of aggregate serves to model any data structure aggregate,{} designating any collection of objects,{} with heterogenous or homogeneous members,{} with a finite or infinite number of members,{} explicitly or implicitly represented. An aggregate can in principle represent everything from a string of characters to abstract sets such as "the set of \spad{x} satisfying relation {\em r(x)}" An attribute \spadatt{finiteAggregate} is used to assert th
798997`--at a domain has a finite number of elements.
799047`The category of associative algebras (modules which are themselves rings). \blankline
799120`Model for algebraically closed fields.
799200`Model for algebraically closed function spaces.
799323`Category for the inverse trigonometric functions.
799485`\spadtype{BasicType} is the basic category for describing a collection of elements with \spadop{=} (equality).
800059`Differential extensions of a ring \spad{R}. Given a differentiation on \spad{R},{} extend it to a differentiation on \%.
800335`An ordinary differential ring,{} that is,{} a ring with an operation \spadfun{differentiate}. \blankline
800618`A division ring (sometimes called a skew field),{} \spadignore{i.e.} a not necessarily commutative ring where all non-zero elements have multiplicative inverses.
800678`Category for the elementary functions.
800866`A constructive euclidean domain,{} \spadignore{i.e.} one can divide producing a quotient and a remainder where the remainder is either zero or is smaller (\spadfun{euclideanSize}) than the divisor. \blankline Conditional attributes: \indented{2}{multiplicativeValuation\tab{25}\spad{Size(a*b)=Size(a)*Size(b)}} \indented{2}{additiveValuation\tab{25}\spad{Size(a*b)=Size(a)+Size(b)}}
800931`This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\spad{''} substitutions.
801001`An expression space is a set which is closed under certain operators.
801216`The category of commutative fields,{} \spadignore{i.e.} commutative rings where all non-zero elements have multiplicative inverses. The \spadfun{factor} operation while trivial is useful to have defined. \blankline
801338`This category is similar to AbelianMonoidRing,{} except that the sum is assumed to be finite. It is a useful model for polynomials,{} but is somewhat more general.
801554`This category describes finite rational divisors on a curve,{} that is finite formal sums SUM(\spad{n} * \spad{P}) where the \spad{n}\spad{'s} are integers and the \spad{P}\spad{'s} are finite rational points on the curve.
801933`A FiniteRankAlgebra is an algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.
802067`A FiniteRankNonAssociativeAlgebra is a non associative algebra over a commutative ring \spad{R} which is a free \spad{R}-module of finite rank.
802335`A \spadtype{FramedAlgebra} is a \spadtype{FiniteRankAlgebra} together with a fixed \spad{R}-module basis.
802461`FramedNonAssociativeAlgebra(\spad{R}) is a \spadtype{FiniteRankNonAssociativeAlgebra} (\spadignore{i.e.} a non associative algebra over \spad{R} which is a free \spad{R}-module of finite rank) over a commutative ring \spad{R} together with a fixed \spad{R}-module basis.
802574`This category provides a selection of evaluation operations depending on what the argument type \spad{R} provides.
802663`\spad{S} is \spadtype{FullyLinearlyExplicitRingOver R} means that \spad{S} is a \spadtype{LinearlyExplicitRingOver R} and,{} in addition,{} if \spad{R} is a \spadtype{LinearlyExplicitRingOver Integer},{} then so is \spad{S}
802769`\indented{2}{A is fully retractable to \spad{B} means that A is retractable to \spad{B},{} and,{}} \indented{2}{in addition,{} if \spad{B} is retractable to the integers or rational} \indented{2}{numbers then so is A.} \indented{2}{In particular,{} what we are asserting is that there are no integers} \indented{2}{(rationals) in A which don\spad{'t} retract into \spad{B}.} Date Created: March 1990 Date Last Updated: 9 Apr
802769`--il 1991
802853`This category is a model for the function field of a plane algebraic curve.
803061`A space of formal functions with arguments in an arbitrary ordered set.
803136`This category describes domains where \spadfun{\spad{gcd}} can be computed but where there is no guarantee of the existence of \spadfun{factor} operation for factorisation into irreducibles. However,{} if such a \spadfun{factor} operation exist,{} factorization will be unique up to order and units.
803189`GradedAlgebra(\spad{R},{}\spad{E}) denotes ``E-graded \spad{R}-algebra\spad{''}. A graded algebra is a graded module together with a degree preserving \spad{R}-linear map,{} called the {\em product}. \blankline The name ``product\spad{''} is written out in full so inner and outer products with the same mapping type can be distinguished by name.
803292`GradedModule(\spad{R},{}\spad{E}) denotes ``E-graded \spad{R}-module\spad{''},{} \spadignore{i.e.} collection of \spad{R}-modules indexed by an abelian monoid \spad{E}. An element \spad{g} of \spad{G[s]} for some specific \spad{s} in \spad{E} is said to be an element of \spad{G} with {\em degree} \spad{s}. Sums are defined in each module \spad{G[s]} so two elements of \spad{G} have a sum if they have the s
803292`--ame degree. \blankline Morphisms can be defined and composed by degree to give the mathematical category of graded modules.
803391`The class of multiplicative groups,{} \spadignore{i.e.} monoids with multiplicative inverses. \blankline
803515`Category for the hyperbolic trigonometric functions.
803716`This category provides \spadfun{eval} operations. A domain may belong to this category if it is possible to make ``evaluation\spad{''} substitutions. The difference between this and \spadtype{Evalable} is that the operations in this category specify the substitution as a pair of arguments rather than as an equation.
803808`An \spad{IntegerNumberSystem} is a model for the integers.
803878`The category of commutative integral domains,{} \spadignore{i.e.} commutative rings with no zero divisors. \blankline Conditional attributes: \indented{2}{canonicalUnitNormal\tab{20}the canonical field is the same for all associates} \indented{2}{canonicalsClosed\tab{20}the product of two canonicals is itself canonical}
804054`LazyStreamAggregate is the category of streams with lazy evaluation. It is understood that the function 'empty?' will cause lazy evaluation if necessary to determine if there are entries. Functions which call 'empty?',{} \spadignore{e.g.} 'first' and 'rest',{} will also cause lazy evaluation if necessary.
804140`The category of all left algebras over an arbitrary ring.
804207`\axiom{JacobiIdentity} means that \axiom{[\spad{x},{}[\spad{y},{}\spad{z}]]+[\spad{y},{}[\spad{z},{}\spad{x}]]+[\spad{z},{}[\spad{x},{}\spad{y}]] = 0} holds.
804355`\spad{LinearOrdinaryDifferentialOperatorCategory} is the category of differential operators with coefficients in a ring A with a given derivation. Multiplication of operators corresponds to functional composition: \indented{4}{\spad{(L1 * L2).(f) = L1 L2 f}}
804551``Logic' provides the basic operations for lattices,{} \spadignore{e.g.} boolean algebra.
804595`\spadtype{MatrixCategory} is a general matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col. A domain belonging to this category will be shallowly mutable. The index of the 'first' row may be obtained by calling the 
804595`--function \spadfun{minRowIndex}. The index of the 'first' column may be obtained by calling the function \spadfun{minColIndex}. The index of the first element of a Row is the same as the index of the first column in a matrix and vice versa.
804744`The category of modules over a commutative ring. \blankline
804814`Monad is the class of all multiplicative monads,{} \spadignore{i.e.} sets with a binary operation.
804858`\indented{1}{MonadWithUnit is the class of multiplicative monads with unit,{}} \indented{1}{\spadignore{i.e.} sets with a binary operation and a unit element.} Axioms \indented{3}{leftIdentity("*":(\%,{}\%)\spad{->}\%,{}1)\space{3}\tab{30} 1*x=x} \indented{3}{rightIdentity("*":(\%,{}\%)\spad{->}\%,{}1)\space{2}\tab{30} x*1=x} Common Additional Axioms \indented{3}{unitsKnown
804858`---if "recip" says "failed",{} that PROVES input wasn\spad{'t} a unit}
804920`A \spadtype{MonogenicAlgebra} is an algebra of finite rank which can be generated by a single element.
805052`The class of multiplicative monoids,{} \spadignore{i.e.} semigroups with a multiplicative identity element. \blankline
805099`NonAssociativeAlgebra is the category of non associative algebras (modules which are themselves non associative rngs). Axioms \indented{3}{\spad{r*}(a*b) = (r*a)\spad{*b} = a*(\spad{r*b})}
805196`A NonAssociativeRing is a non associative \spad{rng} which has a unit,{} the multiplication is not necessarily commutative or associative.
805268`NonAssociativeRng is a basic ring-type structure,{} not necessarily commutative or associative,{} and not necessarily with unit. Axioms \indented{2}{\spad{x*}(\spad{y+z}) = x*y + \spad{x*z}} \indented{2}{(x+y)\spad{*z} = \spad{x*z} + \spad{y*z}} Common Additional Axioms \indented{2}{noZeroDivisors\space{2}ab = 0 \spad{=>} \spad{a=0} or \spad{b=0}}
805336`OctonionCategory gives the categorial frame for the octonions,{} and eight-dimensional non-associative algebra,{} doubling the the quaternions in the same way as doubling the Complex numbers to get the quaternions.
805518`Ordered sets which are also rings,{} that is,{} domains where the ring operations are compatible with the ordering. \blankline
805576`The class of totally ordered sets,{} that is,{} sets such that for each pair of elements \spad{(a,{}b)} exactly one of the following relations holds \spad{a<b or a=b or b<a} and the relation is transitive,{} \spadignore{i.e.} \spad{a<b and b<c => a<c}.
805631`A partial differential ring with differentiations indexed by a parameter type \spad{S}. \blankline
805731`The category for general multi-variate polynomials over a ring \spad{R},{} in variables from VarSet,{} with exponents from the \spadtype{OrderedAbelianMonoidSup}.
805877`This is the category of domains that know "enough" about themselves in order to factor univariate polynomials over themselves. This will be used in future releases for supporting factorization over finitely generated coefficient fields,{} it is not yet available in the current release of axiom.
805974`A category for finite subsets of a polynomial ring. Such a set is only regarded as a set of polynomials and not identified to the ideal it generates. So two distinct sets may generate the same the ideal. Furthermore,{} for \spad{R} being an integral domain,{} a set of polynomials may be viewed as a representa
805974`--tion of the ideal it generates in the polynomial ring \spad{(R)^(-1) P},{} or the set of its zeros (described for instance by the radical of the previous ideal,{} or a split of the associated affine variety) and so on. So this category provides operations about those different notions.
806172`\spadtype{PowerSeriesCategory} is the most general power series category with exponents in an ordered abelian monoid.
806327`\spadtype{QuaternionCategory} describes the category of quaternions and implements functions that are not representation specific.
806422`QuotientField(\spad{S}) is the category of fractions of an Integral Domain \spad{S}.
806579`\axiomType{RealClosedField} provides common acces functions for all real closed fields.
806703`\axiomType{RealRootCharacterizationCategory} provides common access functions for all real root codings.
806913`\spadtype{RectangularMatrixCategory} is a category of matrices of fixed dimensions. The dimensions of the matrix will be parameters of the domain. Domains in this category will be \spad{R}-modules and will be non-mutable.
807215`A category for general multi-variate polynomials with coefficients in a ring,{} variables in an ordered set,{} and exponents from an ordered abelian monoid,{} with a \axiomOp{sup} operation. When not constant,{} such a polynomial is viewed as a univariate polynomial in its main variable \spad{w}. \spad{r}. \spad{t}. to the total ordering on the elements in 
807215`--the ordered set,{} so that some operations usually defined for univariate polynomials make sense here.
807364`The category of regular triangular sets,{} introduced under the name regular chains in [1] (and other papers). In [3] it is proved that regular triangular sets and towers of simple extensions of a field are equivalent notions. In the following definitions,{} all polynomials and ideals are taken from the polyno
807364`--mial ring \spad{k[x1,{}...,{}xn]} where \spad{k} is the fraction field of \spad{R}. The triangular set \spad{[t1,{}...,{}tm]} is regular iff for every \spad{i} the initial of \spad{ti+1} is invertible in the tower of simple extensions associated with \spad{[t1,{}...,{}\spad{ti}]}. A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Kalkbrener of a given ideal \spad{I} iff the radical of \spad{I} is equal to the intersection of the radical ideals generated by the saturated 
807364`--ideals of the \spad{[T1,{}...,{}\spad{Ti}]}. A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Kalkbrener of a given triangular set \spad{T} iff it is a split of Kalkbrener of the saturated ideal of \spad{T}. Let \spad{K} be an algebraic closure of \spad{k}. Assume that \spad{V} is finite with cardinality \spad{n} and let \spad{A} be the affine space \spad{K^n}. For a regular triangular set \spad{T} let denote by \spad{W(T)} the set of regular zeros of \spad{T}. A family
807364`-- \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Lazard of a given subset \spad{S} of \spad{A} iff the union of the \spad{W(\spad{Ti})} contains \spad{S} and is contained in the closure of \spad{S} (\spad{w}.\spad{r}.\spad{t}. Zariski topology). A family \spad{[T1,{}...,{}Ts]} of regular triangular sets is a split of Lazard of a given triangular set \spad{T} if it is a split of Lazard of \spad{W(T)}. Note that if \spad{[T1,{}...,{}Ts]} is a split of Lazard of \spad{T} then it i
807364`--s also a split of Kalkbrener of \spad{T}. The converse is \spad{false}. This category provides operations related to both kinds of splits,{} the former being related to ideals decomposition whereas the latter deals with varieties decomposition. See the example illustrating the \spadtype{RegularTriangularSet} constructor for more explanations about decompositions by means of regular triangular sets. \newline References : \indented{1}{[1] \spad{M}. KALKBRENER "Three contributions to elimination 
807364`--theory"} \indented{5}{\spad{Phd} Thesis,{} University of Linz,{} Austria,{} 1991.} \indented{1}{[2] \spad{M}. KALKBRENER "Algorithmic properties of polynomial rings"} \indented{5}{Journal of Symbol. Comp. 1998} \indented{1}{[3] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZA "On the Theories} \indented{5}{of Triangular Sets" Journal of Symbol. Comp. (to appear)} \indented{1}{[4] \spad{M}. MORENO MAZA "A new algorithm for computing triangular} \indented{5}{decomposition of algebra
807364`--ic varieties" NAG Tech. Rep. 4/98.}
807561`A is retractable to \spad{B} means that some elementsif A can be converted into elements of \spad{B} and any element of \spad{B} can be converted into an element of A.
807635`The category of rings with unity,{} always associative,{} but not necessarily commutative.
807676`the class of all multiplicative semigroups,{} \spadignore{i.e.} a set with an associative operation \spadop{*}. \blankline
807801`\spadtype{SetCategory} is the basic category for describing a collection of elements with \spadop{=} (equality) and \spadfun{coerce} to output form. \blankline Conditional Attributes: \indented{3}{canonical\tab{15}data structure equality is the same as \spadop{=}}
807858`\spadtype{SquareMatrixCategory} is a general square matrix category which allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and colums returned as objects of type Col.
808303`Category for the transcendental elementary functions.
808399`The category of triangular sets of multivariate polynomials with coefficients in an integral domain. Let \axiom{\spad{R}} be an integral domain and \axiom{\spad{V}} a finite ordered set of variables,{} say \axiom{\spad{X1} < \spad{X2} < ... < \spad{Xn}}. A set \axiom{\spad{S}} of polynomials in \axiom{\spad{R}[\spad{X1
808399`--},{}\spad{X2},{}...,{}\spad{Xn}]} is triangular if no elements of \axiom{\spad{S}} lies in \axiom{\spad{R}},{} and if two distinct elements of \axiom{\spad{S}} have distinct main variables. Note that the empty set is a triangular set. A triangular set is not necessarily a (lexicographical) Groebner basis and the notion of reduction related to triangular sets is based on the recursive view of polynomials. We recall this notion here and refer to [1] for more details. A polynomial \axiom{\spad{P}
808399`--} is reduced \spad{w}.\spad{r}.\spad{t} a non-constant polynomial \axiom{\spad{Q}} if the degree of \axiom{\spad{P}} in the main variable of \axiom{\spad{Q}} is less than the main degree of \axiom{\spad{Q}}. A polynomial \axiom{\spad{P}} is reduced \spad{w}.\spad{r}.\spad{t} a triangular set \axiom{\spad{T}} if it is reduced \spad{w}.\spad{r}.\spad{t}. every polynomial of \axiom{\spad{T}}. \newline References : \indented{1}{[1] \spad{P}. AUBRY,{} \spad{D}. LAZARD and \spad{M}. MORENO MAZA "On 
808399`--the Theories} \indented{5}{of Triangular Sets" Journal of Symbol. Comp. (to appear)}
808587`Category for the trigonometric functions.
808681`\indented{1}{TwoDimensionalArrayCategory is a general array category which} allows different representations and indexing schemes. Rows and columns may be extracted with rows returned as objects of type Row and columns returned as objects of type Col. The index of the 'first' row may be obtained by calling the function 'minRowInde
808681`--x'. The index of the 'first' column may be obtained by calling the function 'minColIndex'. The index of the first element of a 'Row' is the same as the index of the first column in an array and vice versa.
808943`A constructive unique factorization domain,{} \spadignore{i.e.} where we can constructively factor members into a product of a finite number of irreducible elements.
809025`This is a category of univariate Laurent series constructed from univariate Taylor series. A Laurent series is represented by a pair \spad{[n,{}f(x)]},{} where \spad{n} is an arbitrary integer and \spad{f(x)} is a Taylor series. This pair represents the Laurent series \spad{x**n * f(x)}.
809215`The category of univariate polynomials over a ring \spad{R}. No particular model is assumed - implementations can be either sparse or dense.
809318`\spadtype{UnivariatePowerSeriesCategory} is the most general univariate power series category with exponents in an ordered abelian monoid. Note: this category exports a substitution function if it is possible to multiply exponents. Note: this category exports a derivative operation if it is possible to multiply coefficients by exponents.
809471`This is a category of univariate Puiseux series constructed from univariate Laurent series. A Puiseux series is represented by a pair \spad{[r,{}f(x)]},{} where \spad{r} is a positive rational number and \spad{f(x)} is a Laurent series. This pair represents the Puiseux series \spad{f(x^r)}.
809662`This is the category of univariate skew polynomials over an Ore coefficient ring. The multiplication is given by \spad{x a = \sigma(a) x + \delta a}. This category is an evolution of the types \indented{2}{MonogenicLinearOperator,{} OppositeMonogenicLinearOperator,{} and} \indented{2}{NonCommutativeOperatorDivision} developped by Jean Della Dora and Stephen \spad{M}. Watt.
809774`\spadtype{UnivariateTaylorSeriesCategory} is the category of Taylor series in one variable.
809960`Vector Spaces (not necessarily finite dimensional) over a field.
