<html>
 <head>
  <title>
   Axiom Computer Algebra System
  </title>
 </head>
 <body bgcolor="#ffff66">
   <div id="head" align="center"> 
    <a href="http://savannah.nongnu.org/projects/axiom/">
     <img src="axiom.png" border="0" alt="Axiom">
    </a>
    <br>
    <font size=200%>
     The Scientific Computation System
    </font>
   </div>
   <div align="center">
    [
     <a href="../index.html" title="Home">
      Home
     </a>
    ]
    &nbsp
    [
     <a href="screenshots.html" title="Screen Shots">
      Screenshots
     </a>
    ]
    &nbsp
    [
     <a href="faq.html" title="FAQ">
      FAQ
     </a>
    ]
    &nbsp
    [
     <a href="download.html" title="Download">
      Download
     </a>
    ]
    &nbsp
    [
     <a href="documentation.html" title="Documentation">
      Documentation
     </a>
    ]
    &nbsp
    [
     <a href="currentstate.html" title="Current State">
      Current State
     </a>
    ]
    &nbsp
    [
     <a href="community.html" title="Community">
      Community
     </a>
    ]
    &nbsp
    [
     <a href="developers.html" title="Developers">
      Developers
     </a>
    ]
    &nbsp
    [
     <a href="patches.html" title="Patches">
      Patches
     </a>
    ]
   </div>
   <div align="center">
    [
     <a href="bookvol10.2abb.html" title="Abbreviation Graph">
      Abbreviation Graph
     </a>
    ]
    &nbsp
    [
     <a href="bookvol10.2full.html" title="Full Name Graph">
      Full Name Graph
     </a>
    ]
   </div>
  <br>
  <hr>
  <div id="body">
   <h1>
    Rosetta Stone
   </h1>
   <p>
   <font size=4>
The following is a collection of synonyms for various operations in
the computer algebra systems Axiom, Derive, GAP, DoCon,
Macsyma, Magnus, Maxima, Maple, Mathematica, MuPAD, Octave,
Pari, Reduce, Scilab, Sumit and Yacas.  This collection does not
attempt to be comprehensive, but hopefully it will be useful in giving
an indication of how to translate between the syntaxes used by the
different systems in many common situations.  Note that a blank entry
means either (a) that there may be an exact translation of a
particular operation for the indicated system, but we don't know what
it is or (b) there is no exact translation but it may still be
possible to work around this lack with a related functionality.

While commercial systems are not provided on this CD the intent of the
Rosetta effort is to make it possible for experienced Computer Algebra
users to experiment with other systems. Thus the commands for
commercial systems are included to allow users of those systems to
translate.

Some of these systems are special purpose and do not support a lot of
the functionality of the more general purpose systems. Where they do
support an interpreter the commands are provided.

Originally written by Michael Wester.
Modified for Rosetta by Timothy Daly, Alexander Hulpke (GAP).

<h3>System availability</h3>

<table>
 <tr>
  <th>System</th>
  <th>License</th>
  <th>Status (2002)</th>
  <th>URL</th>
 </tr>
 <tr>
  <td>Aldor</td>
  <td>Non-free</td>
  <td>available</td>
  <td>http://www.aldor.org</td>
 </tr>
 <tr>
 <td>Axiom</td>
 <td>ModifiedBSD</td>
 <td>available</td>
 <td>http://axiom.axiom-developer.org</td>
 </tr>
 <tr>
 <td>Derive</td>
 <td>commercial</td>
 <td>available</td>
 <td>http://www.mathware.com</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td>open source</td>
  <td>available</td>
  <td>http://www.haskell.org/docon</td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>GPL</td>
  <td>Rosetta</td>
  <td>http://www.gap-system.org/~gap</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>commercial</td>
  <td>dead</td>
  <td>unavailable</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td>GPL</td>
  <td>Rosetta</td>
  <td>http://sourceforge.net/projects/magnus</td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>GPL</td>
  <td>Rosetta</td>
  <td>http://www.ma.utexas.edu/maxima.html</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>commercial</td>
  <td>available</td>
  <td>http://www.maplesoft.com</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>commercial</td>
  <td>available</td>
  <td>http://www.wolfram.com</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>commercial</td>
  <td>available</td>
  <td>http://www.mupad.de</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>GPL</td>
  <td>Rosetta</td>
  <td>http://www.octave.org</td>
 </tr>
 <tr>
  <td>Pari</td>
  <td>GPL</td>
  <td>Rosetta</td>
  <td>http://www.parigp-home.de</td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>commercial</td>
  <td>available</td>
  <td>http://www.zib.de/Symbolik/reduce</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td>Scilab</td>
  <td>available</td>
  <td>http://www-rocq.inria.fr/scilab</td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td>available</td>
  <td>http://www-sop.inria.fr/cafe/soft-f.html</td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td>GPL</td>
  <td>available</td>
  <td>http://yacas.sourceforge.net</td>
 </tr>
</table>

<table>
<tr>
 <th>System</th>
 <th>Type</th>
 <th>Interpreted or Compiled</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>General Purpose</td>
  <td>both</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td>General Purpose</td>
  <td>Interpreted in Haskell</td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Group Theory</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td>Infinite Group Theory</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>Numerical Computing</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td>Number Theory</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td>Functional Equations</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td>General Purpose</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<h3>Programming and Miscellaneous</h3>

<table>
 <tr>
  <th>System</th>
  <th>Unix/Microsoft user initialization file</th>
  <th></th>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>.axiom.input</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>.gaprc</td>
  <td>GAP.RC</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
  <td>derive.ini</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>macsyma-init.macsyma</td>
  <td>mac-init.mac</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>macsyma-init.macsyma</td>
  <td>mac-init.mac</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>.mapleinit</td>
  <td>maplev5.ini</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>init.m</td>
  <td>init.m</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>.mupadinit</td>
  <td>\mupad\bin\userinit.mu</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>.reducerc</td>
  <td>reduce.rc</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
 <tr>
  <th>System</th>
  <th>Describe keyword</th>
  <th>Find keywords containing pattern</th>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td>)what operations pattern</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>?keyword</td>
  <td>??keyword</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>describe("keyword")\$</td>
  <td>apropos("pattern");</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>describe("keyword")\$</td>
  <td>apropos("pattern");</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>?keyword</td>
  <td>?pattern\,\fnm</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>?keyword</td>
  <td>?*pattern*</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>?keyword</td>
  <td>?*pattern*</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>help -i keyword</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

Only if the pattern is not a keyword and then the matches are simplistic.

<table>
</td>
  <th>System</th>
  <th>Comment</th>
  <th>Line Cont.</th>
  <th>Prev. Expr.</th>
  <th>Case sensitive</th>
  <th>Variables assumed</th>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>-- comment</td>
  <td>input _CR input</td>
  <td>%</td>
  <td>Yes</td>
  <td>real</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>"comment"</td>
  <td>input CRinput</td>
  <td></td>
  <td>No</td>
  <td>real</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td># comment</td>
  <td>input\CRinput</td>
  <td>last</td>
  <td>Yes</td>
  <td>no assumption</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>/* comment */</td>
  <td>input CR input;</td>
  <td>%</td>
  <td>No</td>
  <td>real</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>/* comment */</td>
  <td>input CR input;</td>
  <td>%</td>
  <td>No</td>
  <td>real</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td># comment</td>
  <td>input CR input;</td>
  <td>%</td>
  <td>Yes</td>
  <td>complex</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>(* comment *)</td>
  <td>input CR input</td>
  <td>%</td>
  <td>Yes</td>
  <td>complex</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td># comment #</td>
  <td>input CR input;</td>
  <td>%</td>
  <td>Yes</td>
  <td>complex</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>##</td>
  <td></td>
  <td></td>
  <td>Yes</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>% comment</td>
  <td>input CR input;</td>
  <td>ws</td>
  <td>No</td>
  <td>complex</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <th>System</th>
  <th>Load a file</th>
  <th>Time a command</th>
  <th>Quit</th>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>)read "file" )quiet</td>
  <td>)set messages time on</td>
  <td>)quit</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>[Transfer Load Derive]</td>
  <td></td>
  <td>[Quit]</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Read("file");</td>
  <td>time; \h{(also see {\tt Runtime();})}</td>
  <td>quit;</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>load("file")\$</td>
  <td>showtime: all\$</td>
  <td>quit();</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>load("file")\$</td>
  <td>showtime: all\$</td>
  <td>quit();</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>read("file"):</td>
  <td>readlib(showtime): on;</td>
  <td>quit</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td><< file</td>
  <td>Timing[command]</td>
  <td>Quit[]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>read("file"):</td>
  <td>time(command);</td>
  <td>quit</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>load file</td>
  <td>tic(); cmd ; toc()</td>
  <td>quit \OR\ exit</td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>in "file"\$</td>
  <td>on time;</td>
  <td>quit;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td>quit</td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Display}</td>
  <td>\h{Suppress}</td>
  <td></td>
 </tr>
 <tr>
  <td></td>
  <td>\h{output}</td>
  <td>\h{output}</td>
  <td>\h{Substitution: $f(x, y) \rightarrow f(z, w)$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>input</td>
  <td>input;</td>
  <td>subst(f(x, y), [x = z, y = w])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>input</td>
  <td>var:= input</td>
  <td>[Manage Substitute]</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>input;</td>
  <td>input;;</td>
  <td>Value(f,[x,y],[z,w]);\fnm</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>input;</td>
  <td>input\$</td>
  <td>subst([x = z, y = w], f(x, y));</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>input;</td>
  <td>input\$</td>
  <td>subst([x = z, y = w], f(x, y));</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>input;</td>
  <td>input:</td>
  <td>subs(\{x = z, y = w\}, f(x, y));</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>input</td>
  <td>input;</td>
  <td>f[x, y] /. \{x -> z, y -> w\}</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>input;</td>
  <td>input:</td>
  <td>subs(f(x, y), [x = z, y = w]);</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td>input</td>
  <td>input;</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>input;</td>
  <td>input\$</td>
  <td>sub(\{x = z, y = w\}, f(x, y));</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Set}</td>
  <td>\h{List}</td>
  <td>\h{Matrix}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>set [1, 2]</td>
  <td>[1, 2]</td>
  <td>matrix([[1, 2],[3, 4]])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>\{1, 2\}</td>
  <td>[1, 2]</td>
  <td>[[1,2], [3,4]]</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Set([1,2])</td>
  <td>[1, 2]</td>
  <td>[[1,2], [3,4]]\fnm</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>[1, 2]</td>
  <td>[1, 2]</td>
  <td>matrix([1, 2], [3, 4])</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>[1, 2]</td>
  <td>[1, 2]</td>
  <td>matrix([1, 2], [3, 4])</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>\{1, 2\}</td>
  <td>[1, 2]</td>
  <td>matrix([[1, 2], [3, 4]])</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>\{1, 2\}</td>
  <td>\{1, 2\}</td>
  <td>\{\{1, 2\}, \{3, 4\}\}</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>\{1, 2\}</td>
  <td>[1, 2]</td>
  <td>export(Dom): \q export(linalg):</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td></td>
  <td>matrix:= ExpressionField(normal)):</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td></td>
  <td>matrix([[1, 2], [3, 4]])</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>\{1, 2\}</td>
  <td>\{1, 2\}</td>
  <td>mat((1, 2), (3, 4))</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td>list(1,2)</td>
  <td>A=[1,2;3,4]</td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Equation}</td>
  <td>\h{List element}</td>
  <td>\h{Matrix element}</td>
  <td>\h{Length of a list}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>x = 0</td>
  <td>l . 2</td>
  <td>m(2, 3)</td>
  <td>\#l</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>x = 0</td>
  <td>l SUB 2</td>
  <td>m SUB 2 SUB 3</td>
  <td>DIMENSION(l)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>x=0</td>
  <td>l[2]</td>
  <td>m[2][3]</td>
  <td>Length(l)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>x = 0</td>
  <td>l[2]</td>
  <td>m[2, 3]</td>
  <td>length(l)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>x = 0</td>
  <td>l[2]</td>
  <td>m[2, 3]</td>
  <td>length(l)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>x = 0</td>
  <td>l[2]</td>
  <td>m[2, 3]</td>
  <td>nops(l)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>x == 0</td>
  <td>l[[2]]</td>
  <td>m[[2, 3]]</td>
  <td>Length[l]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>x = 0</td>
  <td>l[2]</td>
  <td>m[2, 3]</td>
  <td>nops(l)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>x = 0</td>
  <td>part(l, 2)</td>
  <td>m(2, 3)</td>
  <td>length(l)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td>l(2)</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\m{2}{\rm Prepend/append an element to a list}</td>
  <td>\h{Append two lists}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>cons(e, l)</td>
  <td>concat(l, e)</td>
  <td>append(l1, l2)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>APPEND([e], l)</td>
  <td>APPEND(l, [e])</td>
  <td>APPEND(l1, l2)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Concatenation([e],l)</td>
  <td>Add(l,e)</td>
  <td>Append(l1, l2)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>cons(e, l)</td>
  <td>endcons(e, l)</td>
  <td>append(l1, l2)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>cons(e, l)</td>
  <td>endcons(e, l)</td>
  <td>append(l1, l2)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>[e, op(l)]</td>
  <td>[op(l), e]</td>
  <td>[op(l1), op(l2)]</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Prepend[l, e]</td>
  <td>Append[l, e]</td>
  <td>Join[l1, l2]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>[e, op(l)]</td>
  <td>append(l, e)</td>
  <td>l1 . l2</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>e . l</td>
  <td>append(l, {e})</td>
  <td>append(l1, l2)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Matrix column dimension}</td>
  <td>\h{Convert a list into a column vector}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>ncols(m)</td>
  <td>transpose(matrix([l]))</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>DIMENSION(m SUB 1)</td>
  <td>[l]\`{}</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Length(mat[1])</td>
  <td>\h{objects are identical}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>mat\_\,ncols(m)</td>
  <td>transpose(matrix(l))</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>mat\_\,ncols(m)</td>
  <td>transpose(matrix(l))</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>linalg[coldim](m)</td>
  <td>linalg[transpose](matrix([l]))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Dimensions[m][[2]]</td>
  <td>Transpose[\{l\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>linalg::ncols(m)</td>
  <td>transpose(matrix([l]))\,\fnm</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(linalg)\$</td>
  <td>matrix v(length(l), 1)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>column\_dim(m)</td>
  <td>for i:=1:length(l) do</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>\q\q v(i, 1):= part(l, i)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

See the definition of matrix above.

<table>
</td>
  <td>\h{Convert a column vector into a list}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>[v(i, 1) for i in 1..nrows(v)]</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>v\`{} SUB 1</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>\h{objects are identical}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>part(transpose(v), 1)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>part(transpose(v), 1)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>op(convert(linalg[transpose](v), listlist))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Flatten[v]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>[op(v)]</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(linalg)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>for i:=1:row\_\,dim(v) collect(v(i, 1))</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{True}</td>
  <td>\h{False}</td>
  <td>\h{And}</td>
  <td>\h{Or}</td>
  <td>\h{Not}</td>
  <td>\h{Equal}</td>
  <td>\h{Not equal}
	</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>true</td>
  <td>false</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td>=</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>TRUE</td>
  <td>FALSE</td>
  <td>AND</td>
  <td>OR</td>
  <td>NOT</td>
  <td>=</td>
  <td>/=</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>true</td>
  <td>false\fnm</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td><></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>true</td>
  <td>false</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td>\#</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>true</td>
  <td>false</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td>\#</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>true</td>
  <td>false</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td><></td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>True</td>
  <td>False</td>
  <td>\</td>
  <td>\</td>
  <td></td>
  <td>||</td>
  <td>!</td>
  <td>==</td>
  <td>!=</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>true</td>
  <td>false</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td><></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>t</td>
  <td>nil</td>
  <td>and</td>
  <td>or</td>
  <td>not</td>
  <td>=</td>
  <td>neq</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td>\%t</td>
  <td>\%f</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{If+then+else statements}</td>
  <td>\h{Strings (concatenated)}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>if \_ then \_ else if \_ then \_ else \_</td>
  <td>concat(["x", "y"])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>IF(\_, \_, IF(\_, \_, \_))</td>
  <td>"xy"</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>if \_ then \_ elif \_ then \_ else \_ fi</td>
  <td>Concatenation("x","y")</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>if \_ then \_ else if \_ then \_ else \_</td>
  <td>concat("x", "y")</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>if \_ then \_ else if \_ then \_ else \_</td>
  <td>concat("x", "y")</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>if \_ then \_ elif \_ then \_ else \_ fi</td>
  <td>"x" . "y"</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>If[\_, \_, If[\_, \_, \_]]</td>
  <td>"x" <> "y"</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>if \_ then \_ elif \_ then \_ else \_</td>
  <td>"x" . "y"</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q end\_if</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>if \_ then \_ else if \_ then \_ else \_</td>
  <td>"xy" \OR\ mkid(x, y)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Simple loop and Block}</td>
  <td>\h{Generate the list $[1, 2, \ldots, n]$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>for i in 1..n repeat ( x; y )</td>
  <td>[f(i) for i in 1..n]</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>VECTOR([x, y], i, 1, n)</td>
  <td>VECTOR(f(i), i, 1, n)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>for i in [1..n] do \_ od;</td>
  <td>[1..n] {\rm or} [1,2..n]</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>for i:1 thru n do (x, y);</td>
  <td>makelist(f(i), i, 1, n);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>for i:1 thru n do (x, y);</td>
  <td>makelist(f(i), i, 1, n);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>for i from 1 to n do x; y od;</td>
  <td>[f(i) \$ i = 1..n];</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Do[x; y, \{i, 1, n\}]</td>
  <td>Table[f[i], \{i, 1, n\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>for i from 1 to n do x; y</td>
  <td>[f(i) \$ i = 1..n];</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q end\_for;</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>for i:=1:n do <<x; y>>;</td>
  <td>for i:=1:n collect f(i);</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>\end{tabular}</td>
 </tr>
 <tr>
  <td>[10pt]

\begin{tabular}{l|l}
</td>
  <td>\h{Complex loop iterating on a list}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>for x in [2, 3, 5] while x**2 < 10 repeat output(x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>for x in [2, 3, 5] do while x\^{}2<10 do Print(x);od;od;</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>for x in [2, 3, 5] while x\^{}2 < 10 do print(x)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>for x in [2, 3, 5] while x\^{}2 < 10 do print(x)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>for x in [2, 3, 5] while x\^{}2 < 10 do print(x) od:</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>For[l = \{2, 3, 5\}, l != \{\} \</td>
  <td>\</td>
  <td>l[[1]]\^{}2 < 10,</td>
 </tr>
 <tr>
  <td></td>
  <td>\q l = Rest[l], Print[l[[1]]] ]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>for x in [2, 3, 5] do if x\^{}2 < 10 then print(x) end\_if</td>
 </tr>
 <tr>
  <td></td>
  <td>\q end\_for:</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>for each x in \{2, 3, 5\} do if x\^{}2 < 10 then write(x)\$</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{\small Assignment}</td>
  <td>\h{Function definition}</td>
  <td>\h{Clear vars and funs}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>y:= f(x)</td>
  <td>f(x, y) == x*y</td>
  <td>	{\small\tt )clear properties y f}</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>y:= f(x)</td>
  <td>f(x, y):= x*y</td>
  <td>y:=  f:=</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>y:= f(x);</td>
  <td>f:=function(x, y) return x*y; end;</td>
  <td>\h{There are
no symbolic variables}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>y: f(x);</td>
  <td>f(x, y):= x*y;</td>
  <td>remvalue(y)\$</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td></td>
  <td>remfunction(f)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>y: f(x);</td>
  <td>f(x, y):= x*y;</td>
  <td>remvalue(y)\$</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td></td>
  <td>remfunction(f)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>y:= f(x);</td>
  <td>f:= proc(x, y) x*y end;</td>
  <td>y:= 'y':  f:= 'f':</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>y = f[x]</td>
  <td>f[x\_, y\_\,]:= x*y</td>
  <td>Clear[y, f]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>y:= f(x);</td>
  <td>f:= proc(x, y)</td>
  <td>y:= NIL:  f:= NIL:</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>\q\q begin x*y end\_\,proc;</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>y:= f(x);</td>
  <td>procedure f(x, y); x*y;</td>
  <td>clear y, f;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Function definition with a local variable}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>f(x) == (local n; n:= 2; n*x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>f:=function(x) local n; n:=2;return n*x; end;</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>f(x):= block([n], n: 2, n*x);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>f(x):= block([n], n: 2, n*x);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>f:= proc(x) local n; n:= 2; n*x end;</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>f[x\_\,]:= Module[\{n\}, n = 2; n*x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>f:= proc(x) local n; begin n:= 2; n*x end\_\,proc;</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>procedure f(x); begin scalar n; n:= 2; return(n*x) end;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Return unevaluated symbol}</td>
  <td>\h{Define a function from an expression}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>e:= x*y;\q 'e</td>
  <td>function(e, f, x, y)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>e:= x*y\q 'e</td>
  <td>f(x, y):== e</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>\h{No unevaluated symbols}\fnm</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>e: x*y\$\q 'e;</td>
  <td>define(f(x, y), e);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>e: x*y\$\q 'e;</td>
  <td>define(f(x, y), e);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>e:= x*y:\q 'e';</td>
  <td>f:= unapply(e, x, y);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>e = x*y;\q HoldForm[e]</td>
  <td>f[x\_, y\_\,] = e</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>e:= x*y:\q hold(e);</td>
  <td>f:= hold(func)(e, x, y);</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>e:= x*y\$</td>
  <td>for all x, y let f(x, y):= e;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

Variables can be assigned to generators of a suitable free
object, for example x:=X(Rationals,"x"); or 
f:=FreeGroup(2);x:=f.1;}.

<table>
</td>
  <td>\h{Fun.\ of an indefinite number of args}</td>
  <td>\h{Apply ``+'' to sum a list}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td>reduce(+, [1, 2])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>LST l:= l</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>lst:=function(args) \_ end;</td>
  <td>Sum([1,2])</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>lst([l]):= l;</td>
  <td>apply("+", [1, 2])</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>lst([l]):= l;</td>
  <td>apply("+", [1, 2])</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>lst:=proc() [args[1..nargs]] end;</td>
  <td>convert([1, 2], \`{}+\`{})</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>lst[l\_\,\_\,\_\,]:= \{l\}</td>
  <td>Apply[Plus, \{1, 2\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>lst:= proc(l) begin [args()]</td>
  <td>\_\,plus(op([1, 2]))</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q end\_\,proc;</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
  <td>xapply(+, \{1, 2\})\,\fnm</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

procedure xapply(f, lst); lisp(f . cdr(lst))


<table>
</td>
  <td>\h{Apply a fun.\ to a}</td>
  <td></td>
 </tr>
 <tr>
  <td></td>
  <td>\h{list of its args}</td>
  <td>\h{Map an anonymous function onto a list}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>reduce(f, l)</td>
  <td>map(x +-> x + y, [1, 2])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
  <td>x:= [1, 2]</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>VECTOR(x SUB i + y, i, 1, DIMENSION(x))</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>List(l,f)</td>
  <td>List([1,2],x->x+y)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>apply(f, l)</td>
  <td>map(lambda([x], x + y), [1, 2])</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>apply(f, l)</td>
  <td>map(lambda([x], x + y), [1, 2])</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>f(op(l))</td>
  <td>map(x -> x + y, [1, 2])</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Apply[f, l]</td>
  <td>Map[\# + y \</td>
  <td>, \{1, 2\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>f(op(l))</td>
  <td>map([1, 2], func(x + y, x))</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>xapply(f, l)\,\fnm</td>
  <td>for each x in \{1, 2\} collect x + y</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Pattern matching: $f(3 y) + f(z y) \rightarrow 3 f(y) + f(z y)$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>f:= operator('f);</td>
 </tr>
 <tr>
  <td></td>
  <td>( rule f((n | integer?(n)) * x) == n*f(x) )( \_</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q f(3*y) + f(z*y))</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>matchdeclare(n, integerp, x, true)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>defrule(fnx, f(n*x), n*f(x))\$</td>
 </tr>
 <tr>
  <td></td>
  <td>apply1(f(3*y) + f(z*y), fnx);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>matchdeclare(n, integerp, x, true)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>defrule(fnx, f(n*x), n*f(x))\$</td>
 </tr>
 <tr>
  <td></td>
  <td>apply1(f(3*y) + f(z*y), fnx);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>map(proc(q) local m;</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q if match(q = f(n*y), y, 'm') and</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q\q\q type(rhs(op(m)), integer) then</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q\q subs(m, n * f(y)) else q fi</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q end,</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q f(3*y) + f(z*y));</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>f[3*y] + f[z*y] /. f[n\_Integer * x\_\,] -> n*f[x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>d:= domain("match"): \q d::FREEVARIABLE:= TRUE:</td>
 </tr>
 <tr>
  <td></td>
  <td>n:= new(d, "n", func(testtype(m, DOM\_INT), m)):</td>
 </tr>
 <tr>
  <td></td>
  <td>x:= new(d, "x", TRUE):</td>
 </tr>
 <tr>
  <td></td>
  <td>map(f(3*y) + f(z*y),</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q proc(q) local m; begin m:= match(q, f(n*x));</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q if m = FAIL then q</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q\q else subs(hold("n" * f("x")), m) end\_if</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q end\_\,proc);</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>operator f;</td>
 </tr>
 <tr>
  <td></td>
  <td>f(3*y) + f(z*y)</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q where \{f(n * x) => n*f(x) when fixp(n)\};</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Define a new infix operator and then use it}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>\h{One can overload existing infix operators for ones own purposes}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>infix("")\$ \q ""(x, y):= sqrt(x\^{}2 + y\^{}2)\$ \q
	3  4;</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>infix("")\$ \q ""(x, y):= sqrt(x\^{}2 + y\^{}2)\$ \q
	3  4;</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>\`{}\</td>
  <td>\`{}:= (x, y) -> sqrt(x\^{}2 + y\^{}2): \q 3 \</td>
  <td> 4;
	</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>x\_ $\backslash$[Tilde] y\_:= Sqrt[x\^{}2 + y\^{}2]; \q
	3 $\backslash$[Tilde] 4</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>tilde:= proc(x, y) begin sqrt(x\^{}2 + y\^{}2) end\_\,proc:</td>
 </tr>
 <tr>
  <td></td>
  <td>\q 3 \</td>
  <td>tilde 4;</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>infix |\$ \q procedure |(x, y); sqrt(x\^{}2 + y\^{}2)\$ \q
	3 | 4;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Main expression}</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td></td>
  <td>\h{operator}</td>
  <td>\h{\nth{1} operand}</td>
  <td>\h{List of expression operands}</td>
 </tr>
 <tr>
  <td>Axiom\fnm</td>
  <td></td>
  <td>kernels(e) . 1</td>
  <td>kernels(e)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
  <td></td>
  <td>{\em various}\fnm</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>\m{3}{\rm There are no formal unevaluated expressions}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>part(e, 0)</td>
  <td>part(e, 1)</td>
  <td>args(e)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>part(e, 0)</td>
  <td>part(e, 1)</td>
  <td>args(e)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>op(0, e)</td>
  <td>op(1, e)</td>
  <td>[op(e)]</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Head[e]</td>
  <td>e[[1]]</td>
  <td>ReplacePart[e, List, 0]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>op(e, 0)</td>
  <td>op(e, 1)</td>
  <td>[op(e)]</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>part(e, 0)</td>
  <td>part(e, 1)</td>
  <td>for i:=1:arglength(e)</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td></td>
  <td>\q\q collect part(e, i)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

The following commands work only on expressions that consist of a
single level (e.g., $x + y + z$ but not $a/b + c/d$).
TERMS, FACTORS, NUMERATOR, LHS, etc.

<table>
</td>
  <td>\h{Print text and results}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>output(concat(["sin(", string(0), ") = ",</td>
 </tr>
 <tr>
  <td></td>
  <td>\q string(sin(0))]));</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>"sin(0)" = sin(0)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Print("There is no sin, but factors(10)= ",Factors(10),
"$\backslash$n")</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>print("sin(", 0, ") =", sin(0))\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>print("sin(", 0, ") =", sin(0))\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>printf("sin(\%a) = \%a$\backslash$n", 0, sin(0)):</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Print[StringForm["sin(\`{}\`{}) = \`{}\`{}", 0, Sin[0]]];</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>print(Unquoted, "sin(".0.")" = sin(0)):</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>write("sin(", 0, ") = ", sin(0))\$</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Generate FORTRAN}</td>
  <td>\h{Generate \TeX/\LaTeX}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>outputAsFortran(e)</td>
  <td>outputAsTex(e)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>[Transfer Save Fortran]</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td>Print(LaTeX(e));</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>fortran(e)\$ \OR gentran(eval(e))\$</td>
  <td>tex(e);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>fortran(e)\$ \OR gentran(eval(e))\$</td>
  <td>tex(e);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>fortran([e]);</td>
  <td>latex(e);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>FortranForm[e]</td>
  <td>TexForm[e]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>generate::fortran(e);</td>
  <td>generate::TeX(e);</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>on fort; \q e; \q off fort; \OR</td>
  <td>load\_\,package(tri)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>load\_\,package(gentran)\$ gentran e;</td>
  <td>on TeX; e; off TeX;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Import two space separated columns of integers from {\tt file}}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>[Transfer Load daTa] ({\rm from} file.dat)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>xy: read\_num\_data\_to\_matrix("file", nrows, 2)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>xy: read\_num\_data\_to\_matrix("file", nrows, 2)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>xy:= readdata("file", integer, 2):</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>xy = ReadList["file", Number, RecordLists -> True]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Export two space separated columns of integers to {\tt file}\fnm}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>)set output algebra "file" \q ({\rm creates} file.spout)</td>
 </tr>
 <tr>
  <td></td>
  <td>for i in 1..n repeat output( \_</td>
 </tr>
 <tr>
  <td></td>
  <td>\q concat([string(xy(i, 1)), " ", string(xy(i, 2))]) )</td>
 </tr>
 <tr>
  <td></td>
  <td>)set output algebra console</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>xy  [Transfer Print Expressions File]\q({\rm creates} file.prt)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>PrintTo("file");for i in [1..n] do</td>
 </tr>
 <tr>
  <td></td>
  <td>\q AppendTo("file",xy[i][1]," ",xy[i][2],"$\backslash$n");od;</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>writefile("file")\$ \q for i:1 thru n do</td>
 </tr>
 <tr>
  <td></td>
  <td>\q print(xy[i, 1], xy[i, 2])\$ \q closefile()\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>writefile("file")\$ \q for i:1 thru n do</td>
 </tr>
 <tr>
  <td></td>
  <td>\q print(xy[i, 1], xy[i, 2])\$ \q closefile()\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>writedata("file", xy);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>outfile = OpenWrite["file"];</td>
 </tr>
 <tr>
  <td></td>
  <td>Do[WriteString[outfile,</td>
 </tr>
 <tr>
  <td></td>
  <td>\q xy[[i, 1]], " ", xy[[i, 2]], "$\backslash$n"], \{i, 1, n\}]</td>
 </tr>
 <tr>
  <td></td>
  <td>Close[outfile];</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>fprint(Unquoted, Text, "file",</td>
 </tr>
 <tr>
  <td></td>
  <td>\q ("$\backslash$n", xy[i, 1], xy[i, 2]) \$ i = 1..n):</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>out "file"; \q for i:=1:n do</td>
 </tr>
 <tr>
  <td></td>
  <td>\q write(xy(i, 1), " ", xy(i, 2)); \q shut "file";</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<p>
Some editing of file will be necessary for all systems but
Maple and Mathematica.
</p>

<h3>Mathematics and Graphics</h3>

Since GAP aims at discrete mathematics, it does not provide much of
the calculus functionality listed in the following section.

<table>
</td>
  <td>$e$</td>
  <td>$\pi$</td>
  <td>$i$</td>
  <td>$+\infty$</td>
  <td>$\sqrt{2}$</td>
  <td>$2^{1/3}$</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>\%e</td>
  <td>\%pi</td>
  <td>\%i</td>
  <td>\%plusInfinity</td>
  <td>sqrt(2)</td>
  <td>2**(1/3)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>\#e</td>
  <td>pi</td>
  <td>\#i</td>
  <td>inf</td>
  <td>SQRT(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
  <td>E(4)</td>
  <td>infinity</td>
  <td>ER(2)\fnm</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>\%e</td>
  <td>\%pi</td>
  <td>\%i</td>
  <td>inf</td>
  <td>sqrt(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>\%e</td>
  <td>\%pi</td>
  <td>\%i</td>
  <td>inf</td>
  <td>sqrt(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>exp(1)</td>
  <td>Pi</td>
  <td>I</td>
  <td>infinity</td>
  <td>sqrt(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>E</td>
  <td>Pi</td>
  <td>I</td>
  <td>Infinity</td>
  <td>Sqrt[2]</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>E</td>
  <td>PI</td>
  <td>I</td>
  <td>infinity</td>
  <td>sqrt(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>e</td>
  <td>pi</td>
  <td>i</td>
  <td>infinity</td>
  <td>sqrt(2)</td>
  <td>2\^{}(1/3)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>
<b>ER</b> represents special cyclotomic numbers and is not a
root function.}

<table>
</td>
  <td>\h{Euler's constant}</td>
  <td>\h{Natural log}</td>
  <td>\h{Arctangent}</td>
  <td>$n!$</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td>log(x)</td>
  <td>atan(x)</td>
  <td>factorial(n)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>euler\_\,gamma</td>
  <td>LOG(x)</td>
  <td>ATAN(x)</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td>LogInt(x,base)</td>
  <td></td>
  <td>Factorial(n)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>\%gamma</td>
  <td>log(x)</td>
  <td>atan(x)</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>\%gamma</td>
  <td>log(x)</td>
  <td>atan(x)</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>gamma</td>
  <td>log(x)</td>
  <td>arctan(x)</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>EulerGamma</td>
  <td>Log[x]</td>
  <td>ArcTan[x]</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>EULER</td>
  <td>ln(x)</td>
  <td>atan(x)</td>
  <td>n!</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>Euler\_\,Gamma</td>
  <td>log(x)</td>
  <td>atan(x)</td>
  <td>factorial(n)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Legendre polynomial}</td>
  <td>\h{Chebyshev poly.\ of the \nth{1} kind}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>legendreP(n, x)</td>
  <td>chebyshevT(n, x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>LEGENDRE\_\,P(n, x)</td>
  <td>CHEBYCHEV\_\,T(n, x)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>legendre\_\,p(n, x)</td>
  <td>chebyshev\_\,t(n, x)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>legendre\_\,p(n, x)</td>
  <td>chebyshev\_\,t(n, x)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>orthopoly[P](n, x)</td>
  <td>orthopoly[T](n, x)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>LegendreP[n, x]</td>
  <td>ChebyshevT[n, x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>orthpoly::legendre(n, x)</td>
  <td>orthpoly::chebyshev1(n, x)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>LegendreP(n, x)</td>
  <td>ChebyshevT(n, x)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Fibonacci number}</td>
  <td>\h{Elliptic integral of the \nth{1} kind}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>fibonacci(n)</td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>FIBONACCI(n)</td>
  <td>ELLIPTIC\_\,E(phi, k\^{}2)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Fibonacci(n)</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>fib(n)</td>
  <td>elliptic\_\,e(phi, k\^{}2)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>fib(n)</td>
  <td>elliptic\_\,e(phi, k\^{}2)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>combinat[fibonacci](n)</td>
  <td>EllipticE(sin(phi), k)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Fibonacci[n]</td>
  <td>EllipticE[phi, k\^{}2]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>numlib::fibonacci(n)</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
  <td>EllipticE(phi, k\^{}2)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>$\Gamma(x)$</td>
  <td>$\psi(x)$</td>
  <td>\h{Cosine integral}</td>
  <td>\h{Bessel fun.\ (\nth{1})}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>Gamma(x)</td>
  <td>psi(x)</td>
  <td>real(Ei(\%i*x))</td>
  <td>besselJ(n, x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>GAMMA(x)</td>
  <td>PSI(x)</td>
  <td>CI(x)</td>
  <td>BESSEL\_\,J(n, x)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>gamma(x)</td>
  <td>psi[0](x)</td>
  <td>cos\_\,int(x)</td>
  <td>bessel\_j[n](x)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>gamma(x)</td>
  <td>psi[0](x)</td>
  <td>cos\_\,int(x)</td>
  <td>bessel\_j[n](x)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>GAMMA(x)</td>
  <td>Psi(x)</td>
  <td>Ci(x)</td>
  <td>BesselJ(n, x)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Gamma[x]</td>
  <td>PolyGamma[x]</td>
  <td>CosIntegral[x]</td>
  <td>BesselJ[n, x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>gamma(x)</td>
  <td>psi(x)</td>
  <td></td>
  <td>besselJ(n, x)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>Gamma(x)</td>
  <td>Psi(x)</td>
  <td>Ci(x)</td>
  <td>BesselJ(n, x)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Hypergeometric fun.\ ${}_2F_1(a, b; c; x)$}</td>
  <td>\h{Dirac delta}</td>
  <td>	\h{Unit step fun.}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>GAUSS(a, b, c, x)</td>
  <td></td>
  <td>STEP(x)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>hgfred([a, b], [c], x)</td>
  <td>delta(x)</td>
  <td>unit\_\,step(x)
	</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>hgfred([a, b], [c], x)</td>
  <td>delta(x)</td>
  <td>unit\_\,step(x)
	</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>hypergeom([a, b], [c], x)</td>
  <td>Dirac(x)</td>
  <td>Heaviside(x)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>HypergeometricPFQ[\{a,b\},\{c\},x]</td>
  <td>	\m{2}{<< Calculus\`{}DiracDelta\`{}}</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td></td>
  <td>dirac(x)</td>
  <td>heaviside(x)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>hypergeometric(\{a, b\}, \{c\}, x)</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Define $|x|$ via a piecewise function}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>a(x):= -x*CHI(-inf, x, 0) + x*CHI(0, x, inf)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>a(x):= -x*unit\_\,step(-x) + x*unit\_\,step(x)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>a(x):= -x*unit\_\,step(-x) + x*unit\_\,step(x)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>a:= x -> piecewise(x < 0, -x, x):</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td><< Calculus\`{}DiracDelta\`{}</td>
 </tr>
 <tr>
  <td></td>
  <td>a[x\_]:= -x*UnitStep[-x] + x*UnitStep[x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>a:= proc(x) begin -x*heaviside(-x) + x*heaviside(x)</td>
 </tr>
 <tr>
  <td></td>
  <td>\q\q end\_\,proc:</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Assume $x$ is real}</td>
  <td>\h{Remove that assumption}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>x :epsilon Real</td>
  <td>x:=</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>declare(x, real)\$</td>
  <td>remove(x, real)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>declare(x, real)\$</td>
  <td>remove(x, real)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>assume(x, real);</td>
  <td>x:= 'x':</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>x/: Im[x] = 0;</td>
  <td>Clear[x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>assume(x, Type::RealNum):</td>
  <td>unassume(x, Type::RealNum):</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Assume $0 < x \le 1$}</td>
  <td>\h{Remove that assumption}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>x :epsilon (0, 1]</td>
  <td>x:=</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>assume(x > 0, x <= 1)\$</td>
  <td>forget(x > 0, x <= 1)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>assume(x > 0, x <= 1)\$</td>
  <td>forget(x > 0, x <= 1)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>assume(x > 0);</td>
  <td>x:= 'x':</td>
 </tr>
 <tr>
  <td></td>
  <td>additionally(x <= 1);</td>
  <td></td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Assumptions -> 0 < x <= 1\,\fnm</td>
  <td></td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>assume(x > 0):  assume(x <= 1):</td>
  <td>unassume(x):</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

Note: This is an option for {\tt Integrate}.}

<table>
</td>
  <td>\h{Basic simplification of an expression $e$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>simplify(e) \OR\ normalize(e) \OR\ complexNormalize(e)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>e</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>e</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>ratsimp(e) \OR\ radcan(e)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>ratsimp(e) \OR\ radcan(e)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>simplify(e)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Simplify[e] \OR\ FullSimplify[e]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>simplify(e) \OR\ normal(e)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>e</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Use an unknown function}</td>
  <td>\h{Numerically evaluate an expr.}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>f:= operator('f); \q f(x)</td>
  <td>exp(1) :: Complex Float</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>f(x):=</td>
  <td>Precision:= Approximate</td>
 </tr>
 <tr>
  <td></td>
  <td>f(x)</td>
  <td>APPROX(EXP(1))</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>Precision:= Exact</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td>EvalF(123/456)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>f(x)</td>
  <td>sfloat(exp(1));</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>f(x)</td>
  <td>sfloat(exp(1));</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>f(x)</td>
  <td>evalf(exp(1));</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>f[x]</td>
  <td>N[Exp[1]]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>f(x)</td>
  <td>float(exp(1));</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>operator f; \q f(x)</td>
  <td>on rounded; \q exp(1);</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>off rounded;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>$ n \bmod m$</td>
  <td>\h{Solve $e \equiv 0 \bmod m$ for $x$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>rem(n, m)</td>
  <td>solve(e = 0 :: PrimeField(m), x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>MOD(n, m)</td>
  <td>SOLVE\_\,MOD(e = 0, x, m)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>n mod m</td>
  <td>\h{solve using finite fields}</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>mod(n, m)</td>
  <td>modulus: m\$ \q solve(e = 0, x)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>mod(n, m)</td>
  <td>modulus: m\$ \q solve(e = 0, x)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>n mod m</td>
  <td>msolve(e = 0, m)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Mod[n, m]</td>
  <td>Solve[\{e == 0, Modulus == m\}, x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>n mod m</td>
  <td>solve(poly(e = 0, [x], IntMod(m)), x)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>on modular;</td>
  <td>load\_\,package(modsr)\$ \q on modular;</td>
 </tr>
 <tr>
  <td></td>
  <td>setmod m\$ \q n</td>
  <td>setmod m\$ \q m\_solve(e = 0, x)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Put over common denominator}</td>
  <td>\h{Expand into separate fractions}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>a/b + c/d</td>
  <td>(a*d + b*c)/(b*d) :: \_</td>
 </tr>
 <tr>
  <td></td>
  <td></td>
  <td>\q MPOLY([a], FRAC POLY INT)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>FACTOR(a/b + c/d, Trivial)</td>
  <td>EXPAND((a*d + b*c)/(b*d))</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>a/b+c/d</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>xthru(a/b + c/d)</td>
  <td>expand((a*d + b*c)/(b*d))</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>xthru(a/b + c/d)</td>
  <td>expand((a*d + b*c)/(b*d))</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>normal(a/b + c/d)</td>
  <td>expand((a*d + b*c)/(b*d))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Together[a/b + c/d]</td>
  <td>Apart[(a*d + b*c)/(b*d)]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>normal(a/b + c/d)</td>
  <td>expand((a*d + b*c)/(b*d))</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>a/b + c/d</td>
  <td>on div;  (a*d + b*c)/(b*d)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Manipulate the root of a polynomial}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>a:= rootOf(x**2 - 2); \q a**2</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>x:=X(Rationals,"x");</td>
 </tr>
 <tr>
  <td></td>
  <td>\q a:=RootOfDefiningPolynomial(AlgebraicExtension(Rationals,x\^{}2-2));
a\^{}2</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>algebraic:true\$ \q tellrat(a\^{}2 - 2)\$ \q rat(a\^{}2);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>algebraic:true\$ \q tellrat(a\^{}2 - 2)\$ \q rat(a\^{}2);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>a:= RootOf(x\^{}2 - 2): \q simplify(a\^{}2);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>a = Root[\#\^{}2 - 2 \</td>
  <td>, 2] \q a\^{}2</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(arnum)\$ \q defpoly(a\^{}2 - 2); \q a\^{}2;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Noncommutative multiplication}</td>
  <td>\h{Solve a pair of equations}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td></td>
  <td>solve([eqn1, eqn2], [x, y])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>x :epsilon Nonscalar</td>
  <td>SOLVE([eqn1, eqn2], [x, y])</td>
 </tr>
 <tr>
  <td></td>
  <td>y :epsilon Nonscalar</td>
  <td></td>
 </tr>
 <tr>
  <td></td>
  <td>x . y</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>*</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>x . y</td>
  <td>solve([eqn1, eqn2], [x, y])</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>x . y</td>
  <td>solve([eqn1, eqn2], [x, y])</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>x \</td>
  <td>* y</td>
  <td>solve(\{eqn1, eqn2\}, \{x, y\})</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>x ** y</td>
  <td>Solve[\{eqn1, eqn2\}, \{x, y\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td></td>
  <td>solve(\{eqn1, eqn2\}, \{x, y\})</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>operator x, y;</td>
  <td>solve(\{eqn1, eqn2\}, \{x, y\})</td>
 </tr>
 <tr>
  <td></td>
  <td>noncom x, y;</td>
  <td></td>
 </tr>
 <tr>
  <td></td>
  <td>x() * y()</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\m{2}{\rm Decrease/increase angles in trigonometric functions}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>\m{2}{simplify(normalize(sin(2*x)))}</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>Trigonometry:= Expand</td>
  <td>Trigonometry:= Collect</td>
 </tr>
 <tr>
  <td></td>
  <td>sin(2*x)</td>
  <td>2*sin(x)*cos(x)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>trigexpand(sin(2*x))</td>
  <td>trigreduce(2*sin(x)*cos(x))</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>trigexpand(sin(2*x))</td>
  <td>trigreduce(2*sin(x)*cos(x))</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>expand(sin(2*x))</td>
  <td>combine(2*sin(x)*cos(x))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>TrigExpand[Sin[2*x]]</td>
  <td>TrigReduce[2*Sin[x]*Cos[x]]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>expand(sin(2*x))</td>
  <td>combine(2*sin(x)*cos(x), sincos)
	</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(assist)\$</td>
 </tr>
 <tr>
  <td></td>
  <td>trigexpand(sin(2*x))</td>
  <td>trigreduce(2*sin(x)*cos(x))</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Gr\"obner basis}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>groebner([p1, p2, ...])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>grobner([p1, p2, ...])</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>grobner([p1, p2, ...])</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>Groebner[gbasis]([p1, p2, ...], plex(x1, x2, ...))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>GroebnerBasis[\{p1, p2, ...\}, \{x1, x2, ...\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>groebner::gbasis([p1, p2, ...])</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(groebner)\$ \q groebner(\{p1, p2, ...\})</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Factorization of $e$ over $i = \sqrt{-1}$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>factor(e, [rootOf(i**2 + 1)])</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>FACTOR(e, Complex)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Factors(GaussianIntegers,e)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>gfactor(e); \OR\ factor(e, i\^{}2 + 1);</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>gfactor(e); \OR\ factor(e, i\^{}2 + 1);</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>factor(e, I);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Factor[e, Extension -> I]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>QI:= Dom::AlgebraicExtension(Dom::Rational, i\^{}2 + 1);</td>
 </tr>
 <tr>
  <td></td>
  <td>QI::name:= "QI": \q Factor(poly(e, QI));</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>on complex, factor; \q e; \q off complex, factor;</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Real part}</td>
  <td>\h{Convert a complex expr.\ to rectangular form}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>real(f(z))</td>
  <td>complexForm(f(z))</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>RE(f(z))</td>
  <td>f(z)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>(f(z)+GaloisCyc(f(z),-1))/2</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>realpart(f(z))</td>
  <td>rectform(f(z))</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>realpart(f(z))</td>
  <td>rectform(f(z))</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>Re(f(z))</td>
  <td>evalc(f(z))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Re[f[z]]</td>
  <td>ComplexExpand[f[z]]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>Re(f(z))</td>
  <td>rectform(f(z))</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>repart(f(z))</td>
  <td>repart(f(z)) + i*impart(f(z))</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Matrix addition}</td>
  <td>\h{Matrix multiplication}</td>
  <td>\h{Matrix transpose}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>A + B</td>
  <td>A * B</td>
  <td>transpose(A)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>A + B</td>
  <td>A . B</td>
  <td>A\`{}</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>A + B</td>
  <td>A * B</td>
  <td>TransposedMat(A)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>A + B</td>
  <td>A . B</td>
  <td>transpose(A)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>A + B</td>
  <td>A . B</td>
  <td>transpose(A)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>evalm(A + B)</td>
  <td>evalm(A \</td>
  <td>* B)</td>
  <td>linalg[transpose](A)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>A + B</td>
  <td>A . B</td>
  <td>Transpose[A]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>A + B</td>
  <td>A * B</td>
  <td>transpose(A)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>A + B</td>
  <td>A * B</td>
  <td>tp(A)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Solve the matrix equation $A x = b$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>solve(A, transpose(b)) . 1 . particular :: Matrix \_\_\_</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>SolutionMat(TransposedMat(A),b)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>xx: genvector('x, mat\_nrows(b))\$</td>
 </tr>
 <tr>
  <td></td>
  <td>x: part(matlinsolve(A . xx = b, xx), 1, 2)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>xx: genvector('x, mat\_nrows(b))\$</td>
 </tr>
 <tr>
  <td></td>
  <td>x: part(matlinsolve(A . xx = b, xx), 1, 2)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>x:= linalg[linsolve](A, b)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>x = LinearSolve[A, b]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td></td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Sum: $\sum_{i = 1}^n f(i)$}</td>
  <td>\h{Product: $\prod_{i = 1}^n f(i)$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>sum(f(i), i = 1..n)</td>
  <td>product(f(i), i = 1..n)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>SUM(f(i), i, 1, n)</td>
  <td>PRODUCT(f(i), i, 1, n)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td>Sum([1..n],f)</td>
  <td>Product([1..n],f)</td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>closedform(</td>
  <td>closedform(</td>
 </tr>
 <tr>
  <td></td>
  <td>\q sum(f(i), i, 1, n))</td>
  <td>\q product(f(i), i, 1, n))</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>closedform(</td>
  <td>closedform(</td>
 </tr>
 <tr>
  <td></td>
  <td>\q sum(f(i), i, 1, n))</td>
  <td>\q product(f(i), i, 1, n))</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>sum(f(i), i = 1..n)</td>
  <td>product(f(i), i = 1..n)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Sum[f[i], \{i, 1, n\}]</td>
  <td>Product[f[i], \{i, 1, n\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>sum(f(i), i = 1..n)</td>
  <td>product(f(i), i = 1..n)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>sum(f(i), i, 1, n)</td>
  <td>prod(f(i), i, 1, n)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Limit: $\lim_{x \rightarrow 0-} f(x)$}</td>
  <td>\h{Taylor/Laurent/etc.\ series}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>limit(f(x), x = 0, "left")</td>
  <td>series(f(x), x = 0, 3)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>LIM(f(x), x, 0, -1)</td>
  <td>TAYLOR(f(x), x, 0, 3)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>limit(f(x), x, 0, minus)</td>
  <td>taylor(f(x), x, 0, 3)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>limit(f(x), x, 0, minus)</td>
  <td>taylor(f(x), x, 0, 3)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>limit(f(x), x = 0, left)</td>
  <td>series(f(x), x = 0, 4)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Limit[f[x], x->0, Direction->1]</td>
  <td>Series[f[x],\{x, 0, 3\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>limit(f(x), x = 0, Left)</td>
  <td>series(f(x), x = 0, 4)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>limit!-(f(x), x, 0)</td>
  <td>taylor(f(x), x, 0, 3)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Differentiate: $\frac{d^3 f(x, y)}{dx \, dy^2}$}</td>
  <td>	\h{Integrate: $\int_0^1 f(x) \, dx$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>D(f(x, y), [x, y], [1, 2])</td>
  <td>integrate(f(x), x = 0..1)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>DIF(DIF(f(x, y), x), y, 2)</td>
  <td>INT(f(x), x, 0, 1)</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>diff(f(x, y), x, 1, y, 2)</td>
  <td>integrate(f(x), x, 0, 1)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>diff(f(x, y), x, 1, y, 2)</td>
  <td>integrate(f(x), x, 0, 1)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>diff(f(x, y), x, y\$2)</td>
  <td>int(f(x), x = 0..1)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>D[f[x, y], x, \{y, 2\}]</td>
  <td>Integrate[f[x], \{x, 0, 1\}]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>diff(f(x, y), x, y\$2)</td>
  <td>int(f(x), x = 0..1)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>df(f(x, y), x, y, 2)</td>
  <td>int(f(x), x, 0, 1)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Laplace transform}</td>
  <td>\h{Inverse Laplace transform}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>laplace(e, t, s)</td>
  <td>inverseLaplace(e, s, t)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>LAPLACE(e, t, s)</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>laplace(e, t, s)</td>
  <td>ilt(e, s, t)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>laplace(e, t, s)</td>
  <td>ilt(e, s, t)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>inttrans[laplace](e,t,s)</td>
  <td>inttrans[invlaplace](e,s,t)</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>\m{2}{\q << Calculus\`{}LaplaceTransform\`{}}</td>
 </tr>
 <tr>
  <td></td>
  <td>LaplaceTransform[e, t, s]</td>
  <td>{\st InverseLaplaceTransform[e,s,t]}
	</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>transform::laplace(e,t,s)</td>
  <td>transform::ilaplace(e, s, t)</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>\m{2}{\q load\_\,package(laplace)\$ \q load\_\,package(defint)\$}
	</td>
 </tr>
 <tr>
  <td></td>
  <td>laplace(e, t, s)</td>
  <td>invlap(e, t, s)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Solve an ODE (with the initial condition $y'(0) = 1$)}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>solve(eqn, y, x)</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>APPLY\_\,IC(RHS(ODE(eqn, x, y, y\_)), [x, 0], [y, 1])</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>ode\_ibc(ode(eqn, y(x), x), x = 0, diff(y(x), x) = 1)</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>ode\_ibc(ode(eqn, y(x), x), x = 0, diff(y(x), x) = 1)</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>dsolve(\{eqn, D(y)(0) = 1\}, y(x))</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>DSolve[\{eqn, y'[0] == 1\}, y[x], x]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>solve(ode(\{eqn, D(y)(0) = 1\}, y(x)))</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>odesolve(eqn, y(x), x)</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{Define the differential operator $L = D_x + I$ and apply it to $\sin x$}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>DD : LODO(Expression Integer, e +-> D(e, x)) := D();</td>
 </tr>
 <tr>
  <td></td>
  <td>L:= DD + 1; \q L(sin(x))</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td></td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>load(opalg)\$ \q L: (diffop(x) - 1)\$ \q L(sin(x));</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>load(opalg)\$ \q L: (diffop(x) - 1)\$ \q L(sin(x));</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>id:= x -> x: \q L:= (D + id): \q L(sin)(x);</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>L = D[\#, x]\</td>
  <td>+ Identity; \q Through[L[Sin[x]]]</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>L:= (D + id): \q L(sin)(x);</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td></td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
</td>
  <td>\h{2D plot of two separate curves overlayed}</td>
 </tr>
 <tr>
  <td>Axiom</td>
  <td>draw(x, x = 0..1); \q draw(acsch(x), x = 0..1);</td>
 </tr>
 <tr>
  <td>Derive</td>
  <td>[Plot Overlay]</td>
 </tr>
 <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td>Macsyma</td>
  <td>plot(x, x, 0, 1)\$ \q plot(acsch(x), x, 0, 1)\$</td>
 </tr>
 <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td>Maxima</td>
  <td>plot(x, x, 0, 1)\$ \q plot(acsch(x), x, 0, 1)\$</td>
 </tr>
 <tr>
  <td>Maple</td>
  <td>plot(\{x, arccsch(x)\}, x = 0..1):</td>
 </tr>
 <tr>
  <td>Mathematica</td>
  <td>Plot[\{x, ArcCsch[x]\}, \{x, 0, 1\}];</td>
 </tr>
 <tr>
  <td>MuPAD</td>
  <td>plotfunc(x, acsch(x), x = 0..1):</td>
 </tr>
 <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td>Reduce</td>
  <td>load\_\,package(gnuplot)\$ \q plot(y = x, x = (0 .. 1))\$</td>
 </tr>
 <tr>
  <td></td>
  <td>plot(y = acsch(x), x = (0 .. 1))\$</td>
 </tr>
 <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

<table>
 <tr>
  
  <th>System</th>
  <th>Simple 3D plotting</th>
 
 </tr>
 <tr>
  <td> <tr>
  <td>Axiom</td>
  <td>draw(abs(x*y), x = 0..1, y = 0..1);</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Derive</td>
  <td>[Plot Overlay]</td>
 </tr>
 <tr>
  <td> <tr>
  <td>DoCon</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>GAP</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Macsyma</td>
  <td>plot3d(abs(x*y), x, 0, 1, y, 0, 1)\$</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Magnus</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Maxima</td>
  <td>plot3d(abs(x*y), x, 0, 1, y, 0, 1)\$</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Maple</td>
  <td>plot3d(abs(x*y), x = 0..1, y = 0..1):</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Mathematica</td>
  <td>Plot3D[Abs[x*y], \{x, 0, 1\}, \{y, 0, 1\}];</td>
 </tr>
 <tr>
  <td> <tr>
  <td>MuPAD</td>
  <td>plotfunc(abs(x*y), x = 0..1, y = 0..1):</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Octave</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Pari</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Reduce</td>
  <td>load\_\,package(gnuplot)\$</td>
 </tr>
 <tr>
  <td> <tr>
  <td></td>
  <td>plot(z = abs(x*y), x = (0 .. 1), y = (0 .. 1))\$</td>
 </tr>
 <tr>
  <td> <tr>
  <td>Scilab</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Sumit</td>
  <td></td>
 </tr>
 <tr>
  <td> <tr>
  <td>Yacas</td>
  <td></td>
 </tr>
 <tr>
  <td>
</table>

</body>
</html>


