#!/bin/sh

# usage:
#    document [options] file
#    [ plus any legacy usage ]
#
# options:
#    --index
#       Run makeindex on the input file
#
#    --latex
#       Typeset input file assuming it a LaTeX file
#
#    --output=outfile
#       Set the output filename.
#
#    --tangle
#    --tangle=chunk
#       Run notangle on the input file assumed to be a pamphlet.
#
#    --weave 
#       Run noweave on the input file assumed to be a pamphlet
#       When combined with --output, also run latex.
#    --
#       Anything that comes after is treated as an argument, even
#       if it looks like an option


# set -x

# Issue a diagnostic message and exit with non-zero status.
error() {
    echo "error: $1"
    exit 1
}

# Issue a diagnostic if an option ($1) requires a argument
# and its value ($2) is empty.
maybe_missing_value_for() {
    if test -z $2; then
	error "missing value for $1"
    fi
}

# Check validity of --tag.  At the moment
# we support only "boot" and "lisp"
check_tag_value() {
    case $1 in
	boot|lisp) 
           tag=$1
           ;;
	*)
	   error "invalid tag $1"
	   ;;
    esac
}

# Validate argument for --mode.  We support only
#  - "compile", for Lisp source file
#  - "translate", for Boot source file
check_mode_value() {
    case $1 in
	compile|translate)
           mode=$1
	   ;;
	*)
	   error "invalid mode $1"
	   ;;
    esac
}


do_index=
do_latex=
do_tangle=
do_weave=
chunk=
file=
output=
tag=
mode=

while test $# -gt 0 ; do
    optval=$1

    case $optval in
	--)
	   break
	   ;;
	--*=*)
	   arg=`echo $optval | sed -e 's/^[-a-zA-Z]*=//'`
	   opt=`echo $optval | sed -e 's/=.*$//'`
	   shift;
	   ;;
	--*)
	   opt=$optval
	   arg=
	   shift
	   ;;
	*)
	   break
	   ;;
    esac

    case $opt in
	--weave)
	   do_weave=yes
	   ;;

        --latex)
	   do_latex=yes
           ;;

        --index)
	   do_index=yes
	   # FIXME: --index may be used only with --latex.  Check.
           ;;

	--tangle)
	   do_tangle=yes
	   if test -n "$arg"; then
	       chunk=$arg
	   fi
	   # --tangle may not be combined with any other
	   # options.  FIXME:  Check that. 
	   ;;

	--output)
	   maybe_missing_value_for $opt $arg
	   output=$arg
	   ;;

	--tag)
	   maybe_missing_value_for $opt $arg
	   check_tag_value $arg
	  ;;
	
	--mode)
 	   maybe_missing_value_for $opt $arg
	   check_mode_value $arg
	   ;;

	--*)
	   echo unrecognized option $opt
	   exit 1
	   ;;
    esac
done

if test x$do_tangle = xyes; then
    # FIXME: Check that the input file name does indeed have
    # a pamphlet extension.
    file=$1
    if [ -z $output ]; then
	output=`basename $file .pamphlet`;
    fi

    # FIXME: Ideally, we should just prepend -R to $chunk
    #        if it is non-null, and say $tangle $chunk $file > $output
    #        Alternatively, we could initialize chunk to '*' and
    #        unconditionally use -R"$chunk".
    if [ -z "$chunk" ]; then
	notangle $file > $output
    else
	notangle -R"$chunk" $file > $output
    fi
    # FIXME: Handle errors.
    exit $?;
fi


if test x$do_weave = xyes; then
    file=`basename $1 .pamphlet`
    noweave -delay $1 > $file.tex
    if test x$do_latex != xyes; then
	exit 0;
    fi
fi

if test x$do_latex = xyes; then
    if [ -z $file ]; then
	file=`basename $1 .tex`
    fi
    latex --interaction nonstopmode $file;
    if [ x$do_index = xyes ]; then
	makeindex $file.idx
    fi
    latex --interaction nonstopmode $file;
    exit $?
fi

# We only support translation of Boot source files, and
# compilation of Lisp source files
case $mode,$tag in
    translate,boot)
       cmd=$1
       shift
       
       # The bootsys image is currently unable to pass up an
       # exit status that we can hand to the shell.  When an error
       # occurs, bootsys just prints a message and exits as if 
       # everything went well.  To work around that, we have to 
       # capture its output, look for specific patterns, and then
       # return an appropriate exit status.
       # mktemp is used to create a temporary file; for systems that
       # lack support for mktemp, e.g. MinGW/MSYS, we use the common
       # trick of forging a filename based on the pid.
       if `which mktemp`; then
	   tmpfile=`mktemp document.XXXXXX` || exit 1
       else
	   tmpfile=document.$$
       fi
       trap "rm -f $tmpfile" 1 2 15
       $cmd -batch -eval "(boottran::boottoclc \"$1\")" | tee $tmpfile
       grep 'ERROR IN' $tmpfile >/dev/null && { rm $tmpfile; exit 1; }
       rm $tmpfile && exit 0
       ;;

    compile,lisp)
       cmd=$1
       shift
       $cmd -batch -eval "(compile-file \"$1\" :output-file \"$output\")"
       exit $?
       ;;
esac


if [ "$#" = "3" ]; then
 REDIRECT=$2
 FILE=`basename $3 .pamphlet`
 notangle -t8 $FILE.pamphlet >$FILE
 noweave -delay $FILE.pamphlet >$FILE.tex
 latex --interaction nonstopmode $FILE.tex >$REDIRECT
 latex --interaction nonstopmode $FILE.tex >$REDIRECT
 rm -f $FILE~
 rm -f $FILE.pamphlet~
 rm -f $FILE.log
 rm -f $FILE.tex
 rm -f $FILE.toc
 rm -f $FILE.aux
 exit 0
fi
if [ "$#" = "1" ]; then
 FILE=`basename $1 .pamphlet`
 notangle -t8 $FILE.pamphlet >$FILE
 noweave -delay $FILE.pamphlet >$FILE.tex
 latex $FILE.tex 
 latex $FILE.tex
 rm -f $FILE~
 rm -f $FILE.pamphlet~
 rm -f $FILE.log
 rm -f $FILE.tex
 rm -f $FILE.toc
 rm -f $FILE.aux
 exit 0
fi
echo "document [ -o redirect ] pamphlet"

# set +x

