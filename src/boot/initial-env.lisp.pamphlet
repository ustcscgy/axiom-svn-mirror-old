%% Oh Emacs, this is a -*- Lisp -*- file despite apperance.
\documentclass{article}
\usepackage{axiom}

\title{\File{src/boot/initial-env.lisp} Pamphlet}
\author{Gabriel Dos~Reis \and Timothy Daly}

\begin{document}
\maketitle

\begin{abstract}
  This pamphlet defines the base initial environment for building
  a Boot translator image.  It essentially etablishes a namespace
  (package \Code{Boot}) for the Boot translator, and defines 
  some macros that need to be present during translation of Boot
  source files.
\end{abstract}

\tableofcontents
\eject

\section{License}

<<license>>=
;; Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are
;; met:
;;
;;     - Redistributions of source code must retain the above copyright
;;       notice, this list of conditions and the following disclaimer.
;;
;;     - Redistributions in binary form must reproduce the above copyright
;;       notice, this list of conditions and the following disclaimer in
;;       the documentation and/or other materials provided with the
;;       distribution.
;;
;;     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
;;       names of its contributors may be used to endorse or promote products
;;       derived from this software without specific prior written permission.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
;; IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
;; TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
;; PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
;; OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@

\section{The \code{BOOTTRAN} package}

All Boot translator functions are defined in the package
\code{BOOTTRAN}.  It is expected that the translator interfaces
with the rest of the system only through the functions explicitly exported
by \code{BOOTTRAN}:
<<boot-translator>>=
(defpackage "BOOTTRAN"
#+:common-lisp  (:use "COMMON-LISP")
#-:common-lisp  (:use "LISP" "SYSTEM"))

;; ECL does not load the compiler module by default.  Therefore, we
;; must require that appropriate symbols be present.
#+:ecl (require 'cmp)
@

\section{I/O macros}

The Boot translator source codes make uses of some 
higher order functions.  For various reasons, including efficiency,
they are defined as Lisp macros and must therefore be available in each
source file that uses them.

\subsection{[[shoeInputFile]]}

<<with-input-file>>=
(defmacro |shoeOpenInputFile|
     (stream fn prog)
    `(with-open-file (,stream ,fn :direction :input
       :if-does-not-exist nil) ,prog))
@

This macro creates a input stream object from a file name [[fn]], and 
processes it with [[prog]].  If the file name designates a non-existent 
file, the standard input is used instead.

\subsection{[[shoeOpenOutputFile]]}
<<with-output-file>>=
(defmacro |shoeOpenOutputFile|
     (stream fn prog)
    `(with-open-file (,stream ,fn :direction :output
       :if-exists :supersede) ,prog))
@

This macro creates an output stream object from a file name [[fn]], and 
processes it with [[prog]].  The output file is overwritten if it exists.


\section{Interface with the build machinery}

Lisp implementations seem to fill all the implemented-defined 
design space fuzzily described by Common Lisp standard.  What
that means for us is that we need to provide abstractions that
encapsulate all those variabilities in Lisp systems we care about.
The functions defined in the next few subsections interface with
our build-machinery.

\subsection{Translating Boot to Lisp}


When working in batch mode, we need to return so-called `exit status'
to the calling shell.  Common Lisp has no provision for that ---
not even exiting from the toplevel read-eval-print loop.  Most
Lisp implementations provide an `exit' function as extensions, though
they don't agree on the exact spelling, therefore on the API.

The function [[exit-repl]] is our abstractions over those variabilties.
It takes an optional small integer value, the exit status code to
return to the calling shell.  When no exit status code is specified,
it would return $0$, meaning that everything is OK.

<<exit-repl>>=
(defun exit-repl(&optional (status 0))
  #+sbcl (sb-ext:quit :unix-status status)
  #+clisp (ext:quit status)
  #+gcl (quit status)
  #-(or :sbcl :clisp :gcl) (error "exit-repl not implemented for this Lisp"))
@

\subsection{Building new Lisp images}

At many points, the build machinery makes new Lisp images that
are the results of augmenting a given Lisp image with new 
Lisp files (either compiled or in source form).  For most Lisp
implementations, this is done by loading the Lisp files in the 
current image and dumping the result on disk as an executable.
<<make-program>>=
(defun |getOutputFile| (options &optional (default-output "a.out"))
  (let ((output-option (assoc '|output| options)))
    (if output-option
	;; If an output file name was specified on the command line, it
	;; is so relative to the current workding directory.  In 
	;; particular we want to prevent overly zelous SBCL to mess
	;; around with the output file when we call compile-file-pathname. 
	;; The SBCL-specific hack below does not work all the time, but in
	;; most cases, it is OK.
	#+:sbcl (merge-pathnames (cdr output-option)
				 *default-pathname-defaults*)
	#-:sbcl (cdr output-option)
	default-output)))
  

;; Save current image on disk as executable and quit.
(defun save-core (core-image &optional (main nil))
  #+:sbcl (if (null main)
	      (sb-ext::save-lisp-and-die core-image :executable t)
	    (sb-ext::save-lisp-and-die core-image 
				       :toplevel main
				       :executable t))
  #+:gcl (progn 
	   (when main 
	     (setq si::*top-level-hook* main))
	   (system::save-system core-image))
  #+:clisp (progn 
	     (if main
		 (ext::saveinitmem core-image 
				   :init-function main
				   :executable t
				   :norc t
				   )
	       (ext::saveinitmem core-image 
				 :executable t
				 :norc t
				 ))
	     (ext::quit)))

(defun make-program (core-image lisp-files)
  (mapcar #'load lisp-files)
  (save-core core-image #'main-entry-point))

(defun |makeHandler| (prog-name options args)
  (declare (ignore prog-name))
  (unless (> (length args) 1)
    (|fatalError| "--make requires at least one file"))

  (make-program (|getOutputFile| options) args)
  (exit-repl))

@
[[core-image]] is a string designating the name of the resulting program;
[[lisp-files]] is a list of strings designating Lisp files to combine
with the base Lisp system.

\section{Putting it together}

<<*>>=
<<license>>

<<boot-translator>>

(in-package "BOOTTRAN")

;## need the conditional here so it appears in boottran
#+:ieee-floating-point (defparameter $ieee t)
#-:ieee-floating-point (defparameter $ieee nil)

(defmacro memq (a b) `(member ,a ,b :test #'eq))
(defvar *lisp-bin-filetype* "o")
(defvar *lisp-source-filetype* "lisp")
(defun setdifference (x y) (set-difference x y))
(defun make-cvec (sint) (make-string sint))
(defun MAKE-VEC (n) (make-array n))
(defun concat (&rest l)
  (progn
    (setq l (mapcar #'string l))
    (apply #'concatenate 'string l)))

(defun |shoeInputFile| (filespec )
  (open filespec :direction :input :if-does-not-exist nil))

<<with-input-file>>

<<with-output-file>>

(defun shoeprettyprin1 (x &optional (stream *standard-output*))
  (let ((*print-pretty* t)
	(*print-array* t)
	(*print-circle* t)
	(*print-level* nil)
	(*print-length* nil))
    (prin1 x stream)))
 
(defun reallyprettyprint (x &optional (stream *terminal-io*))
  (shoeprettyprin1 x stream) (terpri stream))
 
(defun shoeprettyprin0 (x &optional (stream *standard-output*))
  (let ((*print-pretty* nil)
	(*print-array* t)
	(*print-circle* t)
	(*print-level* nil)
	(*print-length* nil))
    (prin1 x stream)))
 
(defun shoenotprettyprint (x &optional (stream *terminal-io*))
  (shoeprettyprin0 x stream) (terpri stream))

(defun make-full-cvec (sint &optional (char #\space))
  (make-string sint :initial-element (character char)))

(defun |shoePLACEP| (item) 
  (eq item nil))

(defun substring (cvec start length)
  (if length (subseq cvec start (+ start length))
    (subseq cvec start)))

(defun MAKE-HASHTABLE (id1)
  (let ((test (case id1
		    ((EQ ID) #'eq)
		    (CVEC #'equal)
		    ((UEQUAL EQUAL) #'equal)
		    (otherwise (error "bad arg to make-hashtable")))))
    (make-hash-table :test test)))

(defun HKEYS (table)
  (let (keys)
    (maphash #'(lambda (key val) 
		 (declare (ignore val))
		 (push key keys)) table)
    keys))


(defun HPUT (table key value)
  (setf (gethash key table) value))
 
(defun QENUM (cvec ind)
  (char-code (char cvec ind)))
 
(defun charmem (a b)
  (member  a  b :test #'eql))

(defun |shoeIdChar| (x)
  (or (ALPHANUMERICP x)
      (charmem x '(#\' #\? #\%))))

(defun |shoeStartsId| (x)
  (or (alpha-char-p x)
      (charmem x '(#\$ #\? #\%))))
 
(defun strpos (what in start dontcare)
  (setq what (string what) in (string in))
  (if dontcare (progn (setq dontcare (character dontcare))
		      (search what in :start2 start
			      :test #'(lambda (x y) (or (eql x dontcare)
							(eql x y)))))
    (search what in :start2 start)))
 

(defun strposl (table cvec sint item)
  (setq cvec (string cvec))
  (if (not item)
      (position table cvec :test #'(lambda (x y) (position y x)) :start sint)
    (position table cvec :test-not #'(lambda (x y) (position y x))
	      :start sint  )))

(defun VEC-SETELT (vec ind val) 
  (setf (elt vec ind) val))

(defun  bvec-make-full (n x)
  (make-array (list n) :element-type 'bit :initial-element x))

(defun make-bvec (n)
  (bvec-make-full n 0))
 
(defun bvec-setelt (bv i x)
  (setf (sbit bv i) x))

(defun size (l)
  (cond ((vectorp l) (length l))
	((consp l) (list-length l))
	(t 0)))

(defun identp (a) 
  (and (symbolp a) a))

(defun |shoeReadLisp| (s n)
  (multiple-value-list (read-from-string s nil nil :start n)))

(defun |last| (x)
  (car (last x)))

#+ :sbcl
(defun shoe-provide-module(name)
  (load name)
  (provide name))

#+ :sbcl
(eval-when (:load-toplevel :execute)
   (pushnew #'shoe-provide-module sb-ext:*module-provider-functions*))

<<exit-repl>>

<<make-program>>

;; Basic diagnostic machinery:
;;    For the most basic batch stuff, we want:
;;       (1) fatal error: output message and exit with nonzero status
;;       (2) internal error: same.  This is for use on reporting internal
;;           consistency error.
(defun diagnostic-message(msg)
  (write-line msg *error-output*))

(defun |fatalError|(msg)
  (diagnostic-message (concatenate 'string "fatal error: " msg))
  (exit-repl 1))

(defun |internalError|(msg)
  (diagnostic-message (concatenate 'string "internal error: " msg))
  (exit-repl 1))


;; Keep count of number of hard errors.
(defparameter |$errorCount| 0)

;; Global map from requests  to drivers.
;; Ideally we want to handle
;;    --help: just print a help menu and exit
;;    --version: Print version information and exit
;;    --compile: boot or lisp files
;;    --translate: boot files
;;    --make: boot, lisp, or fasl files
(defparameter |$driverTable| (make-hash-table :test #'equal :size 5))

(defparameter |$LispFileType| '|lisp|)

;; Look up the driver that can handle REQUEST.  Returns nil when
;; no driver exists.
(defun |getDriver| (request)
  (gethash request |$driverTable|))

(defun has-handler? (request)
  (|getDriver| request))

(defun |handleRequest| (prog-name request options args)
  (let ((driver (|getDriver| request)))
    (when (null driver) 
      (|fatalError| (format nil "invalid option ~S" request)))
    (funcall driver prog-name options args)
    (when (> |$errorCount| 0)
      (exit-repl 1))))

(defun use-file-type? (request)
  (get request 'use-file-type))


(defun |installDriver| (request driver)
  (when (|getDriver| request) 
    (|internalError| "attempt to override driver"))
  (setf (gethash request |$driverTable|) driver))
  

;; Register DRIVER for a REQUEST
(defun |associateRequestWithFileType| (request file-type driver)
  ;; If a driver is already installed, it must be non-null. 
  ;; We don't allow overriding at the moment.
  (let ((key (cons request file-type)))
    (unless (use-file-type? request)
      (setf (get request 'use-file-type) t))
    (|installDriver| key driver)))
      

;; Print help screen
(defun |printUsage|(prog-name)
  (write-line "usage:")
  (write-line 
   (concatenate 'string prog-name " -- options [files]"))
  (write-line "option:")
  (write-line "   --help                 print this message")
  (write-line "   --compile              compile file")
  (write-line "   --output=OUT           set output file to OUT")
  (write-line "   --load-directory=DIR   use DIR as search path for modules")
  (write-line "   --make                 create an executable"))


(defun |helpHandler|(prog-name)
  (|printUsage| prog-name)
  (exit-repl))

(defun |compileLispFile| (prog-name options file)
  (declare (ignore prog-name))
  (let ((out-file (|getOutputFile| options (compile-file-pathname file))))
    (compile-file file :output-file (pathname out-file))
    (exit-repl)))

(defun |getFileType|(file)
  (let ((file-type (pathname-type file)))
    (cond ((or (equal "clisp" file-type)
	       (equal "lsp" file-type))
	   |$LispFileType|)
	  (t (intern file-type)))))

;; Ideally, we would just like to have a traditional command line
;; passing mechanism from the shell to the application.  That 
;; mechanism works fine with GCL.  Some Lisp implementations such as
;; SBCL or CLISP will insist on processing the command lines.  Some
;; such CLISP will barfle when they hit an option they don't 
;; understand.  Which is silly.  It seems like the only common ground,
;; as ever, is to go with the most annoying behaviour and penalize
;; the good "citizen", sensible, Lisp implementations interfaces.
;; Consequently, we have standardize on the the following practice:
;; always issue a double bash (--) after the command line, and afterwards
;; supply options and other arguments.  The double dash has the effect
;; of disuading the underlying lisp implementation of trying to
;; process whatever comes after as options.  

;; Command line arguments: equivalent of traditional `argv[]' from
;;  systems programming world.
(defun get-command-line-arguments()
  #-(or :gcl :sbcl :clisp) 
  (|fatalError| "don't know how to get command line args")
  (let* ((all-args  
	  #+:gcl si::*command-args*
	  #+:sbcl sb-ext::*posix-argv*
	  #+:clisp (coerce (ext::argv) 'list))
	 (args (member "--" all-args :test #'equal)))
    (cons (car all-args) (if args (cdr args) args))))



;; Returns a pair (name . value) if OPTION if of the form "--name=value",
;; where name is a symbol and value is a string.  Otherwise, if
;; OPTION is of the form "--name", returns the symbol name.
(defun get-option-value (option)
  (setq option (subseq option 2))
  (let ((p (position #\= option)))
    (if p
	(cons (intern (subseq option 0 p)) (subseq option (1+ p)))
      (intern option))))


;; Walk through the command line arguments ARGV, separating options of
;; one of the form --opt or --opt=val into an a-list, and the rest
;; of the command line into a list.  The processing stop as soon as
;; a non-option form is encountered. OPTIONS-SO-FAR accumulates the
;; the list of processed options.
(defun process-command-line (argv options-so-far)
  (if (and argv
	   (equal "--" (subseq (car argv) 0 2)))
      (let ((option (get-option-value (car argv))))
	(cond ((symbolp option)
	       (process-command-line (cdr argv)
				     (cons (cons option t) options-so-far)))
	      ((consp option) 
	       (process-command-line (cdr argv) (cons option options-so-far)))
	      (t (|internalError|
		  (format nil "process-command-line: unknown option ~S"
			  option)))))
    (values options-so-far argv)))


(defun handle-command-line (prog-name options args)
  (unless options			; we certainly require options
	 (|printUsage| prog-name)
	 (exit-repl 1))
  (dolist (opt options)
    (cond ((eq (car opt) '|help|)	; print help, get out of here
	   (|helpHandler| prog-name))
	
	  ((null args)		       ; we must have at least one arg
	   (|printUsage| prog-name)
	   (exit-repl 1))
	
	  ((use-file-type? (car opt))	; process based on file type
	   (dolist (f args)
	     (let* ((file-type (|getFileType| f))
		    (opt-name (car opt))
		    (request (cons opt-name file-type)))
	       (|handleRequest| prog-name request
		(cons (cons file-type opt-name) options) f))))

	  ((stringp (cdr opt))		; option value
	   (when (has-handler? (car opt))
	     (|handleRequest| prog-name (car opt) options args)))
	  
	  (t				; assume we must execute this
	   (|handleRequest| prog-name (car opt) options args)))))
	   

;; The top level entry point to saved Lisp image.
(defun main-entry-point()
  #+ :gcl (setq *package* (find-package "BOOTTRAN"))
  (let ((command-args (get-command-line-arguments)))
    (when (null command-args) 
      (|internalError| "empty command line args"))
    ;; Existing system programming practive, and POSIX, have it
    ;; that the first argument on the command line is the name
    ;; of the current instantiation of the program.
    ;; We require at least two arguments:
    ;;    (0) the program name
    ;;    (1) either one of --help or --version, or
    ;;        a filename.
    (multiple-value-bind 
     (options args)
     (process-command-line (cdr command-args) nil)

     (handle-command-line (car command-args) options args)
     (exit-repl (if (> 0 |$errorCount|) 1 0)))))


;; 
(eval-when (:load-toplevel :execute)
(progn

(defun |error| (msg)
  (setq |$errorCount| (1+ |$errorCount|))
  (diagnostic-message (reduce #'concat (list* "error: " msg)
			      :initial-value "")))

;; Extenstion of FASL files.
(defparameter |$faslType|
  (pathname-type (compile-file-pathname "foo.lisp")))

;; List of directories to search for FASLs.
(defparameter |$LoadDirectories| nil)


;; List of FASLs imported
(defparameter |$ImportedModules| nil)

;; Return true if MODULE is known to have been imported or loaded.
(defun already-loaded? (module)
  (declare (special |$ImportedModules|))
  (member module |$ImportedModules| :test #'equal))

;; Remember that MODULE is imported or loaded.
(defun record-module-as-loaded (module)
  (declare (special |$ImportedModules|))
  (pushnew module |$ImportedModules|))

;; Remember value specified for the --load-dircetory option.  Notice
;; that this is the direct handler for that option.  Consequently, it
;; passed all three arguments: PROG-NAME OPTIONS ARGS.  Only the second
;; argument is of interest.
(defun record-load-directory (prog-name options args)
  (declare (ignore prog-name args)
	   (special |$LoadDirectories|))
  (let ((load-option (assoc '|load-directory| options)))
    (unless load-option
      (|internalError| "record-load-directory called without option"))
    (unless (cdr load-option)
      (|fatalError| "--load-directory option without value"))
    (pushnew (cdr load-option) |$LoadDirectories| :test #'equal)))

;; We are searching for MODULE (currently a FASL) in DIRECTORY.  So, this
;; function returns a (tentative) pathname designating that module.
(defun make-load-path (module dir)
  (declare (special |$faslType|))
  (let ((l (length dir)))
    (unless (> l 0)
      (|fatalError| "load directory with empty name"))
    (unless (char= (char dir (- l 1)) #\/)
      (setq dir (concat dir "/")))
    (make-pathname :directory (pathname-directory dir)
		   :name module
		   :type |$faslType|)))


(defun do-import-module (module directories)
  (unless directories
    (|fatalError| (format nil "module ~S not found in search path ~S"
			  module directories)))
  (unless (already-loaded? module)
    (let* ((lib (probe-file (make-load-path module (car directories)))))
      (if lib
	  (progn 
	    (load lib)
	    (record-module-as-loaded module))
	(do-import-module module (cdr directories))))))


(defun import-module (module)
  (declare (special |$LoadDirectories|))
  (do-import-module module |$LoadDirectories|))

))


;; Install some essential handlers.
(eval-when (:load-toplevel :execute)
	   (progn
	     (|installDriver| '|help| #'|helpHandler|)
	     (|installDriver| '|make| #'|makeHandler|)
	     (|associateRequestWithFileType| '|compile| |$LispFileType|
	      #'|compileLispFile|)
	     (|installDriver| '|load-directory|
	      #'record-load-directory)
	     ))
@


\end{document}
