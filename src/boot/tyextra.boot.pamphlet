\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/boot tyextra.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

)package 'BOOTTRAN
bpStruct()==
   bpEqKey "STRUCTURE" and
      (bpName() or bpTrap()) and
        (bpEqKey "DEF" or bpTrap()) and
           bpTypeList() and bpPush bfStruct(bpPop2(),bpPop1())
 
bpTypeList() == bpPileBracketed function bpTypeItemList
       or bpTerm() and bpPush [bpPop1()]
 
bpTypeItemList() ==  bpListAndRecover function bpTerm
 
bpTerm() ==
          (bpName() or bpTrap()) and
            ((bpParenthesized function bpIdList and
              bpPush bfNameArgs (bpPop2(),bpPop1()))
                or bpName() and bpPush bfNameArgs(bpPop2(),bpPop1()))
                 or bpPush(bfNameOnly bpPop1())
 
bpIdList()== bpTuple function bpName
 
bfNameOnly x==
      if x="t"
      then ["T"]
      else  [x]
 
bfNameArgs (x,y)==
    y:=if EQCAR(y,"TUPLE") then CDR y else [y]
    cons(x,y)
 
bfStruct(name,arglist)==
  bfTuple [bfCreateDef i for i in arglist]
 
bfCreateDef x==
     if null cdr x
     then
       f:=car x
       ["SETQ",f,["LIST",["QUOTE",f]]]
     else
       a:=[bfGenSymbol() for i in cdr x]
       ["DEFUN",car x,a,["CONS",["QUOTE",car x],["LIST",:a]]]
 
bpCase()==
      bpEqKey "CASE" and
        (bpWhere() or bpTrap()) and
           (bpEqKey "OF" or bpMissing "OF") and
                 bpPiledCaseItems()
 
bpPiledCaseItems()==
   bpPileBracketed function bpCaseItemList and
       bpPush bfCase(bpPop2(),bpPop1())
bpCaseItemList()==
   bpListAndRecover function bpCaseItem
 
bpCaseItem()==
    (bpTerm() or bpTrap()) and
       (bpEqKey "EXIT" or bpTrap()) and
         (bpWhere() or bpTrap()) and
            bpPush bfCaseItem (bpPop2(),bpPop1())
 
bfCaseItem(x,y)==[x,y]
 
bfCase(x,y)==
         g:=bfGenSymbol()
         g1:=bfGenSymbol()
         a:=bfLET(g,x)
         b:=bfLET(g1,["CDR",g])
         c:=bfCaseItems (g1,y)
         bfMKPROGN [a,b,["CASE",["CAR", g],:c]]
 
bfCaseItems(g,x)==  [bfCI(g,i,j) for [i,j] in x]
 
bfCI(g,x,y)==
    a:=cdr x
    if null a
    then [car x,y]
    else
       b:=[[i,bfCARCDR(j,g)] for i in a for j in 0..]
       [car x,["LET",b,y]]
 
bfCARCDR (n,g)==[INTERN CONCAT ('"CA",bfDs n,'"R"),g]
 
bfDs n== if n=0 then '"" else CONCAT('"D",bfDs(n-1))
 
 
 
 
@
<<tyextra.clisp>>=

(IN-PACKAGE 'BOOTTRAN)

(DEFUN |bpStruct| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'STRUCTURE) (OR (|bpName|) (|bpTrap|))
           (OR (|bpEqKey| 'DEF) (|bpTrap|)) (|bpTypeList|)
           (|bpPush| (|bfStruct| (|bpPop2|) (|bpPop1|)))))))

(DEFUN |bpTypeList| ()
  (PROG ()
    (RETURN
      (OR (|bpPileBracketed| #'|bpTypeItemList|)
          (AND (|bpTerm|) (|bpPush| (LIST (|bpPop1|))))))))

(DEFUN |bpTypeItemList| ()
  (PROG () (RETURN (|bpListAndRecover| #'|bpTerm|))))

(DEFUN |bpTerm| ()
  (PROG ()
    (RETURN
      (OR (AND (OR (|bpName|) (|bpTrap|))
               (OR (AND (|bpParenthesized| #'|bpIdList|)
                        (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))
                   (AND (|bpName|)
                        (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))))
          (|bpPush| (|bfNameOnly| (|bpPop1|)))))))

(DEFUN |bpIdList| () (PROG () (RETURN (|bpTuple| #'|bpName|))))

(DEFUN |bfNameOnly| (|x|)
  (PROG () (RETURN (COND ((EQ |x| '|t|) (LIST 'T)) ('T (LIST |x|))))))

(DEFUN |bfNameArgs| (|x| |y|)
  (PROG ()
    (RETURN
      (PROGN
        (SETQ |y|
              (COND ((EQCAR |y| 'TUPLE) (CDR |y|)) ('T (LIST |y|))))
        (CONS |x| |y|)))))

(DEFUN |bfStruct| (|name| |arglist|)
  (PROG ()
    (RETURN
      (|bfTuple|
          ((LAMBDA (|bfVar#2| |bfVar#1| |i|)
             (LOOP
               (COND
                 ((OR (ATOM |bfVar#1|)
                      (PROGN (SETQ |i| (CAR |bfVar#1|)) NIL))
                  (RETURN (NREVERSE |bfVar#2|)))
                 ('T
                  (SETQ |bfVar#2| (CONS (|bfCreateDef| |i|) |bfVar#2|))))
               (SETQ |bfVar#1| (CDR |bfVar#1|))))
           NIL |arglist| NIL)))))

(DEFUN |bfCreateDef| (|x|)
  (PROG (|a| |f|)
    (RETURN
      (COND
        ((NULL (CDR |x|)) (SETQ |f| (CAR |x|))
         (LIST 'SETQ |f| (LIST 'LIST (LIST 'QUOTE |f|))))
        ('T
         (SETQ |a|
               ((LAMBDA (|bfVar#4| |bfVar#3| |i|)
                  (LOOP
                    (COND
                      ((OR (ATOM |bfVar#3|)
                           (PROGN (SETQ |i| (CAR |bfVar#3|)) NIL))
                       (RETURN (NREVERSE |bfVar#4|)))
                      ('T
                       (SETQ |bfVar#4|
                             (CONS (|bfGenSymbol|) |bfVar#4|))))
                    (SETQ |bfVar#3| (CDR |bfVar#3|))))
                NIL (CDR |x|) NIL))
         (LIST 'DEFUN (CAR |x|) |a|
               (LIST 'CONS (LIST 'QUOTE (CAR |x|)) (CONS 'LIST |a|))))))))

(DEFUN |bpCase| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'CASE) (OR (|bpWhere|) (|bpTrap|))
           (OR (|bpEqKey| 'OF) (|bpMissing| 'OF)) (|bpPiledCaseItems|)))))

(DEFUN |bpPiledCaseItems| ()
  (PROG ()
    (RETURN
      (AND (|bpPileBracketed| #'|bpCaseItemList|)
           (|bpPush| (|bfCase| (|bpPop2|) (|bpPop1|)))))))

(DEFUN |bpCaseItemList| ()
  (PROG () (RETURN (|bpListAndRecover| #'|bpCaseItem|))))

(DEFUN |bpCaseItem| ()
  (PROG ()
    (RETURN
      (AND (OR (|bpTerm|) (|bpTrap|)) (OR (|bpEqKey| 'EXIT) (|bpTrap|))
           (OR (|bpWhere|) (|bpTrap|))
           (|bpPush| (|bfCaseItem| (|bpPop2|) (|bpPop1|)))))))

(DEFUN |bfCaseItem| (|x| |y|) (PROG () (RETURN (LIST |x| |y|))))

(DEFUN |bfCase| (|x| |y|)
  (PROG (|c| |b| |a| |g1| |g|)
    (RETURN
      (PROGN
        (SETQ |g| (|bfGenSymbol|))
        (SETQ |g1| (|bfGenSymbol|))
        (SETQ |a| (|bfLET| |g| |x|))
        (SETQ |b| (|bfLET| |g1| (LIST 'CDR |g|)))
        (SETQ |c| (|bfCaseItems| |g1| |y|))
        (|bfMKPROGN|
            (LIST |a| |b| (CONS 'CASE (CONS (LIST 'CAR |g|) |c|))))))))

(DEFUN |bfCaseItems| (|g| |x|)
  (PROG (|j| |ISTMP#1| |i|)
    (RETURN
      ((LAMBDA (|bfVar#7| |bfVar#6| |bfVar#5|)
         (LOOP
           (COND
             ((OR (ATOM |bfVar#6|)
                  (PROGN (SETQ |bfVar#5| (CAR |bfVar#6|)) NIL))
              (RETURN (NREVERSE |bfVar#7|)))
             ('T
              (AND (CONSP |bfVar#5|)
                   (PROGN
                     (SETQ |i| (CAR |bfVar#5|))
                     (SETQ |ISTMP#1| (CDR |bfVar#5|))
                     (AND (CONSP |ISTMP#1|) (EQ (CDR |ISTMP#1|) NIL)
                          (PROGN (SETQ |j| (CAR |ISTMP#1|)) 'T)))
                   (SETQ |bfVar#7|
                         (CONS (|bfCI| |g| |i| |j|) |bfVar#7|)))))
           (SETQ |bfVar#6| (CDR |bfVar#6|))))
       NIL |x| NIL))))

(DEFUN |bfCI| (|g| |x| |y|)
  (PROG (|b| |a|)
    (RETURN
      (PROGN
        (SETQ |a| (CDR |x|))
        (COND
          ((NULL |a|) (LIST (CAR |x|) |y|))
          ('T
           (SETQ |b|
                 ((LAMBDA (|bfVar#9| |bfVar#8| |i| |j|)
                    (LOOP
                      (COND
                        ((OR (ATOM |bfVar#8|)
                             (PROGN (SETQ |i| (CAR |bfVar#8|)) NIL))
                         (RETURN (NREVERSE |bfVar#9|)))
                        ('T
                         (SETQ |bfVar#9|
                               (CONS (LIST |i| (|bfCARCDR| |j| |g|))
                                     |bfVar#9|))))
                      (SETQ |bfVar#8| (CDR |bfVar#8|))
                      (SETQ |j| (+ |j| 1))))
                  NIL |a| NIL 0))
           (LIST (CAR |x|) (LIST 'LET |b| |y|))))))))

(DEFUN |bfCARCDR| (|n| |g|)
  (PROG ()
    (RETURN (LIST (INTERN (CONCAT "CA" (|bfDs| |n|) "R")) |g|))))

(DEFUN |bfDs| (|n|)
  (PROG ()
    (RETURN
      (COND ((EQL |n| 0) "") ('T (CONCAT "D" (|bfDs| (- |n| 1))))))))

@

\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
