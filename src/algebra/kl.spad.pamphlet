\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra kl.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package SCACHE SortedCache}
<<package SCACHE SortedCache>>=
)abbrev package SCACHE SortedCache
++ Cache of elements in a set
++ Author: Manuel Bronstein
++ Date Created: 31 Oct 1988
++ Date Last Updated: 14 May 1991
++   A sorted cache of a cachable set S is a dynamic structure that
++   keeps the elements of S sorted and assigns an integer to each
++   element of S once it is in the cache. This way, equality and ordering
++   on S are tested directly on the integers associated with the elements
++   of S, once they have been entered in the cache.
SortedCache(S:CachableSet): Exports == Implementation where
  N    ==> NonNegativeInteger
  DIFF ==> 1024

  Exports ==> with
    clearCache  : () -> Void
      ++ clearCache() empties the cache.
    cache       : () -> List S
      ++ cache() returns the current cache as a list.
    enterInCache: (S, S -> Boolean) -> S
      ++ enterInCache(x, f) enters x in the cache, calling \spad{f(y)} to
      ++ determine whether x is equal to y. It returns x with an integer
      ++ associated with it.
    enterInCache: (S, (S, S) -> Integer) -> S
      ++ enterInCache(x, f) enters x in the cache, calling \spad{f(x, y)} to
      ++ determine whether \spad{x < y (f(x,y) < 0), x = y (f(x,y) = 0)}, or
      ++ \spad{x > y (f(x,y) > 0)}.
      ++ It returns x with an integer associated with it.

  Implementation ==> add
    shiftCache   : (List S, N) -> Void
    insertInCache: (List S, List S, S, N) -> S

    cach := [nil()]$Record(cche:List S)

    cache() == cach.cche

    shiftCache(l, n) ==
      for x in l repeat setPosition(x, n + position x)
      void

    clearCache() ==
      for x in cache repeat setPosition(x, 0)
      cach.cche := nil()
      void

    enterInCache(x:S, equal?:S -> Boolean) ==
      scan := cache()
      while not null scan repeat
        equal?(y := first scan) =>
          setPosition(x, position y)
          return y
        scan := rest scan
      setPosition(x, 1 + #cache())
      cach.cche := concat(cache(), x)
      x

    enterInCache(x:S, triage:(S, S) -> Integer) ==
      scan := cache()
      pos:N:= 0
      for i in 1..#scan repeat
        zero?(n := triage(x, y := first scan)) =>
          setPosition(x, position y)
          return y
        n<0 => return insertInCache(first(cache(),(i-1)::N),scan,x,pos)
        scan := rest scan
        pos  := position y
      setPosition(x, pos + DIFF)
      cach.cche := concat(cache(), x)
      x

    insertInCache(before, after, x, pos) ==
      if ((pos+1) = position first after) then shiftCache(after, DIFF)
      setPosition(x, pos + (((position first after) - pos)::N quo 2))
      cach.cche := concat(before, concat(x, after))
      x

@
\section{domain MKCHSET MakeCachableSet}
<<domain MKCHSET MakeCachableSet>>=
)abbrev domain MKCHSET MakeCachableSet
++ Make a cachable set from any set
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description:
++   MakeCachableSet(S) returns a cachable set which is equal to S as a set.
MakeCachableSet(S:SetCategory): Exports == Implementation where
  Exports ==> Join(CachableSet, CoercibleTo S) with
    coerce: S -> %
      ++ coerce(s) returns s viewed as an element of %.

  Implementation ==> add
    import SortedCache(%)

    Rep := Record(setpart: S, pos: NonNegativeInteger)

    clearCache()

    position x             == x.pos
    setPosition(x, n)      == (x.pos := n; void)
    coerce(x:%):S          == x.setpart
    coerce(x:%):OutputForm == x::S::OutputForm
    coerce(s:S):%          == enterInCache([s, 0]$Rep, s = #1::S)

    x < y ==
      if position(x) = 0 then enterInCache(x, x::S = #1::S)
      if position(y) = 0 then enterInCache(y, y::S = #1::S)
      position(x) < position(y)

    x = y ==
      if position(x) = 0 then enterInCache(x, x::S = #1::S)
      if position(y) = 0 then enterInCache(y, y::S = #1::S)
      position(x) = position(y)

@
\section{domain KERNEL Kernel}
<<Kernel.input>>=
-- kl.spad.pamphlet Kernel.input
)spool Kernel.output
)set message test on
)set message auto off
)clear all
--S 1 of 19
x :: Expression Integer
--R 
--R
--R   (1)  x
--R                                                     Type: Expression Integer
--E 1

--S 2 of 19
kernel x
--R 
--R
--R   (2)  x
--R                                              Type: Kernel Expression Integer
--E 2

--S 3 of 19
sin(x) + cos(x)
--R 
--R
--R   (3)  sin(x) + cos(x)
--R                                                     Type: Expression Integer
--E 3

--S 4 of 19
kernels %
--R 
--R
--R   (4)  [sin(x),cos(x)]
--R                                         Type: List Kernel Expression Integer
--E 4

--S 5 of 19
sin(x)**2 + sin(x) + cos(x)
--R 
--R
--R              2
--R   (5)  sin(x)  + sin(x) + cos(x)
--R                                                     Type: Expression Integer
--E 5

--S 6 of 19
kernels %
--R 
--R
--R   (6)  [sin(x),cos(x)]
--R                                         Type: List Kernel Expression Integer
--E 6

--S 7 of 19
kernels(1 :: Expression Integer)
--R 
--R
--R   (7)  []
--R                                         Type: List Kernel Expression Integer
--E 7

--S 8 of 19
mainKernel(cos(x) + tan(x))
--R 
--R
--R   (8)  tan(x)
--R                                   Type: Union(Kernel Expression Integer,...)
--E 8

--S 9 of 19
height kernel x
--R 
--R
--R   (9)  1
--R                                                        Type: PositiveInteger
--E 9

--S 10 of 19
height mainKernel(sin x)
--R 
--R
--R   (10)  2
--R                                                        Type: PositiveInteger
--E 10

--S 11 of 19
height mainKernel(sin cos x)
--R 
--R
--R   (11)  3
--R                                                        Type: PositiveInteger
--E 11

--S 12 of 19
height mainKernel(sin cos (tan x + sin x))
--R 
--R
--R   (12)  4
--R                                                        Type: PositiveInteger
--E 12

--S 13 of 19
operator mainKernel(sin cos (tan x + sin x))
--R 
--R
--R   (13)  sin
--R                                                          Type: BasicOperator
--E 13

--S 14 of 19
name mainKernel(sin cos (tan x + sin x))
--R 
--R
--R   (14)  sin
--R                                                                 Type: Symbol
--E 14

--S 15 of 19
f := operator 'f 
--R 
--R
--R   (15)  f
--R                                                          Type: BasicOperator
--E 15

--S 16 of 19
e := f(x, y, 10) 
--R 
--R
--R   (16)  f(x,y,10)
--R                                                     Type: Expression Integer
--E 16

--S 17 of 19
is?(e, f) 
--R 
--R
--R   (17)  true
--R                                                                Type: Boolean
--E 17

--S 18 of 19
is?(e, 'f)
--R 
--R
--R   (18)  true
--R                                                                Type: Boolean
--E 18

--S 19 of 19
argument mainKernel e
--R 
--R
--R   (19)  [x,y,10]
--R                                                Type: List Expression Integer
--E 19
)spool
)lisp (bye)
@
<<Kernel.help>>=
====================================================================
Kernel examples
====================================================================

A kernel is a symbolic function application (such as sin(x+ y)) 
or a symbol (such as x).  More precisely, a non-symbol
kernel over a set S is an operator applied to a given list of
arguments from S.  The operator has type BasicOperator
and the kernel object is usually part of an Expression object.

Kernels are created implicitly for you when you create expressions.

  x :: Expression Integer
    x
                         Type: Expression Integer

You can directly create a "symbol" kernel by using the kernel operation.

  kernel x
    x
                         Type: Kernel Expression Integer

This expression has two different kernels.

  sin(x) + cos(x)
    sin(x) + cos(x)
                         Type: Expression Integer

The operator kernels returns a list of the kernels in an object of
type Expression.

  kernels %
    [sin(x),cos(x)]
                         Type: List Kernel Expression Integer

This expression also has two different kernels.

  sin(x)**2 + sin(x) + cos(x)
          2
    sin(x)  + sin(x) + cos(x)
                         Type: Expression Integer

The sin(x) kernel is used twice.

  kernels %
    [sin(x),cos(x)]
                         Type: List Kernel Expression Integer

An expression need not contain any kernels.

  kernels(1 :: Expression Integer)
    []
                         Type: List Kernel Expression Integer

If one or more kernels are present, one of them is designated the main
kernel.

  mainKernel(cos(x) + tan(x))
    tan(x)
                         Type: Union(Kernel Expression Integer,...)

Kernels can be nested. Use height  to determine the nesting depth.

  height kernel x
    1
                         Type: PositiveInteger

This has height 2 because the x has height 1 and then we apply an
operator to that.

  height mainKernel(sin x)
    2
                         Type: PositiveInteger

  height mainKernel(sin cos x)
    3
                         Type: PositiveInteger

  height mainKernel(sin cos (tan x + sin x))
    4
                         Type: PositiveInteger

Use the operator operation to extract the operator component of the
kernel.  The operator has type BasicOperator.

  operator mainKernel(sin cos (tan x + sin x))
    sin
                         Type: BasicOperator

Use the name operation to extract the name of the operator component
of the kernel.  The name has type Symbol.  This is really just a
shortcut for a two-step process of extracting the operator and then
calling name on the operator.

  name mainKernel(sin cos (tan x + sin x))
    sin
                         Type: Symbol

Axiom knows about functions such as sin, cos and so on and can make
kernels and then expressions using them.  To create a kernel and
expression using an arbitrary operator, use operator.

Now f can be used to create symbolic function applications.

  f := operator 'f 
    f
                        Type: BasicOperator

  e := f(x, y, 10) 
    f(x,y,10)
                        Type: Expression Integer

Use the is? operation to learn if the operator component of a kernel
is equal to a given operator.

  is?(e, f) 
    true
                        Type: Boolean

You can also use a symbol or a string as the second argument to is?.

  is?(e, 'f)
    true
                        Type: Boolean

Use the argument operation to get a list containing the argument
component of a kernel.

  argument mainKernel e
    [x,y,10]
                        Type: List Expression Integer

Conceptually, an object of type Expression can be thought of a
quotient of multivariate polynomials, where the "variables" are
kernels.  The arguments of the kernels are again expressions and so
the structure recurses.  See Expression for examples of using kernels
to take apart expression objects.

See Also:
o )help Expression
o )help BasicOperator
o )show Kernel
o $AXIOM/doc/src/algebra/kl.spad.dvi

@
<<domain KERNEL Kernel>>=
)abbrev domain KERNEL Kernel
++ Operators applied to elements of a set
++ Author: Manuel Bronstein
++ Date Created: 22 March 1988
++ Date Last Updated: 10 August 1994
++ Description:
++ A kernel over a set S is an operator applied to a given list
++ of arguments from S.
Kernel(S:OrderedSet): Exports == Implementation where
  O  ==> OutputForm
  N  ==> NonNegativeInteger
  OP ==> BasicOperator

  SYMBOL  ==> "%symbol"
  PMPRED  ==> "%pmpredicate"
  PMOPT   ==> "%pmoptional"
  PMMULT  ==> "%pmmultiple"
  PMCONST ==> "%pmconstant"
  SPECIALDISP  ==> "%specialDisp"
  SPECIALEQUAL ==> "%specialEqual"
  SPECIALINPUT ==> "%specialInput"

  Exports ==> Join(CachableSet, Patternable S) with
    name    : % -> Symbol
      ++ name(op(a1,...,an)) returns the name of op.
    operator: % -> OP
      ++ operator(op(a1,...,an)) returns the operator op.
    argument: % -> List S
      ++ argument(op(a1,...,an)) returns \spad{[a1,...,an]}.
    height  : % -> N
      ++ height(k) returns the nesting level of k.
    kernel  : (OP, List S, N) -> %
      ++ kernel(op, [a1,...,an], m) returns the kernel \spad{op(a1,...,an)}
      ++ of nesting level m.
      ++ Error: if op is k-ary for some k not equal to m.
    kernel  : Symbol -> %
      ++ kernel(x) returns x viewed as a kernel.
    symbolIfCan: % -> Union(Symbol, "failed")
      ++ symbolIfCan(k) returns k viewed as a symbol if k is a symbol, and
      ++ "failed" otherwise.
    is?     : (%, OP) -> Boolean
      ++ is?(op(a1,...,an), f) tests if op = f.
    is?     : (%, Symbol) -> Boolean
      ++ is?(op(a1,...,an), s) tests if the name of op is s.
    if S has ConvertibleTo InputForm then ConvertibleTo InputForm

  Implementation ==> add
    import SortedCache(%)

    Rep := Record(op:OP, arg:List S, nest:N, posit:N)

    clearCache()

    B2Z   : Boolean -> Integer
    triage: (%, %)  -> Integer
    preds : OP      -> List Any

    is?(k:%, s:Symbol) == is?(operator k, s)
    is?(k:%, o:OP)     == (operator k) = o
    name k             == name operator k
    height k           == k.nest
    operator k         == k.op
    argument k         == k.arg
    position k         == k.posit
    setPosition(k, n)  == k.posit := n
    B2Z flag           == (flag => -1; 1)
    kernel s           == kernel(assert(operator(s,0),SYMBOL), nil(), 1)

    preds o ==
      (u := property(o, PMPRED)) case "failed" => nil()
      (u::None) pretend List(Any)

    symbolIfCan k ==
      has?(operator k, SYMBOL) => name operator k
      "failed"

    k1 = k2 ==
      if k1.posit = 0 then enterInCache(k1, triage)
      if k2.posit = 0 then enterInCache(k2, triage)
      k1.posit = k2.posit

    k1 < k2 ==
      if k1.posit = 0 then enterInCache(k1, triage)
      if k2.posit = 0 then enterInCache(k2, triage)
      k1.posit < k2.posit

    kernel(fn, x, n) ==
      ((u := arity fn) case N) and (#x ^= u::N)
                                    => error "Wrong number of arguments"
      enterInCache([fn, x, n, 0]$Rep, triage)

    -- SPECIALDISP contains a map List S -> OutputForm
    -- it is used when the converting the arguments first is not good,
    -- for instance with formal derivatives.
    coerce(k:%):OutputForm ==
      (v := symbolIfCan k) case Symbol => v::Symbol::OutputForm
      (f := property(o := operator k, SPECIALDISP)) case None =>
        ((f::None) pretend (List S -> OutputForm)) (argument k)
      l := [x::OutputForm for x in argument k]$List(OutputForm)
      (u := display o) case "failed" => prefix(name(o)::OutputForm, l)
      (u::(List OutputForm -> OutputForm)) l

    triage(k1, k2) ==
      k1.nest   ^= k2.nest   => B2Z(k1.nest   < k2.nest)
      k1.op ^= k2.op => B2Z(k1.op < k2.op)
      (n1 := #(argument k1)) ^= (n2 := #(argument k2)) => B2Z(n1 < n2)
      ((func := property(operator k1, SPECIALEQUAL)) case None) and
        (((func::None) pretend ((%, %) -> Boolean)) (k1, k2)) => 0
      for x1 in argument(k1) for x2 in argument(k2) repeat
        x1 ^= x2 => return B2Z(x1 < x2)
      0

    if S has ConvertibleTo InputForm then
      convert(k:%):InputForm ==
        (v := symbolIfCan k) case Symbol => convert(v::Symbol)@InputForm
        (f := property(o := operator k, SPECIALINPUT)) case None =>
          ((f::None) pretend (List S -> InputForm)) (argument k)
        l := [convert x for x in argument k]$List(InputForm)
        (u := input operator k) case "failed" =>
          convert concat(convert name operator k, l)
        (u::(List InputForm -> InputForm)) l

    if S has ConvertibleTo Pattern Integer then
      convert(k:%):Pattern(Integer) ==
        o := operator k
        (v := symbolIfCan k) case Symbol =>
          s  := patternVariable(v::Symbol,
                      has?(o, PMCONST), has?(o, PMOPT), has?(o, PMMULT))
          empty?(l := preds o) => s
          setPredicates(s, l)
        o [convert x for x in k.arg]$List(Pattern Integer)

    if S has ConvertibleTo Pattern Float then
      convert(k:%):Pattern(Float) ==
        o := operator k
        (v := symbolIfCan k) case Symbol =>
          s  := patternVariable(v::Symbol,
                      has?(o, PMCONST), has?(o, PMOPT), has?(o, PMMULT))
          empty?(l := preds o) => s
          setPredicates(s, l)
        o [convert x for x in k.arg]$List(Pattern Float)

@
\section{package KERNEL2 KernelFunctions2}
<<package KERNEL2 KernelFunctions2>>=
)abbrev package KERNEL2 KernelFunctions2
++ Description:
++ This package exports some auxiliary functions on kernels
KernelFunctions2(R:OrderedSet, S:OrderedSet): with
  constantKernel: R -> Kernel S
	++ constantKernel(r) \undocumented
  constantIfCan : Kernel S -> Union(R, "failed")
	++ constantIfCan(k) \undocumented

 == add
  import BasicOperatorFunctions1(R)

  constantKernel r == kernel(constantOperator r, nil(), 1)
  constantIfCan k  == constantOpIfCan operator k

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

-- SPAD files for the functional world should be compiled in the
-- following order:
--
--   op  KL  expr function

<<package SCACHE SortedCache>>
<<domain MKCHSET MakeCachableSet>>
<<domain KERNEL Kernel>>
<<package KERNEL2 KernelFunctions2>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
