\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra si.spad}
\author{Stephen M. Watt, Michael Monagan, James Davenport, Barry Trager}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain SINT SingleInteger}
The definition of {\bf one?} has been rewritten 
as it relies on calling {\bf ONEP} which is a function specific
to Codemist Common Lisp but is not defined in Common Lisp.
<<SingleInteger.input>>=
-- si.spad.pamphlet SingleInteger.input
)spool SingleInteger.output
)set message test on
)set message auto off
)clear all
--S 1 of 11
min()$SingleInteger
--R 
--R
--R   (1)  - 2147483648
--R                                                          Type: SingleInteger
--E 1

--S 2 of 11
max()$SingleInteger
--R 
--R
--R   (2)  2147483647
--R                                                          Type: SingleInteger
--E 2

--S 3 of 11
a := 1234 :: SingleInteger
--R 
--R
--R   (3)  1234
--R                                                          Type: SingleInteger
--E 3

--S 4 of 11
b := 124$SingleInteger
--R 
--R
--R   (4)  124
--R                                                          Type: SingleInteger
--E 4

--S 5 of 11
gcd(a,b)
--R 
--R
--R   (5)  2
--R                                                          Type: SingleInteger
--E 5

--S 6 of 11
lcm(a,b)
--R 
--R
--R   (6)  76508
--R                                                          Type: SingleInteger
--E 6

--S 7 of 11
mulmod(5,6,13)$SingleInteger
--R 
--R
--R   (7)  4
--R                                                          Type: SingleInteger
--E 7

--S 8 of 11
positiveRemainder(37,13)$SingleInteger
--R 
--R
--R   (8)  11
--R                                                          Type: SingleInteger
--E 8

--S 9 of 11
And(3,4)$SingleInteger
--R 
--R
--R   (9)  0
--R                                                          Type: SingleInteger
--E 9

--S 10 of 11
shift(1,4)$SingleInteger
--R 
--R
--R   (10)  16
--R                                                          Type: SingleInteger
--E 10

--S 11 of 11
shift(31,-1)$SingleInteger
--R 
--R
--R   (11)  15
--R                                                          Type: SingleInteger
--E 11
)spool
)lisp (bye)
@
<<SingleInteger.help>>=
====================================================================
SingleInteger examples
====================================================================

The SingleInteger domain is intended to provide support in Axiom
for machine integer arithmetic.  It is generally much faster than
(bignum) Integer arithmetic but suffers from a limited range of
values.  Since Axiom can be implemented on top of various dialects of
Lisp, the actual representation of small integers may not correspond
exactly to the host machines integer representation.

You can discover the minimum and maximum values in your implementation
by using min and max.

  min()$SingleInteger
    - 2147483648
                              Type: SingleInteger

  max()$SingleInteger
    2147483647
                              Type: SingleInteger

To avoid confusion with Integer, which is the default type for
integers, you usually need to work with declared variables.

  a := 1234 :: SingleInteger
    1234
                              Type: SingleInteger

or use package calling

  b := 124$SingleInteger
    124
                              Type: SingleInteger

You can add, multiply and subtract SingleInteger objects, and ask for
the greatest common divisor (gcd).

  gcd(a,b)
    2
                              Type: SingleInteger

The least common multiple (lcm) is also available.

  lcm(a,b)
    76508
                              Type: SingleInteger

Operations mulmod, addmod, submod, and invmod are similar - they provide
arithmetic modulo a given small integer.
Here is 5 * 6 mod 13.

  mulmod(5,6,13)$SingleInteger
    4
                              Type: SingleInteger

To reduce a small integer modulo a prime, use positiveRemainder.

  positiveRemainder(37,13)$SingleInteger
    11
                              Type: SingleInteger

Operations And, Or, xor, and Not provide bit level operations on small
integers.

  And(3,4)$SingleInteger
    0
                              Type: SingleInteger

Use shift(int,numToShift) to shift bits, where i is shifted left if
numToShift is positive, right if negative.

  shift(1,4)$SingleInteger
    16
                              Type: SingleInteger

  shift(31,-1)$SingleInteger
    15
                              Type: SingleInteger

Many other operations are available for small integers, including many
of those provided for Integer.  

See Also:
o )help Integer
o )show SingleInteger
o $AXIOM/doc/src/algebra/si.spad.dvi

@
<<dot>>=
"SINT" -> "INS"
"SingleInteger()" -> "IntegerNumberSystem()"
"SINT" -> "LOGIC"
"SingleInteger()" -> "Logic()"
"SINT" -> "OM"
"SingleInteger()" -> "OpenMath()"
@
<<domain SINT SingleInteger>>=
)abbrev domain SINT SingleInteger

-- following patch needed to deal with *:(I,%) -> %
-- affects behavior of SourceLevelSubset
--)bo $noSubsets := true
-- No longer - JHD !! still needed 5/3/91 BMT

++ Author:  Michael Monagan
++ Date Created:
++    January 1988
++ Change History:
++ Basic Operations: max, min,
++    not, and, or, xor, Not, And, Or
++ Related Constructors:
++ Keywords: single integer
++ Description: SingleInteger is intended to support machine integer
++ arithmetic.

-- MAXINT, BASE (machine integer constants)
-- MODULUS, MULTIPLIER (random number generator constants)


-- Lisp dependencies
-- EQ, ABSVAL, TIMES, INTEGER-LENGTH, HASHEQ, REMAINDER
-- QSLESSP, QSGREATERP, QSADD1, QSSUB1, QSMINUS, QSPLUS, QSDIFFERENCE
-- QSTIMES, QSREMAINDER, QSODDP, QSZEROP, QSMAX, QSMIN, QSNOT, QSAND
-- QSOR, QSXOR, QSLEFTSHIFT, QSADDMOD, QSDIFMOD, QSMULTMOD


SingleInteger(): Join(IntegerNumberSystem,Logic,OpenMath) with
   canonical
      ++ \spad{canonical} means that mathematical equality is 
      ++ implied by data structure equality.
   canonicalsClosed
      ++ \spad{canonicalClosed} means two positives multiply to 
      ++ give positive.
   noetherian
      ++ \spad{noetherian} all ideals are finitely generated 
      ++ (in fact principal).

   max      : () -> %
      ++ max() returns the largest single integer.
   min      : () -> %
      ++ min() returns the smallest single integer.

   -- bit operations
   "not":   % -> %
      ++ not(n) returns the bit-by-bit logical {\em not} of the single integer n.
   "~"  :   % -> %
      ++  ~ n returns the bit-by-bit logical {\em not } of the single integer n.
   "/\": (%, %) -> %
      ++ n /\ m  returns the bit-by-bit logical {\em and} of
      ++ the single integers n and m.
   "\/" : (%, %) -> %
      ++ n \/ m  returns the bit-by-bit logical {\em or} of
      ++ the single integers n and m.
   "xor": (%, %) -> %
      ++ xor(n,m)  returns the bit-by-bit logical {\em xor} of
      ++ the single integers n and m.
   Not  : % -> %
      ++ Not(n) returns the bit-by-bit logical {\em not} of the single integer n.
   And  : (%,%) -> %
      ++ And(n,m)  returns the bit-by-bit logical {\em and} of
      ++ the single integers n and m.
   Or   : (%,%) -> %
      ++ Or(n,m)  returns the bit-by-bit logical {\em or} of
      ++ the single integers n and m.

 == add

   seed : % := 1$Lisp               -- for random()
   MAXINT ==> MOST_-POSITIVE_-FIXNUM$Lisp
   MININT ==> MOST_-NEGATIVE_-FIXNUM$Lisp
   BASE ==> 67108864$Lisp           -- 2**26
   MULTIPLIER ==> 314159269$Lisp    -- from Knuth's table
   MODULUS ==> 2147483647$Lisp      -- 2**31-1

   writeOMSingleInt(dev: OpenMathDevice, x: %): Void ==
    if x < 0 then
      OMputApp(dev)
      OMputSymbol(dev, "arith1", "unary_minus")
      OMputInteger(dev, convert(-x))
      OMputEndApp(dev)
    else
      OMputInteger(dev, convert(x))

   OMwrite(x: %): String ==
    s: String := ""
    sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
    dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
    OMputObject(dev)
    writeOMSingleInt(dev, x)
    OMputEndObject(dev)
    OMclose(dev)
    s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
    s

   OMwrite(x: %, wholeObj: Boolean): String ==
    s: String := ""
    sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
    dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
    if wholeObj then
      OMputObject(dev)
    writeOMSingleInt(dev, x)
    if wholeObj then
      OMputEndObject(dev)
    OMclose(dev)
    s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
    s

   OMwrite(dev: OpenMathDevice, x: %): Void ==
    OMputObject(dev)
    writeOMSingleInt(dev, x)
    OMputEndObject(dev)

   OMwrite(dev: OpenMathDevice, x: %, wholeObj: Boolean): Void ==
    if wholeObj then
      OMputObject(dev)
    writeOMSingleInt(dev, x)
    if wholeObj then
      OMputEndObject(dev)

   reducedSystem m      == m pretend Matrix(Integer)
   coerce(x):OutputForm == (convert(x)@Integer)::OutputForm
   convert(x:%):Integer == x pretend Integer
   i:Integer * y:%      == i::% * y
   0         == 0$Lisp
   1         == 1$Lisp
   base()    == 2$Lisp
   max()     == MAXINT
   min()     == MININT
   x = y     == EQL(x,y)$Lisp
   _~ x      == LOGNOT(x)$Lisp
   not(x)    == LOGNOT(x)$Lisp
   _/_\(x,y) == LOGAND(x,y)$Lisp
   _\_/(x,y) == LOGIOR(x,y)$Lisp
   Not(x)    == LOGNOT(x)$Lisp
   And(x,y)  == LOGAND(x,y)$Lisp
   Or(x,y)   == LOGIOR(x,y)$Lisp
   xor(x,y)  == LOGXOR(x,y)$Lisp
   x < y     == QSLESSP(x,y)$Lisp
   inc x     == QSADD1(x)$Lisp
   dec x     == QSSUB1(x)$Lisp
   - x       == QSMINUS(x)$Lisp
   x + y     == QSPLUS(x,y)$Lisp
   x:% - y:% == QSDIFFERENCE(x,y)$Lisp
   x:% * y:% == QSTIMES(x,y)$Lisp
   x:% ** n:NonNegativeInteger == ((EXPT(x, n)$Lisp) pretend Integer)::%
   x quo y   == QSQUOTIENT(x,y)$Lisp
   x rem y   == QSREMAINDER(x,y)$Lisp
   divide(x, y)   == CONS(QSQUOTIENT(x,y)$Lisp,QSREMAINDER(x,y)$Lisp)$Lisp
   gcd(x,y)  == GCD(x,y)$Lisp
   abs(x)    == QSABSVAL(x)$Lisp
   odd?(x)   == QSODDP(x)$Lisp
   zero?(x)  == QSZEROP(x)$Lisp
--   one?(x)   == ONEP(x)$Lisp
   one?(x)   == x = 1
   max(x,y)  == QSMAX(x,y)$Lisp
   min(x,y)  == QSMIN(x,y)$Lisp
   hash(x)   == HASHEQ(x)$Lisp
   length(x) == INTEGER_-LENGTH(x)$Lisp
   shift(x,n)    == QSLEFTSHIFT(x,n)$Lisp
   mulmod(a,b,p) == QSMULTMOD(a,b,p)$Lisp
   addmod(a,b,p) == QSADDMOD(a,b,p)$Lisp
   submod(a,b,p) == QSDIFMOD(a,b,p)$Lisp
   negative?(x)  == QSMINUSP$Lisp x


   reducedSystem(m, v) ==
        [m pretend Matrix(Integer), v pretend Vector(Integer)]

   positiveRemainder(x,n) ==
      r := QSREMAINDER(x,n)$Lisp
      QSMINUSP(r)$Lisp =>
          QSMINUSP(n)$Lisp => QSDIFFERENCE(x, n)$Lisp
          QSPLUS(r, n)$Lisp
      r

   coerce(x:Integer):% ==
      (x <= max pretend Integer) and (x >= min pretend Integer) =>
        x pretend %
      error "integer too large to represent in a machine word"

   random() ==
      seed := REMAINDER(TIMES(MULTIPLIER,seed)$Lisp,MODULUS)$Lisp
      REMAINDER(seed,BASE)$Lisp

   random(n) == RANDOM(n)$Lisp

   UCA ==> Record(unit:%,canonical:%,associate:%)
   unitNormal x ==
      x < 0 => [-1,-x,-1]$UCA
      [1,x,1]$UCA

)bo $noSubsets := false

@
\section{SINT.lsp BOOTSTRAP}
<<SINT.lsp BOOTSTRAP>>=

(/VERSIONCHECK 2) 

(DEFUN |SINT;writeOMSingleInt| (|dev| |x| $) 
  (SEQ 
    (COND 
      ((QSLESSP |x| 0)
        (SEQ 
          (SPADCALL |dev| (QREFELT $ 9))
          (SPADCALL |dev| "arith1" "unaryminus" (QREFELT $ 11))
          (SPADCALL |dev| (QSMINUS |x|) (QREFELT $ 13))
          (EXIT (SPADCALL |dev| (QREFELT $ 14)))))
      ((QUOTE T) (SPADCALL |dev| |x| (QREFELT $ 13)))))) 

(DEFUN |SINT;OMwrite;$S;2| (|x| $) 
  (PROG (|sp| |dev| |s|) 
    (RETURN 
      (SEQ 
        (LETT |s| "" |SINT;OMwrite;$S;2|)
        (LETT |sp| (OM-STRINGTOSTRINGPTR |s|) |SINT;OMwrite;$S;2|)
        (LETT |dev| 
          (SPADCALL |sp| (SPADCALL (QREFELT $ 16)) (QREFELT $ 17))
          |SINT;OMwrite;$S;2|)
        (SPADCALL |dev| (QREFELT $ 18))
        (|SINT;writeOMSingleInt| |dev| |x| $)
        (SPADCALL |dev| (QREFELT $ 19))
        (SPADCALL |dev| (QREFELT $ 20))
        (LETT |s| (OM-STRINGPTRTOSTRING |sp|) |SINT;OMwrite;$S;2|)
        (EXIT |s|))))) 

(DEFUN |SINT;OMwrite;$BS;3| (|x| |wholeObj| $) 
  (PROG (|sp| |dev| |s|) 
    (RETURN 
      (SEQ 
        (LETT |s| "" |SINT;OMwrite;$BS;3|)
        (LETT |sp| (OM-STRINGTOSTRINGPTR |s|) |SINT;OMwrite;$BS;3|)
        (LETT |dev| 
          (SPADCALL |sp| (SPADCALL (QREFELT $ 16)) (QREFELT $ 17))
          |SINT;OMwrite;$BS;3|)
        (COND (|wholeObj| (SPADCALL |dev| (QREFELT $ 18))))
        (|SINT;writeOMSingleInt| |dev| |x| $)
        (COND (|wholeObj| (SPADCALL |dev| (QREFELT $ 19))))
        (SPADCALL |dev| (QREFELT $ 20))
        (LETT |s| (OM-STRINGPTRTOSTRING |sp|) |SINT;OMwrite;$BS;3|)
        (EXIT |s|))))) 

(DEFUN |SINT;OMwrite;Omd$V;4| (|dev| |x| $) 
  (SEQ 
    (SPADCALL |dev| (QREFELT $ 18))
    (|SINT;writeOMSingleInt| |dev| |x| $)
    (EXIT (SPADCALL |dev| (QREFELT $ 19))))) 

(DEFUN |SINT;OMwrite;Omd$BV;5| (|dev| |x| |wholeObj| $) 
  (SEQ 
    (COND (|wholeObj| (SPADCALL |dev| (QREFELT $ 18))))
    (|SINT;writeOMSingleInt| |dev| |x| $)
    (EXIT (COND (|wholeObj| (SPADCALL |dev| (QREFELT $ 19))))))) 

(PUT 
  (QUOTE |SINT;reducedSystem;MM;6|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM (|m|) |m|))) 

(DEFUN |SINT;reducedSystem;MM;6| (|m| $) |m|) 

(DEFUN |SINT;coerce;$Of;7| (|x| $) 
  (SPADCALL |x| (QREFELT $ 30))) 

(PUT 
  (QUOTE |SINT;convert;$I;8|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM (|x|) |x|))) 

(DEFUN |SINT;convert;$I;8| (|x| $) |x|) 

(DEFUN |SINT;*;I2$;9| (|i| |y| $) 
  (QSTIMES (SPADCALL |i| (QREFELT $ 33)) |y|)) 

(PUT 
  (QUOTE |SINT;Zero;$;10|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM NIL 0))) 

(DEFUN |SINT;Zero;$;10| ($) 0) 

(PUT 
  (QUOTE |SINT;One;$;11|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM NIL 1))) 

(DEFUN |SINT;One;$;11| ($) 1) 

(PUT 
  (QUOTE |SINT;base;$;12|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM NIL 2))) 

(DEFUN |SINT;base;$;12| ($) 2) 

(PUT 
  (QUOTE |SINT;max;$;13|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM NIL MOST-POSITIVE-FIXNUM))) 

(DEFUN |SINT;max;$;13| ($) MOST-POSITIVE-FIXNUM) 

(PUT 
  (QUOTE |SINT;min;$;14|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM NIL MOST-NEGATIVE-FIXNUM))) 

(DEFUN |SINT;min;$;14| ($) MOST-NEGATIVE-FIXNUM) 

(PUT 
  (QUOTE |SINT;=;2$B;15|)
  (QUOTE |SPADreplace|)
  (QUOTE EQL)) 

(DEFUN |SINT;=;2$B;15| (|x| |y| $) 
  (EQL |x| |y|)) 

(PUT 
  (QUOTE |SINT;~;2$;16|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGNOT)) 

(DEFUN |SINT;~;2$;16| (|x| $) 
  (LOGNOT |x|)) 

(PUT 
  (QUOTE |SINT;not;2$;17|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGNOT)) 

(DEFUN |SINT;not;2$;17| (|x| $) 
  (LOGNOT |x|)) 

(PUT 
  (QUOTE |SINT;/\\;3$;18|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGAND)) 

(DEFUN |SINT;/\\;3$;18| (|x| |y| $) 
  (LOGAND |x| |y|)) 

(PUT 
  (QUOTE |SINT;\\/;3$;19|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGIOR)) 

(DEFUN |SINT;\\/;3$;19| (|x| |y| $) 
  (LOGIOR |x| |y|)) 

(PUT 
  (QUOTE |SINT;Not;2$;20|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGNOT)) 

(DEFUN |SINT;Not;2$;20| (|x| $) 
  (LOGNOT |x|)) 

(PUT
  (QUOTE |SINT;And;3$;21|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGAND)) 

(DEFUN |SINT;And;3$;21| (|x| |y| $) 
  (LOGAND |x| |y|)) 

(PUT 
  (QUOTE |SINT;Or;3$;22|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGIOR)) 

(DEFUN |SINT;Or;3$;22| (|x| |y| $) 
  (LOGIOR |x| |y|)) 

(PUT
  (QUOTE |SINT;xor;3$;23|)
  (QUOTE |SPADreplace|)
  (QUOTE LOGXOR)) 

(DEFUN |SINT;xor;3$;23| (|x| |y| $) 
  (LOGXOR |x| |y|)) 

(PUT
  (QUOTE |SINT;<;2$B;24|)
  (QUOTE |SPADreplace|)
  (QUOTE QSLESSP)) 

(DEFUN |SINT;<;2$B;24| (|x| |y| $) 
  (QSLESSP |x| |y|)) 

(PUT
  (QUOTE |SINT;inc;2$;25|)
  (QUOTE |SPADreplace|)
  (QUOTE QSADD1)) 

(DEFUN |SINT;inc;2$;25| (|x| $) 
  (QSADD1 |x|)) 

(PUT
  (QUOTE |SINT;dec;2$;26|)
  (QUOTE |SPADreplace|)
  (QUOTE QSSUB1)) 

(DEFUN |SINT;dec;2$;26| (|x| $) 
  (QSSUB1 |x|)) 

(PUT
  (QUOTE |SINT;-;2$;27|)
  (QUOTE |SPADreplace|)
  (QUOTE QSMINUS)) 

(DEFUN |SINT;-;2$;27| (|x| $) 
  (QSMINUS |x|)) 

(PUT 
  (QUOTE |SINT;+;3$;28|)
  (QUOTE |SPADreplace|)
  (QUOTE QSPLUS)) 

(DEFUN |SINT;+;3$;28| (|x| |y| $) 
  (QSPLUS |x| |y|)) 

(PUT 
  (QUOTE |SINT;-;3$;29|)
  (QUOTE |SPADreplace|)
  (QUOTE QSDIFFERENCE)) 

(DEFUN |SINT;-;3$;29| (|x| |y| $) 
  (QSDIFFERENCE |x| |y|)) 

(PUT 
  (QUOTE |SINT;*;3$;30|)
  (QUOTE |SPADreplace|)
  (QUOTE QSTIMES)) 

(DEFUN |SINT;*;3$;30| (|x| |y| $) 
  (QSTIMES |x| |y|)) 

(DEFUN |SINT;**;$Nni$;31| (|x| |n| $) 
  (SPADCALL (EXPT |x| |n|) (QREFELT $ 33))) 

(PUT 
  (QUOTE |SINT;quo;3$;32|)
  (QUOTE |SPADreplace|)
  (QUOTE QSQUOTIENT)) 

(DEFUN |SINT;quo;3$;32| (|x| |y| $) 
  (QSQUOTIENT |x| |y|)) 

(PUT 
  (QUOTE |SINT;rem;3$;33|)
  (QUOTE |SPADreplace|)
  (QUOTE QSREMAINDER)) 

(DEFUN |SINT;rem;3$;33| (|x| |y| $) 
  (QSREMAINDER |x| |y|)) 

(DEFUN |SINT;divide;2$R;34| (|x| |y| $) 
  (CONS (QSQUOTIENT |x| |y|) (QSREMAINDER |x| |y|))) 

(PUT (QUOTE |SINT;gcd;3$;35|) 
  (QUOTE |SPADreplace|) (QUOTE GCD)) 

(DEFUN |SINT;gcd;3$;35| (|x| |y| $) 
  (GCD |x| |y|)) 

(PUT 
  (QUOTE |SINT;abs;2$;36|)
  (QUOTE |SPADreplace|)
  (QUOTE QSABSVAL)) 

(DEFUN |SINT;abs;2$;36| (|x| $) 
  (QSABSVAL |x|)) 

(PUT 
  (QUOTE |SINT;odd?;$B;37|)
  (QUOTE |SPADreplace|)
  (QUOTE QSODDP)) 

(DEFUN |SINT;odd?;$B;37| (|x| $) 
  (QSODDP |x|)) 

(PUT 
  (QUOTE |SINT;zero?;$B;38|)
  (QUOTE |SPADreplace|)
  (QUOTE QSZEROP)) 

(DEFUN |SINT;zero?;$B;38| (|x| $) 
  (QSZEROP |x|)) 

(PUT 
  (QUOTE |SINT;max;3$;39|)
  (QUOTE |SPADreplace|)
  (QUOTE QSMAX)) 

(DEFUN |SINT;max;3$;39| (|x| |y| $) 
  (QSMAX |x| |y|)) 

(PUT 
  (QUOTE |SINT;min;3$;40|)
  (QUOTE |SPADreplace|)
  (QUOTE QSMIN)) 

(DEFUN |SINT;min;3$;40| (|x| |y| $) 
  (QSMIN |x| |y|)) 

(PUT 
  (QUOTE |SINT;hash;2$;41|) 
  (QUOTE |SPADreplace|)
  (QUOTE HASHEQ)) 

(DEFUN |SINT;hash;2$;41| (|x| $) 
  (HASHEQ |x|)) 

(PUT 
  (QUOTE |SINT;length;2$;42|)
  (QUOTE |SPADreplace|)
  (QUOTE INTEGER-LENGTH)) 

(DEFUN |SINT;length;2$;42| (|x| $) 
  (INTEGER-LENGTH |x|)) 

(PUT 
  (QUOTE |SINT;shift;3$;43|)
  (QUOTE |SPADreplace|)
  (QUOTE QSLEFTSHIFT)) 

(DEFUN |SINT;shift;3$;43| (|x| |n| $) 
  (QSLEFTSHIFT |x| |n|)) 

(PUT 
  (QUOTE |SINT;mulmod;4$;44|)
  (QUOTE |SPADreplace|)
  (QUOTE QSMULTMOD)) 

(DEFUN |SINT;mulmod;4$;44| (|a| |b| |p| $) 
  (QSMULTMOD |a| |b| |p|)) 

(PUT 
  (QUOTE |SINT;addmod;4$;45|)
  (QUOTE |SPADreplace|)
  (QUOTE QSADDMOD)) 

(DEFUN |SINT;addmod;4$;45| (|a| |b| |p| $) 
  (QSADDMOD |a| |b| |p|)) 

(PUT 
  (QUOTE |SINT;submod;4$;46|)
  (QUOTE |SPADreplace|)
  (QUOTE QSDIFMOD)) 

(DEFUN |SINT;submod;4$;46| (|a| |b| |p| $) 
  (QSDIFMOD |a| |b| |p|)) 

(PUT 
  (QUOTE |SINT;negative?;$B;47|)
  (QUOTE |SPADreplace|)
  (QUOTE QSMINUSP)) 

(DEFUN |SINT;negative?;$B;47| (|x| $) 
  (QSMINUSP |x|)) 

(PUT 
  (QUOTE |SINT;reducedSystem;MVR;48|)
  (QUOTE |SPADreplace|)
  (QUOTE CONS)) 

(DEFUN |SINT;reducedSystem;MVR;48| (|m| |v| $) 
  (CONS |m| |v|)) 

(DEFUN |SINT;positiveRemainder;3$;49| (|x| |n| $) 
  (PROG (|r|) 
    (RETURN 
      (SEQ 
        (LETT |r| (QSREMAINDER |x| |n|) |SINT;positiveRemainder;3$;49|)
        (EXIT 
          (COND 
            ((QSMINUSP |r|) 
              (COND 
                ((QSMINUSP |n|) (QSDIFFERENCE |x| |n|))
                ((QUOTE T) (QSPLUS |r| |n|))))
            ((QUOTE T) |r|))))))) 

(DEFUN |SINT;coerce;I$;50| (|x| $) 
  (SEQ 
    (COND 
      ((NULL (< MOST-POSITIVE-FIXNUM |x|))
        (COND ((NULL (< |x| MOST-NEGATIVE-FIXNUM)) (EXIT |x|)))))
     (EXIT (|error| "integer too large to represent in a machine word")))) 

(DEFUN |SINT;random;$;51| ($) 
  (SEQ 
    (SETELT $ 6 (REMAINDER (TIMES 314159269 (QREFELT $ 6)) 2147483647))
    (EXIT (REMAINDER (QREFELT $ 6) 67108864)))) 

(PUT 
  (QUOTE |SINT;random;2$;52|)
  (QUOTE |SPADreplace|)
  (QUOTE RANDOM)) 

(DEFUN |SINT;random;2$;52| (|n| $) 
  (RANDOM |n|)) 

(DEFUN |SINT;unitNormal;$R;53| (|x| $) 
  (COND 
    ((QSLESSP |x| 0) (VECTOR -1 (QSMINUS |x|) -1))
    ((QUOTE T) (VECTOR 1 |x| 1)))) 

(DEFUN |SingleInteger| NIL 
  (PROG NIL 
    (RETURN 
      (PROG (#0=#:G1358) 
        (RETURN 
          (COND 
            ((LETT #0# 
                (HGET |$ConstructorCache| (QUOTE |SingleInteger|))
                |SingleInteger|)
              (|CDRwithIncrement| (CDAR #0#)))
            ((QUOTE T) 
              (UNWIND-PROTECT 
                (PROG1 
                  (CDDAR 
                    (HPUT 
                      |$ConstructorCache| 
                      (QUOTE |SingleInteger|)
                      (LIST (CONS NIL (CONS 1 (|SingleInteger;|))))))
                  (LETT #0# T |SingleInteger|))
                (COND 
                  ((NOT #0#)
                     (HREM |$ConstructorCache| 
                       (QUOTE |SingleInteger|)))))))))))) 

(DEFUN |SingleInteger;| NIL 
  (PROG (|dv$| $ |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |dv$| (QUOTE (|SingleInteger|)) . #0=(|SingleInteger|))
        (LETT $ (GETREFV 103) . #0#)
        (QSETREFV $ 0 |dv$|)
        (QSETREFV $ 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #0#))
        (|haddProp| |$ConstructorCache| (QUOTE |SingleInteger|) NIL (CONS 1 $))
        (|stuffDomainSlots| $) (QSETREFV $ 6 1) $)))) 

(MAKEPROP 
  (QUOTE |SingleInteger|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (QUOTE |seed|)
        (|Void|)
        (|OpenMathDevice|)
        (0 . |OMputApp|)
        (|String|)
        (5 . |OMputSymbol|)
        (|Integer|)
        (12 . |OMputInteger|)
        (18 . |OMputEndApp|)
        (|OpenMathEncoding|)
        (23 . |OMencodingXML|)
        (27 . |OMopenString|)
        (33 . |OMputObject|)
        (38 . |OMputEndObject|)
        (43 . |OMclose|)
        |SINT;OMwrite;$S;2| 
        (|Boolean|)
        |SINT;OMwrite;$BS;3|
        |SINT;OMwrite;Omd$V;4|
        |SINT;OMwrite;Omd$BV;5|
        (|Matrix| 12)
        (|Matrix| $)
        |SINT;reducedSystem;MM;6|
        (|OutputForm|)
        (48 . |coerce|)
        |SINT;coerce;$Of;7|
        |SINT;convert;$I;8|
        (53 . |coerce|)
        |SINT;*;I2$;9|
        (CONS IDENTITY (FUNCALL (|dispatchFunction| |SINT;Zero;$;10|) $))
        (CONS IDENTITY (FUNCALL (|dispatchFunction| |SINT;One;$;11|) $))
        |SINT;base;$;12|
        |SINT;max;$;13|
        |SINT;min;$;14|
        |SINT;=;2$B;15|
        |SINT;~;2$;16|
        |SINT;not;2$;17|
        |SINT;/\\;3$;18|
        |SINT;\\/;3$;19|
        |SINT;Not;2$;20|
        |SINT;And;3$;21|
        |SINT;Or;3$;22|
        |SINT;xor;3$;23|
        |SINT;<;2$B;24|
        |SINT;inc;2$;25|
        |SINT;dec;2$;26|
        |SINT;-;2$;27|
        |SINT;+;3$;28|
        |SINT;-;3$;29|
        |SINT;*;3$;30|
        (|NonNegativeInteger|)
        |SINT;**;$Nni$;31|
        |SINT;quo;3$;32|
        |SINT;rem;3$;33|
        (|Record| (|:| |quotient| $) (|:| |remainder| $))
        |SINT;divide;2$R;34|
        |SINT;gcd;3$;35|
        |SINT;abs;2$;36|
        |SINT;odd?;$B;37|
        |SINT;zero?;$B;38|
        |SINT;max;3$;39|
        |SINT;min;3$;40|
        |SINT;hash;2$;41|
        |SINT;length;2$;42|
        |SINT;shift;3$;43|
        |SINT;mulmod;4$;44|
        |SINT;addmod;4$;45|
        |SINT;submod;4$;46|
        |SINT;negative?;$B;47|
        (|Record| (|:| |mat| 26) (|:| |vec| (|Vector| 12)))
        (|Vector| $)
        |SINT;reducedSystem;MVR;48|
        |SINT;positiveRemainder;3$;49|
        |SINT;coerce;I$;50|
        |SINT;random;$;51|
        |SINT;random;2$;52|
        (|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $))
        |SINT;unitNormal;$R;53|
        (|Union| 85 (QUOTE "failed"))
        (|Fraction| 12)
        (|Union| $ (QUOTE "failed"))
        (|Float|)
        (|DoubleFloat|)
        (|Pattern| 12)
        (|PatternMatchResult| 12 $)
        (|InputForm|)
        (|Union| 12 (QUOTE "failed"))
        (|Record| (|:| |coef| 94) (|:| |generator| $))
        (|List| $)
        (|Union| 94 (QUOTE "failed"))
        (|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $))
        (|Record| (|:| |coef1| $) (|:| |coef2| $))
        (|Union| 97 (QUOTE "failed"))
        (|Factored| $)
        (|SparseUnivariatePolynomial| $)
        (|PositiveInteger|)
        (|SingleInteger|)))
     (QUOTE 
       #(~= 58 ~ 64 |zero?| 69 |xor| 74 |unitNormal| 80 |unitCanonical| 85 
         |unit?| 90 |symmetricRemainder| 95 |subtractIfCan| 101 |submod| 107 
         |squareFreePart| 114 |squareFree| 119 |sizeLess?| 124 |sign| 130 
         |shift| 135 |sample| 141 |retractIfCan| 145 |retract| 150 |rem| 155 
         |reducedSystem| 161 |recip| 172 |rationalIfCan| 177 |rational?| 182 
         |rational| 187 |random| 192 |quo| 201 |principalIdeal| 207 
         |prime?| 212 |powmod| 217 |positiveRemainder| 224 |positive?| 230 
         |permutation| 235 |patternMatch| 241 |one?| 248 |odd?| 253 |not| 258
         |nextItem| 263 |negative?| 268 |multiEuclidean| 273 |mulmod| 279
         |min| 286 |max| 296 |mask| 306 |length| 311 |lcm| 316 |latex| 327
         |invmod| 332 |init| 338 |inc| 342 |hash| 347 |gcdPolynomial| 357
         |gcd| 363 |factorial| 374 |factor| 379 |extendedEuclidean| 384
         |exquo| 397 |expressIdealMember| 403 |even?| 409 |euclideanSize| 414
         |divide| 419 |differentiate| 425 |dec| 436 |copy| 441 |convert| 446
         |coerce| 471 |characteristic| 491 |bit?| 495 |binomial| 501
         |base| 507 |associates?| 511 |addmod| 517 |abs| 524 ^ 529 |\\/| 541
         |Zero| 547 |Or| 551 |One| 557 |OMwrite| 561 |Not| 585 D 590
         |And| 601 >= 607 > 613 = 619 <= 625 < 631 |/\\| 637 - 643 + 654
          ** 660 * 672))
     (QUOTE (
       (|noetherian| . 0)
       (|canonicalsClosed| . 0)
       (|canonical| . 0)
       (|canonicalUnitNormal| . 0)
       (|multiplicativeValuation| . 0)
       (|noZeroDivisors| . 0)
       ((|commutative| "*") . 0)
       (|rightUnitary| . 0)
       (|leftUnitary| . 0)
       (|unitsKnown| . 0)))
     (CONS 
       (|makeByteWordVec2| 1 
         (QUOTE (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
                 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)))
       (CONS
         (QUOTE 
           #(|IntegerNumberSystem&| |EuclideanDomain&|
             |UniqueFactorizationDomain&| NIL NIL |GcdDomain&|
             |IntegralDomain&| |Algebra&| |Module&| NIL |Module&| NIL NIL
             |Module&| NIL |DifferentialRing&| |OrderedRing&| NIL |Module&|
             NIL |Module&| NIL NIL NIL NIL NIL NIL |Ring&| NIL NIL NIL NIL
             NIL NIL NIL NIL NIL NIL NIL NIL NIL |AbelianGroup&| NIL NIL
             |AbelianMonoid&| |Monoid&| NIL NIL NIL NIL |OrderedSet&|
             |AbelianSemiGroup&| |SemiGroup&| |Logic&| NIL |SetCategory&| NIL
             NIL NIL NIL |RetractableTo&| NIL NIL NIL |RetractableTo&| NIL NIL
             NIL NIL NIL NIL |RetractableTo&| NIL |BasicType&| NIL))
         (CONS
           (QUOTE 
             #((|IntegerNumberSystem|) (|EuclideanDomain|) 
               (|UniqueFactorizationDomain|) (|PrincipalIdealDomain|) 
               (|OrderedIntegralDomain|) (|GcdDomain|) (|IntegralDomain|) 
               (|Algebra| $$) (|Module| 12) (|LinearlyExplicitRingOver| 12) 
               (|Module| #0=#:G1062) (|LinearlyExplicitRingOver| #0#) 
               (|CharacteristicZero|) (|Module| #1=#:G106217) 
               (|LinearlyExplicitRingOver| #1#) (|DifferentialRing|) 
               (|OrderedRing|) (|CommutativeRing|) (|Module| |t#1|) 
               (|EntireRing|) (|Module| $$) (|BiModule| 12 12) 
               (|BiModule| #0# #0#) (|BiModule| #1# #1#) 
               (|OrderedAbelianGroup|) (|BiModule| |t#1| |t#1|) 
               (|BiModule| $$ $$) (|Ring|) (|RightModule| 12) 
               (|LeftModule| 12) (|RightModule| #0#) (|LeftModule| #0#) 
               (|RightModule| #1#) (|LeftModule| #1#) 
               (|OrderedCancellationAbelianMonoid|) (|RightModule| |t#1|) 
               (|LeftModule| |t#1|) (|LeftModule| $$) (|Rng|) 
               (|RightModule| $$) (|OrderedAbelianMonoid|) (|AbelianGroup|) 
               (|OrderedAbelianSemiGroup|) (|CancellationAbelianMonoid|) 
               (|AbelianMonoid|) (|Monoid|) (|PatternMatchable| 12) 
               (|PatternMatchable| #:G1065) (|StepThrough|) 
               (|PatternMatchable| #:G106220) (|OrderedSet|) 
               (|AbelianSemiGroup|) (|SemiGroup|) (|Logic|) (|RealConstant|) 
               (|SetCategory|) (|OpenMath|) (|CoercibleTo| #:G82356) 
               (|ConvertibleTo| 89) (|ConvertibleTo| 91) (|RetractableTo| 12) 
               (|ConvertibleTo| 12) (|ConvertibleTo| #:G1064) 
               (|ConvertibleTo| #:G1063) (|RetractableTo| #:G1061) 
               (|ConvertibleTo| #:G1060) (|ConvertibleTo| 87) 
               (|ConvertibleTo| 88) (|CombinatorialFunctionCategory|) 
               (|ConvertibleTo| #:G106219) (|ConvertibleTo| #:G106218) 
               (|RetractableTo| #:G106216) (|ConvertibleTo| #:G106215) 
               (|BasicType|) (|CoercibleTo| 29)))
             (|makeByteWordVec2| 102 
               (QUOTE 
                 (1 8 7 0 9 3 8 7 0 10 10 11 2 8 7 0 12 13 1 8 7 0 14 0 15 0
                  16 2 8 0 10 15 17 1 8 7 0 18 1 8 7 0 19 1 8 7 0 20 1 12 29
                  0 30 1 0 0 12 33 2 0 22 0 0 1 1 0 0 0 41 1 0 22 0 65 2 0 0 
                  0 0 48 1 0 82 0 83 1 0 0 0 1 1 0 22 0 1 2 0 0 0 0 1 2 0 86
                  0 0 1 3 0 0 0 0 0 73 1 0 0 0 1 1 0 99 0 1 2 0 22 0 0 1 1 0
                  12 0 1 2 0 0 0 0 70 0 0 0 1 1 0 92 0 1 1 0 12 0 1 2 0 0 0 0
                  59 1 0 26 27 28 2 0 75 27 76 77 1 0 86 0 1 1 0 84 0 1 1 0
                  22 0 1 1 0 85 0 1 1 0 0 0 81 0 0 0 80 2 0 0 0 0 58 1 0 93
                  94 1 1 0 22 0 1 3 0 0 0 0 0 1 2 0 0 0 0 78 1 0 22 0 1 2 0 0
                  0 0 1 3 0 90 0 89 90 1 1 0 22 0 1 1 0 22 0 64 1 0 0 0 42 1
                  0 86 0 1 1 0 22 0 74 2 0 95 94 0 1 3 0 0 0 0 0 71 0 0 0 39
                  2 0 0 0 0 67 0 0 0 38 2 0 0 0 0 66 1 0 0 0 1 1 0 0 0 69 1 0
                  0 94 1 2 0 0 0 0 1 1 0 10 0 1 2 0 0 0 0 1 0 0 0 1 1 0 0 0 50
                  1 0 0 0 68 1 0 102 0 1 2 0 100 100 100 1 1 0 0 94 1 2 0 0 0
                  0 62 1 0 0 0 1 1 0 99 0 1 2 0 96 0 0 1 3 0 98 0 0 0 1 2 0 86
                  0 0 1 2 0 95 94 0 1 1 0 22 0 1 1 0 56 0 1 2 0 60 0 0 61 1 0
                  0 0 1 2 0 0 0 56 1 1 0 0 0 51 1 0 0 0 1 1 0 87 0 1 1 0 88 0
                  1 1 0 89 0 1 1 0 91 0 1 1 0 12 0 32 1 0 0 12 79 1 0 0 0 1 1
                  0 0 12 79 1 0 29 0 31 0 0 56 1 2 0 22 0 0 1 2 0 0 0 0 1 0 0
                  0 37 2 0 22 0 0 1 3 0 0 0 0 0 72 1 0 0 0 63 2 0 0 0 56 1 2 0
                  0 0 101 1 2 0 0 0 0 44 0 0 0 35 2 0 0 0 0 47 0 0 0 36 3 0 7
                  8 0 22 25 2 0 10 0 22 23 2 0 7 8 0 24 1 0 10 0 21 1 0 0 0 45
                  1 0 0 0 1 2 0 0 0 56 1 2 0 0 0 0 46 2 0 22 0 0 1 2 0 22 0 0
                  1 2 0 22 0 0 40 2 0 22 0 0 1 2 0 22 0 0 49 2 0 0 0 0 43 1 0
                  0 0 52 2 0 0 0 0 54 2 0 0 0 0 53 2 0 0 0 56 57 2 0 0 0 101 1
                  2 0 0 0 0 55 2 0 0 12 0 34 2 0 0 56 0 1 2 0 0 101 0 1))))))
     (QUOTE |lookupComplete|))) 

(MAKEPROP (QUOTE |SingleInteger|) (QUOTE NILADIC) T) 

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain SINT SingleInteger>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
