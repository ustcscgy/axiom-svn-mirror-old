%% Oh Emacs, this is a -*- Makefile -*-, so give me tabs.
\documentclass{article}
\usepackage{axiom}

\title{\$SPAD/src/algebra Makefile}
\author{Timothy Daly}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\eject

\tableofcontents
\eject

\section{Adding new algebra}
This is a complex process by its very nature. Developers and Maintainers
who undertake the process need to understand quite a lot of detail. The
ultimate steps to add algebra are tedious but simple. Note that only
algebra code that gets shipped with the system needs to undergo this
process. User code can be compiled once the distributed algebra exists
and does not need either this Makefile or this installation process.

NOTE: If you add new algebra to this file you must also update

[[src/algebra/exposed.lsp.pamphlet]]

otherwise the new algebra won't be loaded by the interpreter when needed.

Since understanding is the key to making correct changes to this file
I'll work on explaining the details of why things need to exist. 

The first idea that you need to understand is the overall process
of adding algebra code. Lets assume that you have a brand new spad
file, called [[foo.spad]] containing a simple domain [[BAR]]. The
steps in the process of adding this file are:
\begin{enumerate}
\item Find out where the algebra code lives in the lattice.

You do this by 
\begin{enumerate}
\item starting a new interpsys session
\item collecting all the names of the algebra files BAR requires
\item determining which layer each of the required files resides
\item determine the highest layer (e.g. 14) that contains the required files
\end{enumerate}

\item insert the documentation into the next layer (e.g. 15)
\item insert the [[\${OUT}/BAR.o]] file into the layer's file list
\end{enumerate}

\section{Rebuilding the algebra from scratch}
Compile order is important. Here we try to define the ordered lattice
of spad file dependencies. However this is, in reality, a graph rather
than a lattice. In order to break cycles in this graph we explicitly
cache a few of the intermediate generated lisp code for certain files.
These are marked throughout (both here and in the various pamphlet
files) with the word {\bf BOOTSTRAP}.

If we take a cycle such as {\bf RING} we discover that in order to
compile the spad code we must load the compiled definition of {\bf RING}.
In this case we must compile the cached lisp code before we try to 
compile the spad file.

The cycle for {\bf SETCAT} is longer consisting of: {\bf SETCAT} needs
{\bf SINT} needs {\bf UFD} needs {\bf GCDDOM} needs {\bf COMRING} needs
{\bf RING} needs {\bf RNG} needs {\bf ABELGRP} needs {\bf CABMON} needs
{\bf ABELMON} needs {\bf ABELSG} needs {\bf SETCAT}.

It is highly recommended that you try to become a developer of Axiom
and read the archived mailing lists before you decide to change a
cached file. In the fullness of time we will rewrite the whole algebra
structure into a proper lattice if possible. Alternatively we'll
reimplement the compiler to handle graphs. Or deeply adopt the
extensible domains. Whatever we do will be much discussed (and cause
much disgust) around the campfire. If you come up with a brilliant
plan that gets adopted we'll even inscribe your name on a log and add
it to the fire.

In the code that follows we find the categories, packages and domains
that compile with no dependencies and call this set ``layer 0''. Next
we find the categories, packages and domains that will compile using
only ``layer 0'' code and call this ``layer 1''. We walk up the
lattice in this fashion adding layers. Note that at layer 3 this
process runs into cycles and we create the ``layer 3 bootstrap''
stanzas before continuing upward.

\section{The Algebra Lattice Layers}
\subsection{Layer 0 Bootstrap}
\subsubsection{Completed spad files}
\begin{verbatim}
si.spad.pamphlet (INS SINT)
\end{verbatim}
Note well that none of the algebra stanzas should include these
files in the preconditions otherwise we have an infinite compile
loop. These files are originally bootstrapped from lisp code
when we build the system for the first time but they are
forcibly recompiled at the end of the build so they reflect
current code (just in case someone changes the spad code but
does not re-cache the generated lisp). If you add these files
as preconditions (note that they are all in the {\bf MID} 
directory rather than the {\bf OUT} directory like everything
else) then the final recompile will invalidate all of the
rest of the algebra targets which will get rebuilt again causing
these targets to be out of date. The rest of the loop is left
up to the student.

The bootstrap process works because first we ask for the compiled
lisp code stanzas (the [[\${MID}/BAR.o]] files), THEN we ask for
the final algebra code stanzas (the [[\${OUT}/BAR.o]] files). This
is a very subtle point so think it through carefully. Notice that
this is the only layer calling for [[\${MID}]] files. All other 
layers call for [[\${OUT}]] files. If you break this the world
will no longer compile so don't change it if you don't understand it.

\begin{verbatim}
LAYER0BOOTSTRAP=${OUT}/XPR.o 
\end{verbatim}

The list [[SPADLIST]] below was produced using the following Perl
progam on the list of unpacked [[.spad]] files (as given by [[ls *.spad]]).
\begin{verbatim}
$j=0;
$cl = "     ";
while(<>) {
     chop;
     $l = $_;
     $l =~ s/\.spad/ /;
     $cl .= $l;
     if ($j == 5) {
         print $cl, "\\\n";
         $cl = "     ";
         $j=0;
     } else {
         $j++;
     }
}
$cl =~ s/ $//;
print $cl, "\n";
\end{verbatim}

<<bootstrap variables>>=

SPADLIST=\
     A1AGG ABELGRP ABELMON ABELSG ACF ACFS \
     ACPLOT AF AGG AHYP ALAGG ALGEBRA \
     ALGFACT ALGFF ALGMANIP ALGMFACT ALGPKG ALGSC \
     ALIST AMR ANON AN ANTISYM ANY1 \
     ANY APPLYORE APPRULE ARR2CAT ARRAY12 ARRAY1 \
     ARRAY2 ASP10 ASP12 ASP19 ASP1 ASP20 \
     ASP24 ASP27 ASP28 ASP29 ASP30 ASP31 \
     ASP33 ASP34 ASP35 ASP41 ASP42 ASP49 \
     ASP4 ASP50 ASP55 ASP6 ASP73 ASP74 \
     ASP77 ASP78 ASP7 ASP80 ASP8 ASP9 \
     ASSOCEQ ASTACK ATRIG ATTRBUT ATTREG AUTOMOR \
     BALFACT BASTYPE BBTREE BEZOUT BFUNCT BGAGG \
     BINARY BINFILE BITS BMODULE BOOLEAN BOP1 \
     BOP BOUNDZRO BPADICRT BPADIC BRAGG BRILL \
     BSTREE BTAGG BTCAT BTOURN BTREE CABMON \
     CACHSET CARD CARTEN2 CARTEN CCLASS CDEN \
     CFCAT CHARNZ CHARPOL CHAR CHARZ CHVAR \
     CINTSLPE CLAGG CLIF CLIP CMPLXRT COLOR \
     COMBF COMBINAT COMBOPC COMMONOP COMM COMMUPC \
     COMPCAT COMPFACT COMPLEX2 COMPLEX COMPLPAT COMPPROP \
     COMRING CONTFRAC COORDSYS CPIMA CPMATCH CRAPACK \
     CRFP CSTTOOLS CTRIGMNP CVMP CYCLES CYCLOTOM \
     D01AGNT D01AJFA D01AKFA D01ALFA D01AMFA D01ANFA \
     D01APFA D01AQFA D01ASFA D01FCFA D01GBFA D01TRNS \
     D01WGTS D02AGNT D02BBFA D02BHFA D02CJFA D02EJFA \
     D03AGNT D03EEFA D03FAFA DBASE DBLRESP DDFACT \
     DECIMAL DEFINTEF DEFINTRF DEGRED DEQUEUE DERHAM \
     DFINTTLS DFLOAT DFSFUN DHMATRIX DIAGG DIFEXT \
     DIFRING DIOPS DIOSP DIRPCAT DIRPROD2 DIRPROD \
     DISPLAY DIVRING DLAGG DLIST DLP DMP \
     DPMM DPMO DPOLCAT DQAGG DRAWCFUN DRAWCURV \
     DRAWCX DRAWHACK DRAWPT DRAW DROPT0 DROPT1 \
     DROPT DSMP DVARCAT E04AGNT E04DGFA E04FDFA \
     E04GCFA E04JAFA E04MBFA E04NAFA E04UCFA EAB \
     EF EFSTRUC EFULS EFUPXS ELAGG ELEMFUN \
     ELFUTS ELTAB ELTAGG EMR ENTIRER EP \
     EQ2 EQ EQTBL ERROR ES1 ES2 \
     ESCONT1 ESCONT ES ESTOOLS1 ESTOOLS2 ESTOOLS \
     EUCDOM EVALAB EVALCYC EXIT EXPEXPAN EXPR2 \
     EXPR2UPS EXPRODE EXPR EXPRTUBE EXPUPXS FACTFUNC \
     FACUTIL FAGROUP FAMONC FAMONOID FAMR FARRAY \
     FAXF FCOMP FCPAK1 FC FDIV2 FDIVCAT \
     FDIV FEVALAB FEXPR FFCAT2 FFCAT FFCGP \
     FFCG FFCGX FFF FFHOM FFIELDC FFINTBAS \
     FFNBP FFNB FFNBX FFPOLY2 FFPOLY FFP \
     FFSLPE FF FFX FGLMICPK FGROUP FIELD \
     FILECAT FILE FINAALG FINITE FINRALG FLAGG2 \
     FLAGG FLALG FLASORT FLINEXP FLOATCP FLOATRP \
     FLOAT FM1 FMCAT FMC FMFUN FMONOID \
     FM FMTC FNAME FNCAT FNLA FOP \
     FORDER FORMULA1 FORMULA FORTCAT FORTFN FORTRAN \
     FORT FPARFRAC FPATMAB FPC FPS FR2 \
     FRAC2 FRAC FRAMALG FRETRCT FRIDEAL2 FRIDEAL \
     FRMOD FRNAAF2 FRNAALG FR FRUTIL FS2EXPXP \
     FS2 FS2UPS FSAGG2 FSAGG FSCINT FSERIES \
     FSINT FSPECF FSPRMELT FSRED FS FST \
     FSUPFACT FTEM FT FUNCTION FVC FVFUN \
     GALFACT GALFACTU GALPOLYU GALUTIL GAUSSFAC GBEUCLID \
     GBF GBINTERN GB GCDDOM GCNAALG GDMP \
     GENEEZ GENMFACT GENPGCD GENUFACT GENUPS GHENSEL \
     GMODPOL GOSPER GPOLSET GRALG GRAY GRDEF \
     GRIMAGE GRMOD GROEBSOL GROUP GSERIES GSTBL \
     GTSET HACKPI HASHTBL HB HDMP HDP \
     HEAP HELLFDIV HEUGCD HEXADEC HOAGG HYPCAT \
     IALGFACT IAN IARRAY1 IARRAY2 IBACHIN IBATOOL \
     IBITS IBPTOOLS ICARD ICDEN IDEAL IDECOMP \
     IDPAG IDPAM IDPC IDPOAM IDPOAMS IDPO \
     IEVALAB IFAMON IFARRAY IFF IIARRAY2 ILIST \
     IMATLIN IMATQF IMATRIX INBFF INCRMAPS INDE \
     INEP INFINITY INFORM1 INFORM INFPROD0 INFSP \
     INMODGCD INNMFACT INPRODFF INPRODPF INPSIGN INS \
     INTABL INTAF INTALG INTBIT INTCAT INTDOM \
     INTEF INTFACT INTFTBL INTG0 INTHEORY INTHERAL \
     INTHERTR INTPACK INTPAF INTPM INTRAT INTRET \
     INTRF INTRVL INTSLPE INT INTTOOLS INTTR \
     INVLAPLA IPADIC IPF IPRNTPK IR2F IR2 \
     IROOT IRREDFFX IRRF2F IRSN IR IRURPK \
     ISTRING ISUMP ISUPS ITAYLOR ITFUN2 ITFUN3 \
     ITRIGMNP ITUPLE IVECTOR IXAGG JORDAN KAFILE \
     KDAGG KERNEL2 KERNEL KOERCE KONVERT KOVACIC \
     LALG LAPLACE LA LAUPOL LAZM3PK LEADCDET \
     LEXP LEXTRIPK LFCAT LF LGROBP LIB \
     LIECAT LIE LIMITPS LIMITRF LINDEP LINEXP \
     LIST2MAP LIST2 LIST3 LIST LMDICT LMODULE \
     LMOPS LNAGG LODEEF LODO1 LODO2 LODOCAT \
     LODOF LODOOPS LODO LOGIC LO LPEFRAC \
     LPOLY LSAGG LSMP1 LSMP LSPP LSQM \
     LWORD LZSTAGG M3D MAGMA MAPHACK1 MAPHACK2 \
     MAPHACK3 MAPPKG1 MAPPKG2 MAPPKG3 MATCAT2 MATCAT \
     MATLIN MATRIX MATSTOR MCALCFN MCDEN MCMPLX \
     MDAGG MDDFACT MESH MFINFACT MFLOAT MHROWRED \
     MINT MKBCFUNC MKCHSET MKFLCFN MKFUNC MKRECORD \
     MKUCFUNC MLIFT MLO MMAP MODFIELD MODMONOM \
     MODMON MODOP MODRING MODULE MOEBIUS MONAD \
     MONADWU MONOGEN MONOID MONOTOOL MPC2 MPC3 \
     MPCPF MPOLY MPRFF MRATFAC MRF2 MRING \
     MSETAGG MSET MSYSCMD MTHING MTSCAT MULTFACT \
     MULTSQFR NAALG NAGC02 NAGC05 NAGC06 NAGD01 \
     NAGD02 NAGD03 NAGE01 NAGE02 NAGE04 NAGF01 \
     NAGF02 NAGF04 NAGF07 NAGSP NAGS NARNG \
     NASRING NCEP NCNTFRAC NCODIV NFINTBAS NIPROB \
     NLINSOL NNI NODE1 NONE1 NONE NORMMA \
     NORMPK NORMRETR NPCOEF NREP NSMP NSUP2 \
     NSUP NTPOLFN NTSCAT NUMERIC NUMFMT NUMINT \
     NUMODE NUMQUAD NUMTUBE OAGROUP OAMON OAMONS \
     OASGP OCAMON OC OCTCT2 OCT ODECAT \
     ODECONST ODEEF ODEIFTBL ODEINT ODEPACK ODEPAL \
     ODEPRIM ODEPROB ODEPRRIC ODERAT ODERED ODERTRIC \
     ODESYS ODETOOLS ODPOL ODP ODR ODVAR \
     OFMONOID OINTDOM OMCONN OMDEV OMENC OMERRK \
     OMERR OMEXPR OMLO OMPKG OMSAGG OMSERVER \
     OM ONECOMP2 ONECOMP OPQUERY OP OPTCAT \
     OPTPACK OPTPROB ORDCOMP2 ORDCOMP ORDFIN ORDFUNS \
     ORDMON ORDRING ORDSET OREPCAT OREPCTO ORESUP \
     OREUP ORTHPOL OSI OUTFORM OUT OVAR \
     OWP PADEPAC PADE PADICCT PADICRAT PADICRC \
     PADIC PALETTE PAN2EXPR PARPC2 PARPCURV PARSC2 \
     PARSCURV PARSU2 PARSURF PARTPERM PATAB PATLRES \
     PATMAB PATMATCH PATRES2 PATRES PATTERN1 PATTERN2 \
     PATTERN PBWLB PCOMP PDECAT PDECOMP PDEPACK \
     PDEPROB PDRING PENDTREE PERMAN PERMCAT PERMGRP \
     PERM PFBR PFBRU PFECAT PFOQ PFO \
     PFOTOOLS PFRPAC PFR PF PGCD PGE \
     PGROEB PICOERCE PID PINTERPA PINTERP PI \
     PLEQN PLOT1 PLOT3D PLOT PLOTTOOL PMASSFS \
     PMASS PMDOWN PMFS PMINS PMKERNEL PMLSAGG \
     PMPLCAT PMPREDFS PMPRED PMQFCAT PMSYM PMTOOLS \
     PNTHEORY POINT POLTOPOL POLUTIL POLY2 POLY2UP \
     POLYCATQ POLYCAT POLYLIFT POLYROOT POLY PPCURVE \
     PREASSOC PRIMARR2 PRIMARR PRIMCAT PRIMELT PRIMES \
     PRINT PRODUCT PRQAGG PR PRS PRTITION \
     PSCAT PSCURVE PSETCAT PSETPK PSEUDLIN PSQFR \
     PTCAT PTFUNC2 PTPACK PTRANFN PUSHVAR PWFFINTB \
     QALGSET2 QALGSET QCMPACK QEQUAT QFCAT2 QFCAT \
     QFORM QUAGG QUATCAT QUATCT2 QUAT QUEUE \
     RADCAT RADFF RADIX RADUTIL RANDSRC RATFACT \
     RATRET RCAGG RCFIELD RDEEF RDEEFS RDETR \
     RDETRS RDIST RDIV REAL0Q REAL0 REALSOLV \
     REAL RECLOS REDORDER REF REGSET REP1 \
     REP2 REPDB REP REPSQ RESLATC RESRING \
     RESULT RETRACT RETSOL RFDIST RFFACTOR RFFACT \
     RF RGCHAIN RIDIST RING RINTERP RMATCAT \
     RMATRIX RMCAT2 RMODULE RNG RNS ROIRC \
     ROMAN ROUTINE RPOLCAT RRCC RSDCMPK RSETCAT \
     RSETGCD RULECOLD RULESET RULE RURPK SAEFACT \
     SAERFFC SAE SAOS SCACHE SCPKG SDPOL \
     SDVAR SEG2 SEGBIND2 SEGBIND SEGCAT SEG \
     SEGXCAT SETAGG SETCAT SETMN SET SEXCAT \
     SEXOF SEX SFORT SFQCMPK SFRGCD SFRTCAT \
     SGCF SGROUP SHDP SHP SIGNEF SIGNRF \
     SIMPAN SINT SKAGG SMATCAT SMITH SMP \
     SMTS SNTSCAT SOLVEFOR SOLVERAD SOLVESER SOLVETRA \
     SORTPAK SPACE3 SPACEC SPECOUT SPFCAT SPLNODE \
     SPLTREE SQMATRIX SRAGG SRDCMPK SREGSET STACK \
     STAGG STBL STEP STINPROD STREAM1 STREAM2 \
     STREAM3 STREAM STRICAT STRING STRTBL STTAYLOR \
     STTFNC STTF SUBRESP SUBSPACE SUCH SULS \
     SUMFS SUMRF SUP2 SUPFRACF SUP SUPXS \
     SUTS SWITCH SYMBOL SYMFUNC SYMPOLY SYMS \
     SYMTAB SYSSOLP TABLBUMP TABLEAU TABLE TANEXP \
     TBAGG TBCMPPK TEMUTL TEX1 TEX TEXTFILE \
     TOOLSIGN TOPSP TRANFUN TREE TRIGCAT TRIGMNIP \
     TRIMAT TRMANIP TSETCAT TS TUBE TUBETOOL \
     TUPLE TWOFACT TYPE UDPO UDVO UFD \
     ULS2 ULSCAT ULSCCAT ULSCONS ULS UNIFACT \
     UNISEG2 UNISEG UP2 UPCDEN UPDECOMP UPDIVP \
     UPMP UPOLYC2 UPOLYC UPSCAT UP UPSQFREE \
     UPXS2 UPXSCAT UPXSCCA UPXSCONS UPXSSING UPXS \
     URAGG UTS2 UTSCAT UTSODE UTSODETL UTS \
     VARIABLE VECTCAT VECTOR2 VECTOR VIEW2D VIEW3D \
     VIEWDEF VIEW VOID VSPACE WEIER WFFINTBS \
     WP WUTSET XALG XDPOLY XEXPPKG XFALG \
     XF XPBWPOLY XPOLYC XPOLY XPR XRPOLY \
     YSTREAM ZDSOLVE ZLINDEP ZMOD

CTRACE= | if [ -z "${NOISE}" ] ; then cat ; else cat >> ${TMP}/trace ; fi

# Full list of categories
CATLIST= AHYP ATTREG CFCAT ELTAB KOERCE KONVERT OM PRIMCAT PTRANFN \
        SPFCAT TYPE BASTYPE IEVALAB AGG EVALAB SETCAT HOAGG CLAGG \
        RADCAT RETRACT TRIGCAT ATRIG HYPCAT ELEMFUN ELTAGG IXAGG \
        LNAGG ORDSET FLAGG A1AGG ABELSG ABELMON CABMON ABELGRP \
        LMODULE RMODULE BMODULE MODULE SGROUP MONOID RNG RING ALGEBRA \
        COMRING ENTIRER DIVRING INTDOM GCDDOM PID EUCDOM UFD FIELD \
        ACF CHARNZ CHARZ ES LINEXP FLINEXP PATMAB FPATMAB FRETRCT \
        GROUP PDRING PATAB FS ACFS BGAGG DIOPS DIAGG ELAGG KDAGG \
        RCAGG URAGG STAGG LSAGG TBAGG ALAGG AMR ARR2CAT BRAGG LOGIC \
        BTAGG BTCAT CACHSET COMBOPC DIFRING DIFEXT FPC FINITE STEP \
        FFIELDC FINRALG FRAMALG FEVALAB MONOGEN PFECAT TRANFUN COMPCAT \
        OASGP OAMON OCAMON OAGROUP OAMONS ORDRING VSPACE DIRPCAT DLAGG \
        FAMR POLYCAT DPOLCAT QUAGG SKAGG DQAGG DVARCAT FAMONC XF FAXF \
        FDIVCAT FFCAT FILECAT MONAD NARNG NAALG FINAALG LIECAT FLALG \
        FORTCAT FMC FMCAT FMFUN FMTC FNCAT FORTFN REAL RNS FPS FRNAALG \
        SETAGG FSAGG FVC FVFUN GRMOD GRALG IDPC OINTDOM INS INTCAT LALG \
        LFCAT OREPCAT LODOCAT LZSTAGG MATCAT MDAGG MLO MONADWU MSETAGG \
        PSCAT MTSCAT NASRING PSETCAT TSETCAT RSETCAT NTSCAT NUMINT OC \
        ODECAT PRQAGG OMSAGG OPTCAT ORDFIN ORDMON PADICCT PDECAT PERMCAT \
        PPCURVE PSCURVE VECTCAT PTCAT QFCAT QUATCAT RCFIELD RMATCAT \
        RPOLCAT RRCC SEGCAT SEGXCAT SEXCAT SFRTCAT SMATCAT SNTSCAT \
        SPACEC SRAGG STRICAT UPSCAT ULSCAT ULSCCAT UPOLYC UPXSCAT \
        UPXSCCA UTSCAT XALG XFALG XPOLYC


# List of core domains
DOMLIST= ALIST BOOLEAN CHAR DFLOAT FRAC ILIST IARRAY1 ISTRING IVECTOR \
        INT LIST NNI OUTFORM PI PRIMARR REF SINT STRING SYMBOL VECTOR

# List of categories which provide default implementations
CATDOMS= A1AGG ABELGRP ABELMON ABELSG ACF ACFS AGG ALGEBRA AMR ARR2CAT \
        ATRIG BASTYPE BGAGG BRAGG BTAGG BTCAT CLAGG COMPCAT DIAGG \
        DIFEXT DIFRING DIOPS DIRPCAT DIVRING DPOLCAT DVARCAT ELAGG \
        ELEMFUN ELTAGG ES EUCDOM EVALAB FAMR FAXF FDIVCAT FEVALAB \
        FFCAT FFIELDC FIELD FINAALG FINRALG FLAGG FLINEXP FPC FPS \
        FRAMALG FRETRCT FRNAALG FSAGG FS GCDDOM GRALG GRMOD GROUP \
        HOAGG HYPCAT IEVALAB INS INTDOM IXAGG KDAGG LALG LIECAT LNAGG \
        LODOCAT LOGIC LSAGG LZSTAGG MATCAT MODULE MONAD MONADWU \
        MONOGEN MONOID NAALG NARNG NASRING OC ORDRING ORDSET OREPCAT \
        PDRING PFECAT POLYCAT PSCAT PSETCAT QFCAT QUATCAT RADCAT \
        RCAGG RCFIELD RETRACT RING RMATCAT RNS RPOLCAT RRCC RSETCAT \
        SETAGG SETCAT SGROUP SMATCAT SRAGG STAGG TBAGG TRANFUN \
        TRIGCAT TSETCAT UFD ULSCCAT UPOLYC UPSCAT UPXSCCA URAGG \
        UTSCAT VECTCAT VSPACE XF
@

<<layer0 bootstrap>>=
stamp-bootstrap: $(patsubst %, ${MID}/%.spad, ${CATLIST} ${DOMLIST})
	( cd ${MID} || exit 1 ; \
	echo "Stage 1 object bootstrap (bootStrapMode)" ; \
	echo ')lisp (setf |$$bootStrapMode| t)' > boo1.input ; \
	for A in ${CATLIST} ; do \
	     echo ')compile "'$$A'.spad"' >> boo1.input ; \
	done; \
	{ echo ')read "boo1.input"' | \
	    ${INTERPSYS} ${CTRACE} } || exit 1 ; \
	echo "Stage 1 copy" ; \
	for A in ${CATLIST} ; do \
	    cp $$A.NRLIB/code.$(FASLEXT) ${OUT}/$$A.$(FASLEXT) || exit 1 ; \
	done ; \
	echo "Stage 2 object bootstrap (bootstrapDomains)" ; \
	echo ')lisp (setf |$$bootstrapDomains| t)' > boo2.input ; \
	for A in ${CATLIST} ${DOMLIST} ; do \
	    echo ')compile "'$$A'.spad"' >> boo2.input ; \
	done; \
	{ echo ')read "boo2.input"' | \
	    ${INTERPSYS} ${CTRACE} } || exit 1 ; \
	echo "Stage 2 copy" ; \
	for A in ${CATLIST} ${DOMLIST} ; do \
	    cp $$A.NRLIB/code.$(FASLEXT) ${OUT}/$$A.$(FASLEXT) || exit 1 ; \
	done ; \
	for A in ${CATDOMS} ; do \
	    cp $${A}-.NRLIB/code.$(FASLEXT) ${OUT}/$${A}-.$(FASLEXT) || exit 1 ; \
	done ; \
	echo "Stage 3 object bootstrap (normal mode)" ; \
	for A in ${CATLIST} ${DOMLIST} ; do \
	    echo ')compile "'$$A'.spad"' >> boo3.input ; \
	done; \
	{ echo ')read "boo3.input"' | \
	    ${INTERPSYS} ${CTRACE} } || exit 1 ; \
	echo "Stage 3 object copy" ; \
	for A in ${CATLIST} ${DOMLIST} ; do \
	   cp $$A.NRLIB/code.$(FASLEXT) ${OUT}/$$A.$(FASLEXT) || exit 1 ; \
	done ; \
	for A in ${CATDOMS} ; do \
	    cp $${A}-.NRLIB/code.$(FASLEXT) ${OUT}/$${A}-.$(FASLEXT)  || exit 1 ; \
	done ; \
	)
	touch stamp-bootstrap

$(patsubst %, ${OUT}/%.$(FASLEXT), ${SPADLIST}) : stamp-bootstrap
@

\subsection{User Layer for newly added algebra}
Rather than classify newly created algebra into the existing type lattice
we add it here.
<<USERLAYER>>=

GUESSLIST= SUPEXPR FAMR2 NEWTON UFPS GOPT GUESSF1 \
           UTSSOL FFFG UFPS1 GOPT0 EXPRSOL FFFGF \
           RECOP GUESS GUESSINT GUESSP GUESSF

@

\section{Broken Files}
These files are Aldor files
\begin{verbatim}
axtimer.as Timer
iviews.as  InventorRenderPackage IVREND
ffrac.as   FormalFraction FORMAL
iviews.as  InventorViewPort IVVIEW
iviews.as  InventorDataSink IVDATA
herm.as    PackedHermitianSequence PACKED
nsfip.as   NagSpecialFunctionsInterfacePackage NAGSPE
nrc.as     NagResultChecks NAGRES
nqip.as    NagQuadratureInterfacePackage NAGQUA
noptip.as  NagOptimizationInterfacePackage NAGOPT
nepip.as   NagEigenInterfacePackage NAGEIG
ndftip.as  NagDiscreteFourierTransformInterfacePackage NAGDIS
\end{verbatim}

These domains are referenced but don't exist
\begin{verbatim}
OBJECT
\end{verbatim}

\section{The Environment}
\subsection{The working directories}
We define 5 directories for this build. The{\bf IN} directory
contains the pamphlet files for the algebra. These are expanded
into the{\bf MID} directory as either .spad or .as files. The
.spad files are compiled by the native spad internal compiler.
The .as files are compiled using the Aldor compiler. The output
of the compilation has two purposes. Part of the information is
used to build various database files (daase files). The other
part is executable code which is placed in the {\bf OUT}
directory. When invoked as ``make document'' we construct
the .dvi files in the{\bf DOC} directory.

The [[OUTSRC=$(axiom_target_srcdir)/algebra]] subdirectory contains the 
algebra source files extracted from the pamphlet files. These sources 
allow the end user to change the algebra if needed.

<<environment>>=

MID=${INT}/algebra
OUT=$(axiom_targetdir)/algebra
DOC=$(axiom_target_docdir)/src/algebra
OUTSRC=$(axiom_target_srcdir)/algebra
INPUT=${INT}/input

@

\subsection{The interpsys variable}
The {\bf interpsys} image is the compile-time environment for algebra
files.

<<environment>>=

INTERPSYS=$(axiom_build_bindir)/interpsys

@
\subsection{The SPADFILES list}
Note that we have excluded {\bf mlift.spad.jhd} from this list.
We need to figure out which mlift.spad to keep.

<<environment>>=

SPADFILES= \
 ${OUTSRC}/acplot.spad ${OUTSRC}/aggcat2.spad ${OUTSRC}/aggcat.spad \
 ${OUTSRC}/algcat.spad ${OUTSRC}/algext.spad ${OUTSRC}/algfact.spad \
 ${OUTSRC}/algfunc.spad ${OUTSRC}/allfact.spad ${OUTSRC}/alql.spad \
 ${OUTSRC}/annacat.spad ${OUTSRC}/any.spad ${OUTSRC}/array1.spad \
 ${OUTSRC}/array2.spad ${OUTSRC}/asp.spad ${OUTSRC}/attreg.spad \
 ${OUTSRC}/bags.spad ${OUTSRC}/bezout.spad ${OUTSRC}/boolean.spad \
 ${OUTSRC}/brill.spad \
 ${OUTSRC}/c02.spad ${OUTSRC}/c05.spad ${OUTSRC}/c06.spad \
 ${OUTSRC}/card.spad ${OUTSRC}/carten.spad ${OUTSRC}/catdef.spad \
 ${OUTSRC}/cden.spad ${OUTSRC}/clifford.spad ${OUTSRC}/clip.spad \
 ${OUTSRC}/cmplxrt.spad ${OUTSRC}/coerce.spad ${OUTSRC}/color.spad \
 ${OUTSRC}/combfunc.spad ${OUTSRC}/combinat.spad ${OUTSRC}/complet.spad \
 ${OUTSRC}/constant.spad ${OUTSRC}/contfrac.spad ${OUTSRC}/cont.spad \
 ${OUTSRC}/coordsys.spad ${OUTSRC}/cra.spad ${OUTSRC}/crfp.spad \
 ${OUTSRC}/curve.spad ${OUTSRC}/cycles.spad ${OUTSRC}/cyclotom.spad \
 ${OUTSRC}/d01agents.spad ${OUTSRC}/d01Package.spad \
 ${OUTSRC}/d01routine.spad ${OUTSRC}/d01.spad ${OUTSRC}/d01transform.spad \
 ${OUTSRC}/d01weights.spad ${OUTSRC}/d02agents.spad \
 ${OUTSRC}/d02Package.spad ${OUTSRC}/d02routine.spad ${OUTSRC}/d02.spad \
 ${OUTSRC}/d03agents.spad ${OUTSRC}/d03Package.spad \
 ${OUTSRC}/d03routine.spad ${OUTSRC}/d03.spad ${OUTSRC}/ddfact.spad \
 ${OUTSRC}/defaults.spad ${OUTSRC}/defintef.spad ${OUTSRC}/defintrf.spad \
 ${OUTSRC}/degred.spad ${OUTSRC}/derham.spad ${OUTSRC}/dhmatrix.spad \
 ${OUTSRC}/divisor.spad ${OUTSRC}/dpolcat.spad ${OUTSRC}/drawopt.spad \
 ${OUTSRC}/drawpak.spad ${OUTSRC}/draw.spad \
 ${OUTSRC}/e01.spad ${OUTSRC}/e02.spad ${OUTSRC}/e04agents.spad \
 ${OUTSRC}/e04Package.spad ${OUTSRC}/e04routine.spad ${OUTSRC}/e04.spad \
 ${OUTSRC}/efstruc.spad ${OUTSRC}/efuls.spad ${OUTSRC}/efupxs.spad \
 ${OUTSRC}/eigen.spad ${OUTSRC}/elemntry.spad ${OUTSRC}/elfuts.spad \
 ${OUTSRC}/equation1.spad ${OUTSRC}/equation2.spad ${OUTSRC}/error.spad \
 ${OUTSRC}/expexpan.spad ${OUTSRC}/expr2ups.spad \
 ${OUTSRC}/exprode.spad ${OUTSRC}/expr.spad \
 ${OUTSRC}/f01.spad ${OUTSRC}/f02.spad ${OUTSRC}/f04.spad \
 ${OUTSRC}/f07.spad ${OUTSRC}/facutil.spad ${OUTSRC}/ffcat.spad \
 ${OUTSRC}/ffcg.spad ${OUTSRC}/fff.spad ${OUTSRC}/ffhom.spad \
 ${OUTSRC}/ffnb.spad ${OUTSRC}/ffpoly2.spad ${OUTSRC}/ffpoly.spad \
 ${OUTSRC}/ffp.spad ${OUTSRC}/ffx.spad \
 ${OUTSRC}/files.spad ${OUTSRC}/float.spad ${OUTSRC}/fmod.spad \
 ${OUTSRC}/fname.spad ${OUTSRC}/fnla.spad ${OUTSRC}/formula.spad \
 ${OUTSRC}/fortcat.spad ${OUTSRC}/fortmac.spad ${OUTSRC}/fortpak.spad \
 ${OUTSRC}/fortran.spad ${OUTSRC}/forttyp.spad ${OUTSRC}/fourier.spad \
 ${OUTSRC}/fparfrac.spad ${OUTSRC}/fraction.spad ${OUTSRC}/free.spad \
 ${OUTSRC}/fr.spad ${OUTSRC}/fs2expxp.spad ${OUTSRC}/fs2ups.spad \
 ${OUTSRC}/fspace.spad ${OUTSRC}/funcpkgs.spad ${OUTSRC}/functions.spad \
 ${OUTSRC}/galfact.spad ${OUTSRC}/galfactu.spad ${OUTSRC}/galpolyu.spad \
 ${OUTSRC}/galutil.spad ${OUTSRC}/gaussfac.spad ${OUTSRC}/gaussian.spad \
 ${OUTSRC}/gbeuclid.spad ${OUTSRC}/gbintern.spad ${OUTSRC}/gb.spad \
 ${OUTSRC}/gdirprod.spad ${OUTSRC}/gdpoly.spad ${OUTSRC}/geneez.spad \
 ${OUTSRC}/generic.spad ${OUTSRC}/genufact.spad ${OUTSRC}/genups.spad \
 ${OUTSRC}/ghensel.spad ${OUTSRC}/gpgcd.spad ${OUTSRC}/gpol.spad \
 ${OUTSRC}/grdef.spad ${OUTSRC}/groebf.spad ${OUTSRC}/groebsol.spad \
 ${OUTSRC}/gseries.spad \
 ${OUTSRC}/ideal.spad ${OUTSRC}/idecomp.spad ${OUTSRC}/indexedp.spad \
 ${OUTSRC}/infprod.spad ${OUTSRC}/intaf.spad ${OUTSRC}/intalg.spad \
 ${OUTSRC}/intaux.spad ${OUTSRC}/intclos.spad ${OUTSRC}/intef.spad \
 ${OUTSRC}/integer.spad ${OUTSRC}/integrat.spad \
 ${OUTSRC}/interval.spad \
 ${OUTSRC}/intfact.spad ${OUTSRC}/intpm.spad \
 ${OUTSRC}/intrf.spad \
 ${OUTSRC}/irexpand.spad \
 ${OUTSRC}/irsn.spad ${OUTSRC}/ituple.spad \
 ${OUTSRC}/kl.spad ${OUTSRC}/kovacic.spad \
 ${OUTSRC}/laplace.spad ${OUTSRC}/laurent.spad ${OUTSRC}/leadcdet.spad \
 ${OUTSRC}/lie.spad ${OUTSRC}/limitps.spad ${OUTSRC}/lindep.spad \
 ${OUTSRC}/lingrob.spad ${OUTSRC}/liouv.spad ${OUTSRC}/listgcd.spad \
 ${OUTSRC}/list.spad ${OUTSRC}/lmdict.spad ${OUTSRC}/lodof.spad \
 ${OUTSRC}/lodop.spad ${OUTSRC}/lodo.spad \
 ${OUTSRC}/manip.spad ${OUTSRC}/mappkg.spad ${OUTSRC}/matcat.spad \
 ${OUTSRC}/matfuns.spad ${OUTSRC}/matrix.spad ${OUTSRC}/matstor.spad \
 ${OUTSRC}/mesh.spad ${OUTSRC}/mfinfact.spad ${OUTSRC}/misc.spad \
 ${OUTSRC}/mkfunc.spad ${OUTSRC}/mkrecord.spad \
 ${OUTSRC}/mlift.spad ${OUTSRC}/moddfact.spad ${OUTSRC}/modgcd.spad \
 ${OUTSRC}/modmonom.spad ${OUTSRC}/modmon.spad ${OUTSRC}/modring.spad \
 ${OUTSRC}/moebius.spad ${OUTSRC}/mring.spad ${OUTSRC}/mset.spad \
 ${OUTSRC}/mts.spad ${OUTSRC}/multfact.spad ${OUTSRC}/multpoly.spad \
 ${OUTSRC}/multsqfr.spad \
 ${OUTSRC}/naalgc.spad ${OUTSRC}/naalg.spad \
 ${OUTSRC}/newdata.spad ${OUTSRC}/newpoint.spad \
 ${OUTSRC}/newpoly.spad ${OUTSRC}/nlinsol.spad ${OUTSRC}/nlode.spad \
 ${OUTSRC}/npcoef.spad \
 ${OUTSRC}/nregset.spad \
 ${OUTSRC}/nsregset.spad ${OUTSRC}/numeigen.spad ${OUTSRC}/numeric.spad \
 ${OUTSRC}/numode.spad ${OUTSRC}/numquad.spad ${OUTSRC}/numsolve.spad \
 ${OUTSRC}/numtheor.spad \
 ${OUTSRC}/oct.spad ${OUTSRC}/odealg.spad ${OUTSRC}/odeef.spad \
 ${OUTSRC}/oderf.spad ${OUTSRC}/omcat.spad ${OUTSRC}/omdev.spad \
 ${OUTSRC}/omerror.spad ${OUTSRC}/omserver.spad ${OUTSRC}/opalg.spad \
 ${OUTSRC}/openmath.spad ${OUTSRC}/op.spad ${OUTSRC}/ore.spad \
 ${OUTSRC}/outform.spad ${OUTSRC}/out.spad \
 ${OUTSRC}/pade.spad ${OUTSRC}/padiclib.spad ${OUTSRC}/padic.spad \
 ${OUTSRC}/paramete.spad ${OUTSRC}/partperm.spad ${OUTSRC}/patmatch1.spad \
 ${OUTSRC}/patmatch2.spad ${OUTSRC}/pattern.spad ${OUTSRC}/pcurve.spad \
 ${OUTSRC}/pdecomp.spad ${OUTSRC}/perman.spad ${OUTSRC}/permgrps.spad \
 ${OUTSRC}/perm.spad ${OUTSRC}/pfbr.spad ${OUTSRC}/pfo.spad \
 ${OUTSRC}/pfr.spad ${OUTSRC}/pf.spad ${OUTSRC}/pgcd.spad \
 ${OUTSRC}/pgrobner.spad ${OUTSRC}/pinterp.spad ${OUTSRC}/pleqn.spad \
 ${OUTSRC}/plot3d.spad ${OUTSRC}/plot.spad ${OUTSRC}/plottool.spad \
 ${OUTSRC}/polset.spad ${OUTSRC}/poltopol.spad ${OUTSRC}/polycat.spad \
 ${OUTSRC}/poly.spad ${OUTSRC}/primelt.spad ${OUTSRC}/print.spad \
 ${OUTSRC}/product.spad ${OUTSRC}/prs.spad ${OUTSRC}/prtition.spad \
 ${OUTSRC}/pscat.spad ${OUTSRC}/pseudolin.spad ${OUTSRC}/ptranfn.spad \
 ${OUTSRC}/puiseux.spad \
 ${OUTSRC}/qalgset.spad ${OUTSRC}/quat.spad \
 ${OUTSRC}/radeigen.spad ${OUTSRC}/radix.spad ${OUTSRC}/random.spad \
 ${OUTSRC}/ratfact.spad ${OUTSRC}/rdeef.spad ${OUTSRC}/rderf.spad \
 ${OUTSRC}/rdesys.spad ${OUTSRC}/real0q.spad ${OUTSRC}/realzero.spad \
 ${OUTSRC}/reclos.spad ${OUTSRC}/regset.spad ${OUTSRC}/rep1.spad \
 ${OUTSRC}/rep2.spad ${OUTSRC}/resring.spad ${OUTSRC}/retract.spad \
 ${OUTSRC}/rf.spad ${OUTSRC}/riccati.spad ${OUTSRC}/rinterp.spad \
 ${OUTSRC}/routines.spad \
 ${OUTSRC}/rule.spad \
 ${OUTSRC}/seg.spad ${OUTSRC}/setorder.spad ${OUTSRC}/sets.spad \
 ${OUTSRC}/sex.spad ${OUTSRC}/sf.spad ${OUTSRC}/sgcf.spad \
 ${OUTSRC}/sign.spad ${OUTSRC}/si.spad ${OUTSRC}/smith.spad \
 ${OUTSRC}/solvedio.spad ${OUTSRC}/solvefor.spad ${OUTSRC}/solvelin.spad \
 ${OUTSRC}/solverad.spad ${OUTSRC}/sortpak.spad ${OUTSRC}/space.spad \
 ${OUTSRC}/special.spad ${OUTSRC}/sregset.spad ${OUTSRC}/s.spad \
 ${OUTSRC}/stream.spad ${OUTSRC}/string.spad ${OUTSRC}/sttaylor.spad \
 ${OUTSRC}/sttf.spad ${OUTSRC}/sturm.spad ${OUTSRC}/suchthat.spad \
 ${OUTSRC}/suls.spad ${OUTSRC}/sum.spad ${OUTSRC}/sups.spad \
 ${OUTSRC}/supxs.spad ${OUTSRC}/suts.spad ${OUTSRC}/symbol.spad \
 ${OUTSRC}/syssolp.spad ${OUTSRC}/system.spad \
 ${OUTSRC}/tableau.spad ${OUTSRC}/table.spad ${OUTSRC}/taylor.spad \
 ${OUTSRC}/tex.spad ${OUTSRC}/tools.spad ${OUTSRC}/transsolve.spad \
 ${OUTSRC}/tree.spad ${OUTSRC}/trigcat.spad ${OUTSRC}/triset.spad \
 ${OUTSRC}/tube.spad ${OUTSRC}/twofact.spad \
 ${OUTSRC}/unifact.spad ${OUTSRC}/updecomp.spad ${OUTSRC}/updivp.spad \
 ${OUTSRC}/utsode.spad \
 ${OUTSRC}/variable.spad ${OUTSRC}/vector.spad ${OUTSRC}/view2D.spad \
 ${OUTSRC}/view3D.spad ${OUTSRC}/viewDef.spad ${OUTSRC}/viewpack.spad \
 ${OUTSRC}/void.spad \
 ${OUTSRC}/weier.spad ${OUTSRC}/wtpol.spad \
 ${OUTSRC}/xlpoly.spad ${OUTSRC}/xpoly.spad \
 ${OUTSRC}/ystream.spad \
 ${OUTSRC}/zerodim.spad

@
\subsection{The ALDORFILES list}
<<environment>>=

ALDORFILES= \
 ${MID}/axtimer.as \
 ${MID}/ffrac.as \
 ${MID}/herm.as \
 ${MID}/interval.as \
 ${MID}/invnode.as ${MID}/invrender.as \
 ${MID}/invtypes.as ${MID}/invutils.as \
 ${MID}/iviews.as \
 ${MID}/ndftip.as \
 ${MID}/nepip.as \
 ${MID}/noptip.as ${MID}/nqip.as \
 ${MID}/nrc.as ${MID}/nsfip.as 

@
\subsection{The DOCFILES list}
<<environment>>=

DOCFILES= \
 ${DOC}/acplot.spad.dvi ${DOC}/aggcat2.spad.dvi ${DOC}/aggcat.spad.dvi \
 ${DOC}/algcat.spad.dvi ${DOC}/algext.spad.dvi ${DOC}/algfact.spad.dvi \
 ${DOC}/algfunc.spad.dvi ${DOC}/allfact.spad.dvi ${DOC}/alql.spad.dvi \
 ${DOC}/annacat.spad.dvi ${DOC}/any.spad.dvi ${DOC}/array1.spad.dvi \
 ${DOC}/array2.spad.dvi ${DOC}/asp.spad.dvi ${DOC}/attreg.spad.dvi \
 ${DOC}/axtimer.as.dvi \
 ${DOC}/bags.spad.dvi ${DOC}/bezout.spad.dvi ${DOC}/boolean.spad.dvi \
 ${DOC}/brill.spad.dvi \
 ${DOC}/c02.spad.dvi ${DOC}/c05.spad.dvi ${DOC}/c06.spad.dvi \
 ${DOC}/card.spad.dvi ${DOC}/carten.spad.dvi ${DOC}/catdef.spad.dvi \
 ${DOC}/cden.spad.dvi ${DOC}/clifford.spad.dvi ${DOC}/clip.spad.dvi \
 ${DOC}/cmplxrt.spad.dvi ${DOC}/coerce.spad.dvi ${DOC}/color.spad.dvi \
 ${DOC}/combfunc.spad.dvi ${DOC}/combinat.spad.dvi ${DOC}/complet.spad.dvi \
 ${DOC}/constant.spad.dvi ${DOC}/contfrac.spad.dvi ${DOC}/cont.spad.dvi \
 ${DOC}/coordsys.spad.dvi ${DOC}/cra.spad.dvi ${DOC}/crfp.spad.dvi \
 ${DOC}/curve.spad.dvi ${DOC}/cycles.spad.dvi ${DOC}/cyclotom.spad.dvi \
 ${DOC}/d01agents.spad.dvi ${DOC}/d01Package.spad.dvi \
 ${DOC}/d01routine.spad.dvi ${DOC}/d01.spad.dvi ${DOC}/d01transform.spad.dvi \
 ${DOC}/d01weights.spad.dvi ${DOC}/d02agents.spad.dvi \
 ${DOC}/d02Package.spad.dvi ${DOC}/d02routine.spad.dvi ${DOC}/d02.spad.dvi \
 ${DOC}/d03agents.spad.dvi ${DOC}/d03Package.spad.dvi \
 ${DOC}/d03routine.spad.dvi ${DOC}/d03.spad.dvi ${DOC}/ddfact.spad.dvi \
 ${DOC}/defaults.spad.dvi ${DOC}/defintef.spad.dvi ${DOC}/defintrf.spad.dvi \
 ${DOC}/degred.spad.dvi ${DOC}/derham.spad.dvi ${DOC}/dhmatrix.spad.dvi \
 ${DOC}/divisor.spad.dvi ${DOC}/dpolcat.spad.dvi ${DOC}/drawopt.spad.dvi \
 ${DOC}/drawpak.spad.dvi ${DOC}/draw.spad.dvi \
 ${DOC}/e01.spad.dvi ${DOC}/e02.spad.dvi ${DOC}/e04agents.spad.dvi \
 ${DOC}/e04Package.spad.dvi ${DOC}/e04routine.spad.dvi ${DOC}/e04.spad.dvi \
 ${DOC}/efstruc.spad.dvi ${DOC}/efuls.spad.dvi ${DOC}/efupxs.spad.dvi \
 ${DOC}/eigen.spad.dvi ${DOC}/elemntry.spad.dvi ${DOC}/elfuts.spad.dvi \
 ${DOC}/equation1.spad.dvi ${DOC}/equation2.spad.dvi ${DOC}/error.spad.dvi \
 ${DOC}/expexpan.spad.dvi ${DOC}/exposed.lsp.dvi ${DOC}/expr2ups.spad.dvi \
 ${DOC}/exprode.spad.dvi ${DOC}/expr.spad.dvi \
 ${DOC}/f01.spad.dvi ${DOC}/f02.spad.dvi ${DOC}/f04.spad.dvi \
 ${DOC}/f07.spad.dvi ${DOC}/facutil.spad.dvi ${DOC}/ffcat.spad.dvi \
 ${DOC}/ffcg.spad.dvi ${DOC}/fff.spad.dvi ${DOC}/ffhom.spad.dvi \
 ${DOC}/ffnb.spad.dvi ${DOC}/ffpoly2.spad.dvi ${DOC}/ffpoly.spad.dvi \
 ${DOC}/ffp.spad.dvi ${DOC}/ffrac.as.dvi ${DOC}/ffx.spad.dvi \
 ${DOC}/files.spad.dvi ${DOC}/float.spad.dvi ${DOC}/fmod.spad.dvi \
 ${DOC}/fname.spad.dvi ${DOC}/fnla.spad.dvi ${DOC}/formula.spad.dvi \
 ${DOC}/fortcat.spad.dvi ${DOC}/fortmac.spad.dvi ${DOC}/fortpak.spad.dvi \
 ${DOC}/fortran.spad.dvi ${DOC}/forttyp.spad.dvi ${DOC}/fourier.spad.dvi \
 ${DOC}/fparfrac.spad.dvi ${DOC}/fraction.spad.dvi ${DOC}/free.spad.dvi \
 ${DOC}/fr.spad.dvi ${DOC}/fs2expxp.spad.dvi ${DOC}/fs2ups.spad.dvi \
 ${DOC}/fspace.spad.dvi ${DOC}/funcpkgs.spad.dvi ${DOC}/functions.spad.dvi \
 ${DOC}/galfact.spad.dvi ${DOC}/galfactu.spad.dvi ${DOC}/galpolyu.spad.dvi \
 ${DOC}/galutil.spad.dvi ${DOC}/gaussfac.spad.dvi ${DOC}/gaussian.spad.dvi \
 ${DOC}/gbeuclid.spad.dvi ${DOC}/gbintern.spad.dvi ${DOC}/gb.spad.dvi \
 ${DOC}/gdirprod.spad.dvi ${DOC}/gdpoly.spad.dvi ${DOC}/geneez.spad.dvi \
 ${DOC}/generic.spad.dvi ${DOC}/genufact.spad.dvi ${DOC}/genups.spad.dvi \
 ${DOC}/ghensel.spad.dvi ${DOC}/gpgcd.spad.dvi ${DOC}/gpol.spad.dvi \
 ${DOC}/grdef.spad.dvi ${DOC}/groebf.spad.dvi ${DOC}/groebsol.spad.dvi \
 ${DOC}/gseries.spad.dvi \
 ${DOC}/herm.as.dvi \
 ${DOC}/ideal.spad.dvi ${DOC}/idecomp.spad.dvi ${DOC}/indexedp.spad.dvi \
 ${DOC}/infprod.spad.dvi ${DOC}/intaf.spad.dvi ${DOC}/intalg.spad.dvi \
 ${DOC}/intaux.spad.dvi ${DOC}/intclos.spad.dvi ${DOC}/intef.spad.dvi \
 ${DOC}/integer.spad.dvi ${DOC}/integrat.spad.dvi \
 ${DOC}/interval.as.dvi ${DOC}/interval.spad.dvi \
 ${DOC}/intfact.spad.dvi ${DOC}/intpm.spad.dvi \
 ${DOC}/intrf.spad.dvi ${DOC}/invnode.as.dvi ${DOC}/invrender.as.dvi \
 ${DOC}/invtypes.as.dvi ${DOC}/invutils.as.dvi ${DOC}/irexpand.spad.dvi \
 ${DOC}/irsn.spad.dvi ${DOC}/ituple.spad.dvi ${DOC}/iviews.as.dvi \
 ${DOC}/kl.spad.dvi ${DOC}/kovacic.spad.dvi \
 ${DOC}/laplace.spad.dvi ${DOC}/laurent.spad.dvi ${DOC}/leadcdet.spad.dvi \
 ${DOC}/lie.spad.dvi ${DOC}/limitps.spad.dvi ${DOC}/lindep.spad.dvi \
 ${DOC}/lingrob.spad.dvi ${DOC}/liouv.spad.dvi ${DOC}/listgcd.spad.dvi \
 ${DOC}/list.spad.dvi ${DOC}/lmdict.spad.dvi ${DOC}/lodof.spad.dvi \
 ${DOC}/lodop.spad.dvi ${DOC}/lodo.spad.dvi \
 ${DOC}/manip.spad.dvi ${DOC}/mappkg.spad.dvi ${DOC}/matcat.spad.dvi \
 ${DOC}/matfuns.spad.dvi ${DOC}/matrix.spad.dvi ${DOC}/matstor.spad.dvi \
 ${DOC}/mesh.spad.dvi ${DOC}/mfinfact.spad.dvi ${DOC}/misc.spad.dvi \
 ${DOC}/mkfunc.spad.dvi ${DOC}/mkrecord.spad.dvi ${DOC}/mlift.spad.jhd.dvi \
 ${DOC}/mlift.spad.dvi ${DOC}/moddfact.spad.dvi ${DOC}/modgcd.spad.dvi \
 ${DOC}/modmonom.spad.dvi ${DOC}/modmon.spad.dvi ${DOC}/modring.spad.dvi \
 ${DOC}/moebius.spad.dvi ${DOC}/mring.spad.dvi ${DOC}/mset.spad.dvi \
 ${DOC}/mts.spad.dvi ${DOC}/multfact.spad.dvi ${DOC}/multpoly.spad.dvi \
 ${DOC}/multsqfr.spad.dvi \
 ${DOC}/naalgc.spad.dvi ${DOC}/naalg.spad.dvi ${DOC}/ndftip.as.dvi \
 ${DOC}/nepip.as.dvi ${DOC}/newdata.spad.dvi ${DOC}/newpoint.spad.dvi \
 ${DOC}/newpoly.spad.dvi ${DOC}/nlinsol.spad.dvi ${DOC}/nlode.spad.dvi \
 ${DOC}/noptip.as.dvi ${DOC}/npcoef.spad.dvi ${DOC}/nqip.as.dvi \
 ${DOC}/nrc.as.dvi ${DOC}/nregset.spad.dvi ${DOC}/nsfip.as.dvi \
 ${DOC}/nsregset.spad.dvi ${DOC}/numeigen.spad.dvi ${DOC}/numeric.spad.dvi \
 ${DOC}/numode.spad.dvi ${DOC}/numquad.spad.dvi ${DOC}/numsolve.spad.dvi \
 ${DOC}/numtheor.spad.dvi \
 ${DOC}/oct.spad.dvi ${DOC}/odealg.spad.dvi ${DOC}/odeef.spad.dvi \
 ${DOC}/oderf.spad.dvi ${DOC}/omcat.spad.dvi ${DOC}/omdev.spad.dvi \
 ${DOC}/omerror.spad.dvi ${DOC}/omserver.spad.dvi ${DOC}/opalg.spad.dvi \
 ${DOC}/openmath.spad.dvi ${DOC}/op.spad.dvi ${DOC}/ore.spad.dvi \
 ${DOC}/outform.spad.dvi ${DOC}/out.spad.dvi \
 ${DOC}/pade.spad.dvi ${DOC}/padiclib.spad.dvi ${DOC}/padic.spad.dvi \
 ${DOC}/paramete.spad.dvi ${DOC}/partperm.spad.dvi ${DOC}/patmatch1.spad.dvi \
 ${DOC}/patmatch2.spad.dvi ${DOC}/pattern.spad.dvi ${DOC}/pcurve.spad.dvi \
 ${DOC}/pdecomp.spad.dvi ${DOC}/perman.spad.dvi ${DOC}/permgrps.spad.dvi \
 ${DOC}/perm.spad.dvi ${DOC}/pfbr.spad.dvi ${DOC}/pfo.spad.dvi \
 ${DOC}/pfr.spad.dvi ${DOC}/pf.spad.dvi ${DOC}/pgcd.spad.dvi \
 ${DOC}/pgrobner.spad.dvi ${DOC}/pinterp.spad.dvi ${DOC}/pleqn.spad.dvi \
 ${DOC}/plot3d.spad.dvi ${DOC}/plot.spad.dvi ${DOC}/plottool.spad.dvi \
 ${DOC}/polset.spad.dvi ${DOC}/poltopol.spad.dvi ${DOC}/polycat.spad.dvi \
 ${DOC}/poly.spad.dvi ${DOC}/primelt.spad.dvi ${DOC}/print.spad.dvi \
 ${DOC}/product.spad.dvi ${DOC}/prs.spad.dvi ${DOC}/prtition.spad.dvi \
 ${DOC}/pscat.spad.dvi ${DOC}/pseudolin.spad.dvi ${DOC}/ptranfn.spad.dvi \
 ${DOC}/puiseux.spad.dvi \
 ${DOC}/qalgset.spad.dvi ${DOC}/quat.spad.dvi \
 ${DOC}/radeigen.spad.dvi ${DOC}/radix.spad.dvi ${DOC}/random.spad.dvi \
 ${DOC}/ratfact.spad.dvi ${DOC}/rdeef.spad.dvi ${DOC}/rderf.spad.dvi \
 ${DOC}/rdesys.spad.dvi ${DOC}/real0q.spad.dvi ${DOC}/realzero.spad.dvi \
 ${DOC}/reclos.spad.dvi ${DOC}/regset.spad.dvi ${DOC}/rep1.spad.dvi \
 ${DOC}/rep2.spad.dvi ${DOC}/resring.spad.dvi ${DOC}/retract.spad.dvi \
 ${DOC}/rf.spad.dvi ${DOC}/riccati.spad.dvi ${DOC}/rinterp.spad.dvi \
 ${DOC}/routines.spad.dvi \
 ${DOC}/rule.spad.dvi \
 ${DOC}/seg.spad.dvi ${DOC}/setorder.spad.dvi ${DOC}/sets.spad.dvi \
 ${DOC}/sex.spad.dvi ${DOC}/sf.spad.dvi ${DOC}/sgcf.spad.dvi \
 ${DOC}/sign.spad.dvi ${DOC}/si.spad.dvi ${DOC}/smith.spad.dvi \
 ${DOC}/solvedio.spad.dvi ${DOC}/solvefor.spad.dvi ${DOC}/solvelin.spad.dvi \
 ${DOC}/solverad.spad.dvi ${DOC}/sortpak.spad.dvi ${DOC}/space.spad.dvi \
 ${DOC}/special.spad.dvi ${DOC}/sregset.spad.dvi ${DOC}/s.spad.dvi \
 ${DOC}/stream.spad.dvi ${DOC}/string.spad.dvi ${DOC}/sttaylor.spad.dvi \
 ${DOC}/sttf.spad.dvi ${DOC}/sturm.spad.dvi ${DOC}/suchthat.spad.dvi \
 ${DOC}/suls.spad.dvi ${DOC}/sum.spad.dvi ${DOC}/sups.spad.dvi \
 ${DOC}/supxs.spad.dvi ${DOC}/suts.spad.dvi ${DOC}/symbol.spad.dvi \
 ${DOC}/syssolp.spad.dvi ${DOC}/system.spad.dvi \
 ${DOC}/tableau.spad.dvi ${DOC}/table.spad.dvi ${DOC}/taylor.spad.dvi \
 ${DOC}/tex.spad.dvi ${DOC}/tools.spad.dvi ${DOC}/transsolve.spad.dvi \
 ${DOC}/tree.spad.dvi ${DOC}/trigcat.spad.dvi ${DOC}/triset.spad.dvi \
 ${DOC}/tube.spad.dvi ${DOC}/twofact.spad.dvi \
 ${DOC}/unifact.spad.dvi ${DOC}/updecomp.spad.dvi ${DOC}/updivp.spad.dvi \
 ${DOC}/utsode.spad.dvi \
 ${DOC}/variable.spad.dvi ${DOC}/vector.spad.dvi ${DOC}/view2D.spad.dvi \
 ${DOC}/view3D.spad.dvi ${DOC}/viewDef.spad.dvi ${DOC}/viewpack.spad.dvi \
 ${DOC}/void.spad.dvi \
 ${DOC}/weier.spad.dvi ${DOC}/wtpol.spad.dvi \
 ${DOC}/xlpoly.spad.dvi ${DOC}/xpoly.spad.dvi \
 ${DOC}/ystream.spad.dvi \
 ${DOC}/zerodim.spad.dvi

@
\section{Test Cases}
<<environment>>=

TESTS=${INPUT}/INTHEORY.input ${INPUT}/VIEW2D.input ${INPUT}/TESTFR.input

@
<<testrules>>=

${INPUT}/TESTFR.input: $(srcdir)/fr.spad.pamphlet
	$(axiom_build_document) --tangle='TEST FR' --output=$@ $<

${INPUT}/INTHEORY.input: $(srcdir)/numtheor.spad.pamphlet
	$(axiom_build_document) --tangle='TEST INTHEORY' --output=$@ $<

${INPUT}/VIEW2D.input: $(srcdir)/view2D.spad.pamphlet
	$(axiom_build_document) --tangle='TEST VIEW2D' --output=$@ $<

@
\section{The Makefile Stanzas}
A [[spad]] pamphlet can contain many Axiom [[categories]], [[domains]], and
[[packages]]. 

For the purpose of explanation we assume that the pamphlet file is 
named [[foo.spad.pamphlet]]. It contains the domains [[BAR]], [[BAX]],
and [[BAZ]]. Thus there will be a subsection named [[foo.spad]].

Since pamphlet files (e.g. [[foo.spad.pamphlet]] contain a spad file
e.g. [[foo.spad]], it follows that every subsection contains a Makefile
stanza that extract the [[foo.spad]] file using [[notangle]].

Since pamphlet files are intended as documents it follows that each
subsection contains a Makefile stanza that extracts a [[dvi]] file
using [[noweave]].

We could have a category, domain, or package that is in
the ``bootstrap'' list. Bootstrap spad files contain their generated
lisp code in special sections. The way bootstrapping works is that
we extract the lisp code and compile it rather than extracting the
spad code. We do this because we need the domain to exist before we
can compile the domain. Some domains depend on themselves directly.
Some domains depend on themselves thru a long chain of other domains.
In either case we can't compile the domain until it exists so we
cache the generated lisp code and, when we need to bootstrap the
domain, we compile the raw lisp rather than the spad.

This will only happen when the system is built from scratch. Once
the system has been built the bootstrap code is no longer executed
and these algebra files will appear as normal algebra files. That
means that once the system has been built once only the last three
rules will ever be executed. The first two rules happen when the
system is built from scratch.

A 5 stanza group for this case performs the following functions:
\begin{enumerate}
\item extract the lisp [[BAR.lsp]] from the pamphlet [[foo.spad.pamphlet]]
\item compile and copy the bootstrap lisp to the final algebra directory
\item extract the bootstrap [[BAR.lsp]] from the spad file [[foo.spad]]
\item compile the extracted [[BAR]] domain
\item copy the compiled [[BAR]] to the final algebra directory
\end{enumerate}

The subtle point here occurs in the first item. The bootstrap code
group (in the [[layer0 bootstrap]] code chunk above) asks for the
compiled [[.o]] files in the [[\${MID}]] directory. Essentially this
code group calls for intermediate compiled files. This triggers the
bootstrap stanzas (items 1 and 2 above). All of the other layer 
chunks ask for compiled code in the [[\${OUT}]] directory which is
the final algebra directory. 

The bootstrap process works because first we ask for the compiled
lisp code stanzas (the [[\${MID}/BAR.o]] files), THEN we ask for
the final algebra code stanzas (the [[\${OUT}/BAR.o]] files). This
is a very subtle point so think it through carefully. The layer0
bootstrap list is the only file list that calls for [[\${MID}]] files.
All other layers ask for [[\${OUT}]] files. Make sure you
understand this before you change things. If you break it the
world will no longer compile.

So we have a 3 stanza group for normal files, a 3+2 (5) stanza
group for normal files with default code, and a 3+2 (5) stanza
group for normal files that need to be bootstrapped. There is
another combination that occurs, namely bootstrap code that
also contains default code which gives a 3+2+2+2 (9) stanza case.
(see TSETCAT for an example. Be sure to read the items in reverse order).

A 9 stanza group for this case performs the following functions:
\begin{enumerate}
\item extract the bootstrap [[BAR.lsp]] from the [[foo.spad.pamphlet]]
\item compile the bootstrap [[BAR.lsp]] and copy to the intermediate directory
\item extract the bootstrap [[BAR-.lsp]] from the [[foo.spad.pamphlet]]
\item compile the bootstrap [[BAR-.lsp]] and copy to intermediate directory
\item extract the spad [[BAR.spad]] from the pamphlet [[foo.spad.pamphlet]]
\item compile the extracted [[BAR.spad]] domain (to get [[BAR.o]])
\item copy the [[BAR.o]] to the final algebra directory
\item compile the extracted [[BAR.spad]] domain (to get [[BAR-.o]])
\item copy the [[BAR-.o]] to the final algebra directory
\end{enumerate}

As you can see this is just the combination of the two possible 5
stanza case. We just have to deal with the [[BAR-]] both in regular
and bootstrap files. The first four stanzas will only happen when
the system is built from scratch. Once the system is built these
four rules no longer apply and these stanzas effectively act like
the 5 stanza rules above.

I'm sure all of this seems confusing but it is very stylized code.
Basically you need to figure out which kind of stanza group you need,
copy an existing stanza group, and do a correct renaming of the parts.
The decision tree looks something like:
\begin{verbatim}
IF (you have a regular spad domain)
 THEN use a 3 stanza form (see YSTREAM)
IF (you have a default spad domain (it generates [[-]] files)) AND
   (it does not require bootstrapping)
 THEN use the first 5 stanza form explained above (see LIECAT)
IF (you have a normal spad domain) AND
   (it requires bootstrapping)
 THEN use the second 5 stanza form explained above (see VECTOR)
IF (you have a default spad domain (it generates [[-]] files)) AND
   (it requires bootstrapping)
 THEN use the 9 stanza form explained above (see TSETCAT)
\end{verbatim}

\section{Generic Make Rules}
The idea is to use generic rules to try to cut down the size of this file.

This Makefile works very hard to cache
intermediate results in order to minimize the re-build time. The cached
files are kept in the [[int]] or [[obj]] directories. If one of these
files disappears but the original pamphlet file is unchanged we only
need to rebuild the intermediate file. These rule will attempt to do
that and they succeed however these are intermediate files created by
implicit rules so they would normally be deleted. To prevent the removal
the NRLIB directory and its contents, the files are marked as .PRECIOUS.

The output of the compile step is saved in a file of the same name
and extension .out in the \${MID} directory. These files are useful for
deriving the dependencies by scanning the ``Loading ...'' messages.

<<genericDotOfiles>>=

${OUT}/%.$(FASLEXT): ${MID}/%.NRLIB/code.$(FASLEXT)
	cp ${MID}/$*.NRLIB/code.$(FASLEXT) $@

@ 
<<genericNRLIBfiles>>=

.PRECIOUS: ${MID}/%.NRLIB/code.$(FASLEXT)
${MID}/%.NRLIB/code.$(FASLEXT): ${MID}/%.spad
	@ echo compiling $*.spad to $*.NRLIB
	rm -rf ${MID}/$*.NRLIB
	(cd ${MID} ; \
	     echo ')co $*.spad' | ${INTERPSYS} >> ${TMP}/trace ; \
	   )

@

<<genericSPADfiles>>=

$(OUTSRC)/%.spad: $(OUTSRC)

${OUTSRC}/%.spad: $(srcdir)/%.spad.pamphlet
	@ echo tangling $< to $@
	@ $(axiom_build_document) --tangle --output=$@ $<

$(OUTSRC):
	$(mkinstalldirs) $@

@
<<genericDOCfiles>>=
.PRECIOUS: $(builddir)/%.tex
.PRECIOUS: $(builddir)/%.dvi

$(DOC)/%.dvi:  $(DOC)

$(DOC):
	$(mkinstalldirs) $@	      

$(DOC)/%.dvi: $(builddir)/%.dvi
	$(INSTALL_DATA) $< $@

$(builddir)/%.dvi: $(axiom_build_texdir)/diagrams.tex \
		   $(axiom_build_texdir)/axiom.sty

$(builddir)/%.dvi: $(builddir)/%.tex
	$(axiom_build_document) --latex $< $(SINK_NOISE)

$(builddir)/%.tex: $(srcdir)/%.pamphlet
	$(axiom_build_document) --weave --output=$@ $<

$(axiom_build_texdir)/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	$(INSTALL_DATA) $< $@
@
<<genericRules>>=

<<genericDotOfiles>>
<<genericNRLIBfiles>>
<<genericSPADfiles>>
<<genericDOCfiles>>

@

\section{Pamphlet file structure}
Because the individual .spad files are grouped into higher-level
algebra pamphlet files, the rules for extracting them are coded
below as simple ``awk'' scripts that are called when the Makefile
is constructed.

<<findAlgebraFiles>>=

<<findSpadFiles>>
@

There are, at present, 3 kinds of algebra files to be handled.
First we have [[.as]] files which use the [[aldor]] compiler.
These are ignored here as the compiler is not yet integrated.

Second, there are the bootstrap files. These files live within
their respective pamphlet files and are "captured" lisp code.
These are necessary to create the algebra. See the 
[[src/algebra/Makefile.pamphlet]] for details.

Third, there are 3 "types" of algebra which are all treated 
the same at compile time, namely the "domain", "category", and
"package" algebra.

\subsection{Finding the algebra code}
Step 1 is to scan all of the algebra pamphlet files for the
chunk names which contain the string "domain", "package", or
"category". This is done using egrep (same as grep -E, which
means that the pattern is an extended regular expression) because
extended regular expressions allows the use of alternatives
written as (domain|package|category). Thus the command
\begin{verbatim}
 egrep '@<<(domain|package|category) .*>>=' *.spad.pamphlet 
\end{verbatim}
will scan the algebra files looking for special chunknames.
Axiom's chunk names are written in a stylized form so that each
algebra chunk name begins with one of those three symbols. Thus 
in zerodim.spad.pamphlet the LexTriangularPackage chunkname is:
\begin{verbatim}
@<<package LEXTRIPK LexTriangularPackage>>
\end{verbatim}
so this egrep will generate an output line, prefixed by the filename
that looks like:
\begin{verbatim}
zerodim.spad.pamphlet:@<<package LEXTRIPK LexTriangularPackage>>=
\end{verbatim}
There can be many lines of output per pamphlet file, one for
each domain, package and category cod chunk contained in the file.

Step 2 is an [[awk]] command line.

\subsection{Write the Makefile stanzas for the algebra files}

<<findSpadFiles>>=

egrep '@<<(domain|package|category) .*>>=' *.spad.pamphlet | sort | uniq | \
awk -F: '{
  chunk=substr($2,3,length($2)-5);
  split(chunk,part," ");
  spadfile="${MID}/"part[2]".spad";
  print spadfile": $(srcdir)/"$1;
  print "\t@${TANGLE} -R\""chunk"\" $(srcdir)/"$1">"spadfile;
  print "";
}'

@
[awk] processes each line of the [[egrep]] output. 

The awk script uses [[-F:]] which is a flag that says that a [[:]] is
the field separator. As a result the \$1 and \$2 in the awk script
refer to the parts of the egrep output that come before and after the
[[:]] respectively.

The variable [[chunk]] is assigned the actual chunk name minus
the @<< and >>= delimiters. In the example given above this will become
\begin{verbatim}
package LEXTRIPK LexTriangularPackage
\end{verbatim}
The call to [[split]] splits the chunk into parts separated
by spaces. Thus
\begin{verbatim}
  part[1]=package
  part[2]=LEXTRIPK
  part[3]=LexTriangularPackage
\end{verbatim}
The variable [[spadfile]] in the above example is set to
\begin{verbatim}
${MID}/LEXTRIPK.spad
\end{verbatim}
Finally, in the domain example given above we print two lines.
The first line is the Makefile stanza header which depends on the
original [[zerodim.spad.pamphlet]] file.

The second line is the body of the makefile stanza which calls 
notangle to extract the algebra from the original pamphlet using
the chunk name and writes it to the intermediate subdirectory. In
the case above this would resolve to [[\${MID}/LEXTRIPK.spad]].

For the line given above it outputs the following:
\begin{verbatim}
${MID}/LEXTRIPK.spad: $(srcdir)/zerodim.spad.pamphlet
	$(axiom_build_document) --tangle='package LEXTRIPK LexTriangularPackage' --output=$@ $<
\end{verbatim}


\section{The Makefile}

<<*>>=

<<environment>>

subdir = src/algebra/


<<bootstrap variables>>
<<USERLAYER>>

# The algebra build is not yet ready for parallel build.
.NOTPARALLEL:

.PHONY: all all-algebra
all: all-ax

all-ax all-algebra: stamp
	@ echo finished $(builddir)

<<layer0 bootstrap>>

guess-pkg: $(patsubst %, ${MID}/%.spad, ${GUESSLIST}) stamp-src
	(cd ${MID} && \
	  { for A in ${GUESSLIST}; do \
	        echo ')compile "'$$A'.spad"' ; \
	    done | ${INTERPSYS} ${CTRACE} ; \
	    for A in ${GUESSLIST}; do \
	        cp $$A.NRLIB/code.$(FASLEXT) ${OUT}/$$A.$(FASLEXT) || exit 1 ; \
	    done ; \
          } \
	)
	touch guess-pkg

stamp: $(OUTSRC) stamp-src guess-pkg ${TESTS}
	-rm -f stamp
	$(STAMP) stamp

everything: check lib db cmd gloss
	@ echo 4303 invoking make in `pwd` with parms:
	@ echo SYS= ${SYS} LSP= ${LSP} PART= ${PART} SUBPART= ${SUBPART}
	@ echo SPAD= ${SPAD} SRC= ${SRC} INT= ${INT}
	@ echo MNT= ${MNT} LISP=${LISP} BYE=${BYE}

stamp-src:	${SPADFILES} stamp-bootstrap $(patsubst %, ${OUT}/%.$(FASLEXT), ${SPADLIST})
	@ echo 4304 Done building NRLIBS from spad sources
	touch stamp-src

check:
	@ echo 4305 Checking that INTERP.EXPOSED and NRLIBs are consistent
	@ echo 4306 libcheck needs to use exposed.lsp, not INTERP.EXPOSED


<<genericRules>>

<<testrules>>


$(MID):
	$(mkinstalldirs) $@

mostlyclean-local: ;

clean-local: mostlyclean-local

distclean-local: clean-local

include $(builddir)/more-rules.mk

.NOTPARALLEL:

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
