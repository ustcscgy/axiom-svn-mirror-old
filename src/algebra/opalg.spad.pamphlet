\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra opalg.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain MODOP ModuleOperator}
<<domain MODOP ModuleOperator>>=
)abbrev domain MODOP ModuleOperator
++ Author: Manuel Bronstein
++ Date Created: 15 May 1990
++ Date Last Updated: 17 June 1993
++ Description:
++ Algebra of ADDITIVE operators on a module.
ModuleOperator(R: Ring, M:LeftModule(R)): Exports == Implementation where
  O    ==> OutputForm
  OP   ==> BasicOperator
  FG   ==> FreeGroup OP
  RM   ==> Record(coef:R, monom:FG)
  TERM ==> List RM
  FAB  ==> FreeAbelianGroup TERM
  OPADJ   ==> "%opAdjoint"
  OPEVAL  ==> "%opEval"
  INVEVAL ==> "%invEval"

  Exports ==> Join(Ring, RetractableTo R, RetractableTo OP,
                   Eltable(M, M)) with
    if R has CharacteristicZero then CharacteristicZero
    if R has CharacteristicNonZero then CharacteristicNonZero
    if R has CommutativeRing then
      Algebra(R)
      adjoint: $ -> $
        ++ adjoint(op) returns the adjoint of the operator \spad{op}.
      adjoint: ($, $) -> $
        ++ adjoint(op1, op2) sets the adjoint of op1 to be op2.
        ++ op1 must be a basic operator
      conjug  : R -> R
        ++ conjug(x)should be local but conditional
    evaluate: ($, M -> M) -> $
      ++ evaluate(f, u +-> g u) attaches the map g to f.
      ++ f must be a basic operator
      ++ g MUST be additive, i.e. \spad{g(a + b) = g(a) + g(b)} for
      ++ any \spad{a}, \spad{b} in M.
      ++ This implies that \spad{g(n a) = n g(a)} for
      ++ any \spad{a} in M and integer \spad{n > 0}.
    evaluateInverse: ($, M -> M) -> $
	++ evaluateInverse(x,f) \undocumented
    "**": (OP, Integer) -> $
	++ op**n \undocumented
    "**": ($, Integer) -> $
	++ op**n \undocumented
    opeval  : (OP, M) -> M
      ++ opeval should be local but conditional
    makeop   : (R, FG) -> $
      ++ makeop should be local but conditional

  Implementation ==> FAB add
    import NoneFunctions1($)
    import BasicOperatorFunctions1(M)

    Rep := FAB

    inv      : TERM -> $
    termeval : (TERM, M) -> M
    rmeval   : (RM, M) -> M
    monomeval: (FG, M) -> M
    opInvEval: (OP, M) -> M
    mkop     : (R, FG) -> $
    termprod0: (Integer, TERM, TERM) -> $
    termprod : (Integer, TERM, TERM) -> TERM
    termcopy : TERM -> TERM
    trm2O    : (Integer, TERM) -> O
    term2O   : TERM -> O
    rm2O     : (R, FG) -> O
    nocopy   : OP -> $

    1                   == makeop(1, 1)
    coerce(n:Integer):$ == n::R::$
    coerce(r:R):$       == (zero? r => 0; makeop(r, 1))
    coerce(op:OP):$     == nocopy copy op
    nocopy(op:OP):$     == makeop(1, op::FG)
    elt(x:$, r:M)       == +/[t.exp * termeval(t.gen, r) for t in terms x]
    rmeval(t, r)        == t.coef * monomeval(t.monom, r)
    termcopy t          == [[rm.coef, rm.monom] for rm in t]
    characteristic()    == characteristic()$R
    mkop(r, fg)         == [[r, fg]$RM]$TERM :: $
    evaluate(f, g)   == nocopy setProperty(retract(f)@OP,OPEVAL,g pretend None)

    if R has OrderedSet then
      makeop(r, fg) == (r >= 0 => mkop(r, fg); - mkop(-r, fg))
    else makeop(r, fg) == mkop(r, fg)

    inv(t:TERM):$ ==
      empty? t => 1
      c := first(t).coef
      m := first(t).monom
      inv(rest t) * makeop(1, inv m) * (recip(c)::R::$)

    x:$ ** i:Integer ==
      i = 0 => 1
      i > 0 => expt(x,i pretend PositiveInteger)$RepeatedSquaring($)
      (inv(retract(x)@TERM)) ** (-i)

    evaluateInverse(f, g) ==
      nocopy setProperty(retract(f)@OP, INVEVAL, g pretend None)

    coerce(x:$):O ==
      zero? x => (0$R)::O
      reduce(_+, [trm2O(t.exp, t.gen) for t in terms x])$List(O)

    trm2O(c, t) ==
--      one? c => term2O t
      (c = 1) => term2O t
      c = -1 => - term2O t
      c::O * term2O t

    term2O t ==
      reduce(_*, [rm2O(rm.coef, rm.monom) for rm in t])$List(O)

    rm2O(c, m) ==
--      one? c => m::O
      (c = 1) => m::O
--      one? m => c::O
      (m = 1) => c::O
      c::O * m::O

    x:$ * y:$ ==
      +/[ +/[termprod0(t.exp * s.exp, t.gen, s.gen) for s in terms y]
          for t in terms x]

    termprod0(n, x, y) ==
      n >= 0 => termprod(n, x, y)::$
      - (termprod(-n, x, y)::$)

    termprod(n, x, y) ==
      lc := first(xx := termcopy x)
      lc.coef := n * lc.coef
      rm := last xx
--      one?(first(y).coef) =>
      ((first(y).coef) = 1) =>
        rm.monom := rm.monom * first(y).monom
        concat_!(xx, termcopy rest y)
--      one?(rm.monom) =>
      ((rm.monom) = 1) =>
        rm.coef := rm.coef * first(y).coef
        rm.monom := first(y).monom
        concat_!(xx, termcopy rest y)
      concat_!(xx, termcopy y)

    if M has ExpressionSpace then
      opeval(op, r) ==
        (func := property(op, OPEVAL)) case "failed" => kernel(op, r)
        ((func::None) pretend (M -> M)) r

    else
      opeval(op, r) ==
        (func := property(op, OPEVAL)) case "failed" =>
          error "eval: operator has no evaluation function"
        ((func::None) pretend (M -> M)) r

    opInvEval(op, r) ==
      (func := property(op, INVEVAL)) case "failed" =>
         error "eval: operator has no inverse evaluation function"
      ((func::None) pretend (M -> M)) r

    termeval(t, r)  ==
      for rm in reverse t repeat r := rmeval(rm, r)
      r

    monomeval(m, r) ==
      for rec in reverse_! factors m repeat
        e := rec.exp
        g := rec.gen
        e > 0 =>
          for i in 1..e repeat r := opeval(g, r)
        e < 0 =>
          for i in 1..(-e) repeat r := opInvEval(g, r)
      r

    recip x ==
      (r := retractIfCan(x)@Union(R, "failed")) case "failed" => "failed"
      (r1 := recip(r::R)) case "failed" => "failed"
      r1::R::$

    retractIfCan(x:$):Union(R, "failed") ==
      (r:= retractIfCan(x)@Union(TERM,"failed")) case "failed" => "failed"
      empty?(t := r::TERM) => 0$R
      empty? rest t =>
        rm := first t
--        one?(rm.monom) => rm.coef
        (rm.monom = 1) => rm.coef
        "failed"
      "failed"

    retractIfCan(x:$):Union(OP, "failed") ==
      (r:= retractIfCan(x)@Union(TERM,"failed")) case "failed" => "failed"
      empty?(t := r::TERM) => "failed"
      empty? rest t =>
        rm := first t
--        one?(rm.coef) => retractIfCan(rm.monom)
        (rm.coef = 1) => retractIfCan(rm.monom)
        "failed"
      "failed"

    if R has CommutativeRing then
      termadj  : TERM -> $
      rmadj    : RM -> $
      monomadj : FG -> $
      opadj    : OP -> $

      r:R * x:$        == r::$ * x
      x:$ * r:R        == x * (r::$)
      adjoint x        == +/[t.exp * termadj(t.gen) for t in terms x]
      rmadj t          == conjug(t.coef) * monomadj(t.monom)
      adjoint(op, adj) == nocopy setProperty(retract(op)@OP, OPADJ, adj::None)

      termadj t ==
        ans:$ := 1
        for rm in t repeat ans := rmadj(rm) * ans
        ans

      monomadj m ==
        ans:$ := 1
        for rec in factors m repeat ans := (opadj(rec.gen) ** rec.exp) * ans
        ans

      opadj op ==
        (adj := property(op, OPADJ)) case "failed" =>
           error "adjoint: operator does not have a defined adjoint"
        (adj::None) pretend $

      if R has conjugate:R -> R then conjug r == conjugate r else conjug r == r

@
\section{domain OP Operator}
<<Operator.input>>=
-- opalg.spad.pamphlet Operator.input
)spool Operator.output
)set message test on
)set message auto off
)clear all
--S 1 of 21
R := SQMATRIX(2, INT)
--R 
--R
--R   (1)  SquareMatrix(2,Integer)
--R                                                                 Type: Domain
--E 1

--S 2 of 21
t := operator("tilde") :: OP(R)
--R 
--R
--R   (2)  tilde
--R                                       Type: Operator SquareMatrix(2,Integer)
--E 2

--S 3 of 21
)set expose add constructor Operator
--R 
--R   Operator is now explicitly exposed in frame frame0 
--E 3

--S 4 of 21
evaluate(t, m +-> transpose m)
--R 
--R
--R   (3)  tilde
--R                                       Type: Operator SquareMatrix(2,Integer)
--E 4

--S 5 of 21
s : R := matrix [ [0, 1], [1, 0] ]
--R 
--R
--R        +0  1+
--R   (4)  |    |
--R        +1  0+
--R                                                Type: SquareMatrix(2,Integer)
--E 5

--S 6 of 21
rho := t * s
--R 
--R
--R             +0  1+
--R   (5)  tilde|    |
--R             +1  0+
--R                                       Type: Operator SquareMatrix(2,Integer)
--E 6

--S 7 of 21
z := rho**4 - 1
--R 
--R
--R                   +0  1+     +0  1+     +0  1+     +0  1+
--R   (6)  - 1 + tilde|    |tilde|    |tilde|    |tilde|    |
--R                   +1  0+     +1  0+     +1  0+     +1  0+
--R                                       Type: Operator SquareMatrix(2,Integer)
--E 7

--S 8 of 21
m:R := matrix [ [1, 2], [3, 4] ]
--R 
--R
--R        +1  2+
--R   (7)  |    |
--R        +3  4+
--R                                                Type: SquareMatrix(2,Integer)
--E 8

--S 9 of 21
z m
--R 
--R
--R        +0  0+
--R   (8)  |    |
--R        +0  0+
--R                                                Type: SquareMatrix(2,Integer)
--E 9

--S 10 of 21
rho m
--R 
--R
--R        +3  1+
--R   (9)  |    |
--R        +4  2+
--R                                                Type: SquareMatrix(2,Integer)
--E 10

--S 11 of 21
rho rho m
--R 
--R
--R         +4  3+
--R   (10)  |    |
--R         +2  1+
--R                                                Type: SquareMatrix(2,Integer)
--E 11

--S 12 of 21
(rho^3) m
--R 
--R
--R         +2  4+
--R   (11)  |    |
--R         +1  3+
--R                                                Type: SquareMatrix(2,Integer)
--E 12

--S 13 of 21
b := t * s - s * t
--R 
--R
--R           +0  1+             +0  1+
--R   (12)  - |    |tilde + tilde|    |
--R           +1  0+             +1  0+
--R                                       Type: Operator SquareMatrix(2,Integer)
--E 13

--S 14 of 21
b m
--R 
--R
--R         +1  - 3+
--R   (13)  |      |
--R         +3  - 1+
--R                                                Type: SquareMatrix(2,Integer)
--E 14

--S 15 of 21
L n ==
  n = 0 => 1
  n = 1 => x
  (2*n-1)/n * x * L(n-1) - (n-1)/n * L(n-2)
--R 
--R                                                                   Type: Void
--E 15

--S 16 of 21
dx := operator("D") :: OP(POLY FRAC INT)
--R 
--R
--R   (15)  D
--R                                   Type: Operator Polynomial Fraction Integer
--E 16

--S 17 of 21
evaluate(dx, p +-> D(p, 'x))
--R 
--R
--R   (16)  D
--R                                   Type: Operator Polynomial Fraction Integer
--E 17

--S 18 of 21
E n == (1 - x**2) * dx**2 - 2 * x * dx + n*(n+1)
--R 
--R                                                                   Type: Void
--E 18

--S 19 of 21
L 15
--R 
--R   Compiling function L with type Integer -> Polynomial Fraction 
--R      Integer 
--R   Compiling function L as a recurrence relation.
--R
--R   (18)
--R     9694845  15   35102025  13   50702925  11   37182145  9   14549535  7
--R     ------- x   - -------- x   + -------- x   - -------- x  + -------- x
--R       2048          2048           2048           2048          2048
--R   + 
--R       2909907  5   255255  3   6435
--R     - ------- x  + ------ x  - ---- x
--R         2048        2048       2048
--R                                            Type: Polynomial Fraction Integer
--E 19

--S 20 of 21
E 15
--R 
--R   Compiling function E with type PositiveInteger -> Operator 
--R      Polynomial Fraction Integer 
--R
--R                        2      2
--R   (19)  240 - 2x D - (x  - 1)D
--R                                   Type: Operator Polynomial Fraction Integer
--E 20

--S 21 of 21
(E 15)(L 15)
--R 
--R
--R   (20)  0
--R                                            Type: Polynomial Fraction Integer
--E 21
)spool
)lisp (bye)
@
<<Operator.help>>=
====================================================================
Operator examples
====================================================================

Given any ring R, the ring of the Integer-linear operators over R is
called Operator(R).  To create an operator over R, first create a
basic operator using the operation operator, and then convert it to
Operator(R) for the R you want.

We choose R to be the two by two matrices over the integers.

  R := SQMATRIX(2, INT)
    SquareMatrix(2,Integer)
                            Type: Domain

Create the operator tilde on R.

  t := operator("tilde") :: OP(R)
    tilde
                            Type: Operator SquareMatrix(2,Integer)

Since Operator is unexposed we must either package-call operations
from it, or expose it explicitly.  For convenience we will do the latter.

Expose Operator.

  )set expose add constructor Operator

To attach an evaluation function (from R to R) to an operator over R,
use evaluate(op, f) where op is an operator over R and f is a function
R -> R.  This needs to be done only once when the operator is defined.
Note that f must be Integer-linear (that is, f(ax+y) = a f(x) + f(y)
for any integer a, and any x and y in R).

We now attach the transpose map to the above operator t.

  evaluate(t, m +-> transpose m)
    tilde
                       Type: Operator SquareMatrix(2,Integer)

Operators can be manipulated formally as in any ring: + is the
pointwise addition and * is composition.  Any element x of R can be
converted to an operator op(x) over R, and the evaluation function of
op(x) is left-multiplication by x.

Multiplying on the left by this matrix swaps the two rows.

  s : R := matrix [ [0, 1], [1, 0] ]
        +0  1+
        |    |
        +1  0+
                       Type: SquareMatrix(2,Integer)

Can you guess what is the action of the following operator?

  rho := t * s
             +0  1+
        tilde|    |
             +1  0+
                       Type: Operator SquareMatrix(2,Integer)

Hint: applying rho four times gives the identity, so rho^4-1 should
return 0 when applied to any two by two matrix.

  z := rho**4 - 1
                   +0  1+     +0  1+     +0  1+     +0  1+
        - 1 + tilde|    |tilde|    |tilde|    |tilde|    |
                   +1  0+     +1  0+     +1  0+     +1  0+
                       Type: Operator SquareMatrix(2,Integer)

Now check with this matrix.

  m:R := matrix [ [1, 2], [3, 4] ]
        +1  2+
        |    |
        +3  4+
                       Type: SquareMatrix(2,Integer)

  z m
        +0  0+
        |    |
        +0  0+
                       Type: SquareMatrix(2,Integer)

As you have probably guessed by now, rho acts on matrices by rotating
the elements clockwise.

  rho m
        +3  1+
        |    |
        +4  2+
                       Type: SquareMatrix(2,Integer)

  rho rho m
         +4  3+
         |    |
         +2  1+
                       Type: SquareMatrix(2,Integer)

  (rho^3) m
         +2  4+
         |    |
         +1  3+
                       Type: SquareMatrix(2,Integer)

Do the swapping of rows and transposition commute?  We can check by
computing their bracket.

  b := t * s - s * t
           +0  1+             +0  1+
         - |    |tilde + tilde|    |
           +1  0+             +1  0+
                       Type: Operator SquareMatrix(2,Integer)

Now apply it to m.

  b m
         +1  - 3+
         |      |
         +3  - 1+
                       Type: SquareMatrix(2,Integer)
 
Next we demonstrate how to define a differential operator on a polynomial ring.

This is the recursive definition of the n-th Legendre polynomial.

  L n ==
    n = 0 => 1
    n = 1 => x
    (2*n-1)/n * x * L(n-1) - (n-1)/n * L(n-2)
                        Type: Void

Create the differential operator d/dx on polynomials in x over the
rational numbers.

  dx := operator("D") :: OP(POLY FRAC INT)
     D
                        Type: Operator Polynomial Fraction Integer

Now attach the map to it.

  evaluate(dx, p +-> D(p, 'x))
    D
                        Type: Operator Polynomial Fraction Integer

This is the differential equation satisfied by the n-th Legendre polynomial.

  E n == (1 - x**2) * dx**2 - 2 * x * dx + n*(n+1)
                        Type: Void

Now we verify this for n = 15.  Here is the polynomial.

  L 15
     9694845  15   35102025  13   50702925  11   37182145  9   14549535  7
     ------- x   - -------- x   + -------- x   - -------- x  + -------- x
       2048          2048           2048           2048          2048
   + 
       2909907  5   255255  3   6435
     - ------- x  + ------ x  - ---- x
         2048        2048       2048
                        Type: Polynomial Fraction Integer

Here is the operator.

  E 15
    240 - 2x D - (x  - 1)D
                        Type: Operator Polynomial Fraction Integer

Here is the evaluation.

  (E 15)(L 15)
    0
                        Type: Polynomial Fraction Integer

See Also:
o )show Operator
o $AXIOM/doc/src/algebra/opalg.spad.dvi

@
<<domain OP Operator>>=
)abbrev domain OP Operator
++ Author: Manuel Bronstein
++ Date Created: 15 May 1990
++ Date Last Updated: 12 February 1993
++ Description:
++ Algebra of ADDITIVE operators over a ring.
Operator(R: Ring) == ModuleOperator(R,R)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain MODOP ModuleOperator>>
<<domain OP Operator>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
