\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra special.spad}
\author{Bruce W. Char, Timothy Daly, Stephen M. Watt}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package DFSFUN DoubleFloatSpecialFunctions}
<<package DFSFUN DoubleFloatSpecialFunctions>>=
)abbrev package DFSFUN DoubleFloatSpecialFunctions
++ Author: Bruce W. Char, Timothy Daly, Stephen M. Watt
++ Date Created:  1990
++ Date Last Updated: Jan 19, 2008
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This package provides special functions for double precision
++   real and complex floating point.

DoubleFloatSpecialFunctions(): Exports == Impl where
    NNI ==> NonNegativeInteger
    R   ==> DoubleFloat
    C   ==> Complex DoubleFloat
    OPR ==> OnePointCompletion R

    Exports ==> with
        Gamma: R -> R
         ++ Gamma(x) is the Euler gamma function, \spad{Gamma(x)}, defined by
         ++   \spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..%infinity)}.
        Gamma: C -> C
         ++ Gamma(x) is the Euler gamma function, \spad{Gamma(x)}, defined by
         ++   \spad{Gamma(x) = integrate(t^(x-1)*exp(-t), t=0..%infinity)}.

        E1: R -> OPR
	 ++ E1(x) is the Exponential Integral function
         ++ The current implementation is a piecewise approximation
         ++ involving one poly from -4..4 and a second poly for x > 4

        Beta: (R, R) -> R
         ++ Beta(x, y) is the Euler beta function, \spad{B(x,y)}, defined by
         ++   \spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.
         ++ This is related to \spad{Gamma(x)} by
         ++   \spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.
        Beta: (C, C) -> C
         ++ Beta(x, y) is the Euler beta function, \spad{B(x,y)}, defined by
         ++   \spad{Beta(x,y) = integrate(t^(x-1)*(1-t)^(y-1), t=0..1)}.
         ++ This is related to \spad{Gamma(x)} by
         ++   \spad{Beta(x,y) = Gamma(x)*Gamma(y) / Gamma(x + y)}.

        logGamma: R -> R
         ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
         ++ This can often be computed even if \spad{Gamma(x)} cannot.
        logGamma: C -> C
         ++ logGamma(x) is the natural log of \spad{Gamma(x)}.
         ++ This can often be computed even if \spad{Gamma(x)} cannot.

        digamma: R -> R
         ++ digamma(x) is the function, \spad{psi(x)}, defined by
         ++   \spad{psi(x) = Gamma'(x)/Gamma(x)}.
        digamma: C -> C
         ++ digamma(x) is the function, \spad{psi(x)}, defined by
         ++   \spad{psi(x) = Gamma'(x)/Gamma(x)}.

        polygamma: (NNI, R) -> R
         ++ polygamma(n, x) is the n-th derivative of \spad{digamma(x)}.
        polygamma: (NNI, C) -> C
         ++ polygamma(n, x) is the n-th derivative of \spad{digamma(x)}.

        besselJ: (R,R) -> R
         ++ besselJ(v,x) is the Bessel function of the first kind,
         ++ \spad{J(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
        besselJ: (C,C) -> C
         ++ besselJ(v,x) is the Bessel function of the first kind,
         ++ \spad{J(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.

        besselY: (R, R) -> R
         ++ besselY(v,x) is the Bessel function of the second kind,
         ++ \spad{Y(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
         ++ Note: The default implementation uses the relation
         ++   \spad{Y(v,x) = (J(v,x) cos(v*%pi) - J(-v,x))/sin(v*%pi)}
         ++ so is not valid for integer values of v.
        besselY: (C, C) -> C
         ++ besselY(v,x) is the Bessel function of the second kind,
         ++ \spad{Y(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) + (x^2-v^2)w(x) = 0}.
         ++ Note: The default implementation uses the relation
         ++   \spad{Y(v,x) = (J(v,x) cos(v*%pi) - J(-v,x))/sin(v*%pi)}
         ++ so is not valid for integer values of v.

        besselI: (R,R) -> R
         ++ besselI(v,x) is the modified Bessel function of the first kind,
         ++ \spad{I(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
        besselI: (C,C) -> C
         ++ besselI(v,x) is the modified Bessel function of the first kind,
         ++ \spad{I(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.

        besselK: (R, R) -> R
         ++ besselK(v,x) is the modified Bessel function of the second kind,
         ++ \spad{K(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
         ++ Note: The default implementation uses the relation
         ++   \spad{K(v,x) = %pi/2*(I(-v,x) - I(v,x))/sin(v*%pi)}.
         ++ so is not valid for integer values of v.
        besselK: (C, C) -> C
         ++ besselK(v,x) is the modified Bessel function of the second kind,
         ++ \spad{K(v,x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{x^2 w''(x) + x w'(x) - (x^2+v^2)w(x) = 0}.
         ++ Note: The default implementation uses the relation
         ++   \spad{K(v,x) = %pi/2*(I(-v,x) - I(v,x))/sin(v*%pi)}
         ++ so is not valid for integer values of v.

        airyAi:   C -> C
         ++ airyAi(x) is the Airy function \spad{Ai(x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{Ai''(x) - x * Ai(x) = 0}.
        airyAi:   R -> R
         ++ airyAi(x) is the Airy function \spad{Ai(x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{Ai''(x) - x * Ai(x) = 0}.

        airyBi:   R -> R
         ++ airyBi(x) is the Airy function \spad{Bi(x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{Bi''(x) - x * Bi(x) = 0}.
        airyBi:   C -> C
         ++ airyBi(x) is the Airy function \spad{Bi(x)}.
         ++ This function satisfies the differential equation:
         ++   \spad{Bi''(x) - x * Bi(x) = 0}.

        hypergeometric0F1: (R, R) -> R
         ++ hypergeometric0F1(c,z) is the hypergeometric function
         ++ \spad{0F1(; c; z)}.
        hypergeometric0F1: (C, C) -> C
         ++ hypergeometric0F1(c,z) is the hypergeometric function
         ++ \spad{0F1(; c; z)}.


    Impl ==> add
        a, v, w, z: C
        n, x, y: R

        -- These are hooks to Bruce's boot code.
        Gamma z         == CGAMMA(z)$Lisp
        Gamma x         == RGAMMA(x)$Lisp

@
\section{The Exponential Integral}
(Quoted from Segletes\cite{2}):

A number of useful integrals exist for which no exact solutions have
been found. In other cases, an exact solution, if found, may be
impractical to utilize over the complete domain of the function
because of precision limitations associated with what usually ends up
as a series solution to the challenging integral. For many of these
integrals, tabulated values may be published in various mathematical
handbooks and articles. In some handbooks, fits (usually piecewise)
also are offered. In some cases, an application may be forced to
resort to numerical integration in order to acquire the integrated
function. In this context, compact ({\sl i.e.} not piecewise)
analytical fits to some of these problematic integrals, accurate to
within a small fraction of the numerically integrated value, serve as
a useful tool to applications requiring the results of the
integration, especially when the integration is required numerous
times throughout the course of the application. Furthermore, the
ability and methodology to develop intelligent fits, in contract to
the more traditional ``brute force'' fits, provide the means to
minimize parameters and maximize accuracy when tackling some of these
difficult functions. The exponential integral will be used as an
opportunity to both demonstrate a methodology for intelligent fitting
as well as for providing an accurate, compact, analytical fit to the
exponential integral.

The exponential integral is a useful class of functions that arise in
a variety of applications [...]. The real branch of the family of
exponential integrals may be defined as
\begin{equation}
E_n(x)=x^{n-1}\int_x^\infty{\frac{e^{-t}}{t^n}\ dt}
\end{equation}
where $n$, a positive integer, denotes the specific member of the
exponential integral family. The argument of the exponential integral,
rather than expressing a lower limit of integration as in (1),
may be thought of as describing the exponential decay
constant, as given in this equivalent (and perhaps more popular)
definition of the integral:
\begin{equation}
E_n(x)=\int_1^\infty{\frac{e^{-xt}}{t^n}\ dt}
\end{equation}

Integration by parts permits any member of the exponential integral
family to be converted to an adjacent member of the family, by way of 
\begin{equation}
\int_x^\infty{\frac{e^{-t}}{t^{n+1}}\ dt}=\frac{1}{n}
\left(
\frac{e^{-x}}{x^n}-\int_x^\infty{\frac{e^{-t}}{t^n}\ dt}
\right)
\end{equation}
expressable in terms of $E_n$ as
\begin{equation}
E_{n+1}(x)=\frac{1}{n}\left[e^{-x}-xE_n(x)\right]\ (n=1,2,3)
\end{equation}

Through recursive employment of this equation, all members of the
exponential integral family may be analytically related. However, this
technique only allows for the transformation of one integral into
another. There remains the problem of evaluating $E_1(x)$. There is an
exact solution to the integral of $(e^{-t}/t)$, appearing in a number
of mathematical references \cite{4,5} which is obtainable by
expanding the exponential into a power series and integrating term by
term. That exact solution, which is convergent, may be used to specify
$E_1(x)$ as 
\begin{equation}
E_1(x)=-\gamma-ln(x)
+\frac{x}{1!}
-\frac{x^2}{2\cdot 2!}
+\frac{x^3}{3\cdot 3!}
-\ldots
\end{equation}

Euler's constant, $\gamma$, equal to $0.57721\ldots$, arises when the
power series expansion for $(e^{-t}/t)$ is integrated and evaluated at
its upper limit, as $x\rightarrow\infty$\cite{6}.

Employing eqn (5), however, to evaluate $E_1(x)$ is problematic for
finite $x$ significantly larger than unity. One may well ask of the
need to evaluate the exponential integral for large $x$, since the
function to be integrated drops off so rapidly that the integral is
surely a very flat function. Such reasoning is true when comparing the
integrand at large $x$ to that at small $x$. However, the definition
of eqn (1) has as its upper limit not a small value of $x$, but rather
that of $\infty$. Therefore, the actual values for $E_n(x)$ are
extremely small numbers for large values of $x$. Thus, it is not
sufficient merely to select enough terms of eqn (5) to evaluate the
integral to within a value of, for example $\pm 0.0001$ because the
actual integral value for large $x$ would be smaller than this
arbitrary tolerance. To draw an analogy, it would be like saying that
it is good enough to approximate $e^{-x}$ as 0.0 for $x>10$, since its
actual value is within 0.0001 of zero. For some applications, such an
approximation may be warranted. In general, though, such an
approximation is mathematically unacceptable. Worse yet, as seen from
eqns (1) and (2), the need to evaluate the exponential integral for
large arguments can arise in real-world problems from either a large
integraion limit or a large value of an exponential decay
constant. Thus, the need to evaluate exponential integrals for large
values of the argument is established. It is here that the practical
problems with the evaluation of eqn (5) become manifest.

First, the number of terms, $N$, required to achieve convergence rises
rapidly with increasing $x$, making the summation an inefficient tool,
even when expressed as a recursion relation (for three digits of
accuracy, $N$ is observed to vary roughly as $9+1.6x$, for $1<x<7$).
More important, however, is the fact that, for calculations of finite
precision, the accuracy of the complete summation will be governed by
the individual term of greatest magnitude. The source of the problem
is that as $x$ is increased, the total summation decreases in
magnitude more rapidly than a decaying exponential, while at the same
time, the largest individual term in the series is observed to grow
rapidly with increasing $x$ (
$\tilde{}10^1$ for $x=7$, 
$\tilde{}10^2$ for $x=10$, 
$\tilde{}10^3$ for $x=13$, {\sl etc.}). The magnitude of this largest
individual term consumes the available precision and, as a result,
leaves little or none left for the ever-diminishing net sum that
constitutes the desired integral.

Literally, the use of eqn (5), even with (32-bit) double precision,
does not permit the exponential integral to be evaluated to three
places for $x>14$ in any case, and with the situation worsening for
lesser precision. For these reasons, the use of eqn (5) to evaluate
the exponential integral numerically for large $x$ is wholly
unsuitable.

\begin{equation}
E_1(x)=e^{-x}\cdot
\frac{1}{\displaystyle x+
\frac{1}{\displaystyle 1+
\frac{1}{\displaystyle x+
\frac{2}{\displaystyle 1+
\frac{2}{\displaystyle x+\ldots}}}}}
\end{equation}

But as $x$ becomes smaller, the number of terms required for
convergence rises quickly. Similar arguments apply for the use of an
asymptotic expansion for $E_1$, which also converges for large $x$. As
such, the more typical approach employed by handbooks is that of a
fit. While some steps are taken to make the fits intelligent ({\sl
e.g.}, transformation of variables), the fits are all piecewise over
the domain of the integral.

Cody and Thatcher \cite{7} performed what is perhaps the definitive
work, with the use of Chebyshev approximations to the exponential 
integral $E_1$. Like others, they fit the integral over a piecewise
series of subdomains (three in their case) and provide the fitting
parameters necessary to evaluate the function to various required
precisions, down to relative errors of $10^-20$. One of the problems
with piecewise fitting over two or more subdomains is that functional
value and derivatives of the spliced fits will not, in general, match
at the domain transition point, unless special accomodations are
made. This sort of discontinuity in functional value and/or slope,
curvature, {\sl etc.}, may cause difficulties for some numerical
algorithms operating upon the fitted function. Numerical
splicing/smoothing algorithms aimed at eliminating discontinuities in
the value and/or derivatives of a piecewise fit are not, in general,
computationally insignificant. Problems associated with piecewise
splicing of fits may also be obviated by obtaining an accurate enough
fit, such that the error is on the order of magnitude of the limiting
machine precision. This alternative, however, requires the use of
additional fitting parameters to acquire the improved precision. Thus,
regardless of approach, the desire to eliminate discontinuities in the
function and its derivatives, between piecewise splices, requires
extra computational effort. One final benefit to be had by avoiding
the use of piecewise fits is the concomitant avoidance of conditional
({\sl i.e.}, IF...THEN) programming statements in the coding of the
routine. The use of conditional statements can preclude maximum
computing efficiency on certain parallel computing architectures.

Segletes constructs an analytic, non-piecewise fit to the Exponential
Integral but the precision is on the order of 4 decimal places and is
not sufficient to compare against the Abramowitz and Stegun Handbook.

Instead we have chosen to use a two piece fitting function based on
the Chebyshev polynomial for computing $E_1$. This agrees with the
handbook values to almost the last published digit. See the {\tt e1.input}
pamphlet for regression testing against the handbook tables.

\subsection{E1:R$\rightarrow$R}
The special function E1 below was originally derived from a function
written by T.Haavie as the {\tt expint.c} function in the Numlibc library
by Lars Erik Lund. Haavie approximates the E1 function by two 
Chebyshev polynomials. For the range $-4 < x < 4$ the Chebyshev
coefficients are:
\begin{verbatim}
 7.8737715392882774, -8.0314874286705335,  3.8797325768522250,
-1.6042971072992259,  0.5630905453891458, -0.1704423017433357,
 0.0452099390015415, -0.0106538986439085,  0.0022562638123478,
-0.0004335700473221,  0.0000762166811878, -0.0000123417443064,
 0.0000018519745698, -0.0000002588698662,  0.0000000338604319,
-0.0000000041611418,  0.0000000004821606, -0.0000000000528465,
 0.0000000000054945, -0.0000000000005433,  0.0000000000000512,
-0.0000000000000046,  0.0000000000000004 
\end{verbatim}
and for the range $x > 4$ the Chebyshev coefficients are:
\begin{verbatim}
 0.2155283776715125,  0.1028106215227030, -0.0045526707131788,
 0.0003571613122851, -0.0000379341616932,  0.0000049143944914,
-0.0000007355024922,  0.0000001230603606, -0.0000000225236907,
 0.0000000044412375, -0.0000000009328509,  0.0000000002069297,
-0.0000000000481502,  0.0000000000116891, -0.0000000000029474,
 0.0000000000007691, -0.0000000000002070,  0.0000000000000573,
-0.0000000000000163,  0.0000000000000047, -0.0000000000000014,
 0.0000000000000004, -0.0000000000000001
\end{verbatim}

I've rewritten the polynomial to use precomputed coefficients
that take into account the scaling used by Haavie. I've also
rewritten the polynomial using Horner's method so the large
powers of $x$ are only computed once.

<<package DFSFUN DoubleFloatSpecialFunctions>>=
        E1(x:R):OPR ==
         x = 0.0::R => infinity()
         x > 4.0::R =>
          t1:R:=0.14999948967737774608E-15::R
          t2:R:=0.9999999999993112::R
          ta:R:=(t1*x+t2)
          t3:R:=0.99999999953685760001::R
          tb:R:=(ta*x-t3)
          t4:R:=1.9999998808293376::R
          tc:R:=(tb*x+t4)
          t5:R:=5.999983407661056::R
          td:R:=(tc*x-t5)
          t6:R:=23.9985380938481664::R
          te:R:=(td*x+t6)
          t7:R:=119.9108830382784512::R
          tf:R:=(te*x-t7)
          t8:R:=716.01351020920176641::R
          tg:R:=(tf*x+t8)
          t9:R:=4903.3466623370985473::R
          th:R:=(tg*x-t9)
          t10:R:=36601.25841454446674::R
          ti:R:=(th*x+t10)
          t11:R:=279913.28608482691646::R
          tj:R:=(ti*x-t11)
          t12:R:=2060518.7020296525186::R
          tk:R:=(tj*x+t12)
          t13:R:=13859772.093039815059::R
          tl:R:=(tk*x-t13)
          t14:R:=81945572.630072918857::R
          tm:R:=(tl*x+t14)
          t15:R:=413965714.82128317479::R
          tn:R:=(tm*x-t15)
          t16:R:=1747209536.2595547568::R
          to:R:=(tn*x+t16)
          t17:R:=6036182333.96179427::R
          tp:R:=(to*x-t17)
          t18:R:=16693683576.106267572::R
          tq:R:=(tp*x+t18)
          t19:R:=35938625644.58286097::R
          tr:R:=(tq*x-t19)
          t20:R:=57888657293.609258888::R
          ts:R:=(tr*x+t20)
          t21:R:=65523779423.11290127::R
          tt:R:=(ts*x-t21)
          t22:R:=46422751473.201760309::R
          tu:R:=(tt*x+t22)
          t23:R:=15474250491.067253436::R
          tv:R:=(tu*x-t23)
          tw:R:=(-1.0::R*x)
          tx:R:=exp(tw)
          ty:R:=tv*tx
          tz:R:=x**22
          taz:R:=ty/tz
          taz::OPR
         x > -4.0::R => 
          a1:R:=0.476837158203125E-22::R
          a2:R:=0.10967254638671875E-20::R
          aa:R:=(-a1*x+a2)
          a3:R:=0.20217895507812500001E-19::R
          ab:R:=(aa*x-a3)
          a4:R:=0.42600631713867187501E-18::R
          ac:R:=(ab*x+a4)
          a5:R:=0.868625640869140625E-17::R
          ad:R:=(ac*x-a5)
          a6:R:=0.16553192138671875E-15::R
          ae:R:=(ad*x+a6)
          a7:R:=0.29870208740234375E-14::R
          af:R:=(ae*x-a7)
          a8:R:=0.5097890777587890625E-13::R
          ag:R:=(af*x+a8)
          a9:R:=0.81934069213867187499E-12::R
          ah:R:=(ag*x-a9)
          a10:R:=0.1235313123779296875E-10::R
          ai:R:=(ah*x+a10)
          a11:R:=0.1739729620849609375E-9::R
          aj:R:=(ai*x-a11)
          a12:R:=0.22774642697021484375E-8::R
          ak:R:=(aj*x+a12)
          a13:R:=0.275573192853515625E-7::R
          al:R:=(ak*x-a13)
          a14:R:=0.30619243635087890625E-6::R
          am:R:=(al*x+a14)
          a15:R:=0.000003100198412519140625::R
          an:R:=(am*x-a15)
          a16:R:=0.00002834467120045546875::R
          ao:R:=(an*x+a16)
          a17:R:=0.00023148148148176953125::R
          ap:R:=(ao*x-a17)
          a18:R:=0.0016666666666686609375::R
          aq:R:=(ap*x+a18)
          a19:R:=0.01041666666666646875::R
          ar:R:=(aq*x-a19)
          a20:R:=0.055555555555554168751::R
          as:R:=(ar*x+a20)
          a21:R:=0.2500000000000000375::R
          at:R:=(as*x-a21)
          a22:R:=1.000000000000000325::R
          au:R:=(at*x+a22)
          a23:R:=0.5772156649015328::R
          av:R:=au*x-a23
          aw:R:=- 1.0::R*log(abs(x)) + av
          aw::OPR
         error "E1: no approximation available"

        polygamma(k,z)  == CPSI(k, z)$Lisp
        polygamma(k,x)  == RPSI(k, x)$Lisp

        logGamma z      == CLNGAMMA(z)$Lisp
        logGamma x      == RLNGAMMA(x)$Lisp

        besselJ(v,z)    == CBESSELJ(v,z)$Lisp
        besselJ(n,x)    == RBESSELJ(n,x)$Lisp

        besselI(v,z)    == CBESSELI(v,z)$Lisp
        besselI(n,x)    == RBESSELI(n,x)$Lisp

        hypergeometric0F1(a,z) == CHYPER0F1(a, z)$Lisp
        hypergeometric0F1(n,x) == retract hypergeometric0F1(n::C, x::C)


        -- All others are defined in terms of these.
        digamma x == polygamma(0, x)
        digamma z == polygamma(0, z)

        Beta(x,y) == Gamma(x)*Gamma(y)/Gamma(x+y)
        Beta(w,z) == Gamma(w)*Gamma(z)/Gamma(w+z)

        fuzz := (10::R)**(-7)

        import IntegerRetractions(R)
        import IntegerRetractions(C)

        besselY(n,x) ==
            if integer? n then n := n + fuzz
            vp := n * pi()$R
            (cos(vp) * besselJ(n,x) - besselJ(-n,x) )/sin(vp)
        besselY(v,z) ==
            if integer? v then v := v + fuzz::C
            vp := v * pi()$C
            (cos(vp) * besselJ(v,z) - besselJ(-v,z) )/sin(vp)

        besselK(n,x) ==
            if integer? n then n := n + fuzz
            p    := pi()$R
            vp   := n*p
            ahalf:= 1/(2::R)
            p * ahalf * ( besselI(-n,x) - besselI(n,x) )/sin(vp)
        besselK(v,z) ==
            if integer? v then v := v + fuzz::C
            p    := pi()$C
            vp   := v*p
            ahalf:= 1/(2::C)
            p * ahalf * ( besselI(-v,z) - besselI(v,z) )/sin(vp)

        airyAi x ==
            ahalf  := recip(2::R)::R
            athird := recip(3::R)::R
            eta := 2 * athird * (-x) ** (3*ahalf)
            (-x)**ahalf * athird * (besselJ(-athird,eta) + besselJ(athird,eta))
        airyAi z ==
            ahalf  := recip(2::C)::C
            athird := recip(3::C)::C
            eta := 2 * athird * (-z) ** (3*ahalf)
            (-z)**ahalf * athird * (besselJ(-athird,eta) + besselJ(athird,eta))

        airyBi x ==
            ahalf  := recip(2::R)::R
            athird := recip(3::R)::R
            eta := 2 * athird * (-x) ** (3*ahalf)
            (-x*athird)**ahalf * ( besselJ(-athird,eta) - besselJ(athird,eta) )

        airyBi z ==
            ahalf  := recip(2::C)::C
            athird := recip(3::C)::C
            eta := 2 * athird * (-z) ** (3*ahalf)
            (-z*athird)**ahalf * ( besselJ(-athird,eta) - besselJ(athird,eta) )

@
\section{package ORTHPOL OrthogonalPolynomialFunctions}
<<package ORTHPOL OrthogonalPolynomialFunctions>>=
)abbrev package ORTHPOL OrthogonalPolynomialFunctions
++ Author: Stephen M. Watt
++ Date Created:  1990
++ Date Last Updated: June 25, 1991
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This package provides orthogonal polynomials as functions on a ring.

OrthogonalPolynomialFunctions(R: CommutativeRing): Exports == Impl where
    NNI ==> NonNegativeInteger
    RN  ==> Fraction Integer

    Exports ==> with

        chebyshevT: (NNI, R) -> R
           ++ chebyshevT(n,x) is the n-th Chebyshev polynomial of the first
           ++ kind, \spad{T[n](x)}.  These are defined by
           ++ \spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x) *t**n, n = 0..)}.

        chebyshevU: (NNI, R) -> R
           ++ chebyshevU(n,x) is the n-th Chebyshev polynomial of the second
           ++ kind, \spad{U[n](x)}. These are defined by
           ++ \spad{1/(1-2*t*x+t**2) = sum(T[n](x) *t**n, n = 0..)}.

        hermiteH:   (NNI, R) -> R
           ++ hermiteH(n,x) is the n-th Hermite polynomial, \spad{H[n](x)}.
           ++ These are defined by
           ++ \spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!, n = 0..)}.

        laguerreL:  (NNI, R) -> R
           ++ laguerreL(n,x) is the n-th Laguerre polynomial, \spad{L[n](x)}.
           ++ These are defined by
           ++ \spad{exp(-t*x/(1-t))/(1-t) = sum(L[n](x)*t**n/n!, n = 0..)}.

        laguerreL:  (NNI, NNI, R) -> R
           ++ laguerreL(m,n,x) is the associated Laguerre polynomial,
           ++ \spad{L<m>[n](x)}.  This is the m-th derivative of \spad{L[n](x)}.

        if R has Algebra RN then
            legendreP:  (NNI, R) -> R
                ++ legendreP(n,x) is the n-th Legendre polynomial,
                ++ \spad{P[n](x)}.  These are defined by
                ++ \spad{1/sqrt(1-2*x*t+t**2) = sum(P[n](x)*t**n, n = 0..)}.

    Impl ==> add
        p0, p1: R
        cx:     Integer

        import IntegerCombinatoricFunctions()

        laguerreL(n, x) ==
            n = 0 => 1
            (p1, p0) := (-x + 1, 1)
            for i in 1..n-1 repeat
                (p1, p0) := ((2*i::R + 1 - x)*p1 - i**2*p0, p1)
            p1
        laguerreL(m, n, x) ==
            ni := n::Integer
            mi := m::Integer
            cx := (-1)**m * binomial(ni,ni-mi) * factorial(ni)
            p0 := 1
            p1 := cx::R
            for j in 1..ni-mi repeat
                cx := -cx*(ni-mi-j+1)
                cx := (cx exquo ((mi+j)*j))::Integer
                p0 := p0 * x
                p1 := p1 + cx*p0
            p1
        chebyshevT(n, x) ==
            n = 0 => 1
            (p1, p0) := (x, 1)
            for i in 1..n-1 repeat
                (p1, p0) := (2*x*p1 - p0, p1)
            p1
        chebyshevU(n, x) ==
            n = 0 => 1
            (p1, p0) := (2*x, 1)
            for i in 1..n-1 repeat
                (p1, p0) := (2*x*p1 - p0, p1)
            p1
        hermiteH(n, x) ==
            n = 0 => 1
            (p1, p0) := (2*x, 1)
            for i in 1..n-1 repeat
                (p1, p0) := (2*x*p1 - 2*i*p0, p1)
            p1
        if R has Algebra RN then
            legendreP(n, x) ==
                n = 0 => 1
                p0 := 1
                p1 := x
                for i in 1..n-1 repeat
                    c: RN := 1/(i+1)
                    (p1, p0) := (c*((2*i+1)*x*p1 - i*p0), p1)
                p1

@
\section{package NTPOLFN NumberTheoreticPolynomialFunctions}
<<package NTPOLFN NumberTheoreticPolynomialFunctions>>=
)abbrev package NTPOLFN NumberTheoreticPolynomialFunctions
++ Author: Stephen M. Watt
++ Date Created:  1990
++ Date Last Updated: June 25, 1991
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This package provides polynomials as functions on a ring.

NumberTheoreticPolynomialFunctions(R: CommutativeRing): Exports == Impl where
    NNI ==> NonNegativeInteger
    RN  ==> Fraction Integer

    Exports ==> with

        cyclotomic: (NNI, R) -> R
         ++ cyclotomic(n,r) \undocumented

        if R has Algebra RN then
            bernoulliB: (NNI, R) -> R
             ++ bernoulliB(n,r) \undocumented
            eulerE:     (NNI, R) -> R
             ++ eulerE(n,r) \undocumented

    Impl ==> add

        import PolynomialNumberTheoryFunctions()

        I   ==> Integer
        SUP ==> SparseUnivariatePolynomial

        -- This is the wrong way to evaluate the polynomial.
        cyclotomic(k, x) ==
            p: SUP(I) := cyclotomic(k)
            r: R      := 0
            while p ^= 0 repeat
                d := degree p
                c := leadingCoefficient p
                p := reductum p
                r := c*x**d + r
            r

        if R has Algebra RN then
            eulerE(k, x) ==
                p: SUP(RN) := euler(k)
                r: R       := 0
                while p ^= 0 repeat
                    d := degree p
                    c := leadingCoefficient p
                    p := reductum p
                    r := c*x**d + r
                r
            bernoulliB(k, x) ==
                p: SUP(RN) := bernoulli(k)
                r: R       := 0
                while p ^= 0 repeat
                    d := degree p
                    c := leadingCoefficient p
                    p := reductum p
                    r := c*x**d + r
                r

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package DFSFUN DoubleFloatSpecialFunctions>>
<<package ORTHPOL OrthogonalPolynomialFunctions>>
<<package NTPOLFN NumberTheoreticPolynomialFunctions>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} Segletes, Steven, B., ``A Compact Analytical Fit to the 
Exponential Integral $E_1(x)$'', Army Research Laboratory, ARL-TR-1758,
September 1998
\bibitem{2} Lund, Lars Erik, ``Numlibc'',\\
{\bf http://www.math.ntnu.no/num/nnm/Program/Numlibc}
\bibitem{3} Haavie, T. ``expint.c'',\\
{\bf http://www.math.ntnu.no/num/nnm/Program/Numlibc}, June, 1988
\bibitem{4} Abramowitz and Stegun,``Handbook of Mathematical Functions'',
Dover Publications, Inc. New York 1965. pp238-243
\bibitem{5} Beyer, W.H. (ed.) CRC Standard Mathematical Tables. 26th
Edition, Boca Raton: CRC Press, 1981.
\bibitem{6} Pearson, C.E. (ed.) ``Handbook of Applied Mathematics; 
Selected Results and Methods''. New York: van Nostrand Reinhold, 1983.
\bibitem{7} Cody, W.J., and H.C. Thatcher, Jr. ``Rational Chebyshev
Approximations for the Exponential Integral $E_1(x)$.''
Mathematics of Computation, 11, pp. 641-649, 1968
\end{thebibliography}
\end{document}
