\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra pattern.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package PATTERN1 PatternFunctions1}
<<dot>>=
"PATTERN1" -> "PACKAGE" 
"PatternFunctions1(a:SetCategory,b:Type)" -> "Package"
@
<<package PATTERN1 PatternFunctions1>>=
)abbrev package PATTERN1 PatternFunctions1
++ Utilities for handling patterns
++ Author: Manuel Bronstein
++ Date Created: 28 Nov 1989
++ Date Last Updated: 5 Jul 1990
++ Description: Tools for patterns;
++ Keywords: pattern, matching.
PatternFunctions1(R:SetCategory, D:Type): with
    suchThat   : (Pattern R, D -> Boolean)       -> Pattern R
      ++ suchThat(p, f) makes a copy of p and adds the predicate
      ++ f to the copy, which is returned.
    suchThat   : (Pattern R, List(D -> Boolean)) -> Pattern R
      ++ \spad{suchThat(p, [f1,...,fn])} makes a copy of p and adds the
      ++ predicate f1 and ... and fn to the copy, which is returned.
    suchThat : (Pattern R, List Symbol, List D -> Boolean)  -> Pattern R
      ++ \spad{suchThat(p, [a1,...,an], f)} returns a copy of p with
      ++ the top-level predicate set to \spad{f(a1,...,an)}.
    predicate  : Pattern R -> (D -> Boolean)
      ++ predicate(p) returns the predicate attached to p, the
      ++ constant function true if p has no predicates attached to it.
    satisfy?   : (D, Pattern R) -> Boolean
      ++ satisfy?(v, p) returns f(v) where f is the predicate
      ++ attached to p.
    satisfy?   : (List D, Pattern R) -> Boolean
      ++ \spad{satisfy?([v1,...,vn], p)} returns \spad{f(v1,...,vn)} 
      ++ where f is the
      ++ top-level predicate attached to p.
    addBadValue: (Pattern R, D) -> Pattern R
      ++ addBadValue(p, v) adds v to the list of "bad values" for p;
      ++ p is not allowed to match any of its "bad values".
    badValues  : Pattern R -> List D
      ++ badValues(p) returns the list of "bad values" for p;
      ++ p is not allowed to match any of its "bad values".
  == add
    A1D ==> AnyFunctions1(D)
    A1  ==> AnyFunctions1(D -> Boolean)
    A1L ==> AnyFunctions1(List D -> Boolean)
 
    applyAll: (List Any, D) -> Boolean
    st      : (Pattern R, List Any) -> Pattern R
 
    st(p, l)          == withPredicates(p, concat(predicates p, l))
    predicate p       == applyAll(predicates p, #1)
    addBadValue(p, v) == addBadValue(p, coerce(v)$A1D)
    badValues p       == [retract(v)$A1D for v in getBadValues p]
    suchThat(p, l, f) == setTopPredicate(copy p, l, coerce(f)$A1L)
    suchThat(p:Pattern R, f:D -> Boolean) == st(p, [coerce(f)$A1])
    satisfy?(d:D, p:Pattern R)            == applyAll(predicates p, d)
 
    satisfy?(l:List D, p:Pattern R) ==
      empty?((rec := topPredicate p).var) => true
      retract(rec.pred)$A1L l
 
    applyAll(l, d) ==
      for f in l repeat
        not(retract(f)$A1 d) => return false
      true
 
    suchThat(p:Pattern R, l:List(D -> Boolean)) ==
      st(p, [coerce(f)$A1 for f in l])

@
\section{package PATTERN2 PatternFunctions2}
<<dot>>=
"PATTERN2" -> "PACKAGE"
"PatternFunctions2(a:SetCategory,b:SetCategory)" -> "Package"
@
<<package PATTERN2 PatternFunctions2>>=
)abbrev package PATTERN2 PatternFunctions2
++ Lifting of maps to patterns
++ Author: Manuel Bronstein
++ Date Created: 28 Nov 1989
++ Date Last Updated: 12 Jan 1990
++ Description: Lifts maps to patterns;
++ Keywords: pattern, matching.
PatternFunctions2(R:SetCategory, S:SetCategory): with
    map: (R -> S, Pattern R) -> Pattern S
      ++ map(f, p) applies f to all the leaves of p and
      ++ returns the result as a pattern over S.
  == add
    map(f, p) ==
      (r := (retractIfCan p)@Union(R, "failed")) case R =>
        f(r::R)::Pattern(S)
      (u := isOp p) case Record(op:BasicOperator, arg:List Pattern R) =>
        ur := u::Record(op:BasicOperator, arg:List Pattern R)
        (ur.op) [map(f, x) for x in ur.arg]
      (v := isQuotient p) case Record(num:Pattern R, den:Pattern R) =>
        vr := v::Record(num:Pattern R, den:Pattern R)
        map(f, vr.num) / map(f, vr.den)
      (l := isPlus p) case List(Pattern R) =>
        reduce("+", [map(f, x) for x in l::List(Pattern R)])
      (l := isTimes p) case List(Pattern R) =>
        reduce("*", [map(f, x) for x in l::List(Pattern R)])
      (x := isPower p) case
       Record(val:Pattern R, exponent: Pattern R) =>
        xr := x::Record(val:Pattern R, exponent: Pattern R)
        map(f, xr.val) ** map(f, xr.exponent)
      (w := isExpt p) case
       Record(val:Pattern R, exponent: NonNegativeInteger) =>
        wr := w::Record(val:Pattern R, exponent: NonNegativeInteger)
        map(f, wr.val) ** wr.exponent
      sy := retract(p)@Symbol
      setPredicates(sy::Pattern(S), copy predicates p)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
 
<<package PATTERN1 PatternFunctions1>>
<<package PATTERN2 PatternFunctions2>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
