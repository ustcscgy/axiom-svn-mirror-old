\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra axserver.spad}
\author{Arthur C. Ralfs}
\maketitle
\begin{abstract}
The AxiomServer package is designed to provide a web interface
to axiom.
\end{abstract}
\eject
\tableofcontents
\eject
\section{Axiom Server}
<<package AXSERV AxiomServer>>=

)abbrev package AXSERV AxiomServer
AxiomServer: public == private where

 public == with

   axServer: (Integer, SExpression->Void) -> Void
   multiServ: SExpression -> Void

 private == add

   getFile: (SExpression,String) -> Void
   getCommand: (SExpression,String) -> Void
   lastStep: () -> String
   lastType: () -> String
   formatMessages: String -> String
   getContentType: String -> String


   axServer(port:Integer,serverfunc:SExpression->Void):Void ==
     WriteLine("socketServer")$Lisp
     s := SiSock(port,serverfunc)$Lisp
     -- To listen for just one connection and then close the socket
     -- uncomment i := 0.
     i:Integer := 1
     while (i > 0) repeat
       if not null?(SiListen(s)$Lisp)$SExpression then
         w := SiAccept(s)$Lisp
         serverfunc(w)
--        i := 0

   multiServ(s:SExpression):Void ==
         WriteLine("multiServ begin")$Lisp
         headers:String := ""
         char:String
         -- read in the http headers
         while (char := STRING(READ_-CHAR_-NO_-HANG(s,NIL$Lisp,'EOF)$Lisp)$Lisp) ^= "EOF" repeat
             headers := concat [headers,char]
         sayTeX$Lisp headers
         StringMatch("([^ ]*)", headers)$Lisp
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         reqtype:String := headers.u
         sayTeX$Lisp  concat ["request type: ",reqtype]
         if  reqtype = "GET" then
             StringMatch("GET ([^ ]*)",headers)$Lisp
             u:UniversalSegment(Integer)
             u := segment(MatchBeginning(1)$Lisp+1,MatchEnd(1)$Lisp)$UniversalSegment(Integer)
             getFile(s,headers.u)
         if reqtype = "POST" then
             StringMatch("command=(.*)$",headers)$Lisp
             u:UniversalSegment(Integer)
             u := segment(MatchBeginning(1)$Lisp+1,MatchEnd(1)$Lisp)$UniversalSegment(Integer)
             getCommand(s,headers.u)
         WriteLine("multiServ end")$Lisp
         WriteLine("")$Lisp

   getFile(s:SExpression,pathvar:String):Void ==
       WriteLine("")$Lisp
       WriteLine("getFile")$Lisp
       if not null? PATHNAME_-NAME(PATHNAME(pathvar)$Lisp)$Lisp then
       -- display contents of file
       --first determine Content-Type from file extension
           contentType:String := getContentType(pathvar)
           q:=Open(pathvar)$Lisp
           if null? q then
             q := MAKE_-STRING_-INPUT_-STREAM("File doesn't exist")$Lisp
             WriteLine("File does not exist.")$Lisp
       else
           q:=MAKE_-STRING_-INPUT_-STREAM("Problem with file path")$Lisp
       file:String := ""
       WriteLine("begin reading file")$Lisp
       r := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
       SiCopyStream(q,r)$Lisp
       filestream:String := GET_-OUTPUT_-STREAM_-STRING(r)$Lisp
       CLOSE(r)$Lisp
       CLOSE(q)$Lisp
       WriteLine("end reading file")$Lisp
       filelength:String := string(#filestream)
       file := concat ["Content-Length: ",filelength,STRING(NewLine$Lisp)$Lisp,STRING(NewLine$Lisp)$Lisp,file]
       file := concat ["Connection: close",STRING(NewLine$Lisp)$Lisp,file]
       file := concat ["Content-Type: ",contentType,STRING(NewLine$Lisp)$Lisp,file]
       file := concat ["HTTP/1.1 200 OK",STRING(NewLine$Lisp)$Lisp,file]
       file := concat [file,filestream]
       f:=MAKE_-STRING_-INPUT_-STREAM(file)$Lisp
       SiCopyStream(f,s)$Lisp
       CLOSE(f)$Lisp
       CLOSE(s)$Lisp
       WriteLine("getFile end")$Lisp
       WriteLine("")$Lisp

   getCommand(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getCommand: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
--      parseAndInterpret$Lisp command
--      parseAndEvalStr$Lisp command
-- The previous two commands don't exit nicely when a syntactically incorrect command is
-- given to them.  They somehow need to be wrapped in CATCH statements but I haven't
-- figured out how to do this.  parseAndEvalToStringEqNum  uses the following CATCH
-- statements to call parseAndEvalStr but when I try these they don't work.  I get a
-- "NIL is not a valid identifier to use in AXIOM" message. Using parseAndEvalToStringEqNum
-- works and doesn't crash on a syntax error.
--        v := CATCH('SPAD__READER, CATCH('top__level, parseAndEvalStr$Lisp command)$Lisp)$Lisp
--        v = 'restart => ['"error"]
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
--       axans:String := concat ["<div><div class=_"command_">(",lastStep(),") -> ",command,"</div><div class=_"algebra_">",algebra,"</div><div class=_"mathml_">",mathml,"</div><div class=_"type_">Type: ",lastType(),"</div></div>"]
       axans:String := concat ["<div class=_"stepnum_">", lastStep(), "</div><div class=_"command_">", command, "</div><div class=_"algebra_">",algebra,"</div><div class=_"mathml_">",mathml,"</div><div class=_"type_">",lastType(),"</div>"]       
       WriteLine$Lisp concat ["mathml answer: ",mathml]
       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp


   lastType():String ==
--  The last history entry is the first item in the $internalHistoryTable list so
--  car(_$internalHistoryTable$Lisp) selects it.  Here's an example:
--  (3 (x+y)**3 (% (value (Polynomial (Integer)) WRAPPED 1 y (3 0 . 1) (2 1 x (1 0 . 3)) (1 1 x (2 0 . 3)) (0 1 x (3 0 . 1)))))
--  This corresponds to the input "(x+y)**3" being issued as the third command after
--  starting axiom.  The following line selects the type information.
       string car(cdr(car(cdr(car(cdr(cdr(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp)$Lisp)$Lisp)$Lisp)$Lisp)$Lisp)$Lisp


   lastStep():String ==
       string car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp


   formatMessages(str:String):String ==
       WriteLine("formatMessages")$Lisp
       -- I need to replace any ampersands with &amp; and may also need to
       -- replace < and > with &lt; and &gt;
       strlist:List String
       WriteLine(str)$Lisp
       strlist := split(str,char "&")
       str := ""
       -- oops, if & is the last character in the string this method
       -- will eliminate it.  Need to redo this.
       for s in strlist repeat
           str := concat [str,s,"&amp;"]
       strlen:Integer := #str
       str := str.(1..(#str - 5))
       WriteLine(str)$Lisp
       -- Here I split the string into lines and put each line in a "div".
       strlist := split(str, char string NewlineChar$Lisp)
       str := ""
       WriteLine("formatMessages1")$Lisp
       WriteLine(concat strlist)$Lisp
       for s in strlist repeat
           WriteLine(s)$Lisp
           str := concat [str,"<div>",s,"</div>"]
       str

   getContentType(pathvar:String):String ==
       WriteLine("getContentType begin")$Lisp
       -- set default content type
       contentType:String := "text/plain"
       -- need to test for successful match?
       StringMatch(".*\.(.*)$", pathvar)$Lisp
       u:UniversalSegment(Integer)
       u := segment(MatchBeginning(1)$Lisp+1,MatchEnd(1)$Lisp)$UniversalSegment(Integer)
       extension:String := pathvar.u
       WriteLine$Lisp concat ["file extension: ",extension]
       -- test for extensions: html, htm, xml, xhtml, js, css
       if extension = "html" then
           contentType:String := "text/html"
       else if extension = "htm" then
           contentType:String := "text/html"
       else if extension = "xml" then
           contentType:String := "text/xml"
       else if extension = "xhtml" then
           contentType:String := "application/xhtml+xml"
       else if extension = "js" then
           contentType:String := "text/javascript"
       else if extension = "css" then
           contentType:String := "text/css"
       else if extension = "png" then
           contentType:String := "image/png"
       else if extension = "jpg" then
           contentType:String := "image/jpeg"
       else if extension = "jpeg" then
           contentType:String := "image/jpeg"
       WriteLine$Lisp concat ["Content-Type: ",contentType]
       WriteLine("getContentType end")$Lisp
       contentType

@
        
\section{License}
<<license>>=
--Copyright (c) 2007 Arthur C. Ralfs
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Arthur C. Ralfs nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@

<<*>>=
<<package AXSERV AxiomServer>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
