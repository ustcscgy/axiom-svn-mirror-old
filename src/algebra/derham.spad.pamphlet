\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra derham.spad}
\author{Larry A. Lambe}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{category LALG LeftAlgebra}
<<category LALG LeftAlgebra>>=
)abbrev category LALG LeftAlgebra
++ Author: Larry A. Lambe
++ Date  : 03/01/89; revised 03/17/89; revised 12/02/90.
++ Description: The category of all left algebras over an arbitrary
++ ring.
LeftAlgebra(R:Ring): Category == Join(Ring, LeftModule R) with
    --operations
      coerce: R -> %
	++ coerce(r) returns r * 1 where 1 is the identity of the
	++ left algebra.
    add
      coerce(x:R):% == x * 1$%

@
\section{domain EAB ExtAlgBasis}
<<domain EAB ExtAlgBasis>>=
)abbrev domain EAB ExtAlgBasis
--% ExtAlgBasis
++  Author: Larry Lambe
++  Date created: 03/14/89
++  Description:
++  A domain used in the construction of the exterior algebra on a set
++  X over a ring R.  This domain represents the set of all ordered
++  subsets of the set X, assumed to be in correspondance with
++  {1,2,3, ...}.  The ordered subsets are themselves ordered 
++  lexicographically and are in bijective correspondance with an ordered 
++  basis of the exterior algebra.  In this domain we are dealing strictly
++  with the exponents of basis elements which can only be 0 or 1.
--  Thus we really have L({0,1}).
++
++  The multiplicative identity element of the exterior algebra corresponds
++  to the empty subset of X.  A coerce from List Integer to an
++  ordered basis element is provided to allow the convenient input of 
++  expressions. Another exported function forgets the ordered structure
++  and simply returns the list corresponding to an ordered subset.
 
ExtAlgBasis(): Export == Implement where
   I   ==> Integer
   L   ==> List
   NNI ==> NonNegativeInteger
 
   Export == OrderedSet with
     coerce     : L I -> %
	++ coerce(l) converts a list of 0's and 1's into a basis
	++ element, where 1 (respectively 0) designates that the
        ++ variable of the corresponding index of l is (respectively, is not)
        ++ present.
        ++ Error: if an element of l is not 0 or 1.
     degree     : %   -> NNI
	++ degree(x) gives the numbers of 1's in x, i.e., the number
	++ of non-zero exponents in the basis element that x represents.
     exponents  : %   -> L I
	++ exponents(x) converts a domain element into a list of zeros
	++ and ones corresponding to the exponents in the basis element
	++ that x represents.
--   subscripts : %   -> L I
	-- subscripts(x) looks at the exponents in x and converts 
	-- them to the proper subscripts
     Nul        : NNI -> %
	++ Nul() gives the basis element 1 for the algebra generated
	++ by n generators.
 
   Implement == add
     Rep := L I
     x,y :  %

     x = y == x =$Rep y

     x < y ==
       null x            => not null y 
       null y            => false
       first x = first y => rest x < rest y
       first x > first y

     coerce(li:(L I)) == 
       for x in li repeat
         if x ^= 1 and x ^= 0 then error "coerce: values can only be 0 and 1"
       li

     degree x         == (_+/x)::NNI

     exponents x      == copy(x @ Rep)

--   subscripts x     ==
--      cntr:I := 1
--      result: L I := []
--      for j in x repeat
--        if j = 1 then result := cons(cntr,result)
--        cntr:=cntr+1
--      reverse_! result

     Nul n            == [0 for i in 1..n]

     coerce x         == coerce(x @ Rep)$(L I)

@
\section{domain ANTISYM AntiSymm}
<<domain ANTISYM AntiSymm>>=
)abbrev domain ANTISYM AntiSymm
++   Author: Larry A. Lambe
++   Date     : 01/26/91.
++   Revised  : 30 Nov 94
++
++   based on AntiSymmetric '89
++
++   Needs: ExtAlgBasis, FreeModule(Ring,OrderedSet), LALG, LALG-
++
++   Description: The domain of antisymmetric polynomials.
 
 
AntiSymm(R:Ring, lVar:List Symbol): Export == Implement where
  LALG ==> LeftAlgebra
  FMR  ==> FM(R,EAB)
  FM   ==> FreeModule
  I    ==> Integer
  L    ==> List
  EAB  ==> ExtAlgBasis     -- these are exponents of basis elements in order
  NNI  ==> NonNegativeInteger
  O    ==> OutputForm
  base ==> k
  coef ==> c
  Term ==> Record(k:EAB,c:R)
 
  Export == Join(LALG(R), RetractableTo(R)) with
      leadingCoefficient : %           -> R
	++ leadingCoefficient(p) returns the leading
	++ coefficient of antisymmetric polynomial p.
--    leadingSupport       : %           -> EAB
      leadingBasisTerm     : %           -> %
	++ leadingBasisTerm(p) returns the leading
	++ basis term of antisymmetric polynomial p.
      reductum           : %           -> %
	++ reductum(p), where p is an antisymmetric polynomial,
        ++ returns p minus the leading
	++ term of p if p has at least two terms, and 0 otherwise.
      coefficient        : (%,%)     -> R 
	++ coefficient(p,u) returns the coefficient of 
	++ the term in p containing the basis term u if such 
        ++ a term exists, and 0 otherwise.
	++ Error: if the second argument u is not a basis element.
      generator          : NNI         -> %
	++ generator(n) returns the nth multiplicative generator,
	++ a basis term.
      exp                : L I         -> %
	++  exp([i1,...in]) returns \spad{u_1\^{i_1} ... u_n\^{i_n}}
      homogeneous?       : %           -> Boolean
	++  homogeneous?(p) tests if all of the terms of 
	++  p have the same degree.
      retractable?       : %           -> Boolean
	++  retractable?(p) tests if p is a 0-form,
	++  i.e., if degree(p) = 0.
      degree             : %           -> NNI
	++  degree(p) returns the homogeneous degree of p.
      map                : (R -> R, %) -> %
	++  map(f,p) changes each coefficient of p by the
	++  application of f.


--    1 corresponds to the empty monomial Nul = [0,...,0]
--    from EAB.  In terms of the exterior algebra on X,
--    it corresponds to the identity element which lives
--    in homogeneous degree 0.
 
  Implement == FMR add
      Rep := L Term
      x,y :  EAB
      a,b :  %
      r   :  R
      m   :  I

      dim := #lVar

      1 == [[ Nul(dim)$EAB, 1$R ]]

      coefficient(a,u) ==
        not null u.rest => error "2nd argument must be a basis element"
        x := u.first.base
        for t in a repeat
          if t.base = x then return t.coef
          if t.base < x then return 0
        0

      retractable?(a) ==
        null a or (a.first.k  =  Nul(dim))

      retractIfCan(a):Union(R,"failed") ==
        null a               => 0$R
        a.first.k = Nul(dim) => leadingCoefficient a
        "failed"

      retract(a):R ==
        null a => 0$R
        leadingCoefficient a

      homogeneous? a ==
        null a => true
        siz := _+/exponents(a.first.base)
        for ta in reductum a repeat
          _+/exponents(ta.base) ^= siz => return false
        true

      degree a ==
        null a => 0$NNI
        homogeneous? a => (_+/exponents(a.first.base)) :: NNI
        error "not a homogeneous element"

      zo : (I,I) -> L I
      zo(p,q) ==
        p = 0 => [1,q]
        q = 0 => [1,1]
        [0,0]

      getsgn : (EAB,EAB) -> I
      getsgn(x,y) ==
        sgn:I  := 0
        xx:L I := exponents x
        yy:L I := exponents y
        for i in 1 .. (dim-1) repeat
          xx  := rest xx
          sgn := sgn + (_+/xx)*yy.i
        sgn rem 2 = 0 => 1
        -1

      Nalpha: (EAB,EAB) -> L I
      Nalpha(x,y) ==
        i:I := 1
        dum2:L I := [0 for i in 1..dim]
        for j in 1..dim repeat
          dum:=zo((exponents x).j,(exponents y).j)
          (i:= i*dum.1) = 0 => leave
          dum2.j := dum.2
        i = 0 => cons(i, dum2)
        cons(getsgn(x,y), dum2)

      a * b ==
        null a => 0
        null b => 0
        ((null a.rest) and (a.first.k = Nul(dim))) => a.first.c * b
        ((null b.rest) and (b.first.k = Nul(dim))) => b.first.c * a
        z:% := 0
        for tb in b repeat
          for ta in a repeat
            stuff:=Nalpha(ta.base,tb.base)
            r:=first(stuff)*ta.coef*tb.coef
            if r ^= 0 then z := z + [[rest(stuff)::EAB, r]]
        z

      coerce(r):% == 
        r = 0 => 0
        [ [Nul(dim), r] ]

      coerce(m):% == 
        m = 0 => 0
        [ [Nul(dim), m::R] ]

      characteristic() == characteristic()$R

      generator(j) == 
        -- j < 1 or j > dim => error "your subscript is out of range"
        -- error will be generated by dum.j if out of range
        dum:L I := [0 for i in 1..dim]
        dum.j:=1
        [[dum::EAB, 1::R]]

      exp(li:(L I)) ==  [[li::EAB, 1]]
 
      leadingBasisTerm a ==
        [[a.first.k, 1]]

      displayList:EAB -> O
      displayList(x):O ==
        le: L I := exponents(x)$EAB
--      reduce(_*,[(lVar.i)::O for i in 1..dim | le.i = 1])$L(O)
--        reduce(_*,[(lVar.i)::O for i in 1..dim | one?(le.i)])$L(O)
        reduce(_*,[(lVar.i)::O for i in 1..dim | ((le.i) = 1)])$L(O)

      makeTerm:(R,EAB) -> O
      makeTerm(r,x) ==
      -- we know that r ^= 0
        x = Nul(dim)$EAB  => r::O
--        one? r => displayList(x)
        (r = 1) => displayList(x)
--      r = 1 => displayList(x)
--      r = 0 => 0$I::O
--      x = Nul(dim)$EAB  => r::O
        r::O * displayList(x)

      coerce(a):O ==
        zero? a     => 0$I::O
        null rest(a @ Rep) => 
                 t := first(a @ Rep)
                 makeTerm(t.coef,t.base)
        reduce(_+,[makeTerm(t.coef,t.base) for t in (a @ Rep)])$L(O)

@
\section{domain DERHAM DeRhamComplex}
<<DeRhamComplex.input>>=
-- derham.spad.pamphlet DeRhamComplex.input
)spool DeRhamComplex.output
)set message test on
)set message auto off
)clear all
--S 1 of 34
coefRing := Integer
--R 
--R
--R   (1)  Integer
--R                                                                 Type: Domain
--E 1

--S 2 of 34
lv : List Symbol := [x,y,z] 
--R 
--R
--R   (2)  [x,y,z]
--R                                                            Type: List Symbol
--E 2

--S 3 of 34
der := DERHAM(coefRing,lv) 
--R 
--R
--R   (3)  DeRhamComplex(Integer,[x,y,z])
--R                                                                 Type: Domain
--E 3

--S 4 of 34
R := Expression coefRing
--R 
--R
--R   (4)  Expression Integer
--R                                                                 Type: Domain
--E 4

--S 5 of 34
f : R := x**2*y*z-5*x**3*y**2*z**5
--R 
--R
--R            3 2 5    2
--R   (5)  - 5x y z  + x y z
--R                                                     Type: Expression Integer
--E 5

--S 6 of 34
g : R := z**2*y*cos(z)-7*sin(x**3*y**2)*z**2 
--R 
--R
--R            2     3 2       2
--R   (6)  - 7z sin(x y ) + y z cos(z)
--R                                                     Type: Expression Integer
--E 6

--S 7 of 34
h : R :=x*y*z-2*x**3*y*z**2 
--R 
--R
--R            3   2
--R   (7)  - 2x y z  + x y z
--R                                                     Type: Expression Integer
--E 7

--S 8 of 34
dx : der := generator(1)
--R 
--R
--R   (8)  dx
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 8

--S 9 of 34
dy : der := generator(2)
--R 
--R
--R   (9)  dy
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 9

--S 10 of 34
dz : der := generator(3)
--R 
--R
--R   (10)  dz
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 10

--S 11 of 34
[dx,dy,dz] := [generator(i)$der for i in 1..3]
--R 
--R
--R   (11)  [dx,dy,dz]
--R                                    Type: List DeRhamComplex(Integer,[x,y,z])
--E 11

--S 12 of 34
alpha : der := f*dx + g*dy + h*dz
--R 
--R
--R   (12)
--R          3   2                   2     3 2       2
--R     (- 2x y z  + x y z)dz + (- 7z sin(x y ) + y z cos(z))dy
--R   + 
--R          3 2 5    2
--R     (- 5x y z  + x y z)dx
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 12

--S 13 of 34
beta  : der := cos(tan(x*y*z)+x*y*z)*dx + x*dy
--R 
--R
--R   (13)  x dy + cos(tan(x y z) + x y z)dx
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 13

--S 14 of 34
exteriorDifferential alpha
--R 
--R
--R   (14)
--R         2                  3 2                    3 2
--R     (y z sin(z) + 14z sin(x y ) - 2y z cos(z) - 2x z  + x z)dy dz
--R   + 
--R         3 2 4     2   2          2
--R     (25x y z  - 6x y z  + y z - x y)dx dz
--R   + 
--R           2 2 2     3 2       3   5    2
--R     (- 21x y z cos(x y ) + 10x y z  - x z)dx dy
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 14

--S 15 of 34
exteriorDifferential %
--R 
--R
--R   (15)  0
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 15

--S 16 of 34
gamma := alpha * beta
--R 
--R
--R   (16)
--R        4   2    2               3   2
--R     (2x y z  - x y z)dy dz + (2x y z  - x y z)cos(tan(x y z) + x y z)dx dz
--R   + 
--R       2     3 2       2                                   4 2 5    3
--R   ((7z sin(x y ) - y z cos(z))cos(tan(x y z) + x y z) - 5x y z  + x y z)dx dy
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 16

--S 17 of 34
exteriorDifferential(gamma) - (exteriorDifferential(alpha)*beta - alpha * exteriorDifferential(beta)) 
--R 
--R
--R   (17)  0
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 17

--S 18 of 34
a : BOP := operator('a)
--R 
--R
--R   (18)  a
--R                                                          Type: BasicOperator
--E 18

--S 19 of 34
b : BOP := operator('b)
--R 
--R
--R   (19)  b
--R                                                          Type: BasicOperator
--E 19

--S 20 of 34
c : BOP := operator('c)
--R 
--R
--R   (20)  c
--R                                                          Type: BasicOperator
--E 20

--S 21 of 34
sigma := a(x,y,z) * dx + b(x,y,z) * dy + c(x,y,z) * dz 
--R 
--R
--R   (21)  c(x,y,z)dz + b(x,y,z)dy + a(x,y,z)dx
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 21

--S 22 of 34
theta  := a(x,y,z) * dx * dy + b(x,y,z) * dx * dz + c(x,y,z) * dy * dz 
--R 
--R
--R   (22)  c(x,y,z)dy dz + b(x,y,z)dx dz + a(x,y,z)dx dy
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 22

--S 23 of 34
totalDifferential(a(x,y,z))$der 
--R 
--R
--R   (23)  a  (x,y,z)dz + a  (x,y,z)dy + a  (x,y,z)dx
--R          ,3             ,2             ,1
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 23

--S 24 of 34
exteriorDifferential sigma
--R 
--R
--R   (24)
--R     (c  (x,y,z) - b  (x,y,z))dy dz + (c  (x,y,z) - a  (x,y,z))dx dz
--R       ,2           ,3                  ,1           ,3
--R   + 
--R     (b  (x,y,z) - a  (x,y,z))dx dy
--R       ,1           ,2
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 24

--S 25 of 34
exteriorDifferential theta
--R 
--R
--R   (25)  (c  (x,y,z) - b  (x,y,z) + a  (x,y,z))dx dy dz
--R           ,1           ,2           ,3
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 25

--S 26 of 34
one : der := 1
--R 
--R
--R   (26)  1
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 26

--S 27 of 34
g1 : der := a([x,t,y,u,v,z,e]) * one 
--R 
--R
--R   (27)  a(x,t,y,u,v,z,e)
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 27

--S 28 of 34
h1 : der := a([x,y,x,t,x,z,y,r,u,x]) * one 
--R 
--R
--R   (28)  a(x,y,x,t,x,z,y,r,u,x)
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 28

--S 29 of 34
exteriorDifferential g1 
--R 
--R
--R   (29)  a  (x,t,y,u,v,z,e)dz + a  (x,t,y,u,v,z,e)dy + a  (x,t,y,u,v,z,e)dx
--R          ,6                     ,3                     ,1
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 29

--S 30 of 34
exteriorDifferential h1
--R 
--R
--R   (30)
--R     a  (x,y,x,t,x,z,y,r,u,x)dz
--R      ,6
--R   + 
--R     (a  (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x))dy
--R       ,7                         ,2
--R   + 
--R         a   (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x)
--R          ,10                         ,5
--R       + 
--R         a  (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x)
--R          ,3                         ,1
--R    *
--R       dx
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 30

--S 31 of 34
coefficient(gamma, dx*dy)
--R 
--R
--R            2     3 2       2                                   4 2 5    3
--R   (31)  (7z sin(x y ) - y z cos(z))cos(tan(x y z) + x y z) - 5x y z  + x y z
--R                                                     Type: Expression Integer
--E 31

--S 32 of 34
coefficient(gamma, one)
--R 
--R
--R   (32)  0
--R                                                     Type: Expression Integer
--E 32

--S 33 of 34
coefficient(g1,one)
--R 
--R
--R   (33)  a(x,t,y,u,v,z,e)
--R                                                     Type: Expression Integer
--E 33

--S 34 of 34
gamma := alpha * beta
--R 
--R
--R   (34)
--R        4   2    2               3   2
--R     (2x y z  - x y z)dy dz + (2x y z  - x y z)cos(tan(x y z) + x y z)dx dz
--R   + 
--R       2     3 2       2                                   4 2 5    3
--R   ((7z sin(x y ) - y z cos(z))cos(tan(x y z) + x y z) - 5x y z  + x y z)dx dy
--R                                         Type: DeRhamComplex(Integer,[x,y,z])
--E 34
)spool
)lisp (bye)
@
<<DeRhamComplex.help>>=
====================================================================
DeRhamComplex
====================================================================

The domain constructor DeRhamComplex creates the class of differential
forms of arbitrary degree over a coefficient ring.  The De Rham
complex constructor takes two arguments: a ring, coefRing, and a list
of coordinate variables.

This is the ring of coefficients.

  coefRing := Integer
   Integer
                      Type: Domain

These are the coordinate variables.

  lv : List Symbol := [x,y,z] 
   [x,y,z]
                      Type: List Symbol


This is the De Rham complex of Euclidean three-space using coordinates
x, y and z.

  der := DERHAM(coefRing,lv) 
   DeRhamComplex(Integer,[x,y,z])
                      Type: Domain

This complex allows us to describe differential forms having
expressions of integers as coefficients.  These coefficients can
involve any number of variables, for example, f(x,t,r,y,u,z).  As
we've chosen to work with ordinary Euclidean three-space, expressions
involving these forms are treated as functions of x, y and z with the
additional arguments t, r and u regarded as symbolic constants.

Here are some examples of coefficients.

  R := Expression coefRing
   Expression Integer
                     Type: Domain

  f : R := x**2*y*z-5*x**3*y**2*z**5
       3 2 5    2
   - 5x y z  + x y z
                     Type: Expression Integer

  g : R := z**2*y*cos(z)-7*sin(x**3*y**2)*z**2 
       2     3 2       2
   - 7z sin(x y ) + y z cos(z)
                     Type: Expression Integer

  h : R :=x*y*z-2*x**3*y*z**2 
       3   2
   - 2x y z  + x y z
                     Type: Expression Integer

We now define the multiplicative basis elements for the exterior
algebra over R.

  dx : der := generator(1)
   dx
                     Type: DeRhamComplex(Integer,[x,y,z])

  dy : der := generator(2)
   dy
                     Type: DeRhamComplex(Integer,[x,y,z])

  dz : der := generator(3)
   dz
                     Type: DeRhamComplex(Integer,[x,y,z])

This is an alternative way to give the above assignments.

  [dx,dy,dz] := [generator(i)$der for i in 1..3]
    [dx,dy,dz]
                     Type: List DeRhamComplex(Integer,[x,y,z])

Now we define some one-forms.

  alpha : der := f*dx + g*dy + h*dz
          3   2                   2     3 2       2
     (- 2x y z  + x y z)dz + (- 7z sin(x y ) + y z cos(z))dy
   + 
          3 2 5    2
     (- 5x y z  + x y z)dx
                     Type: DeRhamComplex(Integer,[x,y,z])

  beta  : der := cos(tan(x*y*z)+x*y*z)*dx + x*dy
    x dy + cos(tan(x y z) + x y z)dx
                     Type: DeRhamComplex(Integer,[x,y,z])

A well-known theorem states that the composition of exteriorDifferential 
with itself is the zero map for continuous forms. Let's verify this 
theorem for alpha.

  exteriorDifferential alpha
         2                  3 2                    3 2
     (y z sin(z) + 14z sin(x y ) - 2y z cos(z) - 2x z  + x z)dy dz
   + 
         3 2 4     2   2          2
     (25x y z  - 6x y z  + y z - x y)dx dz
   + 
           2 2 2     3 2       3   5    2
     (- 21x y z cos(x y ) + 10x y z  - x z)dx dy
                      Type: DeRhamComplex(Integer,[x,y,z])

We see a lengthy output of the last expression, but nevertheless, the
composition is zero.

  exteriorDifferential %
    0
                      Type: DeRhamComplex(Integer,[x,y,z])

Now we check that exteriorDifferential is a "graded derivation" D,
that is, D satisfies:

  D(a*b) = D(a)*b + (-1)**degree(a)*a*D(b)

  gamma := alpha * beta
        4   2    2               3   2
     (2x y z  - x y z)dy dz + (2x y z  - x y z)cos(tan(x y z) + x y z)dx dz
   + 
       2     3 2       2                                   4 2 5    3
   ((7z sin(x y ) - y z cos(z))cos(tan(x y z) + x y z) - 5x y z  + x y z)dx dy
                      Type: DeRhamComplex(Integer,[x,y,z])

We try this for the one-forms alpha and beta.

  exteriorDifferential(gamma) - (exteriorDifferential(alpha)*beta - alpha * exteriorDifferential(beta)) 
    0
                      Type: DeRhamComplex(Integer,[x,y,z])

Now we define some "basic operators"

  a : BOP := operator('a)
    a
                      Type: BasicOperator

  b : BOP := operator('b)
    b
                      Type: BasicOperator

  c : BOP := operator('c)
    c
                      Type: BasicOperator

We also define some indeterminate one- and two-forms using these
operators.

  sigma := a(x,y,z) * dx + b(x,y,z) * dy + c(x,y,z) * dz 
    c(x,y,z)dz + b(x,y,z)dy + a(x,y,z)dx
                      Type: DeRhamComplex(Integer,[x,y,z])

  theta  := a(x,y,z) * dx * dy + b(x,y,z) * dx * dz + c(x,y,z) * dy * dz 
    c(x,y,z)dy dz + b(x,y,z)dx dz + a(x,y,z)dx dy
                      Type: DeRhamComplex(Integer,[x,y,z])

This allows us to get formal definitions for the "gradient" ...

  totalDifferential(a(x,y,z))$der 
   (23)  a  (x,y,z)dz + a  (x,y,z)dy + a  (x,y,z)dx
          ,3             ,2             ,1
                      Type: DeRhamComplex(Integer,[x,y,z])
the "curl" ...

  exteriorDifferential sigma
     (c  (x,y,z) - b  (x,y,z))dy dz + (c  (x,y,z) - a  (x,y,z))dx dz
       ,2           ,3                  ,1           ,3
   + 
     (b  (x,y,z) - a  (x,y,z))dx dy
       ,1           ,2
                       Type: DeRhamComplex(Integer,[x,y,z])

and the "divergence."

  exteriorDifferential theta
    (c  (x,y,z) - b  (x,y,z) + a  (x,y,z))dx dy dz
      ,1           ,2           ,3
                       Type: DeRhamComplex(Integer,[x,y,z])

Note that the De Rham complex is an algebra with unity.  This element
1 is the basis for elements for zero-forms, that is, functions in our
space.

  one : der := 1
    1
                       Type: DeRhamComplex(Integer,[x,y,z])

To convert a function to a function lying in the De Rham complex,
multiply the function by "one."

  g1 : der := a([x,t,y,u,v,z,e]) * one 
    a(x,t,y,u,v,z,e)
                       Type: DeRhamComplex(Integer,[x,y,z])

A current limitation of Axiom forces you to write functions with more
than four arguments using square brackets in this way.

  h1 : der := a([x,y,x,t,x,z,y,r,u,x]) * one 
    a(x,y,x,t,x,z,y,r,u,x)
                        Type: DeRhamComplex(Integer,[x,y,z])

Now note how the system keeps track of where your coordinate functions
are located in expressions.

  exteriorDifferential g1 
    a  (x,t,y,u,v,z,e)dz + a  (x,t,y,u,v,z,e)dy + a  (x,t,y,u,v,z,e)dx
     ,6                     ,3                     ,1
                        Type: DeRhamComplex(Integer,[x,y,z])

  exteriorDifferential h1
     a  (x,y,x,t,x,z,y,r,u,x)dz
      ,6
   + 
     (a  (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x))dy
       ,7                         ,2
   + 
         a   (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x)
          ,10                         ,5
       + 
         a  (x,y,x,t,x,z,y,r,u,x) + a  (x,y,x,t,x,z,y,r,u,x)
          ,3                         ,1
    *
       dx
                       Type: DeRhamComplex(Integer,[x,y,z])

In this example of Euclidean three-space, the basis for the De Rham complex
consists of the eight forms: 1, dx, dy, dz, dx*dy, dx*dz, dy*dz, and dx*dy*dz.

  coefficient(gamma, dx*dy)
       2     3 2       2                                   4 2 5    3
    (7z sin(x y ) - y z cos(z))cos(tan(x y z) + x y z) - 5x y z  + x y z
                       Type: Expression Integer

  coefficient(gamma, one)
    0
                       Type: Expression Integer

  coefficient(g1,one)
    a(x,t,y,u,v,z,e)
                       Type: Expression Integer

See Also:
o )help Operator
o )show DeRhamComplex
o $AXIOM/doc/src/algebra/derham.spad.dvi

@
<<domain DERHAM DeRhamComplex>>=
)abbrev domain DERHAM DeRhamComplex
++ Author: Larry A. Lambe
++ Date    : 01/26/91.
++ Revised : 12/01/91.
++
++ based on code from '89 (AntiSymmetric)
++
++ Needs: LeftAlgebra, ExtAlgBasis, FreeMod(Ring,OrderedSet)
++
++ Description: The deRham complex of Euclidean space, that is, the
++ class of differential forms of arbitary degree over a coefficient ring.
++ See Flanders, Harley, Differential Forms, With Applications to the Physical
++ Sciences, New York, Academic Press, 1963.
 
DeRhamComplex(CoefRing,listIndVar:List Symbol): Export == Implement where
  CoefRing :  Join(Ring, OrderedSet)
  ASY     ==> AntiSymm(R,listIndVar)
  DIFRING ==> DifferentialRing
  LALG    ==> LeftAlgebra
  FMR     ==> FreeMod(R,EAB)
  I       ==> Integer
  L       ==> List
  EAB     ==> ExtAlgBasis  -- these are exponents of basis elements in order
  NNI     ==> NonNegativeInteger
  O       ==> OutputForm
  R       ==> Expression(CoefRing)
 
  Export == Join(LALG(R), RetractableTo(R)) with
      leadingCoefficient : %           -> R
	++ leadingCoefficient(df) returns the leading
	++ coefficient of differential form df.
      leadingBasisTerm   : %           -> %
	++ leadingBasisTerm(df) returns the leading
	++ basis term of differential form df.
      reductum           : %           -> %
	++ reductum(df), where df is a differential form, 
        ++ returns df minus the leading
	++ term of df if df has two or more terms, and
	++ 0 otherwise.
      coefficient        : (%,%)     -> R 
	++ coefficient(df,u), where df is a differential form,
        ++ returns the coefficient of df containing the basis term u
        ++ if such a term exists, and 0 otherwise.
      generator          : NNI         -> %
	++ generator(n) returns the nth basis term for a differential form.
      homogeneous?       : %           -> Boolean
	++  homogeneous?(df) tests if all of the terms of 
	++  differential form df have the same degree.
      retractable?       : %           -> Boolean
	++  retractable?(df) tests if differential form df is a 0-form,
	++  i.e., if degree(df) = 0.
      degree             : %           -> I
	++  degree(df) returns the homogeneous degree of differential form df.
      map                : (R -> R, %) -> %
	++  map(f,df) replaces each coefficient x of differential 
        ++  form df by \spad{f(x)}.
      totalDifferential    : R -> %
	++  totalDifferential(x) returns the total differential 
	++  (gradient) form for element x.
      exteriorDifferential : % -> %
	++  exteriorDifferential(df) returns the exterior 
	++  derivative (gradient, curl, divergence, ...) of
	++  the differential form df.

  Implement == ASY add
      Rep := ASY 

      dim := #listIndVar

      totalDifferential(f) ==
        divs:=[differentiate(f,listIndVar.i)*generator(i)$ASY for i in 1..dim]
        reduce("+",divs)

      termDiff : (R, %) -> %
      termDiff(r,e) ==
        totalDifferential(r) * e

      exteriorDifferential(x) ==
        x = 0 => 0
        termDiff(leadingCoefficient(x)$Rep,leadingBasisTerm x) + exteriorDifferential(reductum x)

      lv := [concat("d",string(liv))$String::Symbol for liv in listIndVar]

      displayList:EAB -> O
      displayList(x):O ==
        le: L I := exponents(x)$EAB
--      reduce(_*,[(lv.i)::O for i in 1..dim | le.i = 1])$L(O)
--        reduce(_*,[(lv.i)::O for i in 1..dim | one?(le.i)])$L(O)
        reduce(_*,[(lv.i)::O for i in 1..dim | ((le.i) = 1)])$L(O)

      makeTerm:(R,EAB) -> O
      makeTerm(r,x) ==
      -- we know that r ^= 0
        x = Nul(dim)$EAB  => r::O
--        one? r => displayList(x)
        (r = 1) => displayList(x)
--      r = 1 => displayList(x)
        r::O * displayList(x)

      terms : % -> List Record(k: EAB, c: R)
      terms(a) ==
        -- it is the case that there are at least two terms in a
        a pretend List Record(k: EAB, c: R)
        
      coerce(a):O ==
        a           = 0$Rep => 0$I::O
        ta := terms a
--      reductum(a) = 0$Rep => makeTerm(leadingCoefficient a, a.first.k)
        null ta.rest => makeTerm(ta.first.c, ta.first.k)
        reduce(_+,[makeTerm(t.c,t.k) for t in ta])$L(O)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<category LALG LeftAlgebra>>
<<domain EAB ExtAlgBasis>>
<<domain ANTISYM AntiSymm>>
<<domain DERHAM DeRhamComplex>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
