\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra void.spad}
\author{Stephen M. Watt}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain VOID Void}
<<Void.input>>=
-- void.spad.pamphlet Void.input
)spool Void.output
)set message test on
)set message auto off
)clear all
--S 1
r := (a; b; if c then d else e; f) 
--R 
--R 
--RDaly Bug
--R   An expression following if/when must evaluate to a Boolean and you 
--R      have written one that does not.
--E 1

--S 2
a : Integer
--R 
--R                                                                   Type: Void
--E 2

)set message void on

--S 3
b : Fraction Integer
--R 
--R
--R   (2)  "()"
--R                                                                   Type: Void
--E 3

)set message void off
 
--S 4
3::Void
--R 
--R                                                                   Type: Void
--E 4

--S 5
% :: PositiveInteger
--R 
--R 
--RDaly Bug
--R   Cannot convert from type Void to PositiveInteger for value
--R   "()"
--R
--E 5
)spool
)lisp (bye)
@
<<Void.help>>=
====================================================================
Void examples
====================================================================

When an expression is not in a value context, it is given type Void.
For example, in the expression

  r := (a; b; if c then d else e; f) 

values are used only from the subexpressions c and f: all others are thrown 
away.  The subexpressions a, b, d and e are evaluated for side-effects only 
and have type Void.  There is a unique value of type Void.

You will most often see results of type Void when you declare a variable.

  a : Integer
                                Type: Void

Usually no output is displayed for Void results.  You can force the
display of a rather ugly object by issuing

  )set message void on

  b : Fraction Integer
                                Type: Void

  )set message void off

All values can be converted to type Void.

  3::Void
                                Type: Void

Once a value has been converted to Void, it cannot be recovered.

  % :: PositiveInteger
   Cannot convert from type Void to PositiveInteger for value "()"

See Also:
o )show Void
o $AXIOM/doc/src/algebra/void.spad.dvi

@
<<domain VOID Void>>=
)abbrev domain VOID Void
-- These types act as the top and bottom of the type lattice
-- and are known to the compiler and interpreter for type resolution.
++ Author: Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations: 
++ Related Domains: ErrorFunctions, ResolveLatticeCompletion, Exit
++ Also See:
++ AMS Classifications:
++ Keywords: type, mode, coerce, no value
++ Examples:
++ References:
++ Description:
++   This type is used when no value is needed, e.g., in the \spad{then}
++   part of a one armed \spad{if}.
++   All values can be coerced to type Void.  Once a value has been coerced
++   to Void, it cannot be recovered.

Void: with
        void: () -> %            ++ void() produces a void object.
        coerce: % -> OutputForm  ++ coerce(v) coerces void object to outputForm.
    == add
        Rep := String
        void()      == voidValue()$Lisp
        coerce(v:%) == coerce(v)$Rep

@
\section{domain EXIT Exit}
<<Exit.input>>=
-- void.spad.pamphlet Exit.input
)spool Exit.output
)set message test on
)set message auto off
)clear all
--S 1
n := 0
--R 
--R
--R   (1)  0
--R                                                     Type: NonNegativeInteger
--E 1

--S 2
gasp(): Exit ==
  free n
  n := n + 1
  error "Oh no!"
--R 
--R   Function declaration gasp : () -> Exit has been added to workspace.
--R                                                                   Type: Void
--E 2

--S 3
half(k) ==
  if odd? k then gasp()
  else k quo 2
--R 
--R                                                                   Type: Void
--E 3

--S 4
half 4
--R 
--R   Compiling function gasp with type () -> Exit 
--R   Compiling function half with type PositiveInteger -> Integer 
--R
--R   (4)  2
--R                                                        Type: PositiveInteger
--E 4

--S 5
half 3
--R 
--R 
--RDaly Bug
--R   Error signalled from user code in function gasp: 
--R      Oh no!
--E 5

--S 6
n
--R 
--R
--R   (5)  1
--R                                                     Type: NonNegativeInteger
--E 6
)spool
)lisp (bye)
@
<<Exit.help>>=
====================================================================
Exit examples
====================================================================

A function that does not return directly to its caller has Exit as its
return type.  The operation error is an example of one which does not
return to its caller.  Instead, it causes a return to top-level.

  n := 0

The function gasp is given return type Exit since it is guaranteed
never to return a value to its caller.

  gasp(): Exit ==
    free n
    n := n + 1
    error "Oh no!"
 
The return type of half is determined by resolving the types of the
two branches of the if.

  half(k) ==
    if odd? k then gasp()
    else k quo 2

Because gasp has the return type Exit, the type of if in half is
resolved to be Integer.

  half 4

  half 3

  n

See Also:
o )show Exit
o $AXIOM/doc/src/algebra/void.spad.dvi

@
<<domain EXIT Exit>>=
)abbrev domain EXIT Exit
++ Author: Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations: 
++ Related Domains: ErrorFunctions, ResolveLatticeCompletion, Void
++ Also See:
++ AMS Classifications:
++ Keywords: exit, throw, error, non-local return
++ Examples:
++ References:
++ Description:
++   A function which does not return directly to its caller should
++   have Exit as its return type.
++
++   Note: It is convenient to have a formal \spad{coerce} into each type from
++   type Exit. This allows, for example, errors to be raised in 
++   one half of a type-balanced \spad{if}.
Exit: SetCategory == add
        coerce(n:%) == error "Cannot use an Exit value."
        n1 = n2     == error "Cannot use an Exit value."

@
\section{package RESLATC ResolveLatticeCompletion}
<<package RESLATC ResolveLatticeCompletion>>=
)abbrev package RESLATC ResolveLatticeCompletion
++ Author: Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations: 
++ Related Domains: ErrorFunctions, Exit, Void
++ Also See:
++ AMS Classifications:
++ Keywords: mode, resolve, type lattice
++ Examples:
++ References:
++ Description:
++   This package provides coercions for the special types \spadtype{Exit}
++   and \spadtype{Void}.
ResolveLatticeCompletion(S: Type): with
        coerce: S -> Void 
             ++ coerce(s) throws all information about s away.
             ++ This coercion allows values of any type to appear
             ++ in contexts where they will not be used.
             ++ For example, it allows the resolution of different types in
             ++ the \spad{then} and \spad{else} branches when an \spad{if}
             ++ is in a context where the resulting value is not used.
        coerce: Exit -> S
             ++ coerce(e) is never really evaluated.  This coercion is 
             ++ used for formal type correctness when a function will not
             ++ return directly to its caller.
    == add
        coerce(s: S): Void == void()
        coerce(e: Exit): S ==
            error "Bug: Should not be able to obtain value of type Exit"

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
 
<<domain VOID Void>>
<<domain EXIT Exit>>
<<package RESLATC ResolveLatticeCompletion>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
