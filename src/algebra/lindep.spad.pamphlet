\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra lindep.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package LINDEP LinearDependence}
<<package LINDEP LinearDependence>>=
)abbrev package LINDEP LinearDependence
++ Test for linear dependence
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Test for linear dependence.
LinearDependence(S, R): Exports == Implementation where
  S: IntegralDomain
  R: LinearlyExplicitRingOver S

  Q ==> Fraction S

  Exports ==> with
    linearlyDependent?: Vector R -> Boolean
      ++ \spad{linearlyDependent?([v1,...,vn])} returns true if
      ++ the vi's are linearly dependent over S, false otherwise.
    linearDependence  : Vector R -> Union(Vector S, "failed")
      ++ \spad{linearDependence([v1,...,vn])} returns \spad{[c1,...,cn]} if
      ++ \spad{c1*v1 + ... + cn*vn = 0} and not all the ci's are 0,
      ++ "failed" if the vi's are linearly independent over S.
    if S has Field then
      solveLinear: (Vector R, R) -> Union(Vector S, "failed")
        ++ \spad{solveLinear([v1,...,vn], u)} returns \spad{[c1,...,cn]}
        ++ such that \spad{c1*v1 + ... + cn*vn = u},
        ++ "failed" if no such ci's exist in S.
    else
      solveLinear: (Vector R, R) -> Union(Vector Q, "failed")
        ++ \spad{solveLinear([v1,...,vn], u)} returns \spad{[c1,...,cn]}
        ++ such that \spad{c1*v1 + ... + cn*vn = u},
        ++ "failed" if no such ci's exist in the quotient field of S.

  Implementation ==> add
    aNonZeroSolution: Matrix S -> Union(Vector S, "failed")

    aNonZeroSolution m ==
      every?(zero?, v := first nullSpace m) => "failed"
      v

    linearlyDependent? v ==
      zero?(n := #v) => true
--      one? n => zero?(v(minIndex v))
      (n = 1) => zero?(v(minIndex v))
      positive? nullity reducedSystem transpose v

    linearDependence v ==
      zero?(n := #v) => empty()
--      one? n =>
      (n = 1) =>
        zero?(v(minIndex v)) => new(1, 1)
        "failed"
      aNonZeroSolution reducedSystem transpose v

    if S has Field then
      solveLinear(v:Vector R, c:R):Union(Vector S, "failed") ==
        zero? c => new(#v, 0)
        empty? v => "failed"
        sys := reducedSystem(transpose v, new(1, c))
        particularSolution(sys.mat, sys.vec)$LinearSystemMatrixPackage(S,
                                           Vector S, Vector S, Matrix S)

    else
      solveLinear(v:Vector R, c:R):Union(Vector Q, "failed") ==
        zero? c => new(#v, 0)
        empty? v => "failed"
        sys := reducedSystem(transpose v, new(1, c))
        particularSolution(map(#1::Q, sys.mat)$MatrixCategoryFunctions2(S,
               Vector S,Vector S,Matrix S,Q,Vector Q,Vector Q,Matrix Q),
                  map(#1::Q, sys.vec)$VectorFunctions2(S, Q)
                                    )$LinearSystemMatrixPackage(Q,
                                           Vector Q, Vector Q, Matrix Q)

@
\section{package ZLINDEP IntegerLinearDependence}
<<IntegerLinearDependence.input>>=
-- lindep.spad.pamphlet IntegerLinearDependence.input
)spool IntegerLinearDependence.output
)set message test on
)set message auto off
)clear all
--S 1
M := SQMATRIX(2,INT)
--R 
--R
--R   (1)  SquareMatrix(2,Integer)
--R                                                                 Type: Domain
--E 1

--S 2
m1: M := squareMatrix matrix [ [1, 2], [0, -1] ]
--R 
--R
--R        +1   2 +
--R   (2)  |      |
--R        +0  - 1+
--R                                                Type: SquareMatrix(2,Integer)
--E 2

--S 3
m2: M := squareMatrix matrix [ [2, 3], [1, -2] ]
--R 
--R
--R        +2   3 +
--R   (3)  |      |
--R        +1  - 2+
--R                                                Type: SquareMatrix(2,Integer)
--E 3

--S 4
m3: M := squareMatrix matrix [ [3, 4], [2, -3] ]
--R 
--R
--R        +3   4 +
--R   (4)  |      |
--R        +2  - 3+
--R                                                Type: SquareMatrix(2,Integer)
--E 4

--S 5
linearlyDependentOverZ? vector [m1, m2, m3]
--R 
--R
--R   (5)  true
--R                                                                Type: Boolean
--E 5

--S 6
c := linearDependenceOverZ vector [m1, m2, m3]
--R 
--R
--R   (6)  [1,- 2,1]
--R                                              Type: Union(Vector Integer,...)
--E 6

--S 7
c.1 * m1 + c.2 * m2 + c.3 * m3
--R 
--R
--R        +0  0+
--R   (7)  |    |
--R        +0  0+
--R                                                Type: SquareMatrix(2,Integer)
--E 7

--S 8
solveLinearlyOverQ(vector [m1, m3], m2)
--R 
--R
--R         1 1
--R   (8)  [-,-]
--R         2 2
--R                                     Type: Union(Vector Fraction Integer,...)
--E 8
)spool
)lisp (bye)
@
<<IntegerLinearDependence.help>>=
====================================================================
IntegerLinearDependence examples
====================================================================

The elements v1,...,vN of a module M over a ring R are said to be 
linearly dependent over R if there exist c1,...,cN in R, not all 0, 
such that c1 v1 + ...  cN vNn = 0.  If such ci's exist, they form 
what is called a linear dependence relation over R for the vi's.

The package IntegerLinearDependence provides functions for testing
whether some elements of a module over the integers are linearly
dependent over the integers, and to find the linear dependence
relations, if any.

Consider the domain of two by two square matrices with integer entries.

  M := SQMATRIX(2,INT)
    SquareMatrix(2,Integer)
                      Type: Domain

Now create three such matrices.

  m1: M := squareMatrix matrix [ [1, 2], [0, -1] ]
     +1   2 +
     |      |
     +0  - 1+
                      Type: SquareMatrix(2,Integer)

  m2: M := squareMatrix matrix [ [2, 3], [1, -2] ]
    +2   3 +
    |      |
    +1  - 2+
                      Type: SquareMatrix(2,Integer)

  m3: M := squareMatrix matrix [ [3, 4], [2, -3] ]
    +3   4 +
    |      |
    +2  - 3+
                      Type: SquareMatrix(2,Integer)

This tells you whether m1, m2 and m3 are linearly dependent over the integers.

  linearlyDependentOverZ? vector [m1, m2, m3]
    true
                      Type: Boolean

Since they are linearly dependent, you can ask for the dependence relation.

  c := linearDependenceOverZ vector [m1, m2, m3]
    [1,- 2,1]
                      Type: Union(Vector Integer,...)

This means that the following linear combination should be 0.

  c.1 * m1 + c.2 * m2 + c.3 * m3
    +0  0+
    |    |
    +0  0+
                      Type: SquareMatrix(2,Integer)

When a given set of elements are linearly dependent over R, this also 
means that at least one of them can be rewritten as a linear combination 
of the others with coefficients in the quotient field of R.

To express a given element in terms of other elements, use the operation
solveLinearlyOverQ.

  solveLinearlyOverQ(vector [m1, m3], m2)
     1 1
    [-,-]
     2 2
                      Type: Union(Vector Fraction Integer,...)

See Also:
o )show IntegerLinearDependence
o $AXIOM/doc/src/algebra/lindep.spad.dvi

@
<<package ZLINDEP IntegerLinearDependence>>=
)abbrev package ZLINDEP IntegerLinearDependence
++ Test for linear dependence over the integers
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Test for linear dependence over the integers.
IntegerLinearDependence(R): Exports == Implementation where
  R: LinearlyExplicitRingOver Integer

  Z ==> Integer

  Exports ==> with
    linearlyDependentOverZ?: Vector R -> Boolean
      ++ \spad{linearlyDependentOverZ?([v1,...,vn])} returns true if the
      ++ vi's are linearly dependent over the integers, false otherwise.
    linearDependenceOverZ  : Vector R -> Union(Vector Z, "failed")
      ++ \spad{linearlyDependenceOverZ([v1,...,vn])} returns
      ++ \spad{[c1,...,cn]} if
      ++ \spad{c1*v1 + ... + cn*vn = 0} and not all the ci's are 0, "failed"
      ++ if the vi's are linearly independent over the integers.
    solveLinearlyOverQ     : (Vector R, R) ->
                                      Union(Vector Fraction Z, "failed")
      ++ \spad{solveLinearlyOverQ([v1,...,vn], u)} returns \spad{[c1,...,cn]}
      ++ such that \spad{c1*v1 + ... + cn*vn = u},
      ++ "failed" if no such rational numbers ci's exist.

  Implementation ==> add
    import LinearDependence(Z, R)

    linearlyDependentOverZ? v == linearlyDependent? v
    linearDependenceOverZ   v == linearDependence v
    solveLinearlyOverQ(v, c)  == solveLinear(v, c)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package LINDEP LinearDependence>>
<<package ZLINDEP IntegerLinearDependence>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
