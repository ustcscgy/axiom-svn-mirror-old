\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra array1.spad}
\author{Michael Monagan, Stephen Watt}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain PRIMARR PrimitiveArray}
<<domain PRIMARR PrimitiveArray>>=
)abbrev domain PRIMARR PrimitiveArray
++ This provides a fast array type with no bound checking on elt's.
++ Minimum index is 0 in this type, cannot be changed
PrimitiveArray(S:Type): OneDimensionalArrayAggregate S == add
   Qmax ==> QVMAXINDEX$Lisp
   Qsize ==> QVSIZE$Lisp
--   Qelt ==> QVELT$Lisp
--   Qsetelt ==> QSETVELT$Lisp
   Qelt ==> ELT$Lisp
   Qsetelt ==> SETELT$Lisp
   Qnew ==> GETREFV$Lisp

   #x                          == Qsize x
   minIndex x                  == 0
   empty()                     == Qnew(0$Lisp)
   new(n, x)                   == fill_!(Qnew n, x)
   qelt(x, i)                  == Qelt(x, i)
   elt(x:%, i:Integer)         == Qelt(x, i)
   qsetelt_!(x, i, s)          == Qsetelt(x, i, s)
   setelt(x:%, i:Integer, s:S) == Qsetelt(x, i, s)
   fill_!(x, s)       == (for i in 0..Qmax x repeat Qsetelt(x, i, s); x)

@
\section{PRIMARR.lsp BOOTSTRAP} 
{\bf PRIMARR} depends on itself.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf PRIMARR} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf PRIMARR.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<PRIMARR.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(PUT (QUOTE |PRIMARR;#;$Nni;1|) (QUOTE |SPADreplace|) (QUOTE QVSIZE)) 

(DEFUN |PRIMARR;#;$Nni;1| (|x| |$|) (QVSIZE |x|)) 

(PUT (QUOTE |PRIMARR;minIndex;$I;2|)
 (QUOTE |SPADreplace|) (QUOTE (XLAM (|x|) 0))) 

(DEFUN |PRIMARR;minIndex;$I;2| (|x| |$|) 0) 

(PUT (QUOTE |PRIMARR;empty;$;3|)
 (QUOTE |SPADreplace|) (QUOTE (XLAM NIL (GETREFV 0)))) 

(DEFUN |PRIMARR;empty;$;3| (|$|) (GETREFV 0)) 

(DEFUN |PRIMARR;new;NniS$;4| (|n| |x| |$|)
 (SPADCALL (GETREFV |n|) |x| (QREFELT |$| 12))) 

(PUT (QUOTE |PRIMARR;qelt;$IS;5|) (QUOTE |SPADreplace|) (QUOTE ELT)) 

(DEFUN |PRIMARR;qelt;$IS;5| (|x| |i| |$|) (ELT |x| |i|)) 

(PUT (QUOTE |PRIMARR;elt;$IS;6|) (QUOTE |SPADreplace|) (QUOTE ELT)) 

(DEFUN |PRIMARR;elt;$IS;6| (|x| |i| |$|) (ELT |x| |i|)) 

(PUT (QUOTE |PRIMARR;qsetelt!;$I2S;7|) (QUOTE |SPADreplace|) (QUOTE SETELT)) 

(DEFUN |PRIMARR;qsetelt!;$I2S;7| (|x| |i| |s| |$|) (SETELT |x| |i| |s|)) 

(PUT (QUOTE |PRIMARR;setelt;$I2S;8|) (QUOTE |SPADreplace|) (QUOTE SETELT)) 

(DEFUN |PRIMARR;setelt;$I2S;8| (|x| |i| |s| |$|) (SETELT |x| |i| |s|)) 

(DEFUN |PRIMARR;fill!;$S$;9| (|x| |s| |$|)
 (PROG (|i| #1=#:G82338)
  (RETURN
   (SEQ
    (SEQ
     (LETT |i| 0 |PRIMARR;fill!;$S$;9|)
     (LETT #1# (QVMAXINDEX |x|) |PRIMARR;fill!;$S$;9|)
     G190
     (COND ((QSGREATERP |i| #1#) (GO G191)))
     (SEQ (EXIT (SETELT |x| |i| |s|)))
     (LETT |i| (QSADD1 |i|) |PRIMARR;fill!;$S$;9|)
     (GO G190)
     G191
    (EXIT NIL))
   (EXIT |x|)))))

(DEFUN |PrimitiveArray| (#1=#:G82348)
 (PROG NIL
  (RETURN 
   (PROG (#2=#:G82349)
    (RETURN
     (COND
      ((LETT #2# 
        (|lassocShiftWithFunction|
          (LIST (|devaluate| #1#))
          (HGET |$ConstructorCache| (QUOTE |PrimitiveArray|))
          (QUOTE |domainEqualList|))
         |PrimitiveArray|)
        (|CDRwithIncrement| #2#))
      ((QUOTE T)
        (|UNWIND-PROTECT|
         (PROG1
          (|PrimitiveArray;| #1#)
          (LETT #2# T |PrimitiveArray|))
         (COND
          ((NOT #2#)
            (HREM |$ConstructorCache| (QUOTE |PrimitiveArray|)))))))))))) 

(DEFUN |PrimitiveArray;| (|#1|)
 (PROG (|DV$1| |dv$| |$| #1=#:G82347 |pv$|)
  (RETURN
   (PROGN 
    (LETT |DV$1| (|devaluate| |#1|) . #2=(|PrimitiveArray|))
    (LETT |dv$| (LIST (QUOTE |PrimitiveArray|) |DV$1|) . #2#)
    (LETT |$| (GETREFV 35) . #2#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0
       (LIST 
        (|HasCategory| |#1| (QUOTE (|SetCategory|)))
        (|HasCategory| |#1| (QUOTE (|ConvertibleTo| (|InputForm|))))
        (LETT #1# (|HasCategory| |#1| (QUOTE (|OrderedSet|))) . #2#)
        (OR #1# (|HasCategory| |#1| (QUOTE (|SetCategory|))))
        (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))
        (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
             (|HasCategory| |#1| (QUOTE (|SetCategory|))))
        (OR 
         (AND 
          (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
          #1#)
         (AND
          (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
          (|HasCategory| |#1| (QUOTE (|SetCategory|)))))))
      . #2#))
    (|haddProp| |$ConstructorCache|
     (QUOTE |PrimitiveArray|) (LIST |DV$1|) (CONS 1 |$|))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    |$|)))) 

(MAKEPROP (QUOTE |PrimitiveArray|) (QUOTE |infovec|)
 (LIST 
  (QUOTE
   #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|NonNegativeInteger|)
     |PRIMARR;#;$Nni;1| (|Integer|) |PRIMARR;minIndex;$I;2|
     |PRIMARR;empty;$;3| |PRIMARR;fill!;$S$;9| |PRIMARR;new;NniS$;4|
     |PRIMARR;qelt;$IS;5| |PRIMARR;elt;$IS;6| |PRIMARR;qsetelt!;$I2S;7|
     |PRIMARR;setelt;$I2S;8| (|Mapping| 6 6 6) (|Boolean|) (|List| 6)
     (|Equation| 6) (|List| 21) (|Mapping| 19 6) (|Mapping| 19 6 6)
     (|UniversalSegment| 9) (|Void|) (|Mapping| 6 6) (|InputForm|)
     (|OutputForm|) (|String|) (|SingleInteger|) (|List| |$|)
     (|Union| 6 (QUOTE "failed")) (|List| 9)))
  (QUOTE
   #(|~=| 0 |swap!| 6 |sorted?| 13 |sort!| 24 |sort| 35 |size?| 46 |setelt|
     52 |select| 66 |sample| 72 |reverse!| 76 |reverse| 81 |removeDuplicates|
     86 |remove| 91 |reduce| 103 |qsetelt!| 124 |qelt| 131 |position| 137
     |parts| 156 |new| 161 |more?| 167 |minIndex| 173 |min| 178 |merge| 184
     |members| 197 |member?| 202 |maxIndex| 208 |max| 213 |map!| 219 |map|
     225 |less?| 238 |latex| 244 |insert| 249 |indices| 263 |index?| 268
     |hash| 274 |first| 279 |find| 284 |fill!| 290 |every?| 296 |eval| 302
     |eq?| 328 |entry?| 334 |entries| 340 |empty?| 345 |empty| 350 |elt| 354
     |delete| 373 |count| 385 |copyInto!| 397 |copy| 404 |convert| 409
     |construct| 414 |concat| 419 |coerce| 442 |any?| 447 |>=| 453 |>| 459
     |=| 465 |<=| 471 |<| 477 |#| 483))
 (QUOTE ((|shallowlyMutable| . 0) (|finiteAggregate| . 0)))
 (CONS 
   (|makeByteWordVec2| 7 (QUOTE (0 0 0 0 0 0 3 0 0 7 4 0 0 7 1 2 4)))
   (CONS
    (QUOTE #(|OneDimensionalArrayAggregate&| |FiniteLinearAggregate&|
     |LinearAggregate&| |IndexedAggregate&| |Collection&|
     |HomogeneousAggregate&| |OrderedSet&| |Aggregate&| |EltableAggregate&|
     |Evalable&| |SetCategory&| NIL NIL |InnerEvalable&| NIL NIL |BasicType&|))
    (CONS
     (QUOTE
      #((|OneDimensionalArrayAggregate| 6) (|FiniteLinearAggregate| 6)
        (|LinearAggregate| 6) (|IndexedAggregate| 9 6) (|Collection| 6)
        (|HomogeneousAggregate| 6) (|OrderedSet|) (|Aggregate|)
        (|EltableAggregate| 9 6) (|Evalable| 6) (|SetCategory|) (|Type|)
        (|Eltable| 9 6) (|InnerEvalable| 6 6) (|CoercibleTo| 29)
        (|ConvertibleTo| 28) (|BasicType|)))
     (|makeByteWordVec2| 34 
      (QUOTE
       (2 1 19 0 0 1 3 0 26 0 9 9 1 1 3 19 0 1 2 0 19 24 0 1 1 3 0 0 1 2 0 0
        24 0 1 1 3 0 0 1 2 0 0 24 0 1 2 0 19 0 7 1 3 0 6 0 25 6 1 3 0 6 0 9
        6 17 2 0 0 23 0 1 0 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 1 2 1 0 6 0 1
        2 0 0 23 0 1 4 1 6 18 0 6 6 1 3 0 6 18 0 6 1 2 0 6 18 0 1 3 0 6 0 9
        6 16 2 0 6 0 9 14 2 1 9 6 0 1 3 1 9 6 0 9 1 2 0 9 23 0 1 1 0 20 0 1
        2 0 0 7 6 13 2 0 19 0 7 1 1 5 9 0 10 2 3 0 0 0 1 2 3 0 0 0 1 3 0 0
        24 0 0 1 1 0 20 0 1 2 1 19 6 0 1 1 5 9 0 1 2 3 0 0 0 1 2 0 0 27 0 1
        3 0 0 18 0 0 1 2 0 0 27 0 1 2 0 19 0 7 1 1 1 30 0 1 3 0 0 0 0 9 1 3
        0 0 6 0 9 1 1 0 34 0 1 2 0 19 9 0 1 1 1 31 0 1 1 5 6 0 1 2 0 33 23
        0 1 2 0 0 0 6 12 2 0 19 23 0 1 3 6 0 0 20 20 1 2 6 0 0 21 1 3 6 0 0
        6 6 1 2 6 0 0 22 1 2 0 19 0 0 1 2 1 19 6 0 1 1 0 20 0 1 1 0 19 0 1
        0 0 0 11 2 0 0 0 25 1 2 0 6 0 9 15 3 0 6 0 9 6 1 2 0 0 0 9 1 2 0 0
        0 25 1 2 1 7 6 0 1 2 0 7 23 0 1 3 0 0 0 0 9 1 1 0 0 0 1 1 2 28 0 1
        1 0 0 20 1 1 0 0 32 1 2 0 0 6 0 1 2 0 0 0 0 1 2 0 0 0 6 1 1 1 29 0
        1 2 0 19 23 0 1 2 3 19 0 0 1 2 3 19 0 0 1 2 1 19 0 0 1 2 3 19 0 0 1
        2 3 19 0 0 1 1 0 7 0 8))))))
 (QUOTE |lookupComplete|))) 
@
\section{package PRIMARR2 PrimitiveArrayFunctions2}
<<package PRIMARR2 PrimitiveArrayFunctions2>>=
)abbrev package PRIMARR2 PrimitiveArrayFunctions2
++ This package provides tools for operating on primitive arrays
++ with unary and binary functions involving different underlying types
PrimitiveArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> PrimitiveArray A
  VB ==> PrimitiveArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)
  Exports ==> with
   scan : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of primitive array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++E adder(a:Integer,b:Integer):Integer == a+b
    ++E scan(adder,[i for i in 1..10],0)$T1
   
   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ primitive array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++E adder(a:Integer,b:Integer):Integer == a+b
    ++E reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of primitive array
    ++ \spad{a} resulting in a new primitive array over a
    ++ possibly different underlying domain.
    ++
    ++E T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++E map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
\section{domain TUPLE Tuple}
<<domain TUPLE Tuple>>=
)abbrev domain TUPLE Tuple
++ This domain is used to interface with the interpreter's notion
++ of comma-delimited sequences of values.
Tuple(S:Type): CoercibleTo(PrimitiveArray S) with
  coerce: PrimitiveArray S -> %
   ++ coerce(a) makes a tuple from primitive array a
   ++
   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++E t2:=coerce(t1)$Tuple(Integer)

  select: (%, NonNegativeInteger) -> S
   ++ select(x,n) returns the n-th element of tuple x.
   ++ tuples are 0-based
   ++
   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++E t2:=coerce(t1)$Tuple(Integer)
   ++E select(t2,3)

  length: % -> NonNegativeInteger
   ++ length(x) returns the number of elements in tuple x
   ++
   ++E t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++E t2:=coerce(t1)$Tuple(Integer)
   ++E length(t2)

  if S has SetCategory then SetCategory
 == add
  Rep := Record(len : NonNegativeInteger, elts : PrimitiveArray S)

  coerce(x: PrimitiveArray S): %  == [#x, x]
  coerce(x:%): PrimitiveArray(S) == x.elts
  length x == x.len

  select(x, n) ==
    n >= x.len => error "Index out of bounds"
    x.elts.n

  if S has SetCategory then
    x = y == (x.len = y.len) and (x.elts =$PrimitiveArray(S) y.elts)
    coerce(x : %): OutputForm ==
      paren [(x.elts.i)::OutputForm
             for i in minIndex x.elts .. maxIndex x.elts]$List(OutputForm)

@
\section{domain IFARRAY IndexedFlexibleArray}
<<domain IFARRAY IndexedFlexibleArray>>=
)abbrev domain IFARRAY IndexedFlexibleArray
++ Author: Michael Monagan July/87, modified SMW June/91
++ A FlexibleArray is the notion of an array intended to allow for growth
++ at the end only.  Hence the following efficient operations
++   \spad{append(x,a)} meaning append item x at the end of the array \spad{a}
++   \spad{delete(a,n)} meaning delete the last item from the array \spad{a}
++ Flexible arrays support the other operations inherited from
++ \spadtype{ExtensibleLinearAggregate}. However, these are not efficient.
++ Flexible arrays combine the \spad{O(1)} access time property of arrays
++ with growing and shrinking at the end in \spad{O(1)} (average) time.
++ This is done by using an ordinary array which may have zero or more
++ empty slots at the end.  When the array becomes full it is copied
++ into a new larger (50% larger) array.  Conversely, when the array
++ becomes less than 1/2 full, it is copied into a smaller array.
++ Flexible arrays provide for an efficient implementation of many
++ data structures in particular heaps, stacks and sets.

IndexedFlexibleArray(S:Type, mn: Integer): Exports == Implementation where
  A ==> PrimitiveArray S
  I ==> Integer
  N ==> NonNegativeInteger
  U ==> UniversalSegment Integer
  Exports ==
   Join(OneDimensionalArrayAggregate S,ExtensibleLinearAggregate S) with
    flexibleArray : List S -> %
     ++ flexibleArray(l) creates a flexible array from the list of elements l
     ++
     ++E T1:=IndexedFlexibleArray(Integer,20)
     ++E flexibleArray([i for i in 1..10])$T1

    physicalLength : % -> NonNegativeInteger
     ++ physicalLength(x) returns the number of elements x can 
     ++ accomodate before growing
     ++
     ++E T1:=IndexedFlexibleArray(Integer,20)
     ++E t2:=flexibleArray([i for i in 1..10])$T1
     ++E physicalLength t2

    physicalLength_!: (%, I) -> %
     ++ physicalLength!(x,n) changes the physical length of x to be n and
     ++ returns the new array.
     ++
     ++E T1:=IndexedFlexibleArray(Integer,20)
     ++E t2:=flexibleArray([i for i in 1..10])$T1
     ++E physicalLength!(t2,15)

    shrinkable: Boolean -> Boolean
     ++ shrinkable(b) sets the shrinkable attribute of flexible arrays to b
     ++ and returns the previous value
     ++
     ++E T1:=IndexedFlexibleArray(Integer,20)
     ++E shrinkable(false)$T1

  Implementation == add
    Rep := Record(physLen:I, logLen:I, f:A)
    shrinkable? : Boolean := true
    growAndFill : (%, I, S) -> %
    growWith    : (%, I, S) -> %
    growAdding  : (%, I, %) -> %
    shrink: (%, I)    -> %
    newa  : (N, A) -> A

    physicalLength(r) == (r.physLen) pretend NonNegativeInteger
    physicalLength_!(r, n) ==
       r.physLen = 0  => error "flexible array must be non-empty"
       growWith(r, n, r.f.0)

    empty()      == [0, 0, empty()]
    #r           == (r.logLen)::N
    fill_!(r, x) == (fill_!(r.f, x); r)
    maxIndex r   == r.logLen - 1 + mn
    minIndex r   == mn
    new(n, a)    == [n, n, new(n, a)]

    shrinkable(b) ==
      oldval := shrinkable?
      shrinkable? := b
      oldval

    flexibleArray l ==
       n := #l
       n = 0 => empty()
       x := l.1
       a := new(n,x)
       for i in mn + 1..mn + n-1 for y in rest l repeat a.i := y
       a

    -- local utility operations
    newa(n, a) ==
       zero? n => empty()
       new(n, a.0)

    growAdding(r, b, s) ==
       b = 0 => r
       #r > 0 => growAndFill(r, b, (r.f).0)
       #s > 0 => growAndFill(r, b, (s.f).0)
       error "no default filler element"

    growAndFill(r, b, x) ==
       (r.logLen := r.logLen + b) <= r.physLen => r
       -- enlarge by 50% + b
       n := r.physLen + r.physLen quo 2 + 1
       if r.logLen > n then n := r.logLen
       growWith(r, n, x)

    growWith(r, n, x) ==
       y := new(n::N, x)$PrimitiveArray(S)
       a := r.f
       for k in 0 .. r.physLen-1 repeat y.k := a.k
       r.physLen := n
       r.f := y
       r

    shrink(r, i) ==
       r.logLen := r.logLen - i
       negative?(n := r.logLen) => error "internal bug in flexible array"
       2*n+2 > r.physLen => r
       not shrinkable? => r
       if n < r.logLen 
         then error "cannot shrink flexible array to indicated size"
       n = 0 => empty()
       r.physLen := n
       y := newa(n::N, a := r.f)
       for k in 0 .. n-1 repeat y.k := a.k
       r.f := y
       r

    copy r ==
       n := #r
       a := r.f
       v := newa(n, a := r.f)
       for k in 0..n-1 repeat v.k := a.k
       [n, n, v]


    elt(r:%, i:I) ==
       i < mn or i >= r.logLen + mn =>
           error "index out of range"
       r.f.(i-mn)

    setelt(r:%, i:I, x:S) ==
       i < mn or i >= r.logLen + mn =>
           error "index out of range"
       r.f.(i-mn) := x

    -- operations inherited from extensible aggregate
    merge(g, a, b)   == merge_!(g, copy a, b)
    concat(x:S, r:%) == insert_!(x, r, mn)

    concat_!(r:%, x:S) ==
       growAndFill(r, 1, x)
       r.f.(r.logLen-1) := x
       r

    concat_!(a:%, b:%) ==
       if eq?(a, b) then b := copy b
       n := #a
       growAdding(a, #b, b)
       copyInto_!(a, b, n + mn)

    remove_!(g:(S->Boolean), a:%) ==
       k:I := 0
       for i in 0..maxIndex a - mn repeat
          if not g(a.i) then (a.k := a.i; k := k+1)
       shrink(a, #a - k)

    delete_!(r:%, i1:I) ==
       i := i1 - mn
       i < 0 or i > r.logLen => error "index out of range"
       for k in i..r.logLen-2 repeat r.f.k := r.f.(k+1)
       shrink(r, 1)

    delete_!(r:%, i:U) ==
       l := lo i - mn; m := maxIndex r - mn
       h := (hasHi i => hi i - mn; m)
       l < 0 or h > m => error "index out of range"
       for j in l.. for k in h+1..m repeat r.f.j := r.f.k
       shrink(r, max(0,h-l+1))

    insert_!(x:S, r:%, i1:I):% ==
       i := i1 - mn
       n := r.logLen
       i < 0 or i > n => error "index out of range"
       growAndFill(r, 1, x)
       for k in n-1 .. i by -1 repeat r.f.(k+1) := r.f.k
       r.f.i := x
       r

    insert_!(a:%, b:%, i1:I):% ==
       i := i1 - mn
       if eq?(a, b) then b := copy b
       m := #a; n := #b
       i < 0 or i > n => error "index out of range"
       growAdding(b, m, a)
       for k in n-1 .. i by -1 repeat b.f.(m+k) := b.f.k
       for k in m-1 .. 0 by -1 repeat b.f.(i+k) := a.f.k
       b

    merge_!(g, a, b) ==
       m := #a; n := #b; growAdding(a, n, b)
       for i in m-1..0 by -1 for j in m+n-1.. by -1 repeat a.f.j := a.f.i
       i := n; j := 0
       for k in 0.. while i < n+m and j < n repeat
          if g(a.f.i,b.f.j) then (a.f.k := a.f.i; i := i+1)
          else (a.f.k := b.f.j; j := j+1)
       for k in k.. for j in j..n-1 repeat a.f.k := b.f.j
       a

    select_!(g:(S->Boolean), a:%) ==
       k:I := 0
       for i in 0..maxIndex a - mn repeat if g(a.f.i) then (a.f.k := a.f.i;k := k+1)
       shrink(a, #a - k)

    if S has SetCategory then
      removeDuplicates_! a ==
         ct := #a
         ct < 2 => a

         i     := mn
         nlim  := mn + ct
         nlim0 := nlim
         while i < nlim repeat
            j := i+1
            for k in j..nlim-1 | a.k ^= a.i repeat
                a.j := a.k
                j := j+1
            nlim := j
            i := i+1
         nlim ^= nlim0 => delete_!(a, i..)
         a

@
\section{domain FARRAY FlexibleArray}
<<FlexibleArray.input>>=
-- array1.spad.pamphlet FlexibleArray.input
)spool FlexibleArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 16
flexibleArray [i for i in 1..6]
--R 
--R
--R   (1)  [1,2,3,4,5,6]
--R                                          Type: FlexibleArray PositiveInteger
--E 1

--S 2 of 16
f : FARRAY INT := new(6,0)
--R 
--R
--R   (2)  [0,0,0,0,0,0]
--R                                                  Type: FlexibleArray Integer
--E 2

--S 3 of 16
for i in 1..6 repeat f.i := i; f
--R 
--R
--R   (3)  [1,2,3,4,5,6]
--R                                                  Type: FlexibleArray Integer
--E 3

--S 4 of 16
physicalLength f
--R 
--R
--R   (4)  6
--R                                                        Type: PositiveInteger
--E 4

--S 5 of 16
concat!(f,11)
--R 
--R
--R   (5)  [1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 5

--S 6 of 16
physicalLength f
--R 
--R
--R   (6)  10
--R                                                        Type: PositiveInteger
--E 6

--S 7 of 16
physicalLength!(f,15)
--R 
--R
--R   (7)  [1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 7

--S 8 of 16
concat!(f,f)
--R 
--R
--R   (8)  [1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 8

--S 9 of 16
insert!(22,f,1)
--R 
--R
--R   (9)  [22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 9

--S 10 of 16
g := f(10..)
--R 
--R
--R   (10)  [2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 10

--S 11 of 16
insert!(g,f,1)
--R 
--R
--R   (11)  [2,3,4,5,6,11,22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 11

--S 12 of 16
merge!(sort! f, sort! g)
--R 
--R
--R   (12)  [1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,11,11,11,11,22]
--R                                                  Type: FlexibleArray Integer
--E 12

--S 13 of 16
removeDuplicates! f
--R 
--R
--R   (13)  [1,2,3,4,5,6,11,22]
--R                                                  Type: FlexibleArray Integer
--E 13

--S 14 of 16
select!(i +-> even? i,f)
--R 
--R
--R   (14)  [2,4,6,22]
--R                                                  Type: FlexibleArray Integer
--E 14

--S 15 of 16
physicalLength f
--R 
--R
--R   (15)  8
--R                                                        Type: PositiveInteger
--E 15

--S 16 of 16
shrinkable(false)$FlexibleArray(Integer)
--R 
--R
--R   (16)  true
--R                                                                Type: Boolean
--E 16
)spool
)lisp (bye)
@
<<FlexibleArray.help>>=
====================================================================
FlexibleArray
====================================================================

The FlexibleArray domain constructor creates one-dimensional
arrays of elements of the same type.  Flexible arrays are an attempt
to provide a data type that has the best features of both
one-dimensional arrays (fast, random access to elements) and lists
(flexibility).  They are implemented by a fixed block of storage.
When necessary for expansion, a new, larger block of storage is
allocated and the elements from the old storage area are copied into
the new block.

Flexible arrays have available most of the operations provided by
OneDimensionalArray Vector.  Since flexible arrays are also of
category ExtensibleLinearAggregate they have operations concat!,
delete!, insert!, merge!, remove!, removeDuplicates!, and select!.  In
addition, the operations physicalLength and physicalLength! provide
user-control over expansion and contraction.

A convenient way to create a flexible array is to apply the operation
flexibleArray to a list of values.

  flexibleArray [i for i in 1..6]
    [1,2,3,4,5,6]
                     Type: FlexibleArray PositiveInteger

Create a flexible array of six zeroes.

  f : FARRAY INT := new(6,0)
    [0,0,0,0,0,0]
                     Type: FlexibleArray Integer

For i=1..6 set the i-th element to i.  Display f.

  for i in 1..6 repeat f.i := i; f
    [1,2,3,4,5,6]
                     Type: FlexibleArray Integer

Initially, the physical length is the same as the number of elements.

  physicalLength f
    6
                     Type: PositiveInteger

Add an element to the end of f.

  concat!(f,11)
    [1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

See that its physical length has grown.

  physicalLength f
    10
                     Type: PositiveInteger

Make f grow to have room for 15 elements.

  physicalLength!(f,15)
    [1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Concatenate the elements of f to itself.  The physical length
allows room for three more values at the end.

  concat!(f,f)
    [1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Use insert! to add an element to the front of a flexible array.

  insert!(22,f,1)
    [22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Create a second flexible array from f consisting of the elements from
index 10 forward.

  g := f(10..)
    [2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Insert this array at the front of f.

  insert!(g,f,1)
    [2,3,4,5,6,11,22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Merge the flexible array f into g after sorting each in place.

  merge!(sort! f, sort! g)
    [1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,11,11,11,11,22]
                     Type: FlexibleArray Integer

Remove duplicates in place.

  removeDuplicates! f
    [1,2,3,4,5,6,11,22]
                     Type: FlexibleArray Integer

Remove all odd integers.

  select!(i +-> even? i,f)
    [2,4,6,22]
                     Type: FlexibleArray Integer

All these operations have shrunk the physical length of f.

  physicalLength f
    8
                     Type: PositiveInteger

To force Axiom not to shrink flexible arrays call the shrinkable
operation with the argument false.  You must package call this
operation.  The previous value is returned.

  shrinkable(false)$FlexibleArray(Integer)
    true
                     Type: Boolean

See Also:
o )help OneDimensionalArray
o )help Vector
o )help ExtensibleLinearAggregate
o )show FlexibleArray
o $AXIOM/doc/src/algebra/array1.spad.dvi

@
<<domain FARRAY FlexibleArray>>=
)abbrev domain FARRAY FlexibleArray
++ A FlexibleArray is the notion of an array intended to allow for growth
++ at the end only.  Hence the following efficient operations
++   \spad{append(x,a)} meaning append item x at the end of the array \spad{a}
++   \spad{delete(a,n)} meaning delete the last item from the array \spad{a}
++ Flexible arrays support the other operations inherited from
++ \spadtype{ExtensibleLinearAggregate}. However, these are not efficient.
++ Flexible arrays combine the \spad{O(1)} access time property of arrays
++ with growing and shrinking at the end in \spad{O(1)} (average) time.
++ This is done by using an ordinary array which may have zero or more
++ empty slots at the end.  When the array becomes full it is copied
++ into a new larger (50% larger) array.  Conversely, when the array
++ becomes less than 1/2 full, it is copied into a smaller array.
++ Flexible arrays provide for an efficient implementation of many
++ data structures in particular heaps, stacks and sets.

FlexibleArray(S: Type) == Implementation where
  ARRAYMININDEX ==> 1       -- if you want to change this, be my guest
  Implementation ==> IndexedFlexibleArray(S, ARRAYMININDEX)
-- Join(OneDimensionalArrayAggregate S, ExtensibleLinearAggregate S)

@
\section{domain IARRAY1 IndexedOneDimensionalArray}
<<domain IARRAY1 IndexedOneDimensionalArray>>=
)abbrev domain IARRAY1 IndexedOneDimensionalArray
++ Author Micheal Monagan Aug/87
++ This is the basic one dimensional array data type.

IndexedOneDimensionalArray(S:Type, mn:Integer):
 OneDimensionalArrayAggregate S == add
   Qmax ==> QVMAXINDEX$Lisp
   Qsize ==> QVSIZE$Lisp
--   Qelt ==> QVELT$Lisp
--   Qsetelt ==> QSETVELT$Lisp
   Qelt ==> ELT$Lisp
   Qsetelt ==> SETELT$Lisp
--   Qelt1 ==> QVELT_-1$Lisp
--   Qsetelt1 ==> QSETVELT_-1$Lisp
   Qnew ==> GETREFV$Lisp
   I ==> Integer

   #x               == Qsize x
   fill_!(x, s)     == (for i in 0..Qmax x repeat Qsetelt(x, i, s); x)
   minIndex x       == mn

   empty()          == Qnew(0$Lisp)
   new(n, s)        == fill_!(Qnew n,s)

   map_!(f, s1)  ==
      n:Integer := Qmax(s1)
      n < 0 => s1
      for i in 0..n repeat Qsetelt(s1, i, f(Qelt(s1,i)))
      s1

   map(f, s1)       ==
      n:Integer := Qmax(s1)
      n < 0 => s1
      ss2:% := Qnew(n+1)
      for i in 0..n repeat Qsetelt(ss2, i, f(Qelt(s1,i)))
      ss2

   map(f, a, b)   ==
      maxind:Integer := min(Qmax a, Qmax b)
      maxind < 0 => empty()
      c:% := Qnew(maxind+1)
      for i in 0..maxind repeat
        Qsetelt(c, i, f(Qelt(a,i),Qelt(b,i)))
      c

   if zero? mn then
     qelt(x, i)       == Qelt(x, i)
     qsetelt_!(x, i, s) == Qsetelt(x, i, s)

     elt(x:%, i:I) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qelt(x, i)

     setelt(x:%, i:I, s:S) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qsetelt_!(x, i, s)

--   else if one? mn then
   else if (mn = 1) then
     maxIndex x       == Qsize x
     qelt(x, i)       == Qelt(x, i-1)
     qsetelt_!(x, i, s) == Qsetelt(x, i-1, s)

     elt(x:%, i:I) ==
       QSLESSP(i,1$Lisp)$Lisp or QSLESSP(Qsize x,i)$Lisp =>
         error "index out of range"
       Qelt(x, i-1)

     setelt(x:%, i:I, s:S) ==
       QSLESSP(i,1$Lisp)$Lisp or QSLESSP(Qsize x,i)$Lisp =>
         error "index out of range"
       Qsetelt(x, i-1, s)

    else
       qelt(x, i)       == Qelt(x, i - mn)
       qsetelt_!(x, i, s) == Qsetelt(x, i - mn, s)

       elt(x:%, i:I) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qelt(x, i)

       setelt(x:%, i:I, s:S) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qsetelt_!(x, i, s)

@
\section{domain ARRAY1 OneDimensionalArray}
<<OneDimensionalArray.input>>=
-- array1.spad.pamphlet OneDimensionalArray.input
)spool OneDimensionalArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
oneDimensionalArray [i**2 for i in 1..10]
--R 
--R
--R   (1)  [1,4,9,16,25,36,49,64,81,100]
--R                                    Type: OneDimensionalArray PositiveInteger
--E 1

--S 2 of 9
a : ARRAY1 INT := new(10,0)
--R 
--R
--R   (2)  [0,0,0,0,0,0,0,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 2

--S 3 of 9
for i in 1..10 repeat a.i := i; a
--R 
--R
--R   (3)  [1,2,3,4,5,6,7,8,9,10]
--R                                            Type: OneDimensionalArray Integer
--E 3

--S 4 of 9
map!(i +-> i ** 2,a); a
--R 
--R
--R   (4)  [1,4,9,16,25,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 4

--S 5 of 9
reverse! a
--R 
--R
--R   (5)  [100,81,64,49,36,25,16,9,4,1]
--R                                            Type: OneDimensionalArray Integer
--E 5

--S 6 of 9
swap!(a,4,5); a
--R 
--R
--R   (6)  [100,81,64,36,49,25,16,9,4,1]
--R                                            Type: OneDimensionalArray Integer
--E 6

--S 7 of 9
sort! a 
--R 
--R
--R   (7)  [1,4,9,16,25,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 7

--S 8 of 9
b := a(6..10)
--R 
--R
--R   (8)  [36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 8

--S 9 of 9
copyInto!(a,b,1)
--R 
--R
--R   (9)  [36,49,64,81,100,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 9
)spool
)lisp (bye)
@
<<OneDimensionalArray.help>>=
====================================================================
OneDimensionalArray examples
====================================================================

The OneDimensionalArray domain is used for storing data in a
one-dimensional indexed data structure.  Such an array is a
homogeneous data structure in that all the entries of the array must
belong to the same Axiom domain.  Each array has a fixed length
specified by the user and arrays are not extensible.  The indexing of
one-dimensional arrays is one-based.  This means that the "first"
element of an array is given the index 1. 

To create a one-dimensional array, apply the operation 
oneDimensionalArray to a list.

  oneDimensionalArray [i**2 for i in 1..10]
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray PositiveInteger

Another approach is to first create a, a one-dimensional array of 10
0's.  OneDimensionalArray has the convenient abbreviation ARRAY1.

  a : ARRAY1 INT := new(10,0)
    [0,0,0,0,0,0,0,0,0,0]
                     Type: OneDimensionalArray Integer

Set each i-th element to i, then display the result.

  for i in 1..10 repeat a.i := i; a
    [1,2,3,4,5,6,7,8,9,10]
                     Type: OneDimensionalArray Integer

Square each element by mapping the function i +-> i^2 onto each element.

  map!(i +-> i ** 2,a); a
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Reverse the elements in place.

  reverse! a
    [100,81,64,49,36,25,16,9,4,1]
                     Type: OneDimensionalArray Integer

Swap the 4th and 5th element.

  swap!(a,4,5); a
    [100,81,64,36,49,25,16,9,4,1]
                     Type: OneDimensionalArray Integer

Sort the elements in place.

  sort! a 
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Create a new one-dimensional array b containing the last 5 elements of a.

  b := a(6..10)
    [36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Replace the first 5 elements of a with those of b.

  copyInto!(a,b,1)
    [36,49,64,81,100,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

See Also:
o )help Vector
o )help FlexibleArray
o )show OneDimensionalArray
o $AXIOM/doc/src/algebra/array1.spad.dvi

@
<<domain ARRAY1 OneDimensionalArray>>=
)abbrev domain ARRAY1 OneDimensionalArray
++ This is the domain of 1-based one dimensional arrays

OneDimensionalArray(S:Type): Exports == Implementation where
  ARRAYMININDEX ==> 1       -- if you want to change this, be my guest
  Exports == OneDimensionalArrayAggregate S with
   oneDimensionalArray: List S -> %
    ++ oneDimensionalArray(l) creates an array from a list of elements l
    ++
    ++E oneDimensionalArray [i**2 for i in 1..10]
  
   oneDimensionalArray: (NonNegativeInteger, S) -> %
    ++ oneDimensionalArray(n,s) creates an array from n copies of element s
    ++
    ++E oneDimensionalArray(10,0.0)

  Implementation == IndexedOneDimensionalArray(S, ARRAYMININDEX) add
    oneDimensionalArray(u) ==
      n := #u
      n = 0 => empty()
      a := new(n, first u)
      for i in 2..n for x in rest u repeat a.i := x
      a
    oneDimensionalArray(n,s) == new(n,s)

@
\section{package ARRAY12 OneDimensionalArrayFunctions2}
<<package ARRAY12 OneDimensionalArrayFunctions2>>=
)abbrev package ARRAY12 OneDimensionalArrayFunctions2
++ This package provides tools for operating on one-dimensional arrays
++ with unary and binary functions involving different underlying types
OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> OneDimensionalArray A
  VB ==> OneDimensionalArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)

  Exports ==> with
   scan   : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of one-dimensional array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++E adder(a:Integer,b:Integer):Integer == a+b
    ++E scan(adder,[i for i in 1..10],0)$T1

   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ one-dimensional array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++E adder(a:Integer,b:Integer):Integer == a+b
    ++E reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of one-dimensional array
    ++ \spad{a} resulting in a new one-dimensional array over a
    ++ possibly different underlying domain.
    ++
    ++E T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++E map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain PRIMARR PrimitiveArray>>
<<package PRIMARR2 PrimitiveArrayFunctions2>>
<<domain TUPLE Tuple>>
<<domain IFARRAY IndexedFlexibleArray>>
<<domain FARRAY FlexibleArray>>
<<domain IARRAY1 IndexedOneDimensionalArray>>
<<domain ARRAY1 OneDimensionalArray>>
<<package ARRAY12 OneDimensionalArrayFunctions2>>

--%% TupleFunctions2
--TupleFunctions2(A:Type, B:Type): with
--  map: (A -> B, Tuple A) -> Tuple B
-- == add
--  map(f, t) ==
--    p:PrimitiveArray(B) := new length t
--    for i in minIndex p .. maxIndex p repeat
--      p.i := f select(t, i)
--    p::Tuple(B)

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
