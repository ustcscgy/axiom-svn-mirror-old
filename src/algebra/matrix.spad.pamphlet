\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra matrix.spad}
\author{Johannes Grabmeier, Oswald Gschnitzer, Clifton J. Williamson}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain IMATRIX IndexedMatrix}
<<domain IMATRIX IndexedMatrix>>=
)abbrev domain IMATRIX IndexedMatrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Date Last Updated: July 1990
++ Basic Operations:
++ Related Domains: Matrix, RectangularMatrix, SquareMatrix,
++   StorageEfficientMatrixOperations
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   An \spad{IndexedMatrix} is a matrix where the minimal row and column
++   indices are parameters of the type.  The domains Row and Col
++   are both IndexedVectors.
++   The index of the 'first' row may be obtained by calling the
++   function \spadfun{minRowIndex}.  The index of the 'first' column may
++   be obtained by calling the function \spadfun{minColIndex}.  The index of
++   the first element of a 'Row' is the same as the index of the
++   first column in a matrix and vice versa.
IndexedMatrix(R,mnRow,mnCol): Exports == Implementation where
  R : Ring
  mnRow, mnCol : Integer
  Row ==> IndexedVector(R,mnCol)
  Col ==> IndexedVector(R,mnRow)
  MATLIN ==> MatrixLinearAlgebraFunctions(R,Row,Col,$)
 
  Exports ==> MatrixCategory(R,Row,Col)
 
  Implementation ==>
    InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col) add
 
      swapRows_!(x,i1,i2) ==
        (i1 < minRowIndex(x)) or (i1 > maxRowIndex(x)) or _
           (i2 < minRowIndex(x)) or (i2 > maxRowIndex(x)) =>
             error "swapRows!: index out of range"
        i1 = i2 => x
        minRow := minRowIndex x
        xx := x pretend PrimitiveArray(PrimitiveArray(R))
        n1 := i1 - minRow; n2 := i2 - minRow
        row1 := qelt(xx,n1)
        qsetelt_!(xx,n1,qelt(xx,n2))
        qsetelt_!(xx,n2,row1)
        xx pretend $
 
      if R has commutative("*") then
 
        determinant x == determinant(x)$MATLIN
        minordet    x == minordet(x)$MATLIN
 
      if R has EuclideanDomain then
 
        rowEchelon  x == rowEchelon(x)$MATLIN
 
      if R has IntegralDomain then
 
        rank        x == rank(x)$MATLIN
        nullity     x == nullity(x)$MATLIN
        nullSpace   x == nullSpace(x)$MATLIN
 
      if R has Field then
 
        inverse     x == inverse(x)$MATLIN

@
\section{domain MATRIX Matrix}
<<Matrix.input>>=
-- matrix.spad.pamphlet Matrix.input
)spool Matrix.output
)set message test on
)set message auto off
)clear all
--S 1 of 38
m : Matrix(Integer) := new(3,3,0)
--R 
--R
--R        +0  0  0+
--R        |       |
--R   (1)  |0  0  0|
--R        |       |
--R        +0  0  0+
--R                                                         Type: Matrix Integer
--E 1

--S 2 of 38
setelt(m,2,3,5)
--R 
--R
--R   (2)  5
--R                                                        Type: PositiveInteger
--E 2

--S 3 of 38
m(1,2) := 10
--R 
--R
--R   (3)  10
--R                                                        Type: PositiveInteger
--E 3

--S 4 of 38
m
--R 
--R
--R        +0  10  0+
--R        |        |
--R   (4)  |0  0   5|
--R        |        |
--R        +0  0   0+
--R                                                         Type: Matrix Integer
--E 4

--S 5 of 38
matrix [ [1,2,3,4],[0,9,8,7] ]
--R 
--R
--R        +1  2  3  4+
--R   (5)  |          |
--R        +0  9  8  7+
--R                                                         Type: Matrix Integer
--E 5

--S 6 of 38
dm := diagonalMatrix [1,x**2,x**3,x**4,x**5]
--R 
--R
--R        +1  0   0   0   0 +
--R        |                 |
--R        |    2            |
--R        |0  x   0   0   0 |
--R        |                 |
--R        |        3        |
--R   (6)  |0  0   x   0   0 |
--R        |                 |
--R        |            4    |
--R        |0  0   0   x   0 |
--R        |                 |
--R        |                5|
--R        +0  0   0   0   x +
--R                                              Type: Matrix Polynomial Integer
--E 6

--S 7 of 38
setRow!(dm,5,vector [1,1,1,1,1])
--R 
--R
--R        +1  0   0   0   0+
--R        |                |
--R        |    2           |
--R        |0  x   0   0   0|
--R        |                |
--R   (7)  |        3       |
--R        |0  0   x   0   0|
--R        |                |
--R        |            4   |
--R        |0  0   0   x   0|
--R        |                |
--R        +1  1   1   1   1+
--R                                              Type: Matrix Polynomial Integer
--E 7

--S 8 of 38
setColumn!(dm,2,vector [y,y,y,y,y])
--R 
--R
--R        +1  y  0   0   0+
--R        |               |
--R        |0  y  0   0   0|
--R        |               |
--R        |       3       |
--R   (8)  |0  y  x   0   0|
--R        |               |
--R        |           4   |
--R        |0  y  0   x   0|
--R        |               |
--R        +1  y  1   1   1+
--R                                              Type: Matrix Polynomial Integer
--E 8

--S 9 of 38
cdm := copy(dm)
--R 
--R
--R        +1  y  0   0   0+
--R        |               |
--R        |0  y  0   0   0|
--R        |               |
--R        |       3       |
--R   (9)  |0  y  x   0   0|
--R        |               |
--R        |           4   |
--R        |0  y  0   x   0|
--R        |               |
--R        +1  y  1   1   1+
--R                                              Type: Matrix Polynomial Integer
--E 9

--S 10 of 38
setelt(dm,4,1,1-x**7)
--R 
--R
--R            7
--R   (10)  - x  + 1
--R                                                     Type: Polynomial Integer
--E 10

--S 11 of 38
[dm,cdm]
--R 
--R
--R          +   1      y  0   0   0+ +1  y  0   0   0+
--R          |                      | |               |
--R          |   0      y  0   0   0| |0  y  0   0   0|
--R          |                      | |               |
--R          |              3       | |       3       |
--R   (11)  [|   0      y  x   0   0|,|0  y  x   0   0|]
--R          |                      | |               |
--R          |   7              4   | |           4   |
--R          |- x  + 1  y  0   x   0| |0  y  0   x   0|
--R          |                      | |               |
--R          +   1      y  1   1   1+ +1  y  1   1   1+
--R                                         Type: List Matrix Polynomial Integer
--E 11

--S 12 of 38
subMatrix(dm,2,3,2,4)
--R 
--R
--R         +y  0   0+
--R   (12)  |        |
--R         |    3   |
--R         +y  x   0+
--R                                              Type: Matrix Polynomial Integer
--E 12

--S 13 of 38
d := diagonalMatrix [1.2,-1.3,1.4,-1.5]
--R 
--R
--R         +1.2   0.0   0.0   0.0 +
--R         |                      |
--R         |0.0  - 1.3  0.0   0.0 |
--R   (13)  |                      |
--R         |0.0   0.0   1.4   0.0 |
--R         |                      |
--R         +0.0   0.0   0.0  - 1.5+
--R                                                           Type: Matrix Float
--E 13

--S 14 of 38
e := matrix [ [6.7,9.11],[-31.33,67.19] ]
--R 
--R
--R         +  6.7    9.11 +
--R   (14)  |              |
--R         +- 31.33  67.19+
--R                                                           Type: Matrix Float
--E 14

--S 15 of 38
setsubMatrix!(d,1,2,e)
--R 
--R
--R         +1.2    6.7    9.11    0.0 +
--R         |                          |
--R         |0.0  - 31.33  67.19   0.0 |
--R   (15)  |                          |
--R         |0.0    0.0     1.4    0.0 |
--R         |                          |
--R         +0.0    0.0     0.0   - 1.5+
--R                                                           Type: Matrix Float
--E 15

--S 16 of 38
d
--R 
--R
--R         +1.2    6.7    9.11    0.0 +
--R         |                          |
--R         |0.0  - 31.33  67.19   0.0 |
--R   (16)  |                          |
--R         |0.0    0.0     1.4    0.0 |
--R         |                          |
--R         +0.0    0.0     0.0   - 1.5+
--R                                                           Type: Matrix Float
--E 16

--S 17 of 38
a := matrix [ [1/2,1/3,1/4],[1/5,1/6,1/7] ]
--R 
--R
--R         +1  1  1+
--R         |-  -  -|
--R         |2  3  4|
--R   (17)  |       |
--R         |1  1  1|
--R         |-  -  -|
--R         +5  6  7+
--R                                                Type: Matrix Fraction Integer
--E 17

--S 18 of 38
b := matrix [ [3/5,3/7,3/11],[3/13,3/17,3/19] ] 
--R 
--R
--R         +3   3    3+
--R         |-   -   --|
--R         |5   7   11|
--R   (18)  |          |
--R         | 3   3   3|
--R         |--  --  --|
--R         +13  17  19+
--R                                                Type: Matrix Fraction Integer
--E 18

--S 19 of 38
horizConcat(a,b)
--R 
--R
--R         +1  1  1  3   3    3+
--R         |-  -  -  -   -   --|
--R         |2  3  4  5   7   11|
--R   (19)  |                   |
--R         |1  1  1   3   3   3|
--R         |-  -  -  --  --  --|
--R         +5  6  7  13  17  19+
--R                                                Type: Matrix Fraction Integer
--E 19

--S 20 of 38
vab := vertConcat(a,b)
--R 
--R
--R         +1   1   1 +
--R         |-   -   - |
--R         |2   3   4 |
--R         |          |
--R         |1   1   1 |
--R         |-   -   - |
--R         |5   6   7 |
--R   (20)  |          |
--R         |3   3    3|
--R         |-   -   --|
--R         |5   7   11|
--R         |          |
--R         | 3   3   3|
--R         |--  --  --|
--R         +13  17  19+
--R                                                Type: Matrix Fraction Integer
--E 20

--S 21 of 38
transpose vab
--R 
--R
--R         +1  1  3    3+
--R         |-  -  -   --|
--R         |2  5  5   13|
--R         |            |
--R         |1  1  3    3|
--R   (21)  |-  -  -   --|
--R         |3  6  7   17|
--R         |            |
--R         |1  1   3   3|
--R         |-  -  --  --|
--R         +4  7  11  19+
--R                                                Type: Matrix Fraction Integer
--E 21

--S 22 of 38
m := matrix [ [1,2],[3,4] ]
--R 
--R
--R         +1  2+
--R   (22)  |    |
--R         +3  4+
--R                                                         Type: Matrix Integer
--E 22

--S 23 of 38
4 * m * (-5)
--R 
--R
--R         +- 20  - 40+
--R   (23)  |          |
--R         +- 60  - 80+
--R                                                         Type: Matrix Integer
--E 23

--S 24 of 38
n := matrix([ [1,0,-2],[-3,5,1] ])
--R 
--R
--R         + 1   0  - 2+
--R   (24)  |           |
--R         +- 3  5   1 +
--R                                                         Type: Matrix Integer
--E 24

--S 25 of 38
m * n
--R 
--R
--R         +- 5  10   0 +
--R   (25)  |            |
--R         +- 9  20  - 2+
--R                                                         Type: Matrix Integer
--E 25

--S 26 of 38
vec := column(n,3)
--R 
--R
--R   (26)  [- 2,1]
--R                                                         Type: Vector Integer
--E 26

--S 27 of 38
vec * m
--R 
--R
--R   (27)  [1,0]
--R                                                         Type: Vector Integer
--E 27

--S 28 of 38
m * vec
--R 
--R
--R   (28)  [0,- 2]
--R                                                         Type: Vector Integer
--E 28

--S 29 of 38
hilb := matrix([ [1/(i + j) for i in 1..3] for j in 1..3])
--R 
--R
--R         +1  1  1+
--R         |-  -  -|
--R         |2  3  4|
--R         |       |
--R         |1  1  1|
--R   (29)  |-  -  -|
--R         |3  4  5|
--R         |       |
--R         |1  1  1|
--R         |-  -  -|
--R         +4  5  6+
--R                                                Type: Matrix Fraction Integer
--E 29

--S 30 of 38
inverse(hilb)
--R 
--R
--R         + 72    - 240   180 +
--R         |                   |
--R   (30)  |- 240   900   - 720|
--R         |                   |
--R         + 180   - 720   600 +
--R                                     Type: Union(Matrix Fraction Integer,...)
--E 30

--S 31 of 38
mm := matrix([ [1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16] ])
--R 
--R
--R         +1   2   3   4 +
--R         |              |
--R         |5   6   7   8 |
--R   (31)  |              |
--R         |9   10  11  12|
--R         |              |
--R         +13  14  15  16+
--R                                                         Type: Matrix Integer
--E 31

--S 32 of 38
inverse(mm)
--R 
--R
--R   (32)  "failed"
--R                                                    Type: Union("failed",...)
--E 32

--S 33 of 38
determinant(mm)
--R 
--R
--R   (33)  0
--R                                                     Type: NonNegativeInteger
--E 33

--S 34 of 38
trace(mm)
--R 
--R
--R   (34)  34
--R                                                        Type: PositiveInteger
--E 34

--S 35 of 38
rank(mm)
--R 
--R
--R   (35)  2
--R                                                        Type: PositiveInteger
--E 35

--S 36 of 38
nullity(mm)
--R 
--R
--R   (36)  2
--R                                                        Type: PositiveInteger
--E 36

--S 37 of 38
nullSpace(mm)
--R 
--R
--R   (37)  [[1,- 2,1,0],[2,- 3,0,1]]
--R                                                    Type: List Vector Integer
--E 37

--S 38 of 38
rowEchelon(mm)
--R 
--R
--R         +1  2  3  4 +
--R         |           |
--R         |0  4  8  12|
--R   (38)  |           |
--R         |0  0  0  0 |
--R         |           |
--R         +0  0  0  0 +
--R                                                         Type: Matrix Integer
--E 38
)spool
)lisp (bye)
@
<<Matrix.help>>=
====================================================================
Matrix examples
====================================================================

The Matrix domain provides arithmetic operations on matrices
and standard functions from linear algebra.
This domain is similar to the TwoDimensionalArray domain, except
that the entries for Matrix must belong to a  Ring.

====================================================================
Creating Matrices
====================================================================

There are many ways to create a matrix from a collection of values or
from existing matrices.

If the matrix has almost all items equal to the same value, use new to
create a matrix filled with that value and then reset the entries that
are different.

  m : Matrix(Integer) := new(3,3,0)
    +0  0  0+
    |       |
    |0  0  0|
    |       |
    +0  0  0+
                      Type: Matrix Integer

To change the entry in the second row, third column to 5, use setelt.

  setelt(m,2,3,5)
    5
                      Type: PositiveInteger

An alternative syntax is to use assignment.

  m(1,2) := 10
    10
                      Type: PositiveInteger

The matrix was destructively modified.

  m
    +0  10  0+
    |        |
    |0  0   5|
    |        |
    +0  0   0+
                      Type: Matrix Integer

If you already have the matrix entries as a list of lists, use matrix.

  matrix [ [1,2,3,4],[0,9,8,7] ]
    +1  2  3  4+
    |          |
    +0  9  8  7+
                      Type: Matrix Integer

If the matrix is diagonal, use diagonalMatrix.

  dm := diagonalMatrix [1,x**2,x**3,x**4,x**5]
        +1  0   0   0   0 +
        |                 |
        |    2            |
        |0  x   0   0   0 |
        |                 |
        |        3        |
        |0  0   x   0   0 |
        |                 |
        |            4    |
        |0  0   0   x   0 |
        |                 |
        |                5|
        +0  0   0   0   x +
                     Type: Matrix Polynomial Integer

Use setRow and setColumn to change a row or column of a matrix.

  setRow!(dm,5,vector [1,1,1,1,1])
        +1  0   0   0   0+
        |                |
        |    2           |
        |0  x   0   0   0|
        |                |
        |        3       |
        |0  0   x   0   0|
        |                |
        |            4   |
        |0  0   0   x   0|
        |                |
        +1  1   1   1   1+
                    Type: Matrix Polynomial Integer

  setColumn!(dm,2,vector [y,y,y,y,y])
        +1  y  0   0   0+
        |               |
        |0  y  0   0   0|
        |               |
        |       3       |
        |0  y  x   0   0|
        |               |
        |           4   |
        |0  y  0   x   0|
        |               |
        +1  y  1   1   1+
                    Type: Matrix Polynomial Integer

Use copy to make a copy of a matrix.

  cdm := copy(dm)
        +1  y  0   0   0+
        |               |
        |0  y  0   0   0|
        |               |
        |       3       |
        |0  y  x   0   0|
        |               |
        |           4   |
        |0  y  0   x   0|
        |               |
        +1  y  1   1   1+
                    Type: Matrix Polynomial Integer

This is useful if you intend to modify a matrix destructively but
want a copy of the original.

  setelt(dm,4,1,1-x**7)
        7
     - x  + 1
                    Type: Polynomial Integer

  [dm,cdm]
          +   1      y  0   0   0+ +1  y  0   0   0+
          |                      | |               |
          |   0      y  0   0   0| |0  y  0   0   0|
          |                      | |               |
          |              3       | |       3       |
         [|   0      y  x   0   0|,|0  y  x   0   0|]
          |                      | |               |
          |   7              4   | |           4   |
          |- x  + 1  y  0   x   0| |0  y  0   x   0|
          |                      | |               |
          +   1      y  1   1   1+ +1  y  1   1   1+
                     Type: List Matrix Polynomial Integer

Use subMatrix to extract part of an existing matrix.  The syntax is 
subMatrix(m, firstrow, lastrow, firstcol, lastcol).

  subMatrix(dm,2,3,2,4)
         +y  0   0+
         |        |
         |    3   |
         +y  x   0+
                     Type: Matrix Polynomial Integer

To change a submatrix, use setsubMatrix.

  d := diagonalMatrix [1.2,-1.3,1.4,-1.5]
         +1.2   0.0   0.0   0.0 +
         |                      |
         |0.0  - 1.3  0.0   0.0 |
         |                      |
         |0.0   0.0   1.4   0.0 |
         |                      |
         +0.0   0.0   0.0  - 1.5+
                     Type: Matrix Float

If e is too big to fit where you specify, an error message is
displayed.  Use subMatrix to extract part of e, if necessary.

  e := matrix [ [6.7,9.11],[-31.33,67.19] ]
         +  6.7    9.11 +
         |              |
         +- 31.33  67.19+
                      Type: Matrix Float

This changes the submatrix of d whose upper left corner is at the
first row and second column and whose size is that of e.

  setsubMatrix!(d,1,2,e)
         +1.2    6.7    9.11    0.0 +
         |                          |
         |0.0  - 31.33  67.19   0.0 |
         |                          |
         |0.0    0.0     1.4    0.0 |
         |                          |
         +0.0    0.0     0.0   - 1.5+
                       Type: Matrix Float

  d
         +1.2    6.7    9.11    0.0 +
         |                          |
         |0.0  - 31.33  67.19   0.0 |
         |                          |
         |0.0    0.0     1.4    0.0 |
         |                          |
         +0.0    0.0     0.0   - 1.5+
                        Type: Matrix Float

Matrices can be joined either horizontally or vertically to make
new matrices.

  a := matrix [ [1/2,1/3,1/4],[1/5,1/6,1/7] ]
         +1  1  1+
         |-  -  -|
         |2  3  4|
         |       |
         |1  1  1|
         |-  -  -|
         +5  6  7+
                         Type: Matrix Fraction Integer

  b := matrix [ [3/5,3/7,3/11],[3/13,3/17,3/19] ] 
         +3   3    3+
         |-   -   --|
         |5   7   11|
         |          |
         | 3   3   3|
         |--  --  --|
         +13  17  19+
                         Type: Matrix Fraction Integer

Use horizConcat to append them side to side.  The two matrices must
have the same number of rows.

  horizConcat(a,b)
         +1  1  1  3   3    3+
         |-  -  -  -   -   --|
         |2  3  4  5   7   11|
         |                   |
         |1  1  1   3   3   3|
         |-  -  -  --  --  --|
         +5  6  7  13  17  19+
                         Type: Matrix Fraction Integer

Use vertConcat to stack one upon the other.  The two matrices must
have the same number of columns.

  vab := vertConcat(a,b)
         +1   1   1 +
         |-   -   - |
         |2   3   4 |
         |          |
         |1   1   1 |
         |-   -   - |
         |5   6   7 |
         |          |
         |3   3    3|
         |-   -   --|
         |5   7   11|
         |          |
         | 3   3   3|
         |--  --  --|
         +13  17  19+
                         Type: Matrix Fraction Integer

The operation transpose is used to create a new matrix by reflection
across the main diagonal.

  transpose vab
         +1  1  3    3+
         |-  -  -   --|
         |2  5  5   13|
         |            |
         |1  1  3    3|
         |-  -  -   --|
         |3  6  7   17|
         |            |
         |1  1   3   3|
         |-  -  --  --|
         +4  7  11  19+
                         Type: Matrix Fraction Integer

====================================================================
Operations on Matrices
====================================================================

Axiom provides both left and right scalar multiplication.

  m := matrix [ [1,2],[3,4] ]
         +1  2+
         |    |
         +3  4+
                          Type: Matrix Integer

  4 * m * (-5)
         +- 20  - 40+
         |          |
         +- 60  - 80+
                          Type: Matrix Integer

You can add, subtract, and multiply matrices provided, of course, that
the matrices have compatible dimensions.  If not, an error message is
displayed.

  n := matrix([ [1,0,-2],[-3,5,1] ])
         + 1   0  - 2+
         |           |
         +- 3  5   1 +
                          Type: Matrix Integer

This following product is defined but n * m is not.

  m * n
         +- 5  10   0 +
         |            |
         +- 9  20  - 2+
                          Type: Matrix Integer

The operations nrows and ncols return the number of rows and columns
of a matrix.  You can extract a row or a column of a matrix using the
operations row and column.  The object returned is a Vector.

Here is the third column of the matrix n.

  vec := column(n,3)
     [- 2,1]
                          Type: Vector Integer

You can multiply a matrix on the left by a "row vector" and on the right
by a "column vector".

  vec * m
     [1,0]
                          Type: Vector Integer

Of course, the dimensions of the vector and the matrix must be compatible
or an error message is returned.

  m * vec
    [0,- 2]
                          Type: Vector Integer

The operation inverse computes the inverse of a matrix if the matrix
is invertible, and returns "failed" if not.

This Hilbert matrix is invertible.

  hilb := matrix([ [1/(i + j) for i in 1..3] for j in 1..3])
         +1  1  1+
         |-  -  -|
         |2  3  4|
         |       |
         |1  1  1|
         |-  -  -|
         |3  4  5|
         |       |
         |1  1  1|
         |-  -  -|
         +4  5  6+
                          Type: Matrix Fraction Integer

  inverse(hilb)
         + 72    - 240   180 +
         |                   |
         |- 240   900   - 720|
         |                   |
         + 180   - 720   600 +
                          Type: Union(Matrix Fraction Integer,...)

This matrix is not invertible.

  mm := matrix([ [1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16] ])
         +1   2   3   4 +
         |              |
         |5   6   7   8 |
         |              |
         |9   10  11  12|
         |              |
         +13  14  15  16+
                           Type: Matrix Integer

  inverse(mm)
     "failed"
                           Type: Union("failed",...)

The operation determinant computes the determinant of a matrix
provided that the entries of the matrix belong to a CommutativeRing.

The above matrix mm is not invertible and, hence, must have determinant 0.

  determinant(mm)
    0
                           Type: NonNegativeInteger

The operation trace computes the trace of a square matrix.

  trace(mm)
    34
                           Type: PositiveInteger

The operation rank computes the rank of a matrix: the maximal number
of linearly independent rows or columns.

  rank(mm)
    2
                           Type: PositiveInteger

The operation nullity computes the nullity of a matrix: the dimension
of its null space.

  nullity(mm)
    2
                           Type: PositiveInteger

The operation nullSpace returns a list containing a basis for the null
space of a matrix.  Note that the nullity is the number of elements in
a basis for the null space.

  nullSpace(mm)
    [[1,- 2,1,0],[2,- 3,0,1]]
                           Type: List Vector Integer

The operation rowEchelon returns the row echelon form of a matrix.  It
is easy to see that the rank of this matrix is two and that its
nullity is also two.

  rowEchelon(mm)
         +1  2  3  4 +
         |           |
         |0  4  8  12|
         |           |
         |0  0  0  0 |
         |           |
         +0  0  0  0 +
                           Type: Matrix Integer

See Also
o )help OneDimensionalArray
o )help TwoDimensionalArray
o )help Vector
o )help Permanent
o )show Matrix
o $AXIOM/doc/src/algebra/matrix.spad.dvi

@
<<domain MATRIX Matrix>>=
)abbrev domain MATRIX Matrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Date Last Updated: July 1990
++ Basic Operations:
++ Related Domains: IndexedMatrix, RectangularMatrix, SquareMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{Matrix} is a matrix domain where 1-based indexing is used
++   for both rows and columns.
Matrix(R): Exports == Implementation where
  R : Ring
  Row ==> Vector R
  Col ==> Vector R
  mnRow ==> 1
  mnCol ==> 1
  MATLIN ==> MatrixLinearAlgebraFunctions(R,Row,Col,$)
  MATSTOR ==> StorageEfficientMatrixOperations(R)
 
  Exports ==> MatrixCategory(R,Row,Col) with
    diagonalMatrix: Vector R -> $
      ++ \spad{diagonalMatrix(v)} returns a diagonal matrix where the elements
      ++ of v appear on the diagonal.

    if R has ConvertibleTo InputForm then ConvertibleTo InputForm

    if R has Field then
      inverse: $ -> Union($,"failed")
        ++ \spad{inverse(m)} returns the inverse of the matrix m. 
        ++ If the matrix is not invertible, "failed" is returned.
        ++ Error: if the matrix is not square.
--     matrix: Vector Vector R -> $
--       ++ \spad{matrix(v)} converts the vector of vectors v to a matrix, where
--       ++ the vector of vectors is viewed as a vector of the rows of the
--       ++ matrix
--     diagonalMatrix: Vector $ -> $
--       ++ \spad{diagonalMatrix([m1,...,mk])} creates a block diagonal matrix
--       ++ M with block matrices {\em m1},...,{\em mk} down the diagonal,
--       ++ with 0 block matrices elsewhere.
--     vectorOfVectors: $ -> Vector Vector R
--       ++ \spad{vectorOfVectors(m)} returns the rows of the matrix m as a
--       ++ vector of vectors
 
  Implementation ==>
   InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col) add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex
 
    minRowIndex x == mnRow
    minColIndex x == mnCol
 
    swapRows_!(x,i1,i2) ==
        (i1 < minRowIndex(x)) or (i1 > maxRowIndex(x)) or _
           (i2 < minRowIndex(x)) or (i2 > maxRowIndex(x)) =>
             error "swapRows!: index out of range"
        i1 = i2 => x
        minRow := minRowIndex x
        xx := x pretend PrimitiveArray(PrimitiveArray(R))
        n1 := i1 - minRow; n2 := i2 - minRow
        row1 := qelt(xx,n1)
        qsetelt_!(xx,n1,qelt(xx,n2))
        qsetelt_!(xx,n2,row1)
        xx pretend $
 
    positivePower:($,Integer,NonNegativeInteger) -> $
    positivePower(x,n,nn) ==
--      one? n => x
      (n = 1) => x
      -- no need to allocate space for 3 additional matrices
      n = 2 => x * x
      n = 3 => x * x * x
      n = 4 => (y := x * x; y * y)
      a := new(nn,nn,0) pretend Matrix(R)
      b := new(nn,nn,0) pretend Matrix(R)
      c := new(nn,nn,0) pretend Matrix(R)
      xx := x pretend Matrix(R)
      power_!(a,b,c,xx,n :: NonNegativeInteger)$MATSTOR pretend $
 
    x:$ ** n:NonNegativeInteger ==
      not((nn := nrows x) = ncols x) =>
        error "**: matrix must be square"
      zero? n => scalarMatrix(nn,1)
      positivePower(x,n,nn)
 
    if R has commutative("*") then
 
        determinant x == determinant(x)$MATLIN
        minordet    x == minordet(x)$MATLIN
 
    if R has EuclideanDomain then
 
        rowEchelon  x == rowEchelon(x)$MATLIN
 
    if R has IntegralDomain then
 
        rank        x == rank(x)$MATLIN
        nullity     x == nullity(x)$MATLIN
        nullSpace   x == nullSpace(x)$MATLIN
 
    if R has Field then
 
        inverse     x == inverse(x)$MATLIN
 
        x:$ ** n:Integer ==
          nn := nrows x
          not(nn = ncols x) =>
            error "**: matrix must be square"
          zero? n => scalarMatrix(nn,1)
          positive? n => positivePower(x,n,nn)
          (xInv := inverse x) case "failed" =>
            error "**: matrix must be invertible"
          positivePower(xInv :: $,-n,nn)
 
--     matrix(v: Vector Vector R) ==
--       (rows := # v) = 0 => new(0,0,0)
--       -- error check: this is a top level function
--       cols := # v.mini(v)
--       for k in (mini(v) + 1)..maxi(v) repeat
--         cols ^= # v.k => error "matrix: rows of different lengths"
--       ans := new(rows,cols,0)
--       for i in minr(ans)..maxr(ans) for k in mini(v)..maxi(v) repeat
--         vv := v.k
--         for j in minc(ans)..maxc(ans) for l in mini(vv)..maxi(vv) repeat
--           ans(i,j) := vv.l
--       ans
 
    diagonalMatrix(v: Vector R) ==
      n := #v; ans := zero(n,n)
      for i in minr(ans)..maxr(ans) for j in minc(ans)..maxc(ans) _
          for k in mini(v)..maxi(v) repeat qsetelt_!(ans,i,j,qelt(v,k))
      ans
 
--     diagonalMatrix(vec: Vector $) ==
--       rows : NonNegativeInteger := 0
--       cols : NonNegativeInteger := 0
--       for r in mini(vec)..maxi(vec) repeat
--         mat := vec.r
--         rows := rows + nrows mat; cols := cols + ncols mat
--       ans := zero(rows,cols)
--       loR := minr ans; loC := minc ans
--       for r in mini(vec)..maxi(vec) repeat
--         mat := vec.r
--         hiR := loR + nrows(mat) - 1; hiC := loC + nrows(mat) - 1
--         for i in loR..hiR for k in minr(mat)..maxr(mat) repeat
--           for j in loC..hiC for l in minc(mat)..maxc(mat) repeat
--             ans(i,j) := mat(k,l)
--         loR := hiR + 1; loC := hiC + 1
--       ans
 
--     vectorOfVectors x ==
--       vv : Vector Vector R := new(nrows x,0)
--       cols := ncols x
--       for k in mini(vv)..maxi(vv) repeat
--         vv.k := new(cols,0)
--       for i in minr(x)..maxr(x) for k in mini(vv)..maxi(vv) repeat
--         v := vv.k
--         for j in minc(x)..maxc(x) for l in mini(v)..maxi(v) repeat
--           v.l := x(i,j)
--       vv
 
    if R has ConvertibleTo InputForm then
      convert(x:$):InputForm ==
         convert [convert("matrix"::Symbol)@InputForm,
                  convert listOfLists x]$List(InputForm)

@
\section{domain RMATRIX RectangularMatrix}
<<domain RMATRIX RectangularMatrix>>=
)abbrev domain RMATRIX RectangularMatrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Date Last Updated: July 1990
++ Basic Operations:
++ Related Domains: IndexedMatrix, Matrix, SquareMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{RectangularMatrix} is a matrix domain where the number of rows
++   and the number of columns are parameters of the domain.
RectangularMatrix(m,n,R): Exports == Implementation where
  m,n : NonNegativeInteger
  R   : Ring
  Row ==> DirectProduct(n,R)
  Col ==> DirectProduct(m,R)
  Exports ==> Join(RectangularMatrixCategory(m,n,R,Row,Col),_
                   CoercibleTo Matrix R) with
 
    if R has Field then VectorSpace R
 
    if R has ConvertibleTo InputForm then ConvertibleTo InputForm

    rectangularMatrix: Matrix R -> $
      ++ \spad{rectangularMatrix(m)} converts a matrix of type \spadtype{Matrix}
      ++ to a matrix of type \spad{RectangularMatrix}.
    coerce: $ -> Matrix R
      ++ \spad{coerce(m)} converts a matrix of type \spadtype{RectangularMatrix}
      ++ to a matrix of type \spad{Matrix}.
 
  Implementation ==> Matrix R add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex
 
    ZERO := new(m,n,0)$Matrix(R) pretend $
    0    == ZERO
 
    coerce(x:$):OutputForm == coerce(x pretend Matrix R)$Matrix(R)

    matrix(l: List List R) ==
      -- error check: this is a top level function
      #l ^= m => error "matrix: wrong number of rows"
      for ll in l repeat
        #ll ^= n => error "matrix: wrong number of columns"
      ans : Matrix R := new(m,n,0)
      for i in minr(ans)..maxr(ans) for ll in l repeat
        for j in minc(ans)..maxc(ans) for r in ll repeat
          qsetelt_!(ans,i,j,r)
      ans pretend $
 
    row(x,i)    == directProduct row(x pretend Matrix(R),i)
    column(x,j) == directProduct column(x pretend Matrix(R),j)
 
    coerce(x:$):Matrix(R) == copy(x pretend Matrix(R))
 
    rectangularMatrix x ==
      (nrows(x) ^= m) or (ncols(x) ^= n) =>
        error "rectangularMatrix: matrix of bad dimensions"
      copy(x) pretend $
 
    if R has EuclideanDomain then
 
      rowEchelon x == rowEchelon(x pretend Matrix(R)) pretend $
 
    if R has IntegralDomain then
 
      rank x    == rank(x pretend Matrix(R))
      nullity x == nullity(x pretend Matrix(R))
      nullSpace x ==
        [directProduct c for c in nullSpace(x pretend Matrix(R))]
 
    if R has Field then
 
      dimension() == (m * n) :: CardinalNumber
 
    if R has ConvertibleTo InputForm then
      convert(x:$):InputForm ==
         convert [convert("rectangularMatrix"::Symbol)@InputForm,
                  convert(x::Matrix(R))]$List(InputForm)

@
\section{domain SQMATRIX SquareMatrix}
<<SquareMatrix.input>>=
-- matrix.spad.pamphlet SquareMatrix.input
)spool SquareMatrix.output
)set message test on
)set message auto off
)clear all
--S 1 of 6
)set expose add constructor SquareMatrix
--R 
--I   SquareMatrix is now explicitly exposed in frame frame0 
--E 1 

--S 2 of 6
m := squareMatrix [ [1,-%i],[%i,4] ]
--R 
--R
--R        +1   - %i+
--R   (1)  |        |
--R        +%i   4  +
--R                                        Type: SquareMatrix(2,Complex Integer)
--E 2

--S 3 of 6
m*m - m
--R 
--R
--R        + 1   - 4%i+
--R   (2)  |          |
--R        +4%i   13  +
--R                                        Type: SquareMatrix(2,Complex Integer)
--E 3

--S 4 of 6
mm := squareMatrix [ [m, 1], [1-m, m**2] ]
--R 
--R
--R        ++1   - %i+      +1  0+   +
--R        ||        |      |    |   |
--R        |+%i   4  +      +0  1+   |
--R   (3)  |                         |
--R        |+ 0    %i +  + 2   - 5%i+|
--R        ||         |  |          ||
--R        ++- %i  - 3+  +5%i   17  ++
--R                        Type: SquareMatrix(2,SquareMatrix(2,Complex Integer))
--E 4

--S 5 of 6
p := (x + m)**2
--R 
--R
--R         2   + 2   - 2%i+    + 2   - 5%i+
--R   (4)  x  + |          |x + |          |
--R             +2%i    8  +    +5%i   17  +
--R                             Type: Polynomial SquareMatrix(2,Complex Integer)
--E 5

--S 6 of 6
p::SquareMatrix(2, ?)
--R 
--R
--R        + 2                        +
--R        |x  + 2x + 2  - 2%i x - 5%i|
--R   (5)  |                          |
--R        |              2           |
--R        +2%i x + 5%i  x  + 8x + 17 +
--R                             Type: SquareMatrix(2,Polynomial Complex Integer)
--E 6
)spool
)lisp (bye)
@
<<SquareMatrix.help>>=
====================================================================
SquareMatrix examples
====================================================================
 
The top level matrix type in Axiom is Matrix, which provides basic
arithmetic and linear algebra functions.  However, since the matrices
can be of any size it is not true that any pair can be added or
multiplied.  Thus Matrix has little algebraic structure.
 
Sometimes you want to use matrices as coefficients for polynomials or
in other algebraic contexts.  In this case, SquareMatrix should be
used.  The domain SquareMatrix(n,R) gives the ring of n by n square
matrices over R.
 
Since SquareMatrix is not normally exposed at the top level, you must
expose it before it can be used.

  )set expose add constructor SquareMatrix

Once SQMATRIX has been exposed, values can be created using the
squareMatrix function.

  m := squareMatrix [ [1,-%i],[%i,4] ]
    +1   - %i+
    |        |
    +%i   4  +
                        Type: SquareMatrix(2,Complex Integer)

The usual arithmetic operations are available.

  m*m - m
    + 1   - 4%i+
    |          |
    +4%i   13  +
                        Type: SquareMatrix(2,Complex Integer)

Square matrices can be used where ring elements are required.
For example, here is a matrix with matrix entries.

  mm := squareMatrix [ [m, 1], [1-m, m**2] ]
    ++1   - %i+      +1  0+   +
    ||        |      |    |   |
    |+%i   4  +      +0  1+   |
    |                         |
    |+ 0    %i +  + 2   - 5%i+|
    ||         |  |          ||
    ++- %i  - 3+  +5%i   17  ++
                        Type: SquareMatrix(2,SquareMatrix(2,Complex Integer))

Or you can construct a polynomial with  square matrix coefficients.

  p := (x + m)**2
     2   + 2   - 2%i+    + 2   - 5%i+
    x  + |          |x + |          |
         +2%i    8  +    +5%i   17  +
                        Type: Polynomial SquareMatrix(2,Complex Integer)

This value can be converted to a square matrix with polynomial coefficients.

  p::SquareMatrix(2, ?)
    + 2                        +
    |x  + 2x + 2  - 2%i x - 5%i|
    |                          |
    |              2           |
    +2%i x + 5%i  x  + 8x + 17 +
                        Type: SquareMatrix(2,Polynomial Complex Integer)
 
See Also:
o )help Matrix
o )show SquareMatrix
o $AXIOM/doc/src/algebra/matrix.spad.dvi

@
<<domain SQMATRIX SquareMatrix>>=
)abbrev domain SQMATRIX SquareMatrix
++ Author: Grabmeier, Gschnitzer, Williamson
++ Date Created: 1987
++ Date Last Updated: July 1990
++ Basic Operations:
++ Related Domains: IndexedMatrix, Matrix, RectangularMatrix
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{SquareMatrix} is a matrix domain of square matrices, where the
++   number of rows (= number of columns) is a parameter of the type.
SquareMatrix(ndim,R): Exports == Implementation where
  ndim : NonNegativeInteger
  R    : Ring
  Row ==> DirectProduct(ndim,R)
  Col ==> DirectProduct(ndim,R)
  MATLIN ==> MatrixLinearAlgebraFunctions(R,Row,Col,$)
 
  Exports ==> Join(SquareMatrixCategory(ndim,R,Row,Col),_
                   CoercibleTo Matrix R) with
 
    transpose: $ -> $
      ++ \spad{transpose(m)} returns the transpose of the matrix m.
    squareMatrix: Matrix R -> $
      ++ \spad{squareMatrix(m)} converts a matrix of type \spadtype{Matrix}
      ++ to a matrix of type \spadtype{SquareMatrix}.
    coerce: $ -> Matrix R
      ++ \spad{coerce(m)} converts a matrix of type \spadtype{SquareMatrix}
      ++ to a matrix of type \spadtype{Matrix}.
--  symdecomp : $ -> Record(sym:$,antisym:$)
--    ++ \spad{symdecomp(m)} decomposes the matrix m as a sum of a symmetric
--    ++ matrix \spad{m1} and an antisymmetric matrix \spad{m2}. The object
--    ++ returned is the Record \spad{[m1,m2]}
--  if R has commutative("*") then
--    minorsVect: -> Vector(Union(R,"uncomputed")) --range: 1..2**n-1
--      ++ \spad{minorsVect(m)} returns a vector of the minors of the matrix m
    if R has commutative("*") then central
      ++ the elements of the Ring R, viewed as diagonal matrices, commute
      ++ with all matrices and, indeed, are the only matrices which commute
      ++ with all matrices.
    if R has commutative("*") and R has unitsKnown then unitsKnown
      ++ the invertible matrices are simply the matrices whose determinants
      ++ are units in the Ring R.
    if R has ConvertibleTo InputForm then ConvertibleTo InputForm
 
  Implementation ==> Matrix R add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex
    mini ==> minIndex
    maxi ==> maxIndex
 
    ZERO := scalarMatrix 0
    0    == ZERO
    ONE  := scalarMatrix 1
    1    == ONE

    characteristic() == characteristic()$R
 
    matrix(l: List List R) ==
      -- error check: this is a top level function
      #l ^= ndim => error "matrix: wrong number of rows"
      for ll in l repeat
        #ll ^= ndim => error "matrix: wrong number of columns"
      ans : Matrix R := new(ndim,ndim,0)
      for i in minr(ans)..maxr(ans) for ll in l repeat
        for j in minc(ans)..maxc(ans) for r in ll repeat
          qsetelt_!(ans,i,j,r)
      ans pretend $
 
    row(x,i)    == directProduct row(x pretend Matrix(R),i)
    column(x,j) == directProduct column(x pretend Matrix(R),j)
    coerce(x:$):OutputForm == coerce(x pretend Matrix R)$Matrix(R)
 
    scalarMatrix r == scalarMatrix(ndim,r)$Matrix(R) pretend $
 
    diagonalMatrix l ==
      #l ^= ndim =>
        error "diagonalMatrix: wrong number of entries in list"
      diagonalMatrix(l)$Matrix(R) pretend $
 
    coerce(x:$):Matrix(R) == copy(x pretend Matrix(R))
 
    squareMatrix x ==
      (nrows(x) ^= ndim) or (ncols(x) ^= ndim) =>
        error "squareMatrix: matrix of bad dimensions"
      copy(x) pretend $
 
    x:$ * v:Col ==
      directProduct((x pretend Matrix(R)) * (v :: Vector(R)))
 
    v:Row * x:$ ==
      directProduct((v :: Vector(R)) * (x pretend Matrix(R)))
 
    x:$ ** n:NonNegativeInteger ==
      ((x pretend Matrix(R)) ** n) pretend $
 
    if R has commutative("*") then
 
      determinant x == determinant(x pretend Matrix(R))
      minordet x    == minordet(x pretend Matrix(R))
 
    if R has EuclideanDomain then
 
      rowEchelon x == rowEchelon(x pretend Matrix(R)) pretend $
 
    if R has IntegralDomain then
 
      rank x    == rank(x pretend Matrix(R))
      nullity x == nullity(x pretend Matrix(R))
      nullSpace x ==
        [directProduct c for c in nullSpace(x pretend Matrix(R))]
 
    if R has Field then
 
      dimension() == (m * n) :: CardinalNumber
 
      inverse x ==
        (u := inverse(x pretend Matrix(R))) case "failed" => "failed"
        (u :: Matrix(R)) pretend $
 
      x:$ ** n:Integer ==
        ((x pretend Matrix(R)) ** n) pretend $
 
      recip x == inverse x
 
    if R has ConvertibleTo InputForm then
      convert(x:$):InputForm ==
         convert [convert("squareMatrix"::Symbol)@InputForm,
                  convert(x::Matrix(R))]$List(InputForm)


@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain IMATRIX IndexedMatrix>>
<<domain MATRIX Matrix>>
<<domain RMATRIX RectangularMatrix>>
<<domain SQMATRIX SquareMatrix>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
