\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra array2.spad}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{category ARR2CAT TwoDimensionalArrayCategory}
TwoDimensionalArrayCategory is a general array category which
allows different representations and indexing schemes.
Rows and columns may be extracted with rows returned as objects
of type Row and columns returned as objects of type Col.
The index of the 'first' row may be obtained by calling the
function 'minRowIndex'.  The index of the 'first' column may
be obtained by calling the function 'minColIndex'.  The index of
the first element of a 'Row' is the same as the index of the
first column in an array and vice versa.
<<dot>>=
"ARR2CAT" -> "HOAGG"
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
    -> "HomogeneousAggregate(a:Type)"
"TwoDimensionalArrayCategory(a:Type,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
-> "TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
@
<<category ARR2CAT TwoDimensionalArrayCategory>>=
)abbrev category ARR2CAT TwoDimensionalArrayCategory
++ Two dimensional array categories and domains
++ Author:
++ Date Created: 27 October 1989
++ Date Last Updated: 27 June 1990
++ Keywords: array, data structure
++ Examples:
++ References:
TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
 R   : Type
 Row : FiniteLinearAggregate R
 Col : FiniteLinearAggregate R

 Definition == HomogeneousAggregate(R) with

   shallowlyMutable
    ++ one may destructively alter arrays

   finiteAggregate
    ++ two-dimensional arrays are finite

--% Array creation

   new: (NonNegativeInteger,NonNegativeInteger,R) -> %
    ++ new(m,n,r) is an m-by-n array all of whose entries are r
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    
   fill_!: (%,R) -> %
    ++ fill!(m,r) fills m with r's
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X fill!(arr,10)

--% Size inquiries

   minRowIndex : % -> Integer
    ++ minRowIndex(m) returns the index of the 'first' row of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X minRowIndex(arr)

   maxRowIndex : % -> Integer
    ++ maxRowIndex(m) returns the index of the 'last' row of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X maxRowIndex(arr)

   minColIndex : % -> Integer
    ++ minColIndex(m) returns the index of the 'first' column of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X minColIndex(arr)

   maxColIndex : % -> Integer
    ++ maxColIndex(m) returns the index of the 'last' column of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X maxColIndex(arr)

   nrows : % -> NonNegativeInteger
    ++ nrows(m) returns the number of rows in the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X nrows(arr)

   ncols : % -> NonNegativeInteger
    ++ ncols(m) returns the number of columns in the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X ncols(arr)

--% Part extractions

   elt: (%,Integer,Integer) -> R
    ++ elt(m,i,j) returns the element in the ith row and jth
    ++ column of the array m
    ++ error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X elt(arr,1,1)

   qelt: (%,Integer,Integer) -> R
    ++ qelt(m,i,j) returns the element in the ith row and jth
    ++ column of the array m
    ++ NO error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X qelt(arr,1,1)

   elt: (%,Integer,Integer,R) -> R
    ++ elt(m,i,j,r) returns the element in the ith row and jth
    ++ column of the array m, if m has an ith row and a jth column,
    ++ and returns r otherwise
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X elt(arr,1,1,6)
    ++X elt(arr,1,10,6)

   row: (%,Integer) -> Row
    ++ row(m,i) returns the ith row of m
    ++ error check to determine if index is in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X row(arr,1)

   column: (%,Integer) -> Col
    ++ column(m,j) returns the jth column of m
    ++ error check to determine if index is in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X column(arr,1)

   parts: % -> List R
    ++ parts(m) returns a list of the elements of m in row major order
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X parts(arr)

--% Part assignments

   setelt: (%,Integer,Integer,R) -> R
    -- will become setelt_!
    ++ setelt(m,i,j,r) sets the element in the ith row and jth
    ++ column of m to r
    ++ error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X setelt(arr,1,1,17)

   qsetelt_!: (%,Integer,Integer,R) -> R
    ++ qsetelt!(m,i,j,r) sets the element in the ith row and jth
    ++ column of m to r
    ++ NO error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X qsetelt!(arr,1,1,17)

   setRow_!: (%,Integer,Row) -> %
    ++ setRow!(m,i,v) sets to ith row of m to v
    ++
    ++X T1:=TwoDimensionalArray Integer
    ++X arr:T1:= new(5,4,0)
    ++X T2:=OneDimensionalArray Integer
    ++X arow:=construct([1,2,3,4]::List(INT))$T2
    ++X setRow!(arr,1,arow)$T1

   setColumn_!: (%,Integer,Col) -> %
    ++ setColumn!(m,j,v) sets to jth column of m to v
    ++
    ++X T1:=TwoDimensionalArray Integer
    ++X arr:T1:= new(5,4,0)
    ++X T2:=OneDimensionalArray Integer
    ++X acol:=construct([1,2,3,4,5]::List(INT))$T2
    ++X setColumn!(arr,1,acol)$T1

--% Map and Zip

   map: (R -> R,%) -> %
    ++ map(f,a) returns \spad{b}, where \spad{b(i,j) = f(a(i,j))} 
    ++ for all \spad{i, j}
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map(-,arr)
    ++X map((x +-> x + x),arr)

   map_!: (R -> R,%) -> %
    ++ map!(f,a)  assign \spad{a(i,j)} to \spad{f(a(i,j))} for all \spad{i, j}
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map!(-,arr)

   map:((R,R) -> R,%,%) -> %
    ++ map(f,a,b) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
    ++ for all \spad{i, j}
    ++
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map(adder,arr,arr)

   map:((R,R) -> R,%,%,R) -> %
    ++ map(f,a,b,r) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
    ++ when both \spad{a(i,j)} and \spad{b(i,j)} exist;
    ++ else \spad{c(i,j) = f(r, b(i,j))} when \spad{a(i,j)} does not exist;
    ++ else \spad{c(i,j) = f(a(i,j),r)} when \spad{b(i,j)} does not exist;
    ++ otherwise \spad{c(i,j) = f(r,r)}.
    ++
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X arr1 : ARRAY2 INT := new(5,4,10)
    ++X arr2 : ARRAY2 INT := new(3,3,10)
    ++X map(adder,arr1,arr2,17)

  add

--% Predicates

    any?(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          f(qelt(m,i,j)) => return true
      false

    every?(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          not f(qelt(m,i,j)) => return false
      true

    size?(m,n) == nrows(m) * ncols(m) = n
    less?(m,n) == nrows(m) * ncols(m) < n
    more?(m,n) == nrows(m) * ncols(m) > n

--% Size inquiries

    # m == nrows(m) * ncols(m)

--% Part extractions

    elt(m,i,j,r) ==
      i < minRowIndex(m) or i > maxRowIndex(m) => r
      j < minColIndex(m) or j > maxColIndex(m) => r
      qelt(m,i,j)

    count(f:R -> Boolean,m:%) ==
      num : NonNegativeInteger := 0
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          if f(qelt(m,i,j)) then num := num + 1
      num

    parts m ==
      entryList : List R := nil()
      for i in maxRowIndex(m)..minRowIndex(m) by -1 repeat
        for j in maxColIndex(m)..minColIndex(m) by -1 repeat
          entryList := concat(qelt(m,i,j),entryList)
      entryList

--% Creation

    copy m ==
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,qelt(m,i,j))
      ans

    fill_!(m,r) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(m,i,j,r)
      m

    map(f,m) ==
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,f(qelt(m,i,j)))
      ans

    map_!(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(m,i,j,f(qelt(m,i,j)))
      m

    map(f,m,n) ==
      (nrows(m) ^= nrows(n)) or (ncols(m) ^= ncols(n)) =>
        error "map: arguments must have same dimensions"
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,f(qelt(m,i,j),qelt(n,i,j)))
      ans

    map(f,m,n,r) ==
      maxRow := max(maxRowIndex m,maxRowIndex n)
      maxCol := max(maxColIndex m,maxColIndex n)
      ans := new(max(nrows m,nrows n),max(ncols m,ncols n),NIL$Lisp)
      for i in minRowIndex(m)..maxRow repeat
        for j in minColIndex(m)..maxCol repeat
          qsetelt_!(ans,i,j,f(elt(m,i,j,r),elt(n,i,j,r)))
      ans

    setRow_!(m,i,v) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "setRow!: index out of range"
      for j in minColIndex(m)..maxColIndex(m) _
        for k in minIndex(v)..maxIndex(v) repeat
          qsetelt_!(m,i,j,v.k)
      m

    setColumn_!(m,j,v) ==
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "setColumn!: index out of range"
      for i in minRowIndex(m)..maxRowIndex(m) _
        for k in minIndex(v)..maxIndex(v) repeat
          qsetelt_!(m,i,j,v.k)
      m

    if R has _= : (R,R) -> Boolean then

      m = n ==
        eq?(m,n) => true
        (nrows(m) ^= nrows(n)) or (ncols(m) ^= ncols(n)) => false
        for i in minRowIndex(m)..maxRowIndex(m) repeat
          for j in minColIndex(m)..maxColIndex(m) repeat
            not (qelt(m,i,j) = qelt(n,i,j)) => return false
        true

      member?(r,m) ==
        for i in minRowIndex(m)..maxRowIndex(m) repeat
          for j in minColIndex(m)..maxColIndex(m) repeat
            qelt(m,i,j) = r => return true
        false

      count(r:R,m:%) == count(#1 = r,m)

    if Row has shallowlyMutable then

      row(m,i) ==
        i < minRowIndex(m) or i > maxRowIndex(m) =>
          error "row: index out of range"
        v : Row := new(ncols m,NIL$Lisp)
        for j in minColIndex(m)..maxColIndex(m) _
          for k in minIndex(v)..maxIndex(v) repeat
            qsetelt_!(v,k,qelt(m,i,j))
        v

    if Col has shallowlyMutable then

      column(m,j) ==
        j < minColIndex(m) or j > maxColIndex(m) =>
          error "column: index out of range"
        v : Col := new(nrows m,NIL$Lisp)
        for i in minRowIndex(m)..maxRowIndex(m) _
          for k in minIndex(v)..maxIndex(v) repeat
            qsetelt_!(v,k,qelt(m,i,j))
        v

    if R has CoercibleTo(OutputForm) then

      coerce(m:%) ==
        l : List List OutputForm
        l := [[qelt(m,i,j) :: OutputForm _
                  for j in minColIndex(m)..maxColIndex(m)] _
                  for i in minRowIndex(m)..maxRowIndex(m)]
        matrix l

@
\section{domain IIARRAY2 InnerIndexedTwoDimensionalArray}
This is an internal type which provides an implementation of
2-dimensional arrays as PrimitiveArray's of PrimitiveArray's.
<<dot>>=
"IIARRAY2" -> "ARR2CAT"
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
-> "TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
-> "InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
"InnerIndexedTwoDimensionalArray(a:Type,1,1,b:OneDimensionalArray(a),c:OneDimensionalArray(a))"
-> "InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
@
<<domain IIARRAY2 InnerIndexedTwoDimensionalArray>>=
)abbrev domain IIARRAY2 InnerIndexedTwoDimensionalArray
InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col):_
       Exports == Implementation where
  R : Type
  mnRow, mnCol : Integer
  Row : FiniteLinearAggregate R
  Col : FiniteLinearAggregate R

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col)

  Implementation ==> add

    Rep := PrimitiveArray PrimitiveArray R

--% Predicates

    empty? m == empty?(m)$Rep

--% Primitive array creation

    empty() == empty()$Rep

    new(rows,cols,a) ==
      rows = 0 =>
        error "new: arrays with zero rows are not supported"
--      cols = 0 =>
--        error "new: arrays with zero columns are not supported"
      arr : PrimitiveArray PrimitiveArray R := new(rows,empty())
      for i in minIndex(arr)..maxIndex(arr) repeat
        qsetelt_!(arr,i,new(cols,a))
      arr

--% Size inquiries

    minRowIndex m == mnRow
    minColIndex m == mnCol
    maxRowIndex m == nrows m + mnRow - 1
    maxColIndex m == ncols m + mnCol - 1

    nrows m == (# m)$Rep

    ncols m ==
      empty? m => 0
      # m(minIndex(m)$Rep)

--% Part selection/assignment

    qelt(m,i,j) ==
      qelt(qelt(m,i - minRowIndex m)$Rep,j - minColIndex m)

    elt(m:%,i:Integer,j:Integer) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "elt: index out of range"
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "elt: index out of range"
      qelt(m,i,j)

    qsetelt_!(m,i,j,r) ==
      setelt(qelt(m,i - minRowIndex m)$Rep,j - minColIndex m,r)

    setelt(m:%,i:Integer,j:Integer,r:R) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "setelt: index out of range"
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "setelt: index out of range"
      qsetelt_!(m,i,j,r)

    if R has SetCategory then
        latex(m : %) : String ==
          s : String := "\left[ \begin{array}{"
          j : Integer
          for j in minColIndex(m)..maxColIndex(m) repeat
            s := concat(s,"c")$String
          s := concat(s,"} ")$String
          i : Integer
          for i in minRowIndex(m)..maxRowIndex(m) repeat
            for j in minColIndex(m)..maxColIndex(m) repeat
              s := concat(s, latex(qelt(m,i,j))$R)$String
              if j < maxColIndex(m) then s := concat(s, " & ")$String
            if i < maxRowIndex(m) then s := concat(s, " \\ ")$String
          concat(s, "\end{array} \right]")$String

@
\section{domain IARRAY2 IndexedTwoDimensionalArray}
An IndexedTwoDimensionalArray is a 2-dimensional array where
the minimal row and column indices are parameters of the type.
Rows and columns are returned as IndexedOneDimensionalArray's with
minimal indices matching those of the IndexedTwoDimensionalArray.
The index of the 'first' row may be obtained by calling the
function 'minRowIndex'.  The index of the 'first' column may
be obtained by calling the function 'minColIndex'.  The index of
the first element of a 'Row' is the same as the index of the
first column in an array and vice versa.
<<dot>>=
"IARRAY2" -> "ARR2CAT"
"IndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer)" ->
"TwoDimensionalArrayCategory(a:Type,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
"IARRAY2" -> "IIARRAY2"
"IndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer)" ->
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
@
<<domain IARRAY2 IndexedTwoDimensionalArray>>=
)abbrev domain IARRAY2 IndexedTwoDimensionalArray
IndexedTwoDimensionalArray(R,mnRow,mnCol):Exports == Implementation where
  R : Type
  mnRow, mnCol : Integer
  Row ==> IndexedOneDimensionalArray(R,mnCol)
  Col ==> IndexedOneDimensionalArray(R,mnRow)

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col)

  Implementation ==>
    InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col)

@
\section{domain ARRAY2 TwoDimensionalArray}
<<TwoDimensionalArray.input>>=
-- array2.spad.pamphlet TwoDimensionalArray.input
)spool TwoDimensionalArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 20
arr : ARRAY2 INT := new(5,4,0)
--R 
--R
--R        +0  0  0  0+
--R        |          |
--R        |0  0  0  0|
--R        |          |
--R   (1)  |0  0  0  0|
--R        |          |
--R        |0  0  0  0|
--R        |          |
--R        +0  0  0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 1

--S 2 of 20
setelt(arr,1,1,17)
--R 
--R
--R   (2)  17
--R                                                        Type: PositiveInteger
--E 2

--S 3 of 20
arr
--R 
--R
--R        +17  0  0  0+
--R        |           |
--R        |0   0  0  0|
--R        |           |
--R   (3)  |0   0  0  0|
--R        |           |
--R        |0   0  0  0|
--R        |           |
--R        +0   0  0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 3

--S 4 of 20
elt(arr,1,1)
--R 
--R
--R   (4)  17
--R                                                        Type: PositiveInteger
--E 4

--S 5 of 20
arr(3,2) := 15
--R 
--R
--R   (5)  15
--R                                                        Type: PositiveInteger
--E 5

--S 6 of 20
arr(3,2)
--R 
--R
--R   (6)  15
--R                                                        Type: PositiveInteger
--E 6

--S 7 of 20
row(arr,1)
--R 
--R
--R   (7)  [17,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 7

--S 8 of 20
column(arr,1)
--R 
--R
--R   (8)  [17,0,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 8

--S 9 of 20
nrows(arr)
--R 
--R
--R   (9)  5
--R                                                        Type: PositiveInteger
--E 9

--S 10 of 20
ncols(arr)
--R 
--R
--R   (10)  4
--R                                                        Type: PositiveInteger
--E 10

--S 11 of 20
map(-,arr)
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (11)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 11

--S 12 of 20
map((x +-> x + x),arr)
--R 
--R
--R         +34  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (12)  |0   30  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 12

--S 13 of 20
arrc := copy(arr)
--R 
--R
--R         +17  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (13)  |0   15  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 13

--S 14 of 20
map!(-,arrc)
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (14)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 14

--S 15 of 20
arrc
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (15)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 15

--S 16 of 20
arr
--R 
--R
--R         +17  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (16)  |0   15  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 16

--S 17 of 20
member?(17,arr)
--R 
--R
--R   (17)  true
--R                                                                Type: Boolean
--E 17

--S 18 of 20
member?(10317,arr)
--R 
--R
--R   (18)  false
--R                                                                Type: Boolean
--E 18

--S 19 of 20
count(17,arr)
--R 
--R
--R   (19)  1
--R                                                        Type: PositiveInteger
--E 19

--S 20 of 20
count(0,arr)
--R 
--R
--R   (20)  18
--R                                                        Type: PositiveInteger
--E 20
)spool
)lisp (bye)
@
<<TwoDimensionalArray.help>>=
====================================================================
TwoDimensionalArray examples
====================================================================

The TwoDimensionalArray domain is used for storing data in a two
dimensional data structure indexed by row and by column.  Such an
array is a homogeneous data structure in that all the entries of the
array must belong to the same Axiom domain..  Each array has a fixed
number of rows and columns specified by the user and arrays are not
extensible.  In Axiom, the indexing of two-dimensional arrays is
one-based.  This means that both the "first" row of an array and the
"first" column of an array are given the index 1.  Thus, the entry
in the upper left corner of an array is in position (1,1).

The operation new creates an array with a specified number of rows and
columns and fills the components of that array with a specified entry.
The arguments of this operation specify the number of rows, the number
of columns, and the entry.

This creates a five-by-four array of integers, all of whose entries are
zero.

  arr : ARRAY2 INT := new(5,4,0)
        +0  0  0  0+
        |          |
        |0  0  0  0|
        |          |
        |0  0  0  0|
        |          |
        |0  0  0  0|
        |          |
        +0  0  0  0+
                         Type: TwoDimensionalArray Integer

The entries of this array can be set to other integers using setelt.

Issue this to set the element in the upper left corner of this array to 17.

  setelt(arr,1,1,17)
    17
                         Type: PositiveInteger

Now the first element of the array is 17.

  arr
        +17  0  0  0+
        |           |
        |0   0  0  0|
        |           |
        |0   0  0  0|
        |           |
        |0   0  0  0|
        |           |
        +0   0  0  0+
                         Type: TwoDimensionalArray Integer

Likewise, elements of an array are extracted using the operation elt.

  elt(arr,1,1)
    17
                         Type: PositiveInteger

Another way to use these two operations is as follows.  This sets the
element in position (3,2) of the array to 15.

  arr(3,2) := 15
    15
                         Type: PositiveInteger

This extracts the element in position (3,2) of the array.

  arr(3,2)
    15
                         Type: PositiveInteger

The operations elt and setelt come equipped with an error check which
verifies that the indices are in the proper ranges.  For example, the
above array has five rows and four columns, so if you ask for the
entry in position (6,2) with arr(6,2) Axiom displays an error message.
If there is no need for an error check, you can call the operations qelt 
and qsetelt which provide the same functionality but without the error 
check. Typically, these operations are called in well-tested programs.

The operations row and column extract rows and columns, respectively,
and return objects of OneDimensionalArray with the same underlying
element type.

  row(arr,1)
    [17,0,0,0]
                         Type: OneDimensionalArray Integer

  column(arr,1)
    [17,0,0,0,0]
                         Type: OneDimensionalArray Integer

You can determine the dimensions of an array by calling the operations
nrows and ncols, which return the number of rows and columns, respectively.

  nrows(arr)
    5
                         Type: PositiveInteger

  ncols(arr)
    4
                         Type: PositiveInteger

To apply an operation to every element of an array, use map.  This
creates a new array.  This expression negates every element.

  map(-,arr)
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

This creates an array where all the elements are doubled.

  map((x +-> x + x),arr)
         +34  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   30  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

To change the array destructively, use map instead of map.  If you
need to make a copy of any array, use copy.

  arrc := copy(arr)
         +17  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   15  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

  map!(-,arrc)
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

  arrc
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

  arr
         +17  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   15  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

Use member? to see if a given element is in an array.

  member?(17,arr)
    true
                         Type: Boolean

  member?(10317,arr)
    false
                         Type: Boolean

To see how many times an element appears in an array, use count.

  count(17,arr)
    1
                         Type: PositiveInteger

  count(0,arr)
    18
                         Type: PositiveInteger

See Also:
o )help Matrix
o )help OneDimensionalArray
o )show TwoDimensionalArray
o $AXIOM/doc/src/algebra/array2.spad.dvi

@
<<dot>>=
"ARRAY2" -> "ARR2CAT"
"TwoDimensionalArray(a:Type)" ->
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
"ARRAY2" -> "IIARRAY2"
"TwoDimensionalArray(a:Type)" ->
"InnerIndexedTwoDimensionalArray(a:Type,1,1,b:OneDimensionalArray(a),c:OneDimensionalArray(a))"
@
<<domain ARRAY2 TwoDimensionalArray>>=
)abbrev domain ARRAY2 TwoDimensionalArray
TwoDimensionalArray(R):Exports == Implementation where
  ++ A TwoDimensionalArray is a two dimensional array with
  ++ 1-based indexing for both rows and columns.
  R : Type
  Row ==> OneDimensionalArray R
  Col ==> OneDimensionalArray R

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col) with
    shallowlyMutable
      ++ One may destructively alter TwoDimensionalArray's.

  Implementation ==> InnerIndexedTwoDimensionalArray(R,1,1,Row,Col)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=

<<category ARR2CAT TwoDimensionalArrayCategory>>
<<domain IIARRAY2 InnerIndexedTwoDimensionalArray>>
<<domain IARRAY2 IndexedTwoDimensionalArray>>
<<domain ARRAY2 TwoDimensionalArray>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
