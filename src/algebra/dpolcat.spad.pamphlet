\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra dpolcat.spad}
\author{William Sit}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{category DVARCAT DifferentialVariableCategory}
<<category DVARCAT DifferentialVariableCategory>>=
)abbrev category DVARCAT DifferentialVariableCategory
++ Author:  William Sit
++ Date Created: 19 July 1990
++ Date Last Updated: 13 September 1991
++ Basic Operations:
++ Related Constructors:DifferentialPolynomialCategory
++ See Also:OrderedDifferentialVariable,
++          SequentialDifferentialVariable,
++          DifferentialSparseMultivariatePolynomial.
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, ranking, order, weight
++ References:Ritt, J.F. "Differential Algebra" (Dover, 1950).
++ Description:
++   \spadtype{DifferentialVariableCategory} constructs the
++   set of derivatives of a given set of
++   (ordinary) differential indeterminates.
++   If x,...,y is an ordered set of differential indeterminates,
++   and the prime notation is used for differentiation, then
++   the set of derivatives (including
++   zero-th order) of the differential indeterminates is
++   x,\spad{x'},\spad{x''},..., y,\spad{y'},\spad{y''},...
++   (Note: in the interpreter, the n-th derivative of y is displayed as
++   y with a subscript n.)  This set is
++   viewed as a set of algebraic indeterminates, totally ordered in a
++   way compatible with differentiation and the given order on the
++   differential indeterminates.  Such a total order is called a
++   ranking of the differential indeterminates.
++
++   A domain in this category is needed to construct a differential
++   polynomial domain.  Differential polynomials are ordered
++   by a ranking on the derivatives,  and by an order (extending the
++   ranking) on
++   on the set of differential monomials.  One may thus associate
++   a domain in this category with a ranking of the differential
++   indeterminates, just as one associates a domain in the category
++   \spadtype{OrderedAbelianMonoidSup} with an ordering of the set of
++   monomials in a set of algebraic indeterminates.  The ranking
++   is specified through the binary relation \spadfun{<}.
++   For example, one may define
++   one derivative to be less than another by lexicographically comparing
++   first the \spadfun{order}, then the given order of the differential
++   indeterminates appearing in the derivatives.  This is the default
++   implementation.
++
++   The notion of weight generalizes that of degree.  A
++   polynomial domain may be made into a graded ring
++   if a weight function is given on the set of indeterminates,
++   Very often, a grading is the first step in ordering the set of
++   monomials.  For differential polynomial domains, this
++   constructor provides a function \spadfun{weight}, which
++   allows the assignment of a non-negative number to each derivative of a
++   differential indeterminate.  For example, one may define
++   the weight of a derivative to be simply its \spadfun{order}
++   (this is the default assignment).
++   This weight function can then be extended to the set of
++   all differential polynomials, providing a graded ring
++   structure.
DifferentialVariableCategory(S:OrderedSet): Category ==
  Join(OrderedSet, RetractableTo S) with
    -- Examples:
    -- v:=makeVariable('s,5)
    makeVariable  : (S, NonNegativeInteger) -> $
       ++ makeVariable(s, n) returns the n-th derivative of a
       ++ differential indeterminate s as an algebraic indeterminate.
       -- Example: makeVariable('s, 5)
    order         : $ -> NonNegativeInteger
       ++ order(v) returns n if v is the n-th derivative of any
       ++ differential indeterminate.
       -- Example: order(v)
    variable      : $ -> S
       ++ variable(v) returns s if v is any derivative of the differential
       ++ indeterminate s.
       -- Example: variable(v)
          --  default implementation using above primitives --

    weight        : $ -> NonNegativeInteger
       ++ weight(v) returns the weight of the derivative v.
       -- Example: weight(v)
    differentiate : $ -> $
       ++ differentiate(v) returns the derivative of v.
       -- Example: differentiate(v)
    differentiate : ($, NonNegativeInteger) -> $
       ++ differentiate(v, n) returns the n-th derivative of v.
       -- Example: differentiate(v,2)
    coerce        : S  -> $
       ++ coerce(s) returns s, viewed as the zero-th order derivative of s.
       -- Example: coerce('s); differentiate(%,5)
 add
    import NumberFormats
    coerce (s:S):$ == makeVariable(s, 0)
    differentiate v     == differentiate(v, 1)
    differentiate(v, n) == makeVariable(variable v, n + order v)
    retractIfCan v == (zero?(order v) => variable v; "failed")
    v = u      == (variable v = variable u) and (order v = order u)

    coerce(v:$):OutputForm ==
      a := variable(v)::OutputForm
      zero?(nn := order v) => a
      sub(a, outputForm nn)
    retract v ==
      zero?(order v) => variable v
      error "Not retractable"
    v < u ==
      -- the ranking below is orderly, and is the default --
      order v = order u => variable v < variable u
      order v < order u
    weight v == order v
      --  the default weight is just the order

@
\section{domain ODVAR OrderlyDifferentialVariable}
<<domain ODVAR OrderlyDifferentialVariable>>=
)abbrev domain ODVAR OrderlyDifferentialVariable
++ Author:  William Sit
++ Date Created: 19 July 1990
++ Date Last Updated: 13 September 1991
++ Basic Operations:differentiate, order, variable,<
++ Related Domains: OrderedVariableList,
++                  SequentialDifferentialVariable.
++ See Also: DifferentialVariableCategory
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, orderly ranking.
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{OrderlyDifferentialVariable} adds a commonly used orderly
++   ranking to the set of derivatives of an ordered list of differential
++   indeterminates.  An orderly ranking is a ranking \spadfun{<} of the
++   derivatives with the property that for two derivatives u and v,
++   u \spadfun{<} v if the \spadfun{order} of u is less than that
++   of v.
++   This domain belongs to \spadtype{DifferentialVariableCategory}.  It
++   defines \spadfun{weight} to be just \spadfun{order}, and it
++   defines an orderly ranking \spadfun{<} on derivatives u via the
++   lexicographic order on the pair
++   (\spadfun{order}(u), \spadfun{variable}(u)).
OrderlyDifferentialVariable(S:OrderedSet):DifferentialVariableCategory(S)
  == add
    Rep := Record(var:S, ord:NonNegativeInteger)
    makeVariable(s,n) == [s, n]
    variable v     == v.var
    order v        == v.ord

@
\section{domain SDVAR SequentialDifferentialVariable}
<<domain SDVAR SequentialDifferentialVariable>>=
)abbrev domain SDVAR SequentialDifferentialVariable
++ Author:  William Sit
++ Date Created: 19 July 1990
++ Date Last Updated: 13 September 1991
++ Basic Operations:differentiate, order, variable, <
++ Related Domains: OrderedVariableList,
++                  OrderlyDifferentialVariable.
++ See Also:DifferentialVariableCategory
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, sequential ranking.
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{OrderlyDifferentialVariable} adds a commonly used sequential
++   ranking to the set of derivatives of an ordered list of differential
++   indeterminates.  A sequential ranking is a ranking \spadfun{<} of the
++   derivatives with the property that for any derivative v,
++   there are only a finite number of derivatives u with u \spadfun{<} v.
++   This domain belongs to \spadtype{DifferentialVariableCategory}.  It
++   defines \spadfun{weight} to be just \spadfun{order}, and it
++   defines a sequential ranking \spadfun{<} on derivatives u by the
++   lexicographic order on the pair
++   (\spadfun{variable}(u), \spadfun{order}(u)).

SequentialDifferentialVariable(S:OrderedSet):DifferentialVariableCategory(S)
  == add
    Rep := Record(var:S, ord:NonNegativeInteger)
    makeVariable(s,n) == [s, n]
    variable v     == v.var
    order v        == v.ord
    v < u ==
      variable v = variable u => order v < order u
      variable v < variable u

@
\section{category DPOLCAT DifferentialPolynomialCategory}
<<category DPOLCAT DifferentialPolynomialCategory>>=
)abbrev category DPOLCAT DifferentialPolynomialCategory
++ Author:  William Sit
++ Date Created: 19 July 1990
++ Date Last Updated: 13 September 1991
++ Basic Operations:PolynomialCategory
++ Related Constructors:DifferentialVariableCategory
++ See Also:
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, ranking, differential polynomials,
++           order, weight, leader, separant, initial, isobaric
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{DifferentialPolynomialCategory} is a category constructor
++   specifying basic functions in an ordinary differential polynomial
++   ring with a given ordered set of differential indeterminates.
++   In addition, it implements defaults for the basic functions.
++   The functions \spadfun{order} and \spadfun{weight} are extended
++   from the set of derivatives of differential indeterminates
++   to the set of differential polynomials.  Other operations
++   provided on differential polynomials are
++   \spadfun{leader}, \spadfun{initial},
++   \spadfun{separant}, \spadfun{differentialVariables}, and
++   \spadfun{isobaric?}.   Furthermore, if the ground ring is
++   a differential ring, then evaluation (substitution
++   of differential indeterminates by elements of the ground ring
++   or by differential polynomials) is
++   provided by \spadfun{eval}.
++   A convenient way of referencing derivatives is provided by
++   the functions \spadfun{makeVariable}.
++
++   To construct a domain using this constructor, one needs
++   to provide a ground ring R, an ordered set S of differential
++   indeterminates, a ranking V on the set of derivatives
++   of the differential indeterminates, and a set E of
++   exponents in bijection with the set of differential monomials
++   in the given differential indeterminates.
++

DifferentialPolynomialCategory(R:Ring,S:OrderedSet,
  V:DifferentialVariableCategory S, E:OrderedAbelianMonoidSup):
              Category ==
  Join(PolynomialCategory(R,E,V),
       DifferentialExtension R, RetractableTo S) with
    -- Examples:
    -- s:=makeVariable('s)
    -- p:= 3*(s 1)**2 + s*(s 2)**3
    --  all functions below have default implementations
    --  using primitives from V

    makeVariable: S -> (NonNegativeInteger -> $)
       ++ makeVariable(s) views s as a differential
       ++ indeterminate,  in such a way that the n-th
       ++ derivative of s may be simply referenced as z.n
       ++ where z :=makeVariable(s).
       ++ Note: In the interpreter, z is
       ++ given as an internal map, which may be ignored.
       -- Example: makeVariable('s); %.5

    differentialVariables: $ ->  List S
      ++ differentialVariables(p) returns a list of differential
      ++ indeterminates occurring in a differential polynomial p.
    order : ($, S) -> NonNegativeInteger
      ++ order(p,s) returns the order of the differential
      ++ polynomial p in differential indeterminate s.
    order : $   -> NonNegativeInteger
      ++ order(p) returns the order of the differential polynomial p,
      ++ which is the maximum number of differentiations of a
      ++ differential indeterminate, among all those appearing in p.
    degree: ($, S) -> NonNegativeInteger
      ++ degree(p, s) returns the maximum degree of
      ++ the differential polynomial p viewed as a differential polynomial
      ++ in the differential indeterminate s alone.
    weights: $ -> List NonNegativeInteger
      ++ weights(p) returns a list of weights of differential monomials
      ++ appearing in differential polynomial p.
    weight: $   -> NonNegativeInteger
      ++ weight(p) returns the maximum weight of all differential monomials
      ++ appearing in the differential polynomial p.
    weights: ($, S) -> List NonNegativeInteger
      ++ weights(p, s) returns a list of
      ++ weights of differential monomials
      ++ appearing in the differential polynomial p when p is viewed
      ++ as a differential polynomial in the differential indeterminate s
      ++ alone.
    weight: ($, S) -> NonNegativeInteger
      ++ weight(p, s) returns the maximum weight of all differential
      ++ monomials appearing in the differential polynomial p
      ++ when p is viewed as a differential polynomial in
      ++ the differential indeterminate s alone.
    isobaric?: $ -> Boolean
      ++ isobaric?(p) returns true if every differential monomial appearing
      ++ in the differential polynomial p has same weight,
      ++ and returns false otherwise.
    leader: $   -> V
      ++ leader(p) returns the derivative of the highest rank
      ++ appearing in the differential polynomial p
      ++ Note: an error occurs if p is in the ground ring.
    initial:$   -> $
      ++ initial(p) returns the
      ++ leading coefficient when the differential polynomial p
      ++ is written as a univariate polynomial in its leader.
    separant:$  -> $
      ++ separant(p) returns the
      ++ partial derivative of the differential polynomial p
      ++ with respect to its leader.
    if R has DifferentialRing then
      InnerEvalable(S, R)
      InnerEvalable(S, $)
      Evalable $
      makeVariable: $ -> (NonNegativeInteger -> $)
       ++ makeVariable(p) views p as an element of a differential
       ++ ring,  in such a way that the n-th
       ++ derivative of p may be simply referenced as z.n
       ++ where z := makeVariable(p).
       ++ Note: In the interpreter, z is
       ++ given as an internal map, which may be ignored.
       -- Example: makeVariable(p); %.5; makeVariable(%**2); %.2

 add
    p:$
    s:S
    makeVariable s == makeVariable(s,#1)::$

    if R has IntegralDomain then
      differentiate(p:$, d:R -> R) ==
        ans:$ := 0
        l := variables p
        while (u:=retractIfCan(p)@Union(R, "failed")) case "failed" repeat
          t := leadingMonomial p
          lc := leadingCoefficient t
          ans := ans + d(lc)::$ * (t exquo lc)::$
              + +/[differentiate(t, v) * (differentiate v)::$ for v in l]
          p := reductum p
        ans + d(u::R)::$

    order (p:$):NonNegativeInteger ==
      ground? p => 0
      "max"/[order v for v in variables p]
    order (p:$,s:S):NonNegativeInteger ==
      ground? p => 0
      empty? (vv:= [order v for v in variables p | (variable v) = s ]) =>0
      "max"/vv

    degree (p, s) ==
      d:NonNegativeInteger:=0
      for lp in monomials p repeat
        lv:= [v for v in variables lp | (variable v) = s ]
        if not empty? lv then d:= max(d, +/degree(lp, lv))
      d

    weights p ==
      ws:List NonNegativeInteger := nil
      empty? (mp:=monomials p) => ws
      for lp in mp repeat
        lv:= variables lp
        if not empty? lv then
          dv:= degree(lp, lv)
          w:=+/[(weight v) * d for v in lv for d in dv]$(List NonNegativeInteger)
          ws:= concat(ws, w)
      ws
    weight p ==
      empty? (ws:=weights p) => 0
      "max"/ws

    weights (p, s) ==
      ws:List NonNegativeInteger := nil
      empty?(mp:=monomials p) => ws
      for lp in mp repeat
        lv:= [v for v in variables lp | (variable v) = s ]
        if not empty? lv then
          dv:= degree(lp, lv)
          w:=+/[(weight v) * d for v in lv for d in dv]$(List NonNegativeInteger)
          ws:= concat(ws, w)
      ws
    weight (p,s)  ==
      empty? (ws:=weights(p,s)) => 0
      "max"/ws

    isobaric? p == (# removeDuplicates weights p) = 1

    leader p ==             -- depends on the ranking
      vl:= variables p
      -- it's not enough just to look at leadingMonomial p
      -- the term-ordering need not respect the ranking
      empty? vl => error "leader is not defined "
      "max"/vl
    initial p == leadingCoefficient univariate(p,leader p)
    separant p == differentiate(p, leader p)

    coerce(s:S):$   == s::V::$

    retractIfCan(p:$):Union(S, "failed") ==
      (v := retractIfCan(p)@Union(V,"failed")) case "failed" => "failed"
      retractIfCan(v::V)

    differentialVariables p ==
      removeDuplicates [variable v for v in variables p]

    if R has DifferentialRing then

      makeVariable p == differentiate(p, #1)

      eval(p:$, sl:List S, rl:List R) ==
        ordp:= order p
        vl  := concat [[makeVariable(s,j)$V for j in  0..ordp]
                                for s in sl]$List(List V)
        rrl:=nil$List(R)
        for r in rl repeat
          t:= r
          rrl:= concat(rrl,
                concat(r, [t := differentiate t for i in 1..ordp]))
        eval(p, vl, rrl)

      eval(p:$, sl:List S, rl:List $) ==
        ordp:= order p
        vl  := concat [[makeVariable(s,j)$V for j in  0..ordp]
                                for s in sl]$List(List V)
        rrl:=nil$List($)
        for r in rl repeat
          t:=r
          rrl:=concat(rrl,
               concat(r, [t:=differentiate t for i in 1..ordp]))
        eval(p, vl, rrl)
      eval(p:$, l:List Equation $) ==
        eval(p, [retract(lhs e)@S for e in l]$List(S),
              [rhs e for e in l]$List($))

@
\section{domain DSMP DifferentialSparseMultivariatePolynomial}
<<domain DSMP DifferentialSparseMultivariatePolynomial>>=
)abbrev domain DSMP DifferentialSparseMultivariatePolynomial
++ Author:  William Sit
++ Date Created: 19 July 1990
++ Date Last Updated: 13 September 1991
++ Basic Operations:DifferentialPolynomialCategory
++ Related Constructors:
++ See Also:
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, ranking, differential polynomials,
++           order, weight, leader, separant, initial, isobaric
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{DifferentialSparseMultivariatePolynomial} implements
++   an ordinary differential polynomial ring by combining a
++   domain belonging to the category \spadtype{DifferentialVariableCategory}
++   with the domain \spadtype{SparseMultivariatePolynomial}.
++

DifferentialSparseMultivariatePolynomial(R, S, V):
     Exports == Implementation where
  R: Ring
  S: OrderedSet
  V: DifferentialVariableCategory S
  E   ==> IndexedExponents(V)
  PC  ==> PolynomialCategory(R,IndexedExponents(V),V)
  PCL ==> PolynomialCategoryLifting
  P   ==> SparseMultivariatePolynomial(R, V)
  SUP ==> SparseUnivariatePolynomial
  SMP ==> SparseMultivariatePolynomial(R, S)

  Exports ==> Join(DifferentialPolynomialCategory(R,S,V,E),
                   RetractableTo SMP)

  Implementation ==> P add
    retractIfCan(p:$):Union(SMP, "failed") ==
      zero? order p =>
        map(retract(#1)@S :: SMP, #1::SMP, p)$PCL(
                                  IndexedExponents V, V, R, $, SMP)
      "failed"

    coerce(p:SMP):$ ==
      map(#1::V::$, #1::$, p)$PCL(IndexedExponents S, S, R, SMP, $)

@
\section{domain ODPOL OrderlyDifferentialPolynomial}
<<OrderlyDifferentialPolynomial.input>>=
-- dpolcat.spad.pamphlet OrderlyDifferentialPolynomial.input
)spool OrderlyDifferentialPolynomial.output
)set message test on
)set message auto off
)clear all
--S 1 of 36
dpol:= ODPOL(FRAC INT)
--R 
--R
--R   (1)  OrderlyDifferentialPolynomial Fraction Integer
--R                                                                 Type: Domain
--E 1

--S 2 of 36
w := makeVariable('w)$dpol
--R 
--R
--R   (2)  theMap(DPOLCAT-;makeVariable;AM;17!0,0)
--R Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)
--E 2

--S 3 of 36
z := makeVariable('z)$dpol
--R 
--R
--R   (3)  theMap(DPOLCAT-;makeVariable;AM;17!0,0)
--R Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)
--E 3

--S 4 of 36
w.5
--R 
--R
--R   (4)  w
--R         5
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 4

--S 5 of 36
w 0
--R 
--R
--R   (5)  w
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 5

--S 6 of 36
[z.i for i in 1..5]
--R 
--R
--R   (6)  [z ,z ,z ,z ,z ]
--R          1  2  3  4  5
--R                    Type: List OrderlyDifferentialPolynomial Fraction Integer
--E 6

--S 7 of 36
f:= w.4 - w.1 * w.1 * z.3 
--R 
--R
--R               2
--R   (7)  w  - w  z
--R         4    1  3
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 7

--S 8 of 36
g:=(z.1)**3 * (z.2)**2 - w.2
--R 
--R
--R          3  2
--R   (8)  z  z   - w
--R         1  2     2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 8

--S 9 of 36
D(f)
--R 
--R
--R               2
--R   (9)  w  - w  z  - 2w w z
--R         5    1  4     1 2 3
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 9

--S 10 of 36
D(f,4)
--R 
--R
--R   (10)
--R            2                               2
--R     w  - w  z  - 8w w z  + (- 12w w  - 12w  )z  - 2w z w
--R      8    1  7     1 2 6         1 3      2   5     1 3 5
--R   + 
--R                                         2
--R     (- 8w w  - 24w w )z  - 8w z w  - 6w  z
--R          1 4      2 3  4     2 3 4     3  3
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 10

--S 11 of 36
df:=makeVariable(f)$dpol
--R 
--R
--R   (11)  theMap(DPOLCAT-;makeVariable;AM;17!0,0)
--R Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)
--E 11

--S 12 of 36
df.4
--R 
--R
--R   (12)
--R            2                               2
--R     w  - w  z  - 8w w z  + (- 12w w  - 12w  )z  - 2w z w
--R      8    1  7     1 2 6         1 3      2   5     1 3 5
--R   + 
--R                                         2
--R     (- 8w w  - 24w w )z  - 8w z w  - 6w  z
--R          1 4      2 3  4     2 3 4     3  3
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 12

--S 13 of 36
order(g)
--R 
--R
--R   (13)  2
--R                                                        Type: PositiveInteger
--E 13

--S 14 of 36
order(g, 'w)
--R 
--R
--R   (14)  2
--R                                                        Type: PositiveInteger
--E 14

--S 15 of 36
differentialVariables(g)
--R 
--R
--R   (15)  [z,w]
--R                                                            Type: List Symbol
--E 15

--S 16 of 36
degree(g)
--R 
--R
--R           2  3
--R   (16)  z  z
--R          2  1
--R                    Type: IndexedExponents OrderlyDifferentialVariable Symbol
--E 16

--S 17 of 36
degree(g, 'w) 
--R 
--R
--R   (17)  1
--R                                                        Type: PositiveInteger
--E 17

--S 18 of 36
weights(g)
--R 
--R
--R   (18)  [7,2]
--R                                                Type: List NonNegativeInteger
--E 18

--S 19 of 36
weights(g,'w)
--R 
--R
--R   (19)  [2]
--R                                                Type: List NonNegativeInteger
--E 19

--S 20 of 36
weight(g)
--R 
--R
--R   (20)  7
--R                                                        Type: PositiveInteger
--E 20

--S 21 of 36
isobaric?(g)
--R 
--R
--R   (21)  false
--R                                                                Type: Boolean
--E 21

--S 22 of 36
eval(g,['w::Symbol],[f])
--R 
--R
--R                  2                           2        3  2
--R   (22)  - w  + w  z  + 4w w z  + (2w w  + 2w  )z  + z  z
--R            6    1  5     1 2 4      1 3     2   3    1  2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 22

--S 23 of 36
eval(g,variables(w.0),[f])
--R 
--R
--R           3  2
--R   (23)  z  z   - w
--R          1  2     2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 23

--S 24 of 36
monomials(g)
--R 
--R
--R            3  2
--R   (24)  [z  z  ,- w ]
--R           1  2     2
--R                    Type: List OrderlyDifferentialPolynomial Fraction Integer
--E 24

--S 25 of 36
variables(g)
--R 
--R
--R   (25)  [z ,w ,z ]
--R           2  2  1
--R                                Type: List OrderlyDifferentialVariable Symbol
--E 25

--S 26 of 36
gcd(f,g)
--R 
--R
--R   (26)  1
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 26

--S 27 of 36
groebner([f,g])
--R 
--R
--R                 2     3  2
--R   (27)  [w  - w  z ,z  z   - w ]
--R           4    1  3  1  2     2
--R                    Type: List OrderlyDifferentialPolynomial Fraction Integer
--E 27

--S 28 of 36
lg:=leader(g)
--R 
--R
--R   (28)  z
--R          2
--R                                     Type: OrderlyDifferentialVariable Symbol
--E 28

--S 29 of 36
sg:=separant(g)
--R 
--R
--R            3
--R   (29)  2z  z
--R           1  2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 29

--S 30 of 36
ig:=initial(g)
--R 
--R
--R           3
--R   (30)  z
--R          1
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 30

--S 31 of 36
g1 := D g
--R 
--R
--R            3               2  3
--R   (31)  2z  z z  - w  + 3z  z
--R           1  2 3    3     1  2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 31

--S 32 of 36
lg1:= leader g1
--R 
--R
--R   (32)  z
--R          3
--R                                     Type: OrderlyDifferentialVariable Symbol
--E 32

--S 33 of 36
pdf:=D(f, lg1)
--R 
--R
--R             2
--R   (33)  - w
--R            1
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 33

--S 34 of 36
prf:=sg * f- pdf * g1
--R 
--R
--R            3         2        2  2  3
--R   (34)  2z  z w  - w  w  + 3w  z  z
--R           1  2 4    1  3     1  1  2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 34

--S 35 of 36
lcf:=leadingCoefficient univariate(prf, lg)
--R 
--R
--R            2  2
--R   (35)  3w  z
--R           1  1
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 35

--S 36 of 36
ig * prf - lcf * g * lg
--R 
--R
--R            6         2  3        2  2
--R   (36)  2z  z w  - w  z  w  + 3w  z  w z
--R           1  2 4    1  1  3     1  1  2 2
--R                         Type: OrderlyDifferentialPolynomial Fraction Integer
--E 36
)spool
)lisp (bye)
@
<<OrderlyDifferentialPolynomial.help>>=
====================================================================
OrderlyDifferentialPolynomial examples
====================================================================

Many systems of differential equations may be transformed to equivalent 
systems of ordinary differential equations where the equations are expressed 
polynomially in terms of the unknown functions.  In Axiom, the domain 
constructors OrderlyDifferentialPolynomial (abbreviated ODPOL) and
SequentialDifferentialPolynomial (abbreviation SDPOL) implement two
domains of ordinary differential polynomials over any differential
ring.  In the simplest case, this differential ring is usually either
the ring of integers, or the field of rational numbers.  However,
Axiom can handle ordinary differential polynomials over a field of
rational functions in a single indeterminate.

The two domains ODPOL and SDPOL are almost identical, the only difference 
being the choice of a different ranking, which is an ordering of the 
derivatives of the indeterminates.  The first domain uses an orderly ranking, 
that is, derivatives of higher order are ranked higher, and derivatives of 
the same order are ranked alphabetically.  The second domain uses a 
sequential ranking, where derivatives are ordered first alphabetically 
by the differential indeterminates, and then by order.  A more general 
domain constructor, DifferentialSparseMultivariatePolynomial (abbreviation 
DSMP) allows both a user-provided list of differential indeterminates
as well as a user-defined ranking.  We shall illustrate ODPOL(FRAC INT), 
which constructs a domain of ordinary differential polynomials in an 
arbitrary number of differential indeterminates with rational numbers 
as coefficients.

  dpol:= ODPOL(FRAC INT)
    OrderlyDifferentialPolynomial Fraction Integer
                            Type: Domain

A differential indeterminate w may be viewed as an infinite sequence of 
algebraic indeterminates, which are the derivatives of w. To facilitate 
referencing these, Axiom provides the operation makeVariable to convert 
an element of type Symbol to a map from the natural numbers to the 
differential polynomial ring.

  w := makeVariable('w)$dpol
    theMap(DPOLCAT-;makeVariable;AM;17!0,0)
 Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)

  z := makeVariable('z)$dpol
    theMap(DPOLCAT-;makeVariable;AM;17!0,0)
 Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)

The fifth derivative of w can be obtained by applying the map w to the 
number 5.  Note that the order of differentiation is given as a subscript 
(except when the order is 0).

  w.5
    w
     5
                      Type: OrderlyDifferentialPolynomial Fraction Integer

  w 0
    w
                      Type: OrderlyDifferentialPolynomial Fraction Integer

The first five derivatives of z can be generated by a list.

  [z.i for i in 1..5]
    [z ,z ,z ,z ,z ]
      1  2  3  4  5
                    Type: List OrderlyDifferentialPolynomial Fraction Integer

The usual arithmetic can be used to form a differential polynomial from
the derivatives.

  f:= w.4 - w.1 * w.1 * z.3 
           2
    w  - w  z
     4    1  3
                    Type: OrderlyDifferentialPolynomial Fraction Integer

  g:=(z.1)**3 * (z.2)**2 - w.2
      3  2
    z  z   - w
     1  2     2
                    Type: OrderlyDifferentialPolynomial Fraction Integer

The operation D computes the derivative of any differential polynomial.

  D(f)
           2
    w  - w  z  - 2w w z
     5    1  4     1 2 3
                    Type: OrderlyDifferentialPolynomial Fraction Integer

The same operation can compute higher derivatives, like the fourth derivative.

  D(f,4)
            2                               2
     w  - w  z  - 8w w z  + (- 12w w  - 12w  )z  - 2w z w
      8    1  7     1 2 6         1 3      2   5     1 3 5
   + 
                                         2
     (- 8w w  - 24w w )z  - 8w z w  - 6w  z
          1 4      2 3  4     2 3 4     3  3
                         Type: OrderlyDifferentialPolynomial Fraction Integer

The operation makeVariable creates a map to facilitate referencing the 
derivatives of f, similar to the map w.

  df:=makeVariable(f)$dpol
    theMap(DPOLCAT-;makeVariable;AM;17!0,0)
 Type: (NonNegativeInteger -> OrderlyDifferentialPolynomial Fraction Integer)

The fourth derivative of f may be referenced easily.

  df.4
            2                               2
     w  - w  z  - 8w w z  + (- 12w w  - 12w  )z  - 2w z w
      8    1  7     1 2 6         1 3      2   5     1 3 5
   + 
                                         2
     (- 8w w  - 24w w )z  - 8w z w  - 6w  z
          1 4      2 3  4     2 3 4     3  3
                    Type: OrderlyDifferentialPolynomial Fraction Integer

The operation order returns the order of a differential polynomial, 
or the order in a specified differential indeterminate.

  order(g)
    2
                    Type: PositiveInteger

  order(g, 'w)
    2
                    Type: PositiveInteger

The operation differentialVariables returns a list of differential 
indeterminates occurring in a differential polynomial.

  differentialVariables(g)
    [z,w]
                    Type: List Symbol

The operation degree returns the degree, or the degree in the differential 
indeterminate specified.

  degree(g)
       2  3
     z  z
      2  1
                    Type: IndexedExponents OrderlyDifferentialVariable Symbol

  degree(g, 'w) 
    1
                    Type: PositiveInteger

The operation weights returns a list of weights of differential monomials 
appearing in differential polynomial, or a list of weights in a specified 
differential indeterminate.

  weights(g)
    [7,2]
                    Type: List NonNegativeInteger

  weights(g,'w)
    [2]
                    Type: List NonNegativeInteger

The operation weight returns the maximum weight of all differential 
monomials appearing in the differential polynomial.

  weight(g)
    7
                    Type: PositiveInteger

A differential polynomial is isobaric if the weights of all differential 
monomials appearing in it are equal.

  isobaric?(g)
    false
                    Type: Boolean

To substitute differentially, use eval. Note that we must coerce 'w to 
Symbol, since in ODPOL, differential indeterminates belong to the domain 
Symbol.  Compare this result to the next, which substitutes algebraically
(no substitution is done since w.0 does not appear in g).

  eval(g,['w::Symbol],[f])
              2                           2        3  2
     - w  + w  z  + 4w w z  + (2w w  + 2w  )z  + z  z
        6    1  5     1 2 4      1 3     2   3    1  2
                    Type: OrderlyDifferentialPolynomial Fraction Integer

  eval(g,variables(w.0),[f])
       3  2
     z  z   - w
      1  2     2
                    Type: OrderlyDifferentialPolynomial Fraction Integer

Since OrderlyDifferentialPolynomial belongs to PolynomialCategory, all 
the operations defined in the latter category, or in packages for the 
latter category, are available.

  monomials(g)
        3  2
     [z  z  ,- w ]
       1  2     2
                    Type: List OrderlyDifferentialPolynomial Fraction Integer

  variables(g)
    [z ,w ,z ]
      2  2  1
                    Type: List OrderlyDifferentialVariable Symbol

  gcd(f,g)
    1
                    Type: OrderlyDifferentialPolynomial Fraction Integer

  groebner([f,g])
             2     3  2
     [w  - w  z ,z  z   - w ]
       4    1  3  1  2     2
                    Type: List OrderlyDifferentialPolynomial Fraction Integer

The next three operations are essential for elimination procedures in
differential polynomial rings.  The operation leader returns the leader
of a differential polynomial, which is the highest ranked derivative
of the differential indeterminates that occurs.

  lg:=leader(g)
     z
      2
                    Type: OrderlyDifferentialVariable Symbol

The operation separant returns the separant of a differential polynomial, 
which is the partial derivative with respect to the leader.

  sg:=separant(g)
       3
    2z  z
      1  2
                    Type: OrderlyDifferentialPolynomial Fraction Integer

The operation initial returns the initial, which is the leading coefficient 
when the given differential polynomial is expressed as a polynomial in 
the leader.

  ig:=initial(g)
      3
    z
     1
                    Type: OrderlyDifferentialPolynomial Fraction Integer

Using these three operations, it is possible to reduce f modulo the 
differential ideal generated by g.  The general scheme is to first 
reduce the order, then reduce the degree in the leader.  First, eliminate 
z.3 using the derivative of g.

  g1 := D g
       3               2  3
    2z  z z  - w  + 3z  z
      1  2 3    3     1  2
                    Type: OrderlyDifferentialPolynomial Fraction Integer

Find its leader.

  lg1:= leader g1
    z
     3
                    Type: OrderlyDifferentialVariable Symbol

Differentiate f partially with respect to this leader.

  pdf:=D(f, lg1)
        2
    - w
       1
                    Type: OrderlyDifferentialPolynomial Fraction Integer

Compute the partial remainder of f with respect to g.

  prf:=sg * f- pdf * g1
       3         2        2  2  3
    2z  z w  - w  w  + 3w  z  z
      1  2 4    1  3     1  1  2
                     Type: OrderlyDifferentialPolynomial Fraction Integer

Note that high powers of lg still appear in prf.  Compute the leading 
coefficient of prf as a polynomial in the leader of g.

  lcf:=leadingCoefficient univariate(prf, lg)
       2  2
    3w  z
      1  1
                     Type: OrderlyDifferentialPolynomial Fraction Integer

Finally, continue eliminating the high powers of lg appearing in prf to 
obtain the (pseudo) remainder of f modulo g and its derivatives.

  ig * prf - lcf * g * lg
       6         2  3        2  2
    2z  z w  - w  z  w  + 3w  z  w z
      1  2 4    1  1  3     1  1  2 2
                     Type: OrderlyDifferentialPolynomial Fraction Integer

See Also:
o )show OrderlyDifferentialPolynomial
o $AXIOM/doc/src/algebra/dpolcat.spad.dvi

@
<<domain ODPOL OrderlyDifferentialPolynomial>>=
)abbrev domain ODPOL OrderlyDifferentialPolynomial
++ Author:  William Sit
++ Date Created: 24 September, 1991
++ Date Last Updated: 7 February, 1992
++ Basic Operations:DifferentialPolynomialCategory
++ Related Constructors: DifferentialSparseMultivariatePolynomial
++ See Also:
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, ranking, differential polynomials,
++           order, weight, leader, separant, initial, isobaric
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{OrderlyDifferentialPolynomial} implements
++   an ordinary differential polynomial ring in arbitrary number
++   of differential indeterminates, with coefficients in a
++   ring.  The ranking on the differential indeterminate is orderly.
++   This is analogous to the domain \spadtype{Polynomial}.
++

OrderlyDifferentialPolynomial(R):
     Exports == Implementation where
  R: Ring
  S  ==> Symbol
  V  ==> OrderlyDifferentialVariable S
  E   ==> IndexedExponents(V)
  SMP ==> SparseMultivariatePolynomial(R, S)
  Exports ==> Join(DifferentialPolynomialCategory(R,S,V,E),
                   RetractableTo SMP)

  Implementation ==> DifferentialSparseMultivariatePolynomial(R,S,V)

@
\section{domain SDPOL SequentialDifferentialPolynomial}
<<domain SDPOL SequentialDifferentialPolynomial>>=
)abbrev domain SDPOL SequentialDifferentialPolynomial
++ Author:  William Sit
++ Date Created: 24 September, 1991
++ Date Last Updated: 7 February, 1992
++ Basic Operations:DifferentialPolynomialCategory
++ Related Constructors: DifferentialSparseMultivariatePolynomial
++ See Also:
++ AMS Classifications:12H05
++ Keywords: differential indeterminates, ranking, differential polynomials,
++           order, weight, leader, separant, initial, isobaric
++ References:Kolchin, E.R. "Differential Algebra and Algebraic Groups"
++   (Academic Press, 1973).
++ Description:
++   \spadtype{SequentialDifferentialPolynomial} implements
++   an ordinary differential polynomial ring in arbitrary number
++   of differential indeterminates, with coefficients in a
++   ring.  The ranking on the differential indeterminate is sequential.
++

SequentialDifferentialPolynomial(R):
     Exports == Implementation where
  R: Ring
  S  ==> Symbol
  V  ==> SequentialDifferentialVariable S
  E   ==> IndexedExponents(V)
  SMP ==> SparseMultivariatePolynomial(R, S)
  Exports ==> Join(DifferentialPolynomialCategory(R,S,V,E),
                   RetractableTo SMP)

  Implementation ==> DifferentialSparseMultivariatePolynomial(R,S,V)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<category DVARCAT DifferentialVariableCategory>>
<<domain ODVAR OrderlyDifferentialVariable>>
<<domain SDVAR SequentialDifferentialVariable>>
<<category DPOLCAT DifferentialPolynomialCategory>>
<<domain DSMP DifferentialSparseMultivariatePolynomial>>
<<domain ODPOL OrderlyDifferentialPolynomial>>
<<domain SDPOL SequentialDifferentialPolynomial>>

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
