\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra contfrac.spad}
\author{Stephen M. Watt, Clifton J. Williamson, Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain CONTFRAC ContinuedFraction}
<<ContinuedFraction.input>>=
-- contfrac.spad.pamphlet ContinuedFraction.input
)spool ContinuedFraction.output
)set message test on
)set message auto off
)clear all
--S 1 of 22
c := continuedFraction(314159/100000)
--R 
--R
--R              1 |     1  |     1 |     1  |     1 |     1 |     1 |
--R   (1)  3 + +---+ + +----+ + +---+ + +----+ + +---+ + +---+ + +---+
--R            | 7     | 15     | 1     | 25     | 1     | 7     | 4
--R                                              Type: ContinuedFraction Integer
--E 1

--S 2 of 22
partialQuotients c
--R 
--R
--R   (2)  [3,7,15,1,25,1,7,4]
--R                                                         Type: Stream Integer
--E 2

--S 3 of 22
convergents c
--R 
--R
--R           22 333 355 9208 9563 76149 314159
--R   (3)  [3,--,---,---,----,----,-----,------]
--R            7 106 113 2931 3044 24239 100000
--R                                                Type: Stream Fraction Integer
--E 3

--S 4 of 22
approximants c
--R 
--R
--R                                      ______
--R           22 333 355 9208 9563 76149 314159
--R   (4)  [3,--,---,---,----,----,-----,------]
--R            7 106 113 2931 3044 24239 100000
--R                                                Type: Stream Fraction Integer
--E 4

--S 5 of 22
pq := partialQuotients(1/c)
--R 
--R
--R   (5)  [0,3,7,15,1,25,1,7,4]
--R                                                         Type: Stream Integer
--E 5

--S 6 of 22
continuedFraction(first pq,repeating [1],rest pq)
--R 
--R
--R          1 |     1 |     1  |     1 |     1  |     1 |     1 |     1 |
--R   (6)  +---+ + +---+ + +----+ + +---+ + +----+ + +---+ + +---+ + +---+
--R        | 3     | 7     | 15     | 1     | 25     | 1     | 7     | 4
--R                                              Type: ContinuedFraction Integer
--E 6

--S 7 of 22
z:=continuedFraction(3,repeating [1],repeating [3,6])
--R 
--R
--R   (7)
--R           1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |
--R     3 + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+
--R         | 3     | 6     | 3     | 6     | 3     | 6     | 3     | 6     | 3
--R   + 
--R       1 |
--R     +---+ + ...
--R     | 6
--R                                              Type: ContinuedFraction Integer
--E 7

--S 8 of 22
dens:Stream Integer := cons(1,generate((x+->x+4),6))
--R 
--R
--R   (8)  [1,6,10,14,18,22,26,30,34,38,...]
--R                                                         Type: Stream Integer
--E 8

--S 9 of 22
cf := continuedFraction(0,repeating [1],dens)
--R 
--R
--R   (9)
--R       1 |     1 |     1  |     1  |     1  |     1  |     1  |     1  |
--R     +---+ + +---+ + +----+ + +----+ + +----+ + +----+ + +----+ + +----+
--R     | 1     | 6     | 10     | 14     | 18     | 22     | 26     | 30
--R   + 
--R       1  |     1  |
--R     +----+ + +----+ + ...
--R     | 34     | 38
--R                                              Type: ContinuedFraction Integer
--E 9

--S 10 of 22
ccf := convergents cf
--R 
--R
--R              6 61  860 15541 342762  8927353 268163352  9126481321
--R   (10)  [0,1,-,--,----,-----,------,--------,---------,-----------,...]
--R              7 71 1001 18089 398959 10391023 312129649 10622799089
--R                                                Type: Stream Fraction Integer
--E 10

--S 11 of 22
eConvergents := [2*e + 1 for e in ccf]
--R 
--R
--R              19 193 2721 49171 1084483 28245729 848456353 28875761731
--R   (11)  [1,3,--,---,----,-----,-------,--------,---------,-----------,...]
--R               7  71 1001 18089  398959 10391023 312129649 10622799089
--R                                                Type: Stream Fraction Integer
--E 11

--S 12 of 22
eConvergents :: Stream Float
--R 
--R
--R   (12)
--R   [1.0, 3.0, 2.7142857142 857142857, 2.7183098591 549295775,
--R    2.7182817182 817182817, 2.7182818287 356957267, 2.7182818284 585634113,
--R    2.7182818284 590458514, 2.7182818284 590452348, 2.7182818284 590452354,
--R    ...]
--R                                                           Type: Stream Float
--E 12

--S 13 of 22
exp 1.0
--R 
--R
--R   (13)  2.7182818284 590452354
--R                                                                  Type: Float
--E 13

--S 14 of 22
cf := continuedFraction(1,[(2*i+1)**2 for i in 0..],repeating [2])
--R 
--R
--R   (14)
--R           1 |     9 |     25 |     49 |     81 |     121 |     169 |     225 |
--R     1 + +---+ + +---+ + +----+ + +----+ + +----+ + +-----+ + +-----+ + +-----+
--R         | 2     | 2     | 2      | 2      | 2      |  2      |  2      |  2
--R   + 
--R       289 |     361 |
--R     +-----+ + +-----+ + ...
--R     |  2      |  2
--R                                              Type: ContinuedFraction Integer
--E 14

--S 15 of 22
ccf := convergents cf
--R 
--R
--R            3 15 105 315 3465 45045 45045 765765 14549535
--R   (15)  [1,-,--,---,---,----,-----,-----,------,--------,...]
--R            2 13  76 263 2578 36979 33976 622637 11064338
--R                                                Type: Stream Fraction Integer
--E 15

--S 16 of 22
piConvergents := [4/p for p in ccf] 
--R 
--R
--R            8 52 304 1052 10312 147916 135904 2490548 44257352
--R   (16)  [4,-,--,---,----,-----,------,------,-------,--------,...]
--R            3 15 105  315  3465  45045  45045  765765 14549535
--R                                                Type: Stream Fraction Integer
--E 16

--S 17 of 22
piConvergents :: Stream Float
--R 
--R
--R   (17)
--R   [4.0, 2.6666666666 666666667, 3.4666666666 666666667,
--R    2.8952380952 380952381, 3.3396825396 825396825, 2.9760461760 461760462,
--R    3.2837384837 384837385, 3.0170718170 718170718, 3.2523659347 188758953,
--R    3.0418396189 294022111, ...]
--R                                                           Type: Stream Float
--E 17

--S 18 of 22
continuedFraction((- 122 + 597*%i)/(4 - 4*%i))
--R 
--R
--R                            1    |         1     |
--R   (18)  - 90 + 59%i + +---------+ + +-----------+
--R                       | 1 - 2%i     | - 1 + 2%i
--R                                      Type: ContinuedFraction Complex Integer
--E 18

--S 19 of 22
r : Fraction UnivariatePolynomial(x,Fraction Integer) 
--R 
--R                                                                   Type: Void
--E 19

--S 20 of 22
r := ((x - 1) * (x - 2)) / ((x-3) * (x-4))
--R 
--R
--R           2
--R          x  - 3x + 2
--R   (20)  ------------
--R          2
--R         x  - 7x + 12
--R                      Type: Fraction UnivariatePolynomial(x,Fraction Integer)
--E 20

--S 21 of 22
continuedFraction r 
--R 
--R
--R                  1    |         1     |
--R   (21)  1 + +---------+ + +-----------+
--R             | 1     9     | 16     40
--R             | - x - -     | -- x - --
--R             | 4     8     |  3      3
--R             Type: ContinuedFraction UnivariatePolynomial(x,Fraction Integer)
--E 21

--S 22 of 22
[i*i for i in convergents(z) :: Stream Float] 
--R 
--R
--R   (22)
--R   [9.0, 11.1111111111 11111111, 10.9944598337 9501385, 11.0002777777 77777778,
--R    10.9999860763 98799786, 11.0000006979 29731039, 10.9999999650 15834446,
--R    11.0000000017 53603304, 10.9999999999 12099531, 11.0000000000 04406066,
--R    ...]
--R                                                           Type: Stream Float
--E 22
)spool
)lisp (bye)
@
<<ContinuedFraction.help>>=
====================================================================
ContinuedFraction examples
====================================================================

Continued fractions have been a fascinating and useful tool in
mathematics for well over three hundred years.  Axiom implements
continued fractions for fractions of any Euclidean domain.  In
practice, this usually means rational numbers.  In this section we
demonstrate some of the operations available for manipulating both
finite and infinite continued fractions.  

The ContinuedFraction domain is a field and therefore you can add,
subtract, multiply and divide the fractions.

The continuedFraction operation converts its fractional argument to a
continued fraction.

  c := continuedFraction(314159/100000)
         1 |     1  |     1 |     1  |     1 |     1 |     1 |
   3 + +---+ + +----+ + +---+ + +----+ + +---+ + +---+ + +---+
       | 7     | 15     | 1     | 25     | 1     | 7     | 4
                        Type: ContinuedFraction Integer

This display is a compact form of the bulkier

        3 +                 1
            -------------------------------
            7 +               1
                ---------------------------
                15 +            1
                     ----------------------
                     1 +          1
                         ------------------
                         25 +       1
                              -------------
                              1 +     1
                                  ---------
                                  7 +   1
                                      -----
                                        4

You can write any rational number in a similar form.  The fraction
will be finite and you can always take the "numerators" to be 1.
That is, any rational number can be written as a simple, finite
continued fraction of the form

        a(1) +           1
               -------------------------
               a(2) +          1
                      --------------------
                      a(3) +
                             .
                              .
                               .
                                     1
                               -------------
                               a(n-1) +  1
                                        ----
                                        a(n)


The a(i) are called partial quotients and the operation partialQuotients 
creates a stream of them.

  partialQuotients c
   [3,7,15,1,25,1,7,4]
                        Type: Stream Integer

By considering more and more of the fraction, you get the convergents.
For example, the first convergent is a(1), the second is a(1) + 1/a(2)
and so on.

  convergents c
      22 333 355 9208 9563 76149 314159
   [3,--,---,---,----,----,-----,------]
       7 106 113 2931 3044 24239 100000
                         Type: Stream Fraction Integer

Since this is a finite continued fraction, the last convergent is the
original rational number, in reduced form.  The result of approximants
is always an infinite stream, though it may just repeat the "last" value.

  approximants c
                                 ______
      22 333 355 9208 9563 76149 314159
   [3,--,---,---,----,----,-----,------]
       7 106 113 2931 3044 24239 100000
                         Type: Stream Fraction Integer

Inverting c only changes the partial quotients of its fraction by
inserting a 0 at the beginning of the list.

  pq := partialQuotients(1/c)
   [0,3,7,15,1,25,1,7,4]
                         Type: Stream Integer

Do this to recover the original continued fraction from this list of
partial quotients.  The three-argument form of the continuedFraction
operation takes an element which is the whole part of the fraction, a
stream of elements which are the numerators of the fraction, and a
stream of elements which are the denominators of the fraction.

  continuedFraction(first pq,repeating [1],rest pq)
     1 |     1 |     1  |     1 |     1  |     1 |     1 |     1 |
   +---+ + +---+ + +----+ + +---+ + +----+ + +---+ + +---+ + +---+
   | 3     | 7     | 15     | 1     | 25     | 1     | 7     | 4
                         Type: ContinuedFraction Integer

The streams need not be finite for continuedFraction.  Can you guess
which irrational number has the following continued fraction?  See the
end of this section for the answer.

  z:=continuedFraction(3,repeating [1],repeating [3,6])
           1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |     1 |
     3 + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+ + +---+
         | 3     | 6     | 3     | 6     | 3     | 6     | 3     | 6     | 3
   + 
       1 |
     +---+ + ...
     | 6
                         Type: ContinuedFraction Integer

In 1737 Euler discovered the infinite continued fraction expansion

        e - 1             1
        ----- = ---------------------
          2     1 +         1
                    -----------------
                    6 +       1
                        -------------
                        10 +    1
                             --------
                             14 + ...


We use this expansion to compute rational and floating point
approximations of e. For this and other interesting expansions, see
C. D. Olds, Continued Fractions, New Mathematical Library, (New York:
Random House, 1963), pp.  134--139.}

By looking at the above expansion, we see that the whole part is 0 and
the numerators are all equal to 1.  This constructs the stream of
denominators.

  dens:Stream Integer := cons(1,generate((x+->x+4),6))
   [1,6,10,14,18,22,26,30,34,38,...]
                        Type: Stream Integer

Therefore this is the continued fraction expansion for (e - 1) / 2.

  cf := continuedFraction(0,repeating [1],dens)
       1 |     1 |     1  |     1  |     1  |     1  |     1  |     1  |
     +---+ + +---+ + +----+ + +----+ + +----+ + +----+ + +----+ + +----+
     | 1     | 6     | 10     | 14     | 18     | 22     | 26     | 30
   + 
       1  |     1  |
     +----+ + +----+ + ...
     | 34     | 38
                    Type: ContinuedFraction Integer

These are the rational number convergents.

  ccf := convergents cf
        6 61  860 15541 342762  8927353 268163352  9126481321
   [0,1,-,--,----,-----,------,--------,---------,-----------,...]
        7 71 1001 18089 398959 10391023 312129649 10622799089
                    Type: Stream Fraction Integer

You can get rational convergents for e by multiplying by 2 and adding 1.

  eConvergents := [2*e + 1 for e in ccf]
         19 193 2721 49171 1084483 28245729 848456353 28875761731
    [1,3,--,---,----,-----,-------,--------,---------,-----------,...]
          7  71 1001 18089  398959 10391023 312129649 10622799089
                    Type: Stream Fraction Integer

You can also compute the floating point approximations to these convergents.

  eConvergents :: Stream Float
   [1.0, 3.0, 2.7142857142 857142857, 2.7183098591 549295775,
    2.7182817182 817182817, 2.7182818287 356957267, 2.7182818284 585634113,
    2.7182818284 590458514, 2.7182818284 590452348, 2.7182818284 590452354,
    ...]
                       Type: Stream Float

Compare this to the value of e computed by the exp operation in Float.

  exp 1.0
   2.7182818284 590452354
                       Type: Float

In about 1658, Lord Brouncker established the following expansion
for 4 / pi,

        1 +            1
            -----------------------
            2 +          9
                -------------------
                2 +        25
                    ---------------
                    2 +      49
                        -----------
                        2 +    81
                            -------
                            2 + ...

Let's use this expansion to compute rational and floating point
approximations for pi.

  cf := continuedFraction(1,[(2*i+1)**2 for i in 0..],repeating [2])
           1 |     9 |     25 |     49 |     81 |     121 |     169 |     225 |
     1 + +---+ + +---+ + +----+ + +----+ + +----+ + +-----+ + +-----+ + +-----+
         | 2     | 2     | 2      | 2      | 2      |  2      |  2      |  2
   + 
       289 |     361 |
     +-----+ + +-----+ + ...
     |  2      |  2
                       Type: ContinuedFraction Integer

  ccf := convergents cf
      3 15 105 315 3465 45045 45045 765765 14549535
   [1,-,--,---,---,----,-----,-----,------,--------,...]
      2 13  76 263 2578 36979 33976 622637 11064338
                       Type: Stream Fraction Integer

  piConvergents := [4/p for p in ccf] 
      8 52 304 1052 10312 147916 135904 2490548 44257352
   [4,-,--,---,----,-----,------,------,-------,--------,...]
      3 15 105  315  3465  45045  45045  765765 14549535
                       Type: Stream Fraction Integer

As you can see, the values are converging to
pi = 3.14159265358979323846..., but not very quickly.

  piConvergents :: Stream Float
   [4.0, 2.6666666666 666666667, 3.4666666666 666666667,
    2.8952380952 380952381, 3.3396825396 825396825, 2.9760461760 461760462,
    3.2837384837 384837385, 3.0170718170 718170718, 3.2523659347 188758953,
    3.0418396189 294022111, ...]
                      Type: Stream Float

You need not restrict yourself to continued fractions of integers.
Here is an expansion for a quotient of Gaussian integers.

  continuedFraction((- 122 + 597*%i)/(4 - 4*%i))
                      1    |         1     |
   - 90 + 59%i + +---------+ + +-----------+
                 | 1 - 2%i     | - 1 + 2%i
                      Type: ContinuedFraction Complex Integer

This is an expansion for a quotient of polynomials in one variable
with rational number coefficients.

  r : Fraction UnivariatePolynomial(x,Fraction Integer) 
                      Type: Void

  r := ((x - 1) * (x - 2)) / ((x-3) * (x-4))
     2
    x  - 3x + 2
   ------------
    2
   x  - 7x + 12
                      Type: Fraction UnivariatePolynomial(x,Fraction Integer)

  continuedFraction r 
            1    |         1     |
   1 + +---------+ + +-----------+
       | 1     9     | 16     40
       | - x - -     | -- x - --
       | 4     8     |  3      3
             Type: ContinuedFraction UnivariatePolynomial(x,Fraction Integer)

To conclude this section, we give you evidence that

    z = 3 +            1
            -----------------------
            3 +          1
                -------------------
                6 +        1
                    ---------------
                    3 +      1
                        -----------
                        6 +    1
                            -------
                            3 + ...

is the expansion of sqrt(11).

  [i*i for i in convergents(z) :: Stream Float] 
   [9.0, 11.1111111111 11111111, 10.9944598337 9501385, 11.0002777777 77777778,
    10.9999860763 98799786, 11.0000006979 29731039, 10.9999999650 15834446,
    11.0000000017 53603304, 10.9999999999 12099531, 11.0000000000 04406066,
    ...]
                        Type: Stream Float

See Also:
o )help Stream
o )show ContinuedFraction
o $AXIOM/doc/src/algebra/contrac.spad.dvi

@
<<domain CONTFRAC ContinuedFraction>>=
)abbrev domain CONTFRAC ContinuedFraction
++ Author: Stephen M. Watt
++ Date Created: January 1987
++ Change History:
++   11 April   1990
++    7 October 1991 -- SMW: Treat whole part specially.  Added comments.
++ Basic Operations:
++   (Field), (Algebra),
++   approximants, complete, continuedFraction, convergents, denominators,
++   extend, numerators, partialDenominators, partialNumerators,
++   partialQuotients, reducedContinuedFraction, reducedForm, wholePart
++ Related Constructors:
++ Also See: Fraction
++ AMS Classifications: 11A55 11J70 11K50 11Y65 30B70 40A15
++ Keywords: continued fraction, convergent
++ References:
++ Description:  \spadtype{ContinuedFraction} implements general
++   continued fractions.  This version is not restricted to simple,
++   finite fractions and uses the \spadtype{Stream} as a
++   representation.  The arithmetic functions assume that the
++   approximants alternate below/above the convergence point.
++   This is enforced by ensuring the partial numerators and partial
++   denominators are greater than 0 in the Euclidean domain view of \spad{R}
++   (i.e. \spad{sizeLess?(0, x)}). 


ContinuedFraction(R): Exports == Implementation where
  R :     EuclideanDomain
  Q   ==> Fraction R
  MT  ==> MoebiusTransform Q
  OUT ==> OutputForm

  Exports ==> Join(Algebra R,Algebra Q,Field) with
    continuedFraction:        Q -> %
      ++ continuedFraction(r) converts the fraction \spadvar{r} with
      ++ components of type \spad{R} to a continued fraction over
      ++ \spad{R}.

    continuedFraction:        (R, Stream R, Stream R) -> %
      ++ continuedFraction(b0,a,b) constructs a continued fraction in
      ++ the following way:  if \spad{a = [a1,a2,...]} and \spad{b =
      ++ [b1,b2,...]} then the result is the continued fraction
      ++ \spad{b0 + a1/(b1 + a2/(b2 + ...))}.

    reducedContinuedFraction: (R, Stream R) -> %
      ++ reducedContinuedFraction(b0,b) constructs a continued
      ++ fraction in the following way:  if \spad{b = [b1,b2,...]}
      ++ then the result is the continued fraction \spad{b0 + 1/(b1 +
      ++ 1/(b2 + ...))}.  That is, the result is the same as
      ++ \spad{continuedFraction(b0,[1,1,1,...],[b1,b2,b3,...])}.

    partialNumerators:   % -> Stream R
      ++ partialNumerators(x) extracts the numerators in \spadvar{x}.
      ++ That is, if \spad{x = continuedFraction(b0, [a1,a2,a3,...],
      ++ [b1,b2,b3,...])}, then \spad{partialNumerators(x) =
      ++ [a1,a2,a3,...]}.

    partialDenominators: % -> Stream R
      ++ partialDenominators(x) extracts the denominators in
      ++ \spadvar{x}.  That is, if \spad{x = continuedFraction(b0,
      ++ [a1,a2,a3,...], [b1,b2,b3,...])}, then
      ++ \spad{partialDenominators(x) = [b1,b2,b3,...]}.

    partialQuotients:    % -> Stream R
      ++ partialQuotients(x) extracts the partial quotients in
      ++ \spadvar{x}.  That is, if \spad{x = continuedFraction(b0,
      ++ [a1,a2,a3,...], [b1,b2,b3,...])}, then
      ++ \spad{partialQuotients(x) = [b0,b1,b2,b3,...]}.

    wholePart:           % -> R
      ++ wholePart(x) extracts the whole part of \spadvar{x}.  That
      ++ is, if \spad{x = continuedFraction(b0, [a1,a2,a3,...],
      ++ [b1,b2,b3,...])}, then \spad{wholePart(x) = b0}.

    reducedForm:         % -> %
      ++ reducedForm(x) puts the continued fraction \spadvar{x} in
      ++ reduced form, i.e.  the function returns an equivalent
      ++ continued fraction of the form
      ++ \spad{continuedFraction(b0,[1,1,1,...],[b1,b2,b3,...])}.

    approximants:        % -> Stream Q
      ++ approximants(x) returns the stream of approximants of the
      ++ continued fraction \spadvar{x}. If the continued fraction is
      ++ finite, then the stream will be infinite and periodic with
      ++ period 1.

    convergents:         % -> Stream Q
      ++ convergents(x) returns the stream of the convergents of the
      ++ continued fraction \spadvar{x}. If the continued fraction is
      ++ finite, then the stream will be finite.

    numerators:          % -> Stream R
      ++ numerators(x) returns the stream of numerators of the
      ++ approximants of the continued fraction \spadvar{x}. If the
      ++ continued fraction is finite, then the stream will be finite.

    denominators:        % -> Stream R
      ++ denominators(x) returns the stream of denominators of the
      ++ approximants of the continued fraction \spadvar{x}. If the
      ++ continued fraction is finite, then the stream will be finite.

    extend:              (%,Integer) -> %
      ++ extend(x,n) causes the first \spadvar{n} entries in the
      ++ continued fraction \spadvar{x} to be computed.  Normally
      ++ entries are only computed as needed.

    complete:            % -> %
      ++ complete(x) causes all entries in \spadvar{x} to be computed.
      ++ Normally entries are only computed as needed.  If \spadvar{x}
      ++ is an infinite continued fraction, a user-initiated interrupt is
      ++ necessary to stop the computation.

  Implementation ==> add

 -- isOrdered  ==> R is Integer
    isOrdered  ==> R has OrderedRing and R has multiplicativeValuation
    canReduce? ==> isOrdered or R has additiveValuation

    Rec ==> Record(num: R, den: R)
    Str ==> Stream Rec
    Rep :=  Record(value: Record(whole: R, fract: Str), reduced?: Boolean)

    import Str

    genFromSequence:     Stream Q -> %
    genReducedForm:      (Q, Stream Q, MT)    -> Stream Rec
    genFractionA:        (Stream R,Stream R)  -> Stream Rec
    genFractionB:        (Stream R,Stream R)  -> Stream Rec
    genNumDen:           (R,R, Stream Rec)    -> Stream R

    genApproximants:     (R,R,R,R,Stream Rec) -> Stream Q
    genConvergents:      (R,R,R,R,Stream Rec) -> Stream Q
    iGenApproximants:    (R,R,R,R,Stream Rec) -> Stream Q
    iGenConvergents:     (R,R,R,R,Stream Rec) -> Stream Q

    reducedForm c == 
        c.reduced? => c
        explicitlyFinite? c.value.fract =>
                      continuedFraction last complete convergents c
        canReduce? => genFromSequence approximants c
        error "Reduced form not defined for this continued fraction."

    eucWhole(a: Q): R == numer a quo denom a

    eucWhole0(a: Q): R ==
        isOrdered =>
            n := numer a
            d := denom a
            q := n quo d
            r := n - q*d
            if r < 0 then q := q - 1
            q
        eucWhole a

    x = y ==
        x := reducedForm x
        y := reducedForm y

        x.value.whole ^= y.value.whole => false

        xl := x.value.fract; yl := y.value.fract

        while not empty? xl and not empty? yl repeat
            frst.xl.den ^= frst.yl.den => return false
            xl := rst xl; yl := rst yl
        empty? xl and empty? yl

    continuedFraction q == q :: %

    if isOrdered then
        continuedFraction(wh,nums,dens) == [[wh,genFractionA(nums,dens)],false]

        genFractionA(nums,dens) ==
            empty? nums or empty? dens => empty()
            n := frst nums
            d := frst dens
            n < 0 => error "Numerators must be greater than 0."
            d < 0 => error "Denominators must be greater than 0."
            concat([n,d]$Rec, delay genFractionA(rst nums,rst dens))
    else
        continuedFraction(wh,nums,dens) == [[wh,genFractionB(nums,dens)],false]

        genFractionB(nums,dens) ==
            empty? nums or empty? dens => empty()
            n := frst nums
            d := frst dens
            concat([n,d]$Rec, delay genFractionB(rst nums,rst dens))

    reducedContinuedFraction(wh,dens) ==
        continuedFraction(wh, repeating [1], dens)

    coerce(n:Integer):% == [[n::R,empty()], true]
    coerce(r:R):%       == [[r,   empty()], true]

    coerce(a: Q): % ==
      wh := eucWhole0 a
      fr := a - wh::Q
      zero? fr => [[wh, empty()], true]

      l : List Rec := empty()
      n := numer fr
      d := denom fr
      while not zero? d repeat
        qr := divide(n,d)
        l  := concat([1,qr.quotient],l)
        n  := d
        d  := qr.remainder
      [[wh, construct rest reverse_! l], true]

    characteristic() == characteristic()$Q


    genFromSequence apps ==
        lo := first apps; apps := rst apps
        hi := first apps; apps := rst apps
        while eucWhole0 lo ^= eucWhole0 hi repeat
            lo := first apps; apps := rst apps
            hi := first apps; apps := rst apps
        wh := eucWhole0 lo
        [[wh, genReducedForm(wh::Q, apps, moebius(1,0,0,1))], canReduce?]

    genReducedForm(wh0, apps, mt) ==
        lo: Q := first apps - wh0; apps := rst apps
        hi: Q := first apps - wh0; apps := rst apps
        lo = hi and zero? eval(mt, lo) => empty()
        mt  := recip mt
        wlo := eucWhole eval(mt, lo)
        whi := eucWhole eval(mt, hi)
        while wlo ^= whi repeat
            wlo := eucWhole eval(mt, first apps - wh0); apps := rst apps
            whi := eucWhole eval(mt, first apps - wh0); apps := rst apps
        concat([1,wlo], delay genReducedForm(wh0, apps, shift(mt, -wlo::Q)))

    wholePart c           == c.value.whole
    partialNumerators c   == map(#1.num, c.value.fract)$StreamFunctions2(Rec,R)
    partialDenominators c == map(#1.den, c.value.fract)$StreamFunctions2(Rec,R)
    partialQuotients c    == concat(c.value.whole, partialDenominators c)

    approximants c ==
      empty? c.value.fract => repeating [c.value.whole::Q]
      genApproximants(1,0,c.value.whole,1,c.value.fract)
    convergents c ==
      empty? c.value.fract => concat(c.value.whole::Q, empty())
      genConvergents (1,0,c.value.whole,1,c.value.fract)
    numerators c ==
      empty? c.value.fract => concat(c.value.whole, empty())
      genNumDen(1,c.value.whole,c.value.fract)
    denominators c ==
      genNumDen(0,1,c.value.fract)

    extend(x,n) == (extend(x.value.fract,n); x)
    complete(x) == (complete(x.value.fract); x)

    iGenApproximants(pm2,qm2,pm1,qm1,fr) == delay
      nd := frst fr
      pm := nd.num*pm2 + nd.den*pm1
      qm := nd.num*qm2 + nd.den*qm1
      genApproximants(pm1,qm1,pm,qm,rst fr)

    genApproximants(pm2,qm2,pm1,qm1,fr) ==
      empty? fr => repeating [pm1/qm1]
      concat(pm1/qm1,iGenApproximants(pm2,qm2,pm1,qm1,fr))

    iGenConvergents(pm2,qm2,pm1,qm1,fr) == delay
      nd := frst fr
      pm := nd.num*pm2 + nd.den*pm1
      qm := nd.num*qm2 + nd.den*qm1
      genConvergents(pm1,qm1,pm,qm,rst fr)

    genConvergents(pm2,qm2,pm1,qm1,fr) ==
      empty? fr => concat(pm1/qm1, empty())
      concat(pm1/qm1,iGenConvergents(pm2,qm2,pm1,qm1,fr))

    genNumDen(m2,m1,fr) ==
      empty? fr => concat(m1,empty())
      concat(m1,delay genNumDen(m1,m2*frst(fr).num + m1*frst(fr).den,rst fr))

    gen  ==> genFromSequence
    apx  ==> approximants

    c, d: %
    a: R
    q: Q
    n: Integer

    0 == (0$R) :: %
    1 == (1$R) :: %

    c + d   == genFromSequence map(#1 + #2, apx c, apx d)
    c - d   == genFromSequence map(#1 - #2, apx c, rest apx d)
    - c     == genFromSequence map(   - #1, rest apx c)
    c * d   == genFromSequence map(#1 * #2, apx c, apx d)
    a * d   == genFromSequence map( a * #1, apx d)
    q * d   == genFromSequence map( q * #1, apx d)
    n * d   == genFromSequence map( n * #1, apx d)
    c / d   == genFromSequence map(#1 / #2, apx c, rest apx d)
    recip c ==(c = 0 => "failed";
	       genFromSequence map( 1 / #1, rest apx c))

    showAll?: () -> Boolean
    showAll?() ==
      NULL(_$streamsShowAll$Lisp)$Lisp => false
      true

    zagRec(t:Rec):OUT == zag(t.num :: OUT,t.den :: OUT)

    coerce(c:%): OUT ==
      wh := c.value.whole
      fr := c.value.fract
      empty? fr => wh :: OUT
      count : NonNegativeInteger := _$streamCount$Lisp
      l : List OUT := empty()
      for n in 1..count while not empty? fr repeat
        l  := concat(zagRec frst fr,l)
        fr := rst fr
      if showAll?() then
        for n in (count + 1).. while explicitEntries? fr repeat
          l  := concat(zagRec frst fr,l)
          fr := rst fr
      if not explicitlyEmpty? fr then l := concat("..." :: OUT,l)
      l := reverse_! l
      e := reduce("+",l)
      zero? wh => e
      (wh :: OUT) + e

@
\section{package NCNTFRAC NumericContinuedFraction}
<<package NCNTFRAC NumericContinuedFraction>>=
)abbrev package NCNTFRAC NumericContinuedFraction
++ Author: Clifton J. Williamson
++ Date Created: 12 April 1990
++ Change History:
++ Basic Operations: continuedFraction
++ Related Constructors: ContinuedFraction, Float
++ Also See: Fraction
++ AMS Classifications: 11J70 11A55 11K50 11Y65 30B70 40A15
++ Keywords: continued fraction
++ References:
++ Description: \spadtype{NumericContinuedFraction} provides functions
++   for converting floating point numbers to continued fractions.

NumericContinuedFraction(F): Exports == Implementation where
  F :     FloatingPointSystem
  CFC ==> ContinuedFraction Integer
  I   ==> Integer
  ST  ==> Stream I

  Exports ==> with
    continuedFraction: F -> CFC
      ++ continuedFraction(f) converts the floating point number
      ++ \spad{f} to a reduced continued fraction.

  Implementation ==> add

    cfc: F -> ST
    cfc(a) == delay
      aa := wholePart a
      zero?(b := a - (aa :: F)) => concat(aa,empty()$ST)
      concat(aa,cfc inv b)

    continuedFraction a ==
      aa := wholePart a
      zero?(b := a - (aa :: F)) =>
        reducedContinuedFraction(aa,empty()$ST) 
      if negative? b then (aa := aa - 1; b := b + 1)
      reducedContinuedFraction(aa,cfc inv b) 

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain CONTFRAC ContinuedFraction>>
<<package NCNTFRAC NumericContinuedFraction>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
