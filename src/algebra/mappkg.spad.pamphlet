\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra mappkg.spad}
\author{Stephen M. Watt, William Burge, Timothy Daly}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package MAPHACK1 MappingPackageInternalHacks1}
<<package MAPHACK1 MappingPackageInternalHacks1>>=
)abbrev package MAPHACK1 MappingPackageInternalHacks1
++ Author: S.M.Watt and W.H.Burge
++ Date Created:Jan 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: various Currying operations.
MappingPackageInternalHacks1(A: SetCategory): MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        iter:  ((A -> A), NNI, A) -> A
          ++\spad{iter(f,n,x)} applies \spad{f n} times to \spad{x}.
        recur: ((NNI, A)->A, NNI, A) -> A
          ++\spad{recur(n,g,x)} is \spad{g(n,g(n-1,..g(1,x)..))}.
 
    MPdef == add
        iter(g,n,x)  ==
            for i in 1..n repeat x := g x     -- g(g(..(x)..))
            x
        recur(g,n,x) ==
            for i in 1..n repeat x := g(i,x)  -- g(n,g(n-1,..g(1,x)..))
            x

@
\section{package MAPHACK2 MappingPackageInternalHacks2}
<<package MAPHACK2 MappingPackageInternalHacks2>>=
)abbrev package MAPHACK2 MappingPackageInternalHacks2
++ Description: various Currying operations.
MappingPackageInternalHacks2(A: SetCategory, C: SetCategory):_
  MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        arg1:  (A, C) -> A
          ++\spad{arg1(a,c)} selects its first argument.
        arg2:  (A, C) -> C
          ++\spad{arg2(a,c)} selects its second argument.
 
    MPdef == add
        arg1(a, c)   == a
        arg2(a, c)   == c

@
\section{package MAPHACK3 MappingPackageInternalHacks3}
<<package MAPHACK3 MappingPackageInternalHacks3>>=
)abbrev package MAPHACK3 MappingPackageInternalHacks3
++ Description: various Currying operations.
MappingPackageInternalHacks3(A: SetCategory, B: SetCategory, C: SetCategory):_
  MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        comp:  (B->C, A->B, A) -> C
          ++\spad{comp(f,g,x)} is \spad{f(g x)}.
 
    MPdef == add
        comp(g,h,x)  == g h x

@
\section{package MAPPKG1 MappingPackage1}
<<MappingPackage1.input>>=
-- mappkg.spad.pamphlet MappingPackage1.input
)spool MappingPackage1.output
)set message test on
)set message auto off
)clear all

--S 1 of 26
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2 of 26
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3 of 26
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4 of 26
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5 of 26
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6 of 26
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7 of 26
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8 of 26
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9 of 26
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10 of 26
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11 of 26
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 26
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13 of 26
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14 of 26
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15 of 26
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16 of 26
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17 of 26
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18 of 26
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19 of 26
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20 of 26
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21 of 26
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22 of 26
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23 of 26
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24 of 26
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25 of 26
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26 of 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
 
)spool 
)lisp (bye)
 
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
)spool
)lisp (bye)
@
<<MappingPackage1.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )show MappingPackage1
o )help MappingPackage2
o )help MappingPackage3
o )help MappingPackage4
o $AXIOM/doc/src/algebra/mappkg.spad.dvi

@
<<package MAPPKG1 MappingPackage1>>=
)abbrev package MAPPKG1 MappingPackage1
++ Author: S.M.Watt and W.H.Burge
++ Date Created:Jan 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: various Currying operations.
MappingPackage1(A:SetCategory): MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        nullary: A           -> (()->A)
          ++\spad{nullary A} changes its argument into a
          ++ nullary function.
        coerce:  A           -> (()->A)
          ++\spad{coerce A} changes its argument into a
          ++ nullary function.
 
        fixedPoint: (A->A) -> A
          ++\spad{fixedPoint f} is the fixed point of function \spad{f}.
          ++ i.e. such that \spad{fixedPoint f = f(fixedPoint f)}.
        fixedPoint: (List A->List A, Integer) -> List A
          ++\spad{fixedPoint(f,n)} is the fixed point of function
          ++ \spad{f} which is assumed to transform a list of length
          ++ \spad{n}.
 
 
        id:    A -> A
          ++\spad{id x} is \spad{x}.
        "**":  (A->A, NNI)  -> (A->A)
          ++\spad{f**n} is the  function which is the n-fold application
          ++ of \spad{f}.
 
        recur: ((NNI, A)->A) -> ((NNI, A)->A)
          ++\spad{recur(g)} is the function \spad{h} such that
          ++ \spad{h(n,x)= g(n,g(n-1,..g(1,x)..))}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks1(A)
 
        a: A
        faa:  A -> A
        f0a:  ()-> A
 
        nullary a   == a
        coerce  a   == nullary a
        fixedPoint faa ==
            g0 := GENSYM()$Lisp
            g1 := faa g0
            EQ(g0, g1)$Lisp => error "All points are fixed points"
            GEQNSUBSTLIST([g0]$Lisp, [g1]$Lisp, g1)$Lisp
 
        fixedPoint(fll, n) ==
            g0 := [(GENSYM()$Lisp):A for i in 1..n]
            g1 := fll g0
            or/[EQ(e0,e1)$Lisp for e0 in g0 for e1 in g1] =>
                error "All points are fixed points"
            GEQNSUBSTLIST(g0, g1, g1)$Lisp
 
        -- Composition and recursion.
        id a        == a
        g**n        == iter(g, n, #1)
 
        recur fnaa  == recur(fnaa, #1, #2)

@
\section{package MAPPKG2 MappingPackage2}
<<MappingPackage2.input>>=
-- mappkg.spad.pamphlet MappingPackage2.input
)spool MappingPackage2.output
)set message test on
)set message auto off
)clear all
--S 1
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
)spool
)lisp (bye)
@
<<MappingPackage2.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )help MappingPackage1
o )show MappingPackage2
o )help MappingPackage3
o )help MappingPackage4
o $AXIOM/doc/src/algebra/mappkg.spad.dvi

@
<<package MAPPKG2 MappingPackage2>>=
)abbrev package MAPPKG2 MappingPackage2
++ Description: various Currying operations.
MappingPackage2(A:SetCategory, C:SetCategory): MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        const:   C           -> (A ->C)
          ++\spad{const c} is a function which produces \spad{c} when
          ++ applied to its argument.
 
        curry:    (A ->C, A)    -> (()->C)
          ++\spad{cu(f,a)} is the function \spad{g}
          ++ such that \spad{g ()= f a}.
        constant:    (()->C)       -> (A ->C)
          ++\spad{vu(f)} is the function \spad{g}
          ++ such that \spad{g a= f ()}.
 
        diag:  ((A,A)->C)    -> (A->C)
          ++\spad{diag(f)} is the function \spad{g}
          ++ such that \spad{g a = f(a,a)}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks2(A, C)
 
        a: A
        c: C
        faa:  A -> A
        f0c:  ()-> C
        fac:  A -> C
        faac: (A,A)->C
 
        const c     == arg2(#1, c)
        curry(fac, a)  == fac a
        constant f0c      == arg2(#1, f0c())
 
        diag  faac  == faac(#1, #1)

@
\section{package MAPPKG3 MappingPackage3}
<<MappingPackage3.input>>=
-- mappkg.spad.pamphlet MappingPackage3.input
)spool MappingPackage3.output
)set message test on
)set message auto off
)clear all
--S 1
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
)spool
)lisp (bye)
@
<<MappingPackage3.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )help MappingPackage1
o )help MappingPackage2
o )show MappingPackage3
o )help MappingPackage4
o $AXIOM/doc/src/algebra/mappkg.spad.dvi

@
<<package MAPPKG3 MappingPackage3>>=
)abbrev package MAPPKG3 MappingPackage3
++ Description: various Currying operations.
MappingPackage3(A:SetCategory, B:SetCategory, C:SetCategory):_
  MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        curryRight:   ((A,B)->C, B) -> (A ->C)
          ++\spad{curryRight(f,b)} is the function \spad{g} such that
          ++ \spad{g a = f(a,b)}.
        curryLeft:   ((A,B)->C, A) -> (B ->C)
          ++\spad{curryLeft(f,a)} is the function \spad{g}
          ++ such that \spad{g b = f(a,b)}.
 
        constantRight:   (A -> C)      -> ((A,B)->C)
          ++\spad{constantRight(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f a}.
        constantLeft:   (B -> C)      -> ((A,B)->C)
          ++\spad{constantLeft(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f b}.
 
        twist: ((A,B)->C)    -> ((B,A)->C)
          ++\spad{twist(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f(b,a)}.
 
        "*":   (B->C, A->B) -> (A->C)
          ++\spad{f*g} is the function \spad{h}
          ++ such that \spad{h x= f(g x)}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks3(A, B, C)
 
        a: A
        b: B
        c: C
        faa:  A -> A
        f0c:  ()-> C
        fac:  A -> C
        fbc:  B -> C
        fab:  A -> B
        fabc: (A,B)->C
        faac: (A,A)->C
 
        -- Fix left and right arguments as constants.
        curryRight(fabc,b) == fabc(#1,b)
        curryLeft(fabc,a) == fabc(a, #1)
 
        -- Add left and right arguments which are ignored.
        constantRight fac     == fac #1
        constantLeft fbc     == fbc #2
 
        -- Combinators to rearrange arguments.
        twist fabc  == fabc(#2, #1)
        -- Functional composition
        fbc*fab == comp(fbc,fab,#1)

@
\section{package MAPPKG4 MappingPackage4}
<<MappingPackage4.input>>=
-- mappkg.spad.pamphlet MappingPackage4.input
)spool MappingPackage4.output
)set message test on
)set message auto off
)clear all

--S 1 of 21
p:=(x:EXPR(INT)):EXPR(INT)+->3*x
--R 
--R
--R   (1)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 1

--S 2 of 21
q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
--R 
--R
--R   (2)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 2

--S 3 of 21
(p+q)(4)-(p(4)+q(4))
--R 
--R
--R   (3)  0
--R                                                     Type: Expression Integer
--E 3

--S 4 of 21
(p+q)(x)-(p(x)+q(x))
--R 
--R
--R   (4)  0
--R                                                     Type: Expression Integer
--E 4

--S 5 of 21
(p-q)(4)-(p(4)-q(4))
--R 
--R
--R   (5)  0
--R                                                     Type: Expression Integer
--E 5

--S 6 of 21
(p-q)(x)-(p(x)-q(x))
--R 
--R
--R   (6)  0
--R                                                     Type: Expression Integer
--E 6

--S 7 of 21
(p*q)(4)-(p(4)*q(4))
--R 
--R
--R   (7)  0
--R                                                     Type: Expression Integer
--E 7

--S 8 of 21
(p*q)(x)-(p(x)*q(x))
--R 
--R
--R   (8)  0
--R                                                     Type: Expression Integer
--E 8

--S 9 of 21
(p/q)(4)-(p(4)/q(4))
--R 
--R
--R   (9)  0
--R                                                     Type: Expression Integer
--E 9

--S 10 of 21
(p/q)(x)-(p(x)/q(x))
--R 
--R
--R   (10)  0
--R                                                     Type: Expression Integer
--E 10

--S 11 of 21
r:=(x:INT):INT+-> (x*x*x)
--R 
--R
--R   (11)  theMap(Closure)
--R                                                   Type: (Integer -> Integer)
--E 11

--S 12 of 21
s:=(y:INT):INT+-> (y*y+3)
--R 
--R
--R   (12)  theMap(Closure)
--R                                                   Type: (Integer -> Integer)
--E 12

--S 13 of 21
(r+s)(4)-(r(4)+s(4))
--R 
--R
--R   (13)  0
--R                                                     Type: NonNegativeInteger
--E 13

--S 14 of 21
(r-s)(4)-(r(4)-s(4))
--R 
--R
--R   (14)  0
--R                                                     Type: NonNegativeInteger
--E 14

--S 15 of 21
(r*s)(4)-(r(4)*s(4))
--R 
--R
--R   (15)  0
--R                                                     Type: NonNegativeInteger
--E 15

--S 16 of 21
t:=(x:INT):EXPR(INT)+-> (x*x*x)
--R 
--R
--R   (16)  theMap(Closure)
--R                                        Type: (Integer -> Expression Integer)
--E 16

--S 17 of 21
u:=(y:INT):EXPR(INT)+-> (y*y+3)
--R 
--R
--R   (17)  theMap(Closure)
--R                                        Type: (Integer -> Expression Integer)
--E 17

--S 18 of 21
(t/u)(4)-(t(4)/u(4))
--R 
--R
--R   (18)  0
--R                                                     Type: Expression Integer
--E 18

--S 19 of 21
h:=(x:EXPR(INT)):EXPR(INT)+->1
--R
--R   (19)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 19

--S 20 of 21
(p/h)(x)
--R
--R   (20)  3x
--R                                                     Type: Expression Integer
--E 20

--S 21 of 21
(q/h)(x)
--R
--R   (21)  2x + 3
--R                                                     Type: Expression Integer
--E 21

)spool 
)lisp (bye)
 
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
)spool
)lisp (bye)
@
<<MappingPackage4.help>>=
====================================================================
MappingPackage examples
====================================================================

We can construct some simple maps that take a variable x
into an equation:

  p:=(x:EXPR(INT)):EXPR(INT)+->3*x
  q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3

Now we can do the four arithmetic operations, +, -, *, / on these
newly constructed mappings. Since the maps are from the domain
Expression Integer to the same domain we can also use symbolic
values for the argument. All of the following will return 0,
showing that function composition is equivalent to the result
of doing the operations individually.

  (p+q)(4)-(p(4)+q(4))
  (p+q)(x)-(p(x)+q(x))
  
  (p-q)(4)-(p(4)-q(4))
  (p-q)(x)-(p(x)-q(x))

  (p*q)(4)-(p(4)*q(4))
  (p*q)(x)-(p(x)*q(x))

  (p/q)(4)-(p(4)/q(4))
  (p/q)(x)-(p(x)/q(x))

We can construct simple maps from Integer to Integer but this
limits our ability to do division.

  r:=(x:INT):INT+-> (x*x*x)
  s:=(y:INT):INT+-> (y*y+3)

Again, all of these will return 0:

  (r+s)(4)-(r(4)+s(4))
  (r-s)(4)-(r(4)-s(4))
  (r*s)(4)-(r(4)*s(4))

If we want to do division with Integer inputs we create the
appropriate map:

  t:=(x:INT):EXPR(INT)+-> (x*x*x)
  u:=(y:INT):EXPR(INT)+-> (y*y+3)

  (t/u)(4)-(t(4)/u(4))

We can even recover the original functions if we make a map
that always returns the constant 1:

  h:=(x:EXPR(INT)):EXPR(INT)+->1

    theMap(Closure)
             Type: (Expression Integer -> Expression Integer)

  (p/h)(x)

     3x
                                     Type: Expression Integer
  (q/h)(x)

    2x + 3
                                     Type: Expression Integer

See Also:
o )show MappingPackage1
o )help MappingPackage2
o )help MappingPackage3
o )help MappingPackage4
o $AXIOM/doc/src/algebra/mappkg.spad.dvi

@
<<package MAPPKG4 MappingPackage4>>=
)abbrev package MAPPKG4 MappingPackage4
++ Author: Timothy Daly
++ Description: Functional Composition
++ Given functions f and g, returns the applicable closure
MappingPackage4(A:SetCategory, B:Ring):
 with
   "+": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f+g)(4)
   "-": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f-g)(4)
   "*": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f*g)(4)
   "/": (A->Expression(Integer), A->Expression(Integer)) -> (A->Expression(Integer))
        ++ \spad(+) does functional addition
        ++
        ++X p:=(x:EXPR(INT)):EXPR(INT)+->3*x
        ++X q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
        ++X (p/q)(4)
        ++X (p/q)(x)
  == add
    fab ==> (A -> B)
    faei ==> (A -> Expression(Integer))

    funcAdd(g:fab,h:fab,x:A):B == ((g x) + (h x))$B

    (a:fab)+(b:fab) == funcAdd(a,b,#1)

    funcSub(g:fab,h:fab,x:A):B == ((g x) - (h x))$B

    (a:fab)-(b:fab) == funcSub(a,b,#1)

    funcMul(g:fab,h:fab,x:A):B == ((g x) * (h x))$B

    (a:fab)*(b:fab) == funcMul(a,b,#1)

    funcDiv(g:faei,h:faei,x:A):Expression(Integer)
           == ((g x) / (h x))$Expression(Integer)

    (a:faei)/(b:faei) == funcDiv(a,b,#1)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
 
<<package MAPHACK1 MappingPackageInternalHacks1>>
<<package MAPHACK2 MappingPackageInternalHacks2>>
<<package MAPHACK3 MappingPackageInternalHacks3>>
<<package MAPPKG1 MappingPackage1>>
<<package MAPPKG2 MappingPackage2>>
<<package MAPPKG3 MappingPackage3>>
<<package MAPPKG4 MappingPackage4>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
