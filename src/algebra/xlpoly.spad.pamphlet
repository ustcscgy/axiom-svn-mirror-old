\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra xlpoly.spad}
\author{Michel Petitot}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain MAGMA Magma}
<<Magma.input>>=
-- xlpoly.spad.pamphlet Magma.input
)spool Magma.output
)set message test on
)set message auto off
)clear all
--S 1
x:Symbol :='x
--R 
--R
--R   (1)  x
--R                                                                 Type: Symbol
--E 1

--S 2
y:Symbol :='y
--R 
--R
--R   (2)  y
--R                                                                 Type: Symbol
--E 2

--S 3
z:Symbol :='z
--R 
--R
--R   (3)  z
--R                                                                 Type: Symbol
--E 3

--S 4
word := OrderedFreeMonoid(Symbol)
--R 
--R
--R   (4)  OrderedFreeMonoid Symbol
--R                                                                 Type: Domain
--E 4

--S 5
tree := Magma(Symbol)
--R 
--R
--R   (5)  Magma Symbol
--R                                                                 Type: Domain
--E 5

--S 6
a:tree := x*x 
--R 
--R
--R   (6)  [x,x]
--R                                                           Type: Magma Symbol
--E 6

--S 7
b:tree := y*y
--R 
--R
--R   (7)  [y,y]
--R                                                           Type: Magma Symbol
--E 7

--S 8
c:tree := a*b
--R 
--R
--R   (8)  [[x,x],[y,y]]
--R                                                           Type: Magma Symbol
--E 8

--S 9
left c
--R 
--R
--R   (9)  [x,x]
--R                                                           Type: Magma Symbol
--E 9

--S 10
right c
--R 
--R
--R   (10)  [y,y]
--R                                                           Type: Magma Symbol
--E 10

--S 11
length c
--R 
--R
--R   (11)  4
--R                                                        Type: PositiveInteger
--E 11

--S 12
c::word
--R 
--R
--R          2 2
--R   (12)  x y
--R                                               Type: OrderedFreeMonoid Symbol
--E 12

--S 13
a < b
--R 
--R
--R   (13)  true
--R                                                                Type: Boolean
--E 13

--S 14
a < c
--R 
--R
--R   (14)  true
--R                                                                Type: Boolean
--E 14

--S 15
b < c
--R 
--R
--R   (15)  true
--R                                                                Type: Boolean
--E 15

--S 16
first c
--R 
--R
--R   (16)  x
--R                                                                 Type: Symbol
--E 16

--S 17
rest c
--R 
--R
--R   (17)  [x,[y,y]]
--R                                                           Type: Magma Symbol
--E 17

--S 18
rest rest c
--R 
--R
--R   (18)  [y,y]
--R                                                           Type: Magma Symbol
--E 18

--S 19
ax:tree := a*x
--R 
--R
--R   (19)  [[x,x],x]
--R                                                           Type: Magma Symbol
--E 19

--S 20
xa:tree := x*a
--R 
--R
--R   (20)  [x,[x,x]]
--R                                                           Type: Magma Symbol
--E 20

--S 21
xa < ax
--R 
--R
--R   (21)  true
--R                                                                Type: Boolean
--E 21

--S 22
lexico(xa,ax)
--R 
--R
--R   (22)  false
--R                                                                Type: Boolean
--E 22
)spool
)lisp (bye)
@
<<Magma.help>>=
====================================================================
Magma examples
====================================================================

Initialisations

  x:Symbol :='x
    x
                         Type: Symbol

  y:Symbol :='y
    y
                         Type: Symbol

  z:Symbol :='z
    z
                         Type: Symbol

  word := OrderedFreeMonoid(Symbol)
    OrderedFreeMonoid Symbol
                         Type: Domain

  tree := Magma(Symbol)
    Magma Symbol
                         Type: Domain

Let's make some trees

  a:tree := x*x 
    [x,x]
                         Type: Magma Symbol

  b:tree := y*y
    [y,y]
                         Type: Magma Symbol

  c:tree := a*b
    [[x,x],[y,y]]
                         Type: Magma Symbol

Query the trees

  left c
    [x,x]
                         Type: Magma Symbol

  right c
    [y,y]
                         Type: Magma Symbol

  length c
    4
                         Type: PositiveInteger

Coerce to the monoid

  c::word
     2 2
    x y
                         Type: OrderedFreeMonoid Symbol

Check ordering

  a < b
    true
                         Type: Boolean

  a < c
    true
                         Type: Boolean

  b < c
    true
                         Type: Boolean

Navigate the tree

  first c
    x
                         Type: Symbol

  rest c
    [x,[y,y]]
                         Type: Magma Symbol

  rest rest c
    [y,y]
                         Type: Magma Symbol

Check ordering

  ax:tree := a*x
    [[x,x],x]
                         Type: Magma Symbol

  xa:tree := x*a
    [x,[x,x]]
                         Type: Magma Symbol

  xa < ax
    true
                         Type: Boolean

  lexico(xa,ax)
    false
                         Type: Boolean

See Also:
o )show Magma
o $AXIOM/doc/src/algebra/xlpoly.spad.dvi

@
<<domain MAGMA Magma>>=
)abbrev domain MAGMA Magma
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This type is the basic representation of 
++ parenthesized words (binary trees over arbitrary symbols)
++ useful in \spadtype{LiePolynomial}. \newline Author: Michel Petitot (petitot@lifl.fr).

Magma(VarSet:OrderedSet):Public == Private where
   WORD ==> OrderedFreeMonoid(VarSet)
   EX   ==> OutputForm

   Public == Join(OrderedSet,RetractableTo VarSet) with
      "*"           : ($,$) -> $
        ++ \axiom{x*y} returns the tree \axiom{[x,y]}.
      coerce        : $ -> WORD
        ++ \axiom{coerce(x)} returns the element of \axiomType{OrderedFreeMonoid}(VarSet) 
        ++ corresponding to \axiom{x} by removing parentheses.
      first         : $ -> VarSet
        ++ \axiom{first(x)} returns the first entry of the tree \axiom{x}.
      left          : $ -> $
        ++ \axiom{left(x)} returns left subtree of \axiom{x} or
        ++ error if \axiomOpFrom{retractable?}{Magma}(\axiom{x}) is true.
      length        : $ -> PositiveInteger
        ++ \axiom{length(x)} returns the number of entries in \axiom{x}.
      lexico        : ($,$) -> Boolean
        ++ \axiom{lexico(x,y)} returns \axiom{true} iff  \axiom{x} is smaller than 
        ++ \axiom{y} w.r.t. the lexicographical ordering induced by \axiom{VarSet}. 
        ++ N.B. This operation does not take into account the tree structure of
        ++ its arguments. Thus this is not a total ordering.
      mirror        : $ -> $
        ++ \axiom{mirror(x)} returns the reversed word of \axiom{x}. 
        ++ That is \axiom{x} itself if \axiomOpFrom{retractable?}{Magma}(\axiom{x}) is true and
        ++ \axiom{mirror(z) * mirror(y)} if \axiom{x} is \axiom{y*z}.
      rest          : $ -> $
        ++ \axiom{rest(x)} return \axiom{x} without the first entry or 
        ++ error if \axiomOpFrom{retractable?}{Magma}(\axiom{x}) is true.
      retractable?  : $ -> Boolean
        ++ \axiom{retractable?(x)} tests if \axiom{x} is a tree with only one entry.
      right         : $ -> $
        ++ \axiom{right(x)} returns right subtree of \axiom{x} or 
        ++ error if \axiomOpFrom{retractable?}{Magma}(\axiom{x}) is true.
      varList       : $ -> List VarSet
        ++ \axiom{varList(x)} returns the list of distinct entries of \axiom{x}.

   Private == add
    -- representation
      VWORD := Record(left:$ ,right:$)
      Rep:= Union(VarSet,VWORD)  

      recursif: ($,$) -> Boolean

    -- define
      x:$ = y:$ ==
        x case VarSet => 
           y case VarSet => x::VarSet = y::VarSet
           false
        y case VWORD => x::VWORD = y::VWORD
        false
 
      varList x == 
        x case VarSet => [x::VarSet]
        lv: List VarSet := setUnion(varList x.left, varList x.right)
        sort_!(lv)

      left x == 
        x case VarSet => error "x has only one entry"
        x.left

      right x == 
        x case VarSet => error "x has only one entry"
        x.right
      retractable? x == (x case VarSet)

      retract x ==
         x case VarSet => x::VarSet
         error "Not retractable"

      retractIfCan x == (retractable? x => x::VarSet ; "failed")
      coerce(l:VarSet):$  == l

      mirror x ==
        x case VarSet => x
        [mirror x.right, mirror x.left]$VWORD

      coerce(x:$): WORD ==
        x case VarSet => x::VarSet::WORD
        x.left::WORD * x.right::WORD

      coerce(x:$):EX ==
         x case VarSet => x::VarSet::EX
         bracket [x.left::EX, x.right::EX]

      x * y == [x,y]$VWORD

      first x ==
         x case VarSet => x::VarSet
         first x.left

      rest x ==
         x case VarSet => error "rest$Magma: inexistant rest"
         lx:$ := x.left
         lx case VarSet => x.right
         [rest lx , x.right]$VWORD

      length x ==
         x case VarSet => 1
         length(x.left) + length(x.right)

      recursif(x,y) ==    
         x case VarSet => 
            y case VarSet => x::VarSet < y::VarSet
            true
         y case VarSet => false
         x.left =  y.left =>  x.right <  y.right
         x.left < y.left

      lexico(x,y) ==      	-- peut etre amelioree !!!!!!!!!!!
         x case VarSet => 
            y case VarSet => x::VarSet < y::VarSet
            x::VarSet <= first y
         y case VarSet => first x < retract y
         fx:VarSet := first x ; fy:VarSet := first y 
         fx = fy => lexico(rest x , rest y)
         fx < fy 

      x < y ==                 	-- recursif par longueur
         lx,ly: PositiveInteger
         lx:= length x ; ly:= length y
         lx = ly => recursif(x,y)
         lx < ly 

@
\section{domain LWORD LyndonWord}
<<LyndonWord.input>>=
-- xlpoly.spad.pamphlet LyndonWord.input
)spool LyndonWord.output
)set message test on
)set message auto off
)clear all
--S 1 of 22
a:Symbol :='a
--R 
--R
--R   (1)  a
--R                                                                 Type: Symbol
--E 1

--S 2 of 22
b:Symbol :='b
--R 
--R
--R   (2)  b
--R                                                                 Type: Symbol
--E 2

--S 3 of 22
c:Symbol :='c
--R 
--R
--R   (3)  c
--R                                                                 Type: Symbol
--E 3

--S 4 of 22
lword:= LyndonWord(Symbol)
--R 
--R
--R   (4)  LyndonWord Symbol
--R                                                                 Type: Domain
--E 4

--S 5 of 22
magma := Magma(Symbol)
--R 
--R
--R   (5)  Magma Symbol
--R                                                                 Type: Domain
--E 5

--S 6 of 22
word := OrderedFreeMonoid(Symbol)
--R 
--R
--R   (6)  OrderedFreeMonoid Symbol
--R                                                                 Type: Domain
--E 6

--S 7 of 22
LyndonWordsList1([a,b,c],3)$lword
--R 
--R
--R   (7)
--R   [[[a],[b],[c]], [[a b],[a c],[b c]],
--R       2     2       2                      2    2       2
--R    [[a b],[a c],[a b ],[a b c],[a c b],[a c ],[b c],[b c ]]]
--R                             Type: OneDimensionalArray List LyndonWord Symbol
--E 7

--S 8 of 22
LyndonWordsList([a,b,c],3)$lword
--R 
--R
--R   (8)
--R                                          2      2        2
--R   [[a], [b], [c], [a b], [a c], [b c], [a b], [a c], [a b ], [a b c], [a c b],
--R        2     2        2
--R    [a c ], [b c], [b c ]]
--R                                                 Type: List LyndonWord Symbol
--E 8

--S 9 of 22
lw := LyndonWordsList([a,b],5)$lword
--R 
--R
--R   (9)
--R                       2        2     3      2 2       3     4      3 2
--R   [[a], [b], [a b], [a b], [a b ], [a b], [a b ], [a b ], [a b], [a b ],
--R      2          2 3           2       4
--R    [a b a b], [a b ], [a b a b ], [a b ]]
--R                                                 Type: List LyndonWord Symbol
--E 9

--S 10 of 22
w1 : word := lw.4 :: word
--R 
--R
--R          2
--R   (10)  a b
--R                                               Type: OrderedFreeMonoid Symbol
--E 10

--S 11 of 22
w2 : word := lw.5 :: word
--R 
--R
--R            2
--R   (11)  a b
--R                                               Type: OrderedFreeMonoid Symbol
--E 11

--S 12 of 22
factor(a::word)$lword
--R 
--R
--R   (12)  [[a]]
--R                                                 Type: List LyndonWord Symbol
--E 12

--S 13 of 22
factor(w1*w2)$lword
--R 
--R
--R            2     2
--R   (13)  [[a b a b ]]
--R                                                 Type: List LyndonWord Symbol
--E 13

--S 14 of 22
factor(w2*w2)$lword
--R 
--R
--R              2      2
--R   (14)  [[a b ],[a b ]]
--R                                                 Type: List LyndonWord Symbol
--E 14

--S 15 of 22
factor(w2*w1)$lword
--R 
--R
--R              2    2
--R   (15)  [[a b ],[a b]]
--R                                                 Type: List LyndonWord Symbol
--E 15

--S 16 of 22
lyndon?(w1)$lword
--R 
--R
--R   (16)  true
--R                                                                Type: Boolean
--E 16

--S 17 of 22
lyndon?(w1*w2)$lword
--R 
--R
--R   (17)  true
--R                                                                Type: Boolean
--E 17

--S 18 of 22
lyndon?(w2*w1)$lword
--R 
--R
--R   (18)  false
--R                                                                Type: Boolean
--E 18

--S 19 of 22
lyndonIfCan(w1)$lword
--R 
--R
--R           2
--R   (19)  [a b]
--R                                           Type: Union(LyndonWord Symbol,...)
--E 19

--S 20 of 22
lyndonIfCan(w2*w1)$lword
--R 
--R
--R   (20)  "failed"
--R                                                    Type: Union("failed",...)
--E 20

--S 21 of 22
lyndon(w1)$lword
--R 
--R
--R           2
--R   (21)  [a b]
--R                                                      Type: LyndonWord Symbol
--E 21

--S 22 of 22
lyndon(w1*w2)$lword
--R 
--R
--R           2     2
--R   (22)  [a b a b ]
--R                                                      Type: LyndonWord Symbol
--E 22
)spool
)lisp (bye)
@
<<LyndonWord.help>>=
====================================================================
LyndonWord examples
====================================================================

A function f in [0,1] is called acyclic if C(F) consists of n
different objects. The canonical representative of the orbit of an
acyclic function is usually called a Lyndon Word. If f is acyclic,
then all elements in the orbit C(f) are acyclic as well, and we call
C(f) an acyclic orbit.

====================================================================
Initialisations
====================================================================

  a:Symbol :='a
    a
                            Type: Symbol

  b:Symbol :='b
    b
                            Type: Symbol

  c:Symbol :='c
    c
                            Type: Symbol

  lword:= LyndonWord(Symbol)
    LyndonWord Symbol
                            Type: Domain

  magma := Magma(Symbol)
    Magma Symbol
                            Type: Domain

  word := OrderedFreeMonoid(Symbol)
    OrderedFreeMonoid Symbol
                            Type: Domain

All Lyndon words of with a, b, c to order 3

  LyndonWordsList1([a,b,c],3)$lword
   [[[a],[b],[c]], [[a b],[a c],[b c]],
       2     2       2                      2    2       2
    [[a b],[a c],[a b ],[a b c],[a c b],[a c ],[b c],[b c ]]]
                            Type: OneDimensionalArray List LyndonWord Symbol

All Lyndon words of with a, b, c to order 3 in flat list

  LyndonWordsList([a,b,c],3)$lword
                                          2      2        2
   [[a], [b], [c], [a b], [a c], [b c], [a b], [a c], [a b ], [a b c], [a c b],
        2     2        2
    [a c ], [b c], [b c ]]
                            Type: List LyndonWord Symbol

All Lyndon words of with a, b to order 5

  lw := LyndonWordsList([a,b],5)$lword
                       2        2     3      2 2       3     4      3 2
   [[a], [b], [a b], [a b], [a b ], [a b], [a b ], [a b ], [a b], [a b ],
      2          2 3           2       4
    [a b a b], [a b ], [a b a b ], [a b ]]
                            Type: List LyndonWord Symbol

  w1 : word := lw.4 :: word
     2
    a b
                             Type: OrderedFreeMonoid Symbol

  w2 : word := lw.5 :: word
       2
    a b
                             Type: OrderedFreeMonoid Symbol

Let's try factoring

  factor(a::word)$lword
    [[a]]
                             Type: List LyndonWord Symbol

  factor(w1*w2)$lword
       2     2
    [[a b a b ]]
                             Type: List LyndonWord Symbol

  factor(w2*w2)$lword
         2      2
    [[a b ],[a b ]]
                             Type: List LyndonWord Symbol

  factor(w2*w1)$lword
         2    2
    [[a b ],[a b]]
                             Type: List LyndonWord Symbol

====================================================================
Checks and coercions
====================================================================

  lyndon?(w1)$lword
    true
                             Type: Boolean

  lyndon?(w1*w2)$lword
    true
                             Type: Boolean

  lyndon?(w2*w1)$lword
    false
                             Type: Boolean

  lyndonIfCan(w1)$lword
      2
    [a b]
                             Type: Union(LyndonWord Symbol,...)

  lyndonIfCan(w2*w1)$lword
    "failed"
                             Type: Union("failed",...)

  lyndon(w1)$lword
      2
    [a b]
                             Type: LyndonWord Symbol

  lyndon(w1*w2)$lword
      2     2
    [a b a b ]
                             Type: LyndonWord Symbol

See Also:
o )show LyndonWord
o $AXIOM/doc/src/algebra/xlpoly.spad.dvi

@
<<domain LWORD LyndonWord>>=
)abbrev domain LWORD LyndonWord
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References: Free Lie Algebras by C. Reutenauer (Oxford science publications).
++ Description:
++ Lyndon words over arbitrary (ordered) symbols:
++ see Free Lie Algebras by C. Reutenauer (Oxford science publications).
++ A Lyndon word is a word which is smaller than any of its right factors
++ w.r.t. the pure lexicographical ordering.
++ If \axiom{a} and \axiom{b} are two Lyndon words such that \axiom{a < b}
++ holds w.r.t lexicographical ordering then \axiom{a*b} is a Lyndon word.
++ Parenthesized Lyndon words can be generated from symbols by using the following
++ rule: \axiom{[[a,b],c]} is a Lyndon word iff \axiom{a*b < c <= b} holds.
++ Lyndon words are internally represented by binary trees using the
++ \spadtype{Magma} domain constructor.
++ Two ordering are provided: lexicographic and 
++ length-lexicographic. \newline 
++ Author : Michel Petitot (petitot@lifl.fr).

LyndonWord(VarSet:OrderedSet):Public == Private where
   OFMON ==> OrderedFreeMonoid(VarSet)
   PI    ==> PositiveInteger
   NNI   ==> NonNegativeInteger
   I     ==> Integer
   OF    ==> OutputForm
   ARRAY1==> OneDimensionalArray

   Public == Join(OrderedSet,RetractableTo VarSet) with
      retractable?  : $ -> Boolean
        ++ \axiom{retractable?(x)} tests if \axiom{x} is a tree with only one entry.
      left          : $ -> $
        ++ \axiom{left(x)} returns left subtree of \axiom{x} or
        ++ error if \axiomOpFrom{retractable?}{LyndonWord}(\axiom{x}) is true.
      right  :  $ -> $
        ++ \axiom{right(x)} returns right subtree of \axiom{x} or
        ++ error if \axiomOpFrom{retractable?}{LyndonWord}(\axiom{x}) is true.
      length :  $ -> PI
        ++ \axiom{length(x)} returns the number of entries in \axiom{x}.
      lexico :  ($,$) -> Boolean 
        ++ \axiom{lexico(x,y)} returns \axiom{true} iff  \axiom{x} is smaller than 
        ++ \axiom{y} w.r.t. the lexicographical ordering induced by \axiom{VarSet}. 
      coerce :  $ -> OFMON
        ++ \axiom{coerce(x)} returns the element of \axiomType{OrderedFreeMonoid}(VarSet) 
        ++ corresponding to \axiom{x}.
      coerce :  $ -> Magma VarSet
        ++ \axiom{coerce(x)} returns the element of \axiomType{Magma}(VarSet)
        ++ corresponding to \axiom{x}.
      factor :  OFMON -> List $  
        ++ \axiom{factor(x)} returns the decreasing factorization into Lyndon words. 
      lyndon?:  OFMON -> Boolean
        ++ \axiom{lyndon?(w)} test if \axiom{w} is a Lyndon word.
      lyndon :  OFMON -> $
        ++ \axiom{lyndon(w)} convert \axiom{w} into a Lyndon word, 
        ++ error if \axiom{w} is not a Lyndon word.
      lyndonIfCan : OFMON -> Union($, "failed")
        ++ \axiom{lyndonIfCan(w)} convert \axiom{w} into a Lyndon word.
      varList     : $ -> List VarSet
        ++ \axiom{varList(x)} returns the list of distinct entries of \axiom{x}.
      LyndonWordsList1: (List VarSet, PI)  -> ARRAY1 List $
        ++ \axiom{LyndonWordsList1(vl, n)} returns an array of lists of Lyndon
        ++ words over the alphabet \axiom{vl}, up to order \axiom{n}.
      LyndonWordsList : (List VarSet, PI)  -> List $
        ++ \axiom{LyndonWordsList(vl, n)} returns the list of Lyndon
        ++ words over the alphabet \axiom{vl}, up to order \axiom{n}.

   Private == Magma(VarSet) add
     -- Representation
       Rep:= Magma(VarSet)

     -- Fonctions locales
       LetterList : OFMON -> List VarSet
       factor1    : (List $, $, List $) -> List $

     -- Definitions
       lyndon? w ==
         w = 1$OFMON => false
         f: OFMON := rest w
         while f ^= 1$OFMON repeat
           not lexico(w,f) => return false
           f := rest f
         true

       lyndonIfCan w ==
         l: List $ := factor w
         # l = 1 => first l
         "failed"

       lyndon w ==
         l: List $ := factor w
         # l = 1 => first l
         error "This word is not a Lyndon word"

       LetterList w ==
         w = 1 => []
         cons(first w , LetterList rest w)

       factor1 (gauche, x, droite) == 
         g: List $ := gauche; d: List $ := droite
         while not null g repeat             ++ (l in g or l=x) et u in d 
           lexico(  g.first , x ) =>         ++  => right(l) >= u 
              x  := g.first *$Rep x          -- crochetage
              null(d) => g := rest g
              g := cons( x, rest g)          -- mouvement a droite
              x  := first d
              d := rest d
           d := cons( x , d)                 -- mouvement a gauche
           x  := first g
           g := rest g
         return cons(x, d)

       factor w ==
         w = 1 => []
         l : List $ := reverse [ u::$ for u in LetterList w]
         factor1( rest l, first l , [] )
      
       x < y ==                     -- lexicographique par longueur
         lx,ly: PI
         lx:= length x ; ly:= length y
         lx = ly => lexico(x,y)
         lx < ly
 
       coerce(x:$):OF == bracket(x::OFMON::OF)
       coerce(x:$):Magma VarSet == x::Rep

       LyndonWordsList1 (vl,n) ==    -- a ameliorer !!!!!!!!!!!
            null vl => error "empty list"
            base: ARRAY1 List $ := new(n::I::NNI ,[])
           
           -- mots de longueur 1
            lbase1:List $ := [w::$ for w in sort(vl)]
            base.1 := lbase1

           -- calcul des mots de longueur ll
            for ll in 2..n:I  repeat 
               lbase1 := []   
               for a in base(1) repeat              -- lettre + mot
                  for b in base(ll-1) repeat
                     if lexico(a,b) then lbase1:=cons(a*b,lbase1)

               for i in 2..ll-1 repeat              -- mot + mot
                 for a in base(i) repeat             
                   for b in base(ll-i) repeat
                     if lexico(a,b) and (lexico(b,right a) or b = right a ) 
                     then lbase1:=cons(a*b,lbase1)
 
               base(ll):= sort_!(lexico, lbase1)
            return base
           
       LyndonWordsList (vl,n) ==
           v:ARRAY1 List $ := LyndonWordsList1(vl,n)
           "append"/ [v.i for i in 1..n] 

@
\section{package XEXPPKG XExponentialPackage}
<<package XEXPPKG XExponentialPackage>>=
)abbrev package XEXPPKG XExponentialPackage
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides computations of logarithms and exponentials 
++ for polynomials in non-commutative 
++ variables. \newline Author: Michel Petitot (petitot@lifl.fr).

XExponentialPackage(R, VarSet, XPOLY): Public == Private where
    RN     ==> Fraction Integer 
    NNI    ==> NonNegativeInteger
    I      ==> Integer
    R      : Join(Ring, Module RN)
    -- R      : Field
    VarSet : OrderedSet
    XPOLY  : XPolynomialsCat(VarSet, R)

    Public == with
       exp:  (XPOLY, NNI) -> XPOLY
         ++ \axiom{exp(p, n)} returns the exponential of \axiom{p}
         ++ truncated at order \axiom{n}.
       log:  (XPOLY, NNI) -> XPOLY
         ++ \axiom{log(p, n)} returns the logarithm of \axiom{p}
         ++ truncated at order \axiom{n}.
       Hausdorff: (XPOLY, XPOLY, NNI) -> XPOLY
         ++ \axiom{Hausdorff(a,b,n)} returns log(exp(a)*exp(b))
         ++ truncated at order \axiom{n}.

    Private == add
  
        log (p,n) ==
           p1 : XPOLY := p - 1
           not quasiRegular? p1 => 
             error "constant term <> 1, impossible log"
           s : XPOLY := 0       -- resultat
           k : I := n :: I 
           for i in 1 .. n repeat
              k1 :RN := 1/k
              k2 : R := k1 * 1$R
              s := trunc( trunc(p1,i) * (k2 :: XPOLY - s) , i)
              k := k - 1
           s

        exp (p,n) ==
           not quasiRegular? p => 
             error "constant term <> 0, exp impossible"
           p = 0 => 1
           s : XPOLY := 1$XPOLY       -- resultat
           k : I := n :: I
           for i in 1 .. n repeat
              k1 :RN := 1/k
              k2 : R := k1 * 1$R
              s := trunc( 1 +$XPOLY k2 * trunc(p,i) * s , i)
              k := k - 1
           s

        Hausdorff(p,q,n) ==
           p1: XPOLY := exp(p,n)
           q1: XPOLY := exp(q,n)
           log(p1*q1, n)

@
\section{domain LPOLY LiePolynomial}
<<LiePolynomial.input>>=
-- xlpoly.spad.pamphlet LiePolynomial.input
)spool LiePolynomial.output
)set message test on
)set message auto off
)clear all
--S 1 of 28
RN := Fraction Integer
--R 
--R
--R   (1)  Fraction Integer
--R                                                                 Type: Domain
--E 1

--S 2 of 28
Lpoly := LiePolynomial(Symbol,RN)
--R 
--R
--R   (2)  LiePolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 2

--S 3 of 28
Dpoly := XDPOLY(Symbol,RN)
--R 
--R
--R   (3)  XDistributedPolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 3

--S 4 of 28
Lword := LyndonWord Symbol
--R 
--R
--R   (4)  LyndonWord Symbol
--R                                                                 Type: Domain
--E 4

--S 5 of 28
a:Symbol := 'a
--R 
--R
--R   (5)  a
--R                                                                 Type: Symbol
--E 5

--S 6 of 28
b:Symbol := 'b 
--R 
--R
--R   (6)  b
--R                                                                 Type: Symbol
--E 6

--S 7 of 28
c:Symbol := 'c
--R 
--R
--R   (7)  c
--R                                                                 Type: Symbol
--E 7

--S 8 of 28
aa: Lpoly := a 
--R 
--R
--R   (8)  [a]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 8

--S 9 of 28
bb: Lpoly := b
--R 
--R
--R   (9)  [b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 9

--S 10 of 28
cc: Lpoly := c
--R 
--R
--R   (10)  [c]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 10

--S 11 of 28
p : Lpoly := [aa,bb]
--R 
--R
--R   (11)  [a b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 11

--S 12 of 28
q : Lpoly := [p,bb]
--R 
--R
--R             2
--R   (12)  [a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 12

--S 13 of 28
liste : List Lword := LyndonWordsList([a,b], 4)
--R 
--R
--R                          2       2    3     2 2      3
--R   (13)  [[a],[b],[a b],[a b],[a b ],[a b],[a b ],[a b ]]
--R                                                 Type: List LyndonWord Symbol
--E 13

--S 14 of 28
r: Lpoly := p + q + 3*LiePoly(liste.4)$Lpoly
--R 
--R
--R                    2         2
--R   (14)  [a b] + 3[a b] + [a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 14

--S 15 of 28
s:Lpoly := [p,r]
--R 
--R
--R              2                 2
--R   (15)  - 3[a b a b] + [a b a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 15

--S 16 of 28
t:Lpoly  := s  + 2*LiePoly(liste.3) - 5*LiePoly(liste.5)
--R 
--R
--R                       2       2                 2
--R   (16)  2[a b] - 5[a b ] - 3[a b a b] + [a b a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 16

--S 17 of 28
degree t
--R 
--R
--R   (17)  5
--R                                                        Type: PositiveInteger
--E 17

--S 18 of 28
mirror t
--R 
--R
--R                         2       2                 2
--R   (18)  - 2[a b] - 5[a b ] - 3[a b a b] + [a b a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 18

--S 19 of 28
Jacobi(p: Lpoly, q: Lpoly, r: Lpoly): Lpoly == _
   [ [p,q]$Lpoly, r] + [ [q,r]$Lpoly, p] + [ [r,p]$Lpoly, q]  
--R 
--R   Function declaration Jacobi : (LiePolynomial(Symbol,Fraction Integer
--R      ),LiePolynomial(Symbol,Fraction Integer),LiePolynomial(Symbol,
--R      Fraction Integer)) -> LiePolynomial(Symbol,Fraction Integer) has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 19

--S 20 of 28
test: Lpoly := Jacobi(a,b,b)
--R 
--R   Compiling function Jacobi with type (LiePolynomial(Symbol,Fraction 
--R      Integer),LiePolynomial(Symbol,Fraction Integer),LiePolynomial(
--R      Symbol,Fraction Integer)) -> LiePolynomial(Symbol,Fraction 
--R      Integer) 
--R
--R   (20)  0
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 20

--S 21 of 28
test: Lpoly := Jacobi(p,q,r)
--R 
--R
--R   (21)  0
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 21

--S 22 of 28
test: Lpoly := Jacobi(r,s,t)
--R 
--R
--R   (22)  0
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 22

--S 23 of 28
eval(p, a, p)$Lpoly
--R 
--R
--R             2
--R   (23)  [a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 23

--S 24 of 28
eval(p, [a,b], [2*bb, 3*aa])$Lpoly
--R 
--R
--R   (24)  - 6[a b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 24

--S 25 of 28
r: Lpoly := [p,c]
--R 
--R
--R   (25)  [a b c] + [a c b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 25

--S 26 of 28
r1: Lpoly := eval(r, [a,b,c], [bb, cc, aa])$Lpoly 
--R 
--R
--R   (26)  - [a b c]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 26

--S 27 of 28
r2: Lpoly := eval(r, [a,b,c], [cc, aa, bb])$Lpoly 
--R 
--R
--R   (27)  - [a c b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 27

--S 28 of 28
r + r1 + r2
--R 
--R
--R   (28)  0
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 28
)spool
 
)spool
)lisp (bye)
@
<<LiePolynomial.help>>=
====================================================================
LiePolynomial examples
====================================================================

====================================================================
Declaration of domains
====================================================================

  RN := Fraction Integer
    Fraction Integer
                     Type: Domain

  Lpoly := LiePolynomial(Symbol,RN)
    LiePolynomial(Symbol,Fraction Integer)
                     Type: Domain

  Dpoly := XDPOLY(Symbol,RN)
    XDistributedPolynomial(Symbol,Fraction Integer)
                     Type: Domain

  Lword := LyndonWord Symbol
    LyndonWord Symbol
                     Type: Domain

====================================================================
Initialisation
====================================================================

  a:Symbol := 'a
    a
                     Type: Symbol

  b:Symbol := 'b 
    b
                     Type: Symbol

  c:Symbol := 'c
    c
                     Type: Symbol

  aa: Lpoly := a 
    [a]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  bb: Lpoly := b
    [b]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  cc: Lpoly := c
    [c]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  p : Lpoly := [aa,bb]
    [a b]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  q : Lpoly := [p,bb]
        2
    [a b ]
                     Type: LiePolynomial(Symbol,Fraction Integer)

All the Lyndon words of order 4

  liste : List Lword := LyndonWordsList([a,b], 4)
                     2       2    3     2 2      3
    [[a],[b],[a b],[a b],[a b ],[a b],[a b ],[a b ]]
                     Type: List LyndonWord Symbol

  r: Lpoly := p + q + 3*LiePoly(liste.4)$Lpoly
               2         2
    [a b] + 3[a b] + [a b ]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  s:Lpoly := [p,r]
         2                 2
    - 3[a b a b] + [a b a b ]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  t:Lpoly  := s  + 2*LiePoly(liste.3) - 5*LiePoly(liste.5)
                  2       2                 2
    2[a b] - 5[a b ] - 3[a b a b] + [a b a b ]
                     Type: LiePolynomial(Symbol,Fraction Integer)

  degree t
    5
                     Type: PositiveInteger

  mirror t
                    2       2                 2
    - 2[a b] - 5[a b ] - 3[a b a b] + [a b a b ]
                     Type: LiePolynomial(Symbol,Fraction Integer)

====================================================================
Jacobi Relation
====================================================================

 Jacobi(p: Lpoly, q: Lpoly, r: Lpoly): Lpoly == _
   [ [p,q]\$Lpoly, r] + [ [q,r]\$Lpoly, p] + [ [r,p]\$Lpoly, q]  
                    Type: Void

====================================================================
Tests
====================================================================

  test: Lpoly := Jacobi(a,b,b)
    0
                    Type: LiePolynomial(Symbol,Fraction Integer)

  test: Lpoly := Jacobi(p,q,r)
    0
                    Type: LiePolynomial(Symbol,Fraction Integer)

  test: Lpoly := Jacobi(r,s,t)
    0
                    Type: LiePolynomial(Symbol,Fraction Integer)

====================================================================
Evaluation
====================================================================

  eval(p, a, p)$Lpoly
        2
    [a b ]
                    Type: LiePolynomial(Symbol,Fraction Integer)

  eval(p, [a,b], [2*bb, 3*aa])$Lpoly
    - 6[a b]
                    Type: LiePolynomial(Symbol,Fraction Integer)

  r: Lpoly := [p,c]
    [a b c] + [a c b]
                    Type: LiePolynomial(Symbol,Fraction Integer)

  r1: Lpoly := eval(r, [a,b,c], [bb, cc, aa])$Lpoly 
    - [a b c]
                    Type: LiePolynomial(Symbol,Fraction Integer)

  r2: Lpoly := eval(r, [a,b,c], [cc, aa, bb])$Lpoly 
    - [a c b]
                    Type: LiePolynomial(Symbol,Fraction Integer)

  r + r1 + r2
    0
                    Type: LiePolynomial(Symbol,Fraction Integer)

See Also:
o )help LyndonWord
o )help XDistributedPolynomial
o )show LiePolynomial
o $AXIOM/doc/src/algebra/xlpoly.spad.dvi 

@
<<domain LPOLY LiePolynomial>>=
)abbrev domain LPOLY LiePolynomial
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:Free Lie Algebras by C. Reutenauer (Oxford science publications). 
++ Description:
++ This type supports Lie polynomials in Lyndon basis
++ see Free Lie Algebras by C. Reutenauer 
++ (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.fr).

LiePolynomial(VarSet:OrderedSet, R:CommutativeRing) : Public == Private where
   MAGMA   ==> Magma(VarSet)
   LWORD   ==> LyndonWord(VarSet)
   WORD    ==> OrderedFreeMonoid(VarSet)
   XDPOLY  ==> XDistributedPolynomial(VarSet,R)
   XRPOLY  ==> XRecursivePolynomial(VarSet,R)
   NNI     ==> NonNegativeInteger
   RN      ==> Fraction Integer
   EX      ==> OutputForm
   TERM    ==> Record(k: LWORD, c: R)

   Public == Join(FreeLieAlgebra(VarSet,R), FreeModuleCat(R,LWORD)) with
      LiePolyIfCan: XDPOLY -> Union($, "failed")
        ++ \axiom{LiePolyIfCan(p)} returns \axiom{p} in Lyndon basis
        ++ if \axiom{p} is a Lie polynomial, otherwise \axiom{"failed"}
        ++ is returned.
      construct: (LWORD, LWORD) -> $
        ++ \axiom{construct(x,y)} returns the Lie bracket \axiom{[x,y]}.
      construct: (LWORD, $) -> $
        ++ \axiom{construct(x,y)} returns the Lie bracket \axiom{[x,y]}.
      construct: ($, LWORD) -> $     
        ++ \axiom{construct(x,y)} returns the Lie bracket \axiom{[x,y]}.

   Private ==  FreeModule1(R, LWORD) add       
        import(TERM)

      --representation
        Rep :=  List TERM

      -- fonctions locales
        cr1 : (LWORD, $    ) -> $
        cr2 : ($, LWORD    ) -> $
        crw : (LWORD, LWORD) -> $     -- crochet de 2 mots de Lyndon
        DPoly: LWORD -> XDPOLY
        lquo1: (XRPOLY , LWORD) -> XRPOLY
        lyndon: (LWORD, LWORD) -> $
        makeLyndon: (LWORD, LWORD) -> LWORD
        rquo1: (XRPOLY , LWORD) -> XRPOLY
        RPoly: LWORD -> XRPOLY
        eval1: (LWORD, VarSet, $) -> $                     -- 08/03/98
        eval2: (LWORD, List VarSet, List $) -> $           -- 08/03/98


      -- Evaluation
        eval1(lw,v,nv) ==                                  -- 08/03/98
          not member?(v, varList(lw)$LWORD) => LiePoly lw
          (s := retractIfCan(lw)$LWORD) case VarSet => 
             if (s::VarSet) = v then nv else LiePoly lw 
          l: LWORD := left lw
          r: LWORD := right lw
          construct(eval1(l,v,nv), eval1(r,v,nv))

        eval2(lw,lv,lnv) ==                                -- 08/03/98
          p: Integer
          (s := retractIfCan(lw)$LWORD) case VarSet =>
             p := position(s::VarSet, lv)$List(VarSet) 
             if p=0 then lw::$ else elt(lnv,p)$List($)
          l: LWORD := left lw
          r: LWORD := right lw
          construct(eval2(l,lv,lnv), eval2(r,lv,lnv))

        eval(p:$, v: VarSet, nv: $): $ ==                  -- 08/03/98
          +/ [t.c * eval1(t.k, v, nv) for t in p]

        eval(p:$, lv: List(VarSet), lnv: List($)): $ ==    -- 08/03/98
          +/ [t.c * eval2(t.k, lv, lnv) for t in p]

        lquo1(p,lw) ==
          constant? p => 0$XRPOLY
          retractable? lw => lquo(p, retract lw)$XRPOLY
          lquo1(lquo1(p, left lw),right lw) - lquo1(lquo1(p, right lw),left lw)  
        rquo1(p,lw) ==
          constant? p => 0$XRPOLY
          retractable? lw => rquo(p, retract lw)$XRPOLY
          rquo1(rquo1(p, left lw),right lw) - rquo1(rquo1(p, right lw),left lw)

        coef(p, lp) == coef(p, lp::XRPOLY)$XRPOLY

        lquo(p, lp) ==
          lp = 0 => 0$XRPOLY
          +/ [t.c * lquo1(p,t.k) for t in lp]
 
        rquo(p, lp) ==
          lp = 0 => 0$XRPOLY
          +/ [t.c * rquo1(p,t.k) for t in lp] 

        LiePolyIfCan p ==         -- inefficace a cause de la rep. de XDPOLY
           not quasiRegular? p => "failed"
           p1: XDPOLY := p ; r:$ := 0
           while p1 ^= 0 repeat
             t: Record(k:WORD, c:R) := mindegTerm p1
             w: WORD := t.k; coef:R := t.c
             (l := lyndonIfCan(w)$LWORD) case "failed" => return "failed"
             lp:$ := coef * LiePoly(l::LWORD)
             r := r + lp 
             p1 := p1 - lp::XDPOLY 
           r
 
      --definitions locales
        makeLyndon(u,v) == (u::MAGMA * v::MAGMA) pretend LWORD
 
        crw(u,v) ==               -- u et v sont des mots de Lyndon
          u = v => 0
          lexico(u,v) => lyndon(u,v)
          - lyndon (v,u)

        lyndon(u,v) ==            -- u et v sont des mots de Lyndon tq u < v
          retractable? u => monom(makeLyndon(u,v),1)
          u1: LWORD := left u
          u2: LWORD := right u
          lexico(u2,v) => cr1(u1, lyndon(u2,v)) + cr2(lyndon(u1,v), u2)
          monom(makeLyndon(u,v),1)
           
        cr1 (l, p) ==
            +/[t.c * crw(l, t.k) for t in p]

        cr2 (p, l) ==
            +/[t.c * crw(t.k, l) for t in p]

        DPoly w ==
           retractable? w => retract(w) :: XDPOLY 
           l:XDPOLY := DPoly left w
           r:XDPOLY := DPoly right w
           l*r - r*l

        RPoly w ==
           retractable? w => retract(w) :: XRPOLY 
           l:XRPOLY := RPoly left w
           r:XRPOLY := RPoly right w
           l*r - r*l 
    
      -- definitions

        coerce(v:VarSet) == monom(v::LWORD , 1)

        construct(x:$ , y:$):$ ==
            +/[t.c * cr1(t.k, y) for t in x]

        construct(l:LWORD , p:$):$ == cr1(l,p) 
        construct(p:$ , l:LWORD):$ == cr2(p,l)
        construct(u:LWORD , v:LWORD):$ == crw(u,v)

        coerce(p:$):XDPOLY ==
            +/ [t.c * DPoly(t.k) for t in p]

        coerce(p:$):XRPOLY ==
            +/ [t.c * RPoly(t.k) for t in p]

        LiePoly(l) == monom(l,1)

        varList p ==
          le : List VarSet := "setUnion"/[varList(t.k)$LWORD for t in p]
          sort(le)$List(VarSet)

        mirror p ==
          [[t.k, (odd? length t.k => t.c; -t.c)]$TERM for t in p]

        trunc(p, n) ==
          degree(p) > n => trunc( reductum p , n)
          p

        degree p == 
          null p => 0
          length( p.first.k)$LWORD

      --  ListOfTerms p == p pretend List TERM
        
--        coerce(x) : EX ==
--           null x => (0$R) :: EX
--           le : List EX := nil
--           for rec in x repeat
--             rec.c = 1$R => le := cons(rec.k :: EX, le)
--             le := cons(mkBinary("*"::EX,  rec.c :: EX, rec.k :: EX), le)
--           1 = #le => first le
--           mkNary("+" :: EX,le)

@
\section{domain PBWLB PoincareBirkhoffWittLyndonBasis}
<<domain PBWLB PoincareBirkhoffWittLyndonBasis>>=
)abbrev domain PBWLB PoincareBirkhoffWittLyndonBasis
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This domain provides the internal representation
++ of polynomials in non-commutative variables written
++ over the Poincare-Birkhoff-Witt basis.
++ See the \spadtype{XPBWPolynomial} domain constructor.
++ See Free Lie Algebras by C. Reutenauer 
++ (Oxford science publications). \newline Author: Michel Petitot (petitot@lifl.fr).

PoincareBirkhoffWittLyndonBasis(VarSet: OrderedSet): Public == Private where
   WORD    ==> OrderedFreeMonoid(VarSet)
   LWORD   ==> LyndonWord(VarSet)
   LWORDS  ==> List(LWORD)
   PI      ==> PositiveInteger
   NNI     ==> NonNegativeInteger
   EX      ==> OutputForm

   Public == Join(OrderedSet, RetractableTo LWORD) with
      1: constant -> %
         ++ \spad{1} returns the empty list.
      coerce       : $ -> WORD
         ++ \spad{coerce([l1]*[l2]*...[ln])} returns the word \spad{l1*l2*...*ln},
         ++ where \spad{[l_i]} is the backeted form of the Lyndon word \spad{l_i}.
      coerce       : VarSet -> $
         ++ \spad{coerce(v)} return \spad{v}
      first        : $ -> LWORD
         ++ \spad{first([l1]*[l2]*...[ln])} returns the Lyndon word \spad{l1}.
      length       : $ -> NNI
         ++ \spad{length([l1]*[l2]*...[ln])} returns the length of the word \spad{l1*l2*...*ln}.
      ListOfTerms  : $ -> LWORDS
         ++ \spad{ListOfTerms([l1]*[l2]*...[ln])} returns the list of words \spad{l1, l2, .... ln}.
      rest         : $ -> $
         ++ \spad{rest([l1]*[l2]*...[ln])} returns the list \spad{l2, .... ln}.
      retractable? : $ -> Boolean
         ++ \spad{retractable?([l1]*[l2]*...[ln])} returns true iff \spad{n}  equals \spad{1}.
      varList      : $ -> List VarSet
         ++ \spad{varList([l1]*[l2]*...[ln])} returns the list of
         ++ variables in the word \spad{l1*l2*...*ln}.
   
   Private == add

    -- Representation
     Rep := LWORDS

    -- Locales
     recursif: ($,$) -> Boolean

    -- Define
     1 == nil

     x = y == x =$Rep y

     varList x ==
        null x => nil
        le: List VarSet := "setUnion"/ [varList$LWORD l for l in x]

     first x == first(x)$Rep
     rest x == rest(x)$Rep

     coerce(v: VarSet):$ == [ v::LWORD ]
     coerce(l: LWORD):$ == [l]
     ListOfTerms(x:$):LWORDS == x pretend LWORDS      

     coerce(x:$):WORD ==
       null x => 1
       x.first :: WORD *$WORD coerce(x.rest)

     coerce(x:$):EX ==
       null x => outputForm(1$Integer)$EX
       reduce(_* ,[l :: EX for l in x])$List(EX)

     retractable? x == 
       null x => false
       null x.rest

     retract x == 
        #x ^= 1 => error "cannot convert to Lyndon word"
        x.first

     retractIfCan x ==
        retractable? x => x.first
        "failed"
      
     length x ==
        n: Integer := +/[ length l for l in x]
        n::NNI

     recursif(x, y) ==
       null y => false
       null x => true
       x.first = y.first => recursif(rest(x), rest(y))
       lexico(x.first, y.first)

     x < y == 
       lx: NNI := length x; ly: NNI := length y 
       lx = ly => recursif(x,y)
       lx < ly

@
\section{domain XPBWPOLY XPBWPolynomial}
<<XPBWPolynomial.input>>=
-- xlpoly.spad.pamphlet XPBWPolynomial.input
)spool XPBWPolynomial.output
)set message test on
)set message auto off
)clear all
--S 1 of 39
a:Symbol := 'a
--R 
--R
--R   (1)  a
--R                                                                 Type: Symbol
--E 1

--S 2 of 39
b:Symbol := 'b
--R 
--R
--R   (2)  b
--R                                                                 Type: Symbol
--E 2

--S 3 of 39
RN := Fraction(Integer)
--R 
--R
--R   (3)  Fraction Integer
--R                                                                 Type: Domain
--E 3

--S 4 of 39
word := OrderedFreeMonoid Symbol
--R 
--R
--R   (4)  OrderedFreeMonoid Symbol
--R                                                                 Type: Domain
--E 4

--S 5 of 39
lword := LyndonWord(Symbol)
--R 
--R
--R   (5)  LyndonWord Symbol
--R                                                                 Type: Domain
--E 5

--S 6 of 39
base := PoincareBirkhoffWittLyndonBasis Symbol
--R 
--R
--R   (6)  PoincareBirkhoffWittLyndonBasis Symbol
--R                                                                 Type: Domain
--E 6

--S 7 of 39
dpoly := XDistributedPolynomial(Symbol, RN)
--R 
--R
--R   (7)  XDistributedPolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 7

--S 8 of 39
rpoly := XRecursivePolynomial(Symbol, RN)
--R 
--R
--R   (8)  XRecursivePolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 8

--S 9 of 39
lpoly := LiePolynomial(Symbol, RN)
--R 
--R
--R   (9)  LiePolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 9

--S 10 of 39
poly  := XPBWPolynomial(Symbol, RN)
--R 
--R
--R   (10)  XPBWPolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 10

--S 11 of 39
liste : List lword := LyndonWordsList([a,b], 6)
--R 
--R
--R   (11)
--R                       2        2     3      2 2       3     4      3 2
--R   [[a], [b], [a b], [a b], [a b ], [a b], [a b ], [a b ], [a b], [a b ],
--R      2          2 3           2       4     5      4 2     3          3 3
--R    [a b a b], [a b ], [a b a b ], [a b ], [a b], [a b ], [a b a b], [a b ],
--R      2     2     2 2        2 4           3       5
--R    [a b a b ], [a b a b], [a b ], [a b a b ], [a b ]]
--R                                                 Type: List LyndonWord Symbol
--E 11

--S 12 of 39
0$poly
--R 
--R
--R   (12)  0
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 12

--S 13 of 39
1$poly
--R 
--R
--R   (13)  1
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 13

--S 14 of 39
p : poly := a
--R 
--R
--R   (14)  [a]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 14

--S 15 of 39
q : poly := b
--R 
--R
--R   (15)  [b]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 15

--S 16 of 39
pq: poly := p*q
--R 
--R
--R   (16)  [a b] + [b][a]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 16

--S 17 of 39
pq :: dpoly
--R 
--R
--R   (17)  a b
--R                        Type: XDistributedPolynomial(Symbol,Fraction Integer)
--E 17

--S 18 of 39
mirror pq
--R 
--R
--R   (18)  [b][a]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 18

--S 19 of 39
ListOfTerms pq
--R 
--R
--R   (19)  [[k= [b][a],c= 1],[k= [a b],c= 1]]
--RType: List Record(k: PoincareBirkhoffWittLyndonBasis Symbol,c: Fraction Integer)
--E 19

--S 20 of 39
reductum pq
--R 
--R
--R   (20)  [a b]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 20

--S 21 of 39
leadingMonomial pq
--R 
--R
--R   (21)  [b][a]
--R                                 Type: PoincareBirkhoffWittLyndonBasis Symbol
--E 21

--S 22 of 39
coefficients pq
--R 
--R
--R   (22)  [1,1]
--R                                                  Type: List Fraction Integer
--E 22

--S 23 of 39
leadingTerm pq
--R 
--R
--R   (23)  [k= [b][a],c= 1]
--R  Type: Record(k: PoincareBirkhoffWittLyndonBasis Symbol,c: Fraction Integer)
--E 23

--S 24 of 39
degree pq
--R 
--R
--R   (24)  2
--R                                                        Type: PositiveInteger
--E 24

--S 25 of 39
pq4:=exp(pq,4)
--R 
--R
--R   (25)
--R                          1              1     2       1      2
--R     1 + [a b] + [b][a] + - [a b][a b] + - [a b ][a] + - [b][a b]
--R                          2              2             2
--R   + 
--R     3               1
--R     - [b][a b][a] + - [b][b][a][a]
--R     2               2
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 25

--S 26 of 39
log(pq4,4) - pq
--R 
--R
--R   (26)  0
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 26

--S 27 of 39
lp1 :lpoly := LiePoly liste.10
--R 
--R
--R           3 2
--R   (27)  [a b ]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 27

--S 28 of 39
lp2 :lpoly := LiePoly liste.11
--R 
--R
--R           2
--R   (28)  [a b a b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 28

--S 29 of 39
lp :lpoly := [lp1, lp2]
--R 
--R
--R           3 2 2
--R   (29)  [a b a b a b]
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 29

--S 30 of 39
lpd1: dpoly := lp1
--R 
--R
--R          3 2     2         2 2                    2 2           2    2 3
--R   (30)  a b  - 2a b a b - a b a + 4a b a b a - a b a  - 2b a b a  + b a
--R                        Type: XDistributedPolynomial(Symbol,Fraction Integer)
--E 30

--S 31 of 39
lpd2: dpoly := lp2
--R 
--R
--R   (31)
--R      2         2 2          2                    2 2       3        2
--R     a b a b - a b a - 3a b a b + 4a b a b a - a b a  + 2b a b - 3b a b a
--R   + 
--R            2
--R     b a b a
--R                        Type: XDistributedPolynomial(Symbol,Fraction Integer)
--E 31

--S 32 of 39
lpd : dpoly := lpd1 * lpd2 - lpd2 * lpd1
--R 
--R
--R   (32)
--R      3 2 2         3 2 2 2      3 2     2      3 2             3 2   2 2
--R     a b a b a b - a b a b a - 3a b a b a b + 4a b a b a b a - a b a b a
--R   + 
--R       3 3 3      3 3 2       3 3     2    2       3 2     2       2 2
--R     2a b a b - 3a b a b a + a b a b a  - a b a b a b  + 3a b a b a b a
--R   + 
--R       2           2       2                    2         2 2     2     2 3
--R     6a b a b a b a b - 12a b a b a b a b a + 3a b a b a b a  - 4a b a b a b
--R   + 
--R       2     2 2       2     3 3    2 2 4 2     2 2 3          2 2 2   2
--R     6a b a b a b a - a b a b a  + a b a b  - 3a b a b a b + 3a b a b a b
--R   + 
--R         2 2     3      2 2     2        2 2         2    2 2   2 3
--R     - 2a b a b a b + 3a b a b a b a - 3a b a b a b a  + a b a b a
--R   + 
--R           2   3 2         2   2              2   2 2           2
--R     3a b a b a b  - 6a b a b a b a b - 3a b a b a b a + 12a b a b a b a b a
--R   + 
--R             2     2 2         2 2     2         2 3 3             4 2
--R     - 3a b a b a b a  - 6a b a b a b a  + 3a b a b a  - 4a b a b a b
--R   + 
--R                3                   2   2                  3
--R     12a b a b a b a b - 12a b a b a b a b + 8a b a b a b a b
--R   + 
--R                      2                         2               2 3      2 5 2
--R     - 12a b a b a b a b a + 12a b a b a b a b a  - 4a b a b a b a  + a b a b
--R   + 
--R           2 4            2 3   2        2 2   3        2 2   2
--R     - 3a b a b a b + 3a b a b a b - 2a b a b a b + 3a b a b a b a
--R   + 
--R           2 2       2      2 2 2 3       3   3 2       3   2
--R     - 3a b a b a b a  + a b a b a  - 2b a b a b  + 4b a b a b a b
--R   + 
--R         3   2 2        3                  3     2 2       3 2     2       3 3 3
--R     2b a b a b a - 8b a b a b a b a + 2b a b a b a  + 4b a b a b a  - 2b a b a
--R   + 
--R         2   4 2       2   3            2   3 2         2   2
--R     3b a b a b  - 6b a b a b a b - 3b a b a b a + 12b a b a b a b a
--R   + 
--R           2   2 2 2       2           2       2     2 3          5 2
--R     - 3b a b a b a  - 6b a b a b a b a  + 3b a b a b a  - b a b a b
--R   + 
--R             4 2            3   2             3                  3 2 2
--R     3b a b a b a + 6b a b a b a b - 12b a b a b a b a + 3b a b a b a
--R   + 
--R               2   3            2   2             2 2 3    2 5         2 5 2
--R     - 4b a b a b a b + 6b a b a b a b a - b a b a b a  + b a b a b - b a b a
--R   + 
--R         2 4   2      2 4           2 4 2 2     2 3   3      2 3   2
--R     - 3b a b a b + 4b a b a b a - b a b a  + 2b a b a b - 3b a b a b a
--R   + 
--R      2 3       2
--R     b a b a b a
--R                        Type: XDistributedPolynomial(Symbol,Fraction Integer)
--E 32

--S 33 of 39
lp :: dpoly - lpd
--R 
--R
--R   (33)  0
--R                        Type: XDistributedPolynomial(Symbol,Fraction Integer)
--E 33

--S 34 of 39
p := 3 * lp
--R 
--R
--R            3 2 2
--R   (34)  3[a b a b a b]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 34

--S 35 of 39
q := lp1
--R 
--R
--R           3 2
--R   (35)  [a b ]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 35

--S 36 of 39
pq:= p * q
--R 
--R
--R            3 2 2        3 2
--R   (36)  3[a b a b a b][a b ]
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 36

--S 37 of 39
pr:rpoly := p :: rpoly
--R 
--R
--R   (37)
--R       a
--R    *
--R           a
--R        *
--R               a b b
--R            *
--R                 a(a b(a b 3 + b a(- 3)) + b(a(a b(- 9) + b a 12) + b a a(- 3)))
--R               + 
--R                 b a(a(a b 6 + b a(- 9)) + b a a 3)
--R           + 
--R               b
--R            *
--R                   a b
--R                *
--R                       a
--R                    *
--R                         a(a b b(- 3) + b b a 9)
--R                       + 
--R                         b(a(a b 18 + b a(- 36)) + b a a 9)
--R                   + 
--R                     b(a a(a b(- 12) + b a 18) + b a a a(- 3))
--R               + 
--R                   b a
--R                *
--R                     a(a(a b b 3 + b a b(- 9)) + b a a b 9)
--R                   + 
--R                     b(a(a(a b(- 6) + b a 9) + b a a(- 9)) + b a a a 3)
--R       + 
--R           b
--R        *
--R               a
--R            *
--R                   a b
--R                *
--R                       a
--R                    *
--R                         a(a b b 9 + b(a b(- 18) + b a(- 9)))
--R                       + 
--R                         b(a b a 36 + b a a(- 9))
--R                   + 
--R                     b(a b a a(- 18) + b a a a 9)
--R               + 
--R                   b a
--R                *
--R                     a(a(a b b(- 12) + b a b 36) + b a a b(- 36))
--R                   + 
--R                     b(a(a(a b 24 + b a(- 36)) + b a a 36) + b a a a(- 12))
--R           + 
--R               b a a
--R            *
--R                 a(a(a b b 3 + b a b(- 9)) + b a a b 9)
--R               + 
--R                 b(a(a(a b(- 6) + b a 9) + b a a(- 9)) + b a a a 3)
--R   + 
--R       b
--R    *
--R           a
--R        *
--R               a
--R            *
--R                   a b
--R                *
--R                       a
--R                    *
--R                         a(a b b(- 6) + b(a b 12 + b a 6))
--R                       + 
--R                         b(a b a(- 24) + b a a 6)
--R                   + 
--R                     b(a b a a 12 + b a a a(- 6))
--R               + 
--R                   b a
--R                *
--R                       a
--R                    *
--R                         a(a b b 9 + b(a b(- 18) + b a(- 9)))
--R                       + 
--R                         b(a b a 36 + b a a(- 9))
--R                   + 
--R                     b(a b a a(- 18) + b a a a 9)
--R           + 
--R               b a a
--R            *
--R                 a(a(a b b(- 3) + b b a 9) + b(a(a b 18 + b a(- 36)) + b a a 9))
--R               + 
--R                 b(a a(a b(- 12) + b a 18) + b a a a(- 3))
--R       + 
--R           b a a a
--R        *
--R             a(a b(a b 3 + b a(- 3)) + b(a(a b(- 9) + b a 12) + b a a(- 3)))
--R           + 
--R             b a(a(a b 6 + b a(- 9)) + b a a 3)
--R                          Type: XRecursivePolynomial(Symbol,Fraction Integer)
--E 37

--S 38 of 39
qr:rpoly := q :: rpoly
--R 
--R
--R   (38)
--R     a(a(a b b 1 + b(a b(- 2) + b a(- 1))) + b(a b a 4 + b a a(- 1)))
--R   + 
--R     b(a b a a(- 2) + b a a a 1)
--R                          Type: XRecursivePolynomial(Symbol,Fraction Integer)
--E 38

--S 39 of 39
pq :: rpoly - pr*qr
--R 
--R
--R   (39)  0
--R                          Type: XRecursivePolynomial(Symbol,Fraction Integer)
--E 39
)spool
)lisp (bye)
@
<<XPBWPolynomial.help>>=
====================================================================
XPBWPolynomial examples
====================================================================

Initialisations

  a:Symbol := 'a
    a
                                  Type: Symbol

  b:Symbol := 'b
    b
                                  Type: Symbol

  RN := Fraction(Integer)
    Fraction Integer
                                  Type: Domain

  word := OrderedFreeMonoid Symbol
    OrderedFreeMonoid Symbol
                                  Type: Domain

  lword := LyndonWord(Symbol)
    LyndonWord Symbol
                                  Type: Domain

  base := PoincareBirkhoffWittLyndonBasis Symbol
    PoincareBirkhoffWittLyndonBasis Symbol
                                  Type: Domain

  dpoly := XDistributedPolynomial(Symbol, RN)
    XDistributedPolynomial(Symbol,Fraction Integer)
                                  Type: Domain

  rpoly := XRecursivePolynomial(Symbol, RN)
    XRecursivePolynomial(Symbol,Fraction Integer)
                                  Type: Domain

  lpoly := LiePolynomial(Symbol, RN)
    LiePolynomial(Symbol,Fraction Integer)
                                  Type: Domain

  poly  := XPBWPolynomial(Symbol, RN)
    XPBWPolynomial(Symbol,Fraction Integer)
                                  Type: Domain

  liste : List lword := LyndonWordsList([a,b], 6)
                       2        2     3      2 2       3     4      3 2
   [[a], [b], [a b], [a b], [a b ], [a b], [a b ], [a b ], [a b], [a b ],
      2          2 3           2       4     5      4 2     3          3 3
    [a b a b], [a b ], [a b a b ], [a b ], [a b], [a b ], [a b a b], [a b ],
      2     2     2 2        2 4           3       5
    [a b a b ], [a b a b], [a b ], [a b a b ], [a b ]]
                                  Type: List LyndonWord Symbol

Let's make some polynomials

  0$poly
    0
                           Type: XPBWPolynomial(Symbol,Fraction Integer)

  1$poly
    1
                           Type: XPBWPolynomial(Symbol,Fraction Integer)

  p : poly := a
    [a]
                           Type: XPBWPolynomial(Symbol,Fraction Integer)

  q : poly := b
    [b]
                           Type: XPBWPolynomial(Symbol,Fraction Integer)

  pq: poly := p*q
    [a b] + [b][a]
                           Type: XPBWPolynomial(Symbol,Fraction Integer)

Coerce to distributed polynomial

  pq :: dpoly
    a b
                      Type: XDistributedPolynomial(Symbol,Fraction Integer)

Check some polynomial operations

  mirror pq
    [b][a]
                      Type: XPBWPolynomial(Symbol,Fraction Integer)

  ListOfTerms pq
    [[k= [b][a],c= 1],[k= [a b],c= 1]]
      Type: List Record(k: PoincareBirkhoffWittLyndonBasis Symbol,
                        c: Fraction Integer)

  reductum pq
    [a b]
                      Type: XPBWPolynomial(Symbol,Fraction Integer)

  leadingMonomial pq
    [b][a]
                      Type: PoincareBirkhoffWittLyndonBasis Symbol

  coefficients pq
    [1,1]
                      Type: List Fraction Integer

  leadingTerm pq
    [k= [b][a],c= 1]
              Type: Record(k: PoincareBirkhoffWittLyndonBasis Symbol,
                           c: Fraction Integer)

  degree pq
    2
                      Type: PositiveInteger

  pq4:=exp(pq,4)
                          1              1     2       1      2
     1 + [a b] + [b][a] + - [a b][a b] + - [a b ][a] + - [b][a b]
                          2              2             2
   + 
     3               1
     - [b][a b][a] + - [b][b][a][a]
     2               2
                      Type: XPBWPolynomial(Symbol,Fraction Integer)

  log(pq4,4) - pq
   (26)  0
                      Type: XPBWPolynomial(Symbol,Fraction Integer)

Calculations with verification in XDistributedPolynomial.

  lp1 :lpoly := LiePoly liste.10
       3 2
     [a b ]
                      Type: LiePolynomial(Symbol,Fraction Integer)

  lp2 :lpoly := LiePoly liste.11
      2
    [a b a b]
                      Type: LiePolynomial(Symbol,Fraction Integer)

  lp :lpoly := [lp1, lp2]
      3 2 2
    [a b a b a b]
                      Type: LiePolynomial(Symbol,Fraction Integer)

  lpd1: dpoly := lp1
     3 2     2         2 2                    2 2           2    2 3
    a b  - 2a b a b - a b a + 4a b a b a - a b a  - 2b a b a  + b a
                      Type: XDistributedPolynomial(Symbol,Fraction Integer)

  lpd2: dpoly := lp2
      2         2 2          2                    2 2       3        2
     a b a b - a b a - 3a b a b + 4a b a b a - a b a  + 2b a b - 3b a b a
   + 
            2
     b a b a
                      Type: XDistributedPolynomial(Symbol,Fraction Integer)

  lpd : dpoly := lpd1 * lpd2 - lpd2 * lpd1
      3 2 2         3 2 2 2      3 2     2      3 2             3 2   2 2
     a b a b a b - a b a b a - 3a b a b a b + 4a b a b a b a - a b a b a
   + 
       3 3 3      3 3 2       3 3     2    2       3 2     2       2 2
     2a b a b - 3a b a b a + a b a b a  - a b a b a b  + 3a b a b a b a
   + 
       2           2       2                    2         2 2     2     2 3
     6a b a b a b a b - 12a b a b a b a b a + 3a b a b a b a  - 4a b a b a b
   + 
       2     2 2       2     3 3    2 2 4 2     2 2 3          2 2 2   2
     6a b a b a b a - a b a b a  + a b a b  - 3a b a b a b + 3a b a b a b
   + 
         2 2     3      2 2     2        2 2         2    2 2   2 3
     - 2a b a b a b + 3a b a b a b a - 3a b a b a b a  + a b a b a
   + 
           2   3 2         2   2              2   2 2           2
     3a b a b a b  - 6a b a b a b a b - 3a b a b a b a + 12a b a b a b a b a
   + 
             2     2 2         2 2     2         2 3 3             4 2
     - 3a b a b a b a  - 6a b a b a b a  + 3a b a b a  - 4a b a b a b
   + 
                3                   2   2                  3
     12a b a b a b a b - 12a b a b a b a b + 8a b a b a b a b
   + 
                      2                         2               2 3      2 5 2
     - 12a b a b a b a b a + 12a b a b a b a b a  - 4a b a b a b a  + a b a b
   + 
           2 4            2 3   2        2 2   3        2 2   2
     - 3a b a b a b + 3a b a b a b - 2a b a b a b + 3a b a b a b a
   + 
           2 2       2      2 2 2 3       3   3 2       3   2
     - 3a b a b a b a  + a b a b a  - 2b a b a b  + 4b a b a b a b
   + 
         3   2 2        3                  3     2 2       3 2     2       3 3 3
     2b a b a b a - 8b a b a b a b a + 2b a b a b a  + 4b a b a b a  - 2b a b a
   + 
         2   4 2       2   3            2   3 2         2   2
     3b a b a b  - 6b a b a b a b - 3b a b a b a + 12b a b a b a b a
   + 
           2   2 2 2       2           2       2     2 3          5 2
     - 3b a b a b a  - 6b a b a b a b a  + 3b a b a b a  - b a b a b
   + 
             4 2            3   2             3                  3 2 2
     3b a b a b a + 6b a b a b a b - 12b a b a b a b a + 3b a b a b a
   + 
               2   3            2   2             2 2 3    2 5         2 5 2
     - 4b a b a b a b + 6b a b a b a b a - b a b a b a  + b a b a b - b a b a
   + 
         2 4   2      2 4           2 4 2 2     2 3   3      2 3   2
     - 3b a b a b + 4b a b a b a - b a b a  + 2b a b a b - 3b a b a b a
   + 
      2 3       2
     b a b a b a
                    Type: XDistributedPolynomial(Symbol,Fraction Integer)

  lp :: dpoly - lpd
    0
                    Type: XDistributedPolynomial(Symbol,Fraction Integer)

Calculations with verification in XRecursivePolynomial.

  p := 3 * lp
       3 2 2
    3[a b a b a b]
                    Type: XPBWPolynomial(Symbol,Fraction Integer)

  q := lp1
      3 2
    [a b ]
                    Type: XPBWPolynomial(Symbol,Fraction Integer)

  pq:= p * q
       3 2 2        3 2
    3[a b a b a b][a b ]
                    Type: XPBWPolynomial(Symbol,Fraction Integer)

  pr:rpoly := p :: rpoly
       a
    *
           a
        *
               a b b
            *
                a(a b(a b 3 + b a(- 3)) + b(a(a b(- 9) + b a 12) + b a a(- 3)))
               + 
                 b a(a(a b 6 + b a(- 9)) + b a a 3)
           + 
               b
            *
                   a b
                *
                       a
                    *
                         a(a b b(- 3) + b b a 9)
                       + 
                         b(a(a b 18 + b a(- 36)) + b a a 9)
                   + 
                     b(a a(a b(- 12) + b a 18) + b a a a(- 3))
               + 
                   b a
                *
                     a(a(a b b 3 + b a b(- 9)) + b a a b 9)
                   + 
                     b(a(a(a b(- 6) + b a 9) + b a a(- 9)) + b a a a 3)
       + 
           b
        *
               a
            *
                   a b
                *
                       a
                    *
                         a(a b b 9 + b(a b(- 18) + b a(- 9)))
                       + 
                         b(a b a 36 + b a a(- 9))
                   + 
                     b(a b a a(- 18) + b a a a 9)
               + 
                   b a
                *
                     a(a(a b b(- 12) + b a b 36) + b a a b(- 36))
                   + 
                     b(a(a(a b 24 + b a(- 36)) + b a a 36) + b a a a(- 12))
           + 
               b a a
            *
                 a(a(a b b 3 + b a b(- 9)) + b a a b 9)
               + 
                 b(a(a(a b(- 6) + b a 9) + b a a(- 9)) + b a a a 3)
   + 
       b
    *
           a
        *
               a
            *
                   a b
                *
                       a
                    *
                         a(a b b(- 6) + b(a b 12 + b a 6))
                       + 
                         b(a b a(- 24) + b a a 6)
                   + 
                     b(a b a a 12 + b a a a(- 6))
               + 
                   b a
                *
                       a
                    *
                         a(a b b 9 + b(a b(- 18) + b a(- 9)))
                       + 
                         b(a b a 36 + b a a(- 9))
                   + 
                     b(a b a a(- 18) + b a a a 9)
           + 
               b a a
            *
                a(a(a b b(- 3) + b b a 9) + b(a(a b 18 + b a(- 36)) + b a a 9))
               + 
                 b(a a(a b(- 12) + b a 18) + b a a a(- 3))
       + 
           b a a a
        *
             a(a b(a b 3 + b a(- 3)) + b(a(a b(- 9) + b a 12) + b a a(- 3)))
           + 
             b a(a(a b 6 + b a(- 9)) + b a a 3)
                      Type: XRecursivePolynomial(Symbol,Fraction Integer)

  qr:rpoly := q :: rpoly
     a(a(a b b 1 + b(a b(- 2) + b a(- 1))) + b(a b a 4 + b a a(- 1)))
   + 
     b(a b a a(- 2) + b a a a 1)
                      Type: XRecursivePolynomial(Symbol,Fraction Integer)

  pq :: rpoly - pr*qr
    0
                      Type: XRecursivePolynomial(Symbol,Fraction Integer)

See Also:
o )show XPBWPolynomial
o $AXIOM/doc/src/algebra/xlpoly.spad.dvi

@
<<domain XPBWPOLY XPBWPolynomial>>=
)abbrev domain XPBWPOLY XPBWPolynomial
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This domain constructor implements polynomials in non-commutative
++ variables written in the Poincare-Birkhoff-Witt basis from the
++ Lyndon basis.
++ These polynomials can be used to compute Baker-Campbell-Hausdorff
++ relations. \newline Author: Michel Petitot (petitot@lifl.fr).

XPBWPolynomial(VarSet:OrderedSet,R:CommutativeRing): XDPcat == XDPdef where

  WORD   ==> OrderedFreeMonoid(VarSet)
  LWORD  ==> LyndonWord(VarSet)
  LWORDS ==> List LWORD
  BASIS  ==> PoincareBirkhoffWittLyndonBasis(VarSet)
  TERM   ==> Record(k:BASIS, c:R)
  LTERMS ==> List(TERM)
  LPOLY  ==> LiePolynomial(VarSet,R)  
  EX     ==> OutputForm
  XDPOLY ==> XDistributedPolynomial(VarSet,R)
  XRPOLY ==> XRecursivePolynomial(VarSet,R)
  TERM1  ==> Record(k:LWORD, c:R)
  NNI    ==> NonNegativeInteger
  I      ==> Integer
  RN     ==> Fraction(Integer)

  XDPcat == Join(XPolynomialsCat(VarSet,R), FreeModuleCat(R, BASIS)) with
    coerce      : LPOLY -> $
      ++ \axiom{coerce(p)} returns \axiom{p}. 
    coerce      : $ -> XDPOLY
      ++ \axiom{coerce(p)} returns \axiom{p} as a distributed polynomial. 
    coerce      : $ -> XRPOLY
      ++ \axiom{coerce(p)} returns \axiom{p} as a recursive polynomial.
    LiePolyIfCan: $ -> Union(LPOLY,"failed")
      ++ \axiom{LiePolyIfCan(p)} return  \axiom{p} if \axiom{p} is a Lie polynomial.
    product     : ($,$,NNI) -> $           -- produit tronque a l'ordre n
      ++ \axiom{product(a,b,n)} returns \axiom{a*b} (truncated up to order \axiom{n}).

    if R has Module(RN) then
       exp      : ($,NNI) -> $
          ++ \axiom{exp(p,n)} returns the exponential of \axiom{p} 
          ++ (truncated up to order \axiom{n}).
       log      : ($,NNI) -> $
          ++ \axiom{log(p,n)} returns the logarithm of \axiom{p}
          ++ (truncated up to order \axiom{n}).

  XDPdef == FreeModule1(R,BASIS) add
       import(TERM)

    -- Representation
       Rep:= LTERMS 

    -- local functions
       prod1: (BASIS, $) -> $
       prod2: ($, BASIS) -> $
       prod : (BASIS, BASIS) -> $

       prod11: (BASIS, $, NNI) -> $
       prod22: ($, BASIS, NNI) -> $

       outForm : TERM -> EX
       Dexpand : BASIS -> XDPOLY
       Rexpand : BASIS -> XRPOLY
       process : (List LWORD, LWORD, List LWORD) -> $
       mirror1 : BASIS -> $

    -- functions locales
       outForm t ==
           t.c =$R 1 => t.k :: EX
           t.k =$BASIS 1 => t.c :: EX
           t.c::EX * t.k ::EX

       prod1(b:BASIS, p:$):$ ==
         +/ [t.c * prod(b, t.k) for t in p]

       prod2(p:$, b:BASIS):$ ==
         +/ [t.c * prod(t.k, b) for t in p]
 
       prod11(b,p,n) ==
           limit: I := n -$I length b
           +/ [t.c * prod(b, t.k) for t in p| length(t.k) :: I <= limit]

       prod22(p,b,n) ==
           limit: I := n -$I length b
           +/ [t.c * prod(t.k, b) for t in p| length(t.k) :: I <= limit]

       prod(g,d) ==
         d = 1 => monom(g,1)
         g = 1 => monom(d,1)
         process(reverse ListOfTerms g, first d, rest ListOfTerms d)

       Dexpand b == 
         b = 1 => 1$XDPOLY
         */ [LiePoly(l)$LPOLY :: XDPOLY for l in ListOfTerms b]

       Rexpand b ==
         b = 1 => 1$XRPOLY
         */ [LiePoly(l)$LPOLY :: XRPOLY for l in ListOfTerms b]

       mirror1(b:BASIS):$ ==
         b = 1 => 1
         lp: LPOLY := LiePoly first b
         lp := mirror lp
         mirror1(rest b) * lp :: $

       process(gauche, x, droite) ==    -- algo du "collect process"
         null gauche => monom( cons(x, droite) pretend BASIS, 1$R)
         r1, r2 : $
         not lexico(first gauche, x) =>     -- cas facile !!!
           monom(append(reverse gauche, cons(x, droite)) pretend BASIS , 1$R)

         p: LPOLY := [first gauche , x]      -- on crochete !!!
         null droite =>
           r1 :=  +/ [t.c * process(rest gauche, t.k, droite) for t in _
                      ListOfTerms p]
           r2 :=  process( rest gauche, x, list first gauche)
           r1 + r2 
         rd: List LWORD := rest droite; fd: LWORD := first droite
         r1 := +/ [t.c * process(list t.k, fd, rd) for t in  ListOfTerms p] 
         r1 := +/ [t.c * process(rest gauche, first t.k, rest ListOfTerms(t.k))_
                  for t in  r1] 
         r2 := process([first gauche, x], fd, rd)
         r2 := +/ [t.c * process(rest gauche, first t.k, rest ListOfTerms(t.k))_
                  for t in  r2]
         r1 + r2

    -- definitions
       1 == monom(1$BASIS, 1$R)

       coerce(r:R):$ == [[1$BASIS , r]$TERM ]

       coerce(p:$):EX ==
         null p => (0$R) :: EX
         le : List EX := nil
         for rec in p repeat le := cons(outForm rec, le)
         reduce(_+, le)$List(EX)

       coerce(v: VarSet):$ == monom(v::BASIS , 1$R)
       coerce(p: LPOLY):$ ==
          [[t.k :: BASIS , t.c ]$TERM for t in ListOfTerms p]

       coerce(p:$):XDPOLY ==
         +/ [t.c * Dexpand t.k for t in p]

       coerce(p:$):XRPOLY ==
         p = 0 => 0$XRPOLY
         +/ [t.c * Rexpand t.k for t in p]

       constant? p == (null p) or (leadingMonomial(p) =$BASIS 1)
       constant p == 
         null p => 0$R
         p.last.k = 1$BASIS => p.last.c
         0$R

       quasiRegular? p == (p=0) or (p.last.k ^= 1$BASIS)
       quasiRegular p == 
         p = 0 => p
         p.last.k = 1$BASIS => delete(p, maxIndex p)
         p
    
       x:$ * y:$ ==
         y = 0$$ => 0
         +/ [t.c * prod1(t.k, y) for t in x]

--       ListOfTerms p == p pretend LTERMS

       varList p == 
          lv: List VarSet := "setUnion"/ [varList(b.k)$BASIS for b in p]
          sort(lv)

       degree(p) ==
          p=0 => error "null polynomial"
          length(leadingMonomial p)

       trunc(p, n) ==
         p = 0 => p
         degree(p) > n => trunc( reductum p , n)
         p

       product(x,y,n) ==
         x = 0 => 0
         y = 0 => 0
         +/ [t.c * prod11(t.k, y, n) for t in x]

       if R has Module(RN) then
         exp (p,n) ==
             p = 0 => 1
             not quasiRegular? p => 
               error "a proper polynomial is required"
             s : $ := 1 ; r: $ := 1                  -- resultat
             for i in 1..n repeat
                k1 :RN := 1/i
                k2 : R := k1 * 1$R
                s := k2 * product(p, s, n)
                r := r + s
             r
  
         log (p,n) ==
             p = 1 => 0
             p1: $ := 1 - p
             not quasiRegular? p1 => 
               error "constant term <> 1, impossible log "
             s : $ := - 1 ; r: $ := 0                 -- resultat
             for i in 1..n repeat
               k1 :RN := 1/i
               k2 : R := k1 * 1$R
               s := product(p1, s, n)
               r := k2 * s + r
             r
 
       LiePolyIfCan p ==
         p = 0 => 0$LPOLY
         "and"/ [retractable?(t.k)$BASIS for t in p] =>
            lt : List TERM1 := _
                 [[retract(t.k)$BASIS, t.c]$TERM1 for t in p]
            lt pretend LPOLY
         "failed"

       mirror p ==
         +/ [t.c * mirror1(t.k) for t in p]

@
\section{domain LEXP LieExponentials}
<<LieExponentials.input>>=
-- xlpoly.spad.pamphlet LieExponentials.input
)spool LieExponentials.output
)set message test on
)set message auto off
)clear all
--S 1 of 13
a: Symbol := 'a
--R 
--R
--R   (1)  a
--R                                                                 Type: Symbol
--E 1

--S 2 of 13
b: Symbol := 'b
--R 
--R
--R   (2)  b
--R                                                                 Type: Symbol
--E 2

--S 3 of 13
coef := Fraction(Integer) 
--R 
--R
--R   (3)  Fraction Integer
--R                                                                 Type: Domain
--E 3

--S 4 of 13
group := LieExponentials(Symbol, coef, 3)
--R 
--R
--R   (4)  LieExponentials(Symbol,Fraction Integer,3)
--R                                                                 Type: Domain
--E 4

--S 5 of 13
lpoly := LiePolynomial(Symbol, coef)
--R 
--R
--R   (5)  LiePolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 5

--S 6 of 13
poly := XPBWPolynomial(Symbol, coef)
--R 
--R
--R   (6)  XPBWPolynomial(Symbol,Fraction Integer)
--R                                                                 Type: Domain
--E 6

--S 7 of 13
ea := exp(a::lpoly)$group
--R 
--R
--R         [a]
--R   (7)  e
--R                             Type: LieExponentials(Symbol,Fraction Integer,3)
--E 7

--S 8 of 13
eb := exp(b::lpoly)$group
--R 
--R
--R         [b]
--R   (8)  e
--R                             Type: LieExponentials(Symbol,Fraction Integer,3)
--E 8

--S 9 of 13
g: group := ea*eb
--R 
--R
--R             1     2        1   2
--R             - [a b ]       - [a b]
--R         [b] 2        [a b] 2       [a]
--R   (9)  e   e        e     e       e
--R                             Type: LieExponentials(Symbol,Fraction Integer,3)
--E 9

--S 10 of 13
g :: poly
--R 
--R
--R   (10)
--R                     1                           1          1
--R     1 + [a] + [b] + - [a][a] + [a b] + [b][a] + - [b][b] + - [a][a][a]
--R                     2                           2          6
--R   + 
--R     1   2                1     2    1                        1
--R     - [a b] + [a b][a] + - [a b ] + - [b][a][a] + [b][a b] + - [b][b][a]
--R     2                    2          2                        2
--R   + 
--R     1
--R     - [b][b][b]
--R     6
--R                                Type: XPBWPolynomial(Symbol,Fraction Integer)
--E 10

--S 11 of 13
log(g)$group
--R 
--R
--R                     1          1   2      1     2
--R   (11)  [a] + [b] + - [a b] + -- [a b] + -- [a b ]
--R                     2         12         12
--R                                 Type: LiePolynomial(Symbol,Fraction Integer)
--E 11

--S 12 of 13
g1: group := inv(g)
--R 
--R
--R          - [b] - [a]
--R   (12)  e     e
--R                             Type: LieExponentials(Symbol,Fraction Integer,3)
--E 12

--S 13 of 13
g*g1
--R 
--R
--R   (13)  1
--R                             Type: LieExponentials(Symbol,Fraction Integer,3)
--E 13
)spool
)lisp (bye)
@
<<LieExponentials.help>>=
====================================================================
LieExponentials examples
====================================================================

  a: Symbol := 'a
    a
                         Type: Symbol

  b: Symbol := 'b
    b
                         Type: Symbol

====================================================================
Declarations of domains
====================================================================

  coef := Fraction(Integer) 
    Fraction Integer
                         Type: Domain

  group := LieExponentials(Symbol, coef, 3)
    LieExponentials(Symbol,Fraction Integer,3)
                         Type: Domain

  lpoly := LiePolynomial(Symbol, coef)
    LiePolynomial(Symbol,Fraction Integer)
                         Type: Domain

  poly := XPBWPolynomial(Symbol, coef)
    XPBWPolynomial(Symbol,Fraction Integer)
                         Type: Domain

====================================================================
Calculations
====================================================================

  ea := exp(a::lpoly)$group
     [a]
    e
                         Type: LieExponentials(Symbol,Fraction Integer,3)

  eb := exp(b::lpoly)$group
     [b]
    e
                         Type: LieExponentials(Symbol,Fraction Integer,3)

  g: group := ea*eb
         1     2        1   2
         - [a b ]       - [a b]
     [b] 2        [a b] 2       [a]
    e   e        e     e       e
                         Type: LieExponentials(Symbol,Fraction Integer,3)

  g :: poly
                     1                           1          1
     1 + [a] + [b] + - [a][a] + [a b] + [b][a] + - [b][b] + - [a][a][a]
                     2                           2          6
   + 
     1   2                1     2    1                        1
     - [a b] + [a b][a] + - [a b ] + - [b][a][a] + [b][a b] + - [b][b][a]
     2                    2          2                        2
   + 
     1
     - [b][b][b]
     6
                        Type: XPBWPolynomial(Symbol,Fraction Integer)

  log(g)$group
                1          1   2      1     2
    [a] + [b] + - [a b] + -- [a b] + -- [a b ]
                2         12         12
                        Type: LiePolynomial(Symbol,Fraction Integer)

  g1: group := inv(g)
     - [b] - [a]
    e     e
                        Type: LieExponentials(Symbol,Fraction Integer,3)

  g*g1
    1
                        Type: LieExponentials(Symbol,Fraction Integer,3)

See Also:
o )show LieExponentials
o $AXIOM/doc/src/algebra/xlpoly.spad.dvi

@
<<domain LEXP LieExponentials>>=
)abbrev domain LEXP LieExponentials
++ Author: Michel Petitot (petitot@lifl.fr).
++ Date Created: 91
++ Date Last Updated: 7 Juillet 92
++ Fix History: compilation v 2.1 le 13 dec 98
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Management of the Lie Group associated with a
++ free nilpotent Lie algebra. Every Lie bracket with 
++ length greater than \axiom{Order} are
++ assumed to be null.
++ The implementation inherits from the \spadtype{XPBWPolynomial}
++ domain constructor: Lyndon
++ coordinates are exponential coordinates 
++ of the second kind. \newline Author: Michel Petitot (petitot@lifl.fr).

LieExponentials(VarSet, R, Order): XDPcat == XDPdef where

  EX     ==> OutputForm
  PI     ==> PositiveInteger
  NNI    ==> NonNegativeInteger
  I      ==> Integer
  RN     ==> Fraction(I)
  R      : Join(CommutativeRing, Module RN)
  Order  : PI 
  VarSet : OrderedSet
  LWORD  ==> LyndonWord(VarSet)
  LWORDS ==> List LWORD
  BASIS  ==> PoincareBirkhoffWittLyndonBasis(VarSet)
  TERM   ==> Record(k:BASIS, c:R)
  LTERMS ==> List(TERM)
  LPOLY  ==> LiePolynomial(VarSet,R)  
  XDPOLY ==> XDistributedPolynomial(VarSet,R)
  PBWPOLY==> XPBWPolynomial(VarSet, R)
  TERM1  ==> Record(k:LWORD, c:R)
  EQ     ==> Equation(R)

  XDPcat == Group with
    exp         : LPOLY -> $
      ++ \axiom{exp(p)} returns the exponential of \axiom{p}.
    log         : $ -> LPOLY
      ++ \axiom{log(p)} returns the logarithm of \axiom{p}.
    ListOfTerms : $ -> LTERMS
      ++ \axiom{ListOfTerms(p)} returns the internal representation of \axiom{p}.
    coerce      : $ -> XDPOLY
      ++ \axiom{coerce(g)} returns the internal representation of \axiom{g}.
    coerce      : $ -> PBWPOLY
      ++ \axiom{coerce(g)} returns the internal representation of \axiom{g}.
    mirror      : $ -> $
      ++ \axiom{mirror(g)} is the mirror of the internal representation of \axiom{g}.
    varList     : $ -> List VarSet
      ++ \axiom{varList(g)} returns the list of variables of \axiom{g}. 
    LyndonBasis : List VarSet -> List LPOLY
      ++ \axiom{LyndonBasis(lv)} returns the Lyndon basis of the nilpotent free
      ++ Lie algebra.
    LyndonCoordinates: $ -> List TERM1
      ++ \axiom{LyndonCoordinates(g)} returns the exponential coordinates of \axiom{g}.
    identification: ($,$) -> List EQ
      ++ \axiom{identification(g,h)} returns the list of equations \axiom{g_i = h_i},
      ++ where \axiom{g_i} (resp. \axiom{h_i}) are exponential coordinates 
      ++ of \axiom{g} (resp. \axiom{h}). 

  XDPdef == PBWPOLY add

    -- Representation
       Rep := PBWPOLY 

    -- local functions
       compareTerm1s: (TERM1, TERM1) -> Boolean
       out: TERM1 -> EX
       ident: (List TERM1, List TERM1) -> List EQ

    -- functions locales
       ident(l1, l2) ==
         import(TERM1)
         null l1 => [equation(0$R,t.c)$EQ for t in l2]
         null l2 => [equation(t.c, 0$R)$EQ for t in l1]        
         u1 : LWORD := l1.first.k; c1 :R := l1.first.c
         u2 : LWORD := l2.first.k; c2 :R := l2.first.c
         u1 = u2 =>
            r: R := c1 - c2
            r = 0 => ident(rest l1, rest l2) 
            cons(equation(c1,c2)$EQ , ident(rest l1, rest l2))
         lexico(u1, u2)$LWORD =>
            cons(equation(0$R,c2)$EQ , ident(l1, rest l2))
         cons(equation(c1,0$R)$EQ , ident(rest l1, l2))

       -- ordre lexico decroissant
       compareTerm1s(u:TERM1, v:TERM1):Boolean == lexico(v.k, u.k)$LWORD

       out(t:TERM1):EX ==
         t.c =$R 1 => char("e")$Character :: EX ** t.k ::EX
         char("e")$Character :: EX ** (t.c::EX * t.k::EX)
 
    -- definitions
       identification(x,y) ==
          l1: List TERM1 := LyndonCoordinates x
          l2: List TERM1 := LyndonCoordinates y
          ident(l1, l2)
 
       LyndonCoordinates x ==
         lt: List TERM1 := [[l::LWORD, t.c]$TERM1 for t in ListOfTerms x | _
                             (l := retractIfCan(t.k)$BASIS) case LWORD ] 
         lt := sort(compareTerm1s,lt)

       x:$ * y:$ == product(x::Rep, y::Rep, Order::I::NNI)$Rep

       exp p == exp(p::Rep , Order::I::NNI)$Rep

       log p == LiePolyIfCan(log(p,Order::I::NNI))$Rep :: LPOLY

       coerce(p:$):EX ==
          p = 1$$ => 1$R :: EX
          lt : List TERM1 := LyndonCoordinates p 
          reduce(_*, [out t for t in lt])$List(EX)


       LyndonBasis(lv) == 
         [LiePoly(l)$LPOLY for l in LyndonWordsList(lv,Order)$LWORD]

       coerce(p:$):PBWPOLY == p::Rep

       inv x ==
         x = 1 => 1
         lt:LTERMS := ListOfTerms mirror x
         lt:= [[t.k, (odd? length(t.k)$BASIS => - t.c; t.c)]$TERM for t in lt ]
         lt pretend $

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain MAGMA Magma>>
<<domain LWORD LyndonWord>>
<<package XEXPPKG XExponentialPackage>>
<<domain LPOLY LiePolynomial>>
<<domain PBWLB PoincareBirkhoffWittLyndonBasis>>
<<domain XPBWPOLY XPBWPolynomial>>
<<domain LEXP LieExponentials>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} 
{\bf http://www.mathe2.uni-bayreuth.de/frib/html/canonsgif/canons.html}
\end{thebibliography}
\end{document}
