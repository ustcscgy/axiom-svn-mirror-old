\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra radix.spad}
\author{Stephen M. Watt, Clifton J. Williamson}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain RADIX RadixExpansion}
<<domain RADIX RadixExpansion>>=
)abbrev domain RADIX RadixExpansion
++ Author: Stephen M. Watt
++ Date Created: October 1986
++ Date Last Updated: May 15, 1991
++ Basic Operations: wholeRadix, fractRadix, wholeRagits, fractRagits
++ Related Domains: BinaryExpansion, DecimalExpansion, HexadecimalExpansion,
++    RadixUtilities
++ Also See:
++ AMS Classifications:
++ Keywords: radix, base, repeating decimal
++ Examples:
++ References:
++ Description:
++   This domain allows rational numbers to be presented as repeating
++   decimal expansions or more generally as repeating expansions in any base.

RadixExpansion(bb): Exports == Implementation where
  bb   :  Integer
  I   ==> Integer
  NNI ==> NonNegativeInteger
  OUT ==> OutputForm
  RN  ==> Fraction Integer
  ST  ==> Stream Integer
  QuoRem ==> Record(quotient: Integer, remainder: Integer)

  Exports ==> QuotientFieldCategory(Integer) with
    coerce: % -> Fraction Integer
      ++ coerce(rx) converts a radix expansion to a rational number.
    fractionPart: % -> Fraction Integer
      ++ fractionPart(rx) returns the fractional part of a radix expansion.
    wholeRagits: % -> List Integer
      ++ wholeRagits(rx) returns the ragits of the integer part
      ++ of a radix expansion.
    fractRagits: % -> Stream Integer
      ++ fractRagits(rx) returns the ragits of the fractional part
      ++ of a radix expansion.
    prefixRagits: % -> List Integer
      ++ prefixRagits(rx) returns the non-cyclic part of the ragits
      ++ of the fractional part of a radix expansion.
      ++ For example, if \spad{x = 3/28 = 0.10 714285 714285 ...},
      ++ then \spad{prefixRagits(x)=[1,0]}.
    cycleRagits: % -> List Integer
      ++ cycleRagits(rx) returns the cyclic part of the ragits of the
      ++ fractional part of a radix expansion.
      ++ For example, if \spad{x = 3/28 = 0.10 714285 714285 ...},
      ++ then \spad{cycleRagits(x) = [7,1,4,2,8,5]}.
    wholeRadix: List Integer -> %
      ++ wholeRadix(l) creates an integral radix expansion from a list
      ++ of ragits.
      ++ For example, \spad{wholeRadix([1,3,4])} will return \spad{134}.
    fractRadix: (List Integer, List Integer) -> %
      ++ fractRadix(pre,cyc) creates a fractional radix expansion
      ++ from a list of prefix ragits and a list of cyclic ragits.
      ++ For example, \spad{fractRadix([1],[6])} will return \spad{0.16666666...}.

  Implementation ==> add
    -- The efficiency of arithmetic operations is poor.
    -- Could use a lazy eval where either rational rep
    -- or list of ragit rep (the current) or both are kept
    -- as demanded.

    bb < 2 => error "Radix base must be at least 2"
    Rep := Record(sgn: Integer,      int: List Integer,
                  pfx: List Integer, cyc: List Integer)

    q:     RN
    qr:    QuoRem
    a,b:   %
    n:     I

    radixInt:    (I, I)    -> List I
    radixFrac:   (I, I, I) -> Record(pfx: List I, cyc: List I)
    checkRagits: List I    -> Boolean

    -- Arithmetic operations
    characteristic() == 0
    differentiate a == 0

    0     == [1, nil(),  nil(), nil()]
    1     == [1, [1], nil(), nil()]
    - a   == (a = 0 => 0; [-a.sgn, a.int, a.pfx, a.cyc])
    a + b == (a::RN + b::RN)::%
    a - b == (a::RN - b::RN)@RN::%
    n * a == (n     * a::RN)::%
    a * b == (a::RN * b::RN)::%
    a / b == (a::RN / b::RN)::%
    (i:I) / (j:I) == (i/j)@RN :: %
    a < b == a::RN < b::RN
    a = b == a.sgn = b.sgn and a.int = b.int and
             a.pfx = b.pfx and a.cyc = b.cyc
    numer a == numer(a::RN)
    denom a == denom(a::RN)

    -- Algebraic coercions
    coerce(a):RN == (wholePart a) :: RN + fractionPart a
    coerce(n):%  == n :: RN :: %
    coerce(q):%  ==
      s := 1; if q < 0 then (s := -1; q := -q)
      qr      := divide(numer q,denom q)
      whole   := radixInt (qr.quotient,bb)
      fractn  := radixFrac(qr.remainder,denom q,bb)
      cycle   := (fractn.cyc = [0] => nil(); fractn.cyc)
      [s,whole,fractn.pfx,cycle]

    retractIfCan(a):Union(RN,"failed") == a::RN
    retractIfCan(a):Union(I,"failed") ==
      empty?(a.pfx) and empty?(a.cyc) => wholePart a
      "failed"

    -- Exported constructor/destructors
    ceiling a == ceiling(a::RN)
    floor a == floor(a::RN)

    wholePart a ==
      n0 := 0
      for r in a.int repeat n0 := bb*n0 + r
      a.sgn*n0
    fractionPart a ==
      n0 := 0
      for r in a.pfx repeat n0 := bb*n0 + r
      null a.cyc =>
          a.sgn*n0/bb**((#a.pfx)::NNI)
      n1 := n0
      for r in a.cyc repeat n1 := bb*n1 + r
      n := n1 - n0
      d := (bb**((#a.cyc)::NNI) - 1) * bb**((#a.pfx)::NNI)
      a.sgn*n/d

    wholeRagits  a == a.int
    fractRagits  a == concat(construct(a.pfx)@ST,repeating a.cyc)
    prefixRagits a == a.pfx
    cycleRagits  a == a.cyc

    wholeRadix li ==
      checkRagits li
      [1, li, nil(), nil()]
    fractRadix(lpfx, lcyc) ==
      checkRagits lpfx; checkRagits lcyc
      [1, nil(), lpfx, lcyc]

    -- Output

    ALPHAS : String := "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    intToExpr(i:I): OUT ==
      -- computes a digit for bases between 11 and 36
      i < 10 => i :: OUT
      elt(ALPHAS,(i-10) + minIndex(ALPHAS)) :: OUT

    exprgroup(le: List OUT): OUT ==
      empty? le      => error "exprgroup needs non-null list"
      empty? rest le => first le
      abs bb <= 36 => hconcat le
      blankSeparate le

    intgroup(li: List I): OUT ==
      empty? li      => error "intgroup needs non-null list"
      empty? rest li => intToExpr first(li)
      abs bb <= 10 => hconcat [i :: OUT for i in li]
      abs bb <= 36 => hconcat [intToExpr(i) for i in li]
      blankSeparate [i :: OUT for i in li]

    overBar(li: List I): OUT == overbar intgroup li

    coerce(a): OUT ==
      le : List OUT := nil()
      if not null a.cyc then le := concat(overBar  a.cyc,le)
      if not null a.pfx then le := concat(intgroup a.pfx,le)
      if not null le    then le := concat("." :: OUT,le)
      if not null a.int then le := concat(intgroup a.int,le)
      else le := concat(0 :: OUT,le)
      rex := exprgroup le
      if a.sgn < 0 then -rex else rex

    -- Construction utilities
    checkRagits li ==
      for i in li repeat if i < 0 or i >= bb then
        error "Each ragit (digit) must be between 0 and base-1"
      true

    radixInt(n,bas) ==
      rits: List I := nil()
      while abs n ^= 0 repeat
        qr   := divide(n,bas)
        n    := qr.quotient
        rits := concat(qr.remainder,rits)
      rits

    radixFrac(num,den,bas) ==
      -- Rits is the sequence of quotient/remainder pairs
      -- in calculating the radix expansion of the rational number.
      -- We wish to find p and c such that
      --    rits.i are distinct    for 0<=i<=p+c-1
      --    rits.i = rits.(i+p)    for i>p
      -- I.e. p is the length of the non-periodic prefix and c is
      -- the length of the cycle.

      -- Compute p and c using Floyd's algorithm.
      -- 1. Find smallest n s.t. rits.n = rits.(2*n)
      qr    := divide(bas * num, den)
      i : I := 0
      qr1i  := qr2i := qr
      rits: List QuoRem := [qr]
      until qr1i = qr2i repeat
        qr1i := divide(bas * qr1i.remainder,den)
        qrt  := divide(bas * qr2i.remainder,den)
        qr2i := divide(bas * qrt.remainder,den)
        rits := concat(qr2i, concat(qrt, rits))
        i    := i + 1
      rits := reverse_! rits
      n    := i
      -- 2. Find p = first i such that rits.i = rits.(i+n)
      ritsi := rits
      ritsn := rits; for i in 1..n repeat ritsn := rest ritsn
      i := 0
      while first(ritsi) ^= first(ritsn) repeat
        ritsi := rest ritsi
        ritsn := rest ritsn
        i     := i + 1
      p := i
      -- 3. Find c = first i such that rits.p = rits.(p+i)
      ritsn := rits; for i in 1..n repeat ritsn := rest ritsn
      rn    := first ritsn
      cfound:= false
      c : I := 0
      for i in 1..p while not cfound repeat
        ritsn := rest ritsn
        if rn = first(ritsn) then
          c := i
          cfound := true
      if not cfound then c := n
      -- 4. Now produce the lists of ragits.
      ritspfx: List I := nil()
      ritscyc: List I := nil()
      for i in 1..p repeat
        ritspfx := concat(first(rits).quotient, ritspfx)
        rits    := rest rits
      for i in 1..c repeat
        ritscyc := concat(first(rits).quotient, ritscyc)
        rits    := rest rits
      [reverse_! ritspfx, reverse_! ritscyc]

@
\section{domain BINARY BinaryExpansion}
<<BinaryExpansion.input>>=
-- radix.spad.pamphlet BinaryExpansion.input
)spool BinaryExpansion.output
)set message test on
)set message auto off
)clear all
--S 1
r := binary(22/7)
--R 
--R
--R           ___
--R   (1)  11.001
--R                                                        Type: BinaryExpansion
--E 1

--S 2
r + binary(6/7)
--R 
--R
--R   (2)  100
--R                                                        Type: BinaryExpansion
--E 2

--S 3
[binary(1/i) for i in 102..106]
--R 
--R
--R   (3)
--R       ________    ___________________________________________________
--R   [0.000000101, 0.000000100111110001000101100101111001110010010101001,
--R         ____________    ____________
--R    0.000000100111011, 0.000000100111,
--R       ____________________________________________________
--R    0.00000010011010100100001110011111011001010110111100011]
--R                                                   Type: List BinaryExpansion
--E 3

--S 4
binary(1/1007)
--R 
--R
--R   (4)
--R   0.
--R     OVERBAR
--R        00000000010000010001010010010111100000111111000010111111001011000111110
--R          100010011100100110011000110010010101011110110100110000000011000011001
--R          111011100011010001011110100100011110110000101011101110011101010111001
--R          100101001011100000001110001111001000000100100100110111001010100111010
--R          001101110110101110001001000001100101101100000010110010111110001010000
--R          010101010110101100000110110111010010101111111010111010100110010000101
--R          0011011000100110001000100001000011000111010011110001
--R                                                        Type: BinaryExpansion
--E 4

--S 5
p := binary(1/4)*x**2 + binary(2/3)*x + binary(4/9)
--R 
--R
--R             2     __      ______
--R   (5)  0.01x  + 0.10x + 0.011100
--R                                             Type: Polynomial BinaryExpansion
--E 5

--S 6
q := D(p, x)
--R 
--R
--R                 __
--R   (6)  0.1x + 0.10
--R                                             Type: Polynomial BinaryExpansion
--E 6

--S 7
g := gcd(p, q)
--R 
--R
--R              __
--R   (7)  x + 1.01
--R                                             Type: Polynomial BinaryExpansion
--E 7
)spool
)lisp (bye)
@
<<BinaryExpansion.help>>=
====================================================================
BinaryExpansion examples
====================================================================
All rational numbers have repeating binary expansions.  Operations to
access the individual bits of a binary expansion can be obtained by
converting the value to RadixExpansion(2).  More examples of
expansions are available with

The expansion (of type BinaryExpansion) of a rational number is
returned by the binary operation.

  r := binary(22/7)
      ___
   11.001
                      Type: BinaryExpansion

Arithmetic is exact.

  r + binary(6/7)
   100 
                      Type: BinaryExpansion

The period of the expansion can be short or long.

  [binary(1/i) for i in 102..106]
      ________
   [0.00000101,
      ___________________________________________________
    0.000000100111110001000101100101111001110010010101001,
         ____________    ____________
    0.000000100111011, 0.000000100111,
       ____________________________________________________
    0.00000010011010100100001110011111011001010110111100011]
                      Type: List BinaryExpansion

or very long.

  binary(1/1007)
     ________________________________________________________________________
   0.000000000100000100010100100101111000001111110000101111110010110001111101
     ________________________________________________________________________
     000100111001001100110001100100101010111101101001100000000110000110011110
     ________________________________________________________________________
     111000110100010111101001000111101100001010111011100111010101110011001010
     ________________________________________________________________________
     010111000000011100011110010000001001001001101110010101001110100011011101
     ________________________________________________________________________
     101011100010010000011001011011000000101100101111100010100000101010101101
     ________________________________________________________________________
     011000001101101110100101011111110101110101001100100001010011011000100110
     ____________________________________
     001000100001000011000111010011110001
                      Type: BinaryExpansion

These numbers are bona fide algebraic objects.

  p := binary(1/4)*x**2 + binary(2/3)*x + binary(4/9)
               __       ______
   0.01 x^2 +0.10 x + 0.011100
                      Type: Polynomial BinaryExpansion

  q := D(p, x)
             __
   0.1 x + 0.10
                      Type: Polynomial BinaryExpansion

  g := gcd(p, q)
       __
   x+1.01
                      Type: Polynomial BinaryExpansion

See Also:
o )help DecimalExpansion
o )help HexadecimalExpansion
o )show BinaryExpansion
o $AXIOM/doc/src/algebra/radix.spad.dvi

@
<<domain BINARY BinaryExpansion>>=
)abbrev domain BINARY BinaryExpansion
++ Author: Clifton J. Williamson
++ Date Created: April 26, 1990
++ Date Last Updated: May 15, 1991
++ Basic Operations:
++ Related Domains: RadixExpansion
++ Also See:
++ AMS Classifications:
++ Keywords: radix, base, binary
++ Examples:
++ References:
++ Description:
++   This domain allows rational numbers to be presented as repeating
++   binary expansions.

BinaryExpansion(): Exports == Implementation where
  Exports ==> QuotientFieldCategory(Integer) with
    coerce: % -> Fraction Integer
      ++ coerce(b) converts a binary expansion to a rational number.
    coerce: % -> RadixExpansion(2)
      ++ coerce(b) converts a binary expansion to a radix expansion with base 2.
    fractionPart: % -> Fraction Integer
      ++ fractionPart(b) returns the fractional part of a binary expansion.
    binary: Fraction Integer -> %
      ++ binary(r) converts a rational number to a binary expansion.

  Implementation ==> RadixExpansion(2) add
    binary r == r :: %
    coerce(x:%): RadixExpansion(2) == x pretend RadixExpansion(2)

@
\section{domain DECIMAL DecimalExpansion}
<<DecimalExpansion.input>>=
-- radix.spad.pamphlet DecimalExpansion.input
)spool DecimalExpansion.output
)set message test on
)set message auto off
)clear all
--S 1 of 7
r := decimal(22/7)
--R 
--R
--R          ______
--R   (1)  3.142857
--R                                                       Type: DecimalExpansion
--E 1

--S 2 of 7
r + decimal(6/7)
--R 
--R
--R   (2)  4
--R                                                       Type: DecimalExpansion
--E 2

--S 3 of 7
[decimal(1/i) for i in 350..354]
--R 
--R
--R   (3)
--R        ______    ______         __    ________________________________
--R   [0.00285714, 0.002849, 0.0028409, 0.00283286118980169971671388101983,
--R       __________________________________________________________
--R    0.00282485875706214689265536723163841807909604519774011299435]
--R                                                  Type: List DecimalExpansion
--E 3

--S 4 of 7
decimal(1/2049)
--R 
--R
--R   (4)
--R   0.
--R     OVERBAR
--R        00048804294777940458760370912640312347486578818936066373840897999023914
--R          104441190824792581747193753050268423621278672523182040019521717911176
--R          183504148365056124938994631527574426549536359199609565641776476329917
--R          032698877501220107369448511469009272816007808687164470473401659346022
--R          449975597852611029770619814543679843826256710590531966813079551
--R                                                       Type: DecimalExpansion
--E 4

--S 5 of 7
p := decimal(1/4)*x**2 + decimal(2/3)*x + decimal(4/9) 
--R 
--R
--R             2     _      _
--R   (5)  0.25x  + 0.6x + 0.4
--R                                            Type: Polynomial DecimalExpansion
--E 5

--S 6 of 7
q := differentiate(p, x)
--R 
--R
--R                 _
--R   (6)  0.5x + 0.6
--R                                            Type: Polynomial DecimalExpansion
--E 6

--S 7 of 7
g := gcd(p, q)
--R 
--R
--R              _
--R   (7)  x + 1.3
--R                                            Type: Polynomial DecimalExpansion
--E 7
)spool
)lisp (bye)
@
<<DecimalExpansion.help>>=
====================================================================
DecimalExpansion examples
====================================================================

All rationals have repeating decimal expansions.  Operations to access
the individual digits of a decimal expansion can be obtained by
converting the value to RadixExpansion(10).  

The operation decimal is used to create this expansion of type
DecimalExpansion.

  r := decimal(22/7)
      ______
    3.142857
                      Type: DecimalExpansion

Arithmetic is exact.

  r + decimal(6/7)
   4
                      Type: DecimalExpansion

The period of the expansion can be short or long ...

  [decimal(1/i) for i in 350..354]
        ______    ______         __    ________________________________
   [0.00285714, 0.002849, 0.0028409, 0.00283286118980169971671388101983,
       __________________________________________________________
    0.00282485875706214689265536723163841807909604519774011299435]
                      Type: List DecimalExpansion

or very long.

  decimal(1/2049)
     _______________________________________________________________________
   0.00048804294777940458760370912640312347486578818936066373840897999023914
     _____________________________________________________________________
     104441190824792581747193753050268423621278672523182040019521717911176
     _____________________________________________________________________
     183504148365056124938994631527574426549536359199609565641776476329917
     _____________________________________________________________________
     032698877501220107369448511469009272816007808687164470473401659346022
     _______________________________________________________________
     449975597852611029770619814543679843826256710590531966813079551
                     Type: DecimalExpansion

These numbers are bona fide algebraic objects.

  p := decimal(1/4)*x**2 + decimal(2/3)*x + decimal(4/9) 
        2     _      _
   0.25x  + 0.6x + 0.4
                     Type: Polynomial DecimalExpansion

  q := differentiate(p, x)
            _
   0.5x + 0.6
                     Type: Polynomial DecimalExpansion

  g := gcd(p, q)
         _
   x + 1.3
                     Type: Polynomial DecimalExpansion

See Also:
o )help RadixExpansion
o )help BinaryExpansion
o )help HexadecimalExpansion
o )show DecimalExpansion
o $AXIOM/doc/src/algebra/radix.spad.dvi

@
<<domain DECIMAL DecimalExpansion>>=
)abbrev domain DECIMAL DecimalExpansion
++ Author: Stephen M. Watt
++ Date Created: October, 1986
++ Date Last Updated: May 15, 1991
++ Basic Operations:
++ Related Domains: RadixExpansion
++ Also See:
++ AMS Classifications:
++ Keywords: radix, base, repeating decimal
++ Examples:
++ References:
++ Description:
++   This domain allows rational numbers to be presented as repeating
++   decimal expansions.
DecimalExpansion(): Exports == Implementation where
  Exports ==> QuotientFieldCategory(Integer) with
    coerce: % -> Fraction Integer
      ++ coerce(d) converts a decimal expansion to a rational number.
    coerce: % -> RadixExpansion(10)
      ++ coerce(d) converts a decimal expansion to a radix expansion
      ++ with base 10.
    fractionPart: % -> Fraction Integer
      ++ fractionPart(d) returns the fractional part of a decimal expansion.
    decimal: Fraction Integer -> %
      ++ decimal(r) converts a rational number to a decimal expansion.

  Implementation ==> RadixExpansion(10) add
    decimal r == r :: %
    coerce(x:%): RadixExpansion(10) == x pretend RadixExpansion(10)

@
\section{domain HEXADEC HexadecimalExpansion}
<<HexadecimalExpansion.input>>=
-- radix.spad.pamphlet HexadecimalExpansion.input
)spool HexadecimalExpansion.output
)set message test on
)set message auto off
)clear all
--S 1 of 7
r := hex(22/7)
--R 
--R
--R          ___
--R   (1)  3.249
--R                                                   Type: HexadecimalExpansion
--E 1

--S 2 of 7
r + hex(6/7)
--R 
--R
--R   (2)  4
--R                                                   Type: HexadecimalExpansion
--E 2

--S 3 of 7
[hex(1/i) for i in 350..354]
--R 
--R
--R   (3)
--R       _______________    _________      _____    ______________________
--R   [0.00BB3EE721A54D88, 0.00BAB6561, 0.00BA2E8, 0.00B9A7862A0FF465879D5F,
--R       _____________________________
--R    0.00B92143FA36F5E02E4850FE8DBD78]
--R                                              Type: List HexadecimalExpansion
--E 3

--S 4 of 7
hex(1/1007)
--R 
--R
--R   (4)
--R   0.
--R     OVERBAR
--R        0041149783F0BF2C7D13933192AF6980619EE345E91EC2BB9D5CCA5C071E40926E54E8D
--R          DAE24196C0B2F8A0AAD60DBA57F5D4C8536262210C74F1
--R                                                   Type: HexadecimalExpansion
--E 4

--S 5 of 7
p := hex(1/4)*x**2 + hex(2/3)*x + hex(4/9)
--R 
--R
--R            2     _      ___
--R   (5)  0.4x  + 0.Ax + 0.71C
--R                                        Type: Polynomial HexadecimalExpansion
--E 5

--S 6 of 7
q := D(p, x)
--R 
--R
--R                 _
--R   (6)  0.8x + 0.A
--R                                        Type: Polynomial HexadecimalExpansion
--E 6

--S 7 of 7
g := gcd(p, q)
--R 
--R
--R              _
--R   (7)  x + 1.5
--R                                        Type: Polynomial HexadecimalExpansion
--E 7
)spool
 
)spool
)lisp (bye)
@
<<HexadecimalExpansion.help>>=
\section{HexadecimalExpansion}
\label{HexadecimalExpansionXmpPage}

All rationals have repeating hexadecimal expansions.  The operation
hex returns these expansions of type HexadecimalExpansion.  Operations
to access the individual numerals of a hexadecimal expansion can be
obtained by converting the value to RadixExpansion(16).  More examples
of expansions are available in the DecimalExpansion, BinaryExpansion,
and RadixExpansion.

This is a hexadecimal expansion of a rational number.

  r := hex(22/7)
      ___
    3.249
                      Type: HexadecimalExpansion

Arithmetic is exact.

  r + hex(6/7)
    4
                      Type: HexadecimalExpansion

The period of the expansion can be short or long ...

  [hex(1/i) for i in 350..354]
       _______________    _________      _____    ______________________
   [0.00BB3EE721A54D88, 0.00BAB6561, 0.00BA2E8, 0.00B9A7862A0FF465879D5F,
       _____________________________
    0.00B92143FA36F5E02E4850FE8DBD78]
                      Type: List HexadecimalExpansion

or very long!

  hex(1/1007)
     _______________________________________________________________________
   0.0041149783F0BF2C7D13933192AF6980619EE345E91EC2BB9D5CCA5C071E40926E54E8D
     ______________________________________________
     DAE24196C0B2F8A0AAD60DBA57F5D4C8536262210C74F1
                      Type: HexadecimalExpansion

These numbers are bona fide algebraic objects.

  p := hex(1/4)*x**2 + hex(2/3)*x + hex(4/9)
        2     _      ___
    0.4x  + 0.Ax + 0.71C
                      Type: Polynomial HexadecimalExpansion

  q := D(p, x)
             _
    0.8x + 0.A
                      Type: Polynomial HexadecimalExpansion

  g := gcd(p, q)
          _
    x + 1.5
                      Type: Polynomial HexadecimalExpansion

See Also:
o )help RadixExpansion
o )help BinaryExpansion
o )help DecimalExpansion
o )show HexadecimalExpansion
o $AXIOM/doc/src/algebra/radix.spad.dvi

@
<<domain HEXADEC HexadecimalExpansion>>=
)abbrev domain HEXADEC HexadecimalExpansion
++ Author: Clifton J. Williamson
++ Date Created: April 26, 1990
++ Date Last Updated: May 15, 1991
++ Basic Operations:
++ Related Domains: RadixExpansion
++ Also See:
++ AMS Classifications:
++ Keywords: radix, base, hexadecimal
++ Examples:
++ References:
++ Description:
++   This domain allows rational numbers to be presented as repeating
++   hexadecimal expansions.

HexadecimalExpansion(): Exports == Implementation where
  Exports ==> QuotientFieldCategory(Integer) with
    coerce: % -> Fraction Integer
      ++ coerce(h) converts a hexadecimal expansion to a rational number.
    coerce: % -> RadixExpansion(16)
      ++ coerce(h) converts a hexadecimal expansion to a radix expansion
      ++ with base 16.
    fractionPart: % -> Fraction Integer
      ++ fractionPart(h) returns the fractional part of a hexadecimal expansion.
    hex: Fraction Integer -> %
      ++ hex(r) converts a rational number to a hexadecimal expansion.

  Implementation ==> RadixExpansion(16) add
    hex r == r :: %
    coerce(x:%): RadixExpansion(16) == x pretend RadixExpansion(16)

@
\section{package RADUTIL RadixUtilities}
<<package RADUTIL RadixUtilities>>=
)abbrev package RADUTIL RadixUtilities
++ Author: Stephen M. Watt
++ Date Created: October 1986
++ Date Last Updated: May 15, 1991
++ Basic Operations:
++ Related Domains: RadixExpansion
++ Also See:
++ AMS Classifications:
++ Keywords: radix, base, repeading decimal
++ Examples:
++ References:
++ Description:
++   This package provides tools for creating radix expansions.
RadixUtilities: Exports == Implementation where
  Exports ==> with
    radix: (Fraction Integer,Integer) -> Any
      ++ radix(x,b) converts x to a radix expansion in base b.
  Implementation ==> add
    radix(q, b) ==
      coerce(q :: RadixExpansion(b))$AnyFunctions1(RadixExpansion b)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain RADIX RadixExpansion>>
<<domain BINARY BinaryExpansion>>
<<domain DECIMAL DecimalExpansion>>
<<domain HEXADEC HexadecimalExpansion>>
<<package RADUTIL RadixUtilities>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
