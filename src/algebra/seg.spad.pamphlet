\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra seg.spad}
\author{Stephen M. Watt, Robert Sutor}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{category SEGCAT SegmentCategory}
<<category SEGCAT SegmentCategory>>=
)abbrev category SEGCAT SegmentCategory
++ Author:  Stephen M. Watt
++ Date Created:  December 1986
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: range, segment
++ Examples:
++ References:
++ Description:
++   This category provides operations on ranges, or {\em segments}
++   as they are called.

SegmentCategory(S:Type): Category == Type with
    SEGMENT: (S, S) -> %
        ++ \spad{l..h} creates a segment with l and h as the endpoints.
    BY: (%, Integer) -> %
        ++ \spad{s by n} creates a new segment in which only every \spad{n}-th
        ++ element is used.
    lo: % -> S
        ++ lo(s) returns the first endpoint of s.
        ++ Note: \spad{lo(l..h) = l}.
    hi: % -> S
        ++ hi(s) returns the second endpoint of s.
        ++ Note: \spad{hi(l..h) = h}.
    low: % -> S
        ++ low(s) returns the first endpoint of s.
        ++ Note: \spad{low(l..h) = l}.
    high: % -> S
        ++ high(s) returns the second endpoint of s.
        ++ Note: \spad{high(l..h) = h}.
    incr: % -> Integer
        ++ incr(s) returns \spad{n}, where s is a segment in which every
        ++ \spad{n}-th element is used.
        ++ Note: \spad{incr(l..h by n) = n}.
    segment: (S, S) -> %
        ++ segment(i,j) is an alternate way to create the segment \spad{i..j}.
    convert: S -> %
        ++ convert(i) creates the segment \spad{i..i}.

@
\section{category SEGXCAT SegmentExpansionCategory}
<<category SEGXCAT SegmentExpansionCategory>>=
)abbrev category SEGXCAT SegmentExpansionCategory
++ Author:  Stephen M. Watt
++ Date Created: June 5, 1991
++ Date Last Updated:
++ Basic Operations:
++ Related Domains: Segment, UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
++   This category provides an interface for expanding segments to
++   a stream of elements.
SegmentExpansionCategory(S: OrderedRing, L: StreamAggregate(S)): Category ==
    SegmentCategory(S) with
      expand: List % -> L
        ++ expand(l) creates a new value of type L in which each segment
        ++ \spad{l..h by k} is replaced with \spad{l, l+k, ... lN},
        ++ where \spad{lN <= h < lN+k}.
        ++ For example, \spad{expand [1..4, 7..9] = [1,2,3,4,7,8,9]}.
      expand: % -> L
        ++ expand(l..h by k) creates value of type L with elements
        ++ \spad{l, l+k, ... lN} where \spad{lN <= h < lN+k}.
        ++ For example, \spad{expand(1..5 by 2) = [1,3,5]}.
      map: (S -> S, %) -> L
        ++ map(f,l..h by k) produces a value of type L by applying f
        ++ to each of the succesive elements of the segment, that is,
        ++ \spad{[f(l), f(l+k), ..., f(lN)]}, where \spad{lN <= h < lN+k}.

@
\section{domain SEG Segment}
<<Segment.input>>=
-- seg.spad.pamphlet Segment.input
)spool Segment.output
)set message test on
)set message auto off
)clear all
--S 1 of 10
s := 3..10
--R 
--R
--R   (1)  3..10
--R                                                Type: Segment PositiveInteger
--E 1

--S 2 of 10
lo s
--R 
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 2

--S 3 of 10
hi s
--R 
--R
--R   (3)  10
--R                                                        Type: PositiveInteger
--E 3

--S 4 of 10
t := 10..3 by -2
--R 
--R
--R   (4)  10..3 by - 2
--R                                                Type: Segment PositiveInteger
--E 4

--S 5 of 10
incr s
--R 
--R
--R   (5)  1
--R                                                        Type: PositiveInteger
--E 5

--S 6 of 10
incr t
--R 
--R
--R   (6)  - 2
--R                                                                Type: Integer
--E 6

--S 7 of 10
l := [1..3, 5, 9, 15..11 by -1]
--R 
--R
--R   (7)  [1..3,5..5,9..9,15..11 by - 1]
--R                                           Type: List Segment PositiveInteger
--E 7

--S 8 of 10
expand s
--R 
--R
--R   (8)  [3,4,5,6,7,8,9,10]
--R                                                           Type: List Integer
--E 8

--S 9 of 10
expand t
--R 
--R
--R   (9)  [10,8,6,4]
--R                                                           Type: List Integer
--E 9

--S 10 of 10
expand l
--R 
--R
--R   (10)  [1,2,3,5,9,15,14,13,12,11]
--R                                                           Type: List Integer
--E 10
)spool
)lisp (bye)
@
<<Segment.help>>=
====================================================================
Segment examples
====================================================================

The Segment domain provides a generalized interval type.

Segments are created using the .. construct by indicating the
(included) end points.

  s := 3..10
    3..10
                             Type: Segment PositiveInteger

The first end point is called the lo and the second is called hi.

  lo s
    3
                             Type: PositiveInteger

These names are used even though the end points might belong to an
unordered set.

  hi s
    10
                              Type: PositiveInteger

In addition to the end points, each segment has an integer "increment".
An increment can be specified using the "by" construct.

  t := 10..3 by -2
    10..3 by - 2
                              Type: Segment PositiveInteger

This part can be obtained using the incr function.

  incr s
    1
                              Type: PositiveInteger

Unless otherwise specified, the increment is 1.

  incr t
    - 2
                              Type: Integer

A single value can be converted to a segment with equal end points.
This happens if segments and single values are mixed in a list.

  l := [1..3, 5, 9, 15..11 by -1]
    [1..3,5..5,9..9,15..11 by - 1]
                               Type: List Segment PositiveInteger

If the underlying type is an ordered ring, it is possible to perform
additional operations.  The expand operation creates a list of points
in a segment.

  expand s
    [3,4,5,6,7,8,9,10]
                               Type: List Integer

If k > 0, then expand(l..h by k) creates the list [l, l+k, ..., lN]
where lN <= h < lN+k.  If k < 0, then lN >= h > lN+k.

  expand t
    [10,8,6,4]
                               Type: List Integer

It is also possible to expand a list of segments.  This is equivalent
to appending lists obtained by expanding each segment individually.

  expand l
    [1,2,3,5,9,15,14,13,12,11]
                                Type: List Integer

See Also:
o )help UniversalSegment
o )help SegmentBinding
o )show Segment
o $AXIOM/doc/src/algebra/seg.spad.dvi

@
<<domain SEG Segment>>=
)abbrev domain SEG Segment
++ Author:  Stephen M. Watt
++ Date Created:  December 1986
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: range, segment
++ Examples:
++ References:
++ Description:
++   This type is used to specify a range of values from type \spad{S}.

Segment(S:Type): SegmentCategory(S) with
    if S has SetCategory then SetCategory
    if S has OrderedRing then SegmentExpansionCategory(S, List S)
  == add

    Rep := Record(low: S, high: S, incr: Integer)

    a..b == [a,b,1]
    lo s == s.low
    low s == s.low
    hi s == s.high
    high s == s.high
    incr s == s.incr
    segment(a,b) == [a,b,1]
    BY(s, r) == [lo s, hi s, r]

    if S has SetCategory then
      (s1:%) = (s2:%) ==
        s1.low = s2.low and s1.high=s2.high and s1.incr = s2.incr

      coerce(s:%):OutputForm ==
        seg := SEGMENT(s.low::OutputForm, s.high::OutputForm)
        s.incr = 1 => seg
        infix(" by "::OutputForm, seg, s.incr::OutputForm)

    convert a == [a,a,1]

    if S has OrderedRing then
      expand(ls: List %):List S ==
        lr := nil()$List(S)
        for s in ls repeat
          l := lo s
          h := hi s
          inc := (incr s)::S
          zero? inc => error "Cannot expand a segment with an increment of zero"
          if inc > 0 then
            while l <= h repeat
              lr := concat(l, lr)
              l := l + inc
          else 
            while l >= h repeat
              lr := concat(l, lr)
              l := l + inc
        reverse_! lr

      expand(s : %) == expand([s]$List(%))$%
      map(f : S->S, s : %): List S ==
        lr := nil()$List(S)
        l := lo s
        h := hi s
        inc := (incr s)::S
        if inc > 0 then
          while l <= h repeat
            lr := concat(f l, lr)
            l := l + inc
        else
          while l >= h repeat
            lr := concat(f l, lr)
            l := l + inc
        reverse_! lr

@
\section{package SEG2 SegmentFunctions2}
<<package SEG2 SegmentFunctions2>>=
)abbrev package SEG2 SegmentFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Segment, UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto segments.

SegmentFunctions2(R:Type, S:Type): public == private where
  public ==> with
    map: (R -> S, Segment R) -> Segment S
        ++ map(f,l..h) returns a new segment \spad{f(l)..f(h)}.

    if R has OrderedRing then
      map: (R -> S, Segment R) -> List S
        ++ map(f,s) expands the segment s, applying \spad{f} to each
        ++ value.  For example, if \spad{s = l..h by k}, then the list
        ++ \spad{[f(l), f(l+k),..., f(lN)]} is computed, where
        ++ \spad{lN <= h < lN+k}.


  private ==> add
    map(f : R->S, r : Segment R): Segment S ==
      SEGMENT(f lo r,f hi r)$Segment(S)

    if R has OrderedRing then
     map(f : R->S, r : Segment R): List S ==
       lr := nil()$List(S)
       l := lo r
       h := hi r
       inc := (incr r)::R
       if inc > 0 then
         while l <= h repeat
           lr := concat(f(l), lr)
           l := l + inc
       else
         while l >= h repeat
           lr := concat(f(l), lr)
           l := l + inc
       reverse_! lr

@
\section{domain SEGBIND SegmentBinding}
<<SegmentBinding.input>>=
-- seg.spad.pamphlet SegmentBinding.input
)spool SegmentBinding.output
)set message test on
)set message auto off
)clear all
--S 1 of 5
x = a..b
--R 
--R
--R   (1)  x= a..b
--R                                                  Type: SegmentBinding Symbol
--E 1

--S 2 of 5
sum(i**2, i = 0..n)
--R 
--R
--R          3     2
--R        2n  + 3n  + n
--R   (2)  -------------
--R              6
--R                                            Type: Fraction Polynomial Integer
--E 2

--S 3 of 5
sb := y = 1/2..3/2
--R 
--R
--R            1    3
--R   (3)  y= (-)..(-)
--R            2    2
--R                                        Type: SegmentBinding Fraction Integer
--E 3

--S 4 of 5
variable(sb)
--R 
--R
--R   (4)  y
--R                                                                 Type: Symbol
--E 4

--S 5 of 5
segment(sb)
--R 
--R
--R         1    3
--R   (5)  (-)..(-)
--R         2    2
--R                                               Type: Segment Fraction Integer
--E 5
)spool
)lisp (bye)
@
<<SegmentBinding.help>>=
====================================================================
SegmentBinding examples
====================================================================

The SegmentBinding type is used to indicate a range for a named symbol.

First give the symbol, then an = and finally a segment of values.

  x = a..b
    x= a..b
                            Type: SegmentBinding Symbol

This is used to provide a convenient syntax for arguments to certain
operations.

  sum(i**2, i = 0..n)
      3     2
    2n  + 3n  + n
    -------------
          6
                            Type: Fraction Polynomial Integer

  draw(x**2, x = -2..2)
    TwoDimensionalViewport: "x*x"
                            Type: TwoDimensionalViewport


The left-hand side must be of type Symbol but the right-hand side can
be a segment over any type.

  sb := y = 1/2..3/2
        1    3
    y= (-)..(-)
        2    2
                            Type: SegmentBinding Fraction Integer

The left- and right-hand sides can be obtained using the variable and
segment operations.

  variable(sb)
    y
                            Type: Symbol

  segment(sb)
     1    3
    (-)..(-)
     2    2
                            Type: Segment Fraction Integer

See Also:
o )help Segment
o )help UniversalSegment
o )show SegmentBinding
o $AXIOM/doc/src/algebra/seg.spad.dvi

@
<<domain SEGBIND SegmentBinding>>=
)abbrev domain SEGBIND SegmentBinding
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Equation, Segment, Symbol
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This domain is used to provide the function argument syntax \spad{v=a..b}.
++   This is used, for example, by the top-level \spadfun{draw} functions.
SegmentBinding(S:Type): Type with
  equation: (Symbol, Segment S) -> %
      ++ equation(v,a..b) creates a segment binding value with variable
      ++ \spad{v} and segment \spad{a..b}.  Note that the interpreter parses
      ++ \spad{v=a..b} to this form.
  variable: % -> Symbol
      ++ variable(segb) returns the variable from the left hand side of
      ++ the \spadtype{SegmentBinding}.  For example, if \spad{segb} is
      ++ \spad{v=a..b}, then \spad{variable(segb)} returns \spad{v}.
  segment : % -> Segment S
      ++ segment(segb) returns the segment from the right hand side of
      ++ the \spadtype{SegmentBinding}.  For example, if \spad{segb} is
      ++ \spad{v=a..b}, then \spad{segment(segb)} returns \spad{a..b}.

  if S has SetCategory then SetCategory
 == add
  Rep := Record(var:Symbol, seg:Segment S)
  equation(x,s) == [x, s]
  variable b    == b.var
  segment b     == b.seg

  if S has SetCategory then

     b1 = b2       == variable b1 = variable b2 and segment b1 = segment b2

     coerce(b:%):OutputForm ==
       variable(b)::OutputForm = segment(b)::OutputForm

@
\section{package SEGBIND2 SegmentBindingFunctions2}
<<package SEGBIND2 SegmentBindingFunctions2>>=
)abbrev package SEGBIND2 SegmentBindingFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: SegmentBinding, Segment, Equation
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto
++   \spadtype{SegmentBinding}s.
SegmentBindingFunctions2(R:Type, S:Type): with
  map: (R -> S, SegmentBinding R) -> SegmentBinding S
      ++ map(f,v=a..b) returns the value given by \spad{v=f(a)..f(b)}.
 == add
  map(f, b) ==
    equation(variable b, map(f, segment b)$SegmentFunctions2(R, S))

@
\section{domain UNISEG UniversalSegment}
<<UniversalSegment.input>>=
-- seg.spad.pamphlet UniversalSegment.input
)spool UniversalSegment.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
pints := 1..
--R 
--R
--R   (1)  1..
--R                                       Type: UniversalSegment PositiveInteger
--E 1

--S 2 of 9
nevens := (0..) by -2
--R 
--R
--R   (2)  0.. by - 2
--R                                    Type: UniversalSegment NonNegativeInteger
--E 2

--S 3 of 9
useg: UniversalSegment(Integer) := 3..10
--R 
--R
--R   (3)  3..10
--R                                               Type: UniversalSegment Integer
--E 3

--S 4 of 9
hasHi pints
--R 
--R
--R   (4)  false
--R                                                                Type: Boolean
--E 4

--S 5 of 9
hasHi nevens
--R 
--R
--R   (5)  false
--R                                                                Type: Boolean
--E 5

--S 6 of 9
hasHi useg
--R 
--R
--R   (6)  true
--R                                                                Type: Boolean
--E 6

--S 7 of 9
expand pints
--R 
--R
--R   (7)  [1,2,3,4,5,6,7,8,9,10,...]
--R                                                         Type: Stream Integer
--E 7

--S 8 of 9
expand nevens
--R 
--R
--R   (8)  [0,- 2,- 4,- 6,- 8,- 10,- 12,- 14,- 16,- 18,...]
--R                                                         Type: Stream Integer
--E 8

--S 9 of 9
expand [1, 3, 10..15, 100..]
--R 
--R
--R   (9)  [1,3,10,11,12,13,14,15,100,101,...]
--R                                                         Type: Stream Integer
--E 9
)spool
)lisp (bye)
@
<<UniversalSegment.help>>=
====================================================================
UniversalSegment examples
====================================================================

The UniversalSegment domain generalizes Segment by allowing segments
without a "hi" end point.

  pints := 1..
    1..
                                Type: UniversalSegment PositiveInteger

  nevens := (0..) by -2
    0.. by - 2
                                Type: UniversalSegment NonNegativeInteger

Values of type Segment are automatically converted to type
UniversalSegment when appropriate.

  useg: UniversalSegment(Integer) := 3..10
    3..10
                                Type: UniversalSegment Integer

The operation hasHi is used to test whether a segment has a hi end point.

  hasHi pints
    false
                                Type: Boolean

  hasHi nevens
    false
                                Type: Boolean

  hasHi useg
    true
                                Type: Boolean

All operations available on type Segment apply to UniversalSegment, with 
the proviso that expansions produce streams rather than lists.  This is 
to accommodate infinite expansions.

  expand pints
    [1,2,3,4,5,6,7,8,9,10,...]
                                Type: Stream Integer

  expand nevens
    [0,- 2,- 4,- 6,- 8,- 10,- 12,- 14,- 16,- 18,...]
                                Type: Stream Integer

  expand [1, 3, 10..15, 100..]
    [1,3,10,11,12,13,14,15,100,101,...]
                                Type: Stream Integer

See Also:
o )help Segment
o )help SegmentBinding
o )help List
o )help Stream
o )show UniversalSegment
o $AXIOM/doc/src/algebra/seg.spad.dvi

@
<<domain UNISEG UniversalSegment>>=
)abbrev domain UNISEG UniversalSegment
++ Author:  Robert S. Sutor
++ Date Created: 1987
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Segment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++  This domain provides segments which may be half open.
++  That is, ranges of the form \spad{a..} or \spad{a..b}.

UniversalSegment(S: Type): SegmentCategory(S) with
    SEGMENT: S -> %
        ++ \spad{l..} produces a half open segment,
        ++ that is, one with no upper bound.
    segment: S -> %
        ++ segment(l) is an alternate way to construct the segment \spad{l..}.
    coerce : Segment S -> %
        ++ coerce(x) allows \spadtype{Segment} values to be used as %.
    hasHi: % -> Boolean
        ++ hasHi(s) tests whether the segment s has an upper bound.

    if S has SetCategory then SetCategory

    if S has OrderedRing then
      SegmentExpansionCategory(S, Stream S)
--    expand : (List %, S) -> Stream S
--    expand : (%, S) -> Stream S

  == add
    Rec  ==> Record(low: S, high: S, incr: Integer)
    Rec2 ==> Record(low: S, incr: Integer)
    SEG ==> Segment S

    Rep := Union(Rec2, Rec)
    a,b : S
    s : %
    i: Integer
    ls : List %

    segment a == [a, 1]$Rec2 :: Rep
    segment(a,b) == [a,b,1]$Rec :: Rep
    BY(s,i) ==
      s case Rec => [lo s, hi s, i]$Rec ::Rep
      [lo s, i]$Rec2 :: Rep

    lo s ==
      s case Rec2 => (s :: Rec2).low
      (s :: Rec).low

    low s ==
      s case Rec2 => (s :: Rec2).low
      (s :: Rec).low

    hasHi s == s case Rec

    hi s ==
      not hasHi(s) => error "hi: segment has no upper bound"
      (s :: Rec).high

    high s ==
      not hasHi(s) => error "high: segment has no upper bound"
      (s :: Rec).high

    incr s ==
      s case Rec2 => (s :: Rec2).incr
      (s :: Rec).incr

    SEGMENT(a) == segment a
    SEGMENT(a,b) == segment(a,b)

    coerce(sg : SEG): % == segment(lo sg, hi sg)

    convert a == [a,a,1]

    if S has SetCategory then

       (s1:%) = (s2:%) ==
          s1 case Rec2 =>
             s2 case Rec2 =>
                 s1.low = s2.low and s1.incr = s2.incr
             false
          s1 case Rec =>
             s2 case Rec =>
                 s2.low = s2.low and s1.high=s2.high and s1.incr=s2.incr
             false
          false

       coerce(s: %): OutputForm ==
	 seg :=
	   e := (lo s)::OutputForm
	   hasHi s => SEGMENT(e, (hi s)::OutputForm)
	   SEGMENT e
	 inc := incr s
	 inc = 1 => seg
	 infix(" by "::OutputForm, seg, inc::OutputForm)

    if S has OrderedRing then
      expand(s:%)       == expand([s])
      map(f:S->S, s:%)  == map(f, expand s)

      plusInc(t: S, a: S): S == t + a

      expand(ls: List %):Stream S ==
        st:Stream S := empty()
        null ls => st

        lb:List(Segment S) := nil()
        while not null ls and hasHi first ls repeat
            s  := first ls
            ls := rest ls
            ns := BY(SEGMENT(lo s, hi s), incr s)$Segment(S)
            lb := concat_!(lb,ns)
        if not null ls then
            s := first ls
            st: Stream S := generate(#1 + incr(s)::S, lo s)
        else
            st: Stream S := empty()
        concat(construct expand(lb),  st)

@
\section{package UNISEG2 UniversalSegmentFunctions2}
<<package UNISEG2 UniversalSegmentFunctions2>>=
)abbrev package UNISEG2 UniversalSegmentFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Segment, UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto segments.

UniversalSegmentFunctions2(R:Type, S:Type): with
    map: (R -> S, UniversalSegment R) -> UniversalSegment S
        ++ map(f,seg) returns the new segment obtained by applying
        ++ f to the endpoints of seg.

    if R has OrderedRing then
      map: (R -> S, UniversalSegment R) -> Stream S
        ++ map(f,s) expands the segment s, applying \spad{f} to each value.


  == add
    map(f:R -> S, u:UniversalSegment R):UniversalSegment S ==
      s := f lo u
      hasHi u => segment(s, f hi u)
      segment s

    if R has OrderedRing then
      map(f:R -> S, u:UniversalSegment R): Stream S ==
        map(f, expand u)$StreamFunctions2(R, S)

@
\section{package INCRMAPS IncrementingMaps}
<<package INCRMAPS IncrementingMaps>>=
)abbrev package INCRMAPS IncrementingMaps
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations to create incrementing functions.

IncrementingMaps(R:Join(Monoid, AbelianSemiGroup)): with
    increment: () -> (R -> R)
        ++ increment() produces a function which adds \spad{1} to whatever
        ++ argument it is given.  For example, if {f := increment()} then
        ++ \spad{f x} is \spad{x+1}.
    incrementBy: R -> (R -> R)
        ++ incrementBy(n) produces a function which adds \spad{n} to whatever
        ++ argument it is given.  For example, if {f := increment(n)} then
        ++ \spad{f x} is \spad{x+n}.
  == add
    increment() == 1 + #1
    incrementBy n == n + #1

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<category SEGCAT SegmentCategory>>
<<category SEGXCAT SegmentExpansionCategory>>
<<domain SEG Segment>>
<<package SEG2 SegmentFunctions2>>
<<domain SEGBIND SegmentBinding>>
<<package SEGBIND2 SegmentBindingFunctions2>>
<<domain UNISEG UniversalSegment>>
<<package UNISEG2 UniversalSegmentFunctions2>>
<<package INCRMAPS IncrementingMaps>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
