\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra seg.spad}
\author{Stephen M. Watt, Robert Sutor}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package SEG2 SegmentFunctions2}
<<package SEG2 SegmentFunctions2>>=
)abbrev package SEG2 SegmentFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Segment, UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto segments.

SegmentFunctions2(R:Type, S:Type): public == private where
  public ==> with
    map: (R -> S, Segment R) -> Segment S
        ++ map(f,l..h) returns a new segment \spad{f(l)..f(h)}.

    if R has OrderedRing then
      map: (R -> S, Segment R) -> List S
        ++ map(f,s) expands the segment s, applying \spad{f} to each
        ++ value.  For example, if \spad{s = l..h by k}, then the list
        ++ \spad{[f(l), f(l+k),..., f(lN)]} is computed, where
        ++ \spad{lN <= h < lN+k}.


  private ==> add
    map(f : R->S, r : Segment R): Segment S ==
      SEGMENT(f lo r,f hi r)$Segment(S)

    if R has OrderedRing then
     map(f : R->S, r : Segment R): List S ==
       lr := nil()$List(S)
       l := lo r
       h := hi r
       inc := (incr r)::R
       if inc > 0 then
         while l <= h repeat
           lr := concat(f(l), lr)
           l := l + inc
       else
         while l >= h repeat
           lr := concat(f(l), lr)
           l := l + inc
       reverse_! lr

@
\section{package SEGBIND2 SegmentBindingFunctions2}
<<package SEGBIND2 SegmentBindingFunctions2>>=
)abbrev package SEGBIND2 SegmentBindingFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: SegmentBinding, Segment, Equation
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto
++   \spadtype{SegmentBinding}s.
SegmentBindingFunctions2(R:Type, S:Type): with
  map: (R -> S, SegmentBinding R) -> SegmentBinding S
      ++ map(f,v=a..b) returns the value given by \spad{v=f(a)..f(b)}.
 == add
  map(f, b) ==
    equation(variable b, map(f, segment b)$SegmentFunctions2(R, S))

@
\section{package UNISEG2 UniversalSegmentFunctions2}
<<package UNISEG2 UniversalSegmentFunctions2>>=
)abbrev package UNISEG2 UniversalSegmentFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: Segment, UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping functions onto segments.

UniversalSegmentFunctions2(R:Type, S:Type): with
    map: (R -> S, UniversalSegment R) -> UniversalSegment S
        ++ map(f,seg) returns the new segment obtained by applying
        ++ f to the endpoints of seg.

    if R has OrderedRing then
      map: (R -> S, UniversalSegment R) -> Stream S
        ++ map(f,s) expands the segment s, applying \spad{f} to each value.


  == add
    map(f:R -> S, u:UniversalSegment R):UniversalSegment S ==
      s := f lo u
      hasHi u => segment(s, f hi u)
      segment s

    if R has OrderedRing then
      map(f:R -> S, u:UniversalSegment R): Stream S ==
        map(f, expand u)$StreamFunctions2(R, S)

@
\section{package INCRMAPS IncrementingMaps}
<<package INCRMAPS IncrementingMaps>>=
)abbrev package INCRMAPS IncrementingMaps
++ Author:
++ Date Created:
++ Date Last Updated: June 4, 1991
++ Basic Operations:
++ Related Domains: UniversalSegment
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations to create incrementing functions.

IncrementingMaps(R:Join(Monoid, AbelianSemiGroup)): with
    increment: () -> (R -> R)
        ++ increment() produces a function which adds \spad{1} to whatever
        ++ argument it is given.  For example, if {f := increment()} then
        ++ \spad{f x} is \spad{x+1}.
    incrementBy: R -> (R -> R)
        ++ incrementBy(n) produces a function which adds \spad{n} to whatever
        ++ argument it is given.  For example, if {f := increment(n)} then
        ++ \spad{f x} is \spad{x+n}.
  == add
    increment() == 1 + #1
    incrementBy n == n + #1

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package SEG2 SegmentFunctions2>>
<<package SEGBIND2 SegmentBindingFunctions2>>
<<package UNISEG2 UniversalSegmentFunctions2>>
<<package INCRMAPS IncrementingMaps>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
