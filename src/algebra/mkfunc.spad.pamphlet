\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra mkfunc.spad}
\author{Manuel Bronstein}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package INFORM1 InputFormFunctions1}
<<package INFORM1 InputFormFunctions1>>=
)abbrev package INFORM1 InputFormFunctions1
--)boot $noSubsumption := false

++ Tools for manipulating input forms
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 19 April 1991
++ Description: Tools for manipulating input forms.

InputFormFunctions1(R:Type):with
  packageCall: Symbol -> InputForm
    ++ packageCall(f) returns the input form corresponding to f$R.
  interpret  : InputForm -> R
    ++ interpret(f) passes f to the interpreter, and transforms
    ++ the result into an object of type R.
 == add
  Rname := devaluate(R)$Lisp :: InputForm

  packageCall name ==
    convert([convert("$elt"::Symbol), Rname,
                                convert name]$List(InputForm))@InputForm

  interpret form ==
    retract(interpret(convert([convert("@"::Symbol), form,
          Rname]$List(InputForm))@InputForm)$InputForm)$AnyFunctions1(R)

@
\section{package MKFUNC MakeFunction}
<<MakeFunction.input>>=
-- mkfunc.spad.pamphlet MakeFunction.input
)spool MakeFunction.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
expr := (x - exp x + 1)^2 * (sin(x^2) * x + 1)^3
--R 
--R
--R   (1)
--R       3   x 2        4     3   x    5     4    3      2 3
--R     (x (%e )  + (- 2x  - 2x )%e  + x  + 2x  + x )sin(x )
--R   + 
--R        2   x 2        3     2   x     4     3     2      2 2
--R     (3x (%e )  + (- 6x  - 6x )%e  + 3x  + 6x  + 3x )sin(x )
--R   + 
--R            x 2        2        x     3     2           2       x 2
--R     (3x (%e )  + (- 6x  - 6x)%e  + 3x  + 6x  + 3x)sin(x ) + (%e )
--R   + 
--R                 x    2
--R     (- 2x - 2)%e  + x  + 2x + 1
--R                                                     Type: Expression Integer
--E 1

--S 2 of 9
function(expr, f, x)
--R 
--R
--R   (2)  f
--R                                                                 Type: Symbol
--E 2

--S 3 of 9
tbl := [f(0.1 * i - 1) for i in 0..20]
--R 
--R   Compiling function f with type Float -> Float 
--R
--R   (3)
--R   [0.0005391844 0362701574, 0.0039657551 1844206653,
--R    0.0088545187 4833983689 2, 0.0116524883 0907069695,
--R    0.0108618220 9245751364 5, 0.0076366823 2120869965 06,
--R    0.0040584985 7597822062 55, 0.0015349542 8910500836 48,
--R    0.0003424903 1549879905 716, 0.0000233304 8276098819 6001, 0.0,
--R    0.0000268186 8782862599 4229, 0.0004691571 3720051642 621,
--R    0.0026924576 5968519586 08, 0.0101486881 7369135148 8,
--R    0.0313833725 8543810564 3, 0.0876991144 5154615297 9,
--R    0.2313019789 3439968362, 0.5843743955 958098772, 1.4114930171 992819197,
--R    3.2216948276 75164252]
--R                                                             Type: List Float
--E 3

--S 4 of 9
e := (x - y + 1)^2 * (x^2 * y + 1)^2 
--R 
--R
--R   (4)
--R      4 4        5     4     2  3     6     5    4     3     2      2
--R     x y  + (- 2x  - 2x  + 2x )y  + (x  + 2x  + x  - 4x  - 4x  + 1)y
--R   + 
--R        4     3     2               2
--R     (2x  + 4x  + 2x  - 2x - 2)y + x  + 2x + 1
--R                                                     Type: Polynomial Integer
--E 4

--S 5 of 9
function(e, g, [x, y])
--R 
--R
--R   (5)  g
--R                                                                 Type: Symbol
--E 5

--S 6 of 9
function(e, h, x, y)
--R 
--R
--R   (6)  h
--R                                                                 Type: Symbol
--E 6

--S 7 of 9
m1 := squareMatrix [ [1, 2], [3, 4] ]
--R 
--R
--R        +1  2+
--R   (7)  |    |
--R        +3  4+
--R                                                Type: SquareMatrix(2,Integer)
--E 7

--S 8 of 9
m2 := squareMatrix [ [1, 0], [-1, 1] ]
--R 
--R
--R        + 1   0+
--R   (8)  |      |
--R        +- 1  1+
--R                                                Type: SquareMatrix(2,Integer)
--E 8

--S 9 of 9
h(m1, m2)
--R 
--R   Compiling function h with type (SquareMatrix(2,Integer),SquareMatrix
--R      (2,Integer)) -> SquareMatrix(2,Integer) 
--R
--R        +- 7836   8960 +
--R   (9)  |              |
--R        +- 17132  19588+
--R                                                Type: SquareMatrix(2,Integer)
--E 9
)spool
)lisp (bye)
@
<<MakeFunction.help>>=
====================================================================
MakeFunction examples
====================================================================

It is sometimes useful to be able to define a function given by
the result of a calculation.

Suppose that you have obtained the following expression after several
computations and that you now want to tabulate the numerical values of
f for x between -1 and +1 with increment 0.1.

  expr := (x - exp x + 1)^2 * (sin(x^2) * x + 1)^3
       3   x 2        4     3   x    5     4    3      2 3
     (x (%e )  + (- 2x  - 2x )%e  + x  + 2x  + x )sin(x )
   + 
        2   x 2        3     2   x     4     3     2      2 2
     (3x (%e )  + (- 6x  - 6x )%e  + 3x  + 6x  + 3x )sin(x )
   + 
            x 2        2        x     3     2           2       x 2
     (3x (%e )  + (- 6x  - 6x)%e  + 3x  + 6x  + 3x)sin(x ) + (%e )
   + 
                 x    2
     (- 2x - 2)%e  + x  + 2x + 1
                               Type: Expression Integer

You could, of course, use the function eval within a loop and evaluate
expr twenty-one times, but this would be quite slow.  A better way is
to create a numerical function f such that f(x) is defined by the
expression expr above, but without retyping expr!  The package
MakeFunction provides the operation function which does exactly this.

Issue this to create the function f(x) given by expr.

  function(expr, f, x)
    f
                               Type: Symbol

To tabulate expr, we can now quickly evaluate f 21 times.

  tbl := [f(0.1 * i - 1) for i in 0..20];
                               Type: List Float

Use the list [x1,...,xn] as the third argument to function to create a
multivariate function f(x1,...,xn).

  e := (x - y + 1)^2 * (x^2 * y + 1)^2 
      4 4        5     4     2  3     6     5    4     3     2      2
     x y  + (- 2x  - 2x  + 2x )y  + (x  + 2x  + x  - 4x  - 4x  + 1)y
   + 
        4     3     2               2
     (2x  + 4x  + 2x  - 2x - 2)y + x  + 2x + 1
                                Type: Polynomial Integer

  function(e, g, [x, y])
    g
                               Type: Symbol

In the case of just two variables, they can be given as arguments
without making them into a list.

  function(e, h, x, y)
    h
                               Type: Symbol

Note that the functions created by function are not limited to
floating point numbers, but can be applied to any type for which they
are defined.

  m1 := squareMatrix [ [1, 2], [3, 4] ]
    +1  2+
    |    |
    +3  4+
                               Type: SquareMatrix(2,Integer)

  m2 := squareMatrix [ [1, 0], [-1, 1] ]
    + 1   0+
    |      |
    +- 1  1+
                               Type: SquareMatrix(2,Integer)

  h(m1, m2)
    +- 7836   8960 +
    |              |
    +- 17132  19588+
                               Type: SquareMatrix(2,Integer)

See Also:
o )show MakeFunction
o $AXIOM/doc/src/algebra/mkfunc.spad.dvi

@
<<package MKFUNC MakeFunction>>=
)abbrev package MKFUNC MakeFunction
++ Tools for making interpreter functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 22 Nov 1988
++ Date Last Updated: 8 Jan 1990
++ Description: transforms top-level objects into interpreter functions.
MakeFunction(S:ConvertibleTo InputForm): Exports == Implementation where
  SY ==> Symbol

  Exports ==> with
    function: (S, SY         ) -> SY
      ++ function(e, foo) creates a function \spad{foo() == e}.
    function: (S, SY,      SY) -> SY
      ++ function(e, foo, x) creates a function \spad{foo(x) == e}.
    function: (S, SY, SY,  SY) -> SY
      ++ function(e, foo, x, y) creates a function \spad{foo(x, y) = e}.
    function: (S, SY, List SY) -> SY
      ++ \spad{function(e, foo, [x1,...,xn])} creates a function
      ++ \spad{foo(x1,...,xn) == e}.

  Implementation ==> add
    function(s, name)            == function(s, name, nil())
    function(s:S, name:SY, x:SY) == function(s, name, [x])
    function(s, name, x, y)      == function(s, name, [x, y])

    function(s:S, name:SY, args:List SY) ==
      interpret function(convert s, args, name)$InputForm
      name

@
\section{package MKUCFUNC MakeUnaryCompiledFunction}
<<package MKUCFUNC MakeUnaryCompiledFunction>>=
)abbrev package MKUCFUNC MakeUnaryCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 1 Dec 1988
++ Date Last Updated: 5 Mar 1990
++ Description: transforms top-level objects into compiled functions.
MakeUnaryCompiledFunction(S, D, I): Exports == Implementation where
  S: ConvertibleTo InputForm
  D, I: Type

  SY  ==> Symbol
  DI  ==> devaluate(D -> I)$Lisp

  Exports ==> with
    unaryFunction   : SY -> (D -> I)
      ++ unaryFunction(a) is a local function
    compiledFunction: (S, SY) -> (D -> I)
      ++ compiledFunction(expr, x) returns a function \spad{f: D -> I}
      ++ defined by \spad{f(x) == expr}. 
      ++ Function f is compiled and directly
      ++ applicable to objects of type D.

  Implementation ==> add
    import MakeFunction(S)

    func: (SY, D) -> I

    func(name, x)       == FUNCALL(name, x, NIL$Lisp)$Lisp
    unaryFunction name  == func(name, #1)

    compiledFunction(e:S, x:SY) ==
      t := [convert([devaluate(D)$Lisp]$List(InputForm))
           ]$List(InputForm)
      unaryFunction compile(function(e, declare DI, x), t)

@
\section{package MKBCFUNC MakeBinaryCompiledFunction}
<<package MKBCFUNC MakeBinaryCompiledFunction>>=
)abbrev package MKBCFUNC MakeBinaryCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 1 Dec 1988
++ Date Last Updated: 5 Mar 1990
++ Description: transforms top-level objects into compiled functions.
MakeBinaryCompiledFunction(S, D1, D2, I):Exports == Implementation where
  S: ConvertibleTo InputForm
  D1, D2, I: Type

  SY  ==> Symbol
  DI  ==> devaluate((D1, D2) -> I)$Lisp

  Exports ==> with
    binaryFunction  : SY -> ((D1, D2) -> I)
      ++ binaryFunction(s) is a local function
    compiledFunction: (S, SY, SY) -> ((D1, D2) -> I)
      ++ compiledFunction(expr,x,y) returns a function \spad{f: (D1, D2) -> I}
      ++ defined by \spad{f(x, y) == expr}.
      ++ Function f is compiled and directly
      ++ applicable to objects of type \spad{(D1, D2)}

  Implementation ==> add
    import MakeFunction(S)

    func: (SY, D1, D2) -> I

    func(name, x, y)   == FUNCALL(name, x, y, NIL$Lisp)$Lisp
    binaryFunction name == func(name, #1, #2)

    compiledFunction(e, x, y) ==
      t := [devaluate(D1)$Lisp, devaluate(D2)$Lisp]$List(InputForm)
      binaryFunction compile(function(e, declare DI, x, y), t)

@
\section{package MKFLCFN MakeFloatCompiledFunction}
<<package MKFLCFN MakeFloatCompiledFunction>>=
)abbrev package MKFLCFN MakeFloatCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 2 Mar 1990
++ Date Last Updated: 2 Dec 1996 (MCD)
++ Description:
++ MakeFloatCompiledFunction transforms top-level objects into
++ compiled Lisp functions whose arguments are Lisp floats.
++ This by-passes the \Language{} compiler and interpreter,
++ thereby gaining several orders of magnitude.
MakeFloatCompiledFunction(S): Exports == Implementation where
  S: ConvertibleTo InputForm

  INF ==> InputForm
  SF  ==> DoubleFloat
  DI1 ==> devaluate(SF -> SF)$Lisp
  DI2 ==> devaluate((SF, SF) -> SF)$Lisp

  Exports ==> with
    makeFloatFunction: (S, Symbol)         -> (SF -> SF)
      ++ makeFloatFunction(expr, x) returns a Lisp function
      ++ \spad{f: \axiomType{DoubleFloat} -> \axiomType{DoubleFloat}}
      ++ defined by \spad{f(x) == expr}. 
      ++ Function f is compiled and directly
      ++ applicable to objects of type \axiomType{DoubleFloat}.
    makeFloatFunction: (S, Symbol, Symbol) -> ((SF, SF) -> SF)
      ++ makeFloatFunction(expr, x, y) returns a Lisp function
      ++ \spad{f: (\axiomType{DoubleFloat}, \axiomType{DoubleFloat}) -> \axiomType{DoubleFloat}}
      ++ defined by \spad{f(x, y) == expr}.
      ++ Function f is compiled and directly
      ++ applicable to objects of type \spad{(\axiomType{DoubleFloat}, \axiomType{DoubleFloat})}.

  Implementation ==> add
    import MakeUnaryCompiledFunction(S, SF, SF)
    import MakeBinaryCompiledFunction(S, SF, SF, SF)

    streq?    : (INF, String) -> Boolean
    streqlist?: (INF, List String) -> Boolean
    gencode   : (String, List INF) -> INF
    mkLisp    : INF -> Union(INF, "failed")
    mkLispList: List INF -> Union(List INF, "failed")
    mkDefun   : (INF, List INF) -> INF
    mkLispCall: INF -> INF
    mkPretend : INF -> INF
    mkCTOR : INF -> INF

    lsf := convert([convert("DoubleFloat"::Symbol)@INF]$List(INF))@INF

    streq?(s, st)    == s = convert(st::Symbol)@INF
    gencode(s, l)    == convert(concat(convert(s::Symbol)@INF, l))@INF
    streqlist?(s, l) == member?(string symbol s, l)

    mkPretend form ==
      convert([convert("pretend"::Symbol), form, lsf]$List(INF))@INF

    mkCTOR form ==
      convert([convert("C-TO-R"::Symbol), form]$List(INF))@INF


    mkLispCall name ==
      convert([convert("$elt"::Symbol),
                           convert("Lisp"::Symbol), name]$List(INF))@INF

    mkDefun(s, lv) ==
      name := convert(new()$Symbol)@INF
      fun  := convert([convert("DEFUN"::Symbol), name, convert lv,
              gencode("DECLARE",[gencode("FLOAT",lv)]),mkCTOR s]$List(INF))@INF
      EVAL(fun)$Lisp
      if _$compileDontDefineFunctions$Lisp then COMPILE(name)$Lisp
      name

    makeFloatFunction(f, x, y) ==
      (u := mkLisp(convert(f)@INF)) case "failed" =>
        compiledFunction(f, x, y)
      name := mkDefun(u::INF, [ix := convert x, iy := convert y])
      t    := [lsf, lsf]$List(INF)
      spadname := declare DI2
      spadform:=mkPretend convert([mkLispCall name,ix,iy]$List(INF))@INF
      interpret function(spadform, [x, y], spadname)
      binaryFunction compile(spadname, t)

    makeFloatFunction(f, var) ==
      (u := mkLisp(convert(f)@INF)) case "failed" =>
        compiledFunction(f, var)
      name := mkDefun(u::INF, [ivar := convert var])
      t    := [lsf]$List(INF)
      spadname := declare DI1
      spadform:= mkPretend convert([mkLispCall name,ivar]$List(INF))@INF
      interpret function(spadform, [var], spadname)
      unaryFunction compile(spadname, t)

    mkLispList l ==
      ans := nil()$List(INF)
      for s in l repeat
        (u := mkLisp s) case "failed" => return "failed"
        ans := concat(u::INF, ans)
      reverse_! ans
    

    mkLisp s ==
      atom? s => s
      op := first(l := destruct s)
      (u := mkLispList rest l) case "failed" => "failed"
      ll := u::List(INF)
      streqlist?(op, ["+","*","/","-"]) => convert(concat(op, ll))@INF
      streq?(op, "**") => gencode("EXPT", ll)
      streqlist?(op, ["exp","sin","cos","tan","atan", 
         "log", "sinh","cosh","tanh","asinh","acosh","atanh","sqrt"]) =>
            gencode(upperCase string symbol op, ll)
      streq?(op, "nthRoot") =>
        second ll = convert(2::Integer)@INF =>gencode("SQRT",[first ll])
        gencode("EXPT", concat(first ll, [1$INF / second ll]))
      streq?(op, "float") =>
        a := ll.1
        e := ll.2
        b := ll.3
        _*(a, EXPT(b, e)$Lisp)$Lisp pretend INF
      "failed"

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package INFORM1 InputFormFunctions1>>
<<package MKFUNC MakeFunction>>
<<package MKUCFUNC MakeUnaryCompiledFunction>>
<<package MKBCFUNC MakeBinaryCompiledFunction>>
<<package MKFLCFN MakeFloatCompiledFunction>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
