\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra cycles.spad}
\author{William Burge}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package CYCLES CycleIndicators}
<<CycleIndicators.input>>=
-- cycles.spad.pamphlet CycleIndicators.input
)spool CycleIndicators.output
)set message test on
)set message auto off
)clear all
--S 1 of 47
complete 1
--R 
--R
--R   (1)  (1)
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 1

--S 2 of 47
complete 2
--R 
--R
--R        1       1   2
--R   (2)  - (2) + - (1 )
--R        2       2
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 2

--S 3 of 47
complete 3
--R 
--R
--R        1       1         1   3
--R   (3)  - (3) + - (2 1) + - (1 )
--R        3       2         6
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 3

--S 4 of 47
complete 7
--R 
--R
--R   (4)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R      1      5      1    7
--R     --- (2 1 ) + ---- (1 )
--R     240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 4

--S 5 of 47
elementary 7
--R 
--R
--R   (5)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R        1      5      1    7
--R     - --- (2 1 ) + ---- (1 )
--R       240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 5

--S 6 of 47
alternating 7
--R 
--R
--R   (6)
--R     2       1     2    1           1   2      1     2     1     4     1   2 3
--R     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
--R     7       5          4           9         12          36          24
--R   + 
--R       1    7
--R     ---- (1 )
--R     2520
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 6

--S 7 of 47
cyclic 7
--R 
--R
--R        6       1   7
--R   (7)  - (7) + - (1 )
--R        7       7
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 7

--S 8 of 47
dihedral 7
--R 
--R
--R        3       1   3      1   7
--R   (8)  - (7) + - (2 1) + -- (1 )
--R        7       2         14
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 8

--S 9 of 47
graphs 5
--R 
--R
--R   (9)
--R   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
--R   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
--R   6           5        4         6         8          12          120
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 9

--S 10 of 47
cap(complete 2**2, complete 2*complete 1**2)
--R 
--R
--R   (10)  4
--R                                                       Type: Fraction Integer
--E 10

--S 11 of 47
cap(elementary 2**2, complete 2*complete 1**2)
--R 
--R
--R   (11)  2
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 47
cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
--R 
--R
--R   (12)  24
--R                                                       Type: Fraction Integer
--E 12

--S 13 of 47
cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
--R 
--R
--R   (13)  8
--R                                                       Type: Fraction Integer
--E 13

--S 14 of 47
cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
--R 
--R
--R   (14)  8
--R                                                       Type: Fraction Integer
--E 14

--S 15 of 47
eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
--R 
--R
--R   (15)  1500
--R                                                       Type: Fraction Integer
--E 15

--S 16 of 47
square:=dihedral 4
--R 
--R
--R         1       3   2    1     2    1   4
--R   (16)  - (4) + - (2 ) + - (2 1 ) + - (1 )
--R         4       8        4          8
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 16

--S 17 of 47
cap(complete 2**2,square)
--R 
--R
--R   (17)  2
--R                                                       Type: Fraction Integer
--E 17

--S 18 of 47
cap(complete 3*complete 2**2,dihedral 7)
--R 
--R
--R   (18)  18
--R                                                       Type: Fraction Integer
--E 18

--S 19 of 47
cap(graphs 5,complete 7*complete 3)
--R 
--R
--R   (19)  4
--R                                                       Type: Fraction Integer
--E 19

--S 20 of 47
s(x) == powerSum(x)
--R 
--R                                                                   Type: Void
--E 20

--S 21 of 47
cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
--R 
--R   Compiling function s with type PositiveInteger -> 
--R      SymmetricPolynomial Fraction Integer 
--R
--R         1   2    1   2 2    3   4     1   8
--R   (21)  - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
--R         4        3          8        24
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 21

--S 22 of 47
cap(complete 4**2,cube)
--R 
--R
--R   (22)  7
--R                                                       Type: Fraction Integer
--E 22

--S 23 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
--R 
--R
--R   (23)  7
--R                                                       Type: Fraction Integer
--E 23

--S 24 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
--R 
--R
--R   (24)  17
--R                                                       Type: Fraction Integer
--E 24

--S 25 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
--R 
--R
--R   (25)  10
--R                                                       Type: Fraction Integer
--E 25

--S 26 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
--R 
--R
--R   (26)  23
--R                                                       Type: Fraction Integer
--E 26

--S 27 of 47
x: ULS(FRAC INT,'x,0) := 'x 
--R 
--R
--R   (27)  x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 27

--S 28 of 47
ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 28

--S 29 of 47
Integers: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 29

--S 30 of 47
ZeroOrOne n == 1+x**n
--R 
--R                                                                   Type: Void
--E 30

--S 31 of 47
ZeroOrOne 5 
--R 
--R   Compiling function ZeroOrOne with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5
--R   (31)  1 + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 31

--S 32 of 47
Integers n == 1/(1-x**n) 
--R 
--R                                                                   Type: Void
--E 32

--S 33 of 47
Integers 5 
--R 
--R   Compiling function Integers with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5    10      11
--R   (33)  1 + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 33

--S 34 of 47
)expose EVALCYC
--R 
--I   EvaluateCycleIndicators is now explicitly exposed in frame frame0 
--E 34

--S 35 of 47
eval(ZeroOrOne, graphs 5) 
--R 
--R
--R                   2     3     4     5     6     7     8    9    10      11
--R   (34)  1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 35

--S 36 of 47
eval(ZeroOrOne,dihedral 8) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (35)  1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 36

--S 37 of 47
eval(Integers,complete 4) 
--R 
--R
--R   (36)
--R             2     3     4     5     6      7      8      9      10      11
--R   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 37

--S 38 of 47
eval(Integers,elementary 4)
--R 
--R
--R   (37)
--R      6    7     8     9     10     11     12      13      14      15      16
--R     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
--R   + 
--R        17
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 38

--S 39 of 47
eval(ZeroOrOne,cube) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (38)  1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 39

--S 40 of 47
eval(Integers,cube) 
--R 
--R
--R   (39)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 40

--S 41 of 47
eval(Integers,graphs 5) 
--R 
--R
--R   (40)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 41

--S 42 of 47
eval(ZeroOrOne ,graphs 15) 
--R 
--R
--R   (41)
--R               2     3      4      5      6       7       8        9        10
--R     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 42

--S 43 of 47
cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
--R 
--R
--R   (42)  49958972383320
--R                                                       Type: Fraction Integer
--E 43

--S 44 of 47
sf3221:= SFunction [3,2,2,1] 
--R 
--R
--R   (43)
--R      1          1     2     1   2     1            1     4     1   2
--R     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
--R     12         12          16        12           24          36
--R   + 
--R      1   2 2     1     2      1       3     1     5     1    4     1   3 2
--R     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
--R     36          24           36            72          192        48
--R   + 
--R      1   2 4     1      6     1    8
--R     -- (2 1 ) - --- (2 1 ) + --- (1 )
--R     96          144          576
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 44

--S 45 of 47
cap(sf3221,complete 2**4) 
--R 
--R
--R   (44)  3
--R                                                       Type: Fraction Integer
--E 45

--S 46 of 47
cap(sf3221, powerSum 1**8)
--R 
--R
--R   (45)  70
--R                                                       Type: Fraction Integer
--E 46

--S 47 of 47
eval(Integers, sf3221)
--R 
--R
--R   (46)
--R      9     10     11      12      13      14      15       16       17       18
--R     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x   + 294x
--R   + 
--R         19      20
--R     432x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 47
)spool
)lisp (bye)
@
<<CycleIndicators.help>>=
====================================================================
CycleIndicators examples
====================================================================

This section is based upon the paper J. H. Redfield, ``The Theory of
Group-Reduced Distributions'', American J. Math.,49 (1927) 433-455,
and is an application of group theory to enumeration problems.  It is
a development of the work by P. A. MacMahon on the application of
symmetric functions and Hammond operators to combinatorial theory.

The theory is based upon the power sum symmetric functions s(i) which
are the sum of the i-th powers of the variables.  The cycle index of a
permutation is an expression that specifies the sizes of the cycles of
a permutation, and may be represented as a partition.  A partition of
a non-negative integer n is a collection of positive integers called
its parts whose sum is n.  For example, the partition (3^2 2 1^2) will
be used to represent s^2_3 s_2 s^2_1 and will indicate that the
permutation has two cycles of length 3, one of length 2 and two of
length 1.  The cycle index of a permutation group is the sum of the
cycle indices of its permutations divided by the number of
permutations.  The cycle indices of certain groups are provided.

The operation complete returns the cycle index of the symmetric group
of order n for argument n.  Alternatively, it is the n-th complete
homogeneous symmetric function expressed in terms of power sum
symmetric functions.

  complete 1
   (1)
                      Type: SymmetricPolynomial Fraction Integer

  complete 2
   1       1   2
   - (2) + - (1 )
   2       2
                      Type: SymmetricPolynomial Fraction Integer

  complete 3
   1       1         1   3
   - (3) + - (2 1) + - (1 )
   3       2         6
                      Type: SymmetricPolynomial Fraction Integer

  complete 7
     1       1          1          1     2     1         1            1     3
     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
      1      5      1    7
     --- (2 1 ) + ---- (1 )
     240          5040
                   Type: SymmetricPolynomial Fraction Integer

The operation elementary computes the n-th elementary symmetric
function for argument n.

  elementary 7
     1       1          1          1     2     1         1            1     3
     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
        1      5      1    7
     - --- (2 1 ) + ---- (1 )
       240          5040
                  Type: SymmetricPolynomial Fraction Integer

The operation alternating returns the cycle index of the alternating 
group having an even number of even parts in each cycle partition.

  alternating 7
     2       1     2    1           1   2      1     2     1     4     1   2 3
     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
     7       5          4           9         12          36          24
   + 
       1    7
     ---- (1 )
     2520
                  Type: SymmetricPolynomial Fraction Integer

The operation cyclic returns the cycle index of the cyclic group.

  cyclic 7
   6       1   7
   - (7) + - (1 )
   7       7
                  Type: SymmetricPolynomial Fraction Integer

The operation dihedral is the cycle index of the dihedral group.

  dihedral 7
   3       1   3      1   7
   - (7) + - (2 1) + -- (1 )
   7       2         14
                  Type: SymmetricPolynomial Fraction Integer

The operation graphs for argument n returns the cycle index of the
group of permutations on the edges of the complete graph with n nodes
induced by applying the symmetric group to the nodes.

  graphs 5
   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
   6           5        4         6         8          12          120
                  Type: SymmetricPolynomial Fraction Integer

The cycle index of a direct product of two groups is the product of
the cycle indices of the groups.  Redfield provided two operations on
two cycle indices which will be called "cup" and "cap" here.  The cup
of two cycle indices is a kind of scalar product that combines
monomials for permutations with the same cycles.  The cap operation
provides the sum of the coefficients of the result of the cup
operation which will be an integer that enumerates what Redfield
called group-reduced distributions.

We can, for example, represent complete 2 * complete 2 as the set of
objects a a b b and complete 2 * complete 1 * complete 1 as c c d e.

This integer is the number of different sets of four pairs.

  cap(complete 2**2, complete 2*complete 1**2)
    4
                  Type: Fraction Integer

For example,
  a a b b     a a b b    a a b b   a a b b
  c c d e     c d c e    c e c d   d e c c

This integer is the number of different sets of four pairs no two
pairs being equal.

  cap(elementary 2**2, complete 2*complete 1**2)
    2
                  Type: Fraction Integer

For example,

  a a b b    a a b b
  c d c e    c e c d

In this case the configurations enumerated are easily constructed,
however the theory merely enumerates them providing little help in
actually constructing them.

Here are the number of 6-pairs, first from a a a b b c, second
from d d e e f g.

  cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
    24
                     Type: Fraction Integer

Here it is again, but with no equal pairs.

  cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
    8
                     Type: Fraction Integer

  cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
    8
                     Type: Fraction Integer

The number of 6-triples, first from a a a b b c, second from
d d e e f g, third from h h i i j j.

  eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
    1500
                     Type: Fraction Integer

The cycle index of vertices of a square is dihedral 4.

  square:=dihedral 4
   1       3   2    1     2    1   4
   - (4) + - (2 ) + - (2 1 ) + - (1 )
   4       8        4          8
                     Type: SymmetricPolynomial Fraction Integer

The number of different squares with 2 red vertices and 2 blue vertices.

  cap(complete 2**2,square)
    2
                     Type: Fraction Integer

The number of necklaces with 3 red beads, 2 blue beads and 2 green beads.

  cap(complete 3*complete 2**2,dihedral 7)
    18
                     Type: Fraction Integer

The number of graphs with 5 nodes and 7 edges.

  cap(graphs 5,complete 7*complete 3)
    4
                     Type: Fraction Integer

The cycle index of rotations of vertices of a cube.

  s(x) == powerSum(x)
                     Type: Void

  cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
   1   2    1   2 2    3   4     1   8
   - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
   4        3          8        24
                     Type: SymmetricPolynomial Fraction Integer

The number of cubes with 4 red vertices and 4 blue vertices.

  cap(complete 4**2,cube)
    7
                     Type: Fraction Integer

The number of labeled graphs with degree sequence 2 2 2 1 1 with no 
loops or multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
    7
                     Type: Fraction Integer

Again, but with loops allowed but not multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
    17
                     Type: Fraction Integer

Again, but with multiple edges allowed, but not loops

  cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
    10
                     Type: Fraction Integer

Again, but with both multiple edges and loops allowed

  cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
    23
                     Type: Fraction Integer

Having constructed a cycle index for a configuration we are at liberty
to evaluate the s_i components any way we please.  For example we can
produce enumerating generating functions.  This is done by providing a
function f on an integer i to the value required of s_i, and then
evaluating eval(f, cycleindex).

  x: ULS(FRAC INT,'x,0) := 'x 
   x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

  ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

  Integers: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

For the integers 0 and 1, or two colors.

  ZeroOrOne n == 1+x**n
                     Type: Void

  ZeroOrOne 5 
         5
    1 + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

For the integers 0, 1, 2, ... we have this.

  Integers n == 1/(1-x**n) 
                     Type: Void

  Integers 5 
         5    10      11
    1 + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and n edges. 

Note that there is an eval function that takes two arguments. It has the 
signature:

  ((Integer -> D1),SymmetricPolynomial Fraction Integer) -> D1
    from EvaluateCycleIndicators D1 if D1 has ALGEBRA FRAC INT

This function is not normally exposed (it will not normally be considered
in the list of eval functions) as it is only useful for this particular
domain. To use it we ask that it be considered thus:

  )expose EVALCYC

and now we can use it:

  eval(ZeroOrOne, graphs 5) 
              2     3     4     5     6     7     8    9    10      11
    1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of necklaces with n red beads 
and n-8 green beads.

  eval(ZeroOrOne,dihedral 8) 
              2     3     4     5     6    7    8
    1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 or fewer parts.

  eval(Integers,complete 4) 
             2     3     4     5     6      7      8      9      10      11
   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 boxes
containing ordered distinct parts.

  eval(Integers,elementary 4)
      6    7     8     9     10     11     12      13      14      15      16
     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
   + 
        17
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with n red
vertices and 8-n green ones.

  eval(ZeroOrOne,cube) 
              2     3     4     5     6    7    8
    1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with integers
on the vertices whose sum is n.

  eval(Integers,cube) 
               2     3      4      5      6       7       8       9       10
     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
   + 
        11
     O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and with
integers on the edges whose sum is n.  In other words, the enumeration
is of multigraphs with 5 nodes and n edges.

  eval(Integers,graphs 5) 
               2     3      4      5      6       7       8       9       10
     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Graphs with 15 nodes enumerated with respect to number of edges.

  eval(ZeroOrOne ,graphs 15) 
               2     3      4      5      6       7       8        9        10
     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Necklaces with 7 green beads, 8 white beads, 5 yellow beads and 10
red beads.

  cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
    49958972383320
                     Type: Fraction Integer

The operation SFunction is the S-function or Schur function of a
partition written as a descending list of integers expressed in terms
of power sum symmetric functions.

In this case the argument partition represents a tableau shape.  For
example 3,2,2,1 represents a tableau with three boxes in the first
row, two boxes in the second and third rows, and one box in the fourth
row.  SFunction [3,2,2,1] counts the number of different tableaux of
shape 3, 2, 2, 1 filled with objects with an ascending order in the
columns and a non-descending order in the rows.

  sf3221:= SFunction [3,2,2,1] 
      1          1     2     1   2     1            1     4     1   2
     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
     12         12          16        12           24          36
   + 
      1   2 2     1     2      1       3     1     5     1    4     1   3 2
     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
     36          24           36            72          192        48
   + 
      1   2 4     1      6     1    8
     -- (2 1 ) - --- (2 1 ) + --- (1 )
     96          144          576
                     Type: SymmetricPolynomial Fraction Integer

This is the number filled with a a b b c c d d.

  cap(sf3221,complete 2**4) 
    3
                     Type: Fraction Integer

The configurations enumerated above are:

  a a b    a a c    a a d
  b c      b b      b b
  c d      c d      c c
  d        d        d

This is the number of tableaux filled with 1..8.

  cap(sf3221, powerSum 1**8)
    70
                     Type: Fraction Integer

The coefficient of x^n is the number of column strict reverse plane
partitions of n of shape 3 2 2 1.

  eval(Integers, sf3221)
      9     10     11      12      13      14      15       16       17
     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x  
   + 
        18      19      20
    294x  + 432x   + O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The smallest is

  0 0 0
  1 1
  2 2
  3

See Also:
o )show CycleIndicators
o $AXIOM/doc/src/algebra/cycles.spad.dvi

@
<<package CYCLES CycleIndicators>>=
)abbrev package CYCLES CycleIndicators
++ Polya-Redfield enumeration by cycle indices.
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: 11 Feb 1992
++ Keywords:Polya, Redfield, enumeration
++ Examples:
++ References: J.H.Redfield, 'The Theory of Group-Reduced Distributions',
++             American J. Math., 49 (1927) 433-455.
++             G.Polya, 'Kombinatorische Anzahlbestimmungen fur Gruppen,
++               Graphen und chemische Verbindungen', Acta Math. 68
++                (1937) 145-254.
++ Description: Enumeration by cycle indices. 
CycleIndicators: Exports == Implementation where
  I    ==> Integer
  L    ==> List
  B    ==> Boolean
  SPOL ==> SymmetricPolynomial
  PTN  ==> Partition
  RN   ==> Fraction Integer
  FR   ==> Factored Integer
  h ==> complete
  s ==> powerSum
  --a ==> elementary
  alt ==> alternating
  cyc ==> cyclic
  dih ==> dihedral
  ev == eval
  Exports ==> with
 
    complete: I -> SPOL RN
      ++\spad{complete n} is the \spad{n} th complete homogeneous
      ++ symmetric function expressed in terms of power sums.
      ++ Alternatively it is the cycle index of the symmetric
      ++ group of degree n.
 
    powerSum: I -> SPOL RN
      ++\spad{powerSum n} is the \spad{n} th power sum symmetric
      ++ function.
 
    elementary: I -> SPOL RN
      ++\spad{elementary n} is the \spad{n} th elementary symmetric
      ++ function expressed in terms of power sums.
 
 -- s2h: I -> SPOL RN--s to h
 
    alternating: I -> SPOL RN
      ++\spad{alternating n} is the cycle index of the
      ++ alternating group of degree n.
 
    cyclic: I -> SPOL RN    --cyclic group
      ++\spad{cyclic n} is the cycle index of the
      ++ cyclic group of degree n.
 
    dihedral: I -> SPOL RN    --dihedral group
      ++\spad{dihedral n} is the cycle index of the
      ++ dihedral group of degree n.
 
    graphs: I -> SPOL RN
      ++\spad{graphs n} is the cycle index of the group induced on
      ++ the edges of a graph by applying the symmetric function to the
      ++ n nodes.
 
    cap: (SPOL RN,SPOL RN) -> RN
      ++\spad{cap(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices.
 
    cup: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{cup(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices, in which the
      ++ power sums are retained to produce a cycle index.
 
    eval: SPOL RN -> RN
      ++\spad{eval s} is the sum of the coefficients of a cycle index.
 
    wreath: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{wreath(s1,s2)} is the cycle index of the wreath product
      ++ of the two groups whose cycle indices are \spad{s1} and
      ++ \spad{s2}.
 
    SFunction:L I -> SPOL RN
      ++\spad{SFunction(li)} is the S-function of the partition \spad{li}
      ++ expressed in terms of power sum symmetric functions.
 
    skewSFunction:(L I,L I) -> SPOL RN
      ++\spad{skewSFunction(li1,li2)} is the S-function
      ++ of the partition difference \spad{li1 - li2}
      ++ expressed in terms of power sum symmetric functions.
 
  Implementation ==> add
    import PartitionsAndPermutations
    import IntegerNumberTheoryFunctions
 
    trm: PTN -> SPOL RN
    trm pt == monomial(inv(pdct(pt) :: RN),pt)
 
    list: Stream L I -> L L I
    list st == entries complete st
 
    complete i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                   _+/[trm(partition pt) for pt in list(partitions i)]
 
 
    even?: L I -> B
    even? li == even?( #([i for i in li | even? i]))
 
    alt i ==
      2 * _+/[trm(partition li) for li in list(partitions i) | even? li]
    elementary i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                  _+/[(spol := trm(partition pt); even? pt => spol; -spol)
                          for pt in list(partitions i)]
 
    divisors: I -> L I
    divisors n ==
      b := factors(n :: FR)
      c := concat(1,"append"/
                 [[a.factor**j for j in 1..a.exponent] for a in b]);
      if #(b) = 1 then c else concat(n,c)
 
    ss: (I,I) -> SPOL RN
    ss(n,m) ==
      li : L I := [n for j in 1..m]
      monomial(1,partition li)
 
    s n == ss(n,1)
 
    cyc n ==
      n = 1 => s 1
      _+/[(eulerPhi(i) / n) * ss(i,numer(n/i)) for i in divisors n]
 
    dih n ==
      k := n quo 2
      odd? n => (1/2) * cyc n + (1/2) * ss(2,k) * s 1
      (1/2) * cyc n + (1/4) * ss(2,k) + (1/4) * ss(2,k-1) * ss(1,2)
 
    trm2: L I -> SPOL RN
    trm2 li ==
      lli := powers(li)$PTN
      xx := 1/(pdct partition li)
      prod : SPOL RN := 1
      for ll in lli repeat
        ll0 := first ll; ll1 := second ll
        k := ll0 quo 2
        c :=
          odd? ll0 => ss(ll0,ll1 * k)
          ss(k,ll1) * ss(ll0,ll1 * (k - 1))
        c := c * ss(ll0,ll0 * ((ll1*(ll1 - 1)) quo 2))
        prod2 : SPOL RN := 1
        for r in lli | first(r) < ll0 repeat
          r0 := first r; r1 := second r
          prod2 := ss(lcm(r0,ll0),gcd(r0,ll0) * r1 * ll1) * prod2
        prod := c * prod2 * prod
      xx * prod
 
    graphs n == _+/[trm2 li for li in list(partitions n)]
 
    cupp: (PTN,SPOL RN) -> SPOL RN
    cupp(pt,spol) ==
      zero? spol => 0
      (dg := degree spol) < pt => 0
      dg = pt => (pdct pt) * monomial(leadingCoefficient spol,dg)
      cupp(pt,reductum spol)
 
    cup(spol1,spol2) ==
      zero? spol1 => 0
      p := leadingCoefficient(spol1) * cupp(degree spol1,spol2)
      p + cup(reductum spol1,spol2)
 
    ev spol ==
      zero? spol => 0
      leadingCoefficient(spol) + ev(reductum spol)
 
    cap(spol1,spol2) == ev cup(spol1,spol2)
 
    mtpol: (I,SPOL RN) -> SPOL RN
    mtpol(n,spol)==
      zero? spol => 0
      deg := partition [n*k for k in (degree spol)::L(I)]
      monomial(leadingCoefficient spol,deg) + mtpol(n,reductum spol)
 
    fn2: I -> SPOL RN
    evspol: ((I -> SPOL RN),SPOL RN) -> SPOL RN
    evspol(fn2,spol) ==
      zero? spol => 0
      lc := leadingCoefficient spol
      prod := _*/[fn2 i for i in (degree spol)::L(I)]
      lc * prod + evspol(fn2,reductum spol)
 
    wreath(spol1,spol2) == evspol(mtpol(#1,spol2),spol1)
 
    hh: I -> SPOL RN      --symmetric group
    hh n == if n=0 then 1 else if n<0 then 0 else h n
    SFunction li==
      a:Matrix SPOL RN:=matrix [[hh(k -j+i) for k in li for j in 1..#li]
                    for i in 1..#li]
      determinant a
 
    roundup:(L I,L I)-> L I
    roundup(li1,li2)==
              #li1 > #li2 => roundup(li1,concat(li2,0))
              li2
 
    skewSFunction(li1,li2)==
      #li1 < #li2 =>
        error "skewSFunction: partition1 does not include partition2"
      li2:=roundup (li1,li2)
      a:Matrix SPOL RN:=matrix [[hh(k-li2.i-j+i)
               for k in li1 for j in 1..#li1]  for i in 1..#li1]
      determinant a

@
\section{package EVALCYC EvaluateCycleIndicators}
<<package EVALCYC EvaluateCycleIndicators>>=
)abbrev package EVALCYC EvaluateCycleIndicators
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: Feb 1992
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: This package is to be used in conjuction with
++             the CycleIndicators package. It provides an evaluation
++             function for SymmetricPolynomials.
EvaluateCycleIndicators(F):T==C where
    F:Algebra Fraction Integer
    I==>Integer
    L==>List
    SPOL==SymmetricPolynomial
    RN==>Fraction Integer
    PR==>Polynomial(RN)
    PTN==>Partition()
    lc ==> leadingCoefficient
    red ==> reductum
    T== with
       eval:((I->F),SPOL RN)->F
         ++\spad{eval(f,s)} evaluates the cycle index s by applying
         ++ the function f to each integer in a monomial partition,
         ++ forms their product and sums the results over all monomials.
    C== add
       evp:((I->F),PTN)->F
       fn:I->F
       pt:PTN
       spol:SPOL RN
       i:I
       evp(fn, pt)== _*/[fn i for i in pt::(L I)]
 
       eval(fn,spol)==
        if spol=0
        then 0
        else ((lc spol)* evp(fn,degree spol)) + eval(fn,red spol)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package CYCLES CycleIndicators>>
<<package EVALCYC EvaluateCycleIndicators>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
