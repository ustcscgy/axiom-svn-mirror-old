\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra sets.spad}
\author{Michael Monagan, Richard Jenks}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain SET Set}
<<Set.input>>=
-- sets.spad.pamphlet Set.input
)spool Set.output
)set message test on
)set message auto off
)clear all
--S 1 of 20
s := set [x**2-1, y**2-1, z**2-1]
--R 
--R
--R          2      2      2
--R   (1)  {x  - 1,y  - 1,z  - 1}
--R                                                 Type: Set Polynomial Integer
--E 1

--S 2 of 20
t := set [x**i - i+1 for i in 2..10 | prime? i]
--R 
--R
--R          2      3      5      7
--R   (2)  {x  - 1,x  - 2,x  - 4,x  - 6}
--R                                                 Type: Set Polynomial Integer
--E 2

--S 3 of 20
i := intersect(s,t)
--R 
--R
--R          2
--R   (3)  {x  - 1}
--R                                                 Type: Set Polynomial Integer
--E 3

--S 4 of 20
u := union(s,t)
--R 
--R
--R          2      3      5      7      2      2
--R   (4)  {x  - 1,x  - 2,x  - 4,x  - 6,y  - 1,z  - 1}
--R                                                 Type: Set Polynomial Integer
--E 4

--S 5 of 20
difference(s,t)
--R 
--R
--R          2      2
--R   (5)  {y  - 1,z  - 1}
--R                                                 Type: Set Polynomial Integer
--E 5

--S 6 of 20
symmetricDifference(s,t)
--R 
--R
--R          3      5      7      2      2
--R   (6)  {x  - 2,x  - 4,x  - 6,y  - 1,z  - 1}
--R                                                 Type: Set Polynomial Integer
--E 6

--S 7 of 20
member?(y, s)
--R 
--R
--R   (7)  false
--R                                                                Type: Boolean
--E 7

--S 8 of 20
member?((y+1)*(y-1), s)
--R 
--R
--R   (8)  true
--R                                                                Type: Boolean
--E 8

--S 9 of 20
subset?(i, s)
--R 
--R
--R   (9)  true
--R                                                                Type: Boolean
--E 9

--S 10 of 20
subset?(u, s)
--R 
--R
--R   (10)  false
--R                                                                Type: Boolean
--E 10

--S 11 of 20
gs := set [g for i in 1..11 | primitive?(g := i::PF 11)] 
--R 
--R
--R   (11)  {2,6,7,8}
--R                                                      Type: Set PrimeField 11
--E 11

--S 12 of 20
complement gs 
--R 
--R
--R   (12)  {1,3,4,5,9,10,0}
--R                                                      Type: Set PrimeField 11
--E 12

--S 13 of 20
a := set [i**2 for i in 1..5]
--R 
--R
--R   (13)  {1,4,9,16,25}
--R                                                    Type: Set PositiveInteger
--E 13

--S 14 of 20
insert!(32, a)
--R 
--R
--R   (14)  {1,4,9,16,25,32}
--R                                                    Type: Set PositiveInteger
--E 14

--S 15 of 20
remove!(25, a)
--R 
--R
--R   (15)  {1,4,9,16,32}
--R                                                    Type: Set PositiveInteger
--E 15

--S 16 of 20
a
--R 
--R
--R   (16)  {1,4,9,16,32}
--R                                                    Type: Set PositiveInteger
--E 16

--S 17 of 20
b := b0 := set [i**2 for i in 1..5]
--R 
--R
--R   (17)  {1,4,9,16,25}
--R                                                    Type: Set PositiveInteger
--E 17

--S 18 of 20
b := union(b, {32})
--R 
--R
--R   (18)  {1,4,9,16,25,32}
--R                                                    Type: Set PositiveInteger
--E 18

--S 19 of 20
b := difference(b, {25})
--R 
--R
--R   (19)  {1,4,9,16,32}
--R                                                    Type: Set PositiveInteger
--E 19

--S 20 of 20
b0
--R 
--R
--R   (20)  {1,4,9,16,25}
--R                                                    Type: Set PositiveInteger
--E 20
)spool
)lisp (bye)
@
<<Set.help>>=
====================================================================
Set examples
====================================================================

The Set domain allows one to represent explicit finite sets of values.
These are similar to lists, but duplicate elements are not allowed.

Sets can be created by giving a fixed set of values ...

  s := set [x**2-1, y**2-1, z**2-1]
      2      2      2
    {x  - 1,y  - 1,z  - 1}
                           Type: Set Polynomial Integer

or by using a collect form, just as for lists.  In either case, the
set is formed from a finite collection of values.

  t := set [x**i - i+1 for i in 2..10 | prime? i]
      2      3      5      7
    {x  - 1,x  - 2,x  - 4,x  - 6}
                           Type: Set Polynomial Integer

The basic operations on sets are intersect, union, difference, and
symmetricDifference.

  i := intersect(s,t)
      2
    {x  - 1}
                           Type: Set Polynomial Integer

  u := union(s,t)
      2      3      5      7      2      2
    {x  - 1,x  - 2,x  - 4,x  - 6,y  - 1,z  - 1}
                           Type: Set Polynomial Integer

The set difference(s,t) contains those members of s which are not in t.

  difference(s,t)
      2      2
    {y  - 1,z  - 1}
                           Type: Set Polynomial Integer

The set symmetricDifference(s,t) contains those elements which are
in s or t but not in both.

  symmetricDifference(s,t)
      3      5      7      2      2
    {x  - 2,x  - 4,x  - 6,y  - 1,z  - 1}
                           Type: Set Polynomial Integer

Set membership is tested using the member? operation.

  member?(y, s)
    false
                           Type: Boolean

  member?((y+1)*(y-1), s)
    true
                           Type: Boolean

The subset? function determines whether one set is a subset of another.

  subset?(i, s)
    true
                           Type: Boolean

  subset?(u, s)
    false
                           Type: Boolean

When the base type is finite, the absolute complement of a set is
defined.  This finds the set of all multiplicative generators of 
PrimeField 11---the integers mod 11.

  gs := set [g for i in 1..11 | primitive?(g := i::PF 11)] 
    {2,6,7,8}
                           Type: Set PrimeField 11

The following values are not generators.

  complement gs 
    {1,3,4,5,9,10,0}
                           Type: Set PrimeField 11

Often the members of a set are computed individually; in addition,
values can be inserted or removed from a set over the course of a
computation.

There are two ways to do this:

  a := set [i**2 for i in 1..5]
    {1,4,9,16,25}
                           Type: Set PositiveInteger

One is to view a set as a data structure and to apply updating operations.

  insert!(32, a)
    {1,4,9,16,25,32}
                           Type: Set PositiveInteger

  remove!(25, a)
    {1,4,9,16,32}
                           Type: Set PositiveInteger

  a
    {1,4,9,16,32}
                           Type: Set PositiveInteger

The other way is to view a set as a mathematical entity and to
create new sets from old.

  b := b0 := set [i**2 for i in 1..5]
    {1,4,9,16,25}
                           Type: Set PositiveInteger

  b := union(b, {32})
    {1,4,9,16,25,32}
                           Type: Set PositiveInteger

  b := difference(b, {25})
    {1,4,9,16,32}
                           Type: Set PositiveInteger

  b0
    {1,4,9,16,25}
                           Type: Set PositiveInteger

See Also:
o )help List
o )show Set
o $AXIOM/doc/src/algebra/sets.spad.dvi

@
<<domain SET Set>>=
)abbrev domain SET Set
++ Author: Michael Monagan; revised by Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: May 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A set over a domain D models the usual mathematical notion of a finite set
++ of elements from D.
++ Sets are unordered collections of distinct elements
++ (that is, order and duplication does not matter).
++ The notation \spad{set [a,b,c]} can be used to create
++ a set and the usual operations such as union and intersection are available
++ to form new sets.
++ In our implementation, \Language{} maintains the entries in
++ sorted order.  Specifically, the parts function returns the entries
++ as a list in ascending order and
++ the extract operation returns the maximum entry.
++ Given two sets s and t where \spad{#s = m} and \spad{#t = n},
++ the complexity of
++   \spad{s = t} is \spad{O(min(n,m))}
++   \spad{s < t} is \spad{O(max(n,m))}
++   \spad{union(s,t)}, \spad{intersect(s,t)}, \spad{minus(s,t)}, \spad{symmetricDifference(s,t)} is \spad{O(max(n,m))}
++   \spad{member(x,t)} is \spad{O(n log n)}
++   \spad{insert(x,t)} and \spad{remove(x,t)} is \spad{O(n)}
Set(S:SetCategory): FiniteSetAggregate S == add
   Rep := FlexibleArray(S)
   # s       == _#$Rep s
   brace()   == empty()
   set()     == empty()
   empty()   == empty()$Rep
   copy s    == copy(s)$Rep
   parts s   == parts(s)$Rep
   inspect s == (empty? s => error "Empty set"; s(maxIndex s))

   extract_! s ==
     x := inspect s
     delete_!(s, maxIndex s)
     x

   find(f, s) == find(f, s)$Rep

   map(f, s) == map_!(f,copy s)

   map_!(f,s) ==
     map_!(f,s)$Rep
     removeDuplicates_! s

   reduce(f, s) == reduce(f, s)$Rep

   reduce(f, s, x) == reduce(f, s, x)$Rep

   reduce(f, s, x, y) == reduce(f, s, x, y)$Rep

   if S has ConvertibleTo InputForm then
     convert(x:%):InputForm ==
        convert [convert("set"::Symbol)@InputForm,
                          convert(parts x)@InputForm]

   if S has OrderedSet then
     s = t == s =$Rep t
     max s == inspect s
     min s == (empty? s => error "Empty set"; s(minIndex s))

     construct l ==
       zero?(n := #l) => empty()
       a := new(n, first l)
       for i in minIndex(a).. for x in l repeat a.i := x
       removeDuplicates_! sort_! a

     insert_!(x, s) ==
       n := inc maxIndex s
       k := minIndex s
       while k < n and x > s.k repeat k := inc k
       k < n and s.k = x => s
       insert_!(x, s, k)

     member?(x, s) == -- binary search
       empty? s => false
       t := maxIndex s
       b := minIndex s
       while b < t repeat
         m := (b+t) quo 2
         if x > s.m then b := m+1 else t := m
       x = s.t

     remove_!(x:S, s:%) ==
       n := inc maxIndex s
       k := minIndex s
       while k < n and x > s.k repeat k := inc k
       k < n and x = s.k => delete_!(s, k)
       s

     -- the set operations are implemented as variations of merging
     intersect(s, t) ==
       m := maxIndex s
       n := maxIndex t
       i := minIndex s
       j := minIndex t
       r := empty()
       while i <= m and j <= n repeat
         s.i = t.j => (concat_!(r, s.i); i := i+1; j := j+1)
         if s.i < t.j then i := i+1 else j := j+1
       r

     difference(s:%, t:%) ==
       m := maxIndex s
       n := maxIndex t
       i := minIndex s
       j := minIndex t
       r := empty()
       while i <= m and j <= n repeat
         s.i = t.j => (i := i+1; j := j+1)
         s.i < t.j => (concat_!(r, s.i); i := i+1)
         j := j+1
       while i <= m repeat (concat_!(r, s.i); i := i+1)
       r

     symmetricDifference(s, t) ==
       m := maxIndex s
       n := maxIndex t
       i := minIndex s
       j := minIndex t
       r := empty()
       while i <= m and j <= n repeat
         s.i < t.j => (concat_!(r, s.i); i := i+1)
         s.i > t.j => (concat_!(r, t.j); j := j+1)
         i := i+1; j := j+1
       while i <= m repeat (concat_!(r, s.i); i := i+1)
       while j <= n repeat (concat_!(r, t.j); j := j+1)
       r

     subset?(s, t) ==
       m := maxIndex s
       n := maxIndex t
       m > n => false
       i := minIndex s
       j := minIndex t
       while i <= m and j <= n repeat
         s.i = t.j => (i := i+1; j := j+1)
         s.i > t.j => j := j+1
         return false
       i > m

     union(s:%, t:%) ==
       m := maxIndex s
       n := maxIndex t
       i := minIndex s
       j := minIndex t
       r := empty()
       while i <= m and j <= n repeat
         s.i = t.j => (concat_!(r, s.i); i := i+1; j := j+1)
         s.i < t.j => (concat_!(r, s.i); i := i+1)
         (concat_!(r, t.j); j := j+1)
       while i <= m repeat (concat_!(r, s.i); i := i+1)
       while j <= n repeat (concat_!(r, t.j); j := j+1)
       r

    else
      insert_!(x, s) ==
        for k in minIndex s .. maxIndex s repeat
          s.k = x => return s
        insert_!(x, s, inc maxIndex s)

      remove_!(x:S, s:%) ==
        n := inc maxIndex s
        k := minIndex s
        while k < n repeat
          x = s.k => return delete_!(s, k)
          k := inc k
        s

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain SET Set>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
