\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra table.spad}
\author{Stephen M. Watt, Barry Trager}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain HASHTBL HashTable}
<<domain HASHTBL HashTable>>=
)abbrev domain HASHTBL HashTable
++ Author: Stephen M. Watt
++ Date Created: 1985
++ Date Last Updated: June 21, 1991
++ Basic Operations: 
++ Related Domains: Table, EqTable, StringTable
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This domain provides access to the underlying Lisp hash tables.
++   By varying the hashfn parameter, tables suited for different 
++   purposes can be obtained.

HashTable(Key, Entry, hashfn): Exports == Implementation where
    Key, Entry: SetCategory
    hashfn: String --  Union("EQ", "UEQUAL", "CVEC", "ID")

    Exports ==> TableAggregate(Key, Entry) with
                     finiteAggregate

    Implementation ==> add
        Pair ==> Record(key: Key, entry: Entry)
        Ex   ==> OutputForm
        failMsg := GENSYM()$Lisp

        t1 = t2              == EQ(t1, t2)$Lisp
        keys t               == HKEYS(t)$Lisp
        # t                  == HCOUNT(t)$Lisp
        setelt(t, k, e)      == HPUT(t,k,e)$Lisp
        remove_!(k:Key, t:%) ==
          r := HGET(t,k,failMsg)$Lisp
          not EQ(r,failMsg)$Lisp =>
            HREM(t, k)$Lisp
            r pretend Entry
          "failed"

        empty() ==
            MAKE_-HASHTABLE(INTERN(hashfn)$Lisp,
                            INTERN("STRONG")$Lisp)$Lisp

        search(k:Key, t:%)  ==
            r := HGET(t, k, failMsg)$Lisp
            not EQ(r, failMsg)$Lisp => r pretend Entry
            "failed"

@
\section{domain INTABL InnerTable}
<<domain INTABL InnerTable>>=
)abbrev domain INTABL InnerTable
++ Author: Barry Trager
++ Date Created: 1992
++ Date Last Updated: Sept 15, 1992
++ Basic Operations: 
++ Related Domains: HashTable, AssociationList, Table
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This domain is used to provide a conditional "add" domain
++   for the implementation of \spadtype{Table}.

InnerTable(Key: SetCategory, Entry: SetCategory, addDom):Exports == Implementation where
    addDom : TableAggregate(Key, Entry) with
                     finiteAggregate
    Exports ==> TableAggregate(Key, Entry) with
                     finiteAggregate
    Implementation ==> addDom

@
\section{domain TABLE Table}
<<Table.input>>=
-- table.spad.pamphlet Table.input
)spool Table.output
)set message test on
)set message auto off
)clear all
--S 1 of 18
t: Table(Polynomial Integer, String) := table()
--R 
--R
--R   (1)  table()
--R                                       Type: Table(Polynomial Integer,String)
--E 1

--S 2 of 18
setelt(t, x**2 - 1, "Easy to factor")
--R 
--R
--R   (2)  "Easy to factor"
--R                                                                 Type: String
--E 2

--S 3 of 18
t(x**3 + 1) := "Harder to factor"
--R 
--R
--R   (3)  "Harder to factor"
--R                                                                 Type: String
--E 3

--S 4 of 18
t(x) := "The easiest to factor"
--R 
--R
--R   (4)  "The easiest to factor"
--R                                                                 Type: String
--E 4

--S 5 of 18
elt(t, x)
--R 
--R
--R   (5)  "The easiest to factor"
--R                                                                 Type: String
--E 5

--S 6 of 18
t.x
--R 
--R
--R   (6)  "The easiest to factor"
--R                                                                 Type: String
--E 6

--S 7 of 18
t x
--R 
--R
--R   (7)  "The easiest to factor"
--R                                                                 Type: String
--E 7

--S 8 of 18
t.(x**2 - 1)
--R 
--R
--R   (8)  "Easy to factor"
--R                                                                 Type: String
--E 8

--S 9 of 18
t (x**3 + 1)
--R 
--R
--R   (9)  "Harder to factor"
--R                                                                 Type: String
--E 9

--S 10 of 18
keys t
--R 
--R
--R             3      2
--R   (10)  [x,x  + 1,x  - 1]
--R                                                Type: List Polynomial Integer
--E 10

--S 11 of 18
search(x, t)
--R 
--R
--R   (11)  "The easiest to factor"
--R                                                      Type: Union(String,...)
--E 11

--S 12 of 18
search(x**2, t)
--R 
--R
--R   (12)  "failed"
--R                                                    Type: Union("failed",...)
--E 12

--S 13 of 18
search(x**2, t) case "failed"
--R 
--R
--R   (13)  true
--R                                                                Type: Boolean
--E 13

--S 14 of 18
remove!(x**2-1, t)
--R 
--R
--R   (14)  "Easy to factor"
--R                                                      Type: Union(String,...)
--E 14

--S 15 of 18
remove!(x-1, t)
--R 
--R
--R   (15)  "failed"
--R                                                    Type: Union("failed",...)
--E 15

--S 16 of 18
#t
--R 
--R
--R   (16)  2
--R                                                        Type: PositiveInteger
--E 16

--S 17 of 18
members t
--R 
--R
--R   (17)  ["The easiest to factor","Harder to factor"]
--R                                                            Type: List String
--E 17

--S 18 of 18
count(s: String +-> prefix?("Hard", s), t)
--R 
--R
--R   (18)  1
--R                                                        Type: PositiveInteger
--E 18
)spool
)lisp (bye)
@
<<Table.help>>=
====================================================================
Table examples
====================================================================

The Table constructor provides a general structure for associative
storage.  This type provides hash tables in which data objects can be
saved according to keys of any type.  For a given table, specific
types must be chosen for the keys and entries.

In this example the keys to the table are polynomials with integer
coefficients.  The entries in the table are strings.

  t: Table(Polynomial Integer, String) := table()
    table()
                               Type: Table(Polynomial Integer,String)

To save an entry in the table, the setelt operation is used.  This can
be called directly, giving the table a key and an entry.

  setelt(t, x**2 - 1, "Easy to factor")
    "Easy to factor"
                               Type: String

Alternatively, you can use assignment syntax.

  t(x**3 + 1) := "Harder to factor"
    "Harder to factor"
                               Type: String

  t(x) := "The easiest to factor"
    "The easiest to factor"
                               Type: String

Entries are retrieved from the table by calling the elt operation.

  elt(t, x)
    "The easiest to factor"
                               Type: String

This operation is called when a table is "applied" to a key using this
or the following syntax.

  t.x
    "The easiest to factor"
                               Type: String

  t x
    "The easiest to factor"
                               Type: String

Parentheses are used only for grouping.  They are needed if the key is
an infixed expression.

  t.(x**2 - 1)
    "Easy to factor"
                               Type: String

Note that the elt operation is used only when the key is known to be
in the table, otherwise an error is generated.

  t (x**3 + 1)
    "Harder to factor"
                               Type: String

You can get a list of all the keys to a table using the keys operation.

  keys t
        3      2
    [x,x  + 1,x  - 1]
                               Type: List Polynomial Integer

If you wish to test whether a key is in a table, the search operation
is used.  This operation returns either an entry or "failed".

  search(x, t)
    "The easiest to factor"
                               Type: Union(String,...)

  search(x**2, t)
    "failed"
                               Type: Union("failed",...)

The return type is a union so the success of the search can be tested
using case.  

  search(x**2, t) case "failed"
    true
                               Type: Boolean

The remove operation is used to delete values from a table.

  remove!(x**2-1, t)
    "Easy to factor"
                               Type: Union(String,...)

If an entry exists under the key, then it is returned.  Otherwise
remove returns "failed".

  remove!(x-1, t)
    "failed"
                               Type: Union("failed",...)

The number of key-entry pairs can be found using the # operation.

  #t
    2
                               Type: PositiveInteger

Just as keys returns a list of keys to the table, a list of all the
entries can be obtained using the members operation.

  members t
   (17)  ["The easiest to factor","Harder to factor"]
                               Type: List String

A number of useful operations take functions and map them on to the
table to compute the result.  Here we count the entries which have
"Hard" as a prefix.

  count(s: String +-> prefix?("Hard", s), t)
    1
                               Type: PositiveInteger

Other table types are provided to support various needs.
  o AssociationList gives a list with a table view. This allows new 
    entries to be appended onto the front of the list to cover up old 
    entries. This is useful when table entries need to be stacked or when
    frequent list traversals are required.
  o EqTable gives tables in which keys are considered equal only when 
    they are in fact the same instance of a structure.
  o StringTable should be used when the keys are known to be strings.
  o SparseTable provides tables with default entries, so lookup never fails.
    The GeneralSparseTable constructor can be used to make any table type 
    behave this way.
  o KeyedAccessFile allows values to be saved in a file, accessed as a table.

See Also:
o )help AssociationList
o )help EqTable
o )help StringTable
o )help SparseTable
o )help GeneralSparseTable
o )help KeyedAccessFile
o )show Table
o $AXIOM/doc/src/algebra/table.spad.dvi

@
<<domain TABLE Table>>=
)abbrev domain TABLE Table
++ Author: Stephen M. Watt, Barry Trager
++ Date Created: 1985
++ Date Last Updated: Sept 15, 1992
++ Basic Operations: 
++ Related Domains: HashTable, EqTable, StringTable, AssociationList
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description:
++   This is the general purpose table type.
++   The keys are hashed to look up the entries.
++   This creates a \spadtype{HashTable} if equal for the Key
++   domain is consistent with Lisp EQUAL otherwise an
++   \spadtype{AssociationList}

Table(Key: SetCategory, Entry: SetCategory):Exports == Implementation where
    Exports ==> TableAggregate(Key, Entry) with
                     finiteAggregate

    Implementation ==> InnerTable(Key, Entry,
        if hashable(Key)$Lisp then HashTable(Key, Entry, "UEQUAL")
          else AssociationList(Key, Entry))

@
\section{domain EQTBL EqTable}
<<EqTable.input>>=
-- table.spad.pamphlet EqTable.input
)spool EqTable.output
)set message test on
)set message auto off
)clear all
--S 1 of 6
e: EqTable(List Integer, Integer) := table()
--R 
--R
--R   (1)  table()
--R                                          Type: EqTable(List Integer,Integer)
--E 1

--S 2 of 6
l1 := [1,2,3]
--R 
--R
--R   (2)  [1,2,3]
--R                                                   Type: List PositiveInteger
--E 2

--S 3 of 6
l2 := [1,2,3]
--R 
--R
--R   (3)  [1,2,3]
--R                                                   Type: List PositiveInteger
--E 3

--S 4 of 6
e.l1 := 111
--R 
--R
--R   (4)  111
--R                                                        Type: PositiveInteger
--E 4

--S 5 of 6
e.l2 := 222
--R 
--R
--R   (5)  222
--R                                                        Type: PositiveInteger
--E 5

--S 6 of 6
e.l1
--R 
--R
--R   (6)  111
--R                                                        Type: PositiveInteger
--E 6
)spool
)lisp (bye)
@
<<EqTable.help>>=
====================================================================
EqTable examples
====================================================================

The EqTable domain provides tables where the keys are compared using
eq?.  Keys are considered equal only if they are the same instance of
a structure.  This is useful if the keys are themselves updatable
structures.  Otherwise, all operations are the same as for type Table.

The operation table is here used to create a table where the keys are
lists of integers.

  e: EqTable(List Integer, Integer) := table()
   table()
                    Type: EqTable(List Integer,Integer)

These two lists are equal according to =, but not according to eq?.

  l1 := [1,2,3]
   [1,2,3]
                    Type: List PositiveInteger

  l2 := [1,2,3]
   [1,2,3]
                    Type: List PositiveInteger
Because the two lists are not eq?, separate values can be stored under
each.

  e.l1 := 111
   111
                    Type: PositiveInteger

  e.l2 := 222
   222
                    Type: PositiveInteger

  e.l1
   111
                    Type: PositiveInteger

See Also:
o )help Table
o )show EqTable
o $AXIOM/doc/src/algebra/table.spad.dvi

@
<<domain EQTBL EqTable>>=
)abbrev domain EQTBL EqTable
++ Author: Stephen M. Watt
++ Date Created: 
++ Date Last Updated: June 21, 1991
++ Basic Operations: 
++ Related Domains: HashTable, Table, StringTable
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This domain provides tables where the keys are compared using 
++   \spadfun{eq?}.  Thus keys are considered equal only if they
++   are the same instance of a structure.
EqTable(Key: SetCategory, Entry: SetCategory) ==
      HashTable(Key, Entry, "EQ")

@
\section{domain STRTBL StringTable}
<<StringTable.input>>=
-- table.spad.pamphlet StringTable.input
)spool StringTable.output
)set message test on
)set message auto off
)clear all
--S 1 of 3
t: StringTable(Integer) := table()
--R 
--R
--R   (1)  table()
--R                                                    Type: StringTable Integer
--E 1

--S 2 of 3
for s in split("My name is Ian Watt.",char " ")
  repeat
    t.s := #s
--R 
--R                                                                   Type: Void
--E 2

--S 3 of 3
for key in keys t repeat output [key, t.key]
--R 
--R   ["Watt.",5]
--R   ["Ian",3]
--R   ["is",2]
--R   ["name",4]
--R   ["My",2]
--R                                                                   Type: Void
--E 3
)spool
)lisp (bye)
@
<<StringTable.help>>=
====================================================================
StringTable examples
====================================================================

This domain provides a table type in which the keys are known to be strings 
so special techniques can be used.  Other than performance, the type 
StringTable(S) should behave exactly the same way as Table(String,S).

This creates a new table whose keys are strings.

  t: StringTable(Integer) := table()
    table()
                               Type: StringTable Integer

The value associated with each string key is the number of characters
in the string.

for s in split("My name is Ian Watt.",char " ")
  repeat
    t.s := #s
                               Type: Void

  for key in keys t repeat output [key, t.key]
   ["Watt.",5]
   ["Ian",3]
   ["is",2]
   ["name",4]
   ["My",2]
                               Type: Void

See Also:
o )help Table
o )show StringTable
o $AXIOM/doc/src/algebra/table.spad.dvi

@
<<domain STRTBL StringTable>>=
)abbrev domain STRTBL StringTable
++ Author: Stephen M. Watt
++ Date Created: 
++ Date Last Updated: June 21, 1991
++ Basic Operations: 
++ Related Domains: Table 
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This domain provides tables where the keys are strings.
++   A specialized hash function for strings is used.
StringTable(Entry: SetCategory) ==
    HashTable(String, Entry, "CVEC")

@
\section{domain GSTBL GeneralSparseTable}
<<GeneralSparseTable.input>>=
-- table.spad.pamphlet GeneralSparseTable.input
)spool GeneralSparseTable.output
)set message test on
)set message auto off
)set break resume
)clear all
--S 1 of 7
patrons: GeneralSparseTable(String, Integer, KeyedAccessFile(Integer), 0) := table() ; 
--E 1

--S 2 of 7
patrons."Smith" := 10500 
--E 2

--S 3 of 7
patrons."Jones" := 22000
--E 3

--S 4 of 7
patrons."Jones" 
--E 4

--S 5 of 7
patrons."Stingy"
--E 5

--S 6 of 7
reduce(+, entries patrons) 
--E 6

--S 7 of 7
)system rm -r kaf*.sdata
--E 7
)spool
)lisp (bye)
@
<<GeneralSparseTable.help>>=
====================================================================
GeneralSparseTable
====================================================================

Sometimes when working with tables there is a natural value to use as
the entry in all but a few cases.  The GeneralSparseTable constructor
can be used to provide any table type with a default value for
entries.

Suppose we launched a fund-raising campaign to raise fifty thousand
dollars.  To record the contributions, we want a table with strings as
keys (for the names) and integer entries (for the amount).  In a data
base of cash contributions, unless someone has been explicitly
entered, it is reasonable to assume they have made a zero dollar
contribution.

This creates a keyed access file with default entry 0.

  patrons: GeneralSparseTable(String, Integer, KeyedAccessFile(Integer), 0) := table() ; 

Now patrons can be used just as any other table.  Here we record two gifts.

  patrons."Smith" := 10500 

  patrons."Jones" := 22000

Now let us look up the size of the contributions from Jones and Stingy.

  patrons."Jones" 

  patrons."Stingy"

Have we met our seventy thousand dollar goal?

  reduce(+, entries patrons) 

So the project is cancelled and we can delete the data base:

  )system rm -r kaf*.sdata

See Also:
o )show GeneralSparseTable
o $AXIOM/doc/src/algebra/table.spad.dvi

@
<<domain GSTBL GeneralSparseTable>>=
)abbrev domain GSTBL GeneralSparseTable
++ Author: Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: June 21, 1991
++ Basic Operations: 
++ Related Domains: Table 
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   A sparse table has a default entry, which is returned if no other
++   value has been explicitly stored for a key.
GeneralSparseTable(Key, Entry, Tbl, dent): TableAggregate(Key, Entry) == Impl
  where
    Key, Entry: SetCategory
    Tbl:  TableAggregate(Key, Entry)
    dent: Entry

    Impl ==> Tbl add
        Rep := Tbl

        elt(t:%, k:Key) ==
            (u := search(k, t)$Rep) case "failed" => dent
            u::Entry

        setelt(t:%, k:Key, e:Entry) ==
            e = dent => (remove_!(k, t); e)
            setelt(t, k, e)$Rep

        search(k:Key, t:%) ==
            (u := search(k, t)$Rep) case "failed" => dent
            u

@
\section{domain STBL SparseTable}
<<SparseTable.input>>=
-- table.spad.pamphlet SparseTable.input
)spool SparseTable.output
)set message test on
)set message auto off
)clear all
--S 1 of 7
t: SparseTable(Integer, String, "Try again!") := table()
--R 
--R
--R   (1)  table()
--R                                 Type: SparseTable(Integer,String,Try again!)
--E 1

--S 2 of 7
t.3 := "Number three"
--R 
--R
--R   (2)  "Number three"
--R                                                                 Type: String
--E 2

--S 3 of 7
t.4 := "Number four"
--R 
--R
--R   (3)  "Number four"
--R                                                                 Type: String
--E 3

--S 4 of 7
t.3
--R 
--R
--R   (4)  "Number three"
--R                                                                 Type: String
--E 4

--S 5 of 7
t.2
--R 
--R
--R   (5)  "Try again!"
--R                                                                 Type: String
--E 5

--S 6 of 7
keys t
--R 
--R
--R   (6)  [4,3]
--R                                                           Type: List Integer
--E 6

--S 7 of 7
entries t
--R 
--R
--R   (7)  ["Number four","Number three"]
--R                                                            Type: List String
--E 7
)spool
)lisp (bye)
@
<<SparseTable.help>>=
====================================================================
SparseTable examples
====================================================================

The SparseTable domain provides a general purpose table type with
default entries.

Here we create a table to save strings under integer keys.  The value
"Try again!" is returned if no other value has been stored for a key.

  t: SparseTable(Integer, String, "Try again!") := table()
    table()
                           Type: SparseTable(Integer,String,Try again!)

Entries can be stored in the table.

  t.3 := "Number three"
    "Number three"
                           Type: String

  t.4 := "Number four"
    "Number four"
                           Type: String

These values can be retrieved as usual, but if a look up fails the
default entry will be returned.

  t.3
    "Number three"
                           Type: String

  t.2
    "Try again!"
                           Type: String

To see which values are explicitly stored, the keys and entries
functions can be used.

  keys t
    [4,3]
                           Type: List Integer

  entries t
    ["Number four","Number three"]
                           Type: List String

If a specific table representation is required, the GeneralSparseTable
constructor should be used.  The domain SparseTable(K, E, dflt)} is
equivalent to GeneralSparseTable(K,E,Table(K,E), dflt).

See Also:
o )help Table
o )help GeneralSparseTable
o )show SparseTable
o $AXIOM/doc/src/algebra/table.spad.dvi

@
<<domain STBL SparseTable>>=
)abbrev domain STBL SparseTable
++ Author: Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: June 21, 1991
++ Basic Operations: 
++ Related Domains: Table 
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   A sparse table has a default entry, which is returned if no other
++   value has been explicitly stored for a key.

SparseTable(Key:SetCategory, Ent:SetCategory, dent:Ent) ==
        GeneralSparseTable(Key, Ent, Table(Key, Ent), dent)

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain HASHTBL HashTable>>
<<domain INTABL InnerTable>>
<<domain TABLE Table>>
<<domain EQTBL EqTable>>
<<domain STRTBL StringTable>>
<<domain GSTBL GeneralSparseTable>>
<<domain STBL SparseTable>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
