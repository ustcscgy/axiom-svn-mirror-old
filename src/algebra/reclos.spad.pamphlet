\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra reclos.spad}
\author{Renaud Rioboo}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
This file describes the Real Closure 1.0 package which consists of different
packages, categoris and domains :

- the package RealPolynomialUtilitiesPackage whichs receives a field and a
univariate polynomial domain with coefficients in the field. It computes some
simple functions such as Strum and Sylvester sequences.

- The category RealRootCharacterizationCategory provides abstarct
functionalities to work with "real roots" of univariate polynomials. These
resemble variables with some functionalities needed to compute important
operations.

- RealClosedField is a category with provides common operations available over
real closed fiels. These include finding all the roots of univariate
polynomial, taking square roots, ...


CAVEATS

Since real algebraic expressions are stored as depending on "real roots" which
are managed like variables, there is an ordering on these. This ordering is
dynamical in the sense that any new algebraic takes precedence over older
ones. In particular every cretaion function raises a new "real root". This has
the effect that when you type something like sqrt(2) + sqrt(2) you have two
new variables which happen to be equal. To avoid this name the expression such
as in s2 := sqrt(2) ; s2 + s2

Also note that computing times depend strongly on the ordering you implicitly
provide. Please provide algebraics in the order which most natural to you.

LIMITATIONS

The file reclos.input show some basic use of the package.  This packages uses
algorithms which are published in [1] and [2] which are based on field
arithmetics, inparticular for polynomial gcd related algorithms. This can be
quite slow for high degree polynomials and subresultants methods usually work
best. Betas versions of the package try to use these techniques in a better
way and work significantly faster. These are mostly based on unpublished
algorithms and cannot be distributed. Please contact the author if you have a
particular problem to solve or want to use these versions.

Be aware that approximations behave as post-processing and that all
computations are done excatly. They can thus be quite time consuming when
depending on several "real roots".
\section{package POLUTIL RealPolynomialUtilitiesPackage}
<<package POLUTIL RealPolynomialUtilitiesPackage>>=
)abbrev package POLUTIL RealPolynomialUtilitiesPackage
++ Author: Renaud Rioboo
++ Date Created: summer 1992
++ Basic Functions: provides polynomial utilities
++ Related Constructors: RealClosure, 
++ Date Last Updated: July 2004
++ Also See: 
++ AMS Classifications:
++ Keywords: Sturm sequences
++ References:  
++ Description:
++ \axiomType{RealPolynomialUtilitiesPackage} provides common functions used
++ by interval coding.
RealPolynomialUtilitiesPackage(TheField,ThePols) : PUB == PRIV where

    TheField : Field
    ThePols : UnivariatePolynomialCategory(TheField)

    Z ==> Integer
    N ==> NonNegativeInteger
    P ==> ThePols

    PUB == with

       sylvesterSequence : (ThePols,ThePols) -> List ThePols
         ++ \axiom{sylvesterSequence(p,q)} is the negated remainder sequence
         ++ of p and q divided by the last computed term
       sturmSequence : ThePols -> List ThePols
         ++ \axiom{sturmSequence(p) = sylvesterSequence(p,p')}
       if TheField has OrderedRing then
         boundOfCauchy : ThePols -> TheField
           ++ \axiom{boundOfCauchy(p)} bounds the roots of p
         sturmVariationsOf : List TheField -> N
           ++ \axiom{sturmVariationsOf(l)} is the number of sign variations 
           ++ in the list of numbers l,
           ++ note that the first term counts as a sign
         lazyVariations : (List(TheField), Z, Z) -> N
           ++ \axiom{lazyVariations(l,s1,sn)} is the number of sign variations 
           ++ in the list of non null numbers [s1::l]@sn,


    PRIV == add

     sturmSequence(p) ==
       sylvesterSequence(p,differentiate(p))

     sylvesterSequence(p1,p2) ==
       res : List(ThePols) := [p1]
       while (p2 ^= 0) repeat
         res := cons(p2 , res)
         (p1 , p2) := (p2 , -(p1 rem p2))
       if degree(p1) > 0
       then
         p1 := unitCanonical(p1)
         res := [ term quo p1 for term in res ]
       reverse! res

     if TheField has OrderedRing
     then

       boundOfCauchy(p) ==
         c :TheField := inv(leadingCoefficient(p))
         l := [ c*term for term in rest(coefficients(p))]
         null(l) => 1
         1 + ("max" / [ abs(t) for t in l ])

--       sturmVariationsOf(l) == 
--         res : N := 0
--         lsg := sign(first(l))
--         for term in l repeat
--           if ^( (sg := sign(term) ) = 0 ) then
--             if (sg ^= lsg) then res := res + 1
--             lsg := sg
--         res

       sturmVariationsOf(l) == 
         null(l) => error "POLUTIL: sturmVariationsOf: empty list !"
         l1 := first(l)
         -- first 0 counts as a sign
         ll : List(TheField) := []
         for term in rest(l) repeat
           -- zeros don't count
           if not(zero?(term)) then ll := cons(term,ll)
         -- if l1 is not zero then ll = reverse(l)
         null(ll) => error "POLUTIL: sturmVariationsOf: Bad sequence"
         ln := first(ll)
         ll := reverse(rest(ll))
         -- if l1 is not zero then first(l) = first(ll)
         -- if l1 is zero then first zero should count as a sign
         zero?(l1) => 1 + lazyVariations(rest(ll),sign(first(ll)),sign(ln))
         lazyVariations(ll, sign(l1), sign(ln))

       lazyVariations(l,sl,sh) ==
         zero?(sl) or zero?(sh) => error "POLUTIL: lazyVariations: zero sign!"
         null(l) =>
           if sl = sh then 0 else 1
         null(rest(l)) => 
           if zero?(first(l))
           then error "POLUTIL: lazyVariations: zero sign!"
           else
             if sl = sh 
             then 
               if (sl = sign(first(l)))
               then 0
               else 2
             -- in this case we save one test
             else 1
         s := sign(l.2)
         lazyVariations([first(l)],sl,s) + 
           lazyVariations(rest(rest(l)),s,sh)
    
@
\section{License}
<<license>>=
-----------------------------------------------------------------------------
-- This software was written by Renaud Rioboo (Computer Algebra group of
-- Laboratoire d'Informatique de Paris 6) and is the property of university
-- Paris 6.
-----------------------------------------------------------------------------
@
<<*>>=
<<license>>
<<package POLUTIL RealPolynomialUtilitiesPackage>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} R. Rioboo,
{\sl Real Algebraic Closure of an ordered Field : Implementation in Axiom.},
In proceedings of the ISSAC'92 Conference, Berkeley 1992 pp. 206-215.
\bibitem{2} Z. Ligatsikas, R. Rioboo, M. F. Roy 
{\sl Generic computation of the real closure of an ordered field.},
In Mathematics and Computers in Simulation Volume 42, Issue 4-6,
November 1996.
\end{thebibliography}
\end{document}
