\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra reclos.spad}
\author{Renaud Rioboo}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
This file describes the Real Closure 1.0 package which consists of different
packages, categoris and domains :

- the package RealPolynomialUtilitiesPackage whichs receives a field and a
univariate polynomial domain with coefficients in the field. It computes some
simple functions such as Strum and Sylvester sequences.

- The category RealRootCharacterizationCategory provides abstarct
functionalities to work with "real roots" of univariate polynomials. These
resemble variables with some functionalities needed to compute important
operations.

- RealClosedField is a category with provides comon operations available over
real closed fiels. These include finding all the roots of univariate
polynomial, taking square roots, ...

- The domain RightOpenIntervalRootCharacterization is the main code that
provides the functionalities of RealRootCharacterizationCategory for the case
of archimedean fileds. Abstract roots are encoded with a left closed right
open interval containing the root together with a defining polynomial for the
root.

- The RealClosure domain is the end-user code, it provides usual arithmetics
with real algebraic numbers, along with the functionalities of a real closed
field. It also provides functions to approximate a real algebraic number by an
element of the base field. This approximation may either be absolute
(approximate) or relative (realtivApprox).


CAVEEATS

Since real algebraic expressions are stored as depending on "real roots" which
are managed like variables, there is an ordering on these. This ordering is
dynamical in the sense that any new algebraic takes precedence over older
ones. In particular every cretaion function raises a new "real root". This has
the effect that when you type something like sqrt(2) + sqrt(2) you have two
new variables which happen to be equal. To avoid this name the expression such
as in s2 := sqrt(2) ; s2 + s2

Also note that computing times depend strongly on the ordering you implicitly
provide. Please provide algebraics in the order which most natural to you.

LIMITATIONS

The file reclos.input show some basic use of the package.  This packages uses
algorithms which are published in [1] and [2] which are based on field
arithmetics, inparticular for polynomial gcd related algorithms. This can be
quite slow for high degree polynomials and subresultants methods usually work
best. Betas versions of the package try to use these techniques in a better
way and work significantly faster. These are mostly based on unpublished
algorithms and cannot be distributed. Please contact the author if you have a
particular problem to solve or want to use these versions.

Be aware that approximations behave as post-processing and that all
computations are done excatly. They can thus be quite time consuming when
depending on several "real roots".
\section{package POLUTIL RealPolynomialUtilitiesPackage}
<<package POLUTIL RealPolynomialUtilitiesPackage>>=
)abbrev package POLUTIL RealPolynomialUtilitiesPackage
++ Author: Renaud Rioboo
++ Date Created: summer 1992
++ Basic Functions: provides polynomial utilities
++ Related Constructors: RealClosure, 
++ Date Last Updated: July 2004
++ Also See: 
++ AMS Classifications:
++ Keywords: Sturm sequences
++ References:  
++ Description:
++ \axiomType{RealPolynomialUtilitiesPackage} provides common functions used
++ by interval coding.
RealPolynomialUtilitiesPackage(TheField,ThePols) : PUB == PRIV where

    TheField : Field
    ThePols : UnivariatePolynomialCategory(TheField)

    Z ==> Integer
    N ==> NonNegativeInteger
    P ==> ThePols

    PUB == with

       sylvesterSequence : (ThePols,ThePols) -> List ThePols
         ++ \axiom{sylvesterSequence(p,q)} is the negated remainder sequence
         ++ of p and q divided by the last computed term
       sturmSequence : ThePols -> List ThePols
         ++ \axiom{sturmSequence(p) = sylvesterSequence(p,p')}
       if TheField has OrderedRing then
         boundOfCauchy : ThePols -> TheField
           ++ \axiom{boundOfCauchy(p)} bounds the roots of p
         sturmVariationsOf : List TheField -> N
           ++ \axiom{sturmVariationsOf(l)} is the number of sign variations 
           ++ in the list of numbers l,
           ++ note that the first term counts as a sign
         lazyVariations : (List(TheField), Z, Z) -> N
           ++ \axiom{lazyVariations(l,s1,sn)} is the number of sign variations 
           ++ in the list of non null numbers [s1::l]@sn,


    PRIV == add

     sturmSequence(p) ==
       sylvesterSequence(p,differentiate(p))

     sylvesterSequence(p1,p2) ==
       res : List(ThePols) := [p1]
       while (p2 ^= 0) repeat
         res := cons(p2 , res)
         (p1 , p2) := (p2 , -(p1 rem p2))
       if degree(p1) > 0
       then
         p1 := unitCanonical(p1)
         res := [ term quo p1 for term in res ]
       reverse! res

     if TheField has OrderedRing
     then

       boundOfCauchy(p) ==
         c :TheField := inv(leadingCoefficient(p))
         l := [ c*term for term in rest(coefficients(p))]
         null(l) => 1
         1 + ("max" / [ abs(t) for t in l ])

--       sturmVariationsOf(l) == 
--         res : N := 0
--         lsg := sign(first(l))
--         for term in l repeat
--           if ^( (sg := sign(term) ) = 0 ) then
--             if (sg ^= lsg) then res := res + 1
--             lsg := sg
--         res

       sturmVariationsOf(l) == 
         null(l) => error "POLUTIL: sturmVariationsOf: empty list !"
         l1 := first(l)
         -- first 0 counts as a sign
         ll : List(TheField) := []
         for term in rest(l) repeat
           -- zeros don't count
           if not(zero?(term)) then ll := cons(term,ll)
         -- if l1 is not zero then ll = reverse(l)
         null(ll) => error "POLUTIL: sturmVariationsOf: Bad sequence"
         ln := first(ll)
         ll := reverse(rest(ll))
         -- if l1 is not zero then first(l) = first(ll)
         -- if l1 is zero then first zero should count as a sign
         zero?(l1) => 1 + lazyVariations(rest(ll),sign(first(ll)),sign(ln))
         lazyVariations(ll, sign(l1), sign(ln))

       lazyVariations(l,sl,sh) ==
         zero?(sl) or zero?(sh) => error "POLUTIL: lazyVariations: zero sign!"
         null(l) =>
           if sl = sh then 0 else 1
         null(rest(l)) => 
           if zero?(first(l))
           then error "POLUTIL: lazyVariations: zero sign!"
           else
             if sl = sh 
             then 
               if (sl = sign(first(l)))
               then 0
               else 2
             -- in this case we save one test
             else 1
         s := sign(l.2)
         lazyVariations([first(l)],sl,s) + 
           lazyVariations(rest(rest(l)),s,sh)
    
@
\section{category RRCC RealRootCharacterizationCategory}
<<category RRCC RealRootCharacterizationCategory>>=
)abbrev category RRCC RealRootCharacterizationCategory
++ Author: Renaud Rioboo
++ Date Created: summer 1992
++ Date Last Updated: January 2004
++ Basic Functions: provides operations with generic real roots of 
++                  polynomials 
++ Related Constructors: RealClosure, RightOpenIntervalRootCharacterization
++ Also See: 
++ AMS Classifications:
++ Keywords: Real Algebraic Numbers
++ References: 
++ Description:
++ \axiomType{RealRootCharacterizationCategory} provides common acces
++ functions for all real root codings.
RealRootCharacterizationCategory(TheField, ThePols ) : Category == PUB where

   TheField : Join(OrderedRing, Field)
   ThePols : UnivariatePolynomialCategory(TheField)

   Z ==> Integer
   N ==> PositiveInteger

   PUB ==>
     SetCategory with

        sign:                ( ThePols, $ )   ->            Z
              ++ \axiom{sign(pol,aRoot)} gives the sign of \axiom{pol}
              ++ interpreted as \axiom{aRoot}
        zero? :              ( ThePols, $ )   ->         Boolean
              ++ \axiom{zero?(pol,aRoot)} answers if \axiom{pol}
              ++ interpreted as \axiom{aRoot} is \axiom{0}
        negative?:           ( ThePols, $ )   ->         Boolean
              ++ \axiom{negative?(pol,aRoot)} answers if \axiom{pol}
              ++ interpreted as \axiom{aRoot} is negative
        positive?:           ( ThePols, $ )   ->         Boolean
              ++ \axiom{positive?(pol,aRoot)} answers if \axiom{pol}
              ++ interpreted as \axiom{aRoot} is positive
        recip:               ( ThePols, $ )   ->   Union(ThePols,"failed") 
              ++ \axiom{recip(pol,aRoot)} tries to inverse \axiom{pol}
              ++ interpreted as \axiom{aRoot}
        definingPolynomial:         $         ->         ThePols
              ++ \axiom{definingPolynomial(aRoot)} gives a polynomial
              ++ such that \axiom{definingPolynomial(aRoot).aRoot = 0} 
        allRootsOf:              ThePols      ->          List $
              ++ \axiom{allRootsOf(pol)} creates all the roots of \axiom{pol} 
              ++ in the Real Closure, assumed in order.
        rootOf:              ( ThePols, N )   ->      Union($,"failed")
              ++ \axiom{rootOf(pol,n)} gives the nth root for the order of the
              ++ Real Closure
        approximate :  (ThePols,$,TheField)   ->    TheField
              ++ \axiom{approximate(term,root,prec)} gives an approximation 
              ++ of \axiom{term} over \axiom{root} with precision \axiom{prec}

        relativeApprox :  (ThePols,$,TheField)   ->    TheField
              ++ \axiom{approximate(term,root,prec)} gives an approximation 
              ++ of \axiom{term} over \axiom{root} with precision \axiom{prec}

      add

        zero?(toTest, rootChar) == 
          sign(toTest, rootChar) = 0
                
        negative?(toTest, rootChar) == 
          sign(toTest, rootChar) < 0              
        
        positive?(toTest, rootChar) == 
          sign(toTest, rootChar) > 0

        rootOf(pol,n) ==
          liste:List($):= allRootsOf(pol)
          # liste > n => "failed"
          liste.n

        recip(toInv,rootChar) ==
          degree(toInv) = 0 => 
            res := recip(leadingCoefficient(toInv))
            if (res case "failed") then "failed" else (res::TheField::ThePols)
          defPol := definingPolynomial(rootChar)
          d := principalIdeal([defPol,toInv])
          zero?(d.generator,rootChar) => "failed"
          if (degree(d.generator) ^= 0 )
          then
            defPol := (defPol exquo (d.generator))::ThePols
            d := principalIdeal([defPol,toInv])
          d.coef.2

@
\section{category RCFIELD RealClosedField}
<<category RCFIELD RealClosedField>>=
)abbrev category RCFIELD RealClosedField
++ Author: Renaud Rioboo
++ Date Created: may 1993
++ Date Last Updated: January 2004
++ Basic Functions: provides computations with generic real roots of 
++                  polynomials 
++ Related Constructors: SimpleOrderedAlgebraicExtension, RealClosure
++ Also See: 
++ AMS Classifications:
++ Keywords: Real Algebraic Numbers
++ References: 
++ Description:
++ \axiomType{RealClosedField} provides common acces
++ functions for all real closed fields.
RealClosedField : Category == PUB where

    E ==> OutputForm
    SUP ==> SparseUnivariatePolynomial
    OFIELD ==> Join(OrderedRing,Field)
    PME ==> SUP($)
    N ==> NonNegativeInteger
    PI ==> PositiveInteger
    RN ==> Fraction(Integer)
    Z  ==> Integer
    POLY ==> Polynomial
    PACK ==> SparseUnivariatePolynomialFunctions2

    PUB == Join(CharacteristicZero,
                OrderedRing,
                CommutativeRing,
                Field,
                FullyRetractableTo(Fraction(Integer)),
                Algebra Integer,
                Algebra(Fraction(Integer)),
                RadicalCategory) with

        mainForm :   $ -> Union(E,"failed")
             ++ \axiom{mainForm(x)} is the main algebraic quantity name of 
             ++ \axiom{x}

        mainDefiningPolynomial :   $ -> Union(PME,"failed")
             ++ \axiom{mainDefiningPolynomial(x)} is the defining 
             ++ polynomial for the main algebraic quantity of \axiom{x}

        mainValue :   $ -> Union(PME,"failed")
             ++ \axiom{mainValue(x)} is the expression of \axiom{x} in terms
             ++ of \axiom{SparseUnivariatePolynomial($)} 

        rootOf:          (PME,PI,E)           -> Union($,"failed")
             ++ \axiom{rootOf(pol,n,name)} creates the nth root for the order
             ++ of \axiom{pol} and names it \axiom{name}

        rootOf:          (PME,PI)             -> Union($,"failed")
             ++ \axiom{rootOf(pol,n)} creates the nth root for the order
             ++ of \axiom{pol} and gives it unique name

        allRootsOf:       PME                ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        allRootsOf:       (SUP(RN))          ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        allRootsOf:       (SUP(Z))          ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        allRootsOf:       (POLY($))         ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        allRootsOf:       (POLY(RN))        ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        allRootsOf:       (POLY(Z))         ->  List $
             ++ \axiom{allRootsOf(pol)} creates all the roots
             ++ of \axiom{pol} naming each uniquely

        sqrt:            ($,N)                ->     $
             ++ \axiom{sqrt(x,n)} is \axiom{x ** (1/n)}

        sqrt:              $                  ->     $
             ++ \axiom{sqrt(x)} is \axiom{x ** (1/2)}

        sqrt:             RN                  ->     $
             ++ \axiom{sqrt(x)} is \axiom{x ** (1/2)}

        sqrt:              Z                  ->     $
             ++ \axiom{sqrt(x)} is \axiom{x ** (1/2)}

        rename! :        ($,E)                ->     $
             ++ \axiom{rename!(x,name)} changes the way \axiom{x} is printed

        rename :         ($,E)                ->     $
             ++ \axiom{rename(x,name)} gives a new number that prints as name

        approximate:       ($,$) -> RN
              ++ \axiom{approximate(n,p)} gives an approximation of \axiom{n}
              ++ that has precision \axiom{p}

      add

        sqrt(a:$):$ == sqrt(a,2)

        sqrt(a:RN):$ == sqrt(a::$,2)

        sqrt(a:Z):$ == sqrt(a::$,2)

        characteristic() == 0

        rootOf(pol,n,o) == 
          r := rootOf(pol,n)
          r case "failed" => "failed"
          rename!(r,o)

        rootOf(pol,n) ==
          liste:List($):= allRootsOf(pol)
          # liste > n => "failed"
          liste.n


        sqrt(x,n) ==
          n = 0 => 1
          n = 1 => x
          zero?(x) => 0
          one?(x) => 1 
          if odd?(n)
          then
            r := rootOf(monomial(1,n) - (x :: PME), 1)
          else
            r := rootOf(monomial(1,n) - (x :: PME), 2)
          r case "failed" => error "no roots"
          n = 2 => rename(r,root(x::E)$E)
          rename(r,root(x :: E, n :: E)$E)

        (x : $) ** (rn : RN) == sqrt(x**numer(rn),denom(rn)::N)

        nthRoot(x, n) == 
          zero?(n) => x
          negative?(n) => inv(sqrt(x,(-n) :: N))
          sqrt(x,n :: N)

        allRootsOf(p:SUP(RN)) == allRootsOf(map(#1 :: $ ,p)$PACK(RN,$))

        allRootsOf(p:SUP(Z)) == allRootsOf(map(#1 :: $ ,p)$PACK(Z,$))

        allRootsOf(p:POLY($)) == allRootsOf(univariate(p))

        allRootsOf(p:POLY(RN)) == allRootsOf(univariate(p))

        allRootsOf(p:POLY(Z)) == allRootsOf(univariate(p))

@
\section{domain ROIRC RightOpenIntervalRootCharacterization}
\subsection{makeChar performance problem}
The following lines of code, which check for a possible error,
cause major performance problems and were removed by Renaud Rioboo,
the original author. They were originally inserted for debugging.
\begin{verbatim}
    right <= left => error "ROIRC: makeChar: Bad interval"
    (pol.left * pol.right) > 0 => error "ROIRC: makeChar: Bad pol"
\end{verbatim}
<<performance problem>>=
@
<<domain ROIRC RightOpenIntervalRootCharacterization>>=
)abbrev domain ROIRC RightOpenIntervalRootCharacterization 
++ Author: Renaud Rioboo
++ Date Created: summer 1992
++ Date Last Updated: January 2004
++ Basic Functions: provides computations with real roots of olynomials 
++ Related Constructors: RealRootCharacterizationCategory, RealClosure
++ Also See: 
++ AMS Classifications:
++ Keywords: Real Algebraic Numbers
++ References: 
++ Description:
++ \axiomType{RightOpenIntervalRootCharacterization} provides work with
++ interval root coding.
RightOpenIntervalRootCharacterization(TheField,ThePolDom) : PUB == PRIV where

  TheField : Join(OrderedRing,Field)
  ThePolDom : UnivariatePolynomialCategory(TheField)


  Z           ==>  Integer
  P           ==>  ThePolDom
  N           ==>  NonNegativeInteger
  B           ==>  Boolean
  UTIL        ==>  RealPolynomialUtilitiesPackage(TheField,ThePolDom)
  RRCC        ==>  RealRootCharacterizationCategory
  O ==> OutputForm
  TwoPoints ==> Record(low:TheField , high:TheField)

  PUB == RealRootCharacterizationCategory(TheField, ThePolDom) with

      left    :             $            -> TheField
           ++ \axiom{left(rootChar)} is the left bound of the isolating
           ++ interval
      right   :             $            -> TheField
           ++ \axiom{right(rootChar)} is the right bound of the isolating
           ++ interval
      size    :             $            -> TheField
           ++ The size of the isolating interval
      middle  :             $            -> TheField
           ++ \axiom{middle(rootChar)} is the middle of the isolating
           ++ interval
      refine  :             $            ->    $
           ++ \axiom{refine(rootChar)} shrinks isolating interval around 
           ++ \axiom{rootChar}
      mightHaveRoots :     (P,$)         ->    B
           ++ \axiom{mightHaveRoots(p,r)} is false if \axiom{p.r} is not 0
      relativeApprox :     (P,$,TheField) -> TheField
           ++ \axiom{relativeApprox(exp,c,p) = a} is relatively close to exp
           ++ as a polynomial in c ip to precision p

  PRIV == add



-- local functions


   makeChar:             (TheField,TheField,ThePolDom) ->     $
   refine! :                              $            ->     $
   sturmIsolate : (List(P), TheField, TheField,N,N)    -> List TwoPoints
   isolate :                            List(P)        -> List TwoPoints
   rootBound :                             P           ->   TheField
--   varStar :                                P          ->     N
   linearRecip :                       ( P , $)        -> Union(P, "failed")
   linearZero? :                     (TheField,$)      ->     B
   linearSign :                          (P,$)         ->     Z
   sturmNthRoot : (List(P), TheField, TheField,N,N,N)  -> Union(TwoPoints,"failed")
   addOne :                              P             ->      P
   minus :                               P             ->      P
   translate :                    (P,TheField)         ->      P
   dilate :                       (P,TheField)         ->      P
   invert :                              P             ->      P
   evalOne :                             P             ->   TheField
   hasVarsl:                     List(TheField)        ->      B
   hasVars:                              P             ->      B

-- Representation

   Rep:= Record(low:TheField,high:TheField,defPol:ThePolDom)

-- and now the code !


   size(rootCode) ==
     rootCode.high - rootCode.low

   relativeApprox(pval,rootCode,prec) ==
     -- beurk !
     dPol := rootCode.defPol
     degree(dPol) = 1 => 
       c := -coefficient(dPol,0)/leadingCoefficient(dPol)
       pval.c
     pval := pval rem dPol
     degree(pval) = 0 => leadingCoefficient(pval)
     zero?(pval,rootCode)  => 0
     while mightHaveRoots(pval,rootCode) repeat
          rootCode := refine(rootCode)
     dpval := differentiate(pval)
     degree(dpval) = 0 =>
       l := left(rootCode)
       r := right(rootCode)
       a := pval.l
       b := pval.r
       while ( abs(2*(a-b)/(a+b)) > prec ) repeat
         rootCode := refine(rootCode)
         l := left(rootCode)
         r := right(rootCode)
         a := pval.l
         b := pval.r
       (a+b)/(2::TheField)
     zero?(dpval,rootCode) => 
        relativeApprox(pval, 
                       [left(rootCode),
                         right(rootCode),
                           gcd(dpval,rootCode.defPol)]$Rep,
                       prec)
     while mightHaveRoots(dpval,rootCode) repeat
          rootCode := refine(rootCode)
     l := left(rootCode)
     r := right(rootCode)
     a := pval.l
     b := pval.r
     while ( abs(2*(a-b)/(a+b)) > prec ) repeat
       rootCode := refine(rootCode)
       l := left(rootCode)
       r := right(rootCode)
       a := pval.l
       b := pval.r
     (a+b)/(2::TheField)

   approximate(pval,rootCode,prec) ==
     -- glurp
     dPol := rootCode.defPol
     degree(dPol) = 1 => 
       c := -coefficient(dPol,0)/leadingCoefficient(dPol)
       pval.c
     pval := pval rem dPol
     degree(pval) = 0 => leadingCoefficient(pval)
     dpval := differentiate(pval)
     degree(dpval) = 0 =>
       l := left(rootCode)
       r := right(rootCode)
       while ( abs((a := pval.l) - (b := pval.r)) > prec ) repeat
         rootCode := refine(rootCode)
         l := left(rootCode)
         r := right(rootCode)
       (a+b)/(2::TheField)
     zero?(dpval,rootCode) => 
        approximate(pval, 
                    [left(rootCode),
                     right(rootCode),
                      gcd(dpval,rootCode.defPol)]$Rep,
                    prec)
     while mightHaveRoots(dpval,rootCode) repeat
          rootCode := refine(rootCode)
     l := left(rootCode)
     r := right(rootCode)
     while ( abs((a := pval.l) - (b := pval.r)) > prec ) repeat
       rootCode := refine(rootCode)
       l := left(rootCode)
       r := right(rootCode)
     (a+b)/(2::TheField)


   addOne(p) == p.(monomial(1,1)+(1::P))

   minus(p) == p.(monomial(-1,1))

   translate(p,a) == p.(monomial(1,1)+(a::P))

   dilate(p,a) == p.(monomial(a,1))

   evalOne(p) == "+" / coefficients(p)

   invert(p) == 
        d := degree(p)
        mapExponents((d-#1)::N, p)

   rootBound(p) ==
     res : TheField := 1
     raw :TheField := 1+boundOfCauchy(p)$UTIL
     while (res < raw) repeat
       res := 2*(res)
     res

   sturmNthRoot(lp,l,r,vl,vr,n) ==
    nv := (vl - vr)::N
    nv < n => "failed"
    ((nv = 1) and (n = 1)) => [l,r]
    int := (l+r)/(2::TheField)
    lt:List(TheField):=[]
    for t in lp repeat
        lt := cons(t.int , lt)
    vi := sturmVariationsOf(reverse! lt)$UTIL
    o :Z := n - vl + vi
    if o > 0
    then 
       sturmNthRoot(lp,int,r,vi,vr,o::N)
    else
       sturmNthRoot(lp,l,int,vl,vi,n)

   sturmIsolate(lp,l,r,vl,vr) ==
    r <= l => error "ROIRC: sturmIsolate: bad bounds"
    n := (vl - vr)::N
    zero?(n) => []
    one?(n) => [[l,r]]
    int := (l+r)/(2::TheField)
    vi := sturmVariationsOf( [t.int for t in lp ] )$UTIL
    append(sturmIsolate(lp,l,int,vl,vi),sturmIsolate(lp,int,r,vi,vr))

   isolate(lp) ==
     b := rootBound(first(lp))
     l1,l2 : List(TheField)
     (l1,l2) := ([] , [])
     for t in reverse(lp) repeat
       if odd?(degree(t))
       then
        (l1,l2):= (cons(-leadingCoefficient(t),l1),
                   cons(leadingCoefficient(t),l2))
       else
        (l1,l2):= (cons(leadingCoefficient(t),l1),
                   cons(leadingCoefficient(t),l2))
     sturmIsolate(lp,
                  -b,
                  b,
                  sturmVariationsOf(l1)$UTIL,
                  sturmVariationsOf(l2)$UTIL)

   rootOf(pol,n) ==
    ls := sturmSequence(pol)$UTIL
    pol := unitCanonical(first(ls)) -- this one is SqFR
    degree(pol) = 0 => "failed"
    numberOfMonomials(pol) = 1 => ([0,1,monomial(1,1)]$Rep)::$
    b := rootBound(pol)
    l1,l2 : List(TheField)
    (l1,l2) := ([] , [])
    for t in reverse(ls) repeat
      if odd?(degree(t))
      then
       (l1,l2):= (cons(leadingCoefficient(t),l1),
                  cons(-leadingCoefficient(t),l2))
      else
       (l1,l2):= (cons(leadingCoefficient(t),l1),
                  cons(leadingCoefficient(t),l2))
    res := sturmNthRoot(ls,
                        -b,
                        b,
                        sturmVariationsOf(l2)$UTIL,
                        sturmVariationsOf(l1)$UTIL,
                        n)
    res case "failed" => "failed"
    makeChar(res.low,res.high,pol)

   allRootsOf(pol) == 
    ls := sturmSequence(unitCanonical pol)$UTIL
    pol := unitCanonical(first(ls)) -- this one is SqFR
    degree(pol) = 0 => []
    numberOfMonomials(pol) = 1 => [[0,1,monomial(1,1)]$Rep]
    [ makeChar(term.low,term.high,pol) for term in isolate(ls) ]


   hasVarsl(l:List(TheField)) ==
    null(l) => false
    f := sign(first(l))
    for term in rest(l) repeat
      if f*term < 0 then return(true)
    false
    
   hasVars(p:P) ==
    zero?(p) => error "ROIRC: hasVars: null polynonial"
    zero?(coefficient(p,0)) => true
    hasVarsl(coefficients(p))


   mightHaveRoots(p,rootChar) == 
      a := rootChar.low
      q := translate(p,a)
      not(hasVars(q)) => false
--      varStar(q) = 0 => false
      a := (rootChar.high) - a
      q := dilate(q,a)
      sign(coefficient(q,0))*sign(evalOne(q)) <= 0 => true
      q := minus(addOne(q))
      not(hasVars(q)) => false
--      varStar(q) = 0 => false
      q := invert(q)
      hasVars(addOne(q))
--      ^(varStar(addOne(q)) = 0)

   coerce(rootChar:$):O == 
     commaSeparate([ hconcat("[" :: O , (rootChar.low)::O), 
                     hconcat((rootChar.high)::O,"[" ::O ) ])

   c1 = c2 == 
     mM := max(c1.low,c2.low)
     Mm := min(c1.high,c2.high)
     mM >= Mm => false
     rr : ThePolDom := gcd(c1.defPol,c2.defPol)
     degree(rr) = 0 => false
     sign(rr.mM) * sign(rr.Mm) <= 0

   makeChar(left,right,pol) == 
<<performance problem>>
    res :$ := [left,right,leadingMonomial(pol)+reductum(pol)]$Rep -- safe copy
    while zero?(pol.(res.high)) repeat refine!(res)
    while (res.high * res.low < 0 ) repeat refine!(res)
    zero?(pol.(res.low)) => [res.low,res.high,monomial(1,1)-(res.low)::P]
    res

   definingPolynomial(rootChar) == rootChar.defPol

   linearRecip(toTest,rootChar) ==
      c := - inv(leadingCoefficient(toTest)) * coefficient(toTest,0)
      r := recip(rootChar.defPol.c)
      if (r case "failed")
      then
        if (c - rootChar.low) * (c - rootChar.high) <= 0
        then 
          "failed"
        else
          newPol := (rootChar.defPol exquo toTest)::P
          ((1$ThePolDom - inv(newPol.c)*newPol) exquo toTest)::P
      else
         ((1$ThePolDom - (r::TheField)*rootChar.defPol) exquo toTest)::P

   recip(toTest,rootChar) ==
     degree(toTest) = 0 or degree(rootChar.defPol) <= degree(toTest) =>
       error "IRC: recip: Not reduced"
     degree(rootChar.defPol) = 1 =>
       error "IRC: recip: Linear Defining Polynomial"
     degree(toTest) = 1 =>
       linearRecip(toTest, rootChar)
     d := extendedEuclidean((rootChar.defPol),toTest)
     (degree(d.generator) = 0 ) => 
         d.coef2
     d.generator := unitCanonical(d.generator)
     (d.generator.(rootChar.low) *
      d.generator.(rootChar.high)<= 0) => "failed"
     newPol := (rootChar.defPol exquo (d.generator))::P
     degree(newPol) = 1 =>
       c := - inv(leadingCoefficient(newPol)) * coefficient(newPol,0)
       inv(toTest.c)::P
     degree(toTest) = 1 => 
       c := - coefficient(toTest,0)/ leadingCoefficient(toTest)
       ((1$ThePolDom - inv(newPol.(c))*newPol) exquo toTest)::P
     d := extendedEuclidean(newPol,toTest)
     d.coef2

   linearSign(toTest,rootChar) ==
      c := - inv(leadingCoefficient(toTest)) * coefficient(toTest,0)
      ev := sign(rootChar.defPol.c)
      if zero?(ev)
      then
        if (c - rootChar.low) * (c - rootChar.high) <= 0
        then
          0
        else
          sign(toTest.(rootChar.high))
      else
        if (ev*sign(rootChar.defPol.(rootChar.high)) <= 0 )
        then
          sign(toTest.(rootChar.high))
        else
          sign(toTest.(rootChar.low))

   sign(toTest,rootChar) ==
     degree(toTest) = 0 or degree(rootChar.defPol) <= degree(toTest) =>
       error "IRC: sign: Not reduced"
     degree(rootChar.defPol) = 1 =>
       error "IRC: sign: Linear Defining Polynomial"
     degree(toTest) = 1 =>
      linearSign(toTest, rootChar)
     s := sign(leadingCoefficient(toTest))
     toTest := monomial(1,degree(toTest))+
               inv(leadingCoefficient(toTest))*reductum(toTest)
     delta := gcd(toTest,rootChar.defPol)
     newChar := [rootChar.low,rootChar.high,rootChar.defPol]$Rep
     if degree(delta) > 0
     then
       if sign(delta.(rootChar.low) * delta.(rootChar.high)) <= 0
       then
        return(0)
       else
        newChar.defPol := (newChar.defPol exquo delta) :: P
        toTest := toTest rem (newChar.defPol)
     degree(toTest) = 0 => s * sign(leadingCoefficient(toTest))
     degree(toTest) = 1 => s * linearSign(toTest, newChar)
     while mightHaveRoots(toTest,newChar) repeat
       newChar := refine(newChar)
     s*sign(toTest.(newChar.low))

   linearZero?(c,rootChar) == 
      zero?((rootChar.defPol).c) and 
       (c - rootChar.low) * (c - rootChar.high) <= 0

   zero?(toTest,rootChar) ==
     degree(toTest) = 0 or degree(rootChar.defPol) <= degree(toTest) =>
       error "IRC: zero?: Not reduced"
     degree(rootChar.defPol) = 1 =>
       error "IRC: zero?: Linear Defining Polynomial"
     degree(toTest) = 1 => 
      linearZero?(- inv(leadingCoefficient(toTest)) * coefficient(toTest,0),
                  rootChar)
     toTest := monomial(1,degree(toTest))+
               inv(leadingCoefficient(toTest))*reductum(toTest)
     delta := gcd(toTest,rootChar.defPol)
     degree(delta) = 0 => false
     sign(delta.(rootChar.low) * delta.(rootChar.high)) <= 0


   refine!(rootChar) ==
     -- this is not a safe function, it can work with badly created object
     -- we do not assume (rootChar.defPol).(rootChar.high) <> 0
        int := middle(rootChar)
        s1 := sign((rootChar.defPol).(rootChar.low))
        zero?(s1) =>
          rootChar.high := int
          rootChar.defPol := monomial(1,1) - (rootChar.low)::P
          rootChar
        s2 := sign((rootChar.defPol).int)
        zero?(s2) =>
          rootChar.low := int
          rootChar.defPol := monomial(1,1) - int::P
          rootChar
        if (s1*s2 < 0)
        then 
          rootChar.high := int
        else 
          rootChar.low := int
        rootChar

   refine(rootChar) ==
     -- we assume (rootChar.defPol).(rootChar.high) <> 0
        int := middle(rootChar)
        s:= (rootChar.defPol).int * (rootChar.defPol).(rootChar.high)
        zero?(s) => [int,rootChar.high,monomial(1,1)-int::P]
        if s < 0 
        then 
          [int,rootChar.high,rootChar.defPol]
        else 
          [rootChar.low,int,rootChar.defPol]

   left(rootChar) == rootChar.low

   right(rootChar) == rootChar.high

   middle(rootChar) == (rootChar.low + rootChar.high)/(2::TheField)

--   varStar(p) == -- if 0 no roots in [0,:infty[
--     res : N := 0
--     lsg := sign(coefficient(p,0))
--     l := [ sign(i) for i in reverse!(coefficients(p))]
--     for sg in l repeat
--      if (sg ^= lsg) then res := res + 1
--      lsg := sg
--     res
@
\section{domain RECLOS RealClosure}
The domain constructore {\bf RealClosure} by Renaud Rioboo (University
of Paris 6, France) provides the real closure of an ordered field.
The implementation is based on interval arithmetic. Moreover, the
design of this constructor and its related packages allows an easy
use of other codings for real algebraic numbers.
ordered field
<<RealClosure.input>>=
-- reclos.spad.pamphlet RealClosure.input
)spool RealClosure.output
)set message test on
)set message auto off
)clear all
--S 1 of 67
Ran := RECLOS(FRAC INT)
--R 
--R
--R   (1)  RealClosure Fraction Integer
--R                                                                 Type: Domain
--E 1

--S 2 of 67
fourSquares(a:Ran,b:Ran,c:Ran,d:Ran):Ran==sqrt(a)+sqrt(b)-sqrt(c)-sqrt(d)
--R 
--R   Function declaration fourSquares : (RealClosure Fraction Integer,
--R      RealClosure Fraction Integer,RealClosure Fraction Integer,
--R      RealClosure Fraction Integer) -> RealClosure Fraction Integer has
--R      been added to workspace.
--R                                                                   Type: Void
--E 2

--S 3 of 67
squareDiff1 := fourSquares(73,548,60,586)
--R 
--R   Compiling function fourSquares with type (RealClosure Fraction 
--R      Integer,RealClosure Fraction Integer,RealClosure Fraction Integer
--R      ,RealClosure Fraction Integer) -> RealClosure Fraction Integer 
--R
--R           +---+    +--+    +---+    +--+
--R   (3)  - \|586  - \|60  + \|548  + \|73
--R                                           Type: RealClosure Fraction Integer
--E 3

--S 4 of 67
recip(squareDiff1)
--R 
--R
--R   (4)
--R             +---+          +--+  +--+         +--+ +---+            +---+
--R     ((54602\|548  + 149602\|73 )\|60  + 49502\|73 \|548  + 9900895)\|586
--R   + 
--R             +--+ +---+             +--+            +---+            +--+
--R     (154702\|73 \|548  + 30941947)\|60  + 10238421\|548  + 28051871\|73
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 4

--S 5 of 67
sign(squareDiff1)
--R 
--R
--R   (5)  1
--R                                                        Type: PositiveInteger
--E 5

--S 6 of 67
squareDiff2 := fourSquares(165,778,86,990)
--R 
--R
--R           +---+    +--+    +---+    +---+
--R   (6)  - \|990  - \|86  + \|778  + \|165
--R                                           Type: RealClosure Fraction Integer
--E 6

--S 7 of 67
recip(squareDiff2)
--R 
--R
--R   (7)
--R                +---+           +---+  +--+          +---+ +---+
--R       ((556778\|778  + 1209010\|165 )\|86  + 401966\|165 \|778  + 144019431)
--R    *
--R        +---+
--R       \|990
--R   + 
--R              +---+ +---+              +--+             +---+             +---+
--R     (1363822\|165 \|778  + 488640503)\|86  + 162460913\|778  + 352774119\|165
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 7

--S 8 of 67
sign(squareDiff2)
--R 
--R
--R   (8)  1
--R                                                        Type: PositiveInteger
--E 8

--S 9 of 67
squareDiff3 := fourSquares(217,708,226,692)
--R 
--R
--R           +---+    +---+    +---+    +---+
--R   (9)  - \|692  - \|226  + \|708  + \|217
--R                                           Type: RealClosure Fraction Integer
--E 9

--S 10 of 67
recip(squareDiff3)
--R 
--R
--R   (10)
--R               +---+         +---+  +---+         +---+ +---+             +---+
--R     ((- 34102\|708  - 61598\|217 )\|226  - 34802\|217 \|708  - 13641141)\|692
--R   + 
--R              +---+ +---+             +---+            +---+            +---+
--R     (- 60898\|217 \|708  - 23869841)\|226  - 13486123\|708  - 24359809\|217
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 10

--S 11 of 67
sign(squareDiff3)
--R 
--R
--R   (11)  - 1
--R                                                                Type: Integer
--E 11

--S 12 of 67
squareDiff4 := fourSquares(155,836,162,820)
--R 
--R
--R            +---+    +---+    +---+    +---+
--R   (12)  - \|820  - \|162  + \|836  + \|155
--R                                           Type: RealClosure Fraction Integer
--E 12

--S 13 of 67
recip(squareDiff4)
--R 
--R
--R   (13)
--R               +---+         +---+  +---+         +---+ +---+             +---+
--R     ((- 37078\|836  - 86110\|155 )\|162  - 37906\|155 \|836  - 13645107)\|820
--R   + 
--R              +---+ +---+             +---+            +---+            +---+
--R     (- 85282\|155 \|836  - 30699151)\|162  - 13513901\|836  - 31384703\|155
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 13

--S 14 of 67
sign(squareDiff4)
--R 
--R
--R   (14)  - 1
--R                                                                Type: Integer
--E 14

--S 15 of 67
squareDiff5 := fourSquares(591,772,552,818)
--R 
--R
--R            +---+    +---+    +---+    +---+
--R   (15)  - \|818  - \|552  + \|772  + \|591
--R                                           Type: RealClosure Fraction Integer
--E 15

--S 16 of 67
recip(squareDiff5)
--R 
--R
--R   (16)
--R             +---+         +---+  +---+         +---+ +---+             +---+
--R     ((70922\|772  + 81058\|591 )\|552  + 68542\|591 \|772  + 46297673)\|818
--R   + 
--R            +---+ +---+             +---+            +---+            +---+
--R     (83438\|591 \|772  + 56359389)\|552  + 47657051\|772  + 54468081\|591
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 16

--S 17 of 67
sign(squareDiff5)
--R 
--R
--R   (17)  1
--R                                                        Type: PositiveInteger
--E 17

--S 18 of 67
squareDiff6 := fourSquares(434,1053,412,1088)
--R 
--R
--R            +----+    +---+    +----+    +---+
--R   (18)  - \|1088  - \|412  + \|1053  + \|434
--R                                           Type: RealClosure Fraction Integer
--E 18

--S 19 of 67
recip(squareDiff6)
--R 
--R
--R   (19)
--R                +----+          +---+  +---+          +---+ +----+
--R       ((115442\|1053  + 179818\|434 )\|412  + 112478\|434 \|1053  + 76037291)
--R    *
--R        +----+
--R       \|1088
--R   + 
--R           +---+ +----+              +---+            +----+             +---+
--R   (182782\|434 \|1053  + 123564147)\|412  + 77290639\|1053  + 120391609\|434
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 19

--S 20 of 67
sign(squareDiff6)
--R 
--R
--R   (20)  1
--R                                                        Type: PositiveInteger
--E 20

--S 21 of 67
squareDiff7 := fourSquares(514,1049,446,1152)
--R 
--R
--R            +----+    +---+    +----+    +---+
--R   (21)  - \|1152  - \|446  + \|1049  + \|514
--R                                           Type: RealClosure Fraction Integer
--E 21

--S 22 of 67
recip(squareDiff7)
--R 
--R
--R   (22)
--R                +----+          +---+  +---+          +---+ +----+
--R       ((349522\|1049  + 499322\|514 )\|446  + 325582\|514 \|1049  + 239072537)
--R    *
--R        +----+
--R       \|1152
--R   + 
--R           +---+ +----+              +---+             +----+             +---+
--R   (523262\|514 \|1049  + 384227549)\|446  + 250534873\|1049  + 357910443\|514
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 22

--S 23 of 67
sign(squareDiff7)
--R 
--R
--R   (23)  1
--R                                                        Type: PositiveInteger
--E 23

--S 24 of 67
squareDiff8 := fourSquares(190,1751,208,1698)
--R 
--R
--R            +----+    +---+    +----+    +---+
--R   (24)  - \|1698  - \|208  + \|1751  + \|190
--R                                           Type: RealClosure Fraction Integer
--E 24

--S 25 of 67
recip(squareDiff8)
--R 
--R
--R   (25)
--R                     +----+          +---+  +---+          +---+ +----+
--R           (- 214702\|1751  - 651782\|190 )\|208  - 224642\|190 \|1751
--R         + 
--R           - 129571901
--R    *
--R        +----+
--R       \|1698
--R   + 
--R               +---+ +----+              +---+             +----+
--R     (- 641842\|190 \|1751  - 370209881)\|208  - 127595865\|1751
--R   + 
--R                 +---+
--R     - 387349387\|190
--R                                Type: Union(RealClosure Fraction Integer,...)
--E 25

--S 26 of 67
sign(squareDiff8)
--R 
--R
--R   (26)  - 1
--R                                                                Type: Integer
--E 26

--S 27 of 67
relativeApprox(squareDiff8,10**(-3))::Float
--R 
--R
--R   (27)  - 0.2340527771 5937700123 E -10
--R                                                                  Type: Float
--E 27

--S 28 of 67
l := allRootsOf((x**2-2)**2-2)$Ran
--R 
--R
--R   (28)  [%A33,%A34,%A35,%A36]
--R                                      Type: List RealClosure Fraction Integer
--E 28

--S 29 of 67
removeDuplicates map(mainDefiningPolynomial,l)
--R 
--R
--R           4     2
--R   (29)  [?  - 4?  + 2]
--RType: List Union(SparseUnivariatePolynomial RealClosure Fraction Integer,"failed")
--E 29

--S 30 of 67
map(mainCharacterization,l)
--R 
--R
--R   (30)  [[- 2,- 1[,[- 1,0[,[0,1[,[1,2[]
--RType: List Union(RightOpenIntervalRootCharacterization(RealClosure Fraction Integer,SparseUnivariatePolynomial RealClosure Fraction Integer),"failed")
--E 30

--S 31 of 67
[reduce(+,l),reduce(*,l)-2]
--R 
--R
--R   (31)  [0,0]
--R                                      Type: List RealClosure Fraction Integer
--E 31

--S 32 of 67
(s2, s5, s10) := (sqrt(2)$Ran, sqrt(5)$Ran, sqrt(10)$Ran)
--R 
--R
--R          +--+
--R   (32)  \|10
--R                                           Type: RealClosure Fraction Integer
--E 32

--S 33 of 67
eq1:=sqrt(s10+3)*sqrt(s5+2) - sqrt(s10-3)*sqrt(s5-2) = sqrt(10*s2+10)
--R 
--R
--R            +---------+ +--------+    +---------+ +--------+   +-----------+
--R            | +--+      | +-+         | +--+      | +-+        |   +-+
--R   (33)  - \|\|10  - 3 \|\|5  - 2  + \|\|10  + 3 \|\|5  + 2 = \|10\|2  + 10
--R                                  Type: Equation RealClosure Fraction Integer
--E 33

--S 34 of 67
eq1::Boolean
--R 
--R
--R   (34)  true
--R                                                                Type: Boolean
--E 34

--S 35 of 67
eq2:=sqrt(s5+2)*sqrt(s2+1) - sqrt(s5-2)*sqrt(s2-1) = sqrt(2*s10+2)
--R 
--R
--R            +--------+ +--------+    +--------+ +--------+   +----------+
--R            | +-+      | +-+         | +-+      | +-+        |  +--+
--R   (35)  - \|\|5  - 2 \|\|2  - 1  + \|\|5  + 2 \|\|2  + 1 = \|2\|10  + 2
--R                                  Type: Equation RealClosure Fraction Integer
--E 35

--S 36 of 67
eq2::Boolean
--R 
--R
--R   (36)  true
--R                                                                Type: Boolean
--E 36

--S 37 of 67
s3 := sqrt(3)$Ran
--R 
--R
--R          +-+
--R   (37)  \|3
--R                                           Type: RealClosure Fraction Integer
--E 37

--S 38 of 67
s7:= sqrt(7)$Ran
--R 
--R
--R          +-+
--R   (38)  \|7
--R                                           Type: RealClosure Fraction Integer
--E 38

--S 39 of 67
e1 := sqrt(2*s7-3*s3,3)
--R 
--R
--R          +-------------+
--R         3|  +-+     +-+
--R   (39)  \|2\|7  - 3\|3
--R                                           Type: RealClosure Fraction Integer
--E 39

--S 40 of 67
e2 := sqrt(2*s7+3*s3,3)
--R 
--R
--R          +-------------+
--R         3|  +-+     +-+
--R   (40)  \|2\|7  + 3\|3
--R                                           Type: RealClosure Fraction Integer
--E 40

--S 41 of 67
e2-e1-s3
--R 
--R
--R   (41)  0
--R                                           Type: RealClosure Fraction Integer
--E 41

--S 42 of 67
pol : UP(x,Ran) := x**4+(7/3)*x**2+30*x-(100/3)
--R 
--R
--R          4   7  2         100
--R   (42)  x  + - x  + 30x - ---
--R              3             3
--R                   Type: UnivariatePolynomial(x,RealClosure Fraction Integer)
--E 42

--S 43 of 67
r1 := sqrt(7633)$Ran
--R 
--R
--R          +----+
--R   (43)  \|7633
--R                                           Type: RealClosure Fraction Integer
--E 43

--S 44 of 67
alpha := sqrt(5*r1-436,3)/3
--R 
--R
--R            +--------------+
--R         1 3|  +----+
--R   (44)  - \|5\|7633  - 436
--R         3
--R                                           Type: RealClosure Fraction Integer
--E 44

--S 45 of 67
beta := -sqrt(5*r1+436,3)/3 
--R 
--R
--R              +--------------+
--R           1 3|  +----+
--R   (45)  - - \|5\|7633  + 436
--R           3
--R                                           Type: RealClosure Fraction Integer
--E 45

--S 46 of 67
pol.(alpha+beta-1/3)
--R 
--R
--R   (46)  0
--R                                           Type: RealClosure Fraction Integer
--E 46

--S 47 of 67
qol : UP(x,Ran) := x**5+10*x**3+20*x+22
--R 
--R
--R          5      3
--R   (47)  x  + 10x  + 20x + 22
--R                   Type: UnivariatePolynomial(x,RealClosure Fraction Integer)
--E 47

--S 48 of 67
r2 := sqrt(153)$Ran
--R 
--R
--R          +---+
--R   (48)  \|153
--R                                           Type: RealClosure Fraction Integer
--E 48

--S 49 of 67
alpha2 := sqrt(r2-11,5)
--R 
--R
--R          +-----------+
--R         5| +---+
--R   (49)  \|\|153  - 11
--R                                           Type: RealClosure Fraction Integer
--E 49

--S 50 of 67
beta2 := -sqrt(r2+11,5)
--R 
--R
--R            +-----------+
--R           5| +---+
--R   (50)  - \|\|153  + 11
--R                                           Type: RealClosure Fraction Integer
--E 50

--S 51 of 67
qol(alpha2+beta2)
--R 
--R
--R   (51)  0
--R                                           Type: RealClosure Fraction Integer
--E 51

--S 52 of 67
dst1:=sqrt(9+4*s2)=1+2*s2
--R 
--R
--R          +---------+
--R          |  +-+         +-+
--R   (52)  \|4\|2  + 9 = 2\|2  + 1
--R                                  Type: Equation RealClosure Fraction Integer
--E 52

--S 53 of 67
dst1::Boolean
--R 
--R
--R   (53)  true
--R                                                                Type: Boolean
--E 53

--S 54 of 67
s6:Ran:=sqrt 6
--R 
--R
--R          +-+
--R   (54)  \|6
--R                                           Type: RealClosure Fraction Integer
--E 54

--S 55 of 67
dst2:=sqrt(5+2*s6)+sqrt(5-2*s6) = 2*s3
--R 
--R
--R          +-----------+    +---------+
--R          |    +-+         |  +-+         +-+
--R   (55)  \|- 2\|6  + 5  + \|2\|6  + 5 = 2\|3
--R                                  Type: Equation RealClosure Fraction Integer
--E 55

--S 56 of 67
dst2::Boolean
--R 
--R
--R   (56)  true
--R                                                                Type: Boolean
--E 56

--S 57 of 67
s29:Ran:=sqrt 29
--R 
--R
--R          +--+
--R   (57)  \|29
--R                                           Type: RealClosure Fraction Integer
--E 57

--S 58 of 67
dst4:=sqrt(16-2*s29+2*sqrt(55-10*s29)) = sqrt(22+2*s5)-sqrt(11+2*s29)+s5
--R 
--R
--R   (58)
--R    +--------------------------------+
--R    |  +--------------+                    +-----------+    +----------+
--R    |  |     +--+           +--+           |  +--+          |  +-+          +-+
--R   \|2\|- 10\|29  + 55  - 2\|29  + 16 = - \|2\|29  + 11  + \|2\|5  + 22  + \|5
--R                                  Type: Equation RealClosure Fraction Integer
--E 58

--S 59 of 67
dst4::Boolean
--R 
--R
--R   (59)  true
--R                                                                Type: Boolean
--E 59

--S 60 of 67
dst6:=sqrt((112+70*s2)+(46+34*s2)*s5) = (5+4*s2)+(3+s2)*s5 
--R 
--R
--R          +--------------------------------+
--R          |    +-+       +-+      +-+           +-+      +-+     +-+
--R   (60)  \|(34\|2  + 46)\|5  + 70\|2  + 112 = (\|2  + 3)\|5  + 4\|2  + 5
--R                                  Type: Equation RealClosure Fraction Integer
--E 60

--S 61 of 67
dst6::Boolean
--R 
--R
--R   (61)  true
--R                                                                Type: Boolean
--E 61

--S 62 of 67
f3:Ran:=sqrt(3,5)
--R 
--R
--R         5+-+
--R   (62)  \|3
--R                                           Type: RealClosure Fraction Integer
--E 62

--S 63 of 67
f25:Ran:=sqrt(1/25,5)
--R 
--R
--R          +--+
--R          | 1
--R   (63)  5|--
--R         \|25
--R                                           Type: RealClosure Fraction Integer
--E 63

--S 64 of 67
f32:Ran:=sqrt(32/5,5)
--R 
--R
--R          +--+
--R          |32
--R   (64)  5|--
--R         \| 5
--R                                           Type: RealClosure Fraction Integer
--E 64

--S 65 of 67
f27:Ran:=sqrt(27/5,5)
--R 
--R
--R          +--+
--R          |27
--R   (65)  5|--
--R         \| 5
--R                                           Type: RealClosure Fraction Integer
--E 65

--S 66 of 67
dst5:=sqrt((f32-f27,3)) = f25*(1+f3-f3**2)
--R 
--R
--R          +---------------+
--R          |   +--+    +--+                         +--+
--R          |   |27     |32       5+-+2   5+-+       | 1
--R   (66)  3|- 5|--  + 5|--  = (- \|3   + \|3  + 1) 5|--
--R         \|  \| 5    \| 5                         \|25
--R                                  Type: Equation RealClosure Fraction Integer
--E 66

--S 67 of 67
dst5::Boolean
--R 
--R
--R   (67)  true
--R                                                                Type: Boolean
--E 67
)spool
)lisp (bye)
@
<<RealClosure.help>>=
====================================================================
RealClosure examples
====================================================================

The Real Closure 1.0 package provided by Renaud Rioboo consists of
different packages, categories and domains :

The package RealPolynomialUtilitiesPackage which needs a Field F and a 
UnivariatePolynomialCategory domain with coefficients in F. It computes 
some simple functions such as Sturm and Sylvester sequences sturmSequence,
sylvesterSequence.

The category RealRootCharacterizationCategory provides abstract
functions to work with "real roots" of univariate polynomials. These
resemble variables with some functionality needed to compute important
operations.

The category RealClosedField provides common operations available over
real closed fiels. These include finding all the roots of a univariate
polynomial, taking square (and higher) roots, ...

The domain RightOpenIntervalRootCharacterization is the main code that
provides the functionality of RealRootCharacterizationCategory for the
case of archimedean fields. Abstract roots are encoded with a left
closed right open interval containing the root together with a
defining polynomial for the root.

The RealClosure domain is the end-user code. It provides usual arithmetic 
with real algebraic numbers, along with the functionality of a real closed 
field. It also provides functions to approximate a real algebraic number 
by an element of the base field. This approximation may either be absolute, 
approximate or relative (relativeApprox).

====================================================================
CAVEATS
====================================================================

Since real algebraic expressions are stored as depending on "real
roots" which are managed like variables, there is an ordering on
these. This ordering is dynamical in the sense that any new algebraic
takes precedence over older ones. In particular every creation
function raises a new "real root". This has the effect that when you
type something like sqrt(2) + sqrt(2) you have two new variables
which happen to be equal. To avoid this name the expression such as in
s2 := sqrt(2) ; s2 + s2

Also note that computing times depend strongly on the ordering you
implicitly provide. Please provide algebraics in the order which seems
most natural to you.

====================================================================
LIMITATIONS
====================================================================

This packages uses algorithms which are published in [1] and [2] which
are based on field arithmetics, in particular for polynomial gcd
related algorithms. This can be quite slow for high degree polynomials
and subresultants methods usually work best. Beta versions of the
package try to use these techniques in a better way and work
significantly faster. These are mostly based on unpublished algorithms
and cannot be distributed. Please contact the author if you have a
particular problem to solve or want to use these versions.

Be aware that approximations behave as post-processing and that all
computations are done exactly. They can thus be quite time consuming when
depending on several ``real roots''.

====================================================================
REFERENCES
====================================================================


[1]  R. Rioboo : Real Algebraic Closure of an ordered Field : Implementation 
     in Axiom. 
     In proceedings of the ISSAC'92 Conference, Berkeley 1992 pp. 206-215.

[2]  Z. Ligatsikas, R. Rioboo, M. F. Roy : Generic computation of the real
     closure of an ordered field.
     In Mathematics and Computers in Simulation Volume 42, Issue 4-6,
     November 1996.

====================================================================
EXAMPLES
====================================================================

We shall work with the real closure of the ordered field of 
rational numbers.

  Ran := RECLOS(FRAC INT)
    RealClosure Fraction Integer
                              Type: Domain

Some simple signs for square roots, these correspond to an extension
of degree 16 of the rational numbers. Examples provided by J. Abbot.

  fourSquares(a:Ran,b:Ran,c:Ran,d:Ran):Ran==sqrt(a)+sqrt(b)-sqrt(c)-sqrt(d)
                              Type: Void

These produce values very close to zero.

  squareDiff1 := fourSquares(73,548,60,586)
       +---+    +--+    +---+    +--+
    - \|586  - \|60  + \|548  + \|73
                              Type: RealClosure Fraction Integer

  recip(squareDiff1)
             +---+          +--+  +--+         +--+ +---+            +---+
     ((54602\|548  + 149602\|73 )\|60  + 49502\|73 \|548  + 9900895)\|586
   + 
             +--+ +---+             +--+            +---+            +--+
     (154702\|73 \|548  + 30941947)\|60  + 10238421\|548  + 28051871\|73
                              Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff1)
    1
                              Type: PositiveInteger

  squareDiff2 := fourSquares(165,778,86,990)
       +---+    +--+    +---+    +---+
    - \|990  - \|86  + \|778  + \|165
                              Type: RealClosure Fraction Integer

  recip(squareDiff2)
                +---+           +---+  +--+          +---+ +---+
       ((556778\|778  + 1209010\|165 )\|86  + 401966\|165 \|778  + 144019431)
    *
        +---+
       \|990
   + 
              +---+ +---+              +--+             +---+             +---+
     (1363822\|165 \|778  + 488640503)\|86  + 162460913\|778  + 352774119\|165
                              Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff2)
    1
                              Type: PositiveInteger

  squareDiff3 := fourSquares(217,708,226,692)
       +---+    +---+    +---+    +---+
    - \|692  - \|226  + \|708  + \|217
                              Type: RealClosure Fraction Integer

  recip(squareDiff3)
               +---+         +---+  +---+         +---+ +---+             +---+
     ((- 34102\|708  - 61598\|217 )\|226  - 34802\|217 \|708  - 13641141)\|692
   + 
              +---+ +---+             +---+            +---+            +---+
     (- 60898\|217 \|708  - 23869841)\|226  - 13486123\|708  - 24359809\|217
                              Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff3)
    - 1
                              Type: Integer

  squareDiff4 := fourSquares(155,836,162,820)
       +---+    +---+    +---+    +---+
    - \|820  - \|162  + \|836  + \|155
                              Type: RealClosure Fraction Integer

  recip(squareDiff4)
               +---+         +---+  +---+         +---+ +---+             +---+
     ((- 37078\|836  - 86110\|155 )\|162  - 37906\|155 \|836  - 13645107)\|820
   + 
              +---+ +---+             +---+            +---+            +---+
     (- 85282\|155 \|836  - 30699151)\|162  - 13513901\|836  - 31384703\|155
                              Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff4)
    - 1
                              Type: Integer

  squareDiff5 := fourSquares(591,772,552,818)
       +---+    +---+    +---+    +---+
    - \|818  - \|552  + \|772  + \|591
                              Type: RealClosure Fraction Integer

  recip(squareDiff5)
             +---+         +---+  +---+         +---+ +---+             +---+
     ((70922\|772  + 81058\|591 )\|552  + 68542\|591 \|772  + 46297673)\|818
   + 
            +---+ +---+             +---+            +---+            +---+
     (83438\|591 \|772  + 56359389)\|552  + 47657051\|772  + 54468081\|591
                              Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff5)
    1
                              Type: PositiveInteger

  squareDiff6 := fourSquares(434,1053,412,1088)
       +----+    +---+    +----+    +---+
    - \|1088  - \|412  + \|1053  + \|434
                              Type: RealClosure Fraction Integer

  recip(squareDiff6)
                +----+          +---+  +---+          +---+ +----+
       ((115442\|1053  + 179818\|434 )\|412  + 112478\|434 \|1053  + 76037291)
    *
        +----+
       \|1088
   + 
           +---+ +----+              +---+            +----+             +---+
   (182782\|434 \|1053  + 123564147)\|412  + 77290639\|1053  + 120391609\|434
                             Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff6)
    1
                             Type: PositiveInteger

  squareDiff7 := fourSquares(514,1049,446,1152)
       +----+    +---+    +----+    +---+
    - \|1152  - \|446  + \|1049  + \|514
                             Type: RealClosure Fraction Integer

  recip(squareDiff7)
                +----+          +---+  +---+          +---+ +----+
       ((349522\|1049  + 499322\|514 )\|446  + 325582\|514 \|1049  + 239072537)
    *
        +----+
       \|1152
   + 
           +---+ +----+              +---+             +----+             +---+
   (523262\|514 \|1049  + 384227549)\|446  + 250534873\|1049  + 357910443\|514
                             Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff7)
    1
                             Type: PositiveInteger

  squareDiff8 := fourSquares(190,1751,208,1698)
       +----+    +---+    +----+    +---+
    - \|1698  - \|208  + \|1751  + \|190
                             Type: RealClosure Fraction Integer

  recip(squareDiff8)
                     +----+          +---+  +---+          +---+ +----+
           (- 214702\|1751  - 651782\|190 )\|208  - 224642\|190 \|1751
         + 
           - 129571901
    *
        +----+
       \|1698
   + 
               +---+ +----+              +---+             +----+
     (- 641842\|190 \|1751  - 370209881)\|208  - 127595865\|1751
   + 
                 +---+
     - 387349387\|190
                            Type: Union(RealClosure Fraction Integer,...)

  sign(squareDiff8)
    - 1
                            Type: Integer

This should give three digits of precision

  relativeApprox(squareDiff8,10**(-3))::Float
    - 0.2340527771 5937700123 E -10
                            Type: Float

The sum of these 4 roots is 0

  l := allRootsOf((x**2-2)**2-2)$Ran
    [%A33,%A34,%A35,%A36]
                            Type: List RealClosure Fraction Integer

Check that they are all roots of the same polynomial

  removeDuplicates map(mainDefiningPolynomial,l)
      4     2
    [?  - 4?  + 2]
       Type: List Union(
                   SparseUnivariatePolynomial RealClosure Fraction Integer,
                   "failed")

We can see at a glance that they are separate roots

  map(mainCharacterization,l)
    [[- 2,- 1[,[- 1,0[,[0,1[,[1,2[]
       Type: List Union(
              RightOpenIntervalRootCharacterization(
               RealClosure Fraction Integer,
               SparseUnivariatePolynomial RealClosure Fraction Integer),
              "failed")

Check the sum and product

  [reduce(+,l),reduce(*,l)-2]
    [0,0]
                    Type: List RealClosure Fraction Integer

A more complicated test that involve an extension of degree 256.
This is a way of checking nested radical identities.

  (s2, s5, s10) := (sqrt(2)$Ran, sqrt(5)$Ran, sqrt(10)$Ran)
     +--+
    \|10
                    Type: RealClosure Fraction Integer

  eq1:=sqrt(s10+3)*sqrt(s5+2) - sqrt(s10-3)*sqrt(s5-2) = sqrt(10*s2+10)
       +---------+ +--------+    +---------+ +--------+   +-----------+
       | +--+      | +-+         | +--+      | +-+        |   +-+
    - \|\|10  - 3 \|\|5  - 2  + \|\|10  + 3 \|\|5  + 2 = \|10\|2  + 10
                    Type: Equation RealClosure Fraction Integer

  eq1::Boolean
    true
                    Type: Boolean

  eq2:=sqrt(s5+2)*sqrt(s2+1) - sqrt(s5-2)*sqrt(s2-1) = sqrt(2*s10+2)
       +--------+ +--------+    +--------+ +--------+   +----------+
       | +-+      | +-+         | +-+      | +-+        |  +--+
    - \|\|5  - 2 \|\|2  - 1  + \|\|5  + 2 \|\|2  + 1 = \|2\|10  + 2
                    Type: Equation RealClosure Fraction Integer

  eq2::Boolean
    true
                    Type: Boolean

Some more examples from J. M. Arnaudies

  s3 := sqrt(3)$Ran
     +-+
    \|3
                    Type: RealClosure Fraction Integer

  s7:= sqrt(7)$Ran
     +-+
    \|7
                    Type: RealClosure Fraction Integer

  e1 := sqrt(2*s7-3*s3,3)
     +-------------+
    3|  +-+     +-+
    \|2\|7  - 3\|3
                    Type: RealClosure Fraction Integer

  e2 := sqrt(2*s7+3*s3,3)
     +-------------+
    3|  +-+     +-+
    \|2\|7  + 3\|3
                    Type: RealClosure Fraction Integer

This should be null

  e2-e1-s3
    0
                    Type: RealClosure Fraction Integer

A quartic polynomial

  pol : UP(x,Ran) := x**4+(7/3)*x**2+30*x-(100/3)
     4   7  2         100
    x  + - x  + 30x - ---
         3             3
                  Type: UnivariatePolynomial(x,RealClosure Fraction Integer)

Add some cubic roots

  r1 := sqrt(7633)$Ran
     +----+
    \|7633
                        Type: RealClosure Fraction Integer

  alpha := sqrt(5*r1-436,3)/3
       +--------------+
    1 3|  +----+
    - \|5\|7633  - 436
    3
                        Type: RealClosure Fraction Integer

  beta := -sqrt(5*r1+436,3)/3 
         +--------------+
      1 3|  +----+
    - - \|5\|7633  + 436
      3
                        Type: RealClosure Fraction Integer

this should be null

  pol.(alpha+beta-1/3)
    0
                        Type: RealClosure Fraction Integer

A quintic polynomial

  qol : UP(x,Ran) := x**5+10*x**3+20*x+22
     5      3
    x  + 10x  + 20x + 22
              Type: UnivariatePolynomial(x,RealClosure Fraction Integer)

Add some cubic roots

  r2 := sqrt(153)$Ran
     +---+
    \|153
                          Type: RealClosure Fraction Integer

  alpha2 := sqrt(r2-11,5)
     +-----------+
    5| +---+
    \|\|153  - 11
                          Type: RealClosure Fraction Integer

  beta2 := -sqrt(r2+11,5)
       +-----------+
      5| +---+
    - \|\|153  + 11
                          Type: RealClosure Fraction Integer

this should be null

  qol(alpha2+beta2)
    0
                          Type: RealClosure Fraction Integer

Finally, some examples from the book Computer Algebra by Davenport,
Siret and Tournier (page 77).  The last one is due to Ramanujan.

  dst1:=sqrt(9+4*s2)=1+2*s2
     +---------+
     |  +-+         +-+
    \|4\|2  + 9 = 2\|2  + 1
                          Type: Equation RealClosure Fraction Integer

  dst1::Boolean
    true
                          Type: Boolean

  s6:Ran:=sqrt 6
     +-+
    \|6
                          Type: RealClosure Fraction Integer

  dst2:=sqrt(5+2*s6)+sqrt(5-2*s6) = 2*s3
     +-----------+    +---------+
     |    +-+         |  +-+         +-+
    \|- 2\|6  + 5  + \|2\|6  + 5 = 2\|3
                          Type: Equation RealClosure Fraction Integer

  dst2::Boolean
    true
                          Type: Boolean

  s29:Ran:=sqrt 29
     +--+
    \|29
                          Type: RealClosure Fraction Integer

  dst4:=sqrt(16-2*s29+2*sqrt(55-10*s29)) = sqrt(22+2*s5)-sqrt(11+2*s29)+s5
    +--------------------------------+
    |  +--------------+                    +-----------+    +----------+
    |  |     +--+           +--+           |  +--+          |  +-+          +-+
   \|2\|- 10\|29  + 55  - 2\|29  + 16 = - \|2\|29  + 11  + \|2\|5  + 22  + \|5
                          Type: Equation RealClosure Fraction Integer

  dst4::Boolean
    true
                          Type: Boolean

  dst6:=sqrt((112+70*s2)+(46+34*s2)*s5) = (5+4*s2)+(3+s2)*s5 
     +--------------------------------+
     |    +-+       +-+      +-+           +-+      +-+     +-+
    \|(34\|2  + 46)\|5  + 70\|2  + 112 = (\|2  + 3)\|5  + 4\|2  + 5
                          Type: Equation RealClosure Fraction Integer

  dst6::Boolean
    true
                          Type: Boolean

  f3:Ran:=sqrt(3,5)
    5+-+
    \|3
                          Type: RealClosure Fraction Integer

  f25:Ran:=sqrt(1/25,5)
     +--+
     | 1
    5|--
    \|25
                          Type: RealClosure Fraction Integer

  f32:Ran:=sqrt(32/5,5)
     +--+
     |32
    5|--
    \| 5
                          Type: RealClosure Fraction Integer

  f27:Ran:=sqrt(27/5,5)
     +--+
     |27
    5|--
    \| 5
                          Type: RealClosure Fraction Integer

  dst5:=sqrt((f32-f27,3)) = f25*(1+f3-f3**2)
     +---------------+
     |   +--+    +--+                         +--+
     |   |27     |32       5+-+2   5+-+       | 1
    3|- 5|--  + 5|--  = (- \|3   + \|3  + 1) 5|--
    \|  \| 5    \| 5                         \|25
                          Type: Equation RealClosure Fraction Integer

  dst5::Boolean
    true
                          Type: Boolean

See Also:
o )help RightOpenIntervalRootCharacterization
o )help RealClosedField
o )help RealRootCharacterizationCategory
o )help UnivariatePolynomialCategory
o )help Field
o )help RealPolynomialUtilitiesPackage
o )show RealClosure
o $AXIOM/doc/src/algebra/reclos.spad.dvi

@
<<domain RECLOS RealClosure>>=
)abbrev domain RECLOS RealClosure
++ Author: Renaud Rioboo
++ Date Created: summer 1988
++ Date Last Updated: January 2004
++ Basic Functions: provides computations in an ordered real closure
++ Related Constructors: RightOpenIntervalRootCharacterization
++ Also See:
++ AMS Classifications:
++ Keywords: Real Algebraic Numbers
++ References: 
++ Description:
++ This domain implements the real closure of an ordered field.
++ Note: 
++ The code here is generic i.e. it does not depend of the way the operations
++ are done. The two macros PME and SEG should be passed as functorial
++ arguments to the domain. It does not help much to write a category
++ since non trivial methods cannot be placed there either.
++ 
RealClosure(TheField): PUB == PRIV where

   TheField   : Join(OrderedRing, Field, RealConstant)

--   ThePols    : UnivariatePolynomialCategory($)
--   PME       ==> ThePols
--   TheCharDom : RealRootCharacterizationCategory($, ThePols )
--   SEG       ==> TheCharDom
-- this does not work yet

   E         ==> OutputForm
   Z         ==> Integer
   SE        ==> Symbol
   B         ==> Boolean
   SUP       ==> SparseUnivariatePolynomial($)
   N         ==> PositiveInteger
   RN        ==> Fraction Z
   LF        ==> ListFunctions2($,N)

-- *****************************************************************
-- *****************************************************************
--             PUT YOUR OWN PREFERENCE HERE
-- *****************************************************************
-- *****************************************************************
   PME       ==> SparseUnivariatePolynomial($)
   SEG       ==> RightOpenIntervalRootCharacterization($,PME)
-- *****************************************************************
-- *****************************************************************


   PUB == Join(RealClosedField,
               FullyRetractableTo TheField,
               Algebra TheField) with

       algebraicOf :   (SEG,E) -> $
             ++ \axiom{algebraicOf(char)} is the external number

       mainCharacterization :   $ -> Union(SEG,"failed")
             ++ \axiom{mainCharacterization(x)} is the main algebraic 
             ++ quantity of \axiom{x} (\axiom{SEG})

       relativeApprox :     ($,$) -> RN
             ++ \axiom{relativeApprox(n,p)} gives a relative 
             ++ approximation of \axiom{n} 
             ++ that has precision \axiom{p}

   PRIV == add

-- local functions

       lessAlgebraic  : $ -> $
       newElementIfneeded : (SEG,E) -> $

-- Representation

       Rec := Record(seg: SEG, val:PME, outForm:E, order:N)
       Rep := Union(TheField,Rec)

-- global (mutable) variables

       orderOfCreation : N := 1$N
          -- it is internally used to sort the algebraic levels

       instanceName : Symbol := new()$Symbol
          -- this used to print the results, thus different instanciations
          -- use different names

-- now the code

       relativeApprox(nbe,prec) ==
          nbe case TheField => retract(nbe)
          appr := relativeApprox(nbe.val, nbe.seg, prec)
          -- now appr has the good exact precision but is $
          relativeApprox(appr,prec)


       approximate(nbe,prec) ==
          abs(nbe) < prec => 0
          nbe case TheField => retract(nbe)
          appr := approximate(nbe.val, nbe.seg, prec)
          -- now appr has the good exact precision but is $
          approximate(appr,prec)

       newElementIfneeded(s,o) ==
         p := definingPolynomial(s)
         degree(p) = 1 => 
             - coefficient(p,0) / leadingCoefficient(p)
         res := [s, monomial(1,1), o, orderOfCreation ]$Rec
         orderOfCreation := orderOfCreation + 1
         res :: $

       algebraicOf(s,o) ==
         pol := definingPolynomial(s)
         degree(pol) = 1 => 
           -coefficient(pol,0) / leadingCoefficient(pol) 
         res := [s, monomial(1,1), o, orderOfCreation ]$Rec
         orderOfCreation := orderOfCreation + 1
         res :: $
         
       rename!(x,o) ==
         x.outForm := o
         x

       rename(x,o) ==
         [x.seg, x.val, o, x.order]$Rec

       rootOf(pol,n) ==
        degree(pol) = 0 => "failed"
        degree(pol) = 1 =>
          if n=1
          then
            -coefficient(pol,0) / leadingCoefficient(pol)
          else
            "failed"
        r := rootOf(pol,n)$SEG
        r case "failed" => "failed"
        o := hconcat(instanceName :: E , orderOfCreation :: E)$E
        algebraicOf(r,o)

       allRootsOf(pol:SUP):List($) == 
        degree(pol)=0 => []
        degree(pol)=1 => [-coefficient(pol,0) / leadingCoefficient(pol)]
        liste := allRootsOf(pol)$SEG
        res : List $ := []
        for term in liste repeat
           o := hconcat(instanceName :: E , orderOfCreation :: E)$E
           res := cons(algebraicOf(term,o), res)
        reverse! res

       coerce(x:$):$ ==
          x case TheField => x
          [x.seg,x.val rem$PME definingPolynomial(x.seg),x.outForm,x.order]$Rec

       positive?(x) == 
          x case TheField => positive?(x)$TheField
          positive?(x.val,x.seg)$SEG

       negative?(x) == 
          x case TheField => negative?(x)$TheField
          negative?(x.val,x.seg)$SEG

       abs(x) == sign(x)*x

       sign(x) ==
          x case TheField => sign(x)$TheField
          sign(x.val,x.seg)$SEG

       x < y == positive?(y-x)

       x = y == zero?(x-y)

       mainCharacterization(x) ==
          x case TheField => "failed"
          x.seg

       mainDefiningPolynomial(x) ==
          x case TheField => "failed"
          definingPolynomial x.seg

       mainForm(x) ==
          x case TheField => "failed"
          x.outForm

       mainValue(x) ==
          x case TheField => "failed"
          x.val

       coerce(x:$):E ==
          x case TheField => x::TheField :: E
          xx:$ := coerce(x)
          outputForm(univariate(xx.val),x.outForm)$SUP


       inv(x) ==
          (res:= recip x) case "failed" => error "Division by 0"
          res :: $

       recip(x) ==
         x case TheField =>
           if ((r := recip(x)$TheField) case TheField)
           then r::$
           else "failed"
         if ((r := recip(x.val,x.seg)$SEG) case "failed")
         then "failed"
         else lessAlgebraic([x.seg,r::PME,x.outForm,x.order]$Rec) 

       (n:Z * x:$):$ == 
          x case TheField => n *$TheField x
          zero?(n) => 0
          one?(n) => x
          [x.seg,map(n * #1, x.val),x.outForm,x.order]$Rec

       (rn:TheField * x:$):$ == 
          x case TheField => rn *$TheField x
          zero?(rn) => 0
          one?(rn) => x
          [x.seg,map(rn * #1, x.val),x.outForm,x.order]$Rec

       (x:$ * y:$):$ ==
          (x case TheField) and (y case TheField) => x *$TheField y
          (x case TheField) => x::TheField * y
              -- x is no longer TheField
          (y case TheField) => y::TheField * x
              -- now both are algebraic
          y.order > x.order => 
            [y.seg,map(x * #1 , y.val),y.outForm,y.order]$Rec
          x.order > y.order => 
            [x.seg,map( #1 * y , x.val),x.outForm,x.order]$Rec
              -- now x.exp = y.exp
              -- we will multiply the polynomials and then reduce
              -- however wee need to call lessAlgebraic  
          lessAlgebraic([x.seg,
                         (x.val * y.val) rem definingPolynomial(x.seg),
                         x.outForm,
                         x.order]$Rec)

       nonNull(rep:Rec):$ ==
         degree(rep.val)=0 => leadingCoefficient(rep.val)
         numberOfMonomials(rep.val) = 1 => rep
         zero?(rep.val,rep.seg)$SEG => 0
         rep

--       zero?(x) ==
--          x case TheField => zero?(x)$TheField
--          zero?(x.val,x.seg)$SEG
 
       zero?(x) ==
          x case TheField => zero?(x)$TheField
          false
 
       x + y ==
          (x case TheField) and (y case TheField) => x +$TheField y
          (x case TheField) => 
             if zero?(x)
             then 
               y
             else 
               nonNull([y.seg,x::PME+(y.val),y.outForm,y.order]$Rec)
             -- x is no longer TheField
          (y case TheField) => 
             if zero?(y)
             then 
               x
             else 
               nonNull([x.seg,(x.val)+y::PME,x.outForm,x.order]$Rec)
             -- now both are algebraic
          y.order > x.order => 
               nonNull([y.seg,x::PME+y.val,y.outForm,y.order]$Rec)
          x.order > y.order => 
               nonNull([x.seg,(x.val)+y::PME,x.outForm,x.order]$Rec)
              -- now x.exp = y.exp 
              -- we simply add polynomials (since degree cannot increase)
              -- however wee need to call lessAlgebraic  
          nonNull([x.seg,x.val + y.val,x.outForm,x.order])


       -x ==
          x case TheField => -$TheField (x::TheField)
          [x.seg,-$PME x.val,x.outForm,x.order]$Rec


       retractIfCan(x:$):Union(TheField,"failed") ==
          x case TheField => x
          o := x.order
          res := lessAlgebraic x
          res case TheField => res
          o = res.order => "failed"
          retractIfCan res

       retract(x:$):TheField ==
          x case TheField => x
          o := x.order
          res := lessAlgebraic x
          res case TheField => res
          o = res.order => error "Can't retract"
          retract res


       lessAlgebraic(x) ==
          x case TheField => x
          degree(x.val) = 0 => leadingCoefficient(x.val)
          def := definingPolynomial(x.seg)
          degree(def) = 1 => 
            x.val.(- coefficient(def,0) / leadingCoefficient(def))
          x

       0 == (0$TheField) :: $

       1 == (1$TheField) :: $

       coerce(rn:TheField):$ == rn :: $

@
\section{License}
<<license>>=
-----------------------------------------------------------------------------
-- This software was written by Renaud Rioboo (Computer Algebra group of
-- Laboratoire d'Informatique de Paris 6) and is the property of university
-- Paris 6.
-----------------------------------------------------------------------------
@
<<*>>=
<<license>>
<<package POLUTIL RealPolynomialUtilitiesPackage>>
<<category RRCC RealRootCharacterizationCategory>>
<<category RCFIELD RealClosedField>>
<<domain ROIRC RightOpenIntervalRootCharacterization>>
<<domain RECLOS RealClosure>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} R. Rioboo,
{\sl Real Algebraic Closure of an ordered Field : Implementation in Axiom.},
In proceedings of the ISSAC'92 Conference, Berkeley 1992 pp. 206-215.
\bibitem{2} Z. Ligatsikas, R. Rioboo, M. F. Roy 
{\sl Generic computation of the real closure of an ordered field.},
In Mathematics and Computers in Simulation Volume 42, Issue 4-6,
November 1996.
\end{thebibliography}
\end{document}
