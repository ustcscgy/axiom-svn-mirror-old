\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra fr.spad}
\author{Robert S. Sutor, Johnannes Grabmeier}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package FRUTIL FactoredFunctionUtilities}
<<package FRUTIL FactoredFunctionUtilities>>=
)abbrev package FRUTIL FactoredFunctionUtilities
++ Author:
++ Date Created:
++ Change History:
++ Basic Operations: refine, mergeFactors
++ Related Constructors: Factored
++ Also See:
++ AMS Classifications: 11A51, 11Y05
++ Keywords: factor
++ References:
++ Description:
++   \spadtype{FactoredFunctionUtilities} implements some utility
++   functions for manipulating factored objects.
FactoredFunctionUtilities(R): Exports == Implementation where
  R: IntegralDomain
  FR ==> Factored R

  Exports ==> with
    refine: (FR, R-> FR) -> FR
      ++ refine(u,fn) is used to apply the function \userfun{fn} to
      ++ each factor of \spadvar{u} and then build a new factored
      ++ object from the results.  For example, if \spadvar{u} were
      ++ created by calling \spad{nilFactor(10,2)} then
      ++ \spad{refine(u,factor)} would create a factored object equal
      ++ to that created by \spad{factor(100)} or
      ++ \spad{primeFactor(2,2) * primeFactor(5,2)}.

    mergeFactors: (FR,FR) -> FR
      ++ mergeFactors(u,v) is used when the factorizations of \spadvar{u}
      ++ and \spadvar{v} are known to be disjoint, e.g. resulting from a
      ++ content/primitive part split. Essentially, it creates a new
      ++ factored object by multiplying the units together and appending
      ++ the lists of factors.

  Implementation ==> add
    fg: FR
    func: R -> FR
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FF     ==> Record(flg: fUnion, fctr: R, xpnt: Integer)

    mergeFactors(f,g) ==
      makeFR(unit(f)*unit(g),append(factorList f,factorList g))

    refine(f, func) ==
       u := unit(f)
       l: List FF := empty()
       for item in factorList f repeat
         fitem := func item.fctr
         u := u*unit(fitem) ** (item.xpnt :: NonNegativeInteger)
         if item.xpnt = 1 then
            l := concat(factorList fitem,l)
         else l := concat([[v.flg,v.fctr,v.xpnt*item.xpnt]
                          for v in factorList fitem],l)
       makeFR(u,l)

@
\section{package FR2 FactoredFunctions2}
<<FactoredFunctions2.input>>=
-- fr.spad.pamphlet FactoredFunctions2.input
)spool FactoredFunctions2.output
)set message test on
)set message auto off
)clear all
--S 1 of 6
double(x) == x + x
--R 
--R                                                                   Type: Void
--E 1

--S 2 of 6
f := factor(720) 
--R 
--R
--R         4 2
--R   (2)  2 3 5
--R                                                       Type: Factored Integer
--E 2

--S 3 of 6
map(double,f) 
--R 
--R   Compiling function double with type Integer -> Integer 
--R
--R           4 2
--R   (3)  2 4 6 10
--R                                                       Type: Factored Integer
--E 3

--S 4 of 6
makePoly(b) == x + b 
--R 
--R                                                                   Type: Void
--E 4

--S 5 of 6
g := map(makePoly,f) 
--R 
--R   Compiling function makePoly with type Integer -> Polynomial Integer 
--R
--R                      4       2
--R   (5)  (x + 1)(x + 2) (x + 3) (x + 5)
--R                                            Type: Factored Polynomial Integer
--E 5

--S 6 of 6
nthFlag(g,1) 
--R 
--R
--R   (6)  "nil"
--R                                                       Type: Union("nil",...)
--E 6
)spool
)lisp (bye)
@

<<FactoredFunctions2.help>>=
====================================================================
FactoredFunctions2 examples
====================================================================

The FactoredFunctions2 package implements one operation, map, for
applying an operation to every base in a factored object and to the unit.

  double(x) == x + x
                         Type: Void

  f := factor(720) 
     4 2
    2 3 5
                         Type: Factored Integer

Actually, the map operation used in this example comes from Factored
itself, since double takes an integer argument and returns an integer
result.

  map(double,f) 
       4 2
    2 4 6 10
                         Type: Factored Integer

If we want to use an operation that returns an object that has a type
different from the operation's argument, the map in Factored cannot be
used and we use the one in FactoredFunctions2.

  makePoly(b) == x + b 
                  4       2
    (x + 1)(x + 2) (x + 3) (x + 5)
                         Type: Factored Polynomial Integer

In fact, the "2" in the name of the package means that we might
be using factored objects of two different types.

  g := map(makePoly,f) 

It is important to note that both versions of map destroy any information 
known about the bases (the fact that they are prime, for instance).

The flags for each base are set to "nil" in the object returned by map.

  nthFlag(g,1) 
    "nil"
                        Type: Union("nil",...)

See Also:
o )help Factored
o )show FactoredFunctions2
o $AXIOM/doc/src/algebra/fr.spad.dvi

@
<<package FR2 FactoredFunctions2>>=
)abbrev package FR2 FactoredFunctions2
++ Author: Robert S. Sutor
++ Date Created: 1987
++ Change History:
++ Basic Operations: map
++ Related Constructors: Factored
++ Also See:
++ AMS Classifications: 11A51, 11Y05
++ Keywords: map, factor
++ References:
++ Description:
++   \spadtype{FactoredFunctions2} contains functions that involve
++   factored objects whose underlying domains may not be the same.
++   For example, \spadfun{map} might be used to coerce an object of
++   type \spadtype{Factored(Integer)} to
++   \spadtype{Factored(Complex(Integer))}.
FactoredFunctions2(R, S): Exports == Implementation where
  R: IntegralDomain
  S: IntegralDomain

  Exports ==> with
    map: (R -> S, Factored R) -> Factored S
      ++ map(fn,u) is used to apply the function \userfun{fn} to every
      ++ factor of \spadvar{u}. The new factored object will have all its
      ++ information flags set to "nil". This function is used, for
      ++ example, to coerce every factor base to another type.

  Implementation ==> add
    map(func, f) ==
      func(unit f) *
             _*/[nilFactor(func(g.factor), g.exponent) for g in factors f]

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package FRUTIL FactoredFunctionUtilities>>
<<package FR2 FactoredFunctions2>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
