\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra tree.spad}
\author{William Burge}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain TREE Tree}
<<domain TREE Tree>>=
)abbrev domain TREE Tree
++ Author:W. H. Burge
++ Date Created:17 Feb 1992
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: \spadtype{Tree(S)} is a basic domains of tree structures.
++ Each tree is either empty or else is a {\it node} consisting of a value and
++ a list of (sub)trees.
Tree(S: SetCategory): T==C where
 T== RecursiveAggregate(S) with
     finiteAggregate
     shallowlyMutable
     tree: (S,List %) -> %
       ++ tree(nd,ls) creates a tree with value nd, and children ls.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X tree(5,[t1])

     tree: List S -> %
       ++ tree(ls) creates a tree from a list of elements of s. 
       ++
       ++X tree [1,2,3,4]

     tree: S -> %
       ++ tree(nd) creates a tree with value nd, and no children
       ++
       ++X tree 6

     cyclic?: % -> Boolean
       ++ cyclic?(t) tests if t is a cyclic tree.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclic? t1

     cyclicCopy: % -> %
       ++ cyclicCopy(l) makes a copy of a (possibly) cyclic tree l.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicCopy t1

     cyclicEntries:    % -> List %
       ++ cyclicEntries(t) returns a list of top-level cycles in tree t.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicEntries t1

     cyclicEqual?: (%, %) -> Boolean
       ++ cyclicEqual?(t1, t2) tests of two cyclic trees have 
       ++ the same structure.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X t2:=tree [1,2,3,4]
       ++X cyclicEqual?(t1,t2)

     cyclicParents: % -> List %
       ++ cyclicParents(t) returns a list of cycles that are parents of t.
       ++
       ++X t1:=tree [1,2,3,4]
       ++X cyclicParents t1

 C== add
    cycleTreeMax ==> 5

    Rep := Union(node:Record(value: S, args: List %),empty:"empty")
    t:%
    br:%
    s: S
    ls: List S
    empty? t == t case empty
    empty()  == ["empty"]
    children t == 
      t case empty => error "cannot take the children of an empty tree" 
      (t.node.args)@List(%)
    setchildren_!(t,lt) == 
      t case empty => error "cannot set children of an empty tree"
      (t.node.args:=lt;t pretend %)
    setvalue_!(t,s) == 
      t case empty => error "cannot set value of an empty tree"
      (t.node.value:=s;s)
    count(n, t) == 
      t case empty => 0
      i := +/[count(n, c) for c in children t]
      value t = n => i + 1
      i
    count(fn: S -> Boolean, t: %): NonNegativeInteger ==
      t case empty => 0
      i := +/[count(fn, c) for c in children t]
      fn value t => i + 1
      i
    map(fn, t) == 
      t case empty => t
      tree(fn value t,[map(fn, c) for c in children t])
    map_!(fn, t) == 
      t case empty => t
      setvalue_!(t, fn value t)
      for c in children t repeat map_!(fn, c)
    tree(s,lt) == [[s,lt]]
    tree(s) == [[s,[]]]
    tree(ls) ==
      empty? ls => empty()
      tree(first ls, [tree s for s in rest ls])
    value t ==
      t case empty => error "cannot take the value of an empty tree" 
      t.node.value
    child?(t1,t2) == 
      empty? t2 => false
      "or"/[t1 = t for t in children t2]
    distance1(t1: %, t2: %): Integer ==
      t1 = t2 => 0
      t2 case empty => -1
      u := [n for t in children t2 | (n := distance1(t1,t)) >= 0]
      #u > 0 => 1 + "min"/u 
      -1 
    distance(t1,t2) == 
      n := distance1(t1, t2)
      n >= 0 => n
      distance1(t2, t1)
    node?(t1, t2) ==
      t1 = t2 => true
      t case empty => false
      "or"/[node?(t1, t) for t in children t2]
    leaf? t == 
      t case empty => false
      empty? children t
    leaves t == 
      t case empty => empty()
      leaf? t => [value t]
      "append"/[leaves c for c in children t]
    less? (t, n) == # t < n
    more?(t, n) == # t > n
    nodes t ==       ---buggy
      t case empty => empty()
      nl := [nodes c for c in children t]
      nl = empty() => [t]
      cons(t,"append"/nl)
    size? (t, n) == # t = n
    any?(fn, t) ==  ---bug fixed
      t case empty => false
      fn value t or "or"/[any?(fn, c) for c in children t]
    every?(fn, t) == 
      t case empty => true
      fn value t and "and"/[every?(fn, c) for c in children t]
    member?(n, t) == 
      t case empty => false
      n = value t or "or"/[member?(n, c) for c in children t]
    members t == parts t
    parts t == --buggy?
      t case empty => empty()
      u := [parts c for c in children t]
      u = empty() => [value t]
      cons(value t,"append"/u)
 
    ---Functions that guard against cycles: =, #, copy-------------

    -----> =   
    equal?: (%, %, %, %, Integer) -> Boolean

    t1 = t2 == equal?(t1, t2, t1, t2, 0) 

    equal?(t1, t2, ot1, ot2, k) ==
      k = cycleTreeMax and (cyclic? ot1 or cyclic? ot2) => 
        error "use cyclicEqual? to test equality on cyclic trees"
      t1 case empty => t2 case empty
      t2 case empty => false
      value t1 = value t2 and (c1 := children t1) = (c2 := children t2) and
        "and"/[equal?(x,y,ot1, ot2,k + 1) for x in c1 for y in c2]

    -----> #
    treeCount: (%, %, NonNegativeInteger) -> NonNegativeInteger    
    # t == treeCount(t, t, 0)
    treeCount(t, origTree, k) ==
      k = cycleTreeMax and cyclic? origTree => 
        error "# is not defined on cyclic trees"
      t case empty => 0
      1 + +/[treeCount(c, origTree, k + 1) for c in children t]
 
    -----> copy
    copy1: (%, %, Integer) -> %
    copy t == copy1(t, t, 0)
    copy1(t, origTree, k) == 
      k = cycleTreeMax and cyclic? origTree => 
        error "use cyclicCopy to copy a cyclic tree"
      t case empty  => t
      empty? children t => tree value t
      tree(value t, [copy1(x, origTree, k + 1) for x in children t])
      
    -----------Functions that allow cycles---------------
    --local utility functions:
    eqUnion: (List %, List %) -> List %
    eqMember?: (%, List %) -> Boolean
    eqMemberIndex: (%, List %, Integer) -> Integer
    lastNode: List % -> List %
    insert: (%, List %) -> List %

    -----> coerce to OutputForm
    if S has SetCategory then
      multipleOverbar: (OutputForm, Integer, List %) -> OutputForm
      coerce1: (%, List %, List %) -> OutputForm

      coerce(t:%): OutputForm == coerce1(t, empty()$(List %), cyclicParents t)

      coerce1(t,parents, pl) ==
        t case empty => empty()@List(S)::OutputForm
        eqMember?(t, parents) => 
          multipleOverbar((".")::OutputForm,eqMemberIndex(t, pl,0),pl)
        empty? children t => value t::OutputForm
        nodeForm := (value t)::OutputForm
        if (k := eqMemberIndex(t, pl, 0)) > 0 then
           nodeForm := multipleOverbar(nodeForm, k, pl)
        prefix(nodeForm, 
          [coerce1(br,cons(t,parents),pl) for br in children t])

      multipleOverbar(x, k, pl) ==
        k < 1 => x
        #pl = 1 => overbar x
        s : String := "abcdefghijklmnopqrstuvwxyz"
        c := s.(1 + ((k - 1) rem 26))
        overlabel(c::OutputForm, x)
 
    -----> cyclic?
    cyclic2?: (%, List %) -> Boolean

    cyclic? t == cyclic2?(t, empty()$(List %))

    cyclic2?(x,parents) ==  
      empty? x => false
      eqMember?(x, parents) => true
      for y in children x repeat
        cyclic2?(y,cons(x, parents)) => return true
      false
 
    -----> cyclicCopy
    cyclicCopy2: (%, List %) -> %
    copyCycle2: (%, List %) -> %
    copyCycle4: (%, %, %, List %) -> %

    cyclicCopy(t) == cyclicCopy2(t, cyclicEntries t)

    cyclicCopy2(t, cycles) ==
      eqMember?(t, cycles) => return copyCycle2(t, cycles)
      tree(value t, [cyclicCopy2(c, cycles) for c in children t])
   
    copyCycle2(cycle, cycleList) == 
      newCycle := tree(value cycle, nil)
      setchildren!(newCycle,
        [copyCycle4(c,cycle,newCycle, cycleList) for c in children cycle])
      newCycle

    copyCycle4(t, cycle, newCycle, cycleList) == 
      empty? cycle => empty()
      eq?(t, cycle) => newCycle
      eqMember?(t, cycleList) => copyCycle2(t, cycleList)
      tree(value t,
           [copyCycle4(c, cycle, newCycle, cycleList) for c in children t])

    -----> cyclicEntries
    cyclicEntries3: (%, List %, List %) -> List %

    cyclicEntries(t) == cyclicEntries3(t, empty()$(List %), empty()$(List %))

    cyclicEntries3(t, parents, cl) ==
      empty? t => cl
      eqMember?(t, parents) => insert(t, cl)
      parents := cons(t, parents)
      for y in children t repeat
        cl := cyclicEntries3(t, parents, cl)
      cl
   
    -----> cyclicEqual?
    cyclicEqual4?: (%, %, List %, List %) -> Boolean

    cyclicEqual?(t1, t2) ==
      cp1 := cyclicParents t1
      cp2 := cyclicParents t2
      #cp1 ^= #cp2 or null cp1 => t1 = t2
      cyclicEqual4?(t1, t2, cp1, cp2)

    cyclicEqual4?(t1, t2, cp1, cp2) == 
      t1 case empty => t2 case empty
      t2 case empty => false
      0 ^= (k := eqMemberIndex(t1, cp1, 0)) => eq?(t2, cp2 . k)
      value t1 = value t2 and 
        "and"/[cyclicEqual4?(x,y,cp1,cp2) 
                 for x in children t1 for y in children t2]

    -----> cyclicParents t
    cyclicParents3: (%, List %, List %) -> List %

    cyclicParents t == cyclicParents3(t, empty()$(List %), empty()$(List %))

    cyclicParents3(x, parents, pl) ==
      empty? x => pl
      eqMember?(x, parents) => 
        cycleMembers := [y for y in parents while not eq?(x,y)]
        eqUnion(cons(x, cycleMembers), pl)
      parents := cons(x, parents)
      for y in children x repeat 
        pl := cyclicParents3(y, parents, pl)
      pl

    insert(x, l) ==
      eqMember?(x, l) => l
      cons(x, l)

    lastNode l ==
      empty? l => error "empty tree has no last node"
      while not empty? rest l repeat l := rest l
      l

    eqMember?(y,l) ==
      for x in l repeat eq?(x,y) => return true
      false

    eqMemberIndex(x, l, k) ==
      null l => k
      k := k + 1
      eq?(x, first l) => k
      eqMemberIndex(x, rest l, k)

    eqUnion(u, v) ==
      null u => v
      x := first u
      newV :=
        eqMember?(x, v) => v
        cons(x, v)
      eqUnion(rest u, newV)

@
\section{domain BTREE BinaryTree}
<<domain BTREE BinaryTree>>=
)abbrev domain BTREE BinaryTree
++ Description: \spadtype{BinaryTree(S)} is the domain of all
++ binary trees. A binary tree over \spad{S} is either empty or has
++ a \spadfun{value} which is an S and a \spadfun{right}
++ and \spadfun{left} which are both binary trees.
BinaryTree(S: SetCategory): Exports == Implementation where
  Exports == BinaryTreeCategory(S) with
   binaryTree: S -> %
    ++ binaryTree(v) is an non-empty binary tree
    ++ with value v, and left and right empty.
    ++
    ++X t1:=binaryTree([1,2,3])
    
   binaryTree: (%,S,%) -> %    
    ++ binaryTree(l,v,r) creates a binary tree with
    ++ value v with left subtree l and right subtree r.
    ++
    ++X t1:=binaryTree([1,2,3])
    ++X t2:=binaryTree([4,5,6])
    ++X binaryTree(t1,[7,8,9],t2)
    
  Implementation == add
     Rep := List Tree S
     t1 = t2 == (t1::Rep) =$Rep (t2::Rep)
     empty()== [] pretend %
     empty()== [] pretend %
     node(l,v,r) == cons(tree(v,l:Rep),r:Rep)
     binaryTree(l,v,r) == node(l,v,r)
     binaryTree(v:S) == node(empty(),v,empty())
     empty? t == empty?(t)$Rep
     leaf? t  == empty? t or empty? left t and empty? right t
     right t ==
       empty? t => error "binaryTree:no right"
       rest t
     left t ==
       empty? t => error "binaryTree:no left"
       children first t
     value t==
       empty? t => error "binaryTree:no value"
       value first t
     setvalue_! (t,nd)==
       empty? t => error "binaryTree:no value to set"
       setvalue_!(first(t:Rep),nd)
       nd
     setleft_!(t1,t2) ==
       empty? t1 => error "binaryTree:no left to set"
       setchildren_!(first(t1:Rep),t2:Rep)
       t1
     setright_!(t1,t2) ==
       empty? t1 => error "binaryTree:no right to set"
       setrest_!(t1:List Tree S,t2)

@
\section{domain BSTREE BinarySearchTree}
<<BinarySearchTree.input>>=
-- tree.spad.pamphlet BinarySearchTree.input
)spool BinarySearchTree.output
)set message test on
)set message auto off
)clear all
--S 1 of 12
lv := [8,3,5,4,6,2,1,5,7]
--R 
--R
--R   (1)  [8,3,5,4,6,2,1,5,7]
--R                                                   Type: List PositiveInteger
--E 1

--S 2 of 12
t := binarySearchTree lv
--R 
--R
--R   (2)  [[[1,2,.],3,[4,5,[5,6,7]]],8,.]
--R                                       Type: BinarySearchTree PositiveInteger
--E 2

--S 3 of 12
emptybst := empty()$BSTREE(INT)
--R 
--R
--R   (3)  []
--R                                               Type: BinarySearchTree Integer
--E 3

--S 4 of 12
t1 := insert!(8,emptybst)
--R 
--R
--R   (4)  8
--R                                               Type: BinarySearchTree Integer
--E 4

--S 5 of 12
insert!(3,t1)
--R 
--R
--R   (5)  [3,8,.]
--R                                               Type: BinarySearchTree Integer
--E 5

--S 6 of 12
leaves t
--R 
--R
--R   (6)  [1,4,5,7]
--R                                                   Type: List PositiveInteger
--E 6

--S 7 of 12
split(3,t)
--R 
--R
--R   (7)  [less= [1,2,.],greater= [[.,3,[4,5,[5,6,7]]],8,.]]
--RType: Record(less: BinarySearchTree PositiveInteger,greater: BinarySearchTree PositiveInteger)
--E 7

--S 8 of 12
insertRoot: (INT,BSTREE INT) -> BSTREE INT
--R 
--R                                                                   Type: Void
--E 8

--S 9 of 12
insertRoot(x, t) ==
    a := split(x, t)
    node(a.less, x, a.greater)
--R 
--R                                                                   Type: Void
--E 9

--S 10 of 12
buildFromRoot ls == reduce(insertRoot,ls,emptybst)
--R 
--R                                                                   Type: Void
--E 10

--S 11 of 12
rt := buildFromRoot reverse lv
--R 
--R   Compiling function buildFromRoot with type List PositiveInteger -> 
--R      BinarySearchTree Integer 
--R   Compiling function insertRoot with type (Integer,BinarySearchTree 
--R      Integer) -> BinarySearchTree Integer 
--R
--R   (11)  [[[1,2,.],3,[4,5,[5,6,7]]],8,.]
--R                                               Type: BinarySearchTree Integer
--E 11

--S 12 of 12
(t = rt)@Boolean
--R 
--R
--R   (12)  true
--R                                                                Type: Boolean
--E 12
)spool
)lisp (bye)
@
<<BinarySearchTree.help>>=
====================================================================
BinarySearchTree examples
====================================================================

BinarySearchTree(R) is the domain of binary trees with elements of
type R, ordered across the nodes of the tree.  A non-empty binary
search tree has a value of type R, and right and left binary search
subtrees.  If a subtree is empty, it is displayed as a period (".").

Define a list of values to be placed across the tree.  The resulting
tree has 8 at the root; all other elements are in the left subtree.

  lv := [8,3,5,4,6,2,1,5,7]
   [8, 3, 5, 4, 6, 2, 1, 5, 7]
                      Type: List PositiveInteger

A convenient way to create a binary search tree is to apply the
operation binarySearchTree to a list of elements.

  t := binarySearchTree lv
   [[[1, 2, .], 3, [4, 5, [5, 6, 7]]], 8, .]
                      Type: BinarySearchTree PositiveInteger

Another approach is to first create an empty binary search tree of integers.

  emptybst := empty()$BSTREE(INT)
   [] 
                      Type: BinarySearchTree Integer

Insert the value 8.  This establishes 8 as the root of the binary
search tree.  Values inserted later that are less than 8 get stored in
the left subtree, others in the right subtree.

  t1 := insert!(8,emptybst)
   8 
                      Type: BinarySearchTree Integer

Insert the value 3. This number becomes the root of the left subtree
of t1.  For optimal retrieval, it is thus important to insert the
middle elements first.

  insert!(3,t1)
   [3, 8, .]
                      Type: BinarySearchTree Integer

We go back to the original tree t.  The leaves of the binary search
tree are those which have empty left and right subtrees.

  leaves t
   [1, 4, 5, 7]
                      Type: List PositiveInteger

The operation split(k,t) returns a record containing the two subtrees:
one with all elements "less" than k, another with elements "greater"
than k.

  split(3,t)
   [less=[1, 2, .], greater=[[., 3, [4, 5, [5, 6, 7]]], 8, .]]
              Type: Record(less: BinarySearchTree PositiveInteger,greater: 
                           BinarySearchTree PositiveInteger)

Define insertRoot to insert new elements by creating a new node.

  insertRoot: (INT,BSTREE INT) -> BSTREE INT
                      Type: Void

The new node puts the inserted value between its "less" tree and
"greater" tree.


  insertRoot(x, t) ==
    a := split(x, t)
    node(a.less, x, a.greater)
                      Type: Void


Function buildFromRoot builds a binary search tree from a list
of elements ls and the empty tree emptybst.

  buildFromRoot ls == reduce(insertRoot,ls,emptybst)
                      Type: Void

Apply this to the reverse of the list lv.

  rt := buildFromRoot reverse lv
   [[[1, 2, . ], 3, [4, 5, [5, 6, 7]]], 8, .]
                      Type: BinarySearchTree Integer

Have Axiom check that these are equal.

  (t = rt)@Boolean
   true
                      Type: Boolean

See Also:
o )show BinarySearchTree
o $AXIOM/doc/src/algebra/tree.spad.dvi

@
<<domain BSTREE BinarySearchTree>>=
)abbrev domain BSTREE BinarySearchTree
++ Description: BinarySearchTree(S) is the domain of
++ a binary trees where elements are ordered across the tree.
++ A binary search tree is either empty or has
++ a value which is an S, and a
++ right and left which are both BinaryTree(S)
++ Elements are ordered across the tree.
BinarySearchTree(S: OrderedSet): Exports == Implementation where
  Exports == BinaryTreeCategory(S) with
    shallowlyMutable
    finiteAggregate
    binarySearchTree: List S -> %
     ++ binarySearchTree(l) \undocumented
     ++
     ++X binarySearchTree [1,2,3,4]

    insert_!: (S,%) -> %
     ++ insert!(x,b) inserts element x as leaves into binary search tree b.
     ++
     ++X t1:=binarySearchTree [1,2,3,4]
     ++X insert!(5,t1)

    insertRoot_!: (S,%) -> %
     ++ insertRoot!(x,b) inserts element x as a root of binary search tree b.
     ++
     ++X t1:=binarySearchTree [1,2,3,4]
     ++X insertRoot!(5,t1)

    split:      (S,%) -> Record(less: %, greater: %)
     ++ split(x,b) splits binary tree b into two trees, one with elements 
     ++ greater than x, the other with elements less than x.
     ++
     ++X t1:=binarySearchTree [1,2,3,4]
     ++X split(3,t1)

  Implementation == BinaryTree(S) add
    Rep := BinaryTree(S)
    binarySearchTree(u:List S) ==
      null u => empty()
      tree := binaryTree(first u)
      for x in rest u repeat insert_!(x,tree)
      tree
    insert_!(x,t) ==
      empty? t => binaryTree(x)
      x >= value t =>
        setright_!(t,insert_!(x,right t))
        t
      setleft_!(t,insert_!(x,left t))
      t
    split(x,t) ==
      empty? t => [empty(),empty()]
      x > value t =>
        a := split(x,right t)
        [node(left t, value t, a.less), a.greater]
      a := split(x,left t)
      [a.less, node(a.greater, value t, right t)]
    insertRoot_!(x,t) ==
      a := split(x,t)
      node(a.less, x, a.greater)

@
\section{domain BTOURN BinaryTournament}
A BinaryTournament(S) is the domain of binary trees where elements are
ordered down the tree.  A binary search tree is either empty or is a
node containing a value of type S, and a right and a left which are
both BinaryTree(S)
<<domain BTOURN BinaryTournament>>=
)abbrev domain BTOURN BinaryTournament
BinaryTournament(S: OrderedSet): Exports == Implementation where
  Exports == BinaryTreeCategory(S) with
    shallowlyMutable
    binaryTournament: List S -> %
      ++ binaryTournament(ls) creates a binary tournament with the
      ++ elements of ls as values at the nodes.
      ++
      ++X binaryTournament [1,2,3,4]

    insert_!: (S,%) -> %
      ++ insert!(x,b) inserts element x as leaves into binary tournament b.
      ++
      ++X t1:=binaryTournament [1,2,3,4]
      ++X insert!(5,t1)
      ++X t1

  Implementation == BinaryTree(S) add
    Rep := BinaryTree(S)
    binaryTournament(u:List S) ==
      null u => empty()
      tree := binaryTree(first u)
      for x in rest u repeat insert_!(x,tree)
      tree
    insert_!(x,t) ==
      empty? t => binaryTree(x)
      x > value t =>
        setleft_!(t,copy t)
        setvalue_!(t,x)
        setright_!(t,empty())
      setright_!(t,insert_!(x,right t))
      t

@
\section{domain BBTREE BalancedBinaryTree}
<<BalancedBinaryTree.input>>=
-- tree.spad.pamphlet BalancedBinaryTree.input
)spool BalancedBinaryTree.output
)set message test on
)set message auto off
)clear all
--S 1
lm := [3,5,7,11]
--R 
--R
--R   (1)  [3,5,7,11]
--R                                                   Type: List PositiveInteger
--E 1

--S 2
modTree(12,lm)
--R 
--R
--R   (2)  [0,2,5,1]
--R                                                           Type: List Integer
--E 2

--S 3
t := balancedBinaryTree(#lm, 0)
--R 
--R
--R   (3)  [[0,0,0],0,[0,0,0]]
--R                                  Type: BalancedBinaryTree NonNegativeInteger
--E 3

--S 4
setleaves!(t,lm)
--R 
--R
--R   (4)  [[3,0,5],0,[7,0,11]]
--R                                  Type: BalancedBinaryTree NonNegativeInteger
--E 4

--S 5
mapUp!(t,_*)
--R 
--R
--R   (5)  1155
--R                                                        Type: PositiveInteger
--E 5

--S 6
t
--R 
--R
--R   (6)  [[3,15,5],1155,[7,77,11]]
--R                                  Type: BalancedBinaryTree NonNegativeInteger
--E 6

--S 7
mapDown!(t,12,_rem)
--R 
--R
--R   (7)  [[0,12,2],12,[5,12,1]]
--R                                  Type: BalancedBinaryTree NonNegativeInteger
--E 7

--S 8
leaves %
--R 
--R
--R   (8)  [0,2,5,1]
--R                                                Type: List NonNegativeInteger
--E 8

--S 9
squares := [x**2 rem m for x in % for m in lm]
--R 
--R
--R   (9)  [0,4,4,1]
--R                                                Type: List NonNegativeInteger
--E 9

--S 10
chineseRemainder(%,lm)
--R 
--R
--R   (10)  144
--R                                                        Type: PositiveInteger
--E 10
)spool
)lisp (bye)
@
<<BalancedBinaryTree.help>>=
====================================================================
BalancedBinaryTree examples
====================================================================

BalancedBinaryTrees(S) is the domain of balanced binary trees with
elements of type S at the nodes.  A binary tree is either empty or
else consists of a node having a value and two branches, each branch a
binary tree.  A balanced binary tree is one that is balanced with
respect its leaves.  One with 2^k leaves is perfectly "balanced": the
tree has minimum depth, and the left and right branch of every
interior node is identical in shape.

Balanced binary trees are useful in algebraic computation for
so-called "divide-and-conquer" algorithms.  Conceptually, the data
for a problem is initially placed at the root of the tree.  The
original data is then split into two subproblems, one for each
subtree.  And so on.  Eventually, the problem is solved at the leaves
of the tree.  A solution to the original problem is obtained by some
mechanism that can reassemble the pieces.  In fact, an implementation
of the Chinese Remainder Algorithm using balanced binary trees was
first proposed by David Y. Y.  Yun at the IBM T. J.  Watson Research
Center in Yorktown Heights, New York, in 1978.  It served as the
prototype for polymorphic algorithms in Axiom.

In what follows, rather than perform a series of computations with a
single expression, the expression is reduced modulo a number of
integer primes, a computation is done with modular arithmetic for each
prime, and the Chinese Remainder Algorithm is used to obtain the
answer to the original problem.  We illustrate this principle with the
computation of 12^2 = 144.

A list of moduli:

  lm := [3,5,7,11]
   [3,5,7,11]
                      Type: PositiveInteger

The expression modTree(n, lm) creates a balanced binary tree with leaf
values n mod m for each modulus m in lm.

  modTree(12,lm)
   [0, 2, 5, 1]
                      Type: List Integer

Operation modTree does this using operations on balanced binary trees.
We trace its steps.  Create a balanced binary tree t of zeros with
four leaves.

  t := balancedBinaryTree(#lm, 0)
   [[0, 0, 0], 0, [0, 0, 0]]
                      Type: BalancedBinaryTree NonNegativeInteger

The leaves of the tree are set to the individual moduli.

  setleaves!(t,lm)
   [[3, 0, 5], 0, [7, 0, 11]]
                      Type: BalancedBinaryTree NonNegativeInteger

mapUp! to do a bottom-up traversal of t, setting each interior node to
the product of the values at the nodes of its children.

  mapUp!(t,_*)
   1155 
                      Type: PositiveInteger

The value at the node of every subtree is the product of the moduli
of the leaves of the subtree.

  t
   [[3, 15, 5], 1155, [7, 77, 11]]
                      Type: BalancedBinaryTree NonNegativeInteger

Operation mapDown!(t,a,fn) replaces the value v at each node of t by
fn(a,v).

  mapDown!(t,12,_rem)
   [[0, 12, 2], 12, [5, 12, 1]]
                      Type: BalancedBinaryTree NonNegativeInteger

The operation leaves returns the leaves of the resulting tree.  In
this case, it returns the list of 12 mod m for each modulus m.

  leaves %
   [0, 2, 5, 1]
                      Type: List NonNegativeInteger

Compute the square of the images of 12 modulo each m.

  squares := [x**2 rem m for x in % for m in lm]
   [0, 4, 4, 1]
                      Type: List NonNegativeInteger

Call the Chinese Remainder Algorithm to get the answer for 12^2.

  chineseRemainder(%,lm)
   144 
                      Type: PositiveInteger

See Also:
o )show BalancedBinaryTree
o $AXIOM/doc/src/algebra/tree.spad.dvi

@
<<domain BBTREE BalancedBinaryTree>>=
)abbrev domain BBTREE BalancedBinaryTree
++ Description: \spadtype{BalancedBinaryTree(S)} is the domain of balanced
++ binary trees (bbtree). A balanced binary tree of \spad{2**k} leaves,
++ for some \spad{k > 0}, is symmetric, that is, the left and right
++ subtree of each interior node have identical shape.
++ In general, the left and right subtree of a given node can differ
++ by at most leaf node.
BalancedBinaryTree(S: SetCategory): Exports == Implementation where
  Exports == BinaryTreeCategory(S) with
    finiteAggregate
    shallowlyMutable
--  BUG: applies wrong fnct for balancedBinaryTree(0,[1,2,3,4])
--    balancedBinaryTree: (S, List S) -> %
--      ++ balancedBinaryTree(s, ls) creates a balanced binary tree with
--      ++ s at the interior nodes and elements of ls at the
--      ++ leaves.
    balancedBinaryTree: (NonNegativeInteger, S) -> %
      ++ balancedBinaryTree(n, s) creates a balanced binary tree with
      ++ n nodes each with value s.
      ++
      ++X balancedBinaryTree(4, 0)

    setleaves_!: (%, List S) -> %
      ++ setleaves!(t, ls) sets the leaves of t in left-to-right order
      ++ to the elements of ls.
      ++
      ++X t1:=balancedBinaryTree(4, 0)
      ++X setleaves!(t1,[1,2,3,4])

    mapUp_!: (%, (S,S) -> S) -> S
      ++ mapUp!(t,f) traverses balanced binary tree t in an "endorder"
      ++ (left then right then node) fashion returning t with the value
      ++ at each successive interior node of t replaced by
      ++ f(l,r) where l and r are the values at the immediate
      ++ left and right nodes.
      ++
      ++X T1:=BalancedBinaryTree Integer
      ++X t2:=balancedBinaryTree(4, 0)$T1
      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
      ++X adder(a:Integer,b:Integer):Integer == a+b
      ++X mapUp!(t2,adder)
      ++X t2

    mapUp_!: (%, %, (S,S,S,S) -> S) -> %
      ++ mapUp!(t,t1,f) traverses balanced binary tree t in an "endorder"
      ++ (left then right then node) fashion returning t with the value
      ++ at each successive interior node of t replaced by
      ++ f(l,r,l1,r1) where l and r are the values at the immediate
      ++ left and right nodes. Values l1 and r1 are values at the
      ++ corresponding nodes of a balanced binary tree t1, of identical
      ++ shape at t.
      ++
      ++X T1:=BalancedBinaryTree Integer
      ++X t2:=balancedBinaryTree(4, 0)$T1
      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
      ++X adder4(i:INT,j:INT,k:INT,l:INT):INT == i+j+k+l
      ++X mapUp!(t2,t2,adder4)
      ++X t2

    mapDown_!: (%,S,(S,S) -> S) -> %
      ++ mapDown!(t,p,f) returns t after traversing t in "preorder"
      ++ (node then left then right) fashion replacing the successive
      ++ interior nodes as follows. The root value x is
      ++ replaced by q := f(p,x). The mapDown!(l,q,f) and
      ++ mapDown!(r,q,f) are evaluated for the left and right subtrees
      ++ l and r of t.
      ++
      ++X T1:=BalancedBinaryTree Integer
      ++X t2:=balancedBinaryTree(4, 0)$T1
      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
      ++X adder(i:Integer,j:Integer):Integer == i+j
      ++X mapDown!(t2,4::INT,adder)
      ++X t2

    mapDown_!: (%,S, (S,S,S) -> List S) -> %
      ++ mapDown!(t,p,f) returns t after traversing t in "preorder"
      ++ (node then left then right) fashion replacing the successive
      ++ interior nodes as follows. Let l and r denote the left and
      ++ right subtrees of t. The root value x of t is replaced by p.
      ++ Then f(value l, value r, p), where l and r denote the left
      ++ and right subtrees of t, is evaluated producing two values
      ++ pl and pr. Then \spad{mapDown!(l,pl,f)} and \spad{mapDown!(l,pr,f)}
      ++ are evaluated.
      ++
      ++X T1:=BalancedBinaryTree Integer
      ++X t2:=balancedBinaryTree(4, 0)$T1
      ++X setleaves!(t2,[1,2,3,4]::List(Integer))
      ++X adder3(i:Integer,j:Integer,k:Integer):List Integer == [i+j,j+k]
      ++X mapDown!(t2,4::INT,adder3)
      ++X t2

  Implementation == BinaryTree(S) add
    Rep := BinaryTree(S)
    leaf? x ==
      empty? x => false
      empty? left x and empty? right x
--    balancedBinaryTree(x: S, u: List S) ==
--      n := #u
--      n = 0 => empty()
--      setleaves_!(balancedBinaryTree(n, x), u)
    setleaves_!(t, u) ==
      n := #u
      n = 0 =>
        empty? t => t
        error "the tree and list must have the same number of elements"
      n = 1 =>
        setvalue_!(t,first u)
        t
      m := n quo 2
      acc := empty()$(List S)
      for i in 1..m repeat
        acc := [first u,:acc]
        u := rest u
      setleaves_!(left t, reverse_! acc)
      setleaves_!(right t, u)
      t
    balancedBinaryTree(n: NonNegativeInteger, val: S) ==
      n = 0 => empty()
      n = 1 => node(empty(),val,empty())
      m := n quo 2
      node(balancedBinaryTree(m, val), val,
           balancedBinaryTree((n - m) pretend NonNegativeInteger, val))
    mapUp_!(x,fn) ==
      empty? x => error "mapUp! called on a null tree"
      leaf? x  => x.value
      x.value := fn(mapUp_!(x.left,fn),mapUp_!(x.right,fn))
    mapUp_!(x,y,fn) ==
      empty? x  => error "mapUp! is called on a null tree"
      leaf? x  =>
        leaf? y => x
        error "balanced binary trees are incompatible"
      leaf? y  =>  error "balanced binary trees are incompatible"
      mapUp_!(x.left,y.left,fn)
      mapUp_!(x.right,y.right,fn)
      x.value := fn(x.left.value,x.right.value,y.left.value,y.right.value)
      x
    mapDown_!(x: %, p: S, fn: (S,S) -> S ) ==
      empty? x => x
      x.value := fn(p, x.value)
      mapDown_!(x.left, x.value, fn)
      mapDown_!(x.right, x.value, fn)
      x
    mapDown_!(x: %, p: S, fn: (S,S,S) -> List S) ==
      empty? x => x
      x.value := p
      leaf? x => x
      u := fn(x.left.value, x.right.value, p)
      mapDown_!(x.left, u.1, fn)
      mapDown_!(x.right, u.2, fn)
      x

@
\section{domain PENDTREE PendantTree}
A PendantTree(S)is either a leaf? and is an S or has
a left and a right both PendantTree(S)'s
<<domain PENDTREE PendantTree>>=
)abbrev domain PENDTREE PendantTree
PendantTree(S: SetCategory): T == C where
 T == BinaryRecursiveAggregate(S) with
   ptree : S->%
    ++ ptree(s) is a leaf? pendant tree
    ++
    ++X t1:=ptree([1,2,3])
       
   ptree:(%, %)->%
    ++ ptree(x,y) \undocumented
    ++
    ++X t1:=ptree([1,2,3])
    ++X ptree(t1,ptree([1,2,3]))

   coerce:%->Tree S
    ++ coerce(x) \undocumented
    ++
    ++X t1:=ptree([1,2,3])
    ++X t2:=ptree(t1,ptree([1,2,3]))
    ++X t2::Tree List PositiveInteger

 C == add
     Rep := Tree S
     import Tree S
     coerce (t:%):Tree S == t pretend Tree S
     ptree(n) == tree(n,[])$Rep pretend %
     ptree(l,r) == tree(value(r:Rep)$Rep,cons(l,children(r:Rep)$Rep)):%
     leaf? t == empty?(children(t)$Rep)
     t1=t2 == (t1:Rep) = (t2:Rep)
     left b ==
       leaf? b => error "ptree:no left"
       first(children(b)$Rep)
     right b ==
       leaf? b => error "ptree:no right"
       tree(value(b)$Rep,rest (children(b)$Rep))
     value b ==
       leaf? b => value(b)$Rep
       error "the pendant tree has no value"
     coerce(b:%): OutputForm ==
       leaf? b => value(b)$Rep :: OutputForm
       paren blankSeparate [left b::OutputForm,right b ::OutputForm]

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
 
<<domain TREE Tree>>
<<domain BTREE BinaryTree>>
<<domain BBTREE BalancedBinaryTree>>
<<domain BSTREE BinarySearchTree>>
<<domain BTOURN BinaryTournament>>
<<domain PENDTREE PendantTree>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
