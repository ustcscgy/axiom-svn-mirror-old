\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra newpoly.spad}
\author{Marc Moreno Maza}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
Based on the {\bf PseudoRemainderSequence} package, the domain
constructor {\bf NewSparseUnivariatePolynomial} extends the
constructur {\bf SparseUnivariatePolynomial}. 
\section{domain NSUP NewSparseUnivariatePolynomial}
<<domain NSUP NewSparseUnivariatePolynomial>>=
)abbrev domain NSUP NewSparseUnivariatePolynomial
++ Author: Marc Moreno Maza
++ Date Created: 23/07/98
++ Date Last Updated: 14/12/98
++ Basic Operations: 
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References: 
++ Description: A post-facto extension for \axiomType{SUP} in order
++ to speed up operations related to pseudo-division and gcd for
++ both \axiomType{SUP} and, consequently, \axiomType{NSMP}.

NewSparseUnivariatePolynomial(R): Exports == Implementation where

  R:Ring
  NNI ==> NonNegativeInteger
  SUPR ==> SparseUnivariatePolynomial R

  Exports == Join(UnivariatePolynomialCategory(R), 
   CoercibleTo(SUPR),RetractableTo(SUPR)) with
     fmecg : (%,NNI,R,%) -> %
        ++ \axiom{fmecg(p1,e,r,p2)} returns \axiom{p1 - r * X**e * p2}
        ++ where \axiom{X} is \axiom{monomial(1,1)}
     monicModulo : ($, $) -> $ 
        ++ \axiom{monicModulo(a,b)} returns \axiom{r} such that \axiom{r} is 
        ++ reduced w.r.t. \axiom{b} and \axiom{b} divides \axiom{a -r}
        ++ where \axiom{b} is monic.
     lazyResidueClass: ($,$) -> Record(polnum:$, polden:R, power:NNI)
        ++ \axiom{lazyResidueClass(a,b)} returns \axiom{[r,c,n]} such that 
        ++ \axiom{r} is reduced w.r.t. \axiom{b} and \axiom{b} divides 
        ++ \axiom{c^n * a - r} where \axiom{c} is \axiom{leadingCoefficient(b)} 
        ++ and \axiom{n} is as small as possible with the previous properties.
     lazyPseudoRemainder: ($,$) -> $
        ++ \axiom{lazyPseudoRemainder(a,b)} returns \axiom{r} if \axiom{lazyResidueClass(a,b)}
        ++ returns \axiom{[r,c,n]}. This lazy pseudo-remainder is computed by 
        ++ means of the \axiomOpFrom{fmecg}{NewSparseUnivariatePolynomial} operation.
     lazyPseudoDivide: ($,$) -> Record(coef:R, gap:NNI, quotient:$, remainder: $)
        ++ \axiom{lazyPseudoDivide(a,b)} returns \axiom{[c,g,q,r]} such that 
        ++ \axiom{c^n * a = q*b +r} and \axiom{lazyResidueClass(a,b)} returns \axiom{[r,c,n]}
        ++ where \axiom{n + g = max(0, degree(b) - degree(a) + 1)}.
     lazyPseudoQuotient: ($,$) -> $
        ++ \axiom{lazyPseudoQuotient(a,b)} returns \axiom{q} if \axiom{lazyPseudoDivide(a,b)}
        ++ returns \axiom{[c,g,q,r]} 
     if R has IntegralDomain
     then 
       subResultantsChain: ($, $) -> List $
         ++ \axiom{subResultantsChain(a,b)} returns the list of the non-zero
         ++ sub-resultants of \axiom{a} and \axiom{b} sorted by increasing 
         ++ degree.
       lastSubResultant: ($, $) -> $
         ++ \axiom{lastSubResultant(a,b)} returns \axiom{resultant(a,b)}
         ++ if \axiom{a} and \axiom{b} has no non-trivial gcd in \axiom{R^(-1) P}
         ++ otherwise the non-zero sub-resultant with smallest index.
       extendedSubResultantGcd: ($, $) -> Record(gcd: $, coef1: $, coef2: $)
         ++ \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[g,ca, cb]} such
         ++ that \axiom{g} is a gcd of \axiom{a} and \axiom{b} in \axiom{R^(-1) P}
         ++ and \axiom{g = ca * a + cb * b}
       halfExtendedSubResultantGcd1: ($, $) -> Record(gcd: $, coef1: $)
         ++ \axiom{halfExtendedSubResultantGcd1(a,b)} returns \axiom{[g,ca]} such that
         ++ \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[g,ca, cb]}
       halfExtendedSubResultantGcd2: ($, $) -> Record(gcd: $, coef2: $)
         ++ \axiom{halfExtendedSubResultantGcd2(a,b)} returns \axiom{[g,cb]} such that
         ++ \axiom{extendedSubResultantGcd(a,b)} returns \axiom{[g,ca, cb]}
       extendedResultant: ($, $) -> Record(resultant: R, coef1: $, coef2: $)
         ++ \axiom{extendedResultant(a,b)} returns  \axiom{[r,ca,cb]} such that 
         ++ \axiom{r} is the resultant of \axiom{a} and \axiom{b} and
         ++ \axiom{r = ca * a + cb * b}
       halfExtendedResultant1: ($, $) -> Record(resultant: R, coef1: $)
         ++ \axiom{halfExtendedResultant1(a,b)} returns \axiom{[r,ca]} such that 
         ++ \axiom{extendedResultant(a,b)}  returns \axiom{[r,ca, cb]} 
       halfExtendedResultant2: ($, $) -> Record(resultant: R, coef2: $)
         ++ \axiom{halfExtendedResultant2(a,b)} returns \axiom{[r,ca]} such that 
         ++ \axiom{extendedResultant(a,b)} returns \axiom{[r,ca, cb]} 

  Implementation == SparseUnivariatePolynomial(R) add
   
     Term == Record(k:NonNegativeInteger,c:R)
     Rep ==> List Term

     rep(s:$):Rep == s pretend Rep
     per(l:Rep):$ == l pretend $

     coerce (p:$):SUPR == 
       p pretend SUPR

     coerce (p:SUPR):$ == 
       p pretend $

     retractIfCan (p:$) : Union(SUPR,"failed") == 
       (p pretend SUPR)::Union(SUPR,"failed")

     monicModulo(x,y) ==
		zero? y => 
		   error "in monicModulo$NSUP: division by 0"
		ground? y =>
		   error "in monicModulo$NSUP: ground? #2"
                yy := rep y
--                not one? (yy.first.c) => 
                not ((yy.first.c) = 1) => 
		   error "in monicModulo$NSUP: not monic #2"
                xx := rep x; empty? xx => x
                e := yy.first.k; y := per(yy.rest)                
                -- while (not empty? xx) repeat
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx:= rep fmecg(per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per xx

     lazyResidueClass(x,y) ==
		zero? y => 
		   error "in lazyResidueClass$NSUP: division by 0"
		ground? y =>
		   error "in lazyResidueClass$NSUP: ground? #2"
                yy := rep y; co := yy.first.c; xx: Rep := rep x
                empty? xx => [x, co, 0]
                pow: NNI := 0; e := yy.first.k; y := per(yy.rest); 
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx:= rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := pow + 1
                  if empty? xx then break
                [per xx, co, pow]

     lazyPseudoRemainder(x,y) ==
		zero? y => 
		   error "in lazyPseudoRemainder$NSUP: division by 0"
		ground? y =>
		   error "in lazyPseudoRemainder$NSUP: ground? #2"
		ground? x => x
                yy := rep y; co := yy.first.c
--                one? co => monicModulo(x,y)
                (co = 1) => monicModulo(x,y)
                (co = -1) => - monicModulo(-x,-y)
                xx:= rep x; e := yy.first.k; y := per(yy.rest)
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  xx:= rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per xx

     lazyPseudoDivide(x,y) ==
		zero? y => 
		   error "in lazyPseudoDivide$NSUP: division by 0"
		ground? y =>
		   error "in lazyPseudoDivide$NSUP: ground? #2"
                yy := rep y; e := yy.first.k; 
                xx: Rep := rep x; co := yy.first.c
		(empty? xx) or (xx.first.k < e) => [co,0,0,x]
                pow: NNI := subtractIfCan(xx.first.k,e)::NNI + 1
                qq: Rep := []; y := per(yy.rest)
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := subtractIfCan(pow,1)::NNI
                  if empty? xx then break
                [co, pow, per reverse qq, per xx]

     lazyPseudoQuotient(x,y) ==
		zero? y => 
		   error "in lazyPseudoQuotient$NSUP: division by 0"
		ground? y =>
		   error "in lazyPseudoQuotient$NSUP: ground? #2"
                yy := rep y; e := yy.first.k; xx: Rep := rep x
		(empty? xx) or (xx.first.k < e) => 0
                qq: Rep := []; co := yy.first.c; y := per(yy.rest)
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  if empty? xx then break
                per reverse qq

     if R has IntegralDomain
     then 
       pack ==> PseudoRemainderSequence(R, %)

       subResultantGcd(p1,p2) == subResultantGcd(p1,p2)$pack

       subResultantsChain(p1,p2) == chainSubResultants(p1,p2)$pack

       lastSubResultant(p1,p2) == lastSubResultant(p1,p2)$pack

       resultant(p1,p2) == resultant(p1,p2)$pack

       extendedResultant(p1,p2) == 
          re: Record(coef1: $, coef2: $, resultant: R) := resultantEuclidean(p1,p2)$pack
          [re.resultant, re.coef1, re.coef2]

       halfExtendedResultant1(p1:$, p2: $): Record(resultant: R, coef1: $) ==
          re: Record(coef1: $, resultant: R) := semiResultantEuclidean1(p1, p2)$pack
          [re.resultant, re.coef1]

       halfExtendedResultant2(p1:$, p2: $): Record(resultant: R, coef2: $) ==
          re: Record(coef2: $, resultant: R) := semiResultantEuclidean2(p1, p2)$pack
          [re.resultant, re.coef2]

       extendedSubResultantGcd(p1,p2) == 
          re: Record(coef1: $, coef2: $, gcd: $) := subResultantGcdEuclidean(p1,p2)$pack
          [re.gcd, re.coef1, re.coef2]

       halfExtendedSubResultantGcd1(p1:$, p2: $): Record(gcd: $, coef1: $) ==
          re: Record(coef1: $, gcd: $) := semiSubResultantGcdEuclidean1(p1, p2)$pack
          [re.gcd, re.coef1]

       halfExtendedSubResultantGcd2(p1:$, p2: $): Record(gcd: $, coef2: $) ==
          re: Record(coef2: $, gcd: $) := semiSubResultantGcdEuclidean2(p1, p2)$pack
          [re.gcd, re.coef2]

       pseudoDivide(x,y) ==
		zero? y => 
		   error "in pseudoDivide$NSUP: division by 0"
		ground? y =>
		   error "in pseudoDivide$NSUP: ground? #2"
                yy := rep y; e := yy.first.k
                xx: Rep := rep x; co := yy.first.c
		(empty? xx) or (xx.first.k < e) => [co,0,x]
                pow: NNI := subtractIfCan(xx.first.k,e)::NNI + 1
                qq: Rep := []; y := per(yy.rest)
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := subtractIfCan(pow,1)::NNI
                  if empty? xx then break
                zero? pow => [co, per reverse qq, per xx]
                default: R := co ** pow
                q := default * (per reverse qq)
                x := default * (per xx)
                [co, q, x]

       pseudoQuotient(x,y) ==
		zero? y => 
		   error "in pseudoDivide$NSUP: division by 0"
		ground? y =>
		   error "in pseudoDivide$NSUP: ground? #2"
                yy := rep y; e := yy.first.k; xx: Rep := rep x
		(empty? xx) or (xx.first.k < e) => 0
                pow: NNI := subtractIfCan(xx.first.k,e)::NNI + 1
                qq: Rep := []; co := yy.first.c; y := per(yy.rest)
                repeat
                  if (u:=subtractIfCan(xx.first.k,e)) case "failed" then break
                  qq := cons([u::NNI, xx.first.c]$Term, rep (co * per qq))
                  xx := rep fmecg(co * per rest(xx), u, xx.first.c, y)
                  pow := subtractIfCan(pow,1)::NNI
                  if empty? xx then break
                zero? pow => per reverse qq
                (co ** pow) * (per reverse qq)

@
\section{package NSUP2 NewSparseUnivariatePolynomialFunctions2}
<<package NSUP2 NewSparseUnivariatePolynomialFunctions2>>=
)abbrev package NSUP2 NewSparseUnivariatePolynomialFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package lifts a mapping from coefficient rings R to S to
++ a mapping from sparse univariate polynomial over R to
++ a sparse univariate polynomial over S.
++ Note that the mapping is assumed
++ to send zero to zero, since it will only be applied to the non-zero
++ coefficients of the polynomial.

NewSparseUnivariatePolynomialFunctions2(R:Ring, S:Ring): with
  map:(R->S,NewSparseUnivariatePolynomial R) -> NewSparseUnivariatePolynomial S
    ++ \axiom{map(func, poly)} creates a new polynomial by applying func to
    ++ every non-zero coefficient of the polynomial poly.
 == add
  map(f, p) == map(f, p)$UnivariatePolynomialCategoryFunctions2(R,
           NewSparseUnivariatePolynomial R, S, NewSparseUnivariatePolynomial S)

@
Based on the {\bf PseudoRemainderSequence} package, the domain
constructor {\bf NewSparseMulitvariatePolynomial} extends
the constructor {\bf SparseMultivariatePolynomial}. It also provides
some additional operations related to polynomial system solving
by means of triangular sets.
\section{domain NSMP NewSparseMultivariatePolynomial}
<<domain NSMP NewSparseMultivariatePolynomial>>=
)abbrev domain NSMP NewSparseMultivariatePolynomial
++ Author: Marc Moreno Maza
++ Date Created: 22/04/94
++ Date Last Updated: 14/12/1998
++ Basic Operations: 
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ Examples:
++ References:
++ Description: A post-facto extension for \axiomType{SMP} in order
++ to speed up operations related to pseudo-division and gcd.
++ This domain is based on the \axiomType{NSUP} constructor which is 
++ itself a post-facto extension of the \axiomType{SUP} constructor.
++ Version: 2

NewSparseMultivariatePolynomial(R,VarSet) : Exports == Implementation where
  R:Ring
  VarSet:OrderedSet
  N ==> NonNegativeInteger
  Z ==> Integer
  SUP ==> NewSparseUnivariatePolynomial
  SMPR ==> SparseMultivariatePolynomial(R, VarSet)
  SUP2 ==> NewSparseUnivariatePolynomialFunctions2($,$)

  Exports == Join(RecursivePolynomialCategory(R,IndexedExponents VarSet, VarSet),
                  CoercibleTo(SMPR),RetractableTo(SMPR))

  Implementation ==  SparseMultivariatePolynomial(R, VarSet) add

     D := NewSparseUnivariatePolynomial($)
     VPoly:=  Record(v:VarSet,ts:D)
     Rep:= Union(R,VPoly)

    --local function
     PSimp: (D,VarSet) -> %

     PSimp(up,mv) ==
       if degree(up) = 0 then leadingCoefficient(up) else [mv,up]$VPoly

     coerce (p:$):SMPR == 
       p pretend SMPR

     coerce (p:SMPR):$ == 
       p pretend $

     retractIfCan (p:$) : Union(SMPR,"failed") == 
       (p pretend SMPR)::Union(SMPR,"failed")

     mvar p == 
       p case R => error" Error in mvar from NSMP : #1 has no variables."
       p.v

     mdeg p == 
       p case R => 0$N
       degree(p.ts)$D

     init p == 
       p case R => error" Error in init from NSMP : #1 has no variables."
       leadingCoefficient(p.ts)$D

     head p == 
       p case R => p
       ([p.v,leadingMonomial(p.ts)$D]$VPoly)::Rep

     tail p == 
       p case R => 0$$
       red := reductum(p.ts)$D
       ground?(red)$D => (ground(red)$D)::Rep
       ([p.v,red]$VPoly)::Rep

     iteratedInitials p == 
       p case R => [] 
       p := leadingCoefficient(p.ts)$D
       cons(p,iteratedInitials(p)) 

     localDeepestInitial (p : $) : $ == 
       p case R => p 
       localDeepestInitial leadingCoefficient(p.ts)$D 

     deepestInitial p == 
       p case R => error"Error in deepestInitial from NSMP : #1 has no variables."
       localDeepestInitial leadingCoefficient(p.ts)$D  

     mainMonomial p == 
       zero? p => error"Error in mainMonomial from NSMP : the argument is zero"
       p case R => 1$$ 
       monomial(1$$,p.v,degree(p.ts)$D)

     leastMonomial p == 
       zero? p => error"Error in leastMonomial from NSMP : the argument is zero"
       p case R => 1$$
       monomial(1$$,p.v,minimumDegree(p.ts)$D)

     mainCoefficients p == 
       zero? p => error"Error in mainCoefficients from NSMP : the argument is zero"
       p case R => [p]
       coefficients(p.ts)$D

     leadingCoefficient(p:$,x:VarSet):$ == 
       (p case R) => p
       p.v = x => leadingCoefficient(p.ts)$D
       zero? (d := degree(p,x)) => p
       coefficient(p,x,d)

     localMonicModulo(a:$,b:$):$ ==
       -- b is assumed to have initial 1
       a case R => a
       a.v < b.v => a 
       mM: $
       if a.v > b.v
         then 
           m : D := map(localMonicModulo(#1,b),a.ts)$SUP2
         else
           m : D := monicModulo(a.ts,b.ts)$D
       if ground?(m)$D 
          then 
            mM := (ground(m)$D)::Rep 
          else 
            mM := ([a.v,m]$VPoly)::Rep
       mM

     monicModulo (a,b) == 
       b case R => error"Error in monicModulo from NSMP : #2 is constant"
       ib : $ := init(b)@$
       not ground?(ib)$$ => 
         error"Error in monicModulo from NSMP : #2 is not monic"
       mM : $
--       if not one?(ib)$$
       if not ((ib) = 1)$$
         then
           r : R := ground(ib)$$
           rec : Union(R,"failed"):= recip(r)$R
           (rec case "failed") =>
             error"Error in monicModulo from NSMP : #2 is not monic"
           a case R => a
           a := (rec::R) * a
           b := (rec::R) * b
           mM := ib * localMonicModulo (a,b)
         else
           mM := localMonicModulo (a,b)
       mM

     prem(a:$, b:$): $ == 
       -- with pseudoRemainder$NSUP
       b case R =>
         error "in prem$NSMP: ground? #2"
       db: N := degree(b.ts)$D
       lcb: $ := leadingCoefficient(b.ts)$D
       test: Z := degree(a,b.v)::Z - db
       delta: Z := max(test + 1$Z, 0$Z)
       (a case R) or (a.v < b.v) => lcb ** (delta::N) * a
       a.v = b.v =>
         r: D := pseudoRemainder(a.ts,b.ts)$D
         ground?(r) => return (ground(r)$D)::Rep 
         ([a.v,r]$VPoly)::Rep
       while not zero?(a) and not negative?(test) repeat 
         term := monomial(leadingCoefficient(a,b.v),b.v,test::N)
         a := lcb * a - term * b
         delta := delta - 1$Z 
         test := degree(a,b.v)::Z - db
       lcb ** (delta::N) * a

     pquo (a:$, b:$)  : $ == 
       cPS := lazyPseudoDivide (a,b)
       c := (cPS.coef) ** (cPS.gap)
       c * cPS.quotient

     pseudoDivide(a:$, b:$): Record (quotient : $, remainder : $) ==
       -- from RPOLCAT
       cPS := lazyPseudoDivide(a,b)
       c := (cPS.coef) ** (cPS.gap)
       [c * cPS.quotient, c * cPS.remainder]

     lazyPrem(a:$, b:$): $ == 
       -- with lazyPseudoRemainder$NSUP
       -- Uses leadingCoefficient: ($, V) -> $
       b case R =>
         error "in lazyPrem$NSMP: ground? #2"
       (a case R) or (a.v < b.v) =>  a
       a.v = b.v => PSimp(lazyPseudoRemainder(a.ts,b.ts)$D,a.v)
       db: N := degree(b.ts)$D
       lcb: $ := leadingCoefficient(b.ts)$D
       test: Z := degree(a,b.v)::Z - db
       while not zero?(a) and not negative?(test) repeat 
         term := monomial(leadingCoefficient(a,b.v),b.v,test::N)
         a := lcb * a - term * b
         test := degree(a,b.v)::Z - db
       a

     lazyPquo (a:$, b:$) : $ ==
       -- with lazyPseudoQuotient$NSUP
       b case R =>
         error " in lazyPquo$NSMP: #2 is conctant"
       (a case R) or (a.v < b.v) => 0
       a.v = b.v => PSimp(lazyPseudoQuotient(a.ts,b.ts)$D,a.v)
       db: N := degree(b.ts)$D
       lcb: $ := leadingCoefficient(b.ts)$D
       test: Z := degree(a,b.v)::Z - db
       q := 0$$
       test: Z := degree(a,b.v)::Z - db
       while not zero?(a) and not negative?(test) repeat 
         term := monomial(leadingCoefficient(a,b.v),b.v,test::N)
         a := lcb * a - term * b
         q := lcb * q + term
         test := degree(a,b.v)::Z - db
       q

     lazyPseudoDivide(a:$, b:$): Record(coef:$, gap: N,quotient:$, remainder:$) == 
       -- with lazyPseudoDivide$NSUP
       b case R =>
         error " in lazyPseudoDivide$NSMP: #2 is conctant"
       (a case R) or (a.v < b.v) => [1$$,0$N,0$$,a]
       a.v = b.v =>
         cgqr := lazyPseudoDivide(a.ts,b.ts)
         [cgqr.coef, cgqr.gap, PSimp(cgqr.quotient,a.v), PSimp(cgqr.remainder,a.v)]
       db: N := degree(b.ts)$D
       lcb: $ := leadingCoefficient(b.ts)$D
       test: Z := degree(a,b.v)::Z - db
       q := 0$$
       delta: Z := max(test + 1$Z, 0$Z) 
       while not zero?(a) and not negative?(test) repeat 
         term := monomial(leadingCoefficient(a,b.v),b.v,test::N)
         a := lcb * a - term * b
         q := lcb * q + term
         delta := delta - 1$Z 
         test := degree(a,b.v)::Z - db
       [lcb, (delta::N), q, a]

     lazyResidueClass(a:$, b:$): Record(polnum:$, polden:$, power:N) == 
       -- with lazyResidueClass$NSUP
       b case R =>
         error " in lazyResidueClass$NSMP: #2 is conctant"
       lcb: $ := leadingCoefficient(b.ts)$D
       (a case R) or (a.v < b.v) => [a,lcb,0]
       a.v = b.v =>
         lrc := lazyResidueClass(a.ts,b.ts)$D
         [PSimp(lrc.polnum,a.v), lrc.polden, lrc.power]
       db: N := degree(b.ts)$D
       test: Z := degree(a,b.v)::Z - db
       pow: N := 0
       while not zero?(a) and not negative?(test) repeat 
         term := monomial(leadingCoefficient(a,b.v),b.v,test::N)
         a := lcb * a - term * b
         pow := pow + 1
         test := degree(a,b.v)::Z - db
       [a, lcb, pow]

     if R has IntegralDomain
     then

       packD := PseudoRemainderSequence($,D)

       exactQuo(x:$, y:$):$ == 
         ex: Union($,"failed") := x exquo$$ y
         (ex case $) => ex::$
         error "in exactQuotient$NSMP: bad args"

       LazardQuotient(x:$, y:$, n: N):$ == 
         zero?(n) => error("LazardQuotient$NSMP : n = 0")
--         one?(n) => x
         (n = 1) => x
         a: N := 1
         while n >= (b := 2*a) repeat a := b
         c: $ := x
         n := (n - a)::N
         repeat       
--           one?(a) => return c
           (a = 1) => return c
           a := a quo 2
           c := exactQuo(c*c,y)
           if n >= a then ( c := exactQuo(c*x,y) ; n := (n - a)::N )

       LazardQuotient2(p:$, a:$, b:$, n: N) ==
         zero?(n) => error " in LazardQuotient2$NSMP: bad #4"
--         one?(n) => p
         (n = 1) => p
         c: $  := LazardQuotient(a,b,(n-1)::N)
         exactQuo(c*p,b)

       next_subResultant2(p:$, q:$, z:$, s:$) ==
         PSimp(next_sousResultant2(p.ts,q.ts,z.ts,s)$packD,p.v)

       subResultantGcd(a:$, b:$): $ ==
         (a case R) or (b case R) => 
           error "subResultantGcd$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "subResultantGcd$NSMP: mvar(#1) ~= mvar(#2)"
         PSimp(subResultantGcd(a.ts,b.ts),a.v)

       halfExtendedSubResultantGcd1(a:$,b:$): Record (gcd: $, coef1: $) ==
         (a case R) or (b case R) => 
           error "halfExtendedSubResultantGcd1$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "halfExtendedSubResultantGcd1$NSMP: mvar(#1) ~= mvar(#2)"
         hesrg := halfExtendedSubResultantGcd1(a.ts,b.ts)$D
         [PSimp(hesrg.gcd,a.v), PSimp(hesrg.coef1,a.v)]

       halfExtendedSubResultantGcd2(a:$,b:$): Record (gcd: $, coef2: $) ==
         (a case R) or (b case R) => 
           error "halfExtendedSubResultantGcd2$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "halfExtendedSubResultantGcd2$NSMP: mvar(#1) ~= mvar(#2)"
         hesrg := halfExtendedSubResultantGcd2(a.ts,b.ts)$D
         [PSimp(hesrg.gcd,a.v), PSimp(hesrg.coef2,a.v)]

       extendedSubResultantGcd(a:$,b:$): Record (gcd: $, coef1: $, coef2: $) ==
         (a case R) or (b case R) => 
           error "extendedSubResultantGcd$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "extendedSubResultantGcd$NSMP: mvar(#1) ~= mvar(#2)"
         esrg := extendedSubResultantGcd(a.ts,b.ts)$D
         [PSimp(esrg.gcd,a.v),PSimp(esrg.coef1,a.v),PSimp(esrg.coef2,a.v)]  

       resultant(a:$, b:$): $ ==
         (a case R) or (b case R) => 
           error "resultant$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "resultant$NSMP: mvar(#1) ~= mvar(#2)"
         resultant(a.ts,b.ts)$D

       subResultantChain(a:$, b:$): List $ ==
         (a case R) or (b case R) => 
           error "subResultantChain$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "subResultantChain$NSMP: mvar(#1) ~= mvar(#2)"
         [PSimp(up,a.v) for up in subResultantsChain(a.ts,b.ts)]

       lastSubResultant(a:$, b:$): $ ==
         (a case R) or (b case R) => 
           error "lastSubResultant$NSMP: one arg is constant"
         a.v ~= b.v => 
           error "lastSubResultant$NSMP: mvar(#1) ~= mvar(#2)"
         PSimp(lastSubResultant(a.ts,b.ts),a.v)

       if R has EuclideanDomain
       then

         exactQuotient (a:$,b:R) ==
--           one? b => a
           (b = 1) => a
           a case R => (a::R quo$R b)::$
           ([a.v, map(exactQuotient(#1,b),a.ts)$SUP2]$VPoly)::Rep

         exactQuotient! (a:$,b:R) ==
--           one? b => a
           (b = 1) => a
           a case R => (a::R quo$R b)::$
           a.ts := map(exactQuotient!(#1,b),a.ts)$SUP2
           a

       else

         exactQuotient (a:$,b:R) ==
--           one? b => a
           (b = 1) => a
           a case R => ((a::R exquo$R b)::R)::$
           ([a.v, map(exactQuotient(#1,b),a.ts)$SUP2]$VPoly)::Rep

         exactQuotient! (a:$,b:R) == 
--           one? b => a
           (b = 1) => a
           a case R => ((a::R exquo$R b)::R)::$
           a.ts := map(exactQuotient!(#1,b),a.ts)$SUP2
           a

     if R has GcdDomain
     then

       localGcd(r:R,p:$):R ==
         p case R => gcd(r,p::R)$R
         gcd(r,content(p))$R         

       gcd(r:R,p:$):R ==
--         one? r => r
         (r = 1) => r
         zero? p => r
         localGcd(r,p)

       content p ==
         p case R => p
         up : D := p.ts
         r := 0$R
--         while (not zero? up) and (not one? r) repeat
         while (not zero? up) and (not (r = 1)) repeat
           r := localGcd(r,leadingCoefficient(up))
           up := reductum up
         r

       primitivePart! p ==
         zero? p => p
         p case R => 1$$
         cp := content(p)
         p.ts := unitCanonical(map(exactQuotient!(#1,cp),p.ts)$SUP2)$D
         p

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain NSUP NewSparseUnivariatePolynomial>>
<<package NSUP2 NewSparseUnivariatePolynomialFunctions2>>
<<domain NSMP NewSparseMultivariatePolynomial>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
