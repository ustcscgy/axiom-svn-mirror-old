\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra multpoly.spad}
\author{Dave Barton, Barry Trager, James Davenport}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{domain POLY Polynomial}
<<Polynomial.input>>=
-- multpoly.spad.pamphlet Polynomial.input
)spool Polynomial.output
)set message test on
)set message auto off
--S 1 of 46
x + 1
--R 
--R
--R   (1)  x + 1
--R                                                     Type: Polynomial Integer
--E 1

--S 2 of 46
z - 2.3
--R 
--R
--R   (2)  z - 2.3
--R                                                       Type: Polynomial Float
--E 2

--S 3 of 46
y**2 - z + 3/4
--R 
--R
--R               2   3
--R   (3)  - z + y  + -
--R                   4
--R                                            Type: Polynomial Fraction Integer
--E 3

--S 4 of 46
y **2 + x*y + y
--R 
--R
--R         2
--R   (4)  y  + (x + 1)y
--R                                                     Type: Polynomial Integer
--E 4

--S 5 of 46
% :: DMP([y,x],INT)
--R 
--R
--R         2
--R   (5)  y  + y x + y
--R                       Type: DistributedMultivariatePolynomial([y,x],Integer)
--E 5

--S 6 of 46
p := (y-1)**2 * x * z
--R 
--R
--R            2
--R   (6)  (x y  - 2x y + x)z
--R                                                     Type: Polynomial Integer
--E 6

--S 7 of 46
q := (y-1) * x * (z+5)
--R 
--R
--R   (7)  (x y - x)z + 5x y - 5x
--R                                                     Type: Polynomial Integer
--E 7

--S 8 of 46
factor(q)
--R 
--R
--R   (8)  x(y - 1)(z + 5)
--R                                            Type: Factored Polynomial Integer
--E 8

--S 9 of 46
p - q**2
--R 
--R
--R   (9)
--R         2 2     2     2  2          2      2       2             2
--R     (- x y  + 2x y - x )z  + ((- 10x  + x)y  + (20x  - 2x)y - 10x  + x)z
--R   + 
--R          2 2      2       2
--R     - 25x y  + 50x y - 25x
--R                                                     Type: Polynomial Integer
--E 9

--S 10 of 46
gcd(p,q)
--R 
--R
--R   (10)  x y - x
--R                                                     Type: Polynomial Integer
--E 10

--S 11 of 46
factor %
--R 
--R
--R   (11)  x(y - 1)
--R                                            Type: Factored Polynomial Integer
--E 11

--S 12 of 46
lcm(p,q)
--R 
--R
--R             2             2        2
--R   (12)  (x y  - 2x y + x)z  + (5x y  - 10x y + 5x)z
--R                                                     Type: Polynomial Integer
--E 12

--S 13 of 46
content p
--R 
--R
--R   (13)  1
--R                                                        Type: PositiveInteger
--E 13

--S 14 of 46
resultant(p,q,z)
--R 
--R
--R           2 3      2 2      2      2
--R   (14)  5x y  - 15x y  + 15x y - 5x
--R                                                     Type: Polynomial Integer
--E 14

--S 15 of 46
resultant(p,q,x)
--R 
--R
--R   (15)  0
--R                                                     Type: Polynomial Integer
--E 15

--S 16 of 46
mainVariable p
--R 
--R
--R   (16)  z
--R                                                      Type: Union(Symbol,...)
--E 16

--S 17 of 46
mainVariable(1 :: POLY INT)
--R 
--R
--R   (17)  "failed"
--R                                                    Type: Union("failed",...)
--E 17

--S 18 of 46
ground? p
--R 
--R
--R   (18)  false
--R                                                                Type: Boolean
--E 18

--S 19 of 46
ground?(1 :: POLY INT)
--R 
--R
--R   (19)  true
--R                                                                Type: Boolean
--E 19

--S 20 of 46
variables p
--R 
--R
--R   (20)  [z,y,x]
--R                                                            Type: List Symbol
--E 20

--S 21 of 46
degree(p,x)
--R 
--R
--R   (21)  1
--R                                                        Type: PositiveInteger
--E 21

--S 22 of 46
degree(p,y)
--R 
--R
--R   (22)  2
--R                                                        Type: PositiveInteger
--E 22

--S 23 of 46
degree(p,z)
--R 
--R
--R   (23)  1
--R                                                        Type: PositiveInteger
--E 23

--S 24 of 46
degree(p,[x,y,z])
--R 
--R
--R   (24)  [1,2,1]
--R                                                Type: List NonNegativeInteger
--E 24

--S 25 of 46
minimumDegree(p,z)
--R 
--R
--R   (25)  1
--R                                                        Type: PositiveInteger
--E 25

--S 26 of 46
totalDegree p
--R 
--R
--R   (26)  4
--R                                                        Type: PositiveInteger
--E 26

--S 27 of 46
leadingMonomial p
--R 
--R
--R            2
--R   (27)  x y z
--R                                                     Type: Polynomial Integer
--E 27

--S 28 of 46
reductum p
--R 
--R
--R   (28)  (- 2x y + x)z
--R                                                     Type: Polynomial Integer
--E 28

--S 29 of 46
p - leadingMonomial p - reductum p
--R 
--R
--R   (29)  0
--R                                                     Type: Polynomial Integer
--E 29

--S 30 of 46
leadingCoefficient p
--R 
--R
--R   (30)  1
--R                                                        Type: PositiveInteger
--E 30

--S 31 of 46
p
--R 
--R
--R             2
--R   (31)  (x y  - 2x y + x)z
--R                                                     Type: Polynomial Integer
--E 31

--S 32 of 46
eval(p,x,w)
--R 
--R
--R             2
--R   (32)  (w y  - 2w y + w)z
--R                                                     Type: Polynomial Integer
--E 32

--S 33 of 46
eval(p,x,1)
--R 
--R
--R           2
--R   (33)  (y  - 2y + 1)z
--R                                                     Type: Polynomial Integer
--E 33

--S 34 of 46
eval(p,x,y^2 - 1)
--R 
--R
--R           4     3
--R   (34)  (y  - 2y  + 2y - 1)z
--R                                                     Type: Polynomial Integer
--E 34

--S 35 of 46
D(p,x)
--R 
--R
--R           2
--R   (35)  (y  - 2y + 1)z
--R                                                     Type: Polynomial Integer
--E 35

--S 36 of 46
D(p,y)
--R 
--R
--R   (36)  (2x y - 2x)z
--R                                                     Type: Polynomial Integer
--E 36

--S 37 of 46
D(p,z)
--R 
--R
--R            2
--R   (37)  x y  - 2x y + x
--R                                                     Type: Polynomial Integer
--E 37

--S 38 of 46
integrate(p,y)
--R 
--R
--R          1    3      2
--R   (38)  (- x y  - x y  + x y)z
--R          3
--R                                            Type: Polynomial Fraction Integer
--E 38

--S 39 of 46
qr := monicDivide(p,x+1,x)
--R 
--R
--R                      2                           2
--R   (39)  [quotient= (y  - 2y + 1)z,remainder= (- y  + 2y - 1)z]
--R     Type: Record(quotient: Polynomial Integer,remainder: Polynomial Integer)
--E 39

--S 40 of 46
qr.remainder
--R 
--R
--R             2
--R   (40)  (- y  + 2y - 1)z
--R                                                     Type: Polynomial Integer
--E 40

--S 41 of 46
p - ((x+1) * qr.quotient + qr.remainder)
--R 
--R
--R   (41)  0
--R                                                     Type: Polynomial Integer
--E 41

--S 42 of 46
p/q
--R 
--R
--R         (y - 1)z
--R   (42)  --------
--R           z + 5
--R                                            Type: Fraction Polynomial Integer
--E 42

--S 43 of 46
(2/3) * x**2 - y + 4/5 
--R 
--R
--R               2  2   4
--R   (43)  - y + - x  + -
--R               3      5
--R                                            Type: Polynomial Fraction Integer
--E 43

--S 44 of 46
% :: FRAC POLY INT
--R 
--R
--R                    2
--R         - 15y + 10x  + 12
--R   (44)  -----------------
--R                 15
--R                                            Type: Fraction Polynomial Integer
--E 44

--S 45 of 46
% :: POLY FRAC INT
--R 
--R
--R               2  2   4
--R   (45)  - y + - x  + -
--R               3      5
--R                                            Type: Polynomial Fraction Integer
--E 45

--S 46 of 46
map(numeric,%)
--R 
--R
--R                                            2
--R   (46)  - 1.0 y + 0.6666666666 6666666667 x  + 0.8
--R                                                       Type: Polynomial Float
--E 46
)spool
)lisp (bye)
@
<<Polynomial.help>>=
====================================================================
Polynomial examples
====================================================================

The domain constructor Polynomial (abbreviation: POLY) provides
polynomials with an arbitrary number of unspecified variables.

It is used to create the default polynomial domains in Axiom.  Here
the coefficients are integers.

  x + 1
    x + 1
                          Type: Polynomial Integer

Here the coefficients have type Float.

  z - 2.3
    z - 2.3
                           Type: Polynomial Float

And here we have a polynomial in two variables with coefficients which
have type Fraction Integer.

  y**2 - z + 3/4
           2   3
    - z + y  + -
               4
                           Type: Polynomial Fraction Integer

The representation of objects of domains created by Polynomial is that
of recursive univariate polynomials. The term univariate means "one
variable". The term multivariate means "possibly more than one variable".

This recursive structure is sometimes obvious from the display of a polynomial.

  y **2 + x*y + y
     2
    y  + (x + 1)y
                           Type: Polynomial Integer

In this example, you see that the polynomial is stored as a polynomial
in y with coefficients that are polynomials in x with integer coefficients.  
In fact, you really don't need to worry about the representation unless you 
are working on an advanced application where it is critical. The polynomial 
types created from DistributedMultivariatePolynomial and
NewDistributedMultivariatePolynomial are stored and displayed in a
non-recursive manner.

You see a "flat" display of the above polynomial by converting to
one of those types.

  % :: DMP([y,x],INT)
     2
    y  + y x + y
                   Type: DistributedMultivariatePolynomial([y,x],Integer)

We will demonstrate many of the polynomial facilities by using two
polynomials with integer coefficients.

By default, the interpreter expands polynomial expressions, even if they
are written in a factored format.

  p := (y-1)**2 * x * z
        2
    (x y  - 2x y + x)z
                   Type: Polynomial Integer

See Factored to see how to create objects in factored form directly.

  q := (y-1) * x * (z+5)
    (x y - x)z + 5x y - 5x
                   Type: Polynomial Integer

The fully factored form can be recovered by using factor.

  factor(q)
    x(y - 1)(z + 5)
                   Type: Factored Polynomial Integer

This is the same name used for the operation to factor integers.  Such
reuse of names is called overloading and makes it much easier to think
of solving problems in general ways.  Axiom facilities for factoring
polynomials created with Polynomial are currently restricted to the
integer and rational number coefficient cases.

The standard arithmetic operations are available for polynomials.

  p - q**2
         2 2     2     2  2          2      2       2             2
     (- x y  + 2x y - x )z  + ((- 10x  + x)y  + (20x  - 2x)y - 10x  + x)z
   + 
          2 2      2       2
     - 25x y  + 50x y - 25x
                   Type: Polynomial Integer

The operation gcd is used to compute the greatest common divisor of
two polynomials.

  gcd(p,q)
    x y - x
                   Type: Polynomial Integer

In the case of p and q, the gcd is obvious from their definitions.  We
factor the gcd to show this relationship better.

  factor %
    x(y - 1)
                   Type: Factored Polynomial Integer

The least common multiple is computed by using lcm.

  lcm(p,q)
        2             2        2
    (x y  - 2x y + x)z  + (5x y  - 10x y + 5x)z
                   Type: Polynomial Integer

Use content to compute the greatest common divisor of the coefficients
of the polynomial.

  content p
    1
                   Type: PositiveInteger

Many of the operations on polynomials require you to specify a variable.  
For example, resultant requires you to give the variable in which the 
polynomials should be expressed.

This computes the resultant of the values of p and q, considering them 
as polynomials in the variable z.  They do not share a root when thought 
of as polynomials in z.

  resultant(p,q,z)
       2 3      2 2      2      2
     5x y  - 15x y  + 15x y - 5x
                   Type: Polynomial Integer

This value is 0 because as polynomials in x the polynomials have a
common root.

  resultant(p,q,x)
    0
                   Type: Polynomial Integer

The data type used for the variables created by Polynomial is Symbol.
As mentioned above, the representation used by Polynomial is recursive
and so there is a main variable for nonconstant polynomials.

The operation mainVariable returns this variable.  The return type is 
actually a union of Symbol and "failed".

  mainVariable p
    z
                   Type: Union(Symbol,...)

The latter branch of the union is be used if the polynomial has no
variables, that is, is a constant.

  mainVariable(1 :: POLY INT)
    "failed"
                   Type: Union("failed",...)

You can also use the predicate ground? to test whether a polynomial is
in fact a member of its ground ring.

  ground? p
    false
                   Type: Boolean

  ground?(1 :: POLY INT)
    true
                   Type: Boolean

The complete list of variables actually used in a particular polynomial 
is returned by variables.  For constant polynomials, this list is empty.

  variables p
    [z,y,x]
                   Type: List Symbol

The degree operation returns the degree of a polynomial in a specific variable.

  degree(p,x)
    1
                   Type: PositiveInteger

  degree(p,y)
    2
                   Type: PositiveInteger

  degree(p,z)
    1
                   Type: PositiveInteger

If you give a list of variables for the second argument, a list of the
degrees in those variables is returned.

  degree(p,[x,y,z])
    [1,2,1]
                   Type: List NonNegativeInteger

The minimum degree of a variable in a polynomial is computed using 
minimumDegree.

  minimumDegree(p,z)
    1
                   Type: PositiveInteger

The total degree of a polynomial is returned by totalDegree.

  totalDegree p
    4
                   Type: PositiveInteger

It is often convenient to think of a polynomial as a leading monomial plus
the remaining terms.

  leadingMonomial p
        2
     x y z
                   Type: Polynomial Integer

The reductum operation returns a polynomial consisting of the sum of
the monomials after the first.

  reductum p
    (- 2x y + x)z
                   Type: Polynomial Integer

These have the obvious relationship that the original polynomial is
equal to the leading monomial plus the reductum.

  p - leadingMonomial p - reductum p
    0
                   Type: Polynomial Integer

The value returned by leadingMonomial includes the coefficient of that term.  
This is extracted by using leadingCoefficient on the original polynomial.

  leadingCoefficient p
    1
                   Type: PositiveInteger

The operation eval is used to substitute a value for a variable in a 
polynomial.

  p
        2
    (x y  - 2x y + x)z
                   Type: Polynomial Integer

This value may be another variable, a constant or a polynomial.

  eval(p,x,w)
        2
    (w y  - 2w y + w)z
                   Type: Polynomial Integer

  eval(p,x,1)
      2
    (y  - 2y + 1)z
                   Type: Polynomial Integer

Actually, all the things being substituted are just polynomials,
some more trivial than others.

  eval(p,x,y^2 - 1)
      4     3
    (y  - 2y  + 2y - 1)z
                   Type: Polynomial Integer

Derivatives are computed using the D operation.

  D(p,x)
      2
    (y  - 2y + 1)z
                   Type: Polynomial Integer

The first argument is the polynomial and the second is the variable.

  D(p,y)
    (2x y - 2x)z
                   Type: Polynomial Integer

Even if the polynomial has only one variable, you must specify it.

  D(p,z)
       2
    x y  - 2x y + x
                   Type: Polynomial Integer

Integration of polynomials is similar and the integrate operation is used.

Integration requires that the coefficients support division. Axiom
converts polynomials over the integers to polynomials over the rational 
numbers before integrating them.

  integrate(p,y)
     1    3      2
    (- x y  - x y  + x y)z
     3
                  Type: Polynomial Fraction Integer

It is not possible, in general, to divide two polynomials.  In our
example using polynomials over the integers, the operation monicDivide
divides a polynomial by a monic polynomial (that is, a polynomial with
leading coefficient equal to 1).  The result is a record of the
quotient and remainder of the division.

You must specify the variable in which to express the polynomial.

  qr := monicDivide(p,x+1,x)
                 2                           2
    [quotient= (y  - 2y + 1)z,remainder= (- y  + 2y - 1)z]
     Type: Record(quotient: Polynomial Integer,remainder: Polynomial Integer)

The selectors of the components of the record are quotient and remainder.  
Issue this to extract the remainder.

  qr.remainder
        2
    (- y  + 2y - 1)z
                       Type: Polynomial Integer

Now that we can extract the components, we can demonstrate the
relationship among them and the arguments to our original expression
qr := monicDivide(p,x+1,x).

  p - ((x+1) * qr.quotient + qr.remainder)
    0
                       Type: Polynomial Integer

If the / operator is used with polynomials, a fraction object is
created.  In this example, the result is an object of type 
Fraction Polynomial Integer.

  p/q
    (y - 1)z
    --------
      z + 5
                       Type: Fraction Polynomial Integer

If you use rational numbers as polynomial coefficients, the
resulting object is of type Polynomial Fraction Integer.

  (2/3) * x**2 - y + 4/5 
          2  2   4
    - y + - x  + -
          3      5
                       Type: Polynomial Fraction Integer

This can be converted to a fraction of polynomials and back again, if
required.

  % :: FRAC POLY INT
               2
    - 15y + 10x  + 12
    -----------------
            15
                       Type: Fraction Polynomial Integer

  % :: POLY FRAC INT
          2  2   4
    - y + - x  + -
          3      5
                       Type: Polynomial Fraction Integer

To convert the coefficients to floating point, map the numeric
operation on the coefficients of the polynomial.

  map(numeric,%)
    - 1.0 y + 0.6666666666 6666666667 x  + 0.8
                       Type: Polynomial Float

See Also:
o )help Factored
o )help UnivariatePolynomial
o )help MultivariatePolynomial
o )help DistributedMultivariatePolynomial
o )help NewDistributedMultivariatePolynomial
o )show Polynomial
o $AXIOM/doc/src/algebra/multpoly.spad.dvi

@
<<domain POLY Polynomial>>=
)abbrev domain POLY Polynomial
++ Author: Dave Barton, Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions: Ring, degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Related Constructors: SparseMultivariatePolynomial, MultivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is the basic representation of sparse recursive multivariate
++ polynomials whose variables are arbitrary symbols. The ordering
++ is alphabetic determined by the Symbol type.
++ The coefficient ring may be non commutative,
++ but the variables are assumed to commute.

Polynomial(R:Ring):
  PolynomialCategory(R, IndexedExponents Symbol, Symbol) with
   if R has Algebra Fraction Integer then
     integrate: (%, Symbol) -> %
       ++ integrate(p,x) computes the integral of \spad{p*dx}, i.e.
       ++ integrates the polynomial p with respect to the variable x.
 == SparseMultivariatePolynomial(R, Symbol) add

    import UserDefinedPartialOrdering(Symbol)

    coerce(p:%):OutputForm ==
      (r:= retractIfCan(p)@Union(R,"failed")) case R => r::R::OutputForm
      a :=
        userOrdered?() => largest variables p
        mainVariable(p)::Symbol
      outputForm(univariate(p, a), a::OutputForm)

    if R has Algebra Fraction Integer then
      integrate(p, x) == (integrate univariate(p, x)) (x::%)

@
\section{package POLY2 PolynomialFunctions2}
<<package POLY2 PolynomialFunctions2>>=
)abbrev package POLY2 PolynomialFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package takes a mapping between coefficient rings, and lifts
++ it to a mapping between polynomials over those rings.

PolynomialFunctions2(R:Ring, S:Ring): with
  map: (R -> S, Polynomial R) -> Polynomial S
    ++ map(f, p) produces a new polynomial as a result of applying
    ++ the function f to every coefficient of the polynomial p.
 == add
  map(f, p) == map(#1::Polynomial(S), f(#1)::Polynomial(S),
                   p)$PolynomialCategoryLifting(IndexedExponents Symbol,
                                   Symbol, R, Polynomial R, Polynomial S)


@
\section{domain MPOLY MultivariatePolynomial}
<<MultivariatePolynomial.input>>=
-- multpoly.spad.pamphlet MultivariatePolynomial.input
)spool MultivariatePolynomial.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
m : MPOLY([x,y],INT) := (x^2 - x*y^3 +3*y)^2
--R 
--R
--R         4     3 3     6       2     4      2
--R   (1)  x  - 2y x  + (y  + 6y)x  - 6y x + 9y
--R                                  Type: MultivariatePolynomial([x,y],Integer)
--E 1

--S 2 of 9
m :: MPOLY([y,x],INT)
--R 
--R
--R         2 6       4     3 3     2     2     4
--R   (2)  x y  - 6x y  - 2x y  + 9y  + 6x y + x
--R                                  Type: MultivariatePolynomial([y,x],Integer)
--E 2

--S 3 of 9
p : MPOLY([x,y],POLY INT)
--R 
--R                                                                   Type: Void
--E 3

--S 4 of 9
p :: POLY INT
--R 
--R
--R   (4)  p
--R                                                     Type: Polynomial Integer
--E 4

--S 5 of 9
% :: MPOLY([a,b],POLY INT)
--R 
--R
--R   (5)  p
--R                       Type: MultivariatePolynomial([a,b],Polynomial Integer)
--E 5

--S 6 of 9
q : UP(x, FRAC MPOLY([y,z],INT))
--R 
--R                                                                   Type: Void
--E 6

--S 7 of 9
q := (x^2 - x*(z+1)/y +2)^2 
--R 
--R
--R                             2    2
--R         4   - 2z - 2  3   4y  + z  + 2z + 1  2   - 4z - 4
--R   (7)  x  + -------- x  + ----------------- x  + -------- x + 4
--R                 y                  2                 y
--R                                   y
--R Type: UnivariatePolynomial(x,Fraction MultivariatePolynomial([y,z],Integer))
--E 7

--S 8 of 9
q :: UP(z, FRAC MPOLY([x,y],INT))
--R 
--R
--R   (8)
--R    2            3     2             2 4       3      2      2            2
--R   x   2   - 2y x  + 2x  - 4y x     y x  - 2y x  + (4y  + 1)x  - 4y x + 4y
--R   -- z  + -------------------- z + ---------------------------------------
--R    2                2                                  2
--R   y                y                                  y
--R Type: UnivariatePolynomial(z,Fraction MultivariatePolynomial([x,y],Integer))
--E 8

--S 9 of 9
q :: MPOLY([x,z], FRAC UP(y,INT))
--R 
--R
--R                                               2
--R         4      2     2  3     1  2    2     4y  + 1  2      4     4
--R   (9)  x  + (- - z - -)x  + (-- z  + -- z + -------)x  + (- - z - -)x + 4
--R                y     y        2       2         2           y     y
--R                              y       y         y
--R Type: MultivariatePolynomial([x,z],Fraction UnivariatePolynomial(y,Integer))
--E 9
)spool
)lisp (bye)
@
<<MultivariatePolynomial.help>>=
====================================================================
MultivariatePolynomial examples
====================================================================

The domain constructor MultivariatePolynomial is similar to Polynomial
except that it specifies the variables to be used.  Polynomial are
available for MultivariatePolynomial.  The abbreviation for
MultivariatePolynomial is MPOLY.  The type expressions

  MultivariatePolynomial([x,y],Integer)
  MPOLY([x,y],INT) 

refer to the domain of multivariate polynomials in the variables x and
y where the coefficients are restricted to be integers.  The first
variable specified is the main variable and the display of the polynomial
reflects this.

This polynomial appears with terms in descending powers of the variable x.

  m : MPOLY([x,y],INT) := (x^2 - x*y^3 +3*y)^2
     4     3 3     6       2     4      2
    x  - 2y x  + (y  + 6y)x  - 6y x + 9y
                     Type: MultivariatePolynomial([x,y],Integer)

It is easy to see a different variable ordering by doing a conversion.

  m :: MPOLY([y,x],INT)
     2 6       4     3 3     2     2     4
    x y  - 6x y  - 2x y  + 9y  + 6x y + x
                     Type: MultivariatePolynomial([y,x],Integer)

You can use other, unspecified variables, by using Polynomial in the
coefficient type of MPOLY.

  p : MPOLY([x,y],POLY INT)
                     Type: Void

Conversions can be used to re-express such polynomials in terms of
the other variables.  For example, you can first push all the
variables into a polynomial with integer coefficients.

  p :: POLY INT
    p
                     Type: Polynomial Integer

Now pull out the variables of interest.

  % :: MPOLY([a,b],POLY INT)
    p
                     Type: MultivariatePolynomial([a,b],Polynomial Integer)

Restriction:
  Axiom does not allow you to create types where MultivariatePolynomial
  is contained in the coefficient type of Polynomial. Therefore,
  MPOLY([x,y],POLY INT) is legal but POLY MPOLY([x,y],INT) is not.

Multivariate polynomials may be combined with univariate polynomials
to create types with special structures.

  q : UP(x, FRAC MPOLY([y,z],INT))
                          Type: Void

This is a polynomial in x whose coefficients are quotients of polynomials 
in y and z.

  q := (x^2 - x*(z+1)/y +2)^2 
                             2    2
         4   - 2z - 2  3   4y  + z  + 2z + 1  2   - 4z - 4
   (7)  x  + -------- x  + ----------------- x  + -------- x + 4
                 y                  2                 y
                                   y
 Type: UnivariatePolynomial(x,Fraction MultivariatePolynomial([y,z],Integer))

Use conversions for structural rearrangements. z does not appear in a
denominator and so it can be made the main variable.

  q :: UP(z, FRAC MPOLY([x,y],INT))
    2            3     2             2 4       3      2      2            2
   x   2   - 2y x  + 2x  - 4y x     y x  - 2y x  + (4y  + 1)x  - 4y x + 4y
   -- z  + -------------------- z + ---------------------------------------
    2                2                                  2
   y                y                                  y
 Type: UnivariatePolynomial(z,Fraction MultivariatePolynomial([x,y],Integer))

Or you can make a multivariate polynomial in x and z whose
coefficients are fractions in polynomials in y.

  q :: MPOLY([x,z], FRAC UP(y,INT))
     4      2     2  3     1  2    2     4y  + 1  2      4     4
    x  + (- - z - -)x  + (-- z  + -- z + -------)x  + (- - z - -)x + 4
            y     y        2       2         2           y     y
                          y       y         y
 Type: MultivariatePolynomial([x,z],Fraction UnivariatePolynomial(y,Integer))

A conversion like q :: MPOLY([x,y], FRAC UP(z,INT)) is not possible in
this example because y appears in the denominator of a fraction.  As
you can see, Axiom provides extraordinary flexibility in the
manipulation and display of expressions via its conversion facility.

See Also:
o )help DistributedMultivariatePolynomial
o )help UnivariatePolynomial
o )help Polynomial
o )show MultivariatePolynomial
o $AXIOM/doc/src/algebra/multpoly.spad.dvi

@
<<domain MPOLY MultivariatePolynomial>>=
)abbrev domain MPOLY MultivariatePolynomial
++ Author: Dave Barton, Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions: Ring, degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Related Constructors: SparseMultivariatePolynomial, Polynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is the basic representation of sparse recursive multivariate
++ polynomials whose variables are from a user specified list of symbols.
++ The ordering is specified by the position of the variable in the list.
++ The coefficient ring may be non commutative,
++ but the variables are assumed to commute.

MultivariatePolynomial(vl:List Symbol, R:Ring)
   ==  SparseMultivariatePolynomial(--SparseUnivariatePolynomial,
           R, OrderedVariableList vl)

@
\section{domain SMP SparseMultivariatePolynomial}
<<domain SMP SparseMultivariatePolynomial>>=
)abbrev domain SMP SparseMultivariatePolynomial
++ Author: Dave Barton, Barry Trager
++ Date Created:
++ Date Last Updated: 30 November 1994
++ Fix History:
++ 30 Nov 94: added gcdPolynomial for float-type coefficients
++ Basic Functions: Ring, degree, eval, coefficient, monomial, differentiate,
++ resultant, gcd
++ Related Constructors: Polynomial, MultivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, multivariate
++ References:
++ Description:
++   This type is the basic representation of sparse recursive multivariate
++ polynomials. It is parameterized by the coefficient ring and the
++ variable set which may be infinite. The variable ordering is determined
++ by the variable set parameter. The coefficient ring may be non-commutative,
++ but the variables are assumed to commute.

SparseMultivariatePolynomial(R: Ring,VarSet: OrderedSet): C == T where
  pgcd ==> PolynomialGcdPackage(IndexedExponents VarSet,VarSet,R,%)
  C == PolynomialCategory(R,IndexedExponents(VarSet),VarSet)
  SUP ==> SparseUnivariatePolynomial
  T == add
    --constants
    --D := F(%) replaced by next line until compiler support completed

    --representations
      D := SparseUnivariatePolynomial(%)
      VPoly:=  Record(v:VarSet,ts:D)
      Rep:=  Union(R,VPoly)

    --local function


    --declarations
      fn: R -> R
      n: Integer
      k: NonNegativeInteger
      kp:PositiveInteger
      k1:NonNegativeInteger
      c: R
      mvar: VarSet
      val : R
      var:VarSet
      up: D
      p,p1,p2,pval: %
      Lval : List(R)
      Lpval : List(%)
      Lvar : List(VarSet)

    --define
      0  == 0$R::%
      1  == 1$R::%


      zero? p == p case R and zero?(p)$R
--      one? p == p case R and one?(p)$R
      one? p == p case R and ((p) = 1)$R
    -- a local function
      red(p:%):% ==
         p case R => 0
         if ground?(reductum p.ts) then leadingCoefficient(reductum p.ts) else [p.v,reductum p.ts]$VPoly

      numberOfMonomials(p): NonNegativeInteger ==
        p case R => 
          zero?(p)$R => 0
          1
        +/[numberOfMonomials q for q in coefficients(p.ts)]

      coerce(mvar):% == [mvar,monomial(1,1)$D]$VPoly

      monomial? p ==
        p case R => true
        sup : D := p.ts
        1 ^= numberOfMonomials(sup) => false
        monomial? leadingCoefficient(sup)$D

--    local
      moreThanOneVariable?: % -> Boolean

      moreThanOneVariable? p == 
         p case R => false
         q:=p.ts
         any?(not ground? #1 ,coefficients q) => true
         false

      -- if we already know we use this (slighlty) faster function
      univariateKnown: % -> SparseUnivariatePolynomial R 

      univariateKnown p == 
        p case R => (leadingCoefficient p) :: SparseUnivariatePolynomial(R)
	monomial( leadingCoefficient p,degree p.ts)+ univariateKnown(red p)

      univariate p ==
        p case R =>(leadingCoefficient p) :: SparseUnivariatePolynomial(R)
        moreThanOneVariable?  p => error "not univariate"
        monomial( leadingCoefficient p,degree p.ts)+ univariate(red p)

      multivariate (u:SparseUnivariatePolynomial(R),var:VarSet) ==
        ground? u => (leadingCoefficient u) ::%
        [var,monomial(leadingCoefficient u,degree u)$D]$VPoly +
           multivariate(reductum u,var)

      univariate(p:%,mvar:VarSet):SparseUnivariatePolynomial(%) ==
        p case R or mvar>p.v  => monomial(p,0)$D
        pt:=p.ts
        mvar=p.v => pt
        monomial(1,p.v,degree pt)*univariate(leadingCoefficient pt,mvar)+
          univariate(red p,mvar)

--  a local functions, used in next definition
      unlikeUnivReconstruct(u:SparseUnivariatePolynomial(%),mvar:VarSet):% ==
        zero? (d:=degree u) => coefficient(u,0)
        monomial(leadingCoefficient u,mvar,d)+
            unlikeUnivReconstruct(reductum u,mvar)

      multivariate(u:SparseUnivariatePolynomial(%),mvar:VarSet):% ==
        ground? u => coefficient(u,0)
        uu:=u
        while not zero? uu repeat
          cc:=leadingCoefficient uu
          cc case R or mvar > cc.v => uu:=reductum uu
          return unlikeUnivReconstruct(u,mvar)
        [mvar,u]$VPoly

      ground?(p:%):Boolean ==
        p case R => true
        false

--      const p ==
--        p case R => p
--        error "the polynomial is not a constant"

      monomial(p,mvar,k1) ==
        zero? k1 or zero? p => p
        p case R or mvar>p.v => [mvar,monomial(p,k1)$D]$VPoly
        p*[mvar,monomial(1,k1)$D]$VPoly

      monomial(c:R,e:IndexedExponents(VarSet)):% ==
        zero? e => (c::%)
        monomial(1,leadingSupport e, leadingCoefficient e) *
            monomial(c,reductum e)

      coefficient(p:%, e:IndexedExponents(VarSet)) : R ==
        zero? e =>
          p case R  => p::R
          coefficient(coefficient(p.ts,0),e)
        p case R => 0
        ve := leadingSupport e
        vp := p.v
        ve < vp =>
          coefficient(coefficient(p.ts,0),e)
        ve > vp => 0
        coefficient(coefficient(p.ts,leadingCoefficient e),reductum e)

--    coerce(e:IndexedExponents(VarSet)) : % ==
--      e = 0 => 1
--      monomial(1,leadingSupport e, leadingCoefficient e) *
--          (reductum e)::%

--    retract(p:%):IndexedExponents(VarSet) ==
--      q:Union(IndexedExponents(VarSet),"failed"):=retractIfCan p
--      q :: IndexedExponents(VarSet)

--    retractIfCan(p:%):Union(IndexedExponents(VarSet),"failed") ==
--      p = 0 => degree p
--      reductum(p)=0 and leadingCoefficient(p)=1 => degree p
--      "failed"

      coerce(n) == n::R::%
      coerce(c) == c::%
      characteristic == characteristic$R

      recip(p) ==
        p case R => (uu:=recip(p::R);uu case "failed" => "failed"; uu::%)
        "failed"

      - p ==
          p case R => -$R p
          [p.v, - p.ts]$VPoly
      n * p  ==
          p case R => n * p::R
          mvar:=p.v
          up:=n*p.ts
          if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
      c * p  ==
          c = 1 => p
          p case R => c * p::R
          mvar:=p.v
          up:=c*p.ts
          if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
      p1 + p2  ==
         p1 case R and p2 case R => p1 +$R p2
         p1 case R => [p2.v, p1::D + p2.ts]$VPoly
	 p2 case R => [p1.v,  p1.ts + p2::D]$VPoly
	 p1.v = p2.v => 
              mvar:=p1.v
              up:=p1.ts+p2.ts
              if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
	 p1.v < p2.v =>
              [p2.v, p1::D + p2.ts]$VPoly
         [p1.v, p1.ts + p2::D]$VPoly

      p1 - p2  ==
         p1 case R and p2 case R => p1 -$R p2
         p1 case R => [p2.v, p1::D - p2.ts]$VPoly
         p2 case R => [p1.v,  p1.ts - p2::D]$VPoly
         p1.v = p2.v =>
              mvar:=p1.v
              up:=p1.ts-p2.ts
              if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
         p1.v < p2.v =>
              [p2.v, p1::D - p2.ts]$VPoly
         [p1.v, p1.ts - p2::D]$VPoly

      p1 = p2  ==
         p1 case R =>
             p2 case R => p1 =$R p2
             false
         p2 case R => false
         p1.v = p2.v => p1.ts = p2.ts
         false

      p1 * p2  ==
         p1 case R => p1::R * p2
         p2 case R => 
            mvar:=p1.v
            up:=p1.ts*p2
            if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
	 p1.v = p2.v => 
            mvar:=p1.v
            up:=p1.ts*p2.ts
            if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
         p1.v > p2.v => 
            mvar:=p1.v
            up:=p1.ts*p2
            if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
            --- p1.v < p2.v 
         mvar:=p2.v
         up:=p1*p2.ts
         if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly

      p ^ kp == p ** (kp pretend NonNegativeInteger)
      p ** kp == p ** (kp pretend NonNegativeInteger )
      p ^ k == p ** k
      p ** k  ==
         p case R => p::R ** k
         -- univariate special case 
         not moreThanOneVariable? p => 
             multivariate( (univariateKnown p) ** k , p.v)
         mvar:=p.v
         up:=p.ts ** k
         if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly

      if R has IntegralDomain then
         UnitCorrAssoc ==> Record(unit:%,canonical:%,associate:%)
         unitNormal(p) ==
            u,c,a:R
            p case R =>
              (u,c,a):= unitNormal(p::R)$R
              [u::%,c::%,a::%]$UnitCorrAssoc
            (u,c,a):= unitNormal(leadingCoefficient(p))$R
            [u::%,(a*p)::%,a::%]$UnitCorrAssoc
         unitCanonical(p) ==
            p case R => unitCanonical(p::R)$R
            (u,c,a):= unitNormal(leadingCoefficient(p))$R
            a*p
         unit? p ==
            p case R => unit?(p::R)$R
            false
         associates?(p1,p2) ==
            p1 case R => p2 case R and associates?(p1,p2)$R
            p2 case VPoly and p1.v = p2.v and associates?(p1.ts,p2.ts)

         if R has approximate then
           p1  exquo  p2  ==
              p1 case R and p2 case R =>
                a:= (p1::R  exquo  p2::R)
                if a case "failed" then "failed" else a::%
              zero? p1 => p1
--              one? p2 => p1
              (p2 = 1) => p1
              p1 case R or p2 case VPoly and p1.v < p2.v => "failed"
              p2 case R or p1.v > p2.v =>
                 a:= (p1.ts  exquo  p2::D)
                 a case "failed" => "failed"
                 [p1.v,a]$VPoly::%
              -- The next test is useful in the case that R has inexact
              -- arithmetic (in particular when it is Interval(...)).
              -- In the case where the test succeeds, empirical evidence
              -- suggests that it can speed up the computation several times,
              -- but in other cases where there are a lot of variables
              -- and p1 and p2 differ only in the low order terms (e.g. p1=p2+1)
              -- it slows exquo down by about 15-20%.
              p1 = p2 => 1
              a:= p1.ts  exquo  p2.ts
              a case "failed" => "failed"
              mvar:=p1.v
              up:SUP %:=a
              if ground? (up) then leadingCoefficient(up) else [mvar,up]$VPoly::%
         else
           p1  exquo  p2  ==
              p1 case R and p2 case R =>
                a:= (p1::R  exquo  p2::R)
                if a case "failed" then "failed" else a::%
              zero? p1 => p1
--              one? p2 => p1
              (p2 = 1) => p1
              p1 case R or p2 case VPoly and p1.v < p2.v => "failed"
              p2 case R or p1.v > p2.v =>
                 a:= (p1.ts  exquo  p2::D)
                 a case "failed" => "failed"
                 [p1.v,a]$VPoly::%
              a:= p1.ts  exquo  p2.ts
              a case "failed" => "failed"
              mvar:=p1.v
              up:SUP %:=a
              if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly::%

      map(fn,p) ==
         p case R => fn(p)
         mvar:=p.v
         up:=map(map(fn,#1),p.ts)
         if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly

      if R has Field then
        (p : %) / (r : R) == inv(r) * p

      if R has GcdDomain then
        content(p) ==
           p case R => p
           c :R :=0
           up:=p.ts
--           while not(zero? up) and not(one? c) repeat
           while not(zero? up) and not(c = 1) repeat
               c:=gcd(c,content leadingCoefficient(up))
               up := reductum up
           c

      if R has EuclideanDomain and R has CharacteristicZero and not(R has FloatingPointSystem)  then
        content(p,mvar) ==
          p case R => p
          gcd(coefficients univariate(p,mvar))$pgcd

        gcd(p1,p2) ==  gcd(p1,p2)$pgcd

        gcd(lp:List %) ==  gcd(lp)$pgcd

        gcdPolynomial(a:SUP $,b:SUP $):SUP $ == gcd(a,b)$pgcd

      else if R has GcdDomain then
        content(p,mvar) ==
          p case R => p
          content univariate(p,mvar)

        gcd(p1,p2) ==
           p1 case R =>
              p2 case R => gcd(p1,p2)$R::%
              zero? p1 => p2
              gcd(p1, content(p2.ts))
           p2 case R =>
              zero? p2 => p1
              gcd(p2, content(p1.ts))
           p1.v < p2.v => gcd(p1, content(p2.ts))
           p1.v > p2.v => gcd(content(p1.ts), p2)
           mvar:=p1.v
           up:=gcd(p1.ts, p2.ts)
           if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly

        if R has FloatingPointSystem then
           -- eventually need a better notion of gcd's over floats
           -- this essentially computes the gcds of the monomial contents
           gcdPolynomial(a:SUP $,b:SUP $):SUP $ ==
	      ground? (a) =>
                  zero? a => b
		  gcd(leadingCoefficient a, content b)::SUP $
	      ground?(b) =>
                  zero? b => b
		  gcd(leadingCoefficient b, content a)::SUP $
	      conta := content a
	      mona:SUP $ := monomial(conta, minimumDegree a)
              if mona ^= 1 then
		   a := (a exquo mona)::SUP $
	      contb := content b
	      monb:SUP $ := monomial(contb, minimumDegree b)
              if monb ^= 1 then
		   b := (b exquo monb)::SUP $
	      mong:SUP $  := monomial(gcd(conta, contb),
                                      min(degree mona, degree monb))
              degree(a) >= degree b =>
		   not((a exquo b) case "failed") =>
			mong * b
		   mong
	      not((b exquo a) case "failed") => mong * a
	      mong

      coerce(p):OutputForm ==
        p case R => (p::R)::OutputForm
        outputForm(p.ts,p.v::OutputForm)

      coefficients p ==
        p case R => list(p :: R)$List(R)
        "append"/[coefficients(p1)$% for p1 in coefficients(p.ts)]

      retract(p:%):R ==
        p case R => p :: R
        error "cannot retract nonconstant polynomial"

      retractIfCan(p:%):Union(R, "failed") ==
        p case R => p::R
        "failed"

--      leadingCoefficientRecursive(p:%):% ==
--         p case R => p
--         leadingCoefficient p.ts

      mymerge:(List VarSet,List VarSet) ->List VarSet
      mymerge(l:List VarSet,m:List VarSet):List VarSet  ==
         empty? l => m
         empty? m => l
         first l = first m => 
            empty? rest l => 
                 setrest!(l,rest m)
                 l
            empty? rest m => l 
	    setrest!(l, mymerge(rest l, rest m))
            l
         first l > first m =>
            empty? rest l => 
                setrest!(l,m) 
                l
            setrest!(l, mymerge(rest l, m))
            l
         empty? rest m => 
             setrest!(m,l)
             m
         setrest!(m,mymerge(l,rest m))
         m
         
      variables p ==
         p case R => empty()
         lv:List VarSet:=empty()
         q := p.ts
         while not zero? q repeat
           lv:=mymerge(lv,variables leadingCoefficient q)
           q := reductum q
         cons(p.v,lv)

      mainVariable p ==
         p case R => "failed"
         p.v

      eval(p,mvar,pval) == univariate(p,mvar)(pval)
      eval(p,mvar,val) ==  univariate(p,mvar)(val)

      evalSortedVarlist(p,Lvar,Lpval):% ==
        p case R => p
        empty? Lvar or empty? Lpval => p
        mvar := Lvar.first
        mvar > p.v => evalSortedVarlist(p,Lvar.rest,Lpval.rest)
        pval := Lpval.first
        pts := map(evalSortedVarlist(#1,Lvar,Lpval),p.ts)
        mvar=p.v =>
             pval case R => pts (pval::R)
             pts pval
        multivariate(pts,p.v)

      eval(p,Lvar,Lpval) ==
	empty? rest Lvar => evalSortedVarlist(p,Lvar,Lpval)
	sorted?(#1 > #2, Lvar) => evalSortedVarlist(p,Lvar,Lpval)
        nlvar := sort(#1 > #2,Lvar)
        nlpval :=
           Lvar = nlvar => Lpval
           nlpval := [Lpval.position(mvar,Lvar) for mvar in nlvar]
        evalSortedVarlist(p,nlvar,nlpval)

      eval(p,Lvar,Lval) ==
        eval(p,Lvar,[val::% for val in Lval]$(List %)) -- kill?

      degree(p,mvar) ==
        p case R => 0
        mvar= p.v => degree p.ts
        mvar > p.v => 0    -- might as well take advantage of the order
        max(degree(leadingCoefficient p.ts,mvar),degree(red p,mvar))

      degree(p,Lvar)  == [degree(p,mvar)  for mvar in Lvar]

      degree p ==
        p case R => 0
        degree(leadingCoefficient(p.ts)) + monomial(degree(p.ts), p.v)

      minimumDegree p ==
        p case R => 0
        md := minimumDegree p.ts
        minimumDegree(coefficient(p.ts,md)) + monomial(md, p.v)

      minimumDegree(p,mvar) ==
        p case R => 0
        mvar = p.v => minimumDegree p.ts
        md:=minimumDegree(leadingCoefficient p.ts,mvar)
        zero? (p1:=red p) => md
        min(md,minimumDegree(p1,mvar))

      minimumDegree(p,Lvar) ==
        [minimumDegree(p,mvar) for mvar in Lvar]

      totalDegree(p, Lvar) ==
        ground? p => 0
        null setIntersection(Lvar, variables p) => 0
        u := univariate(p, mv := mainVariable(p)::VarSet)
        weight:NonNegativeInteger := (member?(mv,Lvar) => 1; 0)
        tdeg:NonNegativeInteger := 0
        while u ^= 0 repeat
            termdeg:NonNegativeInteger := weight*degree u +
                           totalDegree(leadingCoefficient u, Lvar)
            tdeg := max(tdeg, termdeg)
            u := reductum u
        tdeg

      if R has CommutativeRing then
        differentiate(p,mvar) ==
          p case R => 0
          mvar=p.v =>  
             up:=differentiate p.ts
             if ground? up then leadingCoefficient(up) else [mvar,up]$VPoly
          up:=map(differentiate(#1,mvar),p.ts)
          if ground? up then leadingCoefficient(up) else [p.v,up]$VPoly

      leadingCoefficient(p) ==
         p case R => p
         leadingCoefficient(leadingCoefficient(p.ts))

--      trailingCoef(p) ==
--        p case R => p
--        coef(p.ts,0) case R => coef(p.ts,0)
--        trailingCoef(red p)
--      TrailingCoef(p) == trailingCoef(p)

      leadingMonomial p ==
          p case R => p
          monomial(leadingMonomial leadingCoefficient(p.ts),
                   p.v, degree(p.ts))

      reductum(p) == 
          p case R => 0
          p - leadingMonomial p


--        if R is Integer then
--           pgcd := PolynomialGcdPackage(%,VarSet)
--           gcd(p1,p2) ==
--               gcd(p1,p2)$pgcd
--
--        else if R is RationalNumber then
--           gcd(p1,p2) ==
--               mrat:= MRationalFactorize(VarSet,%)
--               gcd(p1,p2)$mrat
--
--        else gcd(p1,p2) ==
--           p1 case R =>
--              p2 case R => gcd(p1,p2)$R::%
--              p1 = 0 => p2
--              gcd(p1, content(p2.ts))
--           p2 case R =>
--              p2 = 0 => p1
--              gcd(p2, content(p1.ts))
--           p1.v < p2.v => gcd(p1, content(p2.ts))
--           p1.v > p2.v => gcd(content(p1.ts), p2)
--           PSimp(p1.v, gcd(p1.ts, p2.ts))

@
\section{domain INDE IndexedExponents}
<<domain INDE IndexedExponents>>=
)abbrev domain INDE IndexedExponents
++ Author: James Davenport
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   IndexedExponents of an ordered set of variables gives a representation
++ for the degree of polynomials in commuting variables. It gives an ordered
++ pairing of non negative integer exponents with variables

IndexedExponents(Varset:OrderedSet): C == T where
  C == Join(OrderedAbelianMonoidSup,
            IndexedDirectProductCategory(NonNegativeInteger,Varset))
  T == IndexedDirectProductOrderedAbelianMonoidSup(NonNegativeInteger,Varset) add
      Term:=  Record(k:Varset,c:NonNegativeInteger)
      Rep:=  List Term
      x:%
      t:Term
      coerceOF(t):OutputForm ==     --++ converts term to OutputForm
         t.c = 1 => (t.k)::OutputForm
         (t.k)::OutputForm ** (t.c)::OutputForm
      coerce(x):OutputForm == ++ converts entire exponents to OutputForm
         null x => 1::Integer::OutputForm
         null rest x => coerceOF(first x)
         reduce("*",[coerceOF t for t in x])

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<domain INDE IndexedExponents>>
<<domain SMP SparseMultivariatePolynomial>>
<<domain POLY Polynomial>>
<<package POLY2 PolynomialFunctions2>>
<<domain MPOLY MultivariatePolynomial>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
