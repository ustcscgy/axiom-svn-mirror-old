\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra gaussian.spad}
\author{Barry Trager, James Davenport}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{package COMPLPAT ComplexPattern}
<<package COMPLPAT ComplexPattern>>=
)abbrev package COMPLPAT ComplexPattern
++ Author: Barry Trager
++ Date Created: 30 Nov 1995
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex, patterns
++ References:
++ Description:
++ This package supports converting complex expressions to patterns
ComplexPattern(R, S, CS) : C == T where
    R: SetCategory
    S: Join(ConvertibleTo Pattern R, CommutativeRing)
    CS: ComplexCategory S
    C == with
       convert: CS -> Pattern R
	  ++ convert(cs) converts the complex expression cs to a pattern

    T == add

       ipat : Pattern R := patternVariable("%i"::Symbol, true, false, false)

       convert(cs) ==
          zero? imag cs => convert real cs
          convert real cs + ipat * convert imag cs

@
\section{package CPMATCH ComplexPatternMatch}
<<package CPMATCH ComplexPatternMatch>>=
)abbrev package CPMATCH ComplexPatternMatch
++ Author: Barry Trager
++ Date Created: 30 Nov 1995
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex, pattern matching
++ References:
++ Description:
++ This package supports matching patterns involving complex expressions
ComplexPatternMatch(R, S, CS) : C == T where
    R: SetCategory
    S: Join(PatternMatchable R, CommutativeRing)
    CS: ComplexCategory S
    PMRS ==> PatternMatchResult(R, CS)
    PS   ==> Polynomial S
    C == with
       if PS has PatternMatchable(R) then
           patternMatch: (CS, Pattern R, PMRS) -> PMRS
             ++ patternMatch(cexpr, pat, res) matches the pattern pat to the
             ++ complex expression cexpr. res contains the variables of pat
             ++ which are already matched and their matches.

    T == add

       import PatternMatchPushDown(R, S, CS)
       import PatternMatchResultFunctions2(R, PS, CS)
       import PatternMatchResultFunctions2(R, CS, PS)

       ivar : PS := "%i"::Symbol::PS

       makeComplex(p:PS):CS ==
          up := univariate p
	  degree up > 1 => error "not linear in %i"
	  icoef:=leadingCoefficient(up)
          rcoef:=leadingCoefficient(reductum p)
	  complex(rcoef,icoef)

       makePoly(cs:CS):PS == real(cs)*ivar + imag(cs)::PS

       if PS has PatternMatchable(R) then
          patternMatch(cs, pat, result) ==
	     zero? imag cs =>
                patternMatch(real cs, pat, result)
             map(makeComplex,
                patternMatch(makePoly cs, pat, map(makePoly, result)))

@
\section{domain COMPLEX Complex}
<<Complex.input>>=
-- gaussian.spad.pamphlet Complex.input
)spool Complex.output
)set message test on
)set message auto off
)clear all
--S 1 of 16
a := complex(4/3,5/2)
--R 
--R
--R        4   5
--R   (1)  - + - %i
--R        3   2
--R                                               Type: Complex Fraction Integer
--E 1

--S 2 of 16
b := complex(4/3,-5/2)
--R 
--R
--R        4   5
--R   (2)  - - - %i
--R        3   2
--R                                               Type: Complex Fraction Integer
--E 2

--S 3 of 16
a + b
--R 
--R
--R        8
--R   (3)  -
--R        3
--R                                               Type: Complex Fraction Integer
--E 3

--S 4 of 16
a - b
--R 
--R
--R   (4)  5%i
--R                                               Type: Complex Fraction Integer
--E 4

--S 5 of 16
a * b
--R 
--R
--R        289
--R   (5)  ---
--R         36
--R                                               Type: Complex Fraction Integer
--E 5

--S 6 of 16
a / b
--R 
--R
--R          161   240
--R   (6)  - --- + --- %i
--R          289   289
--R                                               Type: Complex Fraction Integer
--E 6

--S 7 of 16
% :: Fraction Complex Integer
--R 
--R
--R        - 15 + 8%i
--R   (7)  ----------
--R         15 + 8%i
--R                                               Type: Fraction Complex Integer
--E 7

--S 8 of 16
3.4 + 6.7 * %i
--R 
--R
--R   (8)  3.4 + 6.7 %i
--R                                                          Type: Complex Float
--E 8

--S 9 of 16
conjugate a
--R 
--R
--R        4   5
--R   (9)  - - - %i
--R        3   2
--R                                               Type: Complex Fraction Integer
--E 9

--S 10 of 16
norm a
--R 
--R
--R         289
--R   (10)  ---
--R          36
--R                                                       Type: Fraction Integer
--E 10

--S 11 of 16
real a
--R 
--R
--R         4
--R   (11)  -
--R         3
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 16
imag a
--R 
--R
--R         5
--R   (12)  -
--R         2
--R                                                       Type: Fraction Integer
--E 12

--S 13 of 16
gcd(13 - 13*%i,31 + 27*%i)
--R 
--R
--R   (13)  5 + %i
--R                                                        Type: Complex Integer
--E 13

--S 14 of 16
lcm(13 - 13*%i,31 + 27*%i)
--R 
--R
--R   (14)  143 - 39%i
--R                                                        Type: Complex Integer
--E 14

--S 15 of 16
factor(13 - 13*%i)
--R 
--R
--R   (15)  - (1 + %i)(2 + 3%i)(3 + 2%i)
--R                                               Type: Factored Complex Integer
--E 15

--S 16 of 16
factor complex(2,0)
--R 
--R
--R                      2
--R   (16)  - %i (1 + %i)
--R                                               Type: Factored Complex Integer
--E 16
)spool
)lisp (bye)
@
<<Complex.help>>=
====================================================================
Complex examples
====================================================================

The Complex constructor implements complex objects over a commutative
ring R.  Typically, the ring R is Integer, Fraction Integer, Float or
DoubleFloat.  R can also be a symbolic type, like Polynomial Integer.

Complex objects are created by the complex operation.

  a := complex(4/3,5/2)
   4   5
   - + - %i
   3   2
                        Type: Complex Fraction Integer

  b := complex(4/3,-5/2)
   4   5
   - - - %i
   3   2
                        Type: Complex Fraction Integer

The standard arithmetic operations are available.

  a + b
   8
   -
   3
                        Type: Complex Fraction Integer

  a - b
   5%i
                        Type: Complex Fraction Integer

  a * b
   289
   ---
    36
                        Type: Complex Fraction Integer

If  R is a field, you can also divide the complex objects.

  a / b
     161   240
   - --- + --- %i
     289   289
                        Type: Complex Fraction Integer


We can view the last object as a fraction of complex integers.

  % :: Fraction Complex Integer
   - 15 + 8%i
   ----------
     15 + 8%i
                       Type: Fraction Complex Integer

The predefined macro %i is defined to be complex(0,1).

  3.4 + 6.7 * %i
   3.4 + 6.7 %i
                      Type: Complex Float

You can also compute the conjugate and norm of a complex number.

  conjugate a
   4   5
   - - - %i
   3   2
                      Type: Complex Fraction Integer

  norm a
   289
   ---
    36
                      Type: Fraction Integer

The real and imag operations are provided to extract the real and
imaginary parts, respectively.

  real a
   4
   -
   3
                      Type: Fraction Integer

  imag a
   5
   -
   2
                      Type: Fraction Integer

The domain Complex Integer is also called the Gaussian integers.  If R
is the integers (or, more generally, a EuclideanDomain), you can compute 
greatest common divisors.

  gcd(13 - 13*%i,31 + 27*%i)
   5 + %i
                      Type: Complex Integer

You can also compute least common multiples.

  lcm(13 - 13*%i,31 + 27*%i)
   143 - 39%i
                      Type: Complex Integer

You can factor Gaussian integers.

  factor(13 - 13*%i)
   - (1 + %i)(2 + 3%i)(3 + 2%i)
                      Type: Factored Complex Integer

  factor complex(2,0)
                2
   - %i (1 + %i)
                      Type: Factored Complex Integer

See Also
o )show Complex
o $AXIOM/doc/src/algebra/gaussian.spad.dvi 

@
<<domain COMPLEX Complex>>=
)abbrev domain COMPLEX Complex
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype {Complex(R)} creates the domain of elements of the form
++ \spad{a + b * i} where \spad{a} and b come from the ring R,
++ and i is a new element such that \spad{i**2 = -1}.
Complex(R:CommutativeRing): ComplexCategory(R) with
     if R has OpenMath then OpenMath
   == add
       Rep := Record(real:R, imag:R)

       if R has OpenMath then 
         writeOMComplex(dev: OpenMathDevice, x: %): Void ==
          OMputApp(dev)
          OMputSymbol(dev, "complex1", "complex__cartesian")
          OMwrite(dev, real x)
          OMwrite(dev, imag x)
          OMputEndApp(dev)

         OMwrite(x: %): String ==
          s: String := ""
          sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
          dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
          OMputObject(dev)
          writeOMComplex(dev, x)
          OMputEndObject(dev)
          OMclose(dev)
          s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
          s

         OMwrite(x: %, wholeObj: Boolean): String ==
          s: String := ""
          sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
          dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML)
          if wholeObj then
            OMputObject(dev)
          writeOMComplex(dev, x)
          if wholeObj then
            OMputEndObject(dev)
          OMclose(dev)
          s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
          s

         OMwrite(dev: OpenMathDevice, x: %): Void ==
          OMputObject(dev)
          writeOMComplex(dev, x)
          OMputEndObject(dev)

         OMwrite(dev: OpenMathDevice, x: %, wholeObj: Boolean): Void ==
          if wholeObj then
            OMputObject(dev)
          writeOMComplex(dev, x)
          if wholeObj then
            OMputEndObject(dev)

       0                == [0, 0]
       1                == [1, 0]
       zero? x          == zero?(x.real) and zero?(x.imag)
--       one? x           == one?(x.real) and zero?(x.imag)
       one? x           == ((x.real) = 1) and zero?(x.imag)
       coerce(r:R):%    == [r, 0]
       complex(r, i)   == [r, i]
       real x           == x.real
       imag x           == x.imag
       x + y            == [x.real + y.real, x.imag + y.imag]
                           -- by re-defining this here, we save 5 fn calls
       x:% * y:% ==
         [x.real * y.real - x.imag * y.imag,
          x.imag * y.real + y.imag * x.real] -- here we save nine!


       if R has IntegralDomain then
         _exquo(x:%, y:%) == -- to correct bad defaulting problem
           zero? y.imag => x exquo y.real
           x * conjugate(y) exquo norm(y)

@
\section{package COMPLEX2 ComplexFunctions2}
<<package COMPLEX2 ComplexFunctions2>>=
)abbrev package COMPLEX2 ComplexFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package extends maps from underlying rings to maps between
++   complex over those rings.
ComplexFunctions2(R:CommutativeRing, S:CommutativeRing): with
    map:     (R -> S, Complex R) -> Complex S
      ++ map(f,u) maps f onto real and imaginary parts of u.
 == add
    map(fn, gr) == complex(fn real gr, fn imag gr)

@
\section{package COMPFACT ComplexFactorization}
<<package COMPFACT ComplexFactorization>>=
)abbrev package COMPFACT ComplexFactorization
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: Complex, UnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: complex, polynomial factorization, factor
++ References:
ComplexFactorization(RR,PR) : C == T where
  RR   :    EuclideanDomain   -- R is Z or Q
  PR   :    UnivariatePolynomialCategory Complex RR
  R    ==>  Complex RR
  I    ==>  Integer
  RN   ==>  Fraction I
  GI   ==>  Complex I
  GRN  ==>  Complex RN


  C  == with

     factor        :   PR   ->  Factored PR
       ++ factor(p) factorizes the polynomial p with complex coefficients.

  T  == add
     SUP    ==> SparseUnivariatePolynomial
     fUnion ==> Union("nil", "sqfr", "irred", "prime")
     FF     ==> Record(flg:fUnion, fctr:PR, xpnt:Integer)
     SAEF   :=  SimpleAlgebraicExtensionAlgFactor(SUP RN,GRN,SUP GRN)
     UPCF2  :=  UnivariatePolynomialCategoryFunctions2(R,PR,GRN,SUP GRN)
     UPCFB  :=  UnivariatePolynomialCategoryFunctions2(GRN,SUP GRN,R,PR)

     myMap(r:R) : GRN ==
       R is GI   =>
         cr :GI := r pretend GI
         complex((real cr)::RN,(imag cr)::RN)
       R is GRN  => r pretend GRN

     compND(cc:GRN):Record(cnum:GI,cden:Integer) ==
       ccr:=real cc
       cci:=imag cc
       dccr:=denom ccr
       dcci:=denom cci
       ccd:=lcm(dccr,dcci)
       [complex(((ccd exquo dccr)::Integer)*numer ccr,
                ((ccd exquo dcci)::Integer)*numer cci),ccd]

     conv(f:SUP GRN) :Record(convP:SUP GI, convD:RN) ==
       pris:SUP GI :=0
       dris:Integer:=1
       dris1:Integer:=1
       pdris:Integer:=1
       for i in 0..(degree f) repeat
         (cf:= coefficient(f,i)) = 0 => "next i"
         cdf:=compND cf
         dris:=lcm(cdf.cden,dris1)
         pris:=((dris exquo dris1)::Integer)*pris +
               ((dris exquo cdf.cden)::Integer)*
                 monomial(cdf.cnum,i)$(SUP GI)
         dris1:=dris
       [pris,dris::RN]

     backConv(ffr:Factored SUP GRN) : Factored PR ==
       R is GRN =>
         makeFR((unit ffr) pretend PR,[[f.flg,(f.fctr) pretend PR,f.xpnt]
                                        for f in factorList ffr])
       R is GI  =>
         const:=unit ffr
         ris: List FF :=[]
         for ff in factorList ffr repeat
           fact:=primitivePart(conv(ff.fctr).convP)
           expf:=ff.xpnt
           ris:=cons([ff.flg,fact pretend PR,expf],ris)
           lc:GRN := myMap leadingCoefficient(fact pretend PR)
           const:= const*(leadingCoefficient(ff.fctr)/lc)**expf
         uconst:GI:= compND(coefficient(const,0)).cnum
         makeFR((uconst pretend R)::PR,ris)


     factor(pol : PR)  : Factored PR ==
       ratPol:SUP GRN := 0
       ratPol:=map(myMap,pol)$UPCF2
       ffr:=factor ratPol
       backConv ffr

@
\section{package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation}
<<package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation>>=
)abbrev package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation
++ Author: James Davenport
++ Date Created: 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides the generalized euclidean algorithm which is
++ needed as the basic step for factoring polynomials.
ComplexIntegerSolveLinearPolynomialEquation(R,CR): C == T
 where
  CP ==> SparseUnivariatePolynomial CR
  R:IntegerNumberSystem
  CR:ComplexCategory(R)
  C == with
      solveLinearPolynomialEquation: (List CP,CP) -> Union(List CP,"failed")
                   ++ solveLinearPolynomialEquation([f1, ..., fn], g)
                   ++ where (fi relatively prime to each other)
                   ++ returns a list of ai such that
                   ++ g = sum ai prod fj (j \= i) or
                   ++ equivalently g/prod fj = sum (ai/fi)
                   ++ or returns "failed" if no such list exists
  T == add
      oldlp:List CP := []
      slpePrime:R:=(2::R)
      oldtable:Vector List CP := empty()
      solveLinearPolynomialEquation(lp,p) ==
         if (oldlp ^= lp) then
            -- we have to generate a new table
            deg:= _+/[degree u for u in lp]
            ans:Union(Vector List CP,"failed"):="failed"
            slpePrime:=67108859::R   -- 2**26 -5 : a prime
                 -- a good test case for this package is
                 --  (good question?)
            while (ans case "failed") repeat
              ans:=tablePow(deg,complex(slpePrime,0),lp)$GenExEuclid(CR,CP)
              if (ans case "failed") then
                 slpePrime:=  slpePrime-4::R
                 while not prime?(slpePrime)$IntegerPrimesPackage(R) repeat
                   slpePrime:= slpePrime-4::R
            oldtable:=(ans:: Vector List CP)
         answer:=solveid(p,complex(slpePrime,0),oldtable)
         answer

@
\section{License}
<<license>>=
--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>

<<package COMPLPAT ComplexPattern>>
<<package CPMATCH ComplexPatternMatch>>
<<domain COMPLEX Complex>>
<<package COMPLEX2 ComplexFunctions2>>
<<package COMPFACT ComplexFactorization>>
<<package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
