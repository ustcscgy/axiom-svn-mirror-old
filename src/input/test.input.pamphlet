\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/input test.input}
\author{Scott Morrison, Bill Burge, Robert Sutor, Timothy Daly}
\maketitle
\begin{abstract}
File of recently fixed interpreter bugs
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
<<license>>=
--Copyright The Numerical Algorithms Group Limited 1991.
@
<<*>>=
)spool test.output
)set message test on
)set message auto off
)set break resume

@ 
Eval a polynomial with EXPR substitution values.
Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 1
eq1:= A*x**2 + B*x*y + C*y**2 +D*x + E*y + F
--R 
--R
--R           2                   2
--R   (1)  C y  + (B x + E)y + A x  + D x + F
--R                                                     Type: Polynomial Integer
--E 1

--S 2
eq2:= eval(eq1,[x= xdot*cos(t) - ydot*sin(t), y=xdot*sin(t) + ydot*cos(t)])
--R 
--R
--R   (2)
--R            2                       2       2
--R     (A ydot  - B xdot ydot + C xdot )sin(t)
--R   + 
--R               2                              2
--R     ((- B ydot  + (2C - 2A)xdot ydot + B xdot )cos(t) - D ydot + E xdot)sin(t)
--R   + 
--R            2                       2       2
--R     (C ydot  + B xdot ydot + A xdot )cos(t)  + (E ydot + D xdot)cos(t) + F
--R                                                     Type: Expression Integer
--E 2

@
UTS coercions.  Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 3
taylor exp x
--R 
--R
--R   (1)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                         Type: UnivariateTaylorSeries(Expression Integer,x,0)
--E 3

--S 4
s := %
--R 
--R
--R   (2)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                         Type: UnivariateTaylorSeries(Expression Integer,x,0)
--E 4

--S 5
s::(UTS(EXPR FLOAT, x, 0))
--R 
--R
--R   (3)
--R                    2                            3
--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
--R   + 
--R                                4                               5
--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
--R   + 
--R                                 6                               7
--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
--R   + 
--R                                   8                                  9
--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
--R   + 
--R                                   10      11
--R     0.2755731922 3985890653 E -6 x   + O(x  )
--R                         Type: UnivariateTaylorSeries(Expression Float,x,0.0)
--E 5

--S 6
s::(UTS(FLOAT, x, 0))
--R 
--R
--R   (4)
--R                    2                            3
--R     1.0 + x + 0.5 x  + 0.1666666666 6666666667 x
--R   + 
--R                                4                               5
--R     0.0416666666 6666666666 7 x  + 0.0083333333 3333333333 34 x
--R   + 
--R                                 6                               7
--R     0.0013888888 8888888888 89 x  + 0.0001984126 9841269841 27 x
--R   + 
--R                                   8                                  9
--R     0.0000248015 8730158730 1587 x  + 0.0000027557 3192239858 90653 x
--R   + 
--R                                   10      11
--R     0.2755731922 3985890653 E -6 x   + O(x  )
--R                                    Type: UnivariateTaylorSeries(Float,x,0.0)
--E 6

--S 7
eval(s,1)
--R 
--R
--R             5 8 65 163 1957 685 109601 98641
--R   (5)  [1,2,-,-,--,---,----,---,------,-----,...]
--R             2 3 24  60  720 252  40320 36288
--R                                              Type: Stream Expression Integer
--E 7

--S 8
%::(Stream Float)
--R 
--R
--R   (6)
--R   [1.0, 2.0, 2.5, 2.6666666666 666666667, 2.7083333333 333333333,
--R    2.7166666666 666666667, 2.7180555555 555555556, 2.7182539682 53968254,
--R    2.7182787698 412698413, 2.7182815255 731922399, ...]
--R                                                           Type: Stream Float
--E 8

@
Another bug, fixed by adding UPXS2 package,
<<*>>=
)clear all

--S 9
s := series(sin(a*x),x=0)
--R 
--R
--R               3        5        7          9            11
--R              a   3    a   5    a    7     a     9      a      11      12
--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
--R               6      120      5040      362880      39916800
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 9

--S 10
eval(s, 1.0)
--R 
--R
--R   (2)
--R                                          3
--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
--R                               3
--R    - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                      9                               7
--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
--R     + 
--R                                   5                            3
--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
--R     ,
--R    ...]
--R                                                Type: Stream Expression Float
--E 10

--S 11
s - a*x
--R 
--R
--R   (3)
--R        3        5        7          9            11              13
--R       a   3    a   5    a    7     a     9      a      11       a       13
--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
--R        6      120      5040      362880      39916800       6227020800
--R   + 
--R        14
--R     O(x  )
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 11

@
Grand finale, just fixed on 3/23/91
<<*>>=

--S 12
eval(s, 1.0)
--R 
--R
--R   (4)
--R                                          3
--R   [0.0, a, a, - 0.1666666666 6666666667 a  + a,
--R                               3
--R    - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R                                5                            3
--R    0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                     7                               5
--R       - 0.0001984126 9841269841 27 a  + 0.0083333333 3333333333 34 a
--R     + 
--R                                  3
--R       - 0.1666666666 6666666667 a  + a
--R     ,
--R
--R                                      9                               7
--R       0.0000027557 3192239858 90653 a  - 0.0001984126 9841269841 27 a
--R     + 
--R                                   5                            3
--R       0.0083333333 3333333333 34 a  - 0.1666666666 6666666667 a  + a
--R     ,
--R    ...]
--R                                                Type: Stream Expression Float
--E 12

@
Generalized resolve. Fixed (enhanced) by SCM in 3/23/91
<<*>>=
)clear all

--S 13
v := vector [1,2,3]
--R 
--R
--R   (1)  [1,2,3]
--R                                                 Type: Vector PositiveInteger
--E 13

--S 14
(1/2)*v
--R 
--R
--R         1   3
--R   (2)  [-,1,-]
--R         2   2
--R                                                Type: Vector Fraction Integer
--E 14

--S 15
eval(x**2, x=1/2)
--R 
--R
--R        1
--R   (3)  -
--R        4
--R                                            Type: Polynomial Fraction Integer
--E 15

--S 16
eval(x**2, x=0.5)
--R 
--R
--R   (4)  0.25
--R                                                       Type: Polynomial Float
--E 16

--S 17
eval(3**x, x=0.5)
--R 
--R
--R   (5)  1.7320508075 688772935
--R                                                       Type: Expression Float
--E 17

@
Overloading interpreter maps on arity. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 18
f(x) == x+1
--R 
--R                                                                   Type: Void
--E 18

--S 19
f(x,y) == x+y
--R 
--R                                                                   Type: Void
--E 19

--S 20
f 3
--R 
--R   Compiling function f with type PositiveInteger -> PositiveInteger 
--R
--R   (3)  4
--R                                                        Type: PositiveInteger
--E 20

--S 21
f(3,4)
--R 
--R   Compiling function f with type (PositiveInteger,PositiveInteger) -> 
--R      PositiveInteger 
--R
--R   (4)  7
--R                                                        Type: PositiveInteger
--E 21

--S 22
f(5)
--R 
--R
--R   (5)  6
--R                                                        Type: PositiveInteger
--E 22

--S 23
f(1,x)
--R 
--R   Compiling function f with type (PositiveInteger,Variable x) -> 
--R      Polynomial Integer 
--R
--R   (6)  x + 1
--R                                                     Type: Polynomial Integer
--E 23

@
Targetted function requiring a coercion. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 24
series(n +-> bernoulli(n)/factorial(n), t=0)
--R 
--R
--R   (1)
--R       1      1  2    1   4     1    6      1     8       1     10      11
--R   1 - - t + -- t  - --- t  + ----- t  - ------- t  + -------- t   + O(t  )
--R       2     12      720      30240      1209600      47900160
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,t,0)
--E 24

@
In-homogeneous list mapping. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 25
l := [1,2,-1]
--R 
--R
--R   (1)  [1,2,- 1]
--R                                                           Type: List Integer
--E 25

--S 26
f : INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 26

--S 27
f x == x
--R 
--R                                                                   Type: Void
--E 27

--S 28
map(f, l)
--R 
--R   Compiling function f with type Integer -> Fraction Integer 
--R
--R   (4)  [1,2,- 1]
--R                                                  Type: List Fraction Integer
--E 28

@
Function args to interpreter functions. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 29
f: INT -> INT
--R 
--R                                                                   Type: Void
--E 29

--S 30
f x == x+1
--R 
--R                                                                   Type: Void
--E 30

--S 31
u g == g 3
--R 
--R                                                                   Type: Void
--E 31

--S 32
u f
--R 
--R   Compiling function u with type (Integer -> Integer) -> Integer 
--R   Compiling function f with type Integer -> Integer 
--R
--R   (4)  4
--R                                                        Type: PositiveInteger
--E 32

@
Category modemap requiring a field to be constructed.
Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 33
groebner [x**2 - y, y**3+1]
--R 
--R
--R              2  6
--R   (1)  [y - x ,x  + 1]
--R                                                Type: List Polynomial Integer
--E 33

@
Operations requiring polynomials, passed variables.
Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

--S 34
factor x
--R 
--R
--R   (1)  x
--R                                            Type: Factored Polynomial Integer
--E 34

--draw(x, x=-1..1)

@
Bracket parsing and empty-set types. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

@
--S 35
{}$(List INT)
--R 
--RDaly Bug
--R   The function SEQ is not implemented in List Integer .
--E 35

--S 36
brace []  -- {}
--R
--R   (1)  {}
--R                                                               Type: Set None
--E 36

--S 37
brace [1] -- {1}
--R
--R   (2)  {1}
--R                                                    Type: Set PositiveInteger
--E 37

--S 38
union(brace [], brace [1,2])   -- union({}, {1,2})
--R
--R   (3)  {1,2}
--R                                                    Type: Set PositiveInteger
--E 38

@
Shouldn't work, but no longer bombs the interpreter.
Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

)set mes test off

--S 39
map(variable, [x,y])
--R 
--R
--R   (1)  [x,y]
--R                         Type: List Union(OrderedVariableList [x,y],"failed")
--E 39

)set mes test on

@
Recursive map type analysis bug. Fixed by SCM, verified on 10/30/90
<<*>>=
)clear all

)set fun recur off

--S 40
p(n,x) == if n=0 then 1 else (x+n-1)*p(n-1,x)
--R 
--R                                                                   Type: Void
--E 40

--S 41
pp(n,x) == if n=0 then 1 else if n<0 then (-1)**n/p(-n,1-x) else p(n,x)
--R 
--R                                                                   Type: Void
--E 41

--S 42
pp(-1,x) -- should be 1/(x-1)
--R 
--R   Compiling function p with type (Integer,Polynomial Integer) -> 
--R      Polynomial Integer 
--R   Compiling function p with type (Integer,Variable x) -> Polynomial 
--R      Integer 
--R   Compiling function pp with type (Integer,Variable x) -> Fraction 
--R      Polynomial Fraction Integer 
--R
--R          1
--R   (3)  -----
--R        x - 1
--R                                   Type: Fraction Polynomial Fraction Integer
--E 42

@
Interpret-code mode for iterators is broken
<<*>>=
)clear all

--S 43
f n ==
  for i in 1..n repeat
    j:=2*i
    m:SQMATRIX(j,?):=1
    print m
--R 
--R                                                                   Type: Void
--E 43

--S 44
g n ==
    j:=2*n
    m:SQMATRIX(j,?):=1
    print m
--R 
--R                                                                   Type: Void
--E 44

--S 45
g 3
--R 
--R   Cannot compile the declaration for m because its (possible partial) 
--R      type contains a local variable.
--R   AXIOM will attempt to step through and interpret the code.
--R   +1  0  0  0  0  0+
--R   |                |
--R   |0  1  0  0  0  0|
--R   |                |
--R   |0  0  1  0  0  0|
--R   |                |
--R   |0  0  0  1  0  0|
--R   |                |
--R   |0  0  0  0  1  0|
--R   |                |
--R   +0  0  0  0  0  1+
--R                                                                   Type: Void
--E 45

--S 46
f 3
--R 
--R   Cannot compile the declaration for m because its (possible partial) 
--R      type contains a local variable.
--R   AXIOM will attempt to step through and interpret the code.
--R   +1  0+
--R   |    |
--R   +0  1+
--R   +1  0  0  0+
--R   |          |
--R   |0  1  0  0|
--R   |          |
--R   |0  0  1  0|
--R   |          |
--R   +0  0  0  1+
--R   +1  0  0  0  0  0+
--R   |                |
--R   |0  1  0  0  0  0|
--R   |                |
--R   |0  0  1  0  0  0|
--R   |                |
--R   |0  0  0  1  0  0|
--R   |                |
--R   |0  0  0  0  1  0|
--R   |                |
--R   +0  0  0  0  0  1+
--R                                                                   Type: Void
--E 46

@
Test interpreter list destructuring
<<*>>=
)clear all

--S 47
mp(x,l) ==
  l is [a,:b] =>
    a*x**(#b)+ mp(x,b)
  0
--R 
--R                                                                   Type: Void
--E 47

--S 48
mp(x, [1,3,4, 2])
--R 
--R   Compiling function mp with type (Variable x,List PositiveInteger)
--R       -> Polynomial Integer 
--R
--R         3     2
--R   (2)  x  + 3x  + 4x + 2
--R                                                     Type: Polynomial Integer
--E 48

--S 49
mp(x, [1,2,-3, 4])
--R 
--R   Compiling function mp with type (Variable x,List Integer) -> 
--R      Polynomial Integer 
--R
--R         3     2
--R   (3)  x  + 2x  - 3x + 4
--R                                                     Type: Polynomial Integer
--E 49

@
Tests compilation of recursive functions
<<*>>=
)clear all

--S 50
f1 n ==
  if n=0 then 1 else if n=1 then 1 else f1(n-1)+f1(n-2)
--R 
--R                                                                   Type: Void
--E 50

--S 51
f2 n ==
  m:=n
  if n=0 then 1 else if n=1 then 1 else f2(n-1)+f2(n-2)
--R 
--R                                                                   Type: Void
--E 51

--S 52
f3 n ==
  n=0 => 1
  n=1 => 1
  f3(n-1)+f3(n-2)
--R 
--R                                                                   Type: Void
--E 52

--S 53
f4 n ==
  m:=n
  n=0 => 1
  n=1 => 1
  m:=n
  f4(n-1)+f4(n-2)
--R 
--R                                                                   Type: Void
--E 53

--S 54
f5 n == if n=0 or n=1 then 1 else f5(n-1)+f5(n-2)
--R 
--R                                                                   Type: Void
--E 54

--S 55
[f1 3,f2 3, f3 3,f4 3,f5 3]
--R 
--R   Compiling function f1 with type Integer -> PositiveInteger 
--R   Compiling function f2 with type Integer -> PositiveInteger 
--R   Compiling function f3 with type Integer -> PositiveInteger 
--R   Compiling function f4 with type Integer -> PositiveInteger 
--R   Compiling function f5 with type Integer -> PositiveInteger 
--R
--R   (6)  [3,3,3,3,3]
--R                                                   Type: List PositiveInteger
--E 55

@
Input of GDMP types. Fixed by SCM on 1/22/91
<<*>>=
)clear all

--S 56
g: GDMP([x,y], INT, DIRPROD(2, NNI)) := x**2 + y
--R 
--R
--R         2
--R   (1)  x  + y
--RType: GeneralDistributedMultivariatePolynomial([x,y],Integer,DirectProduct(2,NonNegativeInteger))
--E 56

@
Has test with variables. Fixed by SCM on 1/22/91
<<*>>=
)clear all

--S 57
i := INT
--R 
--R
--R   (1)  Integer
--R                                                                 Type: Domain
--E 57

--S 58
i has Algebra(i)
--R 
--R
--R   (2)  true
--R                                                                Type: Boolean
--E 58

@
Returns in functions. Fixed by SCM on 1/22/91
<<*>>=
)clear all

--S 59
f x == if x<0 then return x else x+1
--R 
--R                                                                   Type: Void
--E 59

--S 60
f 2 -- should be 3
--R 
--R   Compiling function f with type PositiveInteger -> PositiveInteger 
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 60

--S 61
f(-2) -- should be -2
--R 
--R   Compiling function f with type Integer -> Integer 
--R
--R   (3)  - 2
--R                                                                Type: Integer
--E 61

@
resolveTT not returning Any. Fixed by SCM 1/30/91
<<*>>=
)clear all

--S 62
m = [[1,2],[2,3]]  -- Should return type EQ POLY SQMATRIX(2, INT)
--R 
--R
--R           +1  2+
--R   (1)  m= |    |
--R           +2  3+
--R                            Type: Equation Polynomial SquareMatrix(2,Integer)
--E 62

--S 63
[1, "asd"]   -- Should be of type List Any
--R 
--R
--R   (2)  [1,"asd"]
--R                                                               Type: List Any
--E 63

)set mes test off

--S 64
1+"asd"  -- These should both fail in the same way
--R 
--R   There are 11 exposed and 5 unexposed library operations named + 
--R      having 2 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                                )display op +
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named + 
--R      with argument type(s) 
--R                               PositiveInteger
--R                                   String
--R      
--R      Perhaps you should use "@" to indicate the required return type, 
--R      or "$" to specify which version of the function you need.
--E 64

--S 65
1/"asd"
--R 
--R   There are 12 exposed and 12 unexposed library operations named / 
--R      having 2 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                                )display op /
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named / 
--R      with argument type(s) 
--R                               PositiveInteger
--R                                   String
--R      
--R      Perhaps you should use "@" to indicate the required return type, 
--R      or "$" to specify which version of the function you need.
--E 65

)set mes test on

@
Passing type variables to )show
<<*>>=
)clear all

--S 66
t := MPOLY([x,y], INT)
--R 
--R
--R   (1)  MultivariatePolynomial([x,y],Integer)
--R                                                                 Type: Domain
--E 66

--S 67
)show t
--R 
--R MultivariatePolynomial([x,y],Integer) is a domain constructor.
--R Abbreviation for MultivariatePolynomial is MPOLY 
--R This constructor is exposed in this frame.
--R Issue )edit multpoly.spad.pamphlet to see algebra source code for MPOLY 
--R
--R------------------------------- Operations --------------------------------
--R
--R ?*? : (Fraction Integer,%) -> %       ?*? : (Integer,%) -> %
--R ?*? : (PositiveInteger,%) -> %        ?*? : (%,Fraction Integer) -> %
--R ?*? : (%,Integer) -> %                ?*? : (%,%) -> %
--R ?**? : (%,PositiveInteger) -> %       ?+? : (%,%) -> %
--R ?-? : (%,%) -> %                      -? : % -> %
--R ?/? : (%,Integer) -> %                ?<? : (%,%) -> Boolean
--R ?<=? : (%,%) -> Boolean               ?=? : (%,%) -> Boolean
--R ?>? : (%,%) -> Boolean                ?>=? : (%,%) -> Boolean
--R 1 : () -> %                           0 : () -> %
--R ?^? : (%,PositiveInteger) -> %        associates? : (%,%) -> Boolean
--R coefficients : % -> List Integer      coerce : % -> OutputForm
--R coerce : Fraction Integer -> %        coerce : Integer -> %
--R coerce : % -> %                       content : % -> Integer
--R convert : % -> InputForm              convert : % -> Pattern Float
--R convert : % -> Pattern Integer        eval : (%,Equation %) -> %
--R eval : (%,List Equation %) -> %       eval : (%,List %,List %) -> %
--R eval : (%,%,%) -> %                   factor : % -> Factored %
--R gcd : List % -> %                     gcd : (%,%) -> %
--R ground : % -> Integer                 ground? : % -> Boolean
--R hash : % -> SingleInteger             latex : % -> String
--R lcm : List % -> %                     lcm : (%,%) -> %
--R leadingCoefficient : % -> Integer     leadingMonomial : % -> %
--R max : (%,%) -> %                      min : (%,%) -> %
--R monomial? : % -> Boolean              monomials : % -> List %
--R one? : % -> Boolean                   prime? : % -> Boolean
--R primitiveMonomials : % -> List %      primitivePart : % -> %
--R recip : % -> Union(%,"failed")        reductum : % -> %
--R retract : % -> Fraction Integer       retract : % -> Integer
--R sample : () -> %                      squareFree : % -> Factored %
--R squareFreePart : % -> %               unit? : % -> Boolean
--R unitCanonical : % -> %                zero? : % -> Boolean
--R ?~=? : (%,%) -> Boolean              
--R ?*? : (NonNegativeInteger,%) -> %
--R ?**? : (%,NonNegativeInteger) -> %
--R D : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
--R D : (%,List OrderedVariableList [x,y]) -> %
--R D : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
--R D : (%,OrderedVariableList [x,y]) -> %
--R ?^? : (%,NonNegativeInteger) -> %
--R binomThmExpt : (%,%,NonNegativeInteger) -> %
--R characteristic : () -> NonNegativeInteger
--R charthRoot : % -> Union(%,"failed")
--R coefficient : (%,IndexedExponents OrderedVariableList [x,y]) -> Integer
--R coefficient : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
--R coefficient : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
--R coerce : OrderedVariableList [x,y] -> %
--R conditionP : Matrix % -> Union(Vector %,"failed")
--R content : (%,OrderedVariableList [x,y]) -> %
--R degree : % -> IndexedExponents OrderedVariableList [x,y]
--R degree : (%,List OrderedVariableList [x,y]) -> List NonNegativeInteger
--R degree : (%,OrderedVariableList [x,y]) -> NonNegativeInteger
--R differentiate : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
--R differentiate : (%,List OrderedVariableList [x,y]) -> %
--R differentiate : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
--R differentiate : (%,OrderedVariableList [x,y]) -> %
--R discriminant : (%,OrderedVariableList [x,y]) -> %
--R eval : (%,List OrderedVariableList [x,y],List Integer) -> %
--R eval : (%,List OrderedVariableList [x,y],List %) -> %
--R eval : (%,OrderedVariableList [x,y],Integer) -> %
--R eval : (%,OrderedVariableList [x,y],%) -> %
--R exquo : (%,Integer) -> Union(%,"failed")
--R exquo : (%,%) -> Union(%,"failed")
--R factorPolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
--R factorSquareFreePolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
--R gcdPolynomial : (SparseUnivariatePolynomial %,SparseUnivariatePolynomial %) -> SparseUnivariatePolynomial %
--R isExpt : % -> Union(Record(var: OrderedVariableList [x,y],exponent: NonNegativeInteger),"failed")
--R isPlus : % -> Union(List %,"failed")
--R isTimes : % -> Union(List %,"failed")
--R mainVariable : % -> Union(OrderedVariableList [x,y],"failed")
--R map : ((Integer -> Integer),%) -> %
--R mapExponents : ((IndexedExponents OrderedVariableList [x,y] -> IndexedExponents OrderedVariableList [x,y]),%) -> %
--R minimumDegree : % -> IndexedExponents OrderedVariableList [x,y]
--R minimumDegree : (%,List OrderedVariableList [x,y]) -> List NonNegativeInteger
--R minimumDegree : (%,OrderedVariableList [x,y]) -> NonNegativeInteger
--R monicDivide : (%,%,OrderedVariableList [x,y]) -> Record(quotient: %,remainder: %)
--R monomial : (Integer,IndexedExponents OrderedVariableList [x,y]) -> %
--R monomial : (%,List OrderedVariableList [x,y],List NonNegativeInteger) -> %
--R monomial : (%,OrderedVariableList [x,y],NonNegativeInteger) -> %
--R multivariate : (SparseUnivariatePolynomial Integer,OrderedVariableList [x,y]) -> %
--R multivariate : (SparseUnivariatePolynomial %,OrderedVariableList [x,y]) -> %
--R numberOfMonomials : % -> NonNegativeInteger
--R patternMatch : (%,Pattern Float,PatternMatchResult(Float,%)) -> PatternMatchResult(Float,%)
--R patternMatch : (%,Pattern Integer,PatternMatchResult(Integer,%)) -> PatternMatchResult(Integer,%)
--R pomopo! : (%,Integer,IndexedExponents OrderedVariableList [x,y],%) -> %
--R primitivePart : (%,OrderedVariableList [x,y]) -> %
--R reducedSystem : Matrix % -> Matrix Integer
--R reducedSystem : (Matrix %,Vector %) -> Record(mat: Matrix Integer,vec: Vector Integer)
--R resultant : (%,%,OrderedVariableList [x,y]) -> %
--R retract : % -> OrderedVariableList [x,y]
--R retractIfCan : % -> Union(Fraction Integer,"failed")
--R retractIfCan : % -> Union(Integer,"failed")
--R retractIfCan : % -> Union(OrderedVariableList [x,y],"failed")
--R solveLinearPolynomialEquation : (List SparseUnivariatePolynomial %,SparseUnivariatePolynomial %) -> Union(List SparseUnivariatePolynomial %,"failed")
--R squareFreePolynomial : SparseUnivariatePolynomial % -> Factored SparseUnivariatePolynomial %
--R subtractIfCan : (%,%) -> Union(%,"failed")
--R totalDegree : (%,List OrderedVariableList [x,y]) -> NonNegativeInteger
--R totalDegree : % -> NonNegativeInteger
--R unitNormal : % -> Record(unit: %,canonical: %,associate: %)
--R univariate : % -> SparseUnivariatePolynomial Integer
--R univariate : (%,OrderedVariableList [x,y]) -> SparseUnivariatePolynomial %
--R variables : % -> List OrderedVariableList [x,y]
--R
--R
--E 67

@
Caching nullary functions
<<*>>=
)clear all

--S 68
)set fun cache all
--R 
--R   In general, interpreter functions will cache all values.
--E 68

--S 69
u == 1
--R 
--R                                                                   Type: Void
--E 69

--S 70
u
--R 
--R   Compiling body of rule u to compute value of type PositiveInteger 
--R   u will cache all previously computed values.
--R
--R   (2)  1
--R                                                        Type: PositiveInteger
--E 70

--S 71
)set fun cache 0
--R 
--R In general, functions will cache no returned values.
--E 71

@
Interpreter Only mode on collects. Fixed by SCM on 3/1/91
<<*>>=
)clear all

--S 72
factorp: (UP(x,INT),PositiveInteger,PositiveInteger) -> List(UP(x,INT))
--R 
--R                                                                   Type: Void
--E 72

--S 73
factorp(poly,p,e) ==
   ppoly:UP(x,PF p):=poly
   pl := [rec.factor for rec in factors factor ppoly]
   facl:=pl::List(UP(x,INT))
--R 
--R                                                                   Type: Void
--E 73

--S 74
factorp(x**2+x+5,7,1)
--R 
--R   Cannot compile the declaration for ppoly because its (possible 
--R      partial) type contains a local variable.
--R   AXIOM will attempt to step through and interpret the code.
--R   Compiling function factorp with type (UnivariatePolynomial(x,Integer
--R      ),PositiveInteger,PositiveInteger) -> List UnivariatePolynomial(x
--R      ,Integer) 
--R
--R   (3)  [x + 2,x + 6]
--R                                   Type: List UnivariatePolynomial(x,Integer)
--E 74

@
Using "by" with segments. Fixed by SCM on 2/14/91
<<*>>=
)clear all

--S 75
b:= 1..10
--R 
--R
--R   (1)  1..10
--R                                                Type: Segment PositiveInteger
--E 75

--S 76
for i in b by 2 repeat output i
--R 
--R   1
--R   3
--R   5
--R   7
--R   9
--R                                                                   Type: Void
--E 76

@
DMP resolve bug. Fixed by SCM 3/7/91
<<*>>=
)clear all

--S 77
macro RN == FRAC INT
--R 
--R                                                                   Type: Void
--E 77

--S 78
a51:=x+y+z+t+u;
--R 
--R
--R                                                     Type: Polynomial Integer
--E 78

--S 79
a52:=x*y+y*z+z*t+x*u+t*u;
--R 
--R
--R                                                     Type: Polynomial Integer
--E 79

--S 80
a53:=x*y*z+y*z*t+x*y*u+x*t*u+z*t*u;
--R 
--R
--R                                                     Type: Polynomial Integer
--E 80

--S 81
a54:=x*y*z*t+x*y*z*u+x*y*t*u+x*z*t*u+y*z*t*u;
--R 
--R
--R                                                     Type: Polynomial Integer
--E 81

--S 82
a55:=x*y*z*t*u-1;
--R 
--R
--R                                                     Type: Polynomial Integer
--E 82

--S 83
arnborg5: List HDMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
--R 
--R
--RType: List HomogeneousDistributedMultivariatePolynomial([x,y,z,t,u],Fraction Integer)
--E 83

--S 84
arnborg5l: List DMP([x,y,z,t,u],RN):=[a51,a52,a53,a54,a55];
--R 
--R
--R   Type: List DistributedMultivariatePolynomial([x,y,z,t,u],Fraction Integer)
--E 84

@
Construct in interpret-only mode. Fixed by SCM on 3/7/91
<<*>>=
)clear all

--S 85
factorp(poly,p,e) ==
   [rec.factor for rec in factors factor (poly::UP(x, PF p))]::List UP(x, INT)
--R 
--R                                                                   Type: Void
--E 85

--S 86
factorp(x**2+x+5,7,1)
--R 
--R   Cannot compile conversion for types involving local variables. In 
--R      particular, could not compile the expression involving :: UP(x,PF
--R      #2) 
--R   AXIOM will attempt to step through and interpret the code.
--R
--R   (2)  [x + 2,x + 6]
--R                                   Type: List UnivariatePolynomial(x,Integer)
--E 86

@
Return in interpret-only mode. fixed by SCM 3/11/91
<<*>>=
)clear all

--S 87
f (x) ==
  y: PF x := 1
  x = 3 => return x
  x = 4 => return(-x)
  (x+1)
--R 
--R                                                                   Type: Void
--E 87

--S 88
f 3
--R 
--R   Cannot compile the declaration for y because its (possible partial) 
--R      type contains a local variable.
--R   AXIOM will attempt to step through and interpret the code.
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 88

@
Incorrect handling of type of returns. fixed by SCM 3/11/91
<<*>>=
)clear all

--S 89
f (x) ==
  x = 3 => return x
  x = 4 => return(-x)
  return (x+1)
--R 
--R                                                                   Type: Void
--E 89

--S 90
f 3
--R 
--R   Compiling function f with type PositiveInteger -> Integer 
--R
--R   (2)  3
--R                                                        Type: PositiveInteger
--E 90

@
SquareMatrix coercion bug. Fixed by SCM on 4/3/91
<<*>>=
)clear all

--S 91
s:SQMATRIX(2, INT) := matrix [[1,2],[2,3]]
--R 
--R
--R        +1  2+
--R   (1)  |    |
--R        +2  3+
--R                                                Type: SquareMatrix(2,Integer)
--E 91

--S 92
s::SQMATRIX(2, FRAC INT)
--R 
--R
--R        +1  2+
--R   (2)  |    |
--R        +2  3+
--R                                       Type: SquareMatrix(2,Fraction Integer)
--E 92

@
SquareMatric resolve bug
<<*>>=
)clear all

--S 93
Mat := SquareMatrix(2, Polynomial Integer)
--R 
--R
--R   (1)  SquareMatrix(2,Polynomial Integer)
--R                                                                 Type: Domain
--E 93

--S 94
s:Mat := matrix [[ 2*x + 1, x], [x, 1]]
--R 
--R
--R        +2x + 1  x+
--R   (2)  |         |
--R        +  x     1+
--R                                     Type: SquareMatrix(2,Polynomial Integer)
--E 94

--S 95
s**3
--R 
--R
--R        +   3      2             3     2     +
--R        |12x  + 15x  + 6x + 1  5x  + 6x  + 3x|
--R   (3)  |                                    |
--R        |     3     2            3     2     |
--R        +   5x  + 6x  + 3x     2x  + 3x  + 1 +
--R                                     Type: SquareMatrix(2,Polynomial Integer)
--E 95

--S 96
%::Polynomial(?)
--R 
--R
--R        +12  5+ 3   +15  6+ 2   +6  3+    +1  0+
--R   (4)  |     |x  + |     |x  + |    |x + |    |
--R        +5   2+     +6   3+     +3  0+    +0  1+
--R                                     Type: Polynomial SquareMatrix(2,Integer)
--E 96

@
Parsing bug. Fixed by BURGE on 4/18/91
<<*>>=
)clear all

--S 97
-2**2  -- Should return -4
--R 
--R
--R   (1)  - 4
--R                                                                Type: Integer
--E 97

@
\# in constructor arguemnt list bug. Fixed by SCM on 4/9/91
<<*>>=
)clear all

--S 98
f: DMP([x,y], INT) := x**2-y**2
--R 
--R
--R         2    2
--R   (1)  x  - y
--R                       Type: DistributedMultivariatePolynomial([x,y],Integer)
--E 98

--S 99
coefficient(f, degree f)
--R 
--R
--R   (2)  1
--R                                                        Type: PositiveInteger
--E 99

@
Retract from EXPR to POLY. fixed by SCM and SUTOR on 5/1/91
<<*>>=
)clear all

--S 100
x+1::EXPR INT
--R 
--R
--R   (1)  x + 1
--R                                                     Type: Expression Integer
--E 100

--S 101
%::POLY INT
--R 
--R
--R   (2)  x + 1
--R                                                     Type: Polynomial Integer
--E 101

@
Fixed by SCM in May
<<*>>=
)clear all

--S 102
solve([[1,2],[2,3]],[-2,3])
--R 
--R
--R   (1)  [particular= [12,- 7],basis= [[0,0]]]
--RType: Record(particular: Union(Vector Fraction Integer,"failed"),basis: List Vector Fraction Integer)
--E 102

@
Fixed by several people over a period of time
<<*>>=
)clear all

--S 103
eval(m**2, m=[[1,2],[2,3]])
--R 
--R
--R        +5  8 +
--R   (1)  |     |
--R        +8  13+
--R                                     Type: Polynomial SquareMatrix(2,Integer)
--E 103

@
Filtering various illegal declarations
<<*>>=
)clear all

)set mes test off

--S 104
r: Ring
--R 
--R 
--R   Ring is a category, not a domain, and declarations require domains.
--E 104

--S 105
w: RF INT
--R 
--R 
--R   RationalFunction Integer is a package, not a domain, and 
--R      declarations require domains.
--E 105

)set mes test on

@
Correct representation of length 1 records
<<*>>=
)clear all

--S 106
r:Record(a: INT) := [1]
--R 
--R
--R   (1)  [a= 1]
--R                                                     Type: Record(a: Integer)
--E 106

@
Fast generation of POLY FLOAT graphics code
<<*>>=
)clear all

--S 107
p: POLY FLOAT := (x-1)**30
--R 
--R
--R   (1)
--R      30         29          28           27            26             25
--R     x   - 30.0 x   + 435.0 x   - 4060.0 x   + 27405.0 x   - 142506.0 x
--R   + 
--R               24              23              22               21
--R     593775.0 x   - 2035800.0 x   + 5852925.0 x   - 14307150.0 x
--R   + 
--R                 20               19               18                 17
--R     30045015.0 x   - 54627300.0 x   + 86493225.0 x   - 1 19759850.0 x
--R   + 
--R                   16                 15                 14                 13
--R     1 45422675.0 x   - 1 55117520.0 x   + 1 45422675.0 x   - 1 19759850.0 x
--R   + 
--R                 12               11               10               9
--R     86493225.0 x   - 54627300.0 x   + 30045015.0 x   - 14307150.0 x
--R   + 
--R                8              7             6             5            4
--R     5852925.0 x  - 2035800.0 x  + 593775.0 x  - 142506.0 x  + 27405.0 x
--R   + 
--R               3          2
--R     - 4060.0 x  + 435.0 x  - 30.0 x + 1.0
--R                                                       Type: Polynomial Float
--E 107

--draw(p, x=-1..1)

@
Case broken in interpreter. fixed by SCM in early 1991
<<*>>=
)clear all

--S 108
sayBranch x == _
 if x case INT then output "Integer Branch" _
 else if x case STRING then output "String Branch" _
 else if x case FLOAT then output "Float Branch" _
 else output "don't know"
--R 
--R                                                                   Type: Void
--E 108

--S 109
x:Union(INT,STRING,FLOAT)
--R 
--R                                                                   Type: Void
--E 109

--S 110
x:=3
--R 
--R
--R   (3)  3
--R                                                     Type: Union(Integer,...)
--E 110

--S 111
sayBranch(x)
--R 
--R 
--RDaly Bug
--R   case is only used for Unions and the object on the left-hand side 
--R      does not belong to a union.
--E 111

@
Bug in evaluateType. fixed by SCM in May 1991
<<*>>=
)clear all

--S 112
RFI := FRAC POLY INT
--R 
--R
--R   (1)  Fraction Polynomial Integer
--R                                                                 Type: Domain
--E 112

--S 113
g:DMP([x,y], RFI) := a**2*x**2/b**2 - c**2*y**2/d**2
--R 
--R
--R         2       2
--R        a   2   c   2
--R   (2)  -- x  - -- y
--R         2       2
--R        b       d
--R   Type: DistributedMultivariatePolynomial([x,y],Fraction Polynomial Integer)
--E 113

--S 114
factor g
--R 
--R
--R         2
--R        a       b c        b c
--R   (3)  -- (x - --- y)(x + --- y)
--R         2      a d        a d
--R        b
--RType: Factored DistributedMultivariatePolynomial([x,y],Fraction Polynomial Integer)
--E 114

@
Bug in resolveTTSpecial. Fixed by SCM 6/2/91
<<*>>=
)clear all

--S 115
f(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+v
--R 
--R   Function declaration f : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 115

--S 116
g(u:DoubleFloat, v:DoubleFloat):DoubleFloat == sin(u+v)
--R 
--R   Function declaration g : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 116

--S 117
h(u:DoubleFloat, v:DoubleFloat):DoubleFloat == u+cos(v)
--R 
--R   Function declaration h : (DoubleFloat,DoubleFloat) -> DoubleFloat 
--R      has been added to workspace.
--R                                                                   Type: Void
--E 117

--draw(surface(f,g,h), 0..4, 0..2*%pi)

@
Check for package calling from categories. fixed by SCM 6/4/91
<<*>>=
)clear all

)set mes test off

--S 118
(1+1)$Ring
--R 
--R 
--R   The right-hand side of the $ operator must be a package or domain 
--R      name, but Ring is a category.
--E 118

)set mes test on

@
UnivariateSeries coercions. Fixed by SCM 6/20/91
<<*>>=
)clear all

--S 119
s := series(sin(a*x), x=0)
--R 
--R
--R               3        5        7          9            11
--R              a   3    a   5    a    7     a     9      a      11      12
--R   (1)  a x - -- x  + --- x  - ---- x  + ------ x  - -------- x   + O(x  )
--R               6      120      5040      362880      39916800
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 119

--S 120
s - a*x
--R 
--R
--R   (2)
--R        3        5        7          9            11              13
--R       a   3    a   5    a    7     a     9      a      11       a       13
--R     - -- x  + --- x  - ---- x  + ------ x  - -------- x   + ---------- x
--R        6      120      5040      362880      39916800       6227020800
--R   + 
--R        14
--R     O(x  )
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 120

--S 121
s - sin(a*x)
--R 
--R
--R           21
--R   (3)  O(x  )
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 121

@
Complex & AlgebraicNumber coercions. fixed by SCM 6/91
<<*>>=
)clear all

--S 122
sin %i
--R 
--R
--R   (1)  sin(%i)
--R                                             Type: Expression Complex Integer
--E 122

--S 123
sin sqrt 2
--R 
--R
--R             +-+
--R   (2)  sin(\|2 )
--R                                                     Type: Expression Integer
--E 123

--S 124
%i*sqrt(2)
--R 
--R
--R           +-+
--R   (3)  %i\|2
--R                                             Type: Expression Complex Integer
--E 124

--S 125
sin(%i*sqrt 2)
--R 
--R
--R               +-+
--R   (4)  sin(%i\|2 )
--R                                             Type: Expression Complex Integer
--E 125

--S 126
%i * sin(x)
--R 
--R
--R   (5)  %i sin(x)
--R                                             Type: Expression Complex Integer
--E 126

--S 127
sin(x/sqrt(2))
--R 
--R
--R              +-+
--R            x\|2
--R   (6)  sin(-----)
--R              2
--R                                                     Type: Expression Integer
--E 127

@
Bug in resolve. fixed by SCM 8/12/91
<<*>>=
)clear all

)set msg test off

--S 128
primaryDecomp xx
--R 
--R   There are 1 exposed and 0 unexposed library operations named 
--R      primaryDecomp having 1 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                          )display op primaryDecomp
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--RDaly Bug
--R   Cannot find a definition or applicable library operation named 
--R      primaryDecomp with argument type(s) 
--R                                 Variable xx
--R      
--R      Perhaps you should use "@" to indicate the required return type, 
--R      or "$" to specify which version of the function you need.
--E 128

)set msg test on

@
Functions with ADEFs were broken. fixed by SCM 8/9/91
<<*>>=
)clear all

--S 129
f l ==
  reduce((x,y) +-> l.1 + x + y, l)
--R 
--R                                                                   Type: Void
--E 129

--S 130
f [10,2,53]
--R 
--R   Compiling function f with type List PositiveInteger -> 
--R      PositiveInteger 
--R
--R   (2)  85
--R                                                        Type: PositiveInteger
--E 130

--S 131
g l ==
  (x:INT):INT +-> l.x
--R 
--R                                                                   Type: Void
--E 131

--S 132
w := g [23,1,341,12] ;
--R 
--R   Compiling function g with type List PositiveInteger -> (Integer -> 
--R      Integer) 
--R
--R                                                   Type: (Integer -> Integer)
--E 132

--S 133
w(1) + w(3)
--R 
--R
--R   (5)  364
--R                                                        Type: PositiveInteger
--E 133

--S 134
w(-1) 
--R 
--R 
--RDaly Bug
--R   >> Error detected within library code:
--R   index out of range
--R
--R   Continuing to read the file...
--R
--E 134

@
Coerces RN to PF and POLY to EXPR. fixed by SCM 8/9/91
<<*>>=
)clear all

--S 135
a := 2/3
--R 
--R
--R        2
--R   (1)  -
--R        3
--R                                                       Type: Fraction Integer
--E 135

)set mes test off

--S 136
a::PF 3
--R 
--R 
--R   Division by zero on conversion to GaloisField.
--E 136

)set mes test on

--S 137
b := x+1
--R 
--R
--R   (2)  x + 1
--R                                                     Type: Polynomial Integer
--E 137

--S 138
b:: EXPR FLOAT
--R 
--R
--R   (3)  x + 1.0
--R                                                       Type: Expression Float
--E 138

@
Minivector use in coercion functions.
<<*>>=
)clear all
 
--S 139
symbol(s:Symbol,i:Integer):Symbol ==
  st0:String:= convert(i)
  st0:= concat(string(s),st0)
  st0::Symbol
--R 
--R   Function declaration symbol : (Symbol,Integer) -> Symbol has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 139

--S 140
f(a,b) == symbol(a,b)
--R 
--R                                                                   Type: Void
--E 140

--S 141
f('abc,3)
--R 
--R   Compiling function symbol with type (Symbol,Integer) -> Symbol 
--R   Compiling function f with type (Variable abc,PositiveInteger) -> 
--R      Symbol 
--R
--R   (3)  abc3
--R                                                                 Type: Symbol
--E 141

@
Coercing undeclared maps to Mapping types. fixed by SCM 9/3/91
<<*>>=
)clear all

--S 142
f := operator 'f
--R 
--R
--R   (1)  f
--R                                                          Type: BasicOperator
--E 412

--S 143
y := f(x)
--R 
--R
--R   (2)  f(x)
--R                                                     Type: Expression Integer
--E 143

--S 144
foo(u) == sin(u)
--R 
--R                                                                   Type: Void
--E 144

--S 145
eval(y, 'f, foo)
--R 
--R   There are 2 exposed and 6 unexposed library operations named sin 
--R      having 1 argument(s) but none was determined to be applicable. 
--R      Use HyperDoc Browse, or issue
--R                               )display op sin
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R   Compiling function foo with type Expression Integer -> Expression 
--R      Integer 
--R
--R   (4)  sin(x)
--R                                                     Type: Expression Integer
--E 145

@
Package calling constants. fixed by SCM 9/3/91
<<*>>=
)clear all

--S 146
init()$(PF 3)
--R 
--R
--R   (1)  0
--R                                                           Type: PrimeField 3
--E 146

@
Passing ADEFs to functions which require specific mapping types.
<<*>>=
)clear all

--draw((x,y) +-> x**2 - y**2, -1..1, -1..1)

@
DP bug.  Don't know where this came from, but its fixed. DP makes problems:
<<*>>=
)clear all

--S 147
dmp := DMP([u1,u2,u3],Fraction INT)
--R 
--R
--R   (1)  DistributedMultivariatePolynomial([u1,u2,u3],Fraction Integer)
--R                                                                 Type: Domain
--E 147

--S 148
p : dmp := 2*u1**4*u2*u3
--R 
--R
--R           4
--R   (2)  2u1 u2 u3
--R         Type: DistributedMultivariatePolynomial([u1,u2,u3],Fraction Integer)
--E 148

--S 149
e1 := degree p
--R 
--R
--R   (3)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 149

--S 150
e2 : DirectProduct(3,NonNegativeInteger) := e1
--R 
--R
--R   (4)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 150

--S 151
sup(e1,e1)
--R 
--R
--R   (5)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 151

@
If you give to many infos to the Interpreter it has problems.
<<*>>=

--S 152
sup(e1,e1)$DirectProduct(3,NonNegativeInteger)
--R 
--R
--R   (6)  [4,1,1]
--R                                    Type: DirectProduct(3,NonNegativeInteger)
--E 152

)clear all

--S 153
sum:=0
--R 
--R
--R   (1)  0
--R                                                     Type: NonNegativeInteger
--E 153

--S 154
m:=matrix [[1,2],[3,4]]
--R 
--R
--R        +1  2+
--R   (2)  |    |
--R        +3  4+
--R                                                         Type: Matrix Integer
--E 154

--S 155
lastcol:=ncols(m)
--R 
--R
--R   (3)  2
--R                                                        Type: PositiveInteger
--E 155

--S 156
for r in 1..nrows(m) repeat
 -- interpreter having a value for "row" would cause it to hide
 -- the system function
 Row:=row(m,r)
 for c in 1..lastcol repeat
  sum:=sum+Row.c
--R 
--R                                                                   Type: Void
--E 156

--S 157
sum
--R 
--R
--R   (5)  10
--R                                                        Type: PositiveInteger
--E 157

@
interpOnly mode left things in an incosistent state if it failed twice.
fixed by SCM
<<*>>=
)clear all

--S 158
splitPoly(f,var) ==
   map(g +-> multivariate(g,var),monomials univariate(f,var))
--R 
--R                                                                   Type: Void
--E 158

--S 159
g:=sin(x)+cos(x)
--R 
--R
--R   (2)  sin(x) + cos(x)
--R                                                     Type: Expression Integer
--E 159

--S 160
k:=kernels(g).1
--R 
--R
--R   (3)  sin(x)
--R                                              Type: Kernel Expression Integer
--E 160

)set mes test off

--S 161
splitPoly([g],k) -- this is an incorrect call
--R 
--R   There are 4 exposed and 1 unexposed library operations named 
--R      univariate having 2 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                           )display op univariate
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R   Cannot find a definition or applicable library operation named 
--R      univariate with argument type(s) 
--R                           List Expression Integer
--R                          Kernel Expression Integer
--R      
--R      Perhaps you should use "@" to indicate the required return type, 
--R      or "$" to specify which version of the function you need.
--R   AXIOM will attempt to step through and interpret the code.
--R   There are 4 exposed and 1 unexposed library operations named 
--R      univariate having 2 argument(s) but none was determined to be 
--R      applicable. Use HyperDoc Browse, or issue
--R                           )display op univariate
--R      to learn more about the available operations. Perhaps 
--R      package-calling the operation or using coercions on the arguments
--R      will allow you to apply the operation.
--R 
--R   Cannot find a definition or applicable library operation named 
--R      univariate with argument type(s) 
--R                           List Expression Integer
--R                          Kernel Expression Integer
--R      
--R      Perhaps you should use "@" to indicate the required return type, 
--R      or "$" to specify which version of the function you need.
--E 161

)set mes test on

--S 162
splitPoly(numer g,k) -- this is a correct call
--R 
--R   Compiling function splitPoly with type (SparseMultivariatePolynomial
--R      (Integer,Kernel Expression Integer),Kernel Expression Integer)
--R       -> List SparseMultivariatePolynomial(Integer,Kernel Expression 
--R      Integer) 
--R
--R   (4)  [sin(x),cos(x)]
--R   Type: List SparseMultivariatePolynomial(Integer,Kernel Expression Integer)
--E 162

@
Scoping of lambda variables. fixed by SCM in March, 1992
<<*>>=
)clear all

--S 163
f x ==
  g := (y:DoubleFloat):DoubleFloat +-> y+x
  output(y+1)
  g(x)
--R 
--R                                                                   Type: Void
--E 163

--S 164
f 3
--R 
--R   Compiling function f with type PositiveInteger -> DoubleFloat 
--R   y + 1
--R
--R   (2)  6.
--R                                                            Type: DoubleFloat
--E 164

@
Coercing undeclared interpreter function to mapping type with
target which need to be coerced.
fixed by SCM in March, 1992
<<*>>=
)clear all

--S 165
f x == 1/factorial(x)
--R 
--R                                                                   Type: Void
--E 165

--S 166
series(f, x=0)
--R 
--R   Compiling function f with type Integer -> Expression Integer 
--R
--R   (2)
--R             1  2   1  3    1  4    1   5    1   6     1   7     1    8
--R     1 + x + - x  + - x  + -- x  + --- x  + --- x  + ---- x  + ----- x
--R             2      6      24      120      720      5040      40320
--R   + 
--R        1    9      1     10      11
--R     ------ x  + ------- x   + O(x  )
--R     362880      3628800
--R                        Type: UnivariatePuiseuxSeries(Expression Integer,x,0)
--E 166

@
Rule dependencies with dependencies on the operator position.
<<*>>=
)clear all

--S 167
node_a == i1+i2+i3-i5+i6=0
--R 
--R                                                                   Type: Void
--E 167

--S 168
node_b == -i2-i3+i4-i6=0
--R 
--R                                                                   Type: Void
--E 168

--S 169
i1 == va/r1
--R 
--R                                                                   Type: Void
--E 169

--S 170
i2 == (va-vb)/r2
--R 
--R                                                                   Type: Void
--E 170

--S 171
i3 == (va-vb)/r3
--R 
--R                                                                   Type: Void
--E 171

--S 172
i4 == vb/r4
--R 
--R                                                                   Type: Void
--E 172

--S 173
node_a
--R 
--R   Compiling body of rule i1 to compute value of type Fraction 
--R      Polynomial Integer 
--R   Compiling body of rule i2 to compute value of type Fraction 
--R      Polynomial Integer 
--R   Compiling body of rule i3 to compute value of type Fraction 
--R      Polynomial Integer 
--R   Compiling body of rule nodea to compute value of type Equation 
--R      Fraction Polynomial Integer 
--R
--R        (- r1 r3 - r1 r2)vb + ((r2 + r1)r3 + r1 r2)va + (i6 - i5)r1 r2 r3
--R   (7)  -----------------------------------------------------------------= 0
--R                                     r1 r2 r3
--R                                   Type: Equation Fraction Polynomial Integer
--E 173

--S 174
node_b
--R 
--R   Compiling body of rule i4 to compute value of type Fraction 
--R      Polynomial Integer 
--R   Compiling body of rule nodeb to compute value of type Equation 
--R      Fraction Polynomial Integer 
--R
--R        ((r3 + r2)r4 + r2 r3)vb + (- r3 - r2)r4 va - i6 r2 r3 r4
--R   (8)  --------------------------------------------------------= 0
--R                                r2 r3 r4
--R                                   Type: Equation Fraction Polynomial Integer
--E 174

--S 175
ans == solve([node_a,node_b],[va,vb]) -- (*)
--R 
--R                                                                   Type: Void
--E 175

--S 176
x1 == rhs(ans.1.1)
--R 
--R                                                                   Type: Void
--E 176

--S 177
x2 == rhs(ans.1.2)
--R 
--R                                                                   Type: Void
--E 177

--S 178
x1       -- (**)
--R 
--R   Compiling body of rule ans to compute value of type List List 
--R      Equation Fraction Polynomial Integer 
--R   Compiling body of rule x1 to compute value of type Fraction 
--R      Polynomial Integer 
--R
--R         (i5 r1 r3 + i5 r1 r2)r4 + (- i6 + i5)r1 r2 r3
--R   (12)  ---------------------------------------------
--R               (r3 + r2)r4 + (r2 + r1)r3 + r1 r2
--R                                            Type: Fraction Polynomial Integer
--E 178

--S 179
r1 == 2  -- (***)
--R 
--R   Compiled code for i1 has been cleared.
--R   Compiled code for nodea has been cleared.
--R   Compiled code for ans has been cleared.
--R   Compiled code for x1 has been cleared.
--R                                                                   Type: Void
--E 179

--S 180
x1       -- (****)
--R 
--R   Compiling body of rule r1 to compute value of type PositiveInteger 
--R   Compiling body of rule i1 to compute value of type Polynomial 
--R      Fraction Integer 
--R   Compiling body of rule nodea to compute value of type Equation 
--R      Fraction Polynomial Integer 
--R   Compiling body of rule ans to compute value of type List List 
--R      Equation Fraction Polynomial Integer 
--R   Compiling body of rule x1 to compute value of type Fraction 
--R      Polynomial Integer 
--R
--R         (2i5 r3 + 2i5 r2)r4 + (- 2i6 + 2i5)r2 r3
--R   (14)  ----------------------------------------
--R              (r3 + r2)r4 + (r2 + 2)r3 + 2r2
--R                                            Type: Fraction Polynomial Integer
--E 180

@
Look for immediate data in operator position. 
fixed in March 1992 by SCM and RSS
<<*>>=
)clear all

--S 181
"asd" "sdfsdf" "dfgdfg"
--R 
--R
--R   (1)  "asdsdfsdfdfgdfg"
--R                                                                 Type: String
--E 181

@
Global variables that change type in a loop.
fixed by SCM
<<*>>=
)clear all

--S 182
s := 3.4
--R 
--R
--R   (1)  3.4
--R                                                                  Type: Float
--E 182

--S 183
while s > 1.0 repeat (s := 1/2; print s)
--R 
--R   1
--R   -
--R   2
--R                                                                   Type: Void
--E 183

--S 184
s
--R 
--R
--R        1
--R   (3)  -
--R        2
--R                                                       Type: Fraction Integer
--E 184

)clear all

--S 185
f x ==
  free s
  s := x
  while s > 1.0 repeat (s := 1/2; print s)
  s
--R 
--R                                                                   Type: Void
--E 185

--S 186
f(3.4)
--R 
--R   Compiling function f with type Float -> Float 
--R   Compiled code for f has been cleared.
--R   0.5
--R
--R   (2)  0.5
--R                                                                  Type: Float
--E 186

@
Returns in sequences. fixed by SCM
<<*>>=
)clear all

--S 187
t x ==
  if x = 1 then (1; return [x])
  return [2]
--R 
--R                                                                   Type: Void
--E 187

--S 188
t 1
--R 
--R   Compiling function t with type PositiveInteger -> List 
--R      PositiveInteger 
--R
--R   (2)  [1]
--R                                                   Type: List PositiveInteger
--E 188
)spool 
)lisp (bye)
 
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
