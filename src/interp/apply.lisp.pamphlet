\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp apply.lisp}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
<<*>>=

(in-package "BOOT" )

;oldCompilerAutoloadOnceTrigger() == nil

(defun |oldCompilerAutoloadOnceTrigger| () nil) 

;compAtomWithModemap(x,m,e,v) ==
;  Tl :=
;    [[transImplementation(x,map,fn),target,e]
;      for map in v | map is [[.,target],[.,fn]]] =>
;                                         --accept only monadic operators
;        T:= or/[t for (t:= [.,target,.]) in Tl | modeEqual(m,target)] => T
;        1=#(Tl:= [y for t in Tl | (y:= convert(t,m))]) => first Tl
;        0<#Tl and m=$NoValueMode => first Tl
;        nil

(DEFUN |compAtomWithModemap| (|x| |m| |e| |v|)
 (PROG (tmp1 tmp2 tmp3 tmp4 tmp5 |fn| |target| T$ |y| transimp)
  (RETURN
   (SEQ
    (COND
     ((setq transimp
      (PROG (t0)
       (setq t0 NIL)
       (RETURN
        (DO ((t1 |v| (CDR t1)) (|map| NIL))
            ((OR (ATOM t1) (PROGN (SETQ |map| (CAR t1)) NIL))
               (NREVERSE0 t0))
         (SEQ
          (EXIT
           (COND
            ((AND (PAIRP |map|)
                  (PROGN
                   (setq tmp1 (QCAR |map|))
                   (AND
                    (PAIRP tmp1)
                    (PROGN
                     (setq tmp2 (QCDR tmp1))
                     (AND
                      (PAIRP tmp2)
                      (EQ (QCDR tmp2) NIL)
                      (PROGN (setq |target| (QCAR tmp2)) t)))))
                  (PROGN
                   (setq tmp3 (QCDR |map|))
                   (AND
                    (PAIRP tmp3)
                    (EQ (QCDR tmp3) NIL)
                    (PROGN
                     (setq tmp4 (QCAR tmp3))
                     (AND (PAIRP tmp4)
                          (PROGN
                           (setq tmp5 (QCDR tmp4))
                           (AND (PAIRP tmp5)
                                (EQ (QCDR tmp5) NIL)
                                (PROGN (setq |fn| (QCAR tmp5)) t))))))))
              (SETQ t0
               (CONS
                (CONS
                 (|transImplementation| |x| |map| |fn|)
                 (CONS |target| (CONS |e| NIL)))
                t0))))))))))
       (EXIT
        (COND 
         ((setq T$ (PROG (t2) (setq t2 NIL) (RETURN (DO ((t3 NIL t2) (t4 transimp (CDR t4)) (|t| NIL)) ((OR t3 (ATOM t4) (PROGN (SETQ |t| (CAR t4)) NIL) (PROGN (PROGN (setq |target| (CADR |t|)) |t|) NIL)) t2) (SEQ (EXIT (COND ((|modeEqual| |m| |target|) (SETQ t2 (OR t2 |t|)))))))))) T$)
         ((EQL 1
           (|#|
            (setq transimp 
             (PROG (t5)
              (setq t5 NIL)
               (RETURN
                (DO ((t6 transimp (CDR t6)) (|t| NIL))
                    ((OR (ATOM t6) (PROGN (SETQ |t| (CAR t6)) NIL))
                     (NREVERSE0 t5))
                 (SEQ
                  (EXIT
                   (COND 
                    ((setq |y| (|convert| |t| |m|))
                      (setq t5 (cons |y| t5))))))))))))
           (car transimp))
         ((and (qslessp 0 (|#| transimp)) (boot-equal |m| |$NoValueMode|))
           (car transimp))
          (t nil))))))))) 


;transImplementation(op,map,fn) ==
;--+
;  fn := genDeltaEntry [op,:map]
;  fn is ["XLAM",:.] => [fn]
;  ["call",fn]

(defun |transImplementation| (op map fn)
 (setq fn (|genDeltaEntry| (cons op map)))
 (cond
  ((and (pairp fn) (eq (qcar fn) 'xlam)) (cons fn nil))
  (t (cons '|call| (cons fn nil)))))


;compApply(sig,varl,body,argl,m,e) ==
;  argTl:= [[.,.,e]:= comp(x,$EmptyMode,e) for x in argl]
;  contour:=
;    [Pair(x,[["mode",m'],["value",removeEnv comp(a,m',e)]])
;      for x in varl for m' in sig.source for a in argl]
;  code:= [["LAMBDA",varl,body'],:[T.expr for T in argTl]]
;  m':= resolve(m,sig.target)
;  body':= (comp(body,m',addContour(contour,e))).expr
;  [code,m',e]

(defun |compApply| (sig varl body argl m e)
 (let (temp1 argTl contour code mq bodyq)
  (setq argTl
   (prog (t0)
    (setq t0 nil)
    (return
     (do ((t1 argl (cdr t1)) (|x| nil))
         ((or (atom t1) (progn (setq |x| (car t1)) nil)) (nreverse0 t0))
      (seq
       (exit
        (setq t0
         (cons 
          (progn
           (setq temp1 (|comp| |x| |$EmptyMode| e))
           (setq e (caddr temp1))
           temp1)
          t0))))))))
  (setq contour
   (prog (t2)
    (setq t2 NIL)
    (return
     (do ((t3 varl (cdr t3))
          (|x| nil)
          (t4 (cdr sig) (cdr t4))
          (mq nil)
          (t5 argl (cdr t5))
          (|a| nil))
         ((or (atom t3)
              (progn (setq |x| (car t3)) nil)
              (atom t4)
              (progn (setq mq (car t4)) nil)
              (atom t5)
              (progn (setq |a| (car t5)) nil))
           (nreverse0 t2))
        (setq t2
         (cons
          (|Pair| |x|
           (cons 
            (cons '|mode| (cons mq nil))
            (cons
             (cons '|value| (cons (|removeEnv| (|comp| |a| mq e)) nil))
             nil)))
          t2))))))
  (setq code
   (cons
    (cons 'lambda (cons varl (cons bodyq nil)))
    (prog (t6)
     (setq t6 nil)
     (return
      (do ((t7 argTl (cdr t7)) (T$ nil))
          ((or (atom t7) (progn (setq T$ (car t7)) nil)) (nreverse0 t6))
        (setq t6 (cons (car T$) t6)))))))
  (setq mq (|resolve| m (car sig)))
  (setq bodyq (car (|comp| body mq (|addContour| contour e))))
  (cons code (cons mq (cons e nil)))))


;compToApply(op,argl,m,e) ==
;  T:= compNoStacking(op,$EmptyMode,e) or return nil
;  m1:= T.mode
;  T.expr is ["QUOTE", =m1] => nil
;  compApplication(op,argl,m,T.env,T)

(DEFUN |compToApply| (|op| |argl| |m| |e|) (PROG (T$ |m1| tmp1 tmp2) (RETURN (PROGN (setq T$ (OR (|compNoStacking| |op| |$EmptyMode| |e|) (RETURN NIL))) (setq |m1| (CADR T$)) (COND ((PROGN (setq tmp1 (CAR T$)) (AND (PAIRP tmp1) (EQ (QCAR tmp1) (QUOTE QUOTE)) (PROGN (setq tmp2 (QCDR tmp1)) (AND (PAIRP tmp2) (EQ (QCDR tmp2) NIL) (EQUAL (QCAR tmp2) |m1|))))) NIL) (t (|compApplication| |op| |argl| |m| (CADDR T$) T$))))))) 


;compApplication(op,argl,m,e,T) ==
;  T.mode is ['Mapping, retm, :argml] =>
;    #argl ^= #argml => nil
;    retm := resolve(m, retm)
;    retm = $Category or isCategoryForm(retm,e) => nil  -- not handled
;    argTl := [[.,.,e] := comp(x,m,e) or return "failed"
;              for x in argl for m in argml]
;    argTl = "failed" => nil
;    form:=
;      not (MEMBER(op,$formalArgList) or MEMBER(T.expr,$formalArgList)) and ATOM T.expr =>
;        nprefix := $prefix or
;        -- following needed for referencing local funs at capsule level
;           getAbbreviation($op,#rest $form)
;        [op',:[a.expr for a in argTl],"$"] where
;          op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem T.expr)
;      ['call, ['applyFun, T.expr], :[a.expr for a in argTl]]
;    coerce([form, retm, e],resolve(retm,m))
;  op = 'elt => nil
;  eltForm := ['elt, op, :argl]
;  comp(eltForm, m, e)

(DEFUN |compApplication| (|op| |argl| |m| |e| T$) (PROG (tmp1 tmp2 |argml| |retm| temp1 |argTl| |nprefix| |op'| |form| |eltForm|) (RETURN (SEQ (COND ((PROGN (setq tmp1 (CADR T$)) (AND (PAIRP tmp1) (EQ (QCAR tmp1) (QUOTE |Mapping|)) (PROGN (setq tmp2 (QCDR tmp1)) (AND (PAIRP tmp2) (PROGN (setq |retm| (QCAR tmp2)) (setq |argml| (QCDR tmp2)) t))))) (COND ((NEQUAL (|#| |argl|) (|#| |argml|)) NIL) (t (setq |retm| (|resolve| |m| |retm|)) (COND ((OR (BOOT-EQUAL |retm| |$Category|) (|isCategoryForm| |retm| |e|)) NIL) (t (setq |argTl| (PROG (t0) (setq t0 NIL) (RETURN (DO ((t1 |argl| (CDR t1)) (|x| NIL) (t2 |argml| (CDR t2)) (|m| NIL)) ((OR (ATOM t1) (PROGN (SETQ |x| (CAR t1)) NIL) (ATOM t2) (PROGN (SETQ |m| (CAR t2)) NIL)) (NREVERSE0 t0)) (SEQ (EXIT (SETQ t0 (CONS (PROGN (setq temp1 (OR (|comp| |x| |m| |e|) (RETURN (QUOTE |failed|)))) (setq |e| (CADDR temp1)) temp1) t0)))))))) (COND ((BOOT-EQUAL |argTl| (QUOTE |failed|)) NIL) (t (setq |form| (COND ((AND (NULL (OR (|member| |op| |$formalArgList|) (|member| (CAR T$) |$formalArgList|))) (ATOM (CAR T$))) (setq |nprefix| (OR |$prefix| (|getAbbreviation| |$op| (|#| (CDR |$form|))))) (setq |op'| (INTERN (STRCONC (|encodeItem| |nprefix|) (QUOTE |;|) (|encodeItem| (CAR T$))))) (CONS |op'| (APPEND (PROG (t3) (setq t3 NIL) (RETURN (DO ((t4 |argTl| (CDR t4)) (|a| NIL)) ((OR (ATOM t4) (PROGN (SETQ |a| (CAR t4)) NIL)) (NREVERSE0 t3)) (SEQ (EXIT (SETQ t3 (CONS (CAR |a|) t3))))))) (CONS (QUOTE $) NIL)))) (t (CONS (QUOTE |call|) (CONS (CONS (QUOTE |applyFun|) (CONS (CAR T$) NIL)) (PROG (t5) (setq t5 NIL) (RETURN (DO ((t6 |argTl| (CDR t6)) (|a| NIL)) ((OR (ATOM t6) (PROGN (SETQ |a| (CAR t6)) NIL)) (NREVERSE0 t5)) (SEQ (EXIT (SETQ t5 (CONS (CAR |a|) t5)))))))))))) (|coerce| (CONS |form| (CONS |retm| (CONS |e| NIL))) (|resolve| |retm| |m|))))))))) ((BOOT-EQUAL |op| (QUOTE |elt|)) NIL) (t (setq |eltForm| (CONS (QUOTE |elt|) (CONS |op| |argl|))) (|comp| |eltForm| |m| |e|))))))) 


;compFormWithModemap(form is [op,:argl],m,e,modemap) ==
;  [map:= [.,target,:.],[pred,impl]]:= modemap
;  -- this fails if the subsuming modemap is conditional
;  --impl is ['Subsumed,:.] => nil
;  if isCategoryForm(target,e) and isFunctor op then
;    [modemap,e]:= substituteIntoFunctorModemap(argl,modemap,e) or return nil
;    [map:= [.,target,:.],:cexpr]:= modemap
;  sv:=listOfSharpVars map
;  if sv then
;     -- SAY [ "compiling ", op, " in compFormWithModemap,
;     -- mode= ",map," sharp vars=",sv]
;    for x in argl for ss in $FormalMapVariableList repeat
;      if ss in sv then
;        [map:= [.,target,:.],:cexpr]:= modemap :=SUBST(x,ss,modemap)
;        -- SAY ["new map is",map]
;  not (target':= coerceable(target,m,e)) => nil
;  map:= [target',:rest map]
;  [f,Tl,sl]:= compApplyModemap(form,modemap,e,nil) or return nil
;  --generate code; return
;  T:=
;    [x',m',e'] where
;      m':= SUBLIS(sl,map.(1))
;      x':=
;        form':= [f,:[t.expr for t in Tl]]
;        m'=$Category or isCategoryForm(m',e) => form'
;        -- try to deal with new-style Unions where we know the conditions
;        op = "elt" and f is ['XLAM,:.] and IDENTP(z:=CAR argl) and
;          (c:=get(z,'condition,e)) and
;            c is [['case,=z,c1]] and
;              (c1 is ['_:,=(CADR argl),=m] or EQ(c1,CADR argl) ) =>
;-- first is a full tag, as placed by getInverseEnvironment
;-- second is what getSuccessEnvironment will place there
;                ["CDR",z]
;        ["call",:form']
;      e':=
;        Tl => (LAST Tl).env
;        e
;  convert(T,m)

(DEFUN |compFormWithModemap| (|form| |m| |e| |modemap|) (PROG (|op| |argl| |pred| |impl| |sv| |target| |cexpr| |target'| |map| temp1 |f| transimp |sl| |m'| |form'| |z| |c| tmp3 |c1| tmp1 tmp2 |x'| |e'| T$) (RETURN (SEQ (PROGN (setq |op| (CAR |form|)) (setq |argl| (CDR |form|)) (setq |map| (CAR |modemap|)) (setq |target| (CADAR |modemap|)) (setq |pred| (CAADR |modemap|)) (setq |impl| (CADADR |modemap|)) (COND ((AND (|isCategoryForm| |target| |e|) (|isFunctor| |op|)) (setq temp1 (OR (|substituteIntoFunctorModemap| |argl| |modemap| |e|) (RETURN NIL))) (setq |modemap| (CAR temp1)) (setq |e| (CADR temp1)) (setq |map| (CAR |modemap|)) (setq |target| (CADAR |modemap|)) (setq |cexpr| (CDR |modemap|)) |modemap|)) (setq |sv| (|listOfSharpVars| |map|)) (COND (|sv| (DO ((t0 |argl| (CDR t0)) (|x| NIL) (t1 |$FormalMapVariableList| (CDR t1)) (|ss| NIL)) ((OR (ATOM t0) (PROGN (SETQ |x| (CAR t0)) NIL) (ATOM t1) (PROGN (SETQ |ss| (CAR t1)) NIL)) NIL) (SEQ (EXIT (COND ((|member| |ss| |sv|) (setq |modemap| (MSUBST |x| |ss| |modemap|)) (setq |map| (CAR |modemap|)) (setq |target| (CADAR |modemap|)) (setq |cexpr| (CDR |modemap|)) |modemap|) (t NIL))))))) (COND ((NULL (setq |target'| (|coerceable| |target| |m| |e|))) NIL) (t (setq |map| (CONS |target'| (CDR |map|))) (setq temp1 (OR (|compApplyModemap| |form| |modemap| |e| NIL) (RETURN NIL))) (setq |f| (CAR temp1)) (setq transimp (CADR temp1)) (setq |sl| (CADDR temp1)) (setq |m'| (SUBLIS |sl| (ELT |map| 1))) (setq |x'| (PROGN (setq |form'| (CONS |f| (PROG (t2) (setq t2 NIL) (RETURN (DO ((t3 transimp (CDR t3)) (|t| NIL)) ((OR (ATOM t3) (PROGN (SETQ |t| (CAR t3)) NIL)) (NREVERSE0 t2)) (SEQ (EXIT (SETQ t2 (CONS (CAR |t|) t2))))))))) (COND ((OR (BOOT-EQUAL |m'| |$Category|) (|isCategoryForm| |m'| |e|)) |form'|) ((AND (BOOT-EQUAL |op| (QUOTE |elt|)) (PAIRP |f|) (EQ (QCAR |f|) (QUOTE XLAM)) (IDENTP (setq |z| (CAR |argl|))) (setq |c| (|get| |z| (QUOTE |condition|) |e|)) (PAIRP |c|) (EQ (QCDR |c|) NIL) (PROGN (setq tmp1 (QCAR |c|)) (AND (PAIRP tmp1) (EQ (QCAR tmp1) (QUOTE |case|)) (PROGN (setq tmp2 (QCDR tmp1)) (AND (PAIRP tmp2) (EQUAL (QCAR tmp2) |z|) (PROGN (setq tmp3 (QCDR tmp2)) (AND (PAIRP tmp3) (EQ (QCDR tmp3) NIL) (PROGN (setq |c1| (QCAR tmp3)) t))))))) (OR (AND (PAIRP |c1|) (EQ (QCAR |c1|) (QUOTE |:|)) (PROGN (setq tmp1 (QCDR |c1|)) (AND (PAIRP tmp1) (EQUAL (QCAR tmp1) (CADR |argl|)) (PROGN (setq tmp2 (QCDR tmp1)) (AND (PAIRP tmp2) (EQ (QCDR tmp2) NIL) (EQUAL (QCAR tmp2) |m|)))))) (EQ |c1| (CADR |argl|)))) (CONS (QUOTE CDR) (CONS |z| NIL))) (t (CONS (QUOTE |call|) |form'|))))) (setq |e'| (COND (transimp (CADDR (|last| transimp))) (t |e|))) (setq T$ (CONS |x'| (CONS |m'| (CONS |e'| NIL)))) (|convert| T$ |m|)))))))) 


;-- This version tends to give problems with #1 and categories
;-- applyMapping([op,:argl],m,e,ml) ==
;--   #argl^=#ml-1 => nil
;--   mappingHasCategoryTarget :=
;--     isCategoryForm(first ml,e) => --is op a functor?
;--       form:= [op,:argl']
;--       pairlis:= [[v,:a] for a in argl for v in $FormalMapVariableList]
;--       ml:= SUBLIS(pairlis,ml)
;--       true
;--     false
;--   argl':=
;--     [T.expr for x in argl for m' in rest ml] where
;--       T() == [.,.,e]:= comp(x,m',e) or return "failed"
;--   if argl'="failed" then return nil
;--   mappingHasCategoryTarget => convert([form,first ml,e],m)
;--   form:=
;--     not MEMBER(op,$formalArgList) and ATOM op =>
;--       [op',:argl',"$"] where
;--         op':= INTERN STRCONC(STRINGIMAGE $prefix,";",STRINGIMAGE op)
;--     ["call",["applyFun",op],:argl']
;--   pairlis:= [[v,:a] for a in argl' for v in $FormalMapVariableList]
;--   convert([form,SUBLIS(pairlis,first ml),e],m)


;applyMapping([op,:argl],m,e,ml) ==
;  #argl^=#ml-1 => nil
;  isCategoryForm(first ml,e) =>
;                                --is op a functor?
;    pairlis:= [[v,:a] for a in argl for v in $FormalMapVariableList]
;    ml' := SUBLIS(pairlis, ml)
;    argl':=
;      [T.expr for x in argl for m' in rest ml'] where
;        T() == [.,.,e]:= comp(x,m',e) or return "failed"
;    if argl'="failed" then return nil
;    form:= [op,:argl']
;    convert([form,first ml',e],m)
;  argl':=
;    [T.expr for x in argl for m' in rest ml] where
;      T() == [.,.,e]:= comp(x,m',e) or return "failed"
;  if argl'="failed" then return nil
;  form:=
;    not MEMBER(op,$formalArgList) and ATOM op and not get(op,'value,e) =>
;      nprefix := $prefix or
;   -- following needed for referencing local funs at capsule level
;        getAbbreviation($op,#rest $form)
;      [op',:argl',"$"] where
;        op':= INTERN STRCONC(encodeItem nprefix,";",encodeItem op)
;    ['call,['applyFun,op],:argl']
;  pairlis:= [[v,:a] for a in argl' for v in $FormalMapVariableList]
;  convert([form,SUBLIS(pairlis,first ml),e],m)

(DEFUN |applyMapping| (t0 |m| |e| |ml|) (PROG (|op| |argl| |ml'| temp1 |argl'| |nprefix| |op'| |form| |pairlis|) (RETURN (SEQ (PROGN (setq |op| (CAR t0)) (setq |argl| (CDR t0)) (COND ((NEQUAL (|#| |argl|) (SPADDIFFERENCE (|#| |ml|) 1)) NIL) ((|isCategoryForm| (CAR |ml|) |e|) (setq |pairlis| (PROG (t1) (setq t1 NIL) (RETURN (DO ((t2 |argl| (CDR t2)) (|a| NIL) (t3 |$FormalMapVariableList| (CDR t3)) (|v| NIL)) ((OR (ATOM t2) (PROGN (SETQ |a| (CAR t2)) NIL) (ATOM t3) (PROGN (SETQ |v| (CAR t3)) NIL)) (NREVERSE0 t1)) (SEQ (EXIT (SETQ t1 (CONS (CONS |v| |a|) t1)))))))) (setq |ml'| (SUBLIS |pairlis| |ml|)) (setq |argl'| (PROG (t4) (setq t4 NIL) (RETURN (DO ((t5 |argl| (CDR t5)) (|x| NIL) (t6 (CDR |ml'|) (CDR t6)) (|m'| NIL)) ((OR (ATOM t5) (PROGN (SETQ |x| (CAR t5)) NIL) (ATOM t6) (PROGN (SETQ |m'| (CAR t6)) NIL)) (NREVERSE0 t4)) (SEQ (EXIT (SETQ t4 (CONS (CAR (PROGN (setq temp1 (OR (|comp| |x| |m'| |e|) (RETURN (QUOTE |failed|)))) (setq |e| (CADDR temp1)) temp1)) t4)))))))) (COND ((BOOT-EQUAL |argl'| (QUOTE |failed|)) (RETURN NIL))) (setq |form| (CONS |op| |argl'|)) (|convert| (CONS |form| (CONS (CAR |ml'|) (CONS |e| NIL))) |m|)) (t (setq |argl'| (PROG (t7) (setq t7 NIL) (RETURN (DO ((t8 |argl| (CDR t8)) (|x| NIL) (t9 (CDR |ml|) (CDR t9)) (|m'| NIL)) ((OR (ATOM t8) (PROGN (SETQ |x| (CAR t8)) NIL) (ATOM t9) (PROGN (SETQ |m'| (CAR t9)) NIL)) (NREVERSE0 t7)) (SEQ (EXIT (SETQ t7 (CONS (CAR (PROGN (setq temp1 (OR (|comp| |x| |m'| |e|) (RETURN (QUOTE |failed|)))) (setq |e| (CADDR temp1)) temp1)) t7)))))))) (COND ((BOOT-EQUAL |argl'| (QUOTE |failed|)) (RETURN NIL))) (setq |form| (COND ((AND (NULL (|member| |op| |$formalArgList|)) (ATOM |op|) (NULL (|get| |op| (QUOTE |value|) |e|))) (setq |nprefix| (OR |$prefix| (|getAbbreviation| |$op| (|#| (CDR |$form|))))) (setq |op'| (INTERN (STRCONC (|encodeItem| |nprefix|) (QUOTE |;|) (|encodeItem| |op|)))) (CONS |op'| (APPEND |argl'| (CONS (QUOTE $) NIL)))) (t (CONS (QUOTE |call|) (CONS (CONS (QUOTE |applyFun|) (CONS |op| NIL)) |argl'|))))) (setq |pairlis| (PROG (t10) (setq t10 NIL) (RETURN (DO ((t11 |argl'| (CDR t11)) (|a| NIL) (t12 |$FormalMapVariableList| (CDR t12)) (|v| NIL)) ((OR (ATOM t11) (PROGN (SETQ |a| (CAR t11)) NIL) (ATOM t12) (PROGN (SETQ |v| (CAR t12)) NIL)) (NREVERSE0 t10)) (SEQ (EXIT (SETQ t10 (CONS (CONS |v| |a|) t10)))))))) (|convert| (CONS |form| (CONS (SUBLIS |pairlis| (CAR |ml|)) (CONS |e| NIL))) |m|)))))))) 


;--% APPLY MODEMAPS
;compApplyModemap(form,modemap,$e,sl) ==
;  [op,:argl] := form                   --form to be compiled
;  [[mc,mr,:margl],:fnsel] := modemap   --modemap we are testing
;  -- $e     is the current environment
;  -- sl     substitution list, nil means bottom-up, otherwise top-down
;  -- 0.  fail immediately if #argl=#margl
;  if #argl^=#margl then return nil
;  -- 1.  use modemap to evaluate arguments, returning failed if
;  --     not possible
;  lt:=
;    [[.,m',$e]:=
;      comp(y,g,$e) or return "failed" where
;        g:= SUBLIS(sl,m) where
;            sl:= pmatchWithSl(m',m,sl) for y in argl for m in margl]
;  lt="failed" => return nil
;  -- 2.  coerce each argument to final domain, returning failed
;  --     if not possible
;  lt':= [coerce(y,d) or return "failed"
;         for y in lt for d in SUBLIS(sl,margl)]
;  lt'="failed" => return nil
;  -- 3.  obtain domain-specific function, if possible, and return
;  --$bindings is bound by compMapCond
;  [f,$bindings]:= compMapCond(op,mc,sl,fnsel) or return nil
;--+ can no longer trust what the modemap says for a reference into
;--+ an exterior domain (it is calculating the displacement based on view
;--+ information which is no longer valid; thus ignore this index and
;--+ store the signature instead.
;--$NRTflag=true and f is [op1,d,.] and NE(d,'$) and MEMBER(op1,'(ELT CONST)) =>
;  f is [op1,d,.] and MEMBER(op1,'(ELT CONST Subsumed)) =>
;    [genDeltaEntry [op,:modemap],lt',$bindings]
;  [f,lt',$bindings]

(DEFUN |compApplyModemap| (|form| |modemap| |$e| |sl|) (DECLARE (SPECIAL |$e|)) (PROG (|op| |argl| |mc| |mr| |margl| |fnsel| |g| |m'| |lt| |lt'| temp1 |f| |op1| tmp1 |d| tmp2) (RETURN (SEQ (PROGN (setq |op| (CAR |form|)) (setq |argl| (CDR |form|)) (setq |mc| (CAAR |modemap|)) (setq |mr| (CADAR |modemap|)) (setq |margl| (CDDAR |modemap|)) (setq |fnsel| (CDR |modemap|)) (COND ((NEQUAL (|#| |argl|) (|#| |margl|)) (RETURN NIL))) (setq |lt| (PROG (t0) (setq t0 NIL) (RETURN (DO ((t1 |argl| (CDR t1)) (|y| NIL) (t2 |margl| (CDR t2)) (|m| NIL)) ((OR (ATOM t1) (PROGN (SETQ |y| (CAR t1)) NIL) (ATOM t2) (PROGN (SETQ |m| (CAR t2)) NIL)) (NREVERSE0 t0)) (SEQ (EXIT (SETQ t0 (CONS (PROGN (setq |sl| (|pmatchWithSl| |m'| |m| |sl|)) (setq |g| (SUBLIS |sl| |m|)) (setq temp1 (OR (|comp| |y| |g| |$e|) (RETURN (QUOTE |failed|)))) (setq |m'| (CADR temp1)) (setq |$e| (CADDR temp1)) temp1) t0)))))))) (COND ((BOOT-EQUAL |lt| (QUOTE |failed|)) (RETURN NIL)) (t (setq |lt'| (PROG (t3) (setq t3 NIL) (RETURN (DO ((t4 |lt| (CDR t4)) (|y| NIL) (t5 (SUBLIS |sl| |margl|) (CDR t5)) (|d| NIL)) ((OR (ATOM t4) (PROGN (SETQ |y| (CAR t4)) NIL) (ATOM t5) (PROGN (SETQ |d| (CAR t5)) NIL)) (NREVERSE0 t3)) (SEQ (EXIT (SETQ t3 (CONS (OR (|coerce| |y| |d|) (RETURN (QUOTE |failed|))) t3)))))))) (COND ((BOOT-EQUAL |lt'| (QUOTE |failed|)) (RETURN NIL)) (t (setq temp1 (OR (|compMapCond| |op| |mc| |sl| |fnsel|) (RETURN NIL))) (setq |f| (CAR temp1)) (setq |$bindings| (CADR temp1)) (COND ((AND (PAIRP |f|) (PROGN (setq |op1| (QCAR |f|)) (setq tmp1 (QCDR |f|)) (AND (PAIRP tmp1) (PROGN (setq |d| (QCAR tmp1)) (setq tmp2 (QCDR tmp1)) (AND (PAIRP tmp2) (EQ (QCDR tmp2) NIL))))) (|member| |op1| (QUOTE (ELT CONST |Subsumed|)))) (CONS (|genDeltaEntry| (CONS |op| |modemap|)) (CONS |lt'| (CONS |$bindings| NIL)))) (t (CONS |f| (CONS |lt'| (CONS |$bindings| NIL)))))))))))))) 


;compMapCond(op,mc,$bindings,fnsel) ==
;  or/[compMapCond'(u,op,mc,$bindings) for u in fnsel]

(defun |compMapCond| (op mc |$bindings| fnsel)
 (declare (special |$bindings|))
 (let (t0)
  (do ((t1 nil t0) (t2 fnsel (cdr t2)) (|u| nil))
      ((or t1 (atom t2) (progn (setq |u| (car t2)) nil)) t0)
   (setq t0 (or t0 (|compMapCond'| |u| op mc |$bindings|))))))


;compMapCond'([cexpr,fnexpr],op,dc,bindings) ==
;  compMapCond''(cexpr,dc) => compMapCondFun(fnexpr,op,dc,bindings)
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]

(defun |compMapCond'| (t0 op dc bindings)
 (let ((cexpr (car t0)) (fnexpr (cadr t0)))
  (if (|compMapCond''| cexpr dc)
    (|compMapCondFun| fnexpr op dc bindings)
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d)))))

;compMapCond''(cexpr,dc) ==
;  cexpr=true => true
;  --cexpr = "true" => true
;  cexpr is ["AND",:l] => and/[compMapCond''(u,dc) for u in l]
;  cexpr is ["OR",:l] => or/[compMapCond''(u,dc) for u in l]
;  cexpr is ["not",u] => not compMapCond''(u,dc)
;  cexpr is ["has",name,cat] => (knownInfo cexpr => true; false)
;        --for the time being we'll stop here - shouldn't happen so far
;        --$disregardConditionIfTrue => true
;        --stackSemanticError(("not known that",'%b,name,
;        -- '%d,"has",'%b,cat,'%d),nil)
;  --now it must be an attribute
;  MEMBER(["ATTRIBUTE",dc,cexpr],get("$Information","special",$e)) => true
;  --for the time being we'll stop here - shouldn't happen so far
;  stackMessage ["not known that",'%b,dc,'%d,"has",'%b,cexpr,'%d]
;  false

(defun |compMapCond''| (cexpr dc)
 (let (l u tmp1 tmp2)
 (declare (special |$Information|))
  (cond
   ((boot-equal cexpr t) t)
   ((and (pairp cexpr) 
         (eq (qcar cexpr) 'and)
         (progn (setq l (qcdr cexpr)) t))
     (prog (t0)
      (setq t0 t)
      (return
       (do ((t1 nil (null t0)) (t2 l (cdr t2)) (u nil))
           ((or t1 (atom t2) (progn (setq u (car t2)) nil)) t0)
        (setq t0 (and t0 (|compMapCond''| u dc)))))))
   ((and (pairp cexpr) 
         (eq (qcar cexpr) 'or)
         (progn (setq l (qcdr cexpr)) t))
    (prog (t3)
     (setq t3 nil)
     (return
      (do ((t4 nil t3) (t5 l (cdr t5)) (u nil))
          ((or t4 (atom t5) (progn (setq u (car t5)) nil)) t3)
         (setq t3 (or t3 (|compMapCond''| u dc)))))))
   ((and (pairp cexpr)
         (eq (qcar cexpr) '|not|)
         (progn 
          (setq tmp1 (qcdr cexpr))
          (and (pairp tmp1)
               (eq (qcdr tmp1) nil)
               (progn (setq u (qcar tmp1)) t))))
     (null (|compMapCond''| u dc)))
   ((and (pairp cexpr)
         (eq (qcar cexpr) '|has|)
         (progn
          (setq tmp1 (qcdr cexpr))
          (and (pairp tmp1)
               (progn
                (setq tmp2 (qcdr tmp1))
                (and (pairp tmp2)
                     (eq (qcdr tmp2) nil))))))
     (cond
      ((|knownInfo| cexpr) t)
      (t nil)))
   ((|member| 
      (cons 'attribute (cons dc (cons cexpr nil)))
      (|get| '|$Information| '|special| |$e|))
     t)
   (t 
    (|stackMessage| `("not known that" %b ,dc %d "has" %b ,cexpr %d))
    nil))))

;compMapCondFun(fnexpr,op,dc,bindings) == [fnexpr,bindings]

(defun |compMapCondFun| (fnexpr op dc bindings)
 (declare (ignore op) (ignore dc))
 (cons fnexpr (cons bindings nil))) 

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
