\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp interop.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

)package "BOOT"

-- note domainObjects are now (dispatchVector hashCode . domainVector)
-- lazy oldAxiomDomainObjects are (dispatchVector hashCode  (Call form) . backptr), 
-- pre oldAxiomCategory is (dispatchVector . (cat form))
-- oldAxiomCategory objects are (dispatchVector . ( (cat form)  hash defaultpack parentlist))

hashCode? x == INTEGERP x

$domainTypeTokens := ['lazyOldAxiomDomain, 'oldAxiomDomain, 'oldAxiomPreCategory,
           'oldAxiomCategory, 0]

-- The name game.
-- The compiler produces names that are of the form:
-- a) cons(0, <string>)
-- b) cons(1, type-name, arg-names...)
-- c) cons(2, arg-names...)
-- d) cons(3, value)
-- NB: (c) is for tuple-ish constructors, 
--     and (d) is for dependent types.

DNameStringID := 0
DNameApplyID  := 1
DNameTupleID  := 2
DNameOtherID  := 3

DNameToSExpr1 dname ==
  NULL dname => error "unexpected domain name"
  CAR dname = DNameStringID => 
    INTERN(CompStrToString CDR dname)
  name0 := DNameToSExpr1 CAR CDR dname
  args  := CDR CDR dname
  name0 = '_-_> => 
    froms := CAR args
    froms := MAPCAR(function DNameToSExpr, CDR froms)
    ret   := CAR CDR args -- a tuple
    ret   := DNameToSExpr CAR CDR ret -- contents
    CONS('Mapping, CONS(ret, froms))
  name0 = 'Union or name0 = 'Record =>
    sxs := MAPCAR(function DNameToSExpr, CDR CAR args)
    CONS(name0, sxs)
  name0 = 'Enumeration =>
    CONS(name0, MAPCAR(function DNameFixEnum, CDR CAR args))
  CONS(name0, MAPCAR(function DNameToSExpr, args))

DNameToSExpr dname ==
  CAR dname = DNameOtherID  =>
	CDR dname
  sx := DNameToSExpr1 dname
  CONSP sx => sx
  LIST sx

DNameFixEnum arg == CompStrToString CDR arg
  
SExprToDName(sexpr, cosigVal) == 
  -- is it a non-type valued object?
  NOT cosigVal => [DNameOtherID, :sexpr]
  if CAR sexpr = '_: then sexpr := CAR CDR CDR sexpr
  CAR sexpr = 'Mapping =>
    args := [ SExprToDName(sx, 'T) for sx in CDR sexpr]
    [DNameApplyID,
         [DNameStringID,: StringToCompStr '"->"],
              [DNameTupleID, : CDR args],
		 [DNameTupleID, CAR args]]
  name0 :=   [DNameStringID, : StringToCompStr SYMBOL_-NAME CAR sexpr]
  CAR sexpr = 'Union or CAR sexpr = 'Record =>
    [DNameApplyID, name0, 
        [DNameTupleID,: [ SExprToDName(sx, 'T) for sx in CDR sexpr]]]
  newCosig := CDR GETDATABASE(CAR sexpr, QUOTE COSIG)
  [DNameApplyID, name0,
   : MAPCAR(function SExprToDName, CDR sexpr, newCosig)]

-- local garbage because Compiler strings are null terminated
StringToCompStr(str) == 
   CONCATENATE(QUOTE STRING, str, STRING (CODE_-CHAR 0))

CompStrToString(str) == 
   SUBSTRING(str, 0, (LENGTH str - 1))
-- local garbage ends

runOldAxiomFunctor(:allArgs) ==
  [:args,env] := allArgs
  GETDATABASE(env, 'CONSTRUCTORKIND) = 'category =>
      [$oldAxiomPreCategoryDispatch,: [env, :args]]
  dom:=APPLY(env, args)
  makeOldAxiomDispatchDomain dom

makeLazyOldAxiomDispatchDomain domform ==
  attribute? domform =>
      [$attributeDispatch, domform, hashString(SYMBOL_-NAME domform)]
  GETDATABASE(opOf domform, 'CONSTRUCTORKIND) = 'category =>
      [$oldAxiomPreCategoryDispatch,: domform]
  dd := [$lazyOldAxiomDomainDispatch, hashTypeForm(domform,0), domform]
  NCONC(dd,dd) -- installs back pointer to head of domain.
  dd

makeOldAxiomDispatchDomain dom ==
  PAIRP dom => dom
  [$oldAxiomDomainDispatch,hashTypeForm(dom.0,0),:dom]

closeOldAxiomFunctor(name) ==
   [function runOldAxiomFunctor,:SYMBOL_-FUNCTION name]

lazyOldAxiomDomainLookupExport(domenv, self, op, sig, box, skipdefaults, env) ==
  dom := instantiate domenv
  SPADCALL(CDR dom, self, op, sig, box, skipdefaults, CAR(dom).3)

lazyOldAxiomDomainHashCode(domenv, env) == CAR domenv

lazyOldAxiomDomainDevaluate(domenv, env) ==
  dom := instantiate domenv
  SPADCALL(CDR dom, CAR(dom).1)

lazyOldAxiomAddChild(domenv, kid, env) ==
  CONS($lazyOldAxiomDomainDispatch,domenv)

$lazyOldAxiomDomainDispatch :=
   VECTOR('lazyOldAxiomDomain,
          [function lazyOldAxiomDomainDevaluate],
          [nil],
	  [function lazyOldAxiomDomainLookupExport],
          [function lazyOldAxiomDomainHashCode],
          [function lazyOldAxiomAddChild])

-- old Axiom pre category objects are just (dispatch . catform)
-- where catform is ('categoryname,: evaluated args)
-- old Axiom category objects are  (dispatch . [catform, hashcode, defaulting package, parent vector, dom])
oldAxiomPreCategoryBuild(catform, dom, env) ==
   pack := oldAxiomCategoryDefaultPackage(catform, dom)
   CONS($oldAxiomCategoryDispatch,
       [catform, hashTypeForm(catform,0), pack, oldAxiomPreCategoryParents(catform,dom), dom])
oldAxiomPreCategoryHashCode(catform, env) == hashTypeForm(catform,0)
oldAxiomCategoryDefaultPackage(catform, dom) ==
    hasDefaultPackage opOf catform 

oldAxiomPreCategoryDevaluate([op,:args], env) ==
   SExprToDName([op,:devaluateList args], T)

$oldAxiomPreCategoryDispatch :=
   VECTOR('oldAxiomPreCategory,
          [function oldAxiomPreCategoryDevaluate],
          [nil],
          [nil],
          [function oldAxiomPreCategoryHashCode],
          [function oldAxiomPreCategoryBuild],
          [nil])

oldAxiomCategoryDevaluate([[op,:args],:.], env) ==
   SExprToDName([op,:devaluateList args], T)

oldAxiomPreCategoryParents(catform,dom) ==
  vars := ["$",:rest GETDATABASE(opOf catform, 'CONSTRUCTORFORM)]
  vals := [dom,:rest catform]
  -- parents :=  GETDATABASE(opOf catform, 'PARENTS)
  parents := parentsOf opOf catform
  PROGV(vars, vals,
    LIST2VEC
      [EVAL quoteCatOp cat for [cat,:pred] in parents | EVAL pred])

quoteCatOp cat == 
   atom cat => MKQ cat
   ['LIST, MKQ CAR cat,: CDR cat]


oldAxiomCategoryLookupExport(catenv, self, op, sig, box, env) ==
   [catform,hash, pack,:.] := catenv
   opIsHasCat op => if EQL(sig, hash) then [self] else nil
   NULL(pack) => nil
   if not VECP pack then
       pack:=apply(pack, CONS(self, rest catform))
       RPLACA(CDDR catenv, pack)
   fun := basicLookup(op, sig, pack, self) => [fun]
   nil

oldAxiomCategoryParentCount([.,.,.,parents,.], env) == LENGTH parents
oldAxiomCategoryNthParent([.,.,.,parvec,dom], n, env) ==
  catform := ELT(parvec, n-1)
  VECTORP KAR catform => catform
  newcat := oldAxiomPreCategoryBuild(catform,dom,nil)
  SETELT(parvec, n-1, newcat)
  newcat

oldAxiomCategoryBuild([catform,:.], dom, env) ==
  oldAxiomPreCategoryBuild(catform,dom, env)
oldAxiomCategoryHashCode([.,hash,:.], env) == hash

$oldAxiomCategoryDispatch :=
   VECTOR('oldAxiomCategory,
          [function oldAxiomCategoryDevaluate],
          [nil],
          [function oldAxiomCategoryLookupExport],
          [function oldAxiomCategoryHashCode],
          [function oldAxiomCategoryBuild], -- builder ??
          [function oldAxiomCategoryParentCount],
          [function oldAxiomCategoryNthParent]) -- 1 indexed

attributeDevaluate(attrObj, env) ==
   [name, hash] := attrObj
   StringToCompStr SYMBOL_-NAME name

attributeLookupExport(attrObj, self, op, sig, box, env) ==
   [name, hash] := attrObj
   opIsHasCat op => if EQL(hash, sig) then [self] else nil

attributeHashCode(attrObj, env) ==
   [name, hash] := attrObj
   hash

attributeCategoryBuild(attrObj, dom, env) ==
   [name, hash] := attrObj
   [$attributeDispatch, name, hash] 

attributeCategoryParentCount(attrObj, env) == 0

attributeNthParent(attrObj, env) == nil

$attributeDispatch :=
   VECTOR('attribute,
          [function attributeDevaluate],
          [nil],
          [function attributeLookupExport],
          [function attributeHashCode],
          [function attributeCategoryBuild], -- builder ??
          [function attributeCategoryParentCount],
          [function attributeNthParent]) -- 1 indexed


orderedDefaults(conform,domform) ==
  $depthAssocCache : local := MAKE_-HASHTABLE 'ID
  conList := [x for x in orderCatAnc (op := opOf conform) | hasDefaultPackage op]
  acc := nil
  ancestors := ancestorsOf(conform,domform)
  for x in conList repeat
    for y in ancestors | x = CAAR y repeat acc := [y,:acc]
  NREVERSE acc

instantiate domenv ==
   -- following is a patch for a bug in runtime.as
   -- has a lazy dispatch vector with an instantiated domenv
  VECTORP CDR domenv => [$oldAxiomDomainDispatch ,: domenv]
  callForm := CADR domenv
  oldDom := CDDR domenv
  [functor,:args] := callForm
--  if null(fn := GETL(functor,'instantiate)) then
--     ofn := SYMBOL_-FUNCTION functor
--     loadFunctor functor
--     fn := SYMBOL_-FUNCTION functor
--     SETF(SYMBOL_-FUNCTION functor, ofn)
--     PUT(functor, 'instantiate, fn)
--  domvec := APPLY(fn, args)
  domvec := APPLY(functor, args)
  RPLACA(oldDom, $oldAxiomDomainDispatch)
  RPLACD(oldDom, [CADR oldDom,: domvec])
  oldDom

hashTypeForm([fn,: args], percentHash) == 
   hashType([fn,:devaluateList args], percentHash)

--------------------> NEW DEFINITION (override in i-util.boot.pamphlet)
devaluate(d) ==
  isDomain d =>
      -- ?need a shortcut for old domains
      -- ELT(CAR d, 0) = 'oldAxiomDomain => ...
      -- FIXP(ELT(CAR d,0)) => d
      DNameToSExpr(SPADCALL(CDR d,CAR(d).1))
  not REFVECP d => d
  QSGREATERP(QVSIZE d,5) and QREFELT(d,3) is ['Category] => QREFELT(d,0)
  QSGREATERP(QVSIZE d,0) =>
    d':=QREFELT(d,0)
    isFunctor d' => d'
    d
  d

$hashOp1 := hashString '"1"
$hashOp0 := hashString '"0"
$hashOpApply := hashString '"apply"
$hashOpSet := hashString '"set!"
$hashSeg := hashString '".."
$hashPercent := hashString '"%"

oldAxiomDomainLookupExport _
  (domenv, self, op, sig, box, skipdefaults, env) ==
     domainVec := CDR domenv
     if hashCode? op then
         EQL(op, $hashOp1) => op := 'One
         EQL(op, $hashOp0) => op := 'Zero
         EQL(op, $hashOpApply) => op := 'elt
         EQL(op, $hashOpSet) => op := 'setelt
         EQL(op, $hashSeg) => op := 'SEGMENT
     constant := nil
     if hashCode? sig and self and EQL(sig, getDomainHash self) then
       sig := '($)
       constant := true
     val :=
       skipdefaults => 
          oldCompLookupNoDefaults(op, sig, domainVec, self)
       oldCompLookup(op, sig, domainVec, self)
     null val => val
     if constant then val := SPADCALL val
     RPLACA(box, val)
     box
     
oldAxiomDomainHashCode(domenv, env) == CAR domenv

oldAxiomDomainHasCategory(domenv, cat, env) ==
  HasAttribute(domvec := CDR domenv, cat) or
    HasCategory(domvec, devaluate cat)

oldAxiomDomainDevaluate(domenv, env) == 
   SExprToDName(CDR(domenv).0, 'T)

oldAxiomAddChild(domenv, child, env) == CONS($oldAxiomDomainDispatch, domenv)

$oldAxiomDomainDispatch :=
   VECTOR('oldAxiomDomain,
          [function oldAxiomDomainDevaluate],
          [nil],
	  [function oldAxiomDomainLookupExport],
	  [function oldAxiomDomainHashCode],
          [function oldAxiomAddChild])

--------------------> NEW DEFINITION (see g-util.boot.pamphlet)
isDomain a ==
  PAIRP a and VECP(CAR a) and
    member(CAR(a).0, $domainTypeTokens)

-- following is interpreter interfact to function lookup
-- perhaps it should always work with hashcodes for signature?
--------------------> NEW DEFINITION (override in nrungo.boot.pamphlet)
NRTcompiledLookup(op,sig,dom) ==
  if CONTAINED('_#,sig) then
      sig := [NRTtypeHack t for t in sig]
  hashCode? sig =>   compiledLookupCheck(op,sig,dom)
  (fn := compiledLookup(op,sig,dom)) => fn
  percentHash :=
      VECP dom => hashType(dom.0, 0)
      getDomainHash dom
  compiledLookupCheck(op, hashType(['Mapping,:sig], percentHash), dom)

--------------------> NEW DEFINITION (override in nrungo.boot.pamphlet)
compiledLookup(op, sig, dollar) ==
  if not isDomain dollar then dollar := NRTevalDomain dollar
  basicLookup(op, sig, dollar, dollar)

--------------------> NEW DEFINITION (override in nrungo.boot.pamphlet)
basicLookup(op,sig,domain,dollar) ==
   -- following case is for old domains like Record and Union
   -- or for getting operations out of yourself
  VECP domain =>
     isNewWorldDomain domain => -- getting ops from yourself (or for defaults)
        oldCompLookup(op, sig, domain, dollar)
     -- getting ops from Record or Union
     lookupInDomainVector(op,sig,domain,dollar)
  hashPercent :=
     VECP dollar => hashType(dollar.0,0)
     hashType(dollar,0)
  box := [nil]
  not VECP(dispatch := CAR domain) => error "bad domain format"
  lookupFun := dispatch.3
  dispatch.0 = 0 =>  -- new compiler domain object
       hashSig :=
           hashCode? sig => sig
	   opIsHasCat op => hashType(sig, hashPercent)
           hashType(['Mapping,:sig], hashPercent)

       if SYMBOLP op then
          op = 'Zero => op := $hashOp0
          op = 'One => op := $hashOp1
          op = 'elt => op := $hashOpApply
          op = 'setelt => op := $hashOpSet
          op := hashString SYMBOL_-NAME op
       val:=CAR SPADCALL(CDR domain, dollar, op, hashSig, box, false,
                               lookupFun) => val
       hashCode? sig => nil
       #sig>1 or opIsHasCat op => nil
       boxval := SPADCALL(CDR dollar, dollar, op, hashType(first sig, hashPercent),
                     box, false, lookupFun) =>
          [FUNCTION IDENTITY,: CAR boxval]
       nil
  opIsHasCat op =>
      HasCategory(domain, sig)
  if hashCode? op then
     EQL(op, $hashOp1) => op := 'One
     EQL(op, $hashOp0) => op := 'Zero
     EQL(op, $hashOpApply) => op := 'elt
     EQL(op, $hashOpSet) => op := 'setelt
     EQL(op, $hashSeg) => op := 'SEGMENT
  hashCode? sig and EQL(sig, hashPercent) =>
      SPADCALL CAR SPADCALL(CDR dollar, dollar, op, '($), box, false, lookupFun)
  CAR SPADCALL(CDR dollar, dollar, op, sig, box, false, lookupFun)

basicLookupCheckDefaults(op,sig,domain,dollar) ==
  box := [nil]
  not VECP(dispatch := CAR dollar) => error "bad domain format"
  lookupFun := dispatch.3
  dispatch.0 = 0  =>  -- new compiler domain object
       hashPercent :=
          VECP dollar => hashType(dollar.0,0)
          hashType(dollar,0)

       hashSig :=
         hashCode? sig => sig
         hashType( ['Mapping,:sig], hashPercent)

       if SYMBOLP op then op := hashString SYMBOL_-NAME op
       CAR SPADCALL(CDR dollar, dollar, op, hashSig, box, not $lookupDefaults, lookupFun)
  CAR SPADCALL(CDR dollar, dollar, op, sig, box, not $lookupDefaults, lookupFun)

$hasCatOpHash := hashString '"%%"
opIsHasCat op ==
  hashCode? op => EQL(op, $hasCatOpHash)
  EQ(op, "%%")

-- has cat questions lookup up twice if false
-- replace with following ?
--  not(opIsHasCat op) and
--     (u := lookupInDomainVector(op,sig,domvec,domvec)) => u

oldCompLookup(op, sig, domvec, dollar) ==
  $lookupDefaults:local := nil
  u := lookupInDomainVector(op,sig,domvec,dollar) => u
  $lookupDefaults := true
  lookupInDomainVector(op,sig,domvec,dollar)

oldCompLookupNoDefaults(op, sig, domvec, dollar) ==
  $lookupDefaults:local := nil
  lookupInDomainVector(op,sig,domvec,dollar)

--------------------> NEW DEFINITION (override in nrungo.boot.pamphlet)
lookupInDomainVector(op,sig,domain,dollar) ==
  PAIRP domain => basicLookupCheckDefaults(op,sig,domain,domain)
  slot1 := domain.1
  SPADCALL(op,sig,dollar,slot1)

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lookupComplete(op,sig,dollar,env) ==
   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,nil)
   newLookupInTable(op,sig,dollar,env,nil)
 
--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lookupIncomplete(op,sig,dollar,env) == 
   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,true)
   newLookupInTable(op,sig,dollar,env,true)
 
--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lookupInCompactTable(op,sig,dollar,env) ==
   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,true)
   newLookupInTable(op,sig,dollar,env,true)

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lazyMatchArg2(s,a,dollar,domain,typeFlag) ==
  if s = '$ then
--  a = 0 => return true  --needed only if extra call in newGoGet to basicLookup
    s := devaluate dollar -- calls from HasCategory can have $s
  INTEGERP a =>
    not typeFlag => s = domain.a
    a = 6 and $isDefaultingPackage => s = devaluate dollar
    VECP (d := domainVal(dollar,domain,a)) =>
      s = d.0 => true
      domainArg := ($isDefaultingPackage => domain.6.0; domain.0)
      KAR s = QCAR d.0 and lazyMatchArgDollarCheck(s,d.0,dollar.0,domainArg)
    --VECP CAR d => lazyMatch(s,CDDR d,dollar,domain)      --old style (erase)
    isDomain d =>
        dhash:=getDomainHash d
        dhash =
           (if hashCode? s then s else hashType(s, dhash))
--      s = devaluate d
    lazyMatch(s,d,dollar,domain)                         --new style
  a = '$ => s = devaluate dollar
  a = "$$" => s = devaluate domain
  STRINGP a =>
    STRINGP s => a = s
    s is ['QUOTE,y] and PNAME y = a
    IDENTP s and PNAME s = a
  atom a =>  a = s
  op := opOf a
  op  = 'NRTEVAL => s = nrtEval(CADR a,domain)
  op = 'QUOTE => s = CADR a
  lazyMatch(s,a,dollar,domain)
  --above line is temporarily necessary until system is compiled 8/15/90
--s = a
 
--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
getOpCode(op,vec,max) ==
--search Op vector for "op" returning code if found, nil otherwise
  res := nil
  hashCode? op =>
    for i in 0..max by 2 repeat
      EQL(hashString PNAME QVELT(vec,i),op) => return (res := QSADD1 i)
    res
  for i in 0..max by 2 repeat
    EQ(QVELT(vec,i),op) => return (res := QSADD1 i)
  res

hashNewLookupInTable(op,sig,dollar,[domain,opvec],flag) ==
  opIsHasCat op =>
      HasCategory(domain, sig)
  if hashCode? op and EQL(op, $hashOp1) then op := 'One
  if hashCode? op and EQL(op, $hashOp0) then op := 'Zero
  hashPercent :=
    VECP dollar => hashType(dollar.0,0)
    hashType(dollar,0)
  if hashCode? sig and EQL(sig, hashPercent) then 
         sig := hashType('(Mapping $), hashPercent)
  dollar = nil => systemError()
  $lookupDefaults = true =>
    hashNewLookupInCategories(op,sig,domain,dollar)      --lookup first in my cats
      or newLookupInAddChain(op,sig,domain,dollar)
  --fast path when called from newGoGet
  success := false
  if $monitorNewWorld then
    sayLooking(concat('"---->",form2String devaluate domain,
      '"----> searching op table for:","%l","  "),op,sig,dollar)
  someMatch := false
  numvec := getDomainByteVector domain
  predvec := domain.3
  max := MAXINDEX opvec
  k := getOpCode(op,opvec,max) or return
    flag => newLookupInAddChain(op,sig,domain,dollar)
    nil
  maxIndex := MAXINDEX numvec
  start := ELT(opvec,k)
  finish :=
    QSGREATERP(max,k) => opvec.(QSPLUS(k,2))
    maxIndex
  if QSGREATERP(finish,maxIndex) then systemError '"limit too large"
  numArgs := if hashCode? sig then -1 else (#sig)-1
  success := nil
  $isDefaultingPackage: local :=
    -- use special defaulting handler when dollar non-trivial
    dollar ^= domain and isDefaultPackageForm? devaluate domain
  while finish > start repeat
    PROGN
      i := start
      numTableArgs :=numvec.i
      predIndex := numvec.(i := QSADD1 i)
      (predIndex ^= 0) and null testBitVector(predvec,predIndex) => nil
      exportSig :=
          [newExpandTypeSlot(numvec.(i + j + 1),
            dollar,domain) for j in 0..numTableArgs]
      sig ^= hashType(['Mapping,: exportSig],hashPercent) => nil --signifies no match
      loc := numvec.(i + numTableArgs + 2)
      loc = 1 => (someMatch := true)
      loc = 0 =>
        start := QSPLUS(start,QSPLUS(numTableArgs,4))
        i := start + 2
        someMatch := true --mark so that if subsumption fails, look for original
        subsumptionSig :=
          [newExpandTypeSlot(numvec.(QSPLUS(i,j)),
            dollar,domain) for j in 0..numTableArgs]
        if $monitorNewWorld then
          sayBrightly [formatOpSignature(op,sig),'"--?-->",
            formatOpSignature(op,subsumptionSig)]
        nil
      slot := domain.loc
      null atom slot =>
        EQ(QCAR slot,'newGoGet) => someMatch:=true
                   --treat as if operation were not there
        --if EQ(QCAR slot,'newGoGet) then
        --  UNWIND_-PROTECT --break infinite recursion
        --    ((SETELT(domain,loc,'skip); slot := replaceGoGetSlot QCDR slot),
        --      if domain.loc = 'skip then domain.loc := slot)
        return (success := slot)
      slot = 'skip =>       --recursive call from above 'replaceGoGetSlot
        return (success := newLookupInAddChain(op,sig,domain,dollar))
      systemError '"unexpected format"
    start := QSPLUS(start,QSPLUS(numTableArgs,4))
  (success ^= 'failed) and success =>
    if $monitorNewWorld then
      sayLooking1('"<----",uu) where uu ==
        PAIRP success => [first success,:devaluate rest success]
        success
    success
  subsumptionSig and (u:= basicLookup(op,subsumptionSig,domain,dollar)) => u
  flag or someMatch => newLookupInAddChain(op,sig,domain,dollar)
  nil

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
newExpandLocalType(lazyt,dollar,domain) ==
  VECP lazyt => lazyt.0
  isDomain lazyt => devaluate lazyt
  ATOM lazyt => lazyt
  lazyt is [vec,.,:lazyForm] and VECP vec =>              --old style
    newExpandLocalTypeForm(lazyForm,dollar,domain)
  newExpandLocalTypeForm(lazyt,dollar,domain)             --new style

hashNewLookupInCategories(op,sig,dom,dollar) ==
  slot4 := dom.4
  catVec := CADR slot4
  SIZE catVec = 0 => nil                      --early exit if no categories
  INTEGERP KDR catVec.0 =>
    newLookupInCategories1(op,sig,dom,dollar) --old style
  $lookupDefaults : local := nil
  if $monitorNewWorld = true then sayBrightly concat('"----->",
    form2String devaluate dom,'"-----> searching default packages for ",op)
  predvec := dom.3
  packageVec := QCAR slot4
--the next three lines can go away with new category world
  varList := ['$,:$FormalMapVariableList]
  valueList := [dom,:[dom.(5+i) for i in 1..(# rest dom.0)]]
  valueList := [MKQ val for val in valueList]
  nsig := MSUBST(dom.0,dollar.0,sig)
  for i in 0..MAXINDEX packageVec |
       (entry := packageVec.i) and entry ^= 'T repeat
    package :=
      VECP entry =>
         if $monitorNewWorld then
           sayLooking1('"already instantiated cat package",entry)
         entry
      IDENTP entry =>
        cat := catVec.i
        packageForm := nil
        if not GETL(entry,'LOADED) then loadLib entry
        infovec := GETL(entry,'infovec)
        success :=
          --VECP infovec =>  ----new world
          true =>  ----new world
            opvec := infovec.1
            max := MAXINDEX opvec
            code := getOpCode(op,opvec,max)
            null code => nil
            byteVector := CDDDR infovec.3
            endPos :=
              code+2 > max => SIZE byteVector
              opvec.(code+2)
            --not nrunNumArgCheck(#(QCDR sig),byteVector,opvec.code,endPos) => nil
            --numOfArgs := byteVector.(opvec.code)
            --numOfArgs ^= #(QCDR sig) => nil
            packageForm := [entry,'$,:CDR cat]
            package := evalSlotDomain(packageForm,dom)
            packageVec.i := package
            package
                           ----old world
          table := HGET($Slot1DataBase,entry) or systemError nil
          (u := LASSQ(op,table))
            and (v := or/[rest x for x in u]) =>
              packageForm := [entry,'$,:CDR cat]
              package := evalSlotDomain(packageForm,dom)
              packageVec.i := package
              package
          nil
        null success =>
          if $monitorNewWorld = true then
            sayBrightlyNT '"  not in: "
            pp (packageForm and devaluate package or entry)
          nil
        if $monitorNewWorld then
          sayLooking1('"candidate default package instantiated: ",success)
        success
      entry
    null package => nil
    if $monitorNewWorld then
      sayLooking1('"Looking at instantiated package ",package)
    res := basicLookup(op,sig,package,dollar) =>
      if $monitorNewWorld = true then
        sayBrightly '"candidate default package succeeds"
      return res
    if $monitorNewWorld = true then
      sayBrightly '"candidate fails -- continuing to search categories"
    nil

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
replaceGoGetSlot env ==
  [thisDomain,index,:op] := env
  thisDomainForm := devaluate thisDomain
  bytevec := getDomainByteVector thisDomain
  numOfArgs := bytevec.index
  goGetDomainSlotIndex := bytevec.(index := QSADD1 index)
  goGetDomain :=
     goGetDomainSlotIndex = 0 => thisDomain
     thisDomain.goGetDomainSlotIndex
  if PAIRP goGetDomain and SYMBOLP CAR goGetDomain then
     goGetDomain := lazyDomainSet(goGetDomain,thisDomain,goGetDomainSlotIndex)
  sig :=
    [newExpandTypeSlot(bytevec.(index := QSADD1 index),thisDomain,thisDomain)
      for i in 0..numOfArgs]
  thisSlot := bytevec.(QSADD1 index)
  if $monitorNewWorld then
    sayLooking(concat('"%l","..",form2String thisDomainForm,
      '" wants",'"%l",'"  "),op,sig,goGetDomain)
  slot :=  basicLookup(op,sig,goGetDomain,goGetDomain)
  slot = nil =>
    $returnNowhereFromGoGet = true =>
      ['nowhere,:goGetDomain]  --see newGetDomainOpTable
    sayBrightly concat('"Function: ",formatOpSignature(op,sig),
      '" is missing from domain: ",form2String goGetDomain.0)
    keyedSystemError("S2NR0001",[op,sig,goGetDomain.0])
  if $monitorNewWorld then
    sayLooking1(['"goget stuffing slot",:bright thisSlot,'"of "],thisDomain)
  SETELT(thisDomain,thisSlot,slot)
  if $monitorNewWorld then
    sayLooking1('"<------",[CAR slot,:devaluate CDR slot])
  slot

HasAttribute(domain,attrib) ==
  hashPercent :=
       VECP domain => hashType(domain.0,0)
       hashType(domain,0)
  isDomain domain =>
     FIXP((first domain).0) => 
        -- following call to hashType was missing 2nd arg. 
        -- getDomainHash domain added on 4/01/94 by RSS
        basicLookup("%%",hashType(attrib, hashPercent),domain,domain)
     HasAttribute(CDDR domain, attrib)
-->
  isNewWorldDomain domain => newHasAttribute(domain,attrib)
--+
  (u := LASSOC(attrib,domain.2)) and lookupPred(first u,domain,domain)
 
newHasAttribute(domain,attrib) ==
  hashPercent :=
       VECP domain => hashType(domain.0,0)
       hashType(domain,0)
  predIndex :=
     hashCode? attrib =>
        -- following call to hashType was missing 2nd arg. 
        -- hashPercent added by PAB 15/4/94
        or/[x for x in domain.2 | attrib = hashType(first x, hashPercent)]
     LASSOC(attrib,domain.2)
  predIndex =>
    EQ(predIndex,0) => true
    predvec := domain.3
    testBitVector(predvec,predIndex)
  false

newHasCategory(domain,catform) ==
  catform = '(Type) => true  
  slot4 := domain.4
  auxvec := CAR slot4
  catvec := CADR slot4
  $isDefaultingPackage: local := isDefaultPackageForm? devaluate domain
  #catvec > 0 and INTEGERP KDR catvec.0 =>              --old style
    predIndex := lazyMatchAssocV1(catform,catvec,domain)
    null predIndex => false
    EQ(predIndex,0) => true
    predvec := QVELT(domain,3)
    testBitVector(predvec,predIndex)
  lazyMatchAssocV(catform,auxvec,catvec,domain)         --new style

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lazyMatchAssocV(x,auxvec,catvec,domain) ==      --new style slot4
  n : FIXNUM := MAXINDEX catvec
  -- following call to hashType was missing 2nd arg. 0 added on 3/31/94 by RSS
  hashCode? x =>
    percentHash :=
      VECP domain => hashType(domain.0, 0)
      getDomainHash domain
    or/[ELT(auxvec,i) for i in 0..n |
        x = hashType(newExpandLocalType(QVELT(catvec,i),domain,domain), percentHash)]
  xop := CAR x
  or/[ELT(auxvec,i) for i in 0..n |
    --xop = CAR (lazyt := QVELT(catvec,i)) and lazyMatch(x,lazyt,domain,domain)]
    xop = CAR (lazyt := getCatForm(catvec,i,domain)) and lazyMatch(x,lazyt,domain,domain)]

getCatForm(catvec, index, domain) ==
   NUMBERP(form := QVELT(catvec,index)) => domain.form
   form

has(domain,catform') == HasCategory(domain,catform')

HasCategory(domain,catform') ==
  catform' is ['SIGNATURE,:f] => HasSignature(domain,f)
  catform' is ['ATTRIBUTE,f] => HasAttribute(domain,f)
  isDomain domain =>
     FIXP((first domain).0) =>
        catform' := devaluate catform'
        basicLookup("%%",catform',domain,domain)
     HasCategory(CDDR domain, catform')
  catform:= devaluate catform'
  isNewWorldDomain domain => newHasCategory(domain,catform)
  domain0:=domain.0 -- handles old style domains, Record, Union etc.
  slot4 := domain.4
  catlist := slot4.1
  member(catform,catlist) or
   MEMQ(opOf(catform),'(Object Type)) or  --temporary hack
    or/[compareSigEqual(catform,cat,domain0,domain) for cat in catlist]

--systemDependentMkAutoload(fn,cnam) ==
--    FBOUNDP(cnam) => "next"
--    SETF(SYMBOL_-FUNCTION cnam,mkAutoLoad(fn, cnam))

--------------------> NEW DEFINITION (override in nrunfast.boot.pamphlet)
lazyDomainSet(lazyForm,thisDomain,slot) ==
  form :=
    --lazyForm is [vec,.,:u] and VECP vec => u        --old style
    lazyForm                                        --new style
  slotDomain := evalSlotDomain(form,thisDomain)
  if $monitorNewWorld then
    sayLooking1(concat(form2String devaluate thisDomain,
      '" activating lazy slot ",slot,'": "),slotDomain)
-- name := CAR form
--getInfovec name
  SETELT(thisDomain,slot,slotDomain)


--------------------> NEW DEFINITION (override in template.boot.pamphlet)
evalSlotDomain(u,dollar) ==
  $returnNowhereFromGoGet: local := false
  $ : fluid := dollar
  $lookupDefaults : local := nil -- new world
  isDomain u => u
  u = '$ => dollar
  u = "$$" => dollar
  FIXP u =>
    VECP (y := dollar.u) => y
    isDomain y => y
    y is ['SETELT,:.] => eval y--lazy domains need to marked; this is dangerous?
    y is [v,:.] => 
      VECP v => lazyDomainSet(y,dollar,u)               --old style has [$,code,:lazyt]
      constructor? v or MEMQ(v,'(Record Union Mapping)) => 
        lazyDomainSet(y,dollar,u)                       --new style has lazyt
      y
    y
  u is ['NRTEVAL,y] => 
    y is ['ELT,:.] => evalSlotDomain(y,dollar)
    eval  y
  u is ['QUOTE,y] => y
  u is ['Record,:argl] =>
     FUNCALL('Record0,[[tag,:evalSlotDomain(dom,dollar)]
                                 for [.,tag,dom] in argl])
  u is ['Union,:argl] and first argl is ['_:,.,.] =>
     APPLY('Union,[['_:,tag,evalSlotDomain(dom,dollar)]
                                 for [.,tag,dom] in argl])
  u is ['spadConstant,d,n] =>
    dom := evalSlotDomain(d,dollar)
    SPADCALL(dom . n)
  u is ['ELT,d,n] =>
    dom := evalSlotDomain(d,dollar)
    slot := dom . n
    slot is ['newGoGet,:env] => replaceGoGetSlot env
    slot
  u is [op,:argl] => APPLY(op,[evalSlotDomain(x,dollar) for x in argl])
  systemErrorHere '"evalSlotDomain"
 
--------------------> NEW DEFINITION (override in i-util.boot.pamphlet)
domainEqual(a,b) ==
  devaluate(a) = devaluate(b)

--makeConstructorsAutoLoad()

-- following changes should go back into xrun.boot
-- patched version from xrun.boot
--------------------> NEW DEFINITION (override in clammed.boot.pamphlet)
--------------------> NEW DEFINITION (override in xrun.boot.pamphlet)
coerceConvertMmSelection(funName,m1,m2) ==
  -- calls selectMms with $Coerce=NIL and tests for required
  -- target type. funName is either 'coerce or 'convert.
  $declaredMode : local:= NIL
  $reportBottomUpFlag : local:= NIL
  l := selectMms1(funName,m2,[m1],[m1],NIL)
--  mmS := [[sig,[targ,arg],:pred] for x in l | x is [sig,[.,arg],:pred] and
  mmS := [x for x in l | x is [sig,:.] and hasCorrectTarget(m2,sig) and
      sig is [dc,targ,oarg] and isEqualOrSubDomain(m1,oarg)]
  mmS and CAR mmS

--------------------> NEW DEFINITION (see i-funsel.boot.pamphlet)
getFunctionFromDomain(op,dc,args) ==
  -- finds the function op with argument types args in dc
  -- complains, if no function or ambiguous
  $reportBottomUpFlag:local:= NIL
  member(CAR dc,$nonLisplibDomains) =>
    throwKeyedMsg("S2IF0002",[CAR dc])
  not constructor? CAR dc =>
    throwKeyedMsg("S2IF0003",[CAR dc])
  p:= findFunctionInDomain(op,dc,NIL,args,args,NIL,NIL) =>
--+
    --sig := [NIL,:args]
    domain := evalDomain dc
    for mm in nreverse p until b repeat
      [[.,:osig],nsig,:.] := mm
      b := compiledLookup(op,nsig,domain)
    b or  throwKeyedMsg("S2IS0023",[op,dc])
  throwKeyedMsg("S2IF0004",[op,dc])

@
<<interop.clisp>>=

(IN-PACKAGE "BOOT" )

;-- note domainObjects are now (dispatchVector hashCode . domainVector)
;-- lazy oldAxiomDomainObjects are (dispatchVector hashCode  (Call form) . backptr),
;-- pre oldAxiomCategory is (dispatchVector . (cat form))
;-- oldAxiomCategory objects are (dispatchVector . ( (cat form)  hash defaultpack parentlist))
;
;hashCode? x == INTEGERP x

;;;     ***       |hashCode?| REDEFINED

(DEFUN |hashCode?| (|x|) (INTEGERP |x|)) 
;
;$domainTypeTokens := ['lazyOldAxiomDomain, 'oldAxiomDomain, 'oldAxiomPreCategory,
;           'oldAxiomCategory, 0]

(SPADLET |$domainTypeTokens| (CONS (QUOTE |lazyOldAxiomDomain|) (CONS (QUOTE |oldAxiomDomain|) (CONS (QUOTE |oldAxiomPreCategory|) (CONS (QUOTE |oldAxiomCategory|) (CONS 0 NIL)))))) 
;
;-- The name game.
;-- The compiler produces names that are of the form:
;-- a) cons(0, <string>)
;-- b) cons(1, type-name, arg-names...)
;-- c) cons(2, arg-names...)
;-- d) cons(3, value)
;-- NB: (c) is for tuple-ish constructors,
;--     and (d) is for dependent types.
;
;DNameStringID := 0

(SPADLET |DNameStringID| 0) 
;DNameApplyID  := 1

(SPADLET |DNameApplyID| 1) 
;DNameTupleID  := 2

(SPADLET |DNameTupleID| 2) 
;DNameOtherID  := 3

(SPADLET |DNameOtherID| 3) 
;
;DNameToSExpr1 dname ==
;  NULL dname => error "unexpected domain name"
;  CAR dname = DNameStringID =>
;    INTERN(CompStrToString CDR dname)
;  name0 := DNameToSExpr1 CAR CDR dname
;  args  := CDR CDR dname
;  name0 = '_-_> =>
;    froms := CAR args
;    froms := MAPCAR(function DNameToSExpr, CDR froms)
;    ret   := CAR CDR args -- a tuple
;    ret   := DNameToSExpr CAR CDR ret -- contents
;    CONS('Mapping, CONS(ret, froms))
;  name0 = 'Union or name0 = 'Record =>
;    sxs := MAPCAR(function DNameToSExpr, CDR CAR args)
;    CONS(name0, sxs)
;  name0 = 'Enumeration =>
;    CONS(name0, MAPCAR(function DNameFixEnum, CDR CAR args))
;  CONS(name0, MAPCAR(function DNameToSExpr, args))

;;;     ***       |DNameToSExpr1| REDEFINED

(DEFUN |DNameToSExpr1| (|dname|) (PROG (|name0| |args| |froms| |ret| |sxs|) (RETURN (COND ((NULL |dname|) (|error| (QUOTE |unexpected domain name|))) ((|BOOT-EQUAL| (CAR |dname|) |DNameStringID|) (INTERN (|CompStrToString| (CDR |dname|)))) ((QUOTE T) (SPADLET |name0| (|DNameToSExpr1| (CAR (CDR |dname|)))) (SPADLET |args| (CDR (CDR |dname|))) (COND ((|BOOT-EQUAL| |name0| (QUOTE |->|)) (SPADLET |froms| (CAR |args|)) (SPADLET |froms| (MAPCAR (|function| |DNameToSExpr|) (CDR |froms|))) (SPADLET |ret| (CAR (CDR |args|))) (SPADLET |ret| (|DNameToSExpr| (CAR (CDR |ret|)))) (CONS (QUOTE |Mapping|) (CONS |ret| |froms|))) ((OR (|BOOT-EQUAL| |name0| (QUOTE |Union|)) (|BOOT-EQUAL| |name0| (QUOTE |Record|))) (SPADLET |sxs| (MAPCAR (|function| |DNameToSExpr|) (CDR (CAR |args|)))) (CONS |name0| |sxs|)) ((|BOOT-EQUAL| |name0| (QUOTE |Enumeration|)) (CONS |name0| (MAPCAR (|function| |DNameFixEnum|) (CDR (CAR |args|))))) ((QUOTE T) (CONS |name0| (MAPCAR (|function| |DNameToSExpr|) |args|))))))))) 
;
;DNameToSExpr dname ==
;  CAR dname = DNameOtherID  =>
;        CDR dname
;  sx := DNameToSExpr1 dname
;  CONSP sx => sx
;  LIST sx

;;;     ***       |DNameToSExpr| REDEFINED

(DEFUN |DNameToSExpr| (|dname|) (PROG (|sx|) (RETURN (COND ((|BOOT-EQUAL| (CAR |dname|) |DNameOtherID|) (CDR |dname|)) ((QUOTE T) (SPADLET |sx| (|DNameToSExpr1| |dname|)) (COND ((CONSP |sx|) |sx|) ((QUOTE T) (LIST |sx|)))))))) 
;
;DNameFixEnum arg == CompStrToString CDR arg

;;;     ***       |DNameFixEnum| REDEFINED

(DEFUN |DNameFixEnum| (|arg|) (|CompStrToString| (CDR |arg|))) 
;
;SExprToDName(sexpr, cosigVal) ==
;  -- is it a non-type valued object?
;  NOT cosigVal => [DNameOtherID, :sexpr]
;  if CAR sexpr = '_: then sexpr := CAR CDR CDR sexpr
;  CAR sexpr = 'Mapping =>
;    args := [ SExprToDName(sx, 'T) for sx in CDR sexpr]
;    [DNameApplyID,
;         [DNameStringID,: StringToCompStr '"->"],
;              [DNameTupleID, : CDR args],
;                 [DNameTupleID, CAR args]]
;  name0 :=   [DNameStringID, : StringToCompStr SYMBOL_-NAME CAR sexpr]
;  CAR sexpr = 'Union or CAR sexpr = 'Record =>
;    [DNameApplyID, name0,
;        [DNameTupleID,: [ SExprToDName(sx, 'T) for sx in CDR sexpr]]]
;  newCosig := CDR GETDATABASE(CAR sexpr, QUOTE COSIG)
;  [DNameApplyID, name0,
;   : MAPCAR(function SExprToDName, CDR sexpr, newCosig)]

;;;     ***       |SExprToDName| REDEFINED

(DEFUN |SExprToDName| (|sexpr| |cosigVal|) (PROG (|args| |name0| |newCosig|) (RETURN (SEQ (COND ((NULL |cosigVal|) (CONS |DNameOtherID| |sexpr|)) ((QUOTE T) (COND ((|BOOT-EQUAL| (CAR |sexpr|) (QUOTE |:|)) (SPADLET |sexpr| (CAR (CDR (CDR |sexpr|)))))) (COND ((|BOOT-EQUAL| (CAR |sexpr|) (QUOTE |Mapping|)) (SPADLET |args| (PROG (#1=#:G81913) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81914 (CDR |sexpr|) (CDR #2#)) (|sx| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |sx| (CAR #2#)) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (|SExprToDName| |sx| (QUOTE T)) #1#)))))))) (CONS |DNameApplyID| (CONS (CONS |DNameStringID| (|StringToCompStr| (MAKESTRING "->"))) (CONS (CONS |DNameTupleID| (CDR |args|)) (CONS (CONS |DNameTupleID| (CONS (CAR |args|) NIL)) NIL))))) ((QUOTE T) (SPADLET |name0| (CONS |DNameStringID| (|StringToCompStr| (|SYMBOL-NAME| (CAR |sexpr|))))) (COND ((OR (|BOOT-EQUAL| (CAR |sexpr|) (QUOTE |Union|)) (|BOOT-EQUAL| (CAR |sexpr|) (QUOTE |Record|))) (CONS |DNameApplyID| (CONS |name0| (CONS (CONS |DNameTupleID| (PROG (#3=#:G81911) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G81912 (CDR |sexpr|) (CDR #4#)) (|sx| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |sx| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (|SExprToDName| |sx| (QUOTE T)) #3#)))))))) NIL)))) ((QUOTE T) (SPADLET |newCosig| (CDR (GETDATABASE (CAR |sexpr|) (QUOTE COSIG)))) (CONS |DNameApplyID| (CONS |name0| (MAPCAR (|function| |SExprToDName|) (CDR |sexpr|) |newCosig|))))))))))))) 
;
;-- local garbage because Compiler strings are null terminated
;StringToCompStr(str) ==
;   CONCATENATE(QUOTE STRING, str, STRING (CODE_-CHAR 0))

;;;     ***       |StringToCompStr| REDEFINED

(DEFUN |StringToCompStr| (|str|) (CONCATENATE (QUOTE STRING) |str| (STRING (|CODE-CHAR| 0)))) 
;
;CompStrToString(str) ==
;   SUBSTRING(str, 0, (LENGTH str - 1))

;;;     ***       |CompStrToString| REDEFINED

(DEFUN |CompStrToString| (|str|) (SUBSTRING |str| 0 (SPADDIFFERENCE (LENGTH |str|) 1))) 
;-- local garbage ends
;
;runOldAxiomFunctor(:allArgs) ==
;  [:args,env] := allArgs
;  GETDATABASE(env, 'CONSTRUCTORKIND) = 'category =>
;      [$oldAxiomPreCategoryDispatch,: [env, :args]]
;  dom:=APPLY(env, args)
;  makeOldAxiomDispatchDomain dom

;;;     ***       |runOldAxiomFunctor| REDEFINED

(DEFUN |runOldAxiomFunctor| (|&REST| #1=#:G81915 |&AUX| |allArgs|) (DSETQ |allArgs| #1#) (PROG (|LETTMP#1| |env| |args| |dom|) (RETURN (PROGN (SPADLET |LETTMP#1| (REVERSE |allArgs|)) (SPADLET |env| (CAR |LETTMP#1|)) (SPADLET |args| (NREVERSE (CDR |LETTMP#1|))) (COND ((|BOOT-EQUAL| (GETDATABASE |env| (QUOTE CONSTRUCTORKIND)) (QUOTE |category|)) (CONS |$oldAxiomPreCategoryDispatch| (CONS |env| |args|))) ((QUOTE T) (SPADLET |dom| (APPLY |env| |args|)) (|makeOldAxiomDispatchDomain| |dom|))))))) 
;
;makeLazyOldAxiomDispatchDomain domform ==
;  GETDATABASE(opOf domform, 'CONSTRUCTORKIND) = 'category =>
;      [$oldAxiomPreCategoryDispatch,: domform]
;  dd := [$lazyOldAxiomDomainDispatch, hashTypeForm(domform,0), domform]
;  NCONC(dd,dd) -- installs back pointer to head of domain.
;  dd

;;;     ***       |makeLazyOldAxiomDispatchDomain| REDEFINED

(DEFUN |makeLazyOldAxiomDispatchDomain| (|domform|) (PROG (|dd|) (RETURN (COND ((|BOOT-EQUAL| (GETDATABASE (|opOf| |domform|) (QUOTE CONSTRUCTORKIND)) (QUOTE |category|)) (CONS |$oldAxiomPreCategoryDispatch| |domform|)) ((QUOTE T) (SPADLET |dd| (CONS |$lazyOldAxiomDomainDispatch| (CONS (|hashTypeForm| |domform| 0) (CONS |domform| NIL)))) (NCONC |dd| |dd|) |dd|))))) 
;
;makeOldAxiomDispatchDomain dom ==
;  PAIRP dom => dom
;  [$oldAxiomDomainDispatch,hashTypeForm(dom.0,0),:dom]

;;;     ***       |makeOldAxiomDispatchDomain| REDEFINED

(DEFUN |makeOldAxiomDispatchDomain| (|dom|) (COND ((PAIRP |dom|) |dom|) ((QUOTE T) (CONS |$oldAxiomDomainDispatch| (CONS (|hashTypeForm| (ELT |dom| 0) 0) |dom|))))) 
;
;closeOldAxiomFunctor(name) ==
;   [function runOldAxiomFunctor,:SYMBOL_-FUNCTION name]

;;;     ***       |closeOldAxiomFunctor| REDEFINED

(DEFUN |closeOldAxiomFunctor| (|name|) (CONS (|function| |runOldAxiomFunctor|) (|SYMBOL-FUNCTION| |name|))) 
;
;lazyOldAxiomDomainLookupExport(domenv, self, op, sig, box, skipdefaults, env) ==
;  dom := instantiate domenv
;  SPADCALL(CDR dom, self, op, sig, box, skipdefaults, CAR(dom).3)

;;;     ***       |lazyOldAxiomDomainLookupExport| REDEFINED

(DEFUN |lazyOldAxiomDomainLookupExport| (|domenv| |self| |op| |sig| |box| |skipdefaults| |env|) (PROG (|dom|) (RETURN (PROGN (SPADLET |dom| (|instantiate| |domenv|)) (SPADCALL (CDR |dom|) |self| |op| |sig| |box| |skipdefaults| (ELT (CAR |dom|) 3)))))) 
;
;lazyOldAxiomDomainHashCode(domenv, env) == CAR domenv

;;;     ***       |lazyOldAxiomDomainHashCode| REDEFINED

(DEFUN |lazyOldAxiomDomainHashCode| (|domenv| |env|) (CAR |domenv|)) 
;
;lazyOldAxiomDomainDevaluate(domenv, env) ==
;  dom := instantiate domenv
;  SPADCALL(CDR dom, CAR(dom).1)

;;;     ***       |lazyOldAxiomDomainDevaluate| REDEFINED

(DEFUN |lazyOldAxiomDomainDevaluate| (|domenv| |env|) (PROG (|dom|) (RETURN (PROGN (SPADLET |dom| (|instantiate| |domenv|)) (SPADCALL (CDR |dom|) (ELT (CAR |dom|) 1)))))) 
;
;lazyOldAxiomAddChild(domenv, kid, env) ==
;  CONS($lazyOldAxiomDomainDispatch,domenv)

;;;     ***       |lazyOldAxiomAddChild| REDEFINED

(DEFUN |lazyOldAxiomAddChild| (|domenv| |kid| |env|) (CONS |$lazyOldAxiomDomainDispatch| |domenv|)) 
;
;$lazyOldAxiomDomainDispatch :=
;   VECTOR('lazyOldAxiomDomain,
;          [function lazyOldAxiomDomainDevaluate],
;          [nil],
;          [function lazyOldAxiomDomainLookupExport],
;          [function lazyOldAxiomDomainHashCode],
;          [function lazyOldAxiomAddChild])

(SPADLET |$lazyOldAxiomDomainDispatch| (VECTOR (QUOTE |lazyOldAxiomDomain|) (CONS (|function| |lazyOldAxiomDomainDevaluate|) NIL) (CONS NIL NIL) (CONS (|function| |lazyOldAxiomDomainLookupExport|) NIL) (CONS (|function| |lazyOldAxiomDomainHashCode|) NIL) (CONS (|function| |lazyOldAxiomAddChild|) NIL))) 
;
;-- old Axiom pre category objects are just (dispatch . catform)
;-- where catform is ('categoryname,: evaluated args)
;-- old Axiom category objects are  (dispatch . [catform, hashcode, defaulting package, parent vector, dom])
;oldAxiomPreCategoryBuild(catform, dom, env) ==
;   pack := oldAxiomCategoryDefaultPackage(catform, dom)
;   CONS($oldAxiomCategoryDispatch,
;       [catform, hashTypeForm(catform,0), pack, oldAxiomPreCategoryParents(catform,dom), dom])

;;;     ***       |oldAxiomPreCategoryBuild| REDEFINED

(DEFUN |oldAxiomPreCategoryBuild| (|catform| |dom| |env|) (PROG (|pack|) (RETURN (PROGN (SPADLET |pack| (|oldAxiomCategoryDefaultPackage| |catform| |dom|)) (CONS |$oldAxiomCategoryDispatch| (CONS |catform| (CONS (|hashTypeForm| |catform| 0) (CONS |pack| (CONS (|oldAxiomPreCategoryParents| |catform| |dom|) (CONS |dom| NIL)))))))))) 
;oldAxiomPreCategoryHashCode(catform, env) == hashTypeForm(catform,0)

;;;     ***       |oldAxiomPreCategoryHashCode| REDEFINED

(DEFUN |oldAxiomPreCategoryHashCode| (|catform| |env|) (|hashTypeForm| |catform| 0)) 
;oldAxiomCategoryDefaultPackage(catform, dom) ==
;    hasDefaultPackage opOf catform

;;;     ***       |oldAxiomCategoryDefaultPackage| REDEFINED

(DEFUN |oldAxiomCategoryDefaultPackage| (|catform| |dom|) (|hasDefaultPackage| (|opOf| |catform|))) 
;
;oldAxiomPreCategoryDevaluate([op,:args], env) ==
;   SExprToDName([op,:devaluateList args], T)

;;;     ***       |oldAxiomPreCategoryDevaluate| REDEFINED

(DEFUN |oldAxiomPreCategoryDevaluate| (#1=#:G81916 |env|) (PROG (|op| |args|) (RETURN (PROGN (SPADLET |op| (CAR #1#)) (SPADLET |args| (CDR #1#)) (|SExprToDName| (CONS |op| (|devaluateList| |args|)) |T$|))))) 
;
;$oldAxiomPreCategoryDispatch :=
;   VECTOR('oldAxiomPreCategory,
;          [function oldAxiomPreCategoryDevaluate],
;          [nil],
;          [nil],
;          [function oldAxiomPreCategoryHashCode],
;          [function oldAxiomPreCategoryBuild],
;          [nil])

(SPADLET |$oldAxiomPreCategoryDispatch| (VECTOR (QUOTE |oldAxiomPreCategory|) (CONS (|function| |oldAxiomPreCategoryDevaluate|) NIL) (CONS NIL NIL) (CONS NIL NIL) (CONS (|function| |oldAxiomPreCategoryHashCode|) NIL) (CONS (|function| |oldAxiomPreCategoryBuild|) NIL) (CONS NIL NIL))) 
;
;oldAxiomCategoryDevaluate([[op,:args],:.], env) ==
;   SExprToDName([op,:devaluateList args], T)

;;;     ***       |oldAxiomCategoryDevaluate| REDEFINED

(DEFUN |oldAxiomCategoryDevaluate| (#1=#:G81917 |env|) (PROG (|op| |args|) (RETURN (PROGN (SPADLET |op| (CAAR #1#)) (SPADLET |args| (CDAR #1#)) (|SExprToDName| (CONS |op| (|devaluateList| |args|)) |T$|))))) 
;
;oldAxiomPreCategoryParents(catform,dom) ==
;  vars := ["$",:rest GETDATABASE(opOf catform, 'CONSTRUCTORFORM)]
;  vals := [dom,:rest catform]
;  -- parents :=  GETDATABASE(opOf catform, 'PARENTS)
;  parents := parentsOf opOf catform
;  PROGV(vars, vals,
;    LIST2VEC
;      [EVAL quoteCatOp cat for [cat,:pred] in parents | EVAL pred])

;;;     ***       |oldAxiomPreCategoryParents| REDEFINED

(DEFUN |oldAxiomPreCategoryParents| (|catform| |dom|) (PROG (|vars| |vals| |parents| |cat| |pred|) (RETURN (SEQ (PROGN (SPADLET |vars| (CONS (QUOTE |$|) (CDR (GETDATABASE (|opOf| |catform|) (QUOTE CONSTRUCTORFORM))))) (SPADLET |vals| (CONS |dom| (CDR |catform|))) (SPADLET |parents| (|parentsOf| (|opOf| |catform|))) (PROGV |vars| |vals| (LIST2VEC (PROG (#1=#:G81919) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81920 |parents| (CDR #2#)) (#3=#:G81918 NIL)) ((OR (ATOM #2#) (PROGN (SETQ #3# (CAR #2#)) NIL) (PROGN (PROGN (SPADLET |cat| (CAR #3#)) (SPADLET |pred| (CDR #3#)) #3#) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (COND ((EVAL |pred|) (SETQ #1# (CONS (EVAL (|quoteCatOp| |cat|)) #1#)))))))))))))))) 
;
;quoteCatOp cat ==
;   atom cat => MKQ cat
;   ['LIST, MKQ CAR cat,: CDR cat]

;;;     ***       |quoteCatOp| REDEFINED

(DEFUN |quoteCatOp| (|cat|) (COND ((ATOM |cat|) (MKQ |cat|)) ((QUOTE T) (CONS (QUOTE LIST) (CONS (MKQ (CAR |cat|)) (CDR |cat|)))))) 
;
;
;oldAxiomCategoryLookupExport(catenv, self, op, sig, box, env) ==
;   [catform,hash, pack,:.] := catenv
;   opIsHasCat op => if EQL(sig, hash) then [self] else nil
;   NULL(pack) => nil
;   if not VECP pack then
;       pack:=apply(pack, CONS(self, rest catform))
;       RPLACA(CDDR catenv, pack)
;   fun := basicLookup(op, sig, pack, self) => [fun]
;   nil

;;;     ***       |oldAxiomCategoryLookupExport| REDEFINED

(DEFUN |oldAxiomCategoryLookupExport| (|catenv| |self| |op| |sig| |box| |env|) (PROG (|catform| |hash| |pack| |fun|) (RETURN (PROGN (SPADLET |catform| (CAR |catenv|)) (SPADLET |hash| (CADR |catenv|)) (SPADLET |pack| (CADDR |catenv|)) (COND ((|opIsHasCat| |op|) (COND ((EQL |sig| |hash|) (CONS |self| NIL)) ((QUOTE T) NIL))) ((NULL |pack|) NIL) ((QUOTE T) (COND ((NULL (VECP |pack|)) (SPADLET |pack| (APPLY |pack| (CONS |self| (CDR |catform|)))) (RPLACA (CDDR |catenv|) |pack|))) (COND ((SPADLET |fun| (|basicLookup| |op| |sig| |pack| |self|)) (CONS |fun| NIL)) ((QUOTE T) NIL)))))))) 
;
;oldAxiomCategoryParentCount([.,.,.,parents,.], env) == LENGTH parents

;;;     ***       |oldAxiomCategoryParentCount| REDEFINED

(DEFUN |oldAxiomCategoryParentCount| (#1=#:G81921 |env|) (PROG (|parents|) (RETURN (PROGN (SPADLET |parents| (CADDDR #1#)) (LENGTH |parents|))))) 
;oldAxiomCategoryNthParent([.,.,.,parvec,dom], n, env) ==
;  catform := ELT(parvec, n-1)
;  VECTORP KAR catform => catform
;  newcat := oldAxiomPreCategoryBuild(catform,dom,nil)
;  SETELT(parvec, n-1, newcat)
;  newcat

;;;     ***       |oldAxiomCategoryNthParent| REDEFINED

(DEFUN |oldAxiomCategoryNthParent| (#1=#:G81922 |n| |env|) (PROG (|parvec| |dom| |catform| |newcat|) (RETURN (PROGN (SPADLET |parvec| (CADDDR #1#)) (SPADLET |dom| (CAR (CDDDDR #1#))) (SPADLET |catform| (ELT |parvec| (SPADDIFFERENCE |n| 1))) (COND ((VECTORP (KAR |catform|)) |catform|) ((QUOTE T) (SPADLET |newcat| (|oldAxiomPreCategoryBuild| |catform| |dom| NIL)) (SETELT |parvec| (SPADDIFFERENCE |n| 1) |newcat|) |newcat|)))))) 
;
;oldAxiomCategoryBuild([catform,:.], dom, env) ==
;  oldAxiomPreCategoryBuild(catform,dom, env)

;;;     ***       |oldAxiomCategoryBuild| REDEFINED

(DEFUN |oldAxiomCategoryBuild| (#1=#:G81923 |dom| |env|) (PROG (|catform|) (RETURN (PROGN (SPADLET |catform| (CAR #1#)) (|oldAxiomPreCategoryBuild| |catform| |dom| |env|))))) 
;oldAxiomCategoryHashCode([.,hash,:.], env) == hash

;;;     ***       |oldAxiomCategoryHashCode| REDEFINED

(DEFUN |oldAxiomCategoryHashCode| (#1=#:G81924 |env|) (PROG (|hash|) (RETURN (PROGN (SPADLET |hash| (CADR #1#)) |hash|)))) 
;
;$oldAxiomCategoryDispatch :=
;   VECTOR('oldAxiomCategory,
;          [function oldAxiomCategoryDevaluate],
;          [nil],
;          [function oldAxiomCategoryLookupExport],
;          [function oldAxiomCategoryHashCode],
;          [function oldAxiomCategoryBuild], -- builder ??
;          [function oldAxiomCategoryParentCount],
;          [function oldAxiomCategoryNthParent]) -- 1 indexed

(SPADLET |$oldAxiomCategoryDispatch| (VECTOR (QUOTE |oldAxiomCategory|) (CONS (|function| |oldAxiomCategoryDevaluate|) NIL) (CONS NIL NIL) (CONS (|function| |oldAxiomCategoryLookupExport|) NIL) (CONS (|function| |oldAxiomCategoryHashCode|) NIL) (CONS (|function| |oldAxiomCategoryBuild|) NIL) (CONS (|function| |oldAxiomCategoryParentCount|) NIL) (CONS (|function| |oldAxiomCategoryNthParent|) NIL))) 
;
;
;orderedDefaults(conform,domform) ==
;  $depthAssocCache : local := MAKE_-HASHTABLE 'ID
;  conList := [x for x in orderCatAnc (op := opOf conform) | hasDefaultPackage op]
;  acc := nil
;  ancestors := ancestorsOf(conform,domform)
;  for x in conList repeat
;    for y in ancestors | x = CAAR y repeat acc := [y,:acc]
;  NREVERSE acc

;;;     ***       |orderedDefaults| REDEFINED

(DEFUN |orderedDefaults| (|conform| |domform|) (PROG (|$depthAssocCache| |op| |conList| |ancestors| |acc|) (DECLARE (SPECIAL |$depthAssocCache|)) (RETURN (SEQ (PROGN (SPADLET |$depthAssocCache| (|MAKE-HASHTABLE| (QUOTE ID))) (SPADLET |conList| (PROG (#1=#:G81927) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81928 (|orderCatAnc| (SPADLET |op| (|opOf| |conform|))) (CDR #2#)) (|x| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (COND ((|hasDefaultPackage| |op|) (SETQ #1# (CONS |x| #1#)))))))))) (SPADLET |acc| NIL) (SPADLET |ancestors| (|ancestorsOf| |conform| |domform|)) (DO ((#3=#:G81925 |conList| (CDR #3#)) (|x| NIL)) ((OR (ATOM #3#) (PROGN (SETQ |x| (CAR #3#)) NIL)) NIL) (SEQ (EXIT (DO ((#4=#:G81926 |ancestors| (CDR #4#)) (|y| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |y| (CAR #4#)) NIL)) NIL) (SEQ (EXIT (COND ((|BOOT-EQUAL| |x| (CAAR |y|)) (SPADLET |acc| (CONS |y| |acc|)))))))))) (NREVERSE |acc|)))))) 
;
;instantiate domenv ==
;   -- following is a patch for a bug in runtime.as
;   -- has a lazy dispatch vector with an instantiated domenv
;  VECTORP CDR domenv => [$oldAxiomDomainDispatch ,: domenv]
;  callForm := CADR domenv
;  oldDom := CDDR domenv
;  [functor,:args] := callForm
;--  if null(fn := GET(functor,'instantiate)) then
;--     ofn := SYMBOL_-FUNCTION functor
;--     loadFunctor functor
;--     fn := SYMBOL_-FUNCTION functor
;--     SETF(SYMBOL_-FUNCTION functor, ofn)
;--     PUT(functor, 'instantiate, fn)
;--  domvec := APPLY(fn, args)
;  domvec := APPLY(functor, args)
;  RPLACA(oldDom, $oldAxiomDomainDispatch)
;  RPLACD(oldDom, [CADR oldDom,: domvec])
;  oldDom

;;;     ***       |instantiate| REDEFINED

(DEFUN |instantiate| (|domenv|) (PROG (|callForm| |oldDom| |functor| |args| |domvec|) (RETURN (COND ((VECTORP (CDR |domenv|)) (CONS |$oldAxiomDomainDispatch| |domenv|)) ((QUOTE T) (SPADLET |callForm| (CADR |domenv|)) (SPADLET |oldDom| (CDDR |domenv|)) (SPADLET |functor| (CAR |callForm|)) (SPADLET |args| (CDR |callForm|)) (SPADLET |domvec| (APPLY |functor| |args|)) (RPLACA |oldDom| |$oldAxiomDomainDispatch|) (RPLACD |oldDom| (CONS (CADR |oldDom|) |domvec|)) |oldDom|))))) 
;
;hashTypeForm([fn,: args], percentHash) ==
;   hashType([fn,:devaluateList args], percentHash)

;;;     ***       |hashTypeForm| REDEFINED

(DEFUN |hashTypeForm| (#1=#:G81929 |percentHash|) (PROG (|fn| |args|) (RETURN (PROGN (SPADLET |fn| (CAR #1#)) (SPADLET |args| (CDR #1#)) (|hashType| (CONS |fn| (|devaluateList| |args|)) |percentHash|))))) 
;
;devaluate(d) ==
;  isDomain d =>
;      -- ?need a shortcut for old domains
;      -- ELT(CAR d, 0) = 'oldAxiomDomain => ...
;      -- FIXP(ELT(CAR d,0)) => d
;      DNameToSExpr(SPADCALL(CDR d,CAR(d).1))
;  not REFVECP d => d
;  QSGREATERP(QVSIZE d,5) and QREFELT(d,3) is ['Category] => QREFELT(d,0)
;  QSGREATERP(QVSIZE d,0) =>
;    d':=QREFELT(d,0)
;    isFunctor d' => d'
;    d
;  d

;;;     ***       |devaluate| REDEFINED

(DEFUN |devaluate| (|d|) (PROG (|ISTMP#1| |d'|) (RETURN (COND ((|isDomain| |d|) (|DNameToSExpr| (SPADCALL (CDR |d|) (ELT (CAR |d|) 1)))) ((NULL (REFVECP |d|)) |d|) ((AND (QSGREATERP (QVSIZE |d|) 5) (PROGN (SPADLET |ISTMP#1| (QREFELT |d| 3)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (EQ (QCAR |ISTMP#1|) (QUOTE |Category|))))) (QREFELT |d| 0)) ((QSGREATERP (QVSIZE |d|) 0) (SPADLET |d'| (QREFELT |d| 0)) (COND ((|isFunctor| |d'|) |d'|) ((QUOTE T) |d|))) ((QUOTE T) |d|))))) 
;
;$hashOp1 := hashString '"1"

(SPADLET |$hashOp1| (|hashString| (MAKESTRING "1"))) 
;$hashOp0 := hashString '"0"

(SPADLET |$hashOp0| (|hashString| (MAKESTRING "0"))) 
;$hashOpApply := hashString '"apply"

(SPADLET |$hashOpApply| (|hashString| (MAKESTRING "apply"))) 
;$hashOpSet := hashString '"set!"

(SPADLET |$hashOpSet| (|hashString| (MAKESTRING "set!"))) 
;$hashSeg := hashString '".."

(SPADLET |$hashSeg| (|hashString| (MAKESTRING ".."))) 
;$hashPercent := hashString '"%"

(SPADLET |$hashPercent| (|hashString| (MAKESTRING "%"))) 
;
;oldAxiomDomainLookupExport _
;  (domenv, self, op, sig, box, skipdefaults, env) ==
;     domainVec := CDR domenv
;     if hashCode? op then
;         EQL(op, $hashOp1) => op := 'One
;         EQL(op, $hashOp0) => op := 'Zero
;         EQL(op, $hashOpApply) => op := 'elt
;         EQL(op, $hashOpSet) => op := 'setelt
;         EQL(op, $hashSeg) => op := 'SEGMENT
;     constant := nil
;     if hashCode? sig and self and EQL(sig, getDomainHash self) then
;       sig := '($)
;       constant := true
;     val :=
;       skipdefaults =>
;          oldCompLookupNoDefaults(op, sig, domainVec, self)
;       oldCompLookup(op, sig, domainVec, self)
;     null val => val
;     if constant then val := SPADCALL val
;     RPLACA(box, val)
;     box

;;;     ***       |oldAxiomDomainLookupExport| REDEFINED

(DEFUN |oldAxiomDomainLookupExport| (|domenv| |self| |op| |sig| |box| |skipdefaults| |env|) (PROG (|domainVec| |constant| |val|) (RETURN (PROGN (SPADLET |domainVec| (CDR |domenv|)) (COND ((|hashCode?| |op|) (COND ((EQL |op| |$hashOp1|) (SPADLET |op| (QUOTE |One|))) ((EQL |op| |$hashOp0|) (SPADLET |op| (QUOTE |Zero|))) ((EQL |op| |$hashOpApply|) (SPADLET |op| (QUOTE |elt|))) ((EQL |op| |$hashOpSet|) (SPADLET |op| (QUOTE |setelt|))) ((EQL |op| |$hashSeg|) (SPADLET |op| (QUOTE SEGMENT)))))) (SPADLET |constant| NIL) (COND ((AND (|hashCode?| |sig|) |self| (EQL |sig| (|getDomainHash| |self|))) (SPADLET |sig| (QUOTE (|$|))) (SPADLET |constant| (QUOTE T)))) (SPADLET |val| (COND (|skipdefaults| (|oldCompLookupNoDefaults| |op| |sig| |domainVec| |self|)) ((QUOTE T) (|oldCompLookup| |op| |sig| |domainVec| |self|)))) (COND ((NULL |val|) |val|) ((QUOTE T) (COND (|constant| (SPADLET |val| (SPADCALL |val|)))) (RPLACA |box| |val|) |box|)))))) 
;
;oldAxiomDomainHashCode(domenv, env) == CAR domenv

;;;     ***       |oldAxiomDomainHashCode| REDEFINED

(DEFUN |oldAxiomDomainHashCode| (|domenv| |env|) (CAR |domenv|)) 
;
;oldAxiomDomainHasCategory(domenv, cat, env) ==
;  HasAttribute(domvec := CDR domenv, cat) or
;    HasCategory(domvec, devaluate cat)

;;;     ***       |oldAxiomDomainHasCategory| REDEFINED

(DEFUN |oldAxiomDomainHasCategory| (|domenv| |cat| |env|) (PROG (|domvec|) (RETURN (OR (|HasAttribute| (SPADLET |domvec| (CDR |domenv|)) |cat|) (|HasCategory| |domvec| (|devaluate| |cat|)))))) 
;
;oldAxiomDomainDevaluate(domenv, env) ==
;   SExprToDName(CDR(domenv).0, 'T)

;;;     ***       |oldAxiomDomainDevaluate| REDEFINED

(DEFUN |oldAxiomDomainDevaluate| (|domenv| |env|) (|SExprToDName| (ELT (CDR |domenv|) 0) (QUOTE T))) 
;
;oldAxiomAddChild(domenv, child, env) == CONS($oldAxiomDomainDispatch, domenv)

;;;     ***       |oldAxiomAddChild| REDEFINED

(DEFUN |oldAxiomAddChild| (|domenv| |child| |env|) (CONS |$oldAxiomDomainDispatch| |domenv|)) 
;
;$oldAxiomDomainDispatch :=
;   VECTOR('oldAxiomDomain,
;          [function oldAxiomDomainDevaluate],
;          [nil],
;          [function oldAxiomDomainLookupExport],
;          [function oldAxiomDomainHashCode],
;          [function oldAxiomAddChild])

(SPADLET |$oldAxiomDomainDispatch| (VECTOR (QUOTE |oldAxiomDomain|) (CONS (|function| |oldAxiomDomainDevaluate|) NIL) (CONS NIL NIL) (CONS (|function| |oldAxiomDomainLookupExport|) NIL) (CONS (|function| |oldAxiomDomainHashCode|) NIL) (CONS (|function| |oldAxiomAddChild|) NIL))) 
;
;isDomain a ==
;  PAIRP a and VECP(CAR a) and
;    MEMBER(CAR(a).0, $domainTypeTokens)

;;;     ***       |isDomain| REDEFINED

(DEFUN |isDomain| (|a|) (AND (PAIRP |a|) (VECP (CAR |a|)) (|member| (ELT (CAR |a|) 0) |$domainTypeTokens|))) 
;
;-- following is interpreter interfact to function lookup
;-- perhaps it should always work with hashcodes for signature?
;NRTcompiledLookup(op,sig,dom) ==
;  if CONTAINED('_#,sig) then
;      sig := [NRTtypeHack t for t in sig]
;  hashCode? sig =>   compiledLookupCheck(op,sig,dom)
;  (fn := compiledLookup(op,sig,dom)) => fn
;  percentHash :=
;      VECP dom => hashType(dom.0, 0)
;      getDomainHash dom
;  compiledLookupCheck(op, hashType(['Mapping,:sig], percentHash), dom)

;;;     ***       |NRTcompiledLookup| REDEFINED

(DEFUN |NRTcompiledLookup| (|op| |sig| |dom|) (PROG (|fn| |percentHash|) (RETURN (SEQ (PROGN (COND ((CONTAINED (QUOTE |#|) |sig|) (SPADLET |sig| (PROG (#1=#:G81930) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81931 |sig| (CDR #2#)) (|t| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |t| (CAR #2#)) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (|NRTtypeHack| |t|) #1#)))))))))) (COND ((|hashCode?| |sig|) (|compiledLookupCheck| |op| |sig| |dom|)) ((SPADLET |fn| (|compiledLookup| |op| |sig| |dom|)) |fn|) ((QUOTE T) (SPADLET |percentHash| (COND ((VECP |dom|) (|hashType| (ELT |dom| 0) 0)) ((QUOTE T) (|getDomainHash| |dom|)))) (|compiledLookupCheck| |op| (|hashType| (CONS (QUOTE |Mapping|) |sig|) |percentHash|) |dom|)))))))) 
;
;compiledLookup(op, sig, dollar) ==
;  if not isDomain dollar then dollar := NRTevalDomain dollar
;  basicLookup(op, sig, dollar, dollar)

;;;     ***       |compiledLookup| REDEFINED

(DEFUN |compiledLookup| (|op| |sig| |dollar|) (PROGN (COND ((NULL (|isDomain| |dollar|)) (SPADLET |dollar| (|NRTevalDomain| |dollar|)))) (|basicLookup| |op| |sig| |dollar| |dollar|))) 
;
;basicLookup(op,sig,domain,dollar) ==
;   -- following case is for old domains like Record and Union
;   -- or for getting operations out of yourself
;  VECP domain =>
;     isNewWorldDomain domain => -- getting ops from yourself (or for defaults)
;        oldCompLookup(op, sig, domain, dollar)
;     -- getting ops from Record or Union
;     lookupInDomainVector(op,sig,domain,dollar)
;  hashPercent :=
;     VECP dollar => hashType(dollar.0,0)
;     hashType(dollar,0)
;  box := [nil]
;  not VECP(dispatch := CAR domain) => error "bad domain format"
;  lookupFun := dispatch.3
;  dispatch.0 = 0 =>  -- new compiler domain object
;       hashSig :=
;           hashCode? sig => sig
;           opIsHasCat op => hashType(sig, hashPercent)
;           hashType(['Mapping,:sig], hashPercent)
;
;       if SYMBOLP op then
;          op = 'Zero => op := $hashOp0
;          op = 'One => op := $hashOp1
;          op = 'elt => op := $hashOpApply
;          op = 'setelt => op := $hashOpSet
;          op := hashString SYMBOL_-NAME op
;       val:=CAR SPADCALL(CDR domain, dollar, op, hashSig, box, false,
;                               lookupFun) => val
;       hashCode? sig => nil
;       #sig>1 or opIsHasCat op => nil
;       boxval := SPADCALL(CDR dollar, dollar, op, hashType(first sig, hashPercent),
;                     box, false, lookupFun) =>
;          [FUNCTION IDENTITY,: CAR boxval]
;       nil
;  opIsHasCat op =>
;      HasCategory(domain, sig)
;  if hashCode? op then
;     EQL(op, $hashOp1) => op := 'One
;     EQL(op, $hashOp0) => op := 'Zero
;     EQL(op, $hashOpApply) => op := 'elt
;     EQL(op, $hashOpSet) => op := 'setelt
;     EQL(op, $hashSeg) => op := 'SEGMENT
;  hashCode? sig and EQL(sig, hashPercent) =>
;      SPADCALL CAR SPADCALL(CDR dollar, dollar, op, '($), box, false, lookupFun)
;  CAR SPADCALL(CDR dollar, dollar, op, sig, box, false, lookupFun)

;;;     ***       |basicLookup| REDEFINED

(DEFUN |basicLookup| (|op| |sig| |domain| |dollar|) (PROG (|hashPercent| |box| |dispatch| |lookupFun| |hashSig| |val| |boxval|) (RETURN (COND ((VECP |domain|) (COND ((|isNewWorldDomain| |domain|) (|oldCompLookup| |op| |sig| |domain| |dollar|)) ((QUOTE T) (|lookupInDomainVector| |op| |sig| |domain| |dollar|)))) ((QUOTE T) (SPADLET |hashPercent| (COND ((VECP |dollar|) (|hashType| (ELT |dollar| 0) 0)) ((QUOTE T) (|hashType| |dollar| 0)))) (SPADLET |box| (CONS NIL NIL)) (COND ((NULL (VECP (SPADLET |dispatch| (CAR |domain|)))) (|error| (QUOTE |bad domain format|))) ((QUOTE T) (SPADLET |lookupFun| (ELT |dispatch| 3)) (COND ((EQL (ELT |dispatch| 0) 0) (SPADLET |hashSig| (COND ((|hashCode?| |sig|) |sig|) ((|opIsHasCat| |op|) (|hashType| |sig| |hashPercent|)) ((QUOTE T) (|hashType| (CONS (QUOTE |Mapping|) |sig|) |hashPercent|)))) (COND ((SYMBOLP |op|) (COND ((|BOOT-EQUAL| |op| (QUOTE |Zero|)) (SPADLET |op| |$hashOp0|)) ((|BOOT-EQUAL| |op| (QUOTE |One|)) (SPADLET |op| |$hashOp1|)) ((|BOOT-EQUAL| |op| (QUOTE |elt|)) (SPADLET |op| |$hashOpApply|)) ((|BOOT-EQUAL| |op| (QUOTE |setelt|)) (SPADLET |op| |$hashOpSet|)) ((QUOTE T) (SPADLET |op| (|hashString| (|SYMBOL-NAME| |op|))))))) (COND ((SPADLET |val| (CAR (SPADCALL (CDR |domain|) |dollar| |op| |hashSig| |box| NIL |lookupFun|))) |val|) ((|hashCode?| |sig|) NIL) ((OR (|>| (|#| |sig|) 1) (|opIsHasCat| |op|)) NIL) ((SPADLET |boxval| (SPADCALL (CDR |dollar|) |dollar| |op| (|hashType| (CAR |sig|) |hashPercent|) |box| NIL |lookupFun|)) (CONS (FUNCTION IDENTITY) (CAR |boxval|))) ((QUOTE T) NIL))) ((|opIsHasCat| |op|) (|HasCategory| |domain| |sig|)) ((QUOTE T) (COND ((|hashCode?| |op|) (COND ((EQL |op| |$hashOp1|) (SPADLET |op| (QUOTE |One|))) ((EQL |op| |$hashOp0|) (SPADLET |op| (QUOTE |Zero|))) ((EQL |op| |$hashOpApply|) (SPADLET |op| (QUOTE |elt|))) ((EQL |op| |$hashOpSet|) (SPADLET |op| (QUOTE |setelt|))) ((EQL |op| |$hashSeg|) (SPADLET |op| (QUOTE SEGMENT)))))) (COND ((AND (|hashCode?| |sig|) (EQL |sig| |hashPercent|)) (SPADCALL (CAR (SPADCALL (CDR |dollar|) |dollar| |op| (QUOTE (|$|)) |box| NIL |lookupFun|)))) ((QUOTE T) (CAR (SPADCALL (CDR |dollar|) |dollar| |op| |sig| |box| NIL |lookupFun|))))))))))))) 
;
;basicLookupCheckDefaults(op,sig,domain,dollar) ==
;  box := [nil]
;  not VECP(dispatch := CAR dollar) => error "bad domain format"
;  lookupFun := dispatch.3
;  dispatch.0 = 0  =>  -- new compiler domain object
;       hashPercent :=
;          VECP dollar => hashType(dollar.0,0)
;          hashType(dollar,0)
;
;       hashSig :=
;         hashCode? sig => sig
;         hashType( ['Mapping,:sig], hashPercent)
;
;       if SYMBOLP op then op := hashString SYMBOL_-NAME op
;       CAR SPADCALL(CDR dollar, dollar, op, hashSig, box, not $lookupDefaults, lookupFun)
;  CAR SPADCALL(CDR dollar, dollar, op, sig, box, not $lookupDefaults, lookupFun)

;;;     ***       |basicLookupCheckDefaults| REDEFINED

(DEFUN |basicLookupCheckDefaults| (|op| |sig| |domain| |dollar|) (PROG (|box| |dispatch| |lookupFun| |hashPercent| |hashSig|) (RETURN (PROGN (SPADLET |box| (CONS NIL NIL)) (COND ((NULL (VECP (SPADLET |dispatch| (CAR |dollar|)))) (|error| (QUOTE |bad domain format|))) ((QUOTE T) (SPADLET |lookupFun| (ELT |dispatch| 3)) (COND ((EQL (ELT |dispatch| 0) 0) (SPADLET |hashPercent| (COND ((VECP |dollar|) (|hashType| (ELT |dollar| 0) 0)) ((QUOTE T) (|hashType| |dollar| 0)))) (SPADLET |hashSig| (COND ((|hashCode?| |sig|) |sig|) ((QUOTE T) (|hashType| (CONS (QUOTE |Mapping|) |sig|) |hashPercent|)))) (COND ((SYMBOLP |op|) (SPADLET |op| (|hashString| (|SYMBOL-NAME| |op|))))) (CAR (SPADCALL (CDR |dollar|) |dollar| |op| |hashSig| |box| (NULL |$lookupDefaults|) |lookupFun|))) ((QUOTE T) (CAR (SPADCALL (CDR |dollar|) |dollar| |op| |sig| |box| (NULL |$lookupDefaults|) |lookupFun|)))))))))) 
;
;$hasCatOpHash := hashString '"%%"

(SPADLET |$hasCatOpHash| (|hashString| (MAKESTRING "%%"))) 
;opIsHasCat op ==
;  hashCode? op => EQL(op, $hasCatOpHash)
;  EQ(op, "%%")

;;;     ***       |opIsHasCat| REDEFINED

(DEFUN |opIsHasCat| (|op|) (COND ((|hashCode?| |op|) (EQL |op| |$hasCatOpHash|)) ((QUOTE T) (EQ |op| (QUOTE |%%|))))) 
;
;-- has cat questions lookup up twice if false
;-- replace with following ?
;--  not(opIsHasCat op) and
;--     (u := lookupInDomainVector(op,sig,domvec,domvec)) => u
;
;oldCompLookup(op, sig, domvec, dollar) ==
;  $lookupDefaults:local := nil
;  u := lookupInDomainVector(op,sig,domvec,dollar) => u
;  $lookupDefaults := true
;  lookupInDomainVector(op,sig,domvec,dollar)

;;;     ***       |oldCompLookup| REDEFINED

(DEFUN |oldCompLookup| (|op| |sig| |domvec| |dollar|) (PROG (|$lookupDefaults| |u|) (DECLARE (SPECIAL |$lookupDefaults|)) (RETURN (PROGN (SPADLET |$lookupDefaults| NIL) (COND ((SPADLET |u| (|lookupInDomainVector| |op| |sig| |domvec| |dollar|)) |u|) ((QUOTE T) (SPADLET |$lookupDefaults| (QUOTE T)) (|lookupInDomainVector| |op| |sig| |domvec| |dollar|))))))) 
;
;oldCompLookupNoDefaults(op, sig, domvec, dollar) ==
;  $lookupDefaults:local := nil
;  lookupInDomainVector(op,sig,domvec,dollar)

;;;     ***       |oldCompLookupNoDefaults| REDEFINED

(DEFUN |oldCompLookupNoDefaults| (|op| |sig| |domvec| |dollar|) (PROG (|$lookupDefaults|) (DECLARE (SPECIAL |$lookupDefaults|)) (RETURN (PROGN (SPADLET |$lookupDefaults| NIL) (|lookupInDomainVector| |op| |sig| |domvec| |dollar|))))) 
;
;lookupInDomainVector(op,sig,domain,dollar) ==
;  PAIRP domain => basicLookupCheckDefaults(op,sig,domain,domain)
;  slot1 := domain.1
;  SPADCALL(op,sig,dollar,slot1)

;;;     ***       |lookupInDomainVector| REDEFINED

(DEFUN |lookupInDomainVector| (|op| |sig| |domain| |dollar|) (PROG (|slot1|) (RETURN (COND ((PAIRP |domain|) (|basicLookupCheckDefaults| |op| |sig| |domain| |domain|)) ((QUOTE T) (SPADLET |slot1| (ELT |domain| 1)) (SPADCALL |op| |sig| |dollar| |slot1|)))))) 
;
;lookupComplete(op,sig,dollar,env) ==
;   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,nil)
;   newLookupInTable(op,sig,dollar,env,nil)

;;;     ***       |lookupComplete| REDEFINED

(DEFUN |lookupComplete| (|op| |sig| |dollar| |env|) (COND ((|hashCode?| |sig|) (|hashNewLookupInTable| |op| |sig| |dollar| |env| NIL)) ((QUOTE T) (|newLookupInTable| |op| |sig| |dollar| |env| NIL)))) 
;
;lookupIncomplete(op,sig,dollar,env) ==
;   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,true)
;   newLookupInTable(op,sig,dollar,env,true)

;;;     ***       |lookupIncomplete| REDEFINED

(DEFUN |lookupIncomplete| (|op| |sig| |dollar| |env|) (COND ((|hashCode?| |sig|) (|hashNewLookupInTable| |op| |sig| |dollar| |env| (QUOTE T))) ((QUOTE T) (|newLookupInTable| |op| |sig| |dollar| |env| (QUOTE T))))) 
;
;lookupInCompactTable(op,sig,dollar,env) ==
;   hashCode? sig => hashNewLookupInTable(op,sig,dollar,env,true)
;   newLookupInTable(op,sig,dollar,env,true)

;;;     ***       |lookupInCompactTable| REDEFINED

(DEFUN |lookupInCompactTable| (|op| |sig| |dollar| |env|) (COND ((|hashCode?| |sig|) (|hashNewLookupInTable| |op| |sig| |dollar| |env| (QUOTE T))) ((QUOTE T) (|newLookupInTable| |op| |sig| |dollar| |env| (QUOTE T))))) 
;
;lazyMatchArg2(s,a,dollar,domain,typeFlag) ==
;  if s = '$ then
;--  a = 0 => return true  --needed only if extra call in newGoGet to basicLookup
;    s := devaluate dollar -- calls from HasCategory can have $s
;  INTEGERP a =>
;    not typeFlag => s = domain.a
;    a = 6 and $isDefaultingPackage => s = devaluate dollar
;    VECP (d := domainVal(dollar,domain,a)) =>
;      s = d.0 => true
;      domainArg := ($isDefaultingPackage => domain.6.0; domain.0)
;      KAR s = QCAR d.0 and lazyMatchArgDollarCheck(s,d.0,dollar.0,domainArg)
;    --VECP CAR d => lazyMatch(s,CDDR d,dollar,domain)      --old style (erase)
;    isDomain d =>
;        dhash:=getDomainHash d
;        dhash =
;           (if hashCode? s then s else hashType(s, dhash))
;--      s = devaluate d
;    lazyMatch(s,d,dollar,domain)                         --new style
;  a = '$ => s = devaluate dollar
;  a = "$$" => s = devaluate domain
;  STRINGP a =>
;    STRINGP s => a = s
;    s is ['QUOTE,y] and PNAME y = a
;    IDENTP s and PNAME s = a
;  atom a =>  a = s
;  op := opOf a
;  op  = 'NRTEVAL => s = nrtEval(CADR a,domain)
;  op = 'QUOTE => s = CADR a
;  lazyMatch(s,a,dollar,domain)

;;;     ***       |lazyMatchArg2| REDEFINED

(DEFUN |lazyMatchArg2| (|s| |a| |dollar| |domain| |typeFlag|) (PROG (|d| |domainArg| |dhash| |ISTMP#1| |y| |op|) (RETURN (PROGN (COND ((|BOOT-EQUAL| |s| (QUOTE |$|)) (SPADLET |s| (|devaluate| |dollar|)))) (COND ((INTEGERP |a|) (COND ((NULL |typeFlag|) (|BOOT-EQUAL| |s| (ELT |domain| |a|))) ((AND (EQL |a| 6) |$isDefaultingPackage|) (|BOOT-EQUAL| |s| (|devaluate| |dollar|))) ((VECP (SPADLET |d| (|domainVal| |dollar| |domain| |a|))) (COND ((|BOOT-EQUAL| |s| (ELT |d| 0)) (QUOTE T)) ((QUOTE T) (SPADLET |domainArg| (COND (|$isDefaultingPackage| (ELT (ELT |domain| 6) 0)) ((QUOTE T) (ELT |domain| 0)))) (AND (|BOOT-EQUAL| (KAR |s|) (QCAR (ELT |d| 0))) (|lazyMatchArgDollarCheck| |s| (ELT |d| 0) (ELT |dollar| 0) |domainArg|))))) ((|isDomain| |d|) (SPADLET |dhash| (|getDomainHash| |d|)) (|BOOT-EQUAL| |dhash| (COND ((|hashCode?| |s|) |s|) ((QUOTE T) (|hashType| |s| |dhash|))))) ((QUOTE T) (|lazyMatch| |s| |d| |dollar| |domain|)))) ((|BOOT-EQUAL| |a| (QUOTE |$|)) (|BOOT-EQUAL| |s| (|devaluate| |dollar|))) ((|BOOT-EQUAL| |a| (QUOTE |$$|)) (|BOOT-EQUAL| |s| (|devaluate| |domain|))) ((STRINGP |a|) (COND ((STRINGP |s|) (|BOOT-EQUAL| |a| |s|)) ((QUOTE T) (AND (PAIRP |s|) (EQ (QCAR |s|) (QUOTE QUOTE)) (PROGN (SPADLET |ISTMP#1| (QCDR |s|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T)))) (|BOOT-EQUAL| (PNAME |y|) |a|)) (AND (IDENTP |s|) (|BOOT-EQUAL| (PNAME |s|) |a|))))) ((ATOM |a|) (|BOOT-EQUAL| |a| |s|)) ((QUOTE T) (SPADLET |op| (|opOf| |a|)) (COND ((|BOOT-EQUAL| |op| (QUOTE NRTEVAL)) (|BOOT-EQUAL| |s| (|nrtEval| (CADR |a|) |domain|))) ((|BOOT-EQUAL| |op| (QUOTE QUOTE)) (|BOOT-EQUAL| |s| (CADR |a|))) ((QUOTE T) (|lazyMatch| |s| |a| |dollar| |domain|))))))))) 
;  --above line is temporarily necessary until system is compiled 8/15/90
;--s = a
;
;getOpCode(op,vec,max) ==
;--search Op vector for "op" returning code if found, nil otherwise
;  res := nil
;  hashCode? op =>
;    for i in 0..max by 2 repeat
;      EQL(hashString PNAME QVELT(vec,i),op) => return (res := QSADD1 i)
;    res
;  for i in 0..max by 2 repeat
;    EQ(QVELT(vec,i),op) => return (res := QSADD1 i)
;  res

;;;     ***       |getOpCode| REDEFINED

(DEFUN |getOpCode| (|op| |vec| |max|) (PROG (|res|) (RETURN (SEQ (PROGN (SPADLET |res| NIL) (COND ((|hashCode?| |op|) (SEQ (DO ((|i| 0 (|+| |i| 2))) ((|>| |i| |max|) NIL) (SEQ (EXIT (COND ((EQL (|hashString| (PNAME (QVELT |vec| |i|))) |op|) (EXIT (RETURN (SPADLET |res| (QSADD1 |i|))))))))) (EXIT |res|))) ((QUOTE T) (SEQ (DO ((|i| 0 (|+| |i| 2))) ((|>| |i| |max|) NIL) (SEQ (EXIT (COND ((EQ (QVELT |vec| |i|) |op|) (EXIT (RETURN (SPADLET |res| (QSADD1 |i|))))))))) (EXIT |res|))))))))) 
;
;hashNewLookupInTable(op,sig,dollar,[domain,opvec],flag) ==
;  opIsHasCat op =>
;      HasCategory(domain, sig)
;  if hashCode? op and EQL(op, $hashOp1) then op := 'One
;  if hashCode? op and EQL(op, $hashOp0) then op := 'Zero
;  hashPercent :=
;    VECP dollar => hashType(dollar.0,0)
;    hashType(dollar,0)
;  if hashCode? sig and EQL(sig, hashPercent) then
;         sig := hashType('(Mapping $), hashPercent)
;  dollar = nil => systemError()
;  $lookupDefaults = true =>
;    hashNewLookupInCategories(op,sig,domain,dollar)      --lookup first in my cats
;      or newLookupInAddChain(op,sig,domain,dollar)
;  --fast path when called from newGoGet
;  success := false
;  if $monitorNewWorld then
;    sayLooking(concat('"---->",form2String devaluate domain,
;      '"----> searching op table for:","%l","  "),op,sig,dollar)
;  someMatch := false
;  numvec := getDomainByteVector domain
;  predvec := domain.3
;  max := MAXINDEX opvec
;  k := getOpCode(op,opvec,max) or return
;    flag => newLookupInAddChain(op,sig,domain,dollar)
;    nil
;  maxIndex := MAXINDEX numvec
;  start := ELT(opvec,k)
;  finish :=
;    QSGREATERP(max,k) => opvec.(QSPLUS(k,2))
;    maxIndex
;  if QSGREATERP(finish,maxIndex) then systemError '"limit too large"
;  numArgs := if hashCode? sig then -1 else (#sig)-1
;  success := nil
;  $isDefaultingPackage: local :=
;    -- use special defaulting handler when dollar non-trivial
;    dollar ^= domain and isDefaultPackageForm? devaluate domain
;  while finish > start repeat
;    PROGN
;      i := start
;      numTableArgs :=numvec.i
;      predIndex := numvec.(i := QSADD1 i)
;      NE(predIndex,0) and null testBitVector(predvec,predIndex) => nil
;      exportSig :=
;          [newExpandTypeSlot(numvec.(i + j + 1),
;            dollar,domain) for j in 0..numTableArgs]
;      sig ^= hashType(['Mapping,: exportSig],hashPercent) => nil --signifies no match
;      loc := numvec.(i + numTableArgs + 2)
;      loc = 1 => (someMatch := true)
;      loc = 0 =>
;        start := QSPLUS(start,QSPLUS(numTableArgs,4))
;        i := start + 2
;        someMatch := true --mark so that if subsumption fails, look for original
;        subsumptionSig :=
;          [newExpandTypeSlot(numvec.(QSPLUS(i,j)),
;            dollar,domain) for j in 0..numTableArgs]
;        if $monitorNewWorld then
;          sayBrightly [formatOpSignature(op,sig),'"--?-->",
;            formatOpSignature(op,subsumptionSig)]
;        nil
;      slot := domain.loc
;      null atom slot =>
;        EQ(QCAR slot,'newGoGet) => someMatch:=true
;                   --treat as if operation were not there
;        --if EQ(QCAR slot,'newGoGet) then
;        --  UNWIND_-PROTECT --break infinite recursion
;        --    ((SETELT(domain,loc,'skip); slot := replaceGoGetSlot QCDR slot),
;        --      if domain.loc = 'skip then domain.loc := slot)
;        return (success := slot)
;      slot = 'skip =>       --recursive call from above 'replaceGoGetSlot
;        return (success := newLookupInAddChain(op,sig,domain,dollar))
;      systemError '"unexpected format"
;    start := QSPLUS(start,QSPLUS(numTableArgs,4))
;  NE(success,'failed) and success =>
;    if $monitorNewWorld then
;      sayLooking1('"<----",uu) where uu ==
;        PAIRP success => [first success,:devaluate rest success]
;        success
;    success
;  subsumptionSig and (u:= basicLookup(op,subsumptionSig,domain,dollar)) => u
;  flag or someMatch => newLookupInAddChain(op,sig,domain,dollar)
;  nil

;;;     ***       |hashNewLookupInTable| REDEFINED

(DEFUN |hashNewLookupInTable| (|op| |sig| |dollar| #1=#:G81932 |flag|) (PROG (|$isDefaultingPackage| |domain| |opvec| |hashPercent| |numvec| |predvec| |max| |k| |maxIndex| |finish| |numArgs| |numTableArgs| |predIndex| |exportSig| |loc| |i| |subsumptionSig| |slot| |someMatch| |success| |start| |u|) (DECLARE (SPECIAL |$isDefaultingPackage|)) (RETURN (SEQ (PROGN (SPADLET |domain| (CAR #1#)) (SPADLET |opvec| (CADR #1#)) (COND ((|opIsHasCat| |op|) (|HasCategory| |domain| |sig|)) ((QUOTE T) (COND ((AND (|hashCode?| |op|) (EQL |op| |$hashOp1|)) (SPADLET |op| (QUOTE |One|)))) (COND ((AND (|hashCode?| |op|) (EQL |op| |$hashOp0|)) (SPADLET |op| (QUOTE |Zero|)))) (SPADLET |hashPercent| (COND ((VECP |dollar|) (|hashType| (ELT |dollar| 0) 0)) ((QUOTE T) (|hashType| |dollar| 0)))) (COND ((AND (|hashCode?| |sig|) (EQL |sig| |hashPercent|)) (SPADLET |sig| (|hashType| (QUOTE (|Mapping| |$|)) |hashPercent|)))) (COND ((NULL |dollar|) (|systemError|)) ((|BOOT-EQUAL| |$lookupDefaults| (QUOTE T)) (OR (|hashNewLookupInCategories| |op| |sig| |domain| |dollar|) (|newLookupInAddChain| |op| |sig| |domain| |dollar|))) ((QUOTE T) (SPADLET |success| NIL) (COND (|$monitorNewWorld| (|sayLooking| (|concat| (MAKESTRING "---->") (|form2String| (|devaluate| |domain|)) (MAKESTRING "----> searching op table for:") (QUOTE |%l|) (QUOTE |  |)) |op| |sig| |dollar|))) (SPADLET |someMatch| NIL) (SPADLET |numvec| (|getDomainByteVector| |domain|)) (SPADLET |predvec| (ELT |domain| 3)) (SPADLET |max| (MAXINDEX |opvec|)) (SPADLET |k| (OR (|getOpCode| |op| |opvec| |max|) (RETURN (COND (|flag| (|newLookupInAddChain| |op| |sig| |domain| |dollar|)) ((QUOTE T) NIL))))) (SPADLET |maxIndex| (MAXINDEX |numvec|)) (SPADLET |start| (ELT |opvec| |k|)) (SPADLET |finish| (COND ((QSGREATERP |max| |k|) (ELT |opvec| (QSPLUS |k| 2))) ((QUOTE T) |maxIndex|))) (COND ((QSGREATERP |finish| |maxIndex|) (|systemError| (MAKESTRING "limit too large")))) (SPADLET |numArgs| (COND ((|hashCode?| |sig|) (SPADDIFFERENCE 1)) ((QUOTE T) (SPADDIFFERENCE (|#| |sig|) 1)))) (SPADLET |success| NIL) (SPADLET |$isDefaultingPackage| (AND (NEQUAL |dollar| |domain|) (|isDefaultPackageForm?| (|devaluate| |domain|)))) (DO NIL ((NULL (|>| |finish| |start|)) NIL) (SEQ (EXIT (PROGN (SPADLET |i| |start|) (SPADLET |numTableArgs| (ELT |numvec| |i|)) (SPADLET |predIndex| (ELT |numvec| (SPADLET |i| (QSADD1 |i|)))) (COND ((AND (NE |predIndex| 0) (NULL (|testBitVector| |predvec| |predIndex|))) NIL) ((QUOTE T) (SPADLET |exportSig| (PROG (#2=#:G81934) (SPADLET #2# NIL) (RETURN (DO ((|j| 0 (QSADD1 |j|))) ((QSGREATERP |j| |numTableArgs|) (NREVERSE0 #2#)) (SEQ (EXIT (SETQ #2# (CONS (|newExpandTypeSlot| (ELT |numvec| (PLUS (PLUS |i| |j|) 1)) |dollar| |domain|) #2#)))))))) (COND ((NEQUAL |sig| (|hashType| (CONS (QUOTE |Mapping|) |exportSig|) |hashPercent|)) NIL) ((QUOTE T) (SPADLET |loc| (ELT |numvec| (PLUS (PLUS |i| |numTableArgs|) 2))) (COND ((EQL |loc| 1) (SPADLET |someMatch| (QUOTE T))) ((EQL |loc| 0) (SPADLET |start| (QSPLUS |start| (QSPLUS |numTableArgs| 4))) (SPADLET |i| (PLUS |start| 2)) (SPADLET |someMatch| (QUOTE T)) (SPADLET |subsumptionSig| (PROG (#3=#:G81933) (SPADLET #3# NIL) (RETURN (DO ((|j| 0 (QSADD1 |j|))) ((QSGREATERP |j| |numTableArgs|) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (|newExpandTypeSlot| (ELT |numvec| (QSPLUS |i| |j|)) |dollar| |domain|) #3#)))))))) (COND (|$monitorNewWorld| (|sayBrightly| (CONS (|formatOpSignature| |op| |sig|) (CONS (MAKESTRING "--?-->") (CONS (|formatOpSignature| |op| |subsumptionSig|) NIL)))))) NIL) ((QUOTE T) (SPADLET |slot| (ELT |domain| |loc|)) (COND ((NULL (ATOM |slot|)) (COND ((EQ (QCAR |slot|) (QUOTE |newGoGet|)) (SPADLET |someMatch| (QUOTE T))) ((QUOTE T) (RETURN (SPADLET |success| |slot|))))) ((|BOOT-EQUAL| |slot| (QUOTE |skip|)) (RETURN (SPADLET |success| (|newLookupInAddChain| |op| |sig| |domain| |dollar|)))) ((QUOTE T) (|systemError| (MAKESTRING "unexpected format")))))))))) (SPADLET |start| (QSPLUS |start| (QSPLUS |numTableArgs| 4))))))) (COND ((AND (NE |success| (QUOTE |failed|)) |success|) (COND (|$monitorNewWorld| (|sayLooking1| (MAKESTRING "<----") (COND ((PAIRP |success|) (CONS (CAR |success|) (|devaluate| (CDR |success|)))) ((QUOTE T) |success|))))) |success|) ((AND |subsumptionSig| (SPADLET |u| (|basicLookup| |op| |subsumptionSig| |domain| |dollar|))) |u|) ((OR |flag| |someMatch|) (|newLookupInAddChain| |op| |sig| |domain| |dollar|)) ((QUOTE T) NIL))))))))))) 
;
;newExpandLocalType(lazyt,dollar,domain) ==
;  VECP lazyt => lazyt.0
;  isDomain lazyt => devaluate lazyt
;  ATOM lazyt => lazyt
;  lazyt is [vec,.,:lazyForm] and VECP vec =>              --old style
;    newExpandLocalTypeForm(lazyForm,dollar,domain)
;  newExpandLocalTypeForm(lazyt,dollar,domain)             --new style

;;;     ***       |newExpandLocalType| REDEFINED

(DEFUN |newExpandLocalType| (|lazyt| |dollar| |domain|) (PROG (|vec| |ISTMP#1| |lazyForm|) (RETURN (COND ((VECP |lazyt|) (ELT |lazyt| 0)) ((|isDomain| |lazyt|) (|devaluate| |lazyt|)) ((ATOM |lazyt|) |lazyt|) ((AND (PAIRP |lazyt|) (PROGN (SPADLET |vec| (QCAR |lazyt|)) (SPADLET |ISTMP#1| (QCDR |lazyt|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |lazyForm| (QCDR |ISTMP#1|)) (QUOTE T)))) (VECP |vec|)) (|newExpandLocalTypeForm| |lazyForm| |dollar| |domain|)) ((QUOTE T) (|newExpandLocalTypeForm| |lazyt| |dollar| |domain|)))))) 
;
;hashNewLookupInCategories(op,sig,dom,dollar) ==
;  slot4 := dom.4
;  catVec := CADR slot4
;  SIZE catVec = 0 => nil                      --early exit if no categories
;  INTEGERP KDR catVec.0 =>
;    newLookupInCategories1(op,sig,dom,dollar) --old style
;  $lookupDefaults : local := nil
;  if $monitorNewWorld = true then sayBrightly concat('"----->",
;    form2String devaluate dom,'"-----> searching default packages for ",op)
;  predvec := dom.3
;  packageVec := QCAR slot4
;--the next three lines can go away with new category world
;  varList := ['$,:$FormalMapVariableList]
;  valueList := [dom,:[dom.(5+i) for i in 1..(# rest dom.0)]]
;  valueList := [MKQ val for val in valueList]
;  nsig := MSUBST(dom.0,dollar.0,sig)
;  for i in 0..MAXINDEX packageVec |
;       (entry := packageVec.i) and entry ^= 'T repeat
;    package :=
;      VECP entry =>
;         if $monitorNewWorld then
;           sayLooking1('"already instantiated cat package",entry)
;         entry
;      IDENTP entry =>
;        cat := catVec.i
;        packageForm := nil
;        if not GET(entry,'LOADED) then loadLib entry
;        infovec := GET(entry,'infovec)
;        success :=
;          --VECP infovec =>  ----new world
;          true =>  ----new world
;            opvec := infovec.1
;            max := MAXINDEX opvec
;            code := getOpCode(op,opvec,max)
;            null code => nil
;            byteVector := CDDDR infovec.3
;            endPos :=
;              code+2 > max => SIZE byteVector
;              opvec.(code+2)
;            --not nrunNumArgCheck(#(QCDR sig),byteVector,opvec.code,endPos) => nil
;            --numOfArgs := byteVector.(opvec.code)
;            --numOfArgs ^= #(QCDR sig) => nil
;            packageForm := [entry,'$,:CDR cat]
;            package := evalSlotDomain(packageForm,dom)
;            packageVec.i := package
;            package
;                           ----old world
;          table := HGET($Slot1DataBase,entry) or systemError nil
;          (u := LASSQ(op,table))
;            and (v := or/[rest x for x in u]) =>
;              packageForm := [entry,'$,:CDR cat]
;              package := evalSlotDomain(packageForm,dom)
;              packageVec.i := package
;              package
;          nil
;        null success =>
;          if $monitorNewWorld = true then
;            sayBrightlyNT '"  not in: "
;            pp (packageForm and devaluate package or entry)
;          nil
;        if $monitorNewWorld then
;          sayLooking1('"candidate default package instantiated: ",success)
;        success
;      entry
;    null package => nil
;    if $monitorNewWorld then
;      sayLooking1('"Looking at instantiated package ",package)
;    res := basicLookup(op,sig,package,dollar) =>
;      if $monitorNewWorld = true then
;        sayBrightly '"candidate default package succeeds"
;      return res
;    if $monitorNewWorld = true then
;      sayBrightly '"candidate fails -- continuing to search categories"
;    nil

;;;     ***       |hashNewLookupInCategories| REDEFINED

(DEFUN |hashNewLookupInCategories| (|op| |sig| |dom| |dollar|) (PROG (|$lookupDefaults| |slot4| |catVec| |predvec| |packageVec| |varList| |valueList| |nsig| |entry| |cat| |infovec| |opvec| |max| |code| |byteVector| |endPos| |table| |u| |v| |packageForm| |success| |package| |res|) (DECLARE (SPECIAL |$lookupDefaults|)) (RETURN (SEQ (PROGN (SPADLET |slot4| (ELT |dom| 4)) (SPADLET |catVec| (CADR |slot4|)) (COND ((EQL (SIZE |catVec|) 0) NIL) ((INTEGERP (KDR (ELT |catVec| 0))) (|newLookupInCategories1| |op| |sig| |dom| |dollar|)) ((QUOTE T) (SPADLET |$lookupDefaults| NIL) (COND ((|BOOT-EQUAL| |$monitorNewWorld| (QUOTE T)) (|sayBrightly| (|concat| (MAKESTRING "----->") (|form2String| (|devaluate| |dom|)) (MAKESTRING "-----> searching default packages for ") |op|)))) (SPADLET |predvec| (ELT |dom| 3)) (SPADLET |packageVec| (QCAR |slot4|)) (SPADLET |varList| (CONS (QUOTE |$|) |$FormalMapVariableList|)) (SPADLET |valueList| (CONS |dom| (PROG (#1=#:G81941) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81942 (|#| (CDR (ELT |dom| 0)))) (|i| 1 (QSADD1 |i|))) ((QSGREATERP |i| #2#) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (ELT |dom| (PLUS 5 |i|)) #1#))))))))) (SPADLET |valueList| (PROG (#3=#:G81939) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G81940 |valueList| (CDR #4#)) (|val| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |val| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (MKQ |val|) #3#)))))))) (SPADLET |nsig| (MSUBST (ELT |dom| 0) (ELT |dollar| 0) |sig|)) (DO ((#5=#:G81935 (MAXINDEX |packageVec|)) (|i| 0 (QSADD1 |i|))) ((QSGREATERP |i| #5#) NIL) (SEQ (EXIT (COND ((AND (SPADLET |entry| (ELT |packageVec| |i|)) (NEQUAL |entry| (QUOTE T))) (PROGN (SPADLET |package| (COND ((VECP |entry|) (COND (|$monitorNewWorld| (|sayLooking1| (MAKESTRING "already instantiated cat package") |entry|))) |entry|) ((IDENTP |entry|) (SPADLET |cat| (ELT |catVec| |i|)) (SPADLET |packageForm| NIL) (COND ((NULL (GETL |entry| (QUOTE LOADED))) (|loadLib| |entry|))) (SPADLET |infovec| (GETL |entry| (QUOTE |infovec|))) (SPADLET |success| (SEQ (EXIT (PROGN (SPADLET |opvec| (ELT |infovec| 1)) (SPADLET |max| (MAXINDEX |opvec|)) (SPADLET |code| (|getOpCode| |op| |opvec| |max|)) (COND ((NULL |code|) NIL) ((QUOTE T) (SPADLET |byteVector| (CDDDR (ELT |infovec| 3))) (SPADLET |endPos| (COND ((|>| (PLUS |code| 2) |max|) (SIZE |byteVector|)) ((QUOTE T) (ELT |opvec| (PLUS |code| 2))))) (SPADLET |packageForm| (CONS |entry| (CONS (QUOTE |$|) (CDR |cat|)))) (SPADLET |package| (|evalSlotDomain| |packageForm| |dom|)) (SETELT |packageVec| |i| |package|) |package|)))) (SPADLET |table| (OR (HGET |$Slot1DataBase| |entry|) (|systemError| NIL))) (COND ((AND (SPADLET |u| (LASSQ |op| |table|)) (SPADLET |v| (PROG (#6=#:G81936) (SPADLET #6# NIL) (RETURN (DO ((#7=#:G81937 NIL #6#) (#8=#:G81938 |u| (CDR #8#)) (|x| NIL)) ((OR #7# (ATOM #8#) (PROGN (SETQ |x| (CAR #8#)) NIL)) #6#) (SEQ (EXIT (SETQ #6# (OR #6# (CDR |x|)))))))))) (SPADLET |packageForm| (CONS |entry| (CONS (QUOTE |$|) (CDR |cat|)))) (SPADLET |package| (|evalSlotDomain| |packageForm| |dom|)) (SETELT |packageVec| |i| |package|) |package|) ((QUOTE T) NIL)))) (COND ((NULL |success|) (COND ((|BOOT-EQUAL| |$monitorNewWorld| (QUOTE T)) (|sayBrightlyNT| (MAKESTRING "  not in: ")) (|pp| (OR (AND |packageForm| (|devaluate| |package|)) |entry|)))) NIL) ((QUOTE T) (COND (|$monitorNewWorld| (|sayLooking1| (MAKESTRING "candidate default package instantiated: ") |success|))) |success|))) ((QUOTE T) |entry|))) (COND ((NULL |package|) NIL) ((QUOTE T) (COND (|$monitorNewWorld| (|sayLooking1| (MAKESTRING "Looking at instantiated package ") |package|))) (COND ((SPADLET |res| (|basicLookup| |op| |sig| |package| |dollar|)) (COND ((|BOOT-EQUAL| |$monitorNewWorld| (QUOTE T)) (|sayBrightly| (MAKESTRING "candidate default package succeeds")))) (RETURN |res|)) ((QUOTE T) (COND ((|BOOT-EQUAL| |$monitorNewWorld| (QUOTE T)) (|sayBrightly| (MAKESTRING "candidate fails -- continuing to search categories")))) NIL))))))))))))))))) 
;
;replaceGoGetSlot env ==
;  [thisDomain,index,:op] := env
;  thisDomainForm := devaluate thisDomain
;  bytevec := getDomainByteVector thisDomain
;  numOfArgs := bytevec.index
;  goGetDomainSlotIndex := bytevec.(index := QSADD1 index)
;  goGetDomain :=
;     goGetDomainSlotIndex = 0 => thisDomain
;     thisDomain.goGetDomainSlotIndex
;  if PAIRP goGetDomain and SYMBOLP CAR goGetDomain then
;     goGetDomain := lazyDomainSet(goGetDomain,thisDomain,goGetDomainSlotIndex)
;  sig :=
;    [newExpandTypeSlot(bytevec.(index := QSADD1 index),thisDomain,thisDomain)
;      for i in 0..numOfArgs]
;  thisSlot := bytevec.(QSADD1 index)
;  if $monitorNewWorld then
;    sayLooking(concat('"%l","..",form2String thisDomainForm,
;      '" wants",'"%l",'"  "),op,sig,goGetDomain)
;  slot :=  basicLookup(op,sig,goGetDomain,goGetDomain)
;  slot = nil =>
;    $returnNowhereFromGoGet = true =>
;      ['nowhere,:goGetDomain]  --see newGetDomainOpTable
;    sayBrightly concat('"Function: ",formatOpSignature(op,sig),
;      '" is missing from domain: ",form2String goGetDomain.0)
;    keyedSystemError("S2NR0001",[op,sig,goGetDomain.0])
;  if $monitorNewWorld then
;    sayLooking1(['"goget stuffing slot",:bright thisSlot,'"of "],thisDomain)
;  SETELT(thisDomain,thisSlot,slot)
;  if $monitorNewWorld then
;    sayLooking1('"<------",[CAR slot,:devaluate CDR slot])
;  slot

;;;     ***       |replaceGoGetSlot| REDEFINED

(DEFUN |replaceGoGetSlot| (|env|) (PROG (|thisDomain| |op| |thisDomainForm| |bytevec| |numOfArgs| |goGetDomainSlotIndex| |goGetDomain| |index| |sig| |thisSlot| |slot|) (RETURN (SEQ (PROGN (SPADLET |thisDomain| (CAR |env|)) (SPADLET |index| (CADR |env|)) (SPADLET |op| (CDDR |env|)) (SPADLET |thisDomainForm| (|devaluate| |thisDomain|)) (SPADLET |bytevec| (|getDomainByteVector| |thisDomain|)) (SPADLET |numOfArgs| (ELT |bytevec| |index|)) (SPADLET |goGetDomainSlotIndex| (ELT |bytevec| (SPADLET |index| (QSADD1 |index|)))) (SPADLET |goGetDomain| (COND ((EQL |goGetDomainSlotIndex| 0) |thisDomain|) ((QUOTE T) (ELT |thisDomain| |goGetDomainSlotIndex|)))) (COND ((AND (PAIRP |goGetDomain|) (SYMBOLP (CAR |goGetDomain|))) (SPADLET |goGetDomain| (|lazyDomainSet| |goGetDomain| |thisDomain| |goGetDomainSlotIndex|)))) (SPADLET |sig| (PROG (#1=#:G81943) (SPADLET #1# NIL) (RETURN (DO ((|i| 0 (QSADD1 |i|))) ((QSGREATERP |i| |numOfArgs|) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (|newExpandTypeSlot| (ELT |bytevec| (SPADLET |index| (QSADD1 |index|))) |thisDomain| |thisDomain|) #1#)))))))) (SPADLET |thisSlot| (ELT |bytevec| (QSADD1 |index|))) (COND (|$monitorNewWorld| (|sayLooking| (|concat| (MAKESTRING "%l") (INTERN ".." "BOOT") (|form2String| |thisDomainForm|) (MAKESTRING " wants") (MAKESTRING "%l") (MAKESTRING "  ")) |op| |sig| |goGetDomain|))) (SPADLET |slot| (|basicLookup| |op| |sig| |goGetDomain| |goGetDomain|)) (COND ((NULL |slot|) (COND ((|BOOT-EQUAL| |$returnNowhereFromGoGet| (QUOTE T)) (CONS (QUOTE |nowhere|) |goGetDomain|)) ((QUOTE T) (|sayBrightly| (|concat| (MAKESTRING "Function: ") (|formatOpSignature| |op| |sig|) (MAKESTRING " is missing from domain: ") (|form2String| (ELT |goGetDomain| 0)))) (|keyedSystemError| (QUOTE S2NR0001) (CONS |op| (CONS |sig| (CONS (ELT |goGetDomain| 0) NIL))))))) ((QUOTE T) (COND (|$monitorNewWorld| (|sayLooking1| (CONS (MAKESTRING "goget stuffing slot") (APPEND (|bright| |thisSlot|) (CONS (MAKESTRING "of ") NIL))) |thisDomain|))) (SETELT |thisDomain| |thisSlot| |slot|) (COND (|$monitorNewWorld| (|sayLooking1| (MAKESTRING "<------") (CONS (CAR |slot|) (|devaluate| (CDR |slot|)))))) |slot|))))))) 
;
;HasAttribute(domain,attrib) ==
;  hashPercent :=
;       VECP domain => hashType(domain.0,0)
;       hashType(domain,0)
;  isDomain domain =>
;     FIXP((first domain).0) =>
;        -- following call to hashType was missing 2nd arg.
;        -- getDomainHash domain added on 4/01/94 by RSS
;        basicLookup("%%",hashType(attrib, hashPercent),domain,domain)
;     HasAttribute(CDDR domain, attrib)
;-->
;  isNewWorldDomain domain => newHasAttribute(domain,attrib)
;--+
;  (u := LASSOC(attrib,domain.2)) and lookupPred(first u,domain,domain)

;;;     ***       |HasAttribute| REDEFINED

(DEFUN |HasAttribute| (|domain| |attrib|) (PROG (|hashPercent| |u|) (RETURN (PROGN (SPADLET |hashPercent| (COND ((VECP |domain|) (|hashType| (ELT |domain| 0) 0)) ((QUOTE T) (|hashType| |domain| 0)))) (COND ((|isDomain| |domain|) (COND ((FIXP (ELT (CAR |domain|) 0)) (|basicLookup| (QUOTE |%%|) (|hashType| |attrib| |hashPercent|) |domain| |domain|)) ((QUOTE T) (|HasAttribute| (CDDR |domain|) |attrib|)))) ((|isNewWorldDomain| |domain|) (|newHasAttribute| |domain| |attrib|)) ((QUOTE T) (AND (SPADLET |u| (LASSOC |attrib| (ELT |domain| 2))) (|lookupPred| (CAR |u|) |domain| |domain|)))))))) 
;
;newHasAttribute(domain,attrib) ==
;  hashPercent :=
;       VECP domain => hashType(domain.0,0)
;       hashType(domain,0)
;  predIndex :=
;     hashCode? attrib =>
;        -- following call to hashType was missing 2nd arg.
;        -- hashPercent added by PAB 15/4/94
;        or/[x for x in domain.2 | attrib = hashType(first x, hashPercent)]
;     LASSOC(attrib,domain.2)
;  predIndex =>
;    EQ(predIndex,0) => true
;    predvec := domain.3
;    testBitVector(predvec,predIndex)
;  false

;;;     ***       |newHasAttribute| REDEFINED

(DEFUN |newHasAttribute| (|domain| |attrib|) (PROG (|hashPercent| |predIndex| |predvec|) (RETURN (SEQ (PROGN (SPADLET |hashPercent| (COND ((VECP |domain|) (|hashType| (ELT |domain| 0) 0)) ((QUOTE T) (|hashType| |domain| 0)))) (SPADLET |predIndex| (COND ((|hashCode?| |attrib|) (PROG (#1=#:G81944) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81945 NIL #1#) (#3=#:G81946 (ELT |domain| 2) (CDR #3#)) (|x| NIL)) ((OR #2# (ATOM #3#) (PROGN (SETQ |x| (CAR #3#)) NIL)) #1#) (SEQ (EXIT (COND ((|BOOT-EQUAL| |attrib| (|hashType| (CAR |x|) |hashPercent|)) (SETQ #1# (OR #1# |x|)))))))))) ((QUOTE T) (LASSOC |attrib| (ELT |domain| 2))))) (COND (|predIndex| (COND ((EQ |predIndex| 0) (QUOTE T)) ((QUOTE T) (SPADLET |predvec| (ELT |domain| 3)) (|testBitVector| |predvec| |predIndex|)))) ((QUOTE T) NIL))))))) 
;
;newHasCategory(domain,catform) ==
;  catform = '(Type) => true
;  slot4 := domain.4
;  auxvec := CAR slot4
;  catvec := CADR slot4
;  $isDefaultingPackage: local := isDefaultPackageForm? devaluate domain
;  #catvec > 0 and INTEGERP KDR catvec.0 =>              --old style
;    predIndex := lazyMatchAssocV1(catform,catvec,domain)
;    null predIndex => false
;    EQ(predIndex,0) => true
;    predvec := QVELT(domain,3)
;    testBitVector(predvec,predIndex)
;  lazyMatchAssocV(catform,auxvec,catvec,domain)         --new style

;;;     ***       |newHasCategory| REDEFINED

(DEFUN |newHasCategory| (|domain| |catform|) (PROG (|$isDefaultingPackage| |slot4| |auxvec| |catvec| |predIndex| |predvec|) (DECLARE (SPECIAL |$isDefaultingPackage|)) (RETURN (COND ((|BOOT-EQUAL| |catform| (QUOTE (|Type|))) (QUOTE T)) ((QUOTE T) (SPADLET |slot4| (ELT |domain| 4)) (SPADLET |auxvec| (CAR |slot4|)) (SPADLET |catvec| (CADR |slot4|)) (SPADLET |$isDefaultingPackage| (|isDefaultPackageForm?| (|devaluate| |domain|))) (COND ((AND (|>| (|#| |catvec|) 0) (INTEGERP (KDR (ELT |catvec| 0)))) (SPADLET |predIndex| (|lazyMatchAssocV1| |catform| |catvec| |domain|)) (COND ((NULL |predIndex|) NIL) ((EQ |predIndex| 0) (QUOTE T)) ((QUOTE T) (SPADLET |predvec| (QVELT |domain| 3)) (|testBitVector| |predvec| |predIndex|)))) ((QUOTE T) (|lazyMatchAssocV| |catform| |auxvec| |catvec| |domain|)))))))) 
;
;lazyMatchAssocV(x,auxvec,catvec,domain) ==      --new style slot4
;  n : FIXNUM := MAXINDEX catvec
;  -- following call to hashType was missing 2nd arg. 0 added on 3/31/94 by RSS
;  hashCode? x =>
;    percentHash :=
;      VECP domain => hashType(domain.0, 0)
;      getDomainHash domain
;    or/[ELT(auxvec,i) for i in 0..n |
;        x = hashType(newExpandLocalType(QVELT(catvec,i),domain,domain), percentHash)]
;  xop := CAR x
;  or/[ELT(auxvec,i) for i in 0..n |
;    --xop = CAR (lazyt := QVELT(catvec,i)) and lazyMatch(x,lazyt,domain,domain)]
;    xop = CAR (lazyt := getCatForm(catvec,i,domain)) and lazyMatch(x,lazyt,domain,domain)]

;;;     ***       |lazyMatchAssocV| REDEFINED

(DEFUN |lazyMatchAssocV| (|x| |auxvec| |catvec| |domain|) (PROG (|n| |percentHash| |xop| |lazyt|) (RETURN (SEQ (PROGN (SPADLET |n| (MAXINDEX |catvec|)) (COND ((|hashCode?| |x|) (SPADLET |percentHash| (COND ((VECP |domain|) (|hashType| (ELT |domain| 0) 0)) ((QUOTE T) (|getDomainHash| |domain|)))) (PROG (#1=#:G81949) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81950 NIL #1#) (|i| 0 (QSADD1 |i|))) ((OR #2# (QSGREATERP |i| |n|)) #1#) (SEQ (EXIT (COND ((|BOOT-EQUAL| |x| (|hashType| (|newExpandLocalType| (QVELT |catvec| |i|) |domain| |domain|) |percentHash|)) (SETQ #1# (OR #1# (ELT |auxvec| |i|))))))))))) ((QUOTE T) (SPADLET |xop| (CAR |x|)) (PROG (#3=#:G81947) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G81948 NIL #3#) (|i| 0 (QSADD1 |i|))) ((OR #4# (QSGREATERP |i| |n|)) #3#) (SEQ (EXIT (COND ((AND (|BOOT-EQUAL| |xop| (CAR (SPADLET |lazyt| (|getCatForm| |catvec| |i| |domain|)))) (|lazyMatch| |x| |lazyt| |domain| |domain|)) (SETQ #3# (OR #3# (ELT |auxvec| |i|))))))))))))))))) 
;
;getCatForm(catvec, index, domain) ==
;   NUMBERP(form := QVELT(catvec,index)) => domain.form
;   form

(DEFUN |getCatForm| (|catvec| |index| |domain|) (PROG (|form|) (RETURN (COND ((NUMBERP (SPADLET |form| (QVELT |catvec| |index|))) (ELT |domain| |form|)) ((QUOTE T) |form|))))) 
;
;has(domain,catform') == HasCategory(domain,catform')

;;;     ***       |has| REDEFINED

(DEFUN |has| (|domain| |catform'|) (|HasCategory| |domain| |catform'|)) 
;
;HasCategory(domain,catform') ==
;  catform' is ['SIGNATURE,:f] => HasSignature(domain,f)
;  catform' is ['ATTRIBUTE,f] => HasAttribute(domain,f)
;  isDomain domain =>
;     FIXP((first domain).0) =>
;        catform' := devaluate catform'
;        basicLookup("%%",catform',domain,domain)
;     HasCategory(CDDR domain, catform')
;  catform:= devaluate catform'
;  isNewWorldDomain domain => newHasCategory(domain,catform)
;  domain0:=domain.0 -- handles old style domains, Record, Union etc.
;  slot4 := domain.4
;  catlist := slot4.1
;  member(catform,catlist) or
;   MEMQ(opOf(catform),'(Object Type)) or  --temporary hack
;    or/[compareSigEqual(catform,cat,domain0,domain) for cat in catlist]

;;;     ***       |HasCategory| REDEFINED

(DEFUN |HasCategory| (|domain| |catform'|) (PROG (|ISTMP#1| |f| |catform| |domain0| |slot4| |catlist|) (RETURN (SEQ (COND ((AND (PAIRP |catform'|) (EQ (QCAR |catform'|) (QUOTE SIGNATURE)) (PROGN (SPADLET |f| (QCDR |catform'|)) (QUOTE T))) (|HasSignature| |domain| |f|)) ((AND (PAIRP |catform'|) (EQ (QCAR |catform'|) (QUOTE ATTRIBUTE)) (PROGN (SPADLET |ISTMP#1| (QCDR |catform'|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |f| (QCAR |ISTMP#1|)) (QUOTE T))))) (|HasAttribute| |domain| |f|)) ((|isDomain| |domain|) (COND ((FIXP (ELT (CAR |domain|) 0)) (SPADLET |catform'| (|devaluate| |catform'|)) (|basicLookup| (QUOTE |%%|) |catform'| |domain| |domain|)) ((QUOTE T) (|HasCategory| (CDDR |domain|) |catform'|)))) ((QUOTE T) (SPADLET |catform| (|devaluate| |catform'|)) (COND ((|isNewWorldDomain| |domain|) (|newHasCategory| |domain| |catform|)) ((QUOTE T) (SPADLET |domain0| (ELT |domain| 0)) (SPADLET |slot4| (ELT |domain| 4)) (SPADLET |catlist| (ELT |slot4| 1)) (OR (|member| |catform| |catlist|) (MEMQ (|opOf| |catform|) (QUOTE (|Object| |Type|))) (PROG (#1=#:G81951) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81952 NIL #1#) (#3=#:G81953 |catlist| (CDR #3#)) (|cat| NIL)) ((OR #2# (ATOM #3#) (PROGN (SETQ |cat| (CAR #3#)) NIL)) #1#) (SEQ (EXIT (SETQ #1# (OR #1# (|compareSigEqual| |catform| |cat| |domain0| |domain|))))))))))))))))) 
;
;--systemDependentMkAutoload(fn,cnam) ==
;--    FBOUNDP(cnam) => "next"
;--    SETF(SYMBOL_-FUNCTION cnam,mkAutoLoad(fn, cnam))
;
;lazyDomainSet(lazyForm,thisDomain,slot) ==
;  form :=
;    --lazyForm is [vec,.,:u] and VECP vec => u        --old style
;    lazyForm                                        --new style
;  slotDomain := evalSlotDomain(form,thisDomain)
;  if $monitorNewWorld then
;    sayLooking1(concat(form2String devaluate thisDomain,
;      '" activating lazy slot ",slot,'": "),slotDomain)
;-- name := CAR form
;--getInfovec name
;  SETELT(thisDomain,slot,slotDomain)

;;;     ***       |lazyDomainSet| REDEFINED

(DEFUN |lazyDomainSet| (|lazyForm| |thisDomain| |slot|) (PROG (|form| |slotDomain|) (RETURN (PROGN (SPADLET |form| |lazyForm|) (SPADLET |slotDomain| (|evalSlotDomain| |form| |thisDomain|)) (COND (|$monitorNewWorld| (|sayLooking1| (|concat| (|form2String| (|devaluate| |thisDomain|)) (MAKESTRING " activating lazy slot ") |slot| (MAKESTRING ": ")) |slotDomain|))) (SETELT |thisDomain| |slot| |slotDomain|))))) 
;
;
;evalSlotDomain(u,dollar) ==
;  $returnNowhereFromGoGet: local := false
;  $ : fluid := dollar
;  $lookupDefaults : local := nil -- new world
;  isDomain u => u
;  u = '$ => dollar
;  u = "$$" => dollar
;  FIXP u =>
;    VECP (y := dollar.u) => y
;    isDomain y => y
;    y is ['SETELT,:.] => eval y--lazy domains need to marked; this is dangerous?
;    y is [v,:.] =>
;      VECP v => lazyDomainSet(y,dollar,u)               --old style has [$,code,:lazyt]
;      constructor? v or MEMQ(v,'(Record Union Mapping)) =>
;        lazyDomainSet(y,dollar,u)                       --new style has lazyt
;      y
;    y
;  u is ['NRTEVAL,y] =>
;    y is ['ELT,:.] => evalSlotDomain(y,dollar)
;    eval  y
;  u is ['QUOTE,y] => y
;  u is ['Record,:argl] =>
;     FUNCALL('Record0,[[tag,:evalSlotDomain(dom,dollar)]
;                                 for [.,tag,dom] in argl])
;  u is ['Union,:argl] and first argl is ['_:,.,.] =>
;     APPLY('Union,[['_:,tag,evalSlotDomain(dom,dollar)]
;                                 for [.,tag,dom] in argl])
;  u is ['spadConstant,d,n] =>
;    dom := evalSlotDomain(d,dollar)
;    SPADCALL(dom . n)
;  u is ['ELT,d,n] =>
;    dom := evalSlotDomain(d,dollar)
;    slot := dom . n
;    slot is ['newGoGet,:env] => replaceGoGetSlot env
;    slot
;  u is [op,:argl] => APPLY(op,[evalSlotDomain(x,dollar) for x in argl])
;  systemErrorHere '"evalSlotDomain"

;;;     ***       |evalSlotDomain| REDEFINED

(DEFUN |evalSlotDomain| (|u| |dollar|) (PROG (|$returnNowhereFromGoGet| |$| |$lookupDefaults| |v| |y| |ISTMP#3| |tag| |ISTMP#1| |d| |ISTMP#2| |n| |dom| |slot| |env| |op| |argl|) (DECLARE (SPECIAL |$returnNowhereFromGoGet| |$| |$lookupDefaults|)) (RETURN (SEQ (PROGN (SPADLET |$returnNowhereFromGoGet| NIL) (SPADLET |$| |dollar|) (SPADLET |$lookupDefaults| NIL) (COND ((|isDomain| |u|) |u|) ((|BOOT-EQUAL| |u| (QUOTE |$|)) |dollar|) ((|BOOT-EQUAL| |u| (QUOTE |$$|)) |dollar|) ((FIXP |u|) (COND ((VECP (SPADLET |y| (ELT |dollar| |u|))) |y|) ((|isDomain| |y|) |y|) ((AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE SETELT))) (|eval| |y|)) ((AND (PAIRP |y|) (PROGN (SPADLET |v| (QCAR |y|)) (QUOTE T))) (COND ((VECP |v|) (|lazyDomainSet| |y| |dollar| |u|)) ((OR (|constructor?| |v|) (MEMQ |v| (QUOTE (|Record| |Union| |Mapping|)))) (|lazyDomainSet| |y| |dollar| |u|)) ((QUOTE T) |y|))) ((QUOTE T) |y|))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE NRTEVAL)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T))))) (COND ((AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE ELT))) (|evalSlotDomain| |y| |dollar|)) ((QUOTE T) (|eval| |y|)))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE QUOTE)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T))))) |y|) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |Record|)) (PROGN (SPADLET |argl| (QCDR |u|)) (QUOTE T))) (FUNCALL (QUOTE |Record0|) (PROG (#1=#:G81960) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81961 |argl| (CDR #2#)) (#3=#:G81954 NIL)) ((OR (ATOM #2#) (PROGN (SETQ #3# (CAR #2#)) NIL) (PROGN (PROGN (SPADLET |tag| (CADR #3#)) (SPADLET |dom| (CADDR #3#)) #3#) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (CONS |tag| (|evalSlotDomain| |dom| |dollar|)) #1#))))))))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |Union|)) (PROGN (SPADLET |argl| (QCDR |u|)) (QUOTE T)) (PROGN (SPADLET |ISTMP#1| (CAR |argl|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL)))))))) (APPLY (QUOTE |Union|) (PROG (#4=#:G81958) (SPADLET #4# NIL) (RETURN (DO ((#5=#:G81959 |argl| (CDR #5#)) (#6=#:G81955 NIL)) ((OR (ATOM #5#) (PROGN (SETQ #6# (CAR #5#)) NIL) (PROGN (PROGN (SPADLET |tag| (CADR #6#)) (SPADLET |dom| (CADDR #6#)) #6#) NIL)) (NREVERSE0 #4#)) (SEQ (EXIT (SETQ #4# (CONS (CONS (QUOTE |:|) (CONS |tag| (CONS (|evalSlotDomain| |dom| |dollar|) NIL))) #4#))))))))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |spadConstant|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |d| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |n| (QCAR |ISTMP#2|)) (QUOTE T))))))) (SPADLET |dom| (|evalSlotDomain| |d| |dollar|)) (SPADCALL (ELT |dom| |n|))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE ELT)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |d| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |n| (QCAR |ISTMP#2|)) (QUOTE T))))))) (SPADLET |dom| (|evalSlotDomain| |d| |dollar|)) (SPADLET |slot| (ELT |dom| |n|)) (COND ((AND (PAIRP |slot|) (EQ (QCAR |slot|) (QUOTE |newGoGet|)) (PROGN (SPADLET |env| (QCDR |slot|)) (QUOTE T))) (|replaceGoGetSlot| |env|)) ((QUOTE T) |slot|))) ((AND (PAIRP |u|) (PROGN (SPADLET |op| (QCAR |u|)) (SPADLET |argl| (QCDR |u|)) (QUOTE T))) (APPLY |op| (PROG (#7=#:G81956) (SPADLET #7# NIL) (RETURN (DO ((#8=#:G81957 |argl| (CDR #8#)) (|x| NIL)) ((OR (ATOM #8#) (PROGN (SETQ |x| (CAR #8#)) NIL)) (NREVERSE0 #7#)) (SEQ (EXIT (SETQ #7# (CONS (|evalSlotDomain| |x| |dollar|) #7#))))))))) ((QUOTE T) (|systemErrorHere| (MAKESTRING "evalSlotDomain"))))))))) 
;
;domainEqual(a,b) ==
;  devaluate(a) = devaluate(b)

;;;     ***       |domainEqual| REDEFINED

(DEFUN |domainEqual| (|a| |b|) (|BOOT-EQUAL| (|devaluate| |a|) (|devaluate| |b|))) 
;
;--makeConstructorsAutoLoad()
;
;-- following changes should go back into xrun.boot
;-- patched version from xrun.boot
;coerceConvertMmSelection(funName,m1,m2) ==
;  -- calls selectMms with $Coerce=NIL and tests for required
;  -- target type. funName is either 'coerce or 'convert.
;  $declaredMode : local:= NIL
;  $reportBottomUpFlag : local:= NIL
;  l := selectMms1(funName,m2,[m1],[m1],NIL)
;--  mmS := [[sig,[targ,arg],:pred] for x in l | x is [sig,[.,arg],:pred] and
;  mmS := [x for x in l | x is [sig,:.] and hasCorrectTarget(m2,sig) and
;      sig is [dc,targ,oarg] and isEqualOrSubDomain(m1,oarg)]
;  mmS and CAR mmS

;;;     ***       |coerceConvertMmSelection| REDEFINED

;;;     ***       |coerceConvertMmSelection| REDEFINED

(DEFUN |coerceConvertMmSelection| (|&REST| #1=#:G81966 |&AUX| #2=#:G81964) (DSETQ #2# #1#) (PROG NIL (RETURN (PROG (#3=#:G81965) (RETURN (COND ((SETQ #3# (HGET |coerceConvertMmSelection;AL| #2#)) (|CDRwithIncrement| #3#)) ((QUOTE T) (CDR (HPUT |coerceConvertMmSelection;AL| #2# (CONS 1 (APPLY (|function| |coerceConvertMmSelection;|) #2#))))))))))) 

(DEFUN |coerceConvertMmSelection;| (|funName| |m1| |m2|) (PROG (|$declaredMode| |$reportBottomUpFlag| |l| |sig| |dc| |ISTMP#1| |targ| |ISTMP#2| |oarg| |mmS|) (DECLARE (SPECIAL |$declaredMode| |$reportBottomUpFlag|)) (RETURN (SEQ (PROGN (SPADLET |$declaredMode| NIL) (SPADLET |$reportBottomUpFlag| NIL) (SPADLET |l| (|selectMms1| |funName| |m2| (CONS |m1| NIL) (CONS |m1| NIL) NIL)) (SPADLET |mmS| (PROG (#1=#:G81962) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G81963 |l| (CDR #2#)) (|x| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (COND ((AND (PAIRP |x|) (PROGN (SPADLET |sig| (QCAR |x|)) (QUOTE T)) (|hasCorrectTarget| |m2| |sig|) (PAIRP |sig|) (PROGN (SPADLET |dc| (QCAR |sig|)) (SPADLET |ISTMP#1| (QCDR |sig|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |targ| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |oarg| (QCAR |ISTMP#2|)) (QUOTE T)))))) (|isEqualOrSubDomain| |m1| |oarg|)) (SETQ #1# (CONS |x| #1#)))))))))) (AND |mmS| (CAR |mmS|))))))) 

(PUT (QUOTE |coerceConvertMmSelection|) (QUOTE |cacheInfo|) (QUOTE (|coerceConvertMmSelection| |coerceConvertMmSelection;AL| |hash-tableWithCounts| (SETQ |coerceConvertMmSelection;AL| (|MAKE-HASHTABLE| (QUOTE UEQUAL))) (|hashCount| |coerceConvertMmSelection;AL|)))) 

(SETQ |coerceConvertMmSelection;AL| (|MAKE-HASHTABLE| (QUOTE UEQUAL))) 
;
;getFunctionFromDomain(op,dc,args) ==
;  -- finds the function op with argument types args in dc
;  -- complains, if no function or ambiguous
;  $reportBottomUpFlag:local:= NIL
;  MEMBER(CAR dc,$nonLisplibDomains) =>
;    throwKeyedMsg("S2IF0002",[CAR dc])
;  not constructor? CAR dc =>
;    throwKeyedMsg("S2IF0003",[CAR dc])
;  p:= findFunctionInDomain(op,dc,NIL,args,args,NIL,NIL) =>
;--+
;    --sig := [NIL,:args]
;    domain := evalDomain dc
;    for mm in nreverse p until b repeat
;      [[.,:osig],nsig,:.] := mm
;      b := compiledLookup(op,nsig,domain)
;    b or  throwKeyedMsg("S2IS0023",[op,dc])
;  throwKeyedMsg("S2IF0004",[op,dc])
;

;;;     ***       |getFunctionFromDomain| REDEFINED

(DEFUN |getFunctionFromDomain| (|op| |dc| |args|) (PROG (|$reportBottomUpFlag| |p| |domain| |osig| |nsig| |b|) (DECLARE (SPECIAL |$reportBottomUpFlag|)) (RETURN (SEQ (PROGN (SPADLET |$reportBottomUpFlag| NIL) (COND ((|member| (CAR |dc|) |$nonLisplibDomains|) (|throwKeyedMsg| (QUOTE S2IF0002) (CONS (CAR |dc|) NIL))) ((NULL (|constructor?| (CAR |dc|))) (|throwKeyedMsg| (QUOTE S2IF0003) (CONS (CAR |dc|) NIL))) ((SPADLET |p| (|findFunctionInDomain| |op| |dc| NIL |args| |args| NIL NIL)) (SPADLET |domain| (|evalDomain| |dc|)) (DO ((#1=#:G81967 (NREVERSE |p|) (CDR #1#)) (|mm| NIL) (#2=#:G81968 NIL |b|)) ((OR (ATOM #1#) (PROGN (SETQ |mm| (CAR #1#)) NIL) #2#) NIL) (SEQ (EXIT (PROGN (SPADLET |osig| (CDAR |mm|)) (SPADLET |nsig| (CADR |mm|)) (SPADLET |b| (|compiledLookup| |op| |nsig| |domain|)))))) (OR |b| (|throwKeyedMsg| (QUOTE S2IS0023) (CONS |op| (CONS |dc| NIL))))) ((QUOTE T) (|throwKeyedMsg| (QUOTE S2IF0004) (CONS |op| (CONS |dc| NIL)))))))))) 
;;;Boot translation finished for interop.boot

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
