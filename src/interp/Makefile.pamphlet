%% Oh Emacs, this is a -*- Makefile -*-, so give me tabs.
\documentclass{article}
\usepackage{axiom}

\title{\File{src/interp/Makefile} Pamphlet}
\author{Timothy Daly \and Gabriel Dos~Reis}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\eject

\tableofcontents
\eject

\begin{verbatim}
notes for understanding this makefile:
re: postpar.clisp and parse.clisp stanzas: 
NOTE: the .clisp file is copies back into the src directory so that
it is possible to create a new obootsys system from scratch for a 
new platform. parse.clisp needs to be compiled in a depsys.
two things need to be done to create an obootsys by hand:
  :oldboot must be on the *features* list BEFORE util.lisp is loaded
  parse and postpar must be loaded along with the depsys files
     into a bare lisp system.
if these two things are done then a obootsys image can be bootstrapped
to a new platform.

IMPORTANT: all source file names in this Makefile must be lowercase
  This is for cross-platform compatibility and also makes getting
  them into Lisp much easier at the Makefile level.

\end{verbatim}

\section{The Environment}
We define 3 directories for this build. The first two are
the traditional {\bf IN}, which is where the source pamphlets are,
and {\bf OUT} which is where we will put the binaries.

In this case the {\bf IN} files are usually written in Boot \cite{2}.
These will be compiled in a \Tool{bootsys} image to translate from
Boot to Common Lisp. 

The dvi files will be generated from the pamphlet files in the
final ship \File{doc/src/} directory. Since they are system independent 
but machine generated and part of the final ship they will exist 
in the \File{\$(axiom_target_docdir)/src/interp/} directory.

<<environment>>=
IN=$(srcdir)
DOC=$(axiom_target_docdir)/src/interp
BOOK=$(axiom_target_docdir)

# Command to translate Boot to Common Lisp
BOOT_TO_LISP = \
	$(axiom_build_document) --tag=boot --mode=translate \
		$(BOOTSYS) $< >> $(TMP)/trace

# Command to translate Common Lisp to native object code
COMPILE_LISP = \
	$(axiom_build_document) --tag=lisp --mode=compile \
		--output=$@ $(DEPSYS) $< >> $(TMP)/trace
@

In order to minimize the size of the Axiom image at load time
we put some of the compiled files into a separate directory
that will be autoloaded on demand. This directory of code
will be shipped with the final system and so it belongs in
the [[$(axiom_targetdir)]] subtree.
<<environment>>=
AUTO=$(axiom_targetdir)/autoload

autoload_objects =

@

We need a raw Lisp image --- running on the build platform ---
that we can use as a base to construct
the other images. This is called {\bf LISPSYS} and is located in the
build platform sub-directory.
<<environment>>=
# Build platform-dependent Lisp image, at the base of other
# derived Lisp images (bootsys, depsys, interpsys, AXIOMsys)
LISPSYS= $(axiom_build_bindir)/lisp

@

Most of the interpreter is written in Boot. 
Thus we need a program to translate Boot to Common
Lisp.  That program is called the {\bf BOOTSYS} image (because the
translator is written in {\bf boot} and needs to translate
itself to bootstrap the system).  This image is assumed to
have been built (on the build platform) by a previous step in the
make process.
<<environment>>=
BOOTSYS= $(axiom_build_bindir)/bootsys    

@

Some of the Common Lisp code we compile uses macros which
are assumed to be available at compile time. The {\bf DEPSYS}
image is created to contain the compile time environment
and saved. We pipe compile commands into this environment
to compile from Common Lisp to machine dependent code.
%
<<environment>>=
DEPSYS=	$(axiom_build_bindir)/depsys

depsys_lisp_noncompiled_sources += sys-pkg.lisp nocompil.lisp \
	ncompil.lisp bookvol5.lisp util.lisp

depsys_lisp_compiled_sources += parsing.lisp metalex.lisp bootlex.lisp \
	newaux.lisp preparse.lisp postprop.lisp def.lisp metameta.lisp \
	fnewmeta.lisp

depsys_lisp_sources = $(depsys_lisp_noncompiled_sources) \
			$(depsys_lisp_compiled_sources)

depsys_boot_sources = postpar.boot parse.boot clam.boot slam.boot \
	g-boot.boot c-util.boot g-util.boot
@

The {\bf DEP} variable contains the list of files that
will be loaded into {\bf DEPSYS}. Notice that these files
are loaded in interpreted form. We are not concerned about
the compile time performance so we can use interpreted code.
We do, however, care about the macros as these will be
expanded in later compiles. All macros are assumed to be
in this list of files.
<<environment>>=
DEP=	vmlisp.lisp	ggreater.lisp	\
	hash.lisp	bootfuns.lisp	\
	union.lisp	nlib.lisp	\
	macros.lisp	comp.lisp	\
	spaderror.lisp	debug.lisp	\
	spad.lisp	bits.lisp	\
	setq.lisp	property.lisp	\
	unlisp.lisp      foam_l.lisp      \
	axext_l.lisp

depsys_lisp_macro_sources = vmlisp.lisp ggreater.lisp hash.lisp \
	bootfuns.lisp union.lisp nlib.lisp macros.lisp	\
	comp.lisp spaderror.lisp debug.lisp \
	spad.lisp bits.lisp setq.lisp property.lisp \
	unlisp.lisp foam_l.lisp axext_l.lisp

depsys_lisp_noncompiled_sources += $(depsys_lisp_macro_sources)
depsys_lisp_SOURCES = $(addsuffix .pamphlet, $(depsys_lisp_sources))
@

Once we've compile all of the Common Lisp files we fire up
a clean lisp image called {\bf LOADSYS} (from the build platform), load all 
of the
final executable code and save it out as {\bf SAVESYS}.  This image
is used to bootstrap the Algebra files and generate the
databases.  
The {\bf SAVESYS} image is copied to the [[$(axiom_target_bindir)]]
subdirectory and becomes the axiom executable image.  Technically, that is
not right because the host plaform may not be the same as the build
platform.  However, we don't yet support cross compilation, so that
is alright for the time being.
<<environment>>=
LOADSYS= $(axiom_build_bindir)/lisp$(EXEEXT)
SAVESYS= $(axiom_build_bindir)/interpsys$(EXEEXT)
AXIOMSYS= $(axiom_target_bindir)/AXIOMsys$(EXEEXT)

@

Occasionally we need to really get into the system internals.
The best way to do this is to run almost all of the lisp code
interpreted rather than compiled (note that cfuns.lisp and sockio.lisp
still need to be loaded in compiled form as they depend on the 
loader to link with lisp internals). This image is nothing more
than a load of the file \File{src/interp/debugsys.lisp.pamphlet}. If
you need to make test modifications you can add code to that
file and it will show up here.
<<environment>>=
DEBUGSYS=$(axiom_build_bindir)/debugsys$(EXEEXT)

@

These are the files that need to be compiled (in {\bf BOOTSYS}),
loaded into a clean lisp image ({\bf LOADSYS}) and saved as
a runnable \Tool{Axiom} interpreter ({\bf SAVESYS}) usually named
\Tool{interpsys}. Most of these files
are translated from Boot to Common Lisp and then 
compiled. There are two exceptions, \File{bootfuns.lisp}
and \File{setq.lisp}. The \File{bootfuns.lisp} \cite{3} file
contains forward references for Boot code. The \File{setq.lisp}
file contains constant initialization code which gains nothing
by being compiled.

The value of the variable [[AXIOMsys_boot_sources]] is the (currently
partial) list of Boot source files that make up the interpreter.
Similarly, the value of the variable [[AXIOMsys_compiled_lisp_sources]]
is the list of Common Lisp source files that are compiled into
the interpreter.  Notice that some of these files are loaded (\eg{},
interpreted) in [[depsys]].

<<environment>>=
OBJS=	vmlisp.$(OBJEXT)	hash.$(OBJEXT)	\
	bootfuns.lisp	macros.$(OBJEXT)	\
	unlisp.$(OBJEXT)	setq.lisp	\
	astr.$(OBJEXT)	bits.$(OBJEXT)	\
	alql.$(OBJEXT)	buildom.$(OBJEXT)	\
	cattable.$(OBJEXT)				\
	cformat.$(OBJEXT)	cfuns.$(OBJEXT)	\
	clam.$(OBJEXT)	clammed.$(OBJEXT)	\
	comp.$(OBJEXT)	\
	compat.$(OBJEXT)	compress.$(OBJEXT)	\
	cparse.$(OBJEXT)	cstream.$(OBJEXT)	\
	database.$(OBJEXT)	\
	debug.$(OBJEXT)	dq.$(OBJEXT)		\
	fname.$(OBJEXT)	format.$(OBJEXT)	\
	g-boot.$(OBJEXT)	g-cndata.$(OBJEXT)	\
	g-error.$(OBJEXT)	g-opt.$(OBJEXT)	\
	g-timer.$(OBJEXT)	g-util.$(OBJEXT)	\
	ggreater.$(OBJEXT)				\
	hypertex.$(OBJEXT)	i-analy.$(OBJEXT)	\
	i-code.$(OBJEXT)	i-coerce.$(OBJEXT)	\
	i-coerfn.$(OBJEXT)	i-eval.$(OBJEXT)	\
	i-funsel.$(OBJEXT)	bookvol5.$(OBJEXT)	\
	i-intern.$(OBJEXT)	i-map.$(OBJEXT)	\
	i-output.$(OBJEXT)	i-resolv.$(OBJEXT)	\
	i-spec1.$(OBJEXT)				\
	i-spec2.$(OBJEXT)	i-syscmd.$(OBJEXT)	\
	i-toplev.$(OBJEXT)	i-util.$(OBJEXT)	\
	incl.$(OBJEXT)	int-top.$(OBJEXT)	\
	intfile.$(OBJEXT)				\
	lisplib.$(OBJEXT)	macex.$(OBJEXT)	\
	match.$(OBJEXT)				\
	monitor.$(OBJEXT)	msg.$(OBJEXT)		\
	msgdb.$(OBJEXT)	nci.$(OBJEXT)		\
	newaux.$(OBJEXT)	newfort.$(OBJEXT)	\
	nlib.$(OBJEXT)	nrunfast.$(OBJEXT)	\
	nrungo.$(OBJEXT)	nrunopt.$(OBJEXT)	\
	nruntime.$(OBJEXT)	osyscmd.$(OBJEXT)	\
	packtran.$(OBJEXT)	pathname.$(OBJEXT)	\
	pf2sex.$(OBJEXT)	pile.$(OBJEXT)	\
	posit.$(OBJEXT)	property.lisp	\
	ptrees.$(OBJEXT)	ptrop.$(OBJEXT)	\
	record.$(OBJEXT)				\
	rulesets.$(OBJEXT)	\
	scan.$(OBJEXT)	serror.$(OBJEXT)	\
	server.$(OBJEXT)				\
	setvars.$(OBJEXT)	\
	sfsfun-l.$(OBJEXT)	sfsfun.$(OBJEXT)	\
	simpbool.$(OBJEXT)	slam.$(OBJEXT)	\
	sockio.$(OBJEXT)	spad.$(OBJEXT)	\
	spaderror.$(OBJEXT)				\
	template.$(OBJEXT)	termrw.$(OBJEXT)	\
	trace.$(OBJEXT)	\
	union.$(OBJEXT)       daase.$(OBJEXT)  	\
	fortcall.$(OBJEXT)

AXIOMsys_noncompiled_lisp_sources = bootfuns.lisp nocompil.lisp \
	postprop.lisp property.lisp setq.lisp 

AXIOMsys_compiled_lisp_sources = bits.lisp \
	bootlex.lisp cfuns.lisp comp.lisp construc.lisp daase.lisp \
	debug.lisp def.lisp fname.lisp fnewmeta.lisp ggreater.lisp \
	hash.lisp macros.lisp metalex.lisp monitor.lisp newaux.lisp \
	nlib.lisp nspadaux.lisp parsing.lisp \
	patches.lisp preparse.lisp \
	sockio.lisp spad.lisp spaderror.lisp \
	union.lisp util.lisp vmlisp.lisp obey.lisp \
	unlisp.lisp intint.lisp nci.lisp sfsfun-l.lisp \
	axext_l.lisp foam_l.lisp

AXIOMsys_boot_sources = astr.boot alql.boot buildom.boot cattable.boot \
	cformat.boot clam.boot clammed.boot compat.boot compress.boot \
	cparse.boot cstream.boot database.boot dq.boot format.boot \
	g-boot.boot g-cndata.boot g-error.boot g-opt.boot g-timer.boot \
	g-util.boot hypertex.boot i-analy.boot i-code.boot i-coerce.boot \
	i-coerfn.boot i-eval.boot i-funsel.boot i-intern.boot i-map.boot \
	i-output.boot i-resolv.boot i-spec1.boot i-spec2.boot \
	i-syscmd.boot i-toplev.boot i-util.boot incl.boot int-top.boot \
	intfile.boot lisplib.boot macex.boot match.boot msg.boot \
	msgdb.boot newfort.boot nrunfast.boot nrungo.boot nrunopt.boot \
	nruntime.boot osyscmd.boot packtran.boot pathname.boot \
	pf2sex.boot pile.boot posit.boot ptrees.boot ptrop.boot \
	record.boot rulesets.boot scan.boot serror.boot server.boot \
	setvars.boot sfsfun.boot simpbool.boot slam.boot template.boot \
	termrw.boot trace.boot fortcall.boot
@

Before we save the {\bf SAVESYS} image we need to run some
initialization code. These files perform initialization
for various parts of the system. The {\bf patches.lisp} \cite{5}
file contains last-minute changes to various functions and
constants.
<<environment>>=
INOBJS=	varini.$(OBJEXT)	parini.$(OBJEXT)	\
	setvart.$(OBJEXT)	intint.$(OBJEXT)	\
        xrun.$(OBJEXT)        interop.$(OBJEXT)     \
        patches.$(OBJEXT)

@

Certain functions do not need to be in the running system.
If the running image never calls the compiler or does not
use the hypertex browser we will never call the functions
in these files. The code that calls these functions in the
running system will autoload the appropriate files the
first time they are called. Loading the files overwrites
the autoload function call and re-calls the function. 
Any subsequent calls will run the compiled code.

The {\bf OPOBJS} list contains files from the old parser. The use of
``old'' is something of a subtle concept as there were several
generations of ``old'' and all meaning of the term is lost.

Notice that the object file [[def.$(OBJEXT)]] appears on both the
[[OPBJS]] and [[TRANOBJS]] lists.  In normal situation, parsing 
precedes translation; consequently the file [[def]] is loaded by the 
parser, so that it does not need to be reloaded by the translator. 
However, it may theoretically be that a translation could happen without 
prior parsing (in case someone types in a parse tree for SPAD code).  
Consequently, it must be ensured that [[def.]] is still loaded in that
configuration.  In the long term, the autoload machinery need
rethinking.

<<environment>>=
# These are autloaded old parser files
OPOBJS=	${AUTO}/parsing.$(OBJEXT)	${AUTO}/bootlex.$(OBJEXT)	\
        ${AUTO}/def.$(OBJEXT)	\
	${AUTO}/fnewmeta.$(OBJEXT)	${AUTO}/metalex.$(OBJEXT)	\
	${AUTO}/metameta.$(OBJEXT)	\
	${AUTO}/parse.$(OBJEXT)	${AUTO}/postpar.$(OBJEXT)	\
	${AUTO}/postprop.$(OBJEXT)	${AUTO}/preparse.$(OBJEXT)

autoload_objects += $(OPBJS)
@

The {\bf OCOBJS} list contains files from the old compiler. Again,
``old'' is meaningless. These files should probably be autoloaded.
<<environment>>=
OCOBJS=	${AUTO}/apply.$(OBJEXT)	${AUTO}/c-doc.$(OBJEXT)	\
	${AUTO}/c-util.$(OBJEXT)	${AUTO}/profile.$(OBJEXT)	\
	${AUTO}/category.$(OBJEXT)	${AUTO}/compiler.$(OBJEXT)	\
	${AUTO}/define.$(OBJEXT)	${AUTO}/functor.$(OBJEXT)	\
	${AUTO}/info.$(OBJEXT)	${AUTO}/iterator.$(OBJEXT)	\
	${AUTO}/modemap.$(OBJEXT)	${AUTO}/nruncomp.$(OBJEXT)	\
	${AUTO}/package.$(OBJEXT)	${AUTO}/htcheck.$(OBJEXT)	\
        ${AUTO}/xruncomp.$(OBJEXT)   

autoload_objects += $(OCOBJS)

@

The {\bf BROBJS} list contains files only used by the hypertex
browser. These files should probably be autoloaded.
<<environment>>=
BROBJS=	${AUTO}/bc-matrix.$(OBJEXT)				\
	${AUTO}/bc-misc.$(OBJEXT)	${AUTO}/bc-solve.$(OBJEXT)	\
	${AUTO}/bc-util.$(OBJEXT)				\
	${AUTO}/ht-util.$(OBJEXT)	${AUTO}/htsetvar.$(OBJEXT)	\
	${AUTO}/ht-root.$(OBJEXT)	\
	${AUTO}/br-con.$(OBJEXT)	\
	${AUTO}/br-data.$(OBJEXT)	${AUTO}/showimp.$(OBJEXT)    \
	${AUTO}/br-op1.$(OBJEXT)	${AUTO}/br-op2.$(OBJEXT)	\
	${AUTO}/br-search.$(OBJEXT)	${AUTO}/br-util.$(OBJEXT)	\
	${AUTO}/topics.$(OBJEXT)     ${AUTO}/br-prof.$(OBJEXT)    \
	${AUTO}/br-saturn.$(OBJEXT)

autoload_objects += $(BFOBJS)

@
The {\bf TRANOBJS} list contains files used by Spad to Aldor convertor.
The files probably are also used by the {\bf boot}
to Common Lisp translator and are probably never used by anyone
but the developers.

When a user requests converting a file from Spad to Aldor the
function
[[spad2AsTranslatorAutoloadOnceTrigger]] is called triggering
load of this group of files. Loading [[$TRANOBJS]] in turn replaces
many compiler functions by versions contain in this files.
 These files should probably be autoloaded
(at least [[${AUTO}/wi1.$(OBJEXT)]] and [[${AUTO}/wi2.$(OBJEXT)]]
(which replace compiler functions) {\em must} be autoloaded).
<<environment>>=
TRANOBJS= ${AUTO}/wi1.$(OBJEXT) ${AUTO}/wi2.$(OBJEXT) ${AUTO}/pspad1.$(OBJEXT) \
	  ${AUTO}/pspad2.$(OBJEXT) ${AUTO}/mark.$(OBJEXT) ${AUTO}/nspadaux.$(OBJEXT) \
	  ${AUTO}/def.$(OBJEXT)

autoload_objects += $(TRANOBJS)

@

The {\bf NAGBROBJS} list contains files used to access the 
Numerical Algorithms Group (NAG) fortran libraries. 
These files should probably be autoloaded.
Note that [[${AUTO}/nag-e02a.$(OBJEXT)]] is not included in this
list as it is a subset of [[${AUTO}/nag-e02.$(OBJEXT)]].
<<environment>>=
NAGBROBJS= ${AUTO}/nag-c02.$(OBJEXT)   ${AUTO}/nag-c05.$(OBJEXT) \
           ${AUTO}/nag-c06.$(OBJEXT)   ${AUTO}/nag-d01.$(OBJEXT) \
           ${AUTO}/nag-d02.$(OBJEXT)   ${AUTO}/nag-d03.$(OBJEXT) \
           ${AUTO}/nag-e01.$(OBJEXT)   ${AUTO}/nag-e02.$(OBJEXT) \
           ${AUTO}/nag-e04.$(OBJEXT)   ${AUTO}/nag-f01.$(OBJEXT) \
           ${AUTO}/nag-f02.$(OBJEXT)   ${AUTO}/nag-f04.$(OBJEXT) \
           ${AUTO}/nag-f07.$(OBJEXT)   ${AUTO}/nag-s.$(OBJEXT) 

autoload_objects += $(NAGBROBJS)

@
The {\bf ASCOMP} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files should probably be autoloaded.
<<environment>>=
ASCOMP= hashcode.$(OBJEXT) as.$(OBJEXT) \
	foam_l.$(OBJEXT) axext_l.$(OBJEXT)

@
The {\bf ASAUTO} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files are autoloaded as needed.
<<environment>>=
ASAUTO= ${AUTO}/ax.$(OBJEXT)

autoload_objects += $(ASAUTO)
@

Axiom versions are given as a string of the form:
"Sunday September 21, 2003 at 20:38:05 "
which describe the day, date, and time of the build.
This is used for reporting bugs. It is only partially useful
in identifying which source code was used. Ideally we could create
a tar file of all of the date/time stamps of all of the source files
and use the MD5 hash of that file as the version stamp. Ultimately
though, this would be chasing the elusive "perfect information" idea.

A new variable [[boot::*build-version*]] is set here and used by the
[[yearweek]] function to display the version number of the Axiom build.
This information is set by hand in the top level Makefile.
<<environment>>=
TIMESTAMP=$(axiom_targetdir)/timestamp
YEARWEEK=(progn (setq timestamp "${TIMESTAMP}") \
                (setq boot::*build-version* "$(PACKAGE_STRING)") \
                (yearweek))

@
The {\bf .PRECIOUS} setting will keep make from deleting these
images if the build is stopped. Since once they are built they
are likely to be useable we don't need to redo the work if they
exist.
<<environment>>=

.PRECIOUS:	${DEPSYS}
.PRECIOUS:	${SAVESYS}
.PRECIOUS:	${AXIOMSYS}

@

\section{Codes from Pamphlets}

As noted earlier, the Boot codes are first extrated from the pamphlet
files:
<<extract source codes>>=
.PRECIOUS: %.boot
%.boot: $(srcdir)/%.boot.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<
@

The extracted Boot codes are then fed into \Tool{bootsys} which translates
them into Common Lisp codes:
<<extract source codes>>=
.PRECIOUS: %.clisp
%.clisp: %.boot
	$(BOOT_TO_LISP)
@

The resulting Common Lips codes are, in turn, compiled to object codes
using the \Tool{depsys} image.
<<extract source codes>>=
.PRECIOUS: %.$(OBJEXT)
%.$(OBJEXT): %.clisp
	$(COMPILE_LISP)
@

Part of the interpreter is written directly in Common Lisp (instead of the 
sugared dialect Boot).  That part is extracted from the pamphlet files
and compiled to native object code, as usual.
<<extract source codes>>=
# Extract and compile the part of the interpreter written
# in Common Lisp
.PRECIOUS: %.lisp
%.$(OBJEXT): %.lisp
	$(COMPILE_LISP)

%.lisp: $(srcdir)/%.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<
@

\section{Proclaim optimization}

\Tool{GCL}, and possibly other common lisps, can generate much better
code if the function argument types and return values are proclaimed.

In theory what we should do is scan all of the functions in the system
and create a file of proclaim definitions. These proclaim definitions
should be loaded into the image before we do any compiles so they can
allow the compiler to optimize function calling.

\Tool{GCL} has an approximation to this scanning which we use here. 

The first step is to build a version of GCL that includes [[gcl_collectfn]].
This file contains code that enhances the lisp compiler and creates a
hash table of structs. Each struct in the hash table describes information
that about the types of the function being compiled and the types of its
arguments. At the end of the compile-file this hash table is written out
to a ".fn" file. 

The second step is to build axiom images (depsys, interpsys, AXIOMsys)
which contain the [[gcl_collectfn]] code.

The third step is to build the system. This generates a .fn file for 
each lisp file that gets compiled.

The fourth step is to build the proclaims.lisp files. There is one
proclaims.lisp file for 
boot (boot-proclaims.lisp), 
interp (interp-proclaims.lisp), and 
algebra (algebra-proclaims.lisp).

To build the proclaims file (e.g. for interp) we:
\begin{verbatim}
(a) cd to obj/linux/interp
(b) (yourpath)/axiom/obj/linux/bin/lisp
(c) (load "sys-pkg.lsp") 
(d) (mapcar #'load (directory "*.fn"))
(e) (with-open-file (out "interp-proclaims.lisp" :direction :output) 
      (compiler::make-proclaims out))
\end{verbatim}
Note that step (c) is only used for interp, not for boot.

The fifth step is to copy the newly constructed proclaims file back
into the src/interp diretory (or boot, algebra).

In order for this information to be used during compiles we define
<<environment>>=
PROCLAIMS=(progn (load "sys-pkg.lisp") (load "$(srcdir)/interp-proclaims.lisp"))

@

We need a list of all of the pamphlet files so we can generate
the document files. In make's traditional "pull to the target"
fashion we need to provide a list of target dvi files.
<<environment>>=
DOCFILES=${DOC}/alql.boot.dvi \
	 ${DOC}/apply.boot.dvi ${DOC}/as.boot.dvi \
	 ${DOC}/astr.boot.dvi ${DOC}/ax.boot.dvi \
	 ${DOC}/axext_l.lisp.dvi \
	 ${DOC}/bc-matrix.boot.dvi ${DOC}/bc-misc.boot.dvi \
	 ${DOC}/bc-solve.boot.dvi ${DOC}/bc-util.boot.dvi \
	 ${DOC}/bits.lisp.dvi ${DOC}/bootfuns.lisp.dvi \
	 ${DOC}/bootlex.lisp.dvi ${DOC}/br-con.boot.dvi \
	 ${DOC}/br-data.boot.dvi ${DOC}/br-op1.boot.dvi \
	 ${DOC}/br-op2.boot.dvi ${DOC}/br-prof.boot.dvi \
	 ${DOC}/br-saturn.boot.dvi ${DOC}/br-search.boot.dvi \
	 ${DOC}/br-util.boot.dvi ${DOC}/buildom.boot.dvi \
	 ${DOC}/category.boot.dvi ${DOC}/cattable.boot.dvi \
	 ${DOC}/c-doc.boot.dvi ${DOC}/cformat.boot.dvi \
	 ${DOC}/cfuns.lisp.dvi ${DOC}/clam.boot.dvi \
	 ${DOC}/clammed.boot.dvi ${DOC}/compat.boot.dvi \
	 ${DOC}/compiler.boot.dvi ${DOC}/comp.lisp.dvi \
	 ${DOC}/compress.boot.dvi \
	 ${DOC}/cparse.boot.dvi ${DOC}/cstream.boot.dvi \
	 ${DOC}/c-util.boot.dvi ${DOC}/daase.lisp.dvi \
	 ${DOC}/database.boot.dvi ${DOC}/debug.lisp.dvi \
	 ${DOC}/define.boot.dvi \
	 ${DOC}/dq.boot.dvi \
	 ${DOC}/fname.lisp.dvi ${DOC}/fnewmeta.lisp.dvi \
	 ${DOC}/foam_l.lisp.dvi \
	 ${DOC}/format.boot.dvi ${DOC}/fortcall.boot.dvi \
	 ${DOC}/functor.boot.dvi ${DOC}/g-boot.boot.dvi \
	 ${DOC}/g-cndata.boot.dvi ${DOC}/g-error.boot.dvi \
	 ${DOC}/ggreater.lisp.dvi ${DOC}/g-opt.boot.dvi \
	 ${DOC}/g-timer.boot.dvi \
	 ${DOC}/g-util.boot.dvi ${DOC}/hashcode.boot.dvi \
	 ${DOC}/hash.lisp.dvi ${DOC}/htcheck.boot.dvi \
	 ${DOC}/ht-root.boot.dvi ${DOC}/htsetvar.boot.dvi \
	 ${DOC}/ht-util.boot.dvi ${DOC}/hypertex.boot.dvi \
	 ${DOC}/i-analy.boot.dvi ${DOC}/i-code.boot.dvi \
	 ${DOC}/i-coerce.boot.dvi ${DOC}/i-coerfn.boot.dvi \
	 ${DOC}/i-eval.boot.dvi ${DOC}/i-funsel.boot.dvi \
	 ${BOOK}/bookvol5.dvi ${DOC}/i-intern.boot.dvi \
	 ${DOC}/i-map.boot.dvi ${DOC}/incl.boot.dvi \
	 ${DOC}/info.boot.dvi ${DOC}/interop.boot.dvi \
	 ${DOC}/intfile.boot.dvi \
	 ${DOC}/intint.lisp.dvi ${DOC}/int-top.boot.dvi \
	 ${DOC}/i-output.boot.dvi ${DOC}/i-resolv.boot.dvi \
	 ${DOC}/i-spec1.boot.dvi ${DOC}/i-spec2.boot.dvi \
	 ${DOC}/i-syscmd.boot.dvi ${DOC}/iterator.boot.dvi \
	 ${DOC}/i-toplev.boot.dvi ${DOC}/i-util.boot.dvi \
	 ${DOC}/lisplib.boot.dvi ${DOC}/macex.boot.dvi \
	 ${DOC}/macros.lisp.dvi ${DOC}/Makefile.dvi \
	 ${DOC}/mark.boot.dvi ${DOC}/match.boot.dvi \
	 ${DOC}/metalex.lisp.dvi ${DOC}/metameta.lisp.dvi \
	 ${DOC}/modemap.boot.dvi ${DOC}/monitor.lisp.dvi \
	 ${DOC}/msg.boot.dvi ${DOC}/msgdb.boot.dvi \
	 ${DOC}/nag-c02.boot.dvi ${DOC}/nag-c05.boot.dvi \
	 ${DOC}/nag-c06.boot.dvi ${DOC}/nag-d01.boot.dvi \
	 ${DOC}/nag-d02.boot.dvi ${DOC}/nag-d03.boot.dvi \
	 ${DOC}/nag-e01.boot.dvi \
	 ${DOC}/nag-e02.boot.dvi \
	 ${DOC}/nag-e04.boot.dvi ${DOC}/nag-f01.boot.dvi \
	 ${DOC}/nag-f02.boot.dvi ${DOC}/nag-f04.boot.dvi \
	 ${DOC}/nag-f07.boot.dvi ${DOC}/nag-s.boot.dvi \
	 ${DOC}/nci.lisp.dvi ${DOC}/newaux.lisp.dvi \
	 ${DOC}/newfort.boot.dvi \
	 ${DOC}/nlib.lisp.dvi ${DOC}/nocompil.lisp.dvi \
	 ${DOC}/nruncomp.boot.dvi ${DOC}/nrunfast.boot.dvi \
	 ${DOC}/nrungo.boot.dvi ${DOC}/nrunopt.boot.dvi \
	 ${DOC}/nruntime.boot.dvi ${DOC}/nspadaux.lisp.dvi \
	 ${DOC}/obey.lisp.dvi ${DOC}/osyscmd.boot.dvi \
	 ${DOC}/package.boot.dvi ${DOC}/packtran.boot.dvi \
	 ${DOC}/parini.boot.dvi ${DOC}/parse.boot.dvi \
	 ${DOC}/parsing.lisp.dvi ${DOC}/patches.lisp.dvi \
	 ${DOC}/pathname.boot.dvi \
	 ${DOC}/pf2sex.boot.dvi ${DOC}/pile.boot.dvi \
	 ${DOC}/posit.boot.dvi ${DOC}/postpar.boot.dvi \
	 ${DOC}/postprop.lisp.dvi ${DOC}/preparse.lisp.dvi \
	 ${DOC}/profile.boot.dvi ${DOC}/property.lisp.dvi \
	 ${DOC}/pspad1.boot.dvi ${DOC}/pspad2.boot.dvi \
	 ${DOC}/ptrees.boot.dvi ${DOC}/ptrop.boot.dvi \
	 ${DOC}/record.boot.dvi \
	 ${DOC}/rulesets.boot.dvi ${DOC}/scan.boot.dvi \
	 ${DOC}/serror.boot.dvi ${DOC}/server.boot.dvi \
	 ${DOC}/setq.lisp.dvi ${DOC}/setvars.boot.dvi \
	 ${DOC}/setvart.boot.dvi ${DOC}/sfsfun.boot.dvi \
	 ${DOC}/sfsfun-l.lisp.dvi \
	 ${DOC}/showimp.boot.dvi ${DOC}/simpbool.boot.dvi \
	 ${DOC}/slam.boot.dvi ${DOC}/sockio.lisp.dvi \
	 ${DOC}/spaderror.lisp.dvi ${DOC}/spad.lisp.dvi \
	 ${DOC}/sys-pkg.lisp.dvi ${DOC}/template.boot.dvi \
	 ${DOC}/termrw.boot.dvi ${DOC}/topics.boot.dvi \
	 ${DOC}/trace.boot.dvi \
	 ${DOC}/union.lisp.dvi ${DOC}/unlisp.lisp.dvi \
	 ${DOC}/util.lisp.dvi ${DOC}/varini.boot.dvi \
	 ${DOC}/vmlisp.lisp.dvi ${DOC}/wi1.boot.dvi \
	 ${DOC}/wi2.boot.dvi \
	 ${DOC}/xrun.boot.dvi ${DOC}/xruncomp.boot.dvi 

@

\section{The warm.data file}

This is a file of commands that will be loaded into interpsys
at the last minute. It execute functions that will likely be
used in a running system so all of the required routines will
be in the lisp image thus minimizing their startup time.
<<warm.data.stanza>>=
./$(top_builddir)/int/algebra/warm.data: $(srcdir)/Makefile.pamphlet
	@ echo 2 building warm.data
	$(axiom_build_document) --tangle=warm.data --output=$@ $<

@

<<warm.data>>=
(in-package 'boot)
(setq |$topicHash| (make-hash-table))
(setf (gethash '|basic| |$topicHash|) 2)
(setf (gethash '|algebraic| |$topicHash|) 4)
(setf (gethash '|miscellaneous| |$topicHash|) 13)
(setf (gethash '|extraction| |$topicHash|) 6)
(setf (gethash '|conversion| |$topicHash|) 7)
(setf (gethash '|hidden| |$topicHash|) 3)
(setf (gethash '|extended| |$topicHash|) 1)
(setf (gethash '|destructive| |$topicHash|) 5)
(setf (gethash '|transformation| |$topicHash|) 10)
(setf (gethash '|hyperbolic| |$topicHash|) 12)
(setf (gethash '|construct| |$topicHash|) 9)
(setf (gethash '|predicate| |$topicHash|) 8)
(setf (gethash '|trignometric| |$topicHash|) 11)

@

\section{UNUSED}

These files were in the interp distribution from NAG but have
no purpose at the moment. This belief is no doubt due to my
lack of understanding. Rather than erase them they are documented
here for future reference. [[${DOC}/nag-e02a.boot.dvi]] and
[[${DOC}/nag-e02b.boot.dvi]] appear to be two halfs of the file
[[${DOC}/nag-e02.boot.dvi]] and have been removed.
<<environment>>=
UNUSED= ${DOC}/anna.boot.dvi ${DOC}/construc.lisp.dvi \
	${DOC}/domain.lisp.dvi 	${DOC}/guess.boot.dvi \
	${DOC}/interp-fix.boot.dvi \
	${DOC}/nhyper.boot.dvi ${DOC}/pf2atree.boot.dvi \
	${DOC}/redefs.boot.dvi 	${DOC}/word.boot.dvi 

@

\section{Building DEPSYS}

\begin{verbatim}
NOTES: depsys proceeds all else. it is the compile-time environment
for all interpreter code. 
:oldboot is pushed on the features list because there is a function
in util.lisp that emulates the new boot parser command BOOTTOCL. since
we eventually plan to move to the new boot parser this function (and
the push should disappear.
the load of postpar and parse (without extensions) allows the .${LISP} form
to be loaded in a virgin system. however, if depsys is recreated then
the compiled form will get loaded.
\end{verbatim}

\subsection{save depsys image}

Once the appropriate commands are in the [[makedep.lisp]] file
we can load the file into a fresh image and save it. At least that's
how it used to work. In freebsd we cannot do this so we have to use
a much more complicated procedure.
This code used to read:
\begin{verbatim}
<<save depsys image>>=
	@ echo '(progn (load "makedep.lisp") (spad-save "$@"))' \
               | ${LISPSYS}
@
\end{verbatim}

Now game is much more difficult. 
\begin{verbatim}

 '(progn \

\end{verbatim}

[[si::*collect-binary-modules*]] instructs GCL to build a list of 
binary object modules loaded into the current session with (load ...)
The list will be stored in [[si::*binary-modules*]].
\begin{verbatim}

	       (setq si::*collect-binary-modules* t) \
	       (load "makedep.lisp") \

\end{verbatim}

[[compiler::link]] is a lisp interface to the ``ld'' C-based system linker.
The first argumet is a list of [[.o]] binary object modules to link into a
fresh gcl image. The second argument is the name of the new output
image.  The third argument is a string containing an initialization
command to run in the new image to reinitialize the heap.  The fourth
argument is a list of external C libraries, either static or dynamic,
that one wishes to link into the fresh image.  The last argument is a
flag which indicates whether GCL should initialize all of the freshly
linked in new lisp modules, or whether it should transparently
redirect load calls in the new image to initialization calls for the
already linked in module.

Some lisp systems, such as acl2, have a complex heap initialization,
in which load calls must be interspersed with other form evaluation
comprising the logic of the heap construction.  Others, such as
maxima, have no such complex initialization sequence.
\begin{verbatim}

	       (compiler::link \

\end{verbatim}
[[si::*binary-modules*]] here has the list of compiled lisp binary module
.o files loaded by makedep.lsp above.
\begin{verbatim}

				 (remove-duplicates si::*binary-modules* :test (quote equal)) \

\end{verbatim}

The name of the output image.
\begin{verbatim}

				 "$(DEPSYS)" \

\end{verbatim}

This will be run in the newly linked sub-image.
\begin{verbatim}

				 (format nil "\

\end{verbatim}

Collect loaded binary modules again to make sure that there are none,
as all should be already linked in via ld.  For error checking
purposes.
\begin{verbatim}

(setq si::*collect-binary-modules* t) \

\end{verbatim}

We need to find [[gcl_collectfn.lsp]], so set the [[*load-path*]], and make
sure the source, not the binary, form is loaded here, as we're only
using this entire sequence on machines which cannot load binary object
modules and preserve them in saved images.
\begin{verbatim}

(let ((si::*load-path* (cons ~S si::*load-path*))\
                                     (si::*load-types* ~S))\

\end{verbatim}

Turn on function analyzation and autoload thereby [[gcl_collectfn.lsp]].
\begin{verbatim}

(compiler::emit-fn t))\

\end{verbatim}

Load the heap creation sequence again in the fresh new image, this
time transparently redirecting all calls to load of binary modules
invoked thereby into initialization calls for the already linkned in
module.

Load has code in it to recognize when a module is already linked in,
and to forgo in this case the actual load and replace with a mere
initialization call instead.
\begin{verbatim}

(load \"makedep.lisp\")\

(gbc t)\

\end{verbatim}

It is an error to load a binary module. Calling load will not
reload them but only run initialization.
Throw an error if we've actually loaded any binary modules.
\begin{verbatim}

(when si::*binary-modules* \
(error si::*binary-modules*))\

\end{verbatim}

Unset the binary module collection flags.
\begin{verbatim}

(setq si::collect-binary-modules* nil si::*binary-modules* nil)\
(gbc t)\

\end{verbatim}

Turn on SGC (Stratified Garbage Collection) in the final image.  This
is a optional gbc algorithm which is suitable for images which will
not grow much further.  It marks a large fraction of the heap
read-only, eliminating such pages from the time-consuming gbc
processing.  When writes are actually made to such pages, a segfault
is triggered which is handled by a function which remarks the pages
read-write and continues.
\begin{verbatim}

(when (fboundp (quote si::sgc-on)) (si::sgc-on t))\

\end{verbatim}

This is a flag which instructs the GCL compiler to make unique
initialzation function C names.  This is necessary when using ld, as
all function names must be unique.
\begin{verbatim}

(setq compiler::*default-system-p* t)\

si::*system-directory* goes into the *load-path*, and .lsp in the *load-types*.

" si::*system-directory* (quote (list ".lsp")))\

\end{verbatim}
No C libraries to link in here.
\begin{verbatim}

"" \

\end{verbatim}

Do not run the initialization code for the newly linked in lisp
modules ``by hand'', but rather rely on the transparent load redirection
described above to initialize at the proper moment in the heap
initialization sequence.
\begin{verbatim}

nil))' | $(LISPSYS))

\end{verbatim}
The [[save depsys image]] was supposed to read:
\begin{verbatim}
	@ (cd ${OBJ}/${SYS}/bin ; \
	   echo '(progn \
		(setq si::*collect-binary-modules* t) \
		(load "makedep.lisp") \
		(compiler::link \
			(remove-duplicates si::*binary-modules* :test (quote equal)) \
			"$(DEPSYS)" \
			(format nil "\
				(setq si::*collect-binary-modules* t) \
				(let ((si::*load-path* (cons ~S si::*load-path*))\
					(si::*load-types* ~S))\
					(compiler::emit-fn t))\
				(load \"makedep.lisp\")\
				(gbc t)\
				(when si::*binary-modules* \
					(error si::*binary-modules*))\
				(setq si::collect-binary-modules* nil si::*binary-modules* nil)\
				(gbc t)\
				(when (fboundp (quote si::sgc-on)) (si::sgc-on t))\
				(setq compiler::*default-system-p* t)\
			" si::*system-directory* (quote (list ".lsp")))\
			"" \
			nil))' | $(LISPSYS))
\end{verbatim}

This scheme does not work. It fails during loading with multiple messages
of the form:
\begin{verbatim}
/home/axiom--main--1--patch-33/obj/linux/interp/parse.o(.text+0x5660): In function `init_code':
: multiple definition of `init_code'
/home/axiom--main--1--patch-33/obj/linux/interp/postpar.o(.text+0x4e78): first defined here
\end{verbatim}

<<depsys>>=
depsys_lisp_sources += parsing.lisp metalex.lisp bootlex.lisp \
			newaux.lisp preparse.lisp postprop.lisp \
			metameta.lisp fnewmeta.lisp

depsys_boot_sources = postpar.boot parse.boot clam.boot slam.boot \
			g-boot.boot c-util.boot g-util.boot

depsys_SOURCES = $(depsys_lisp_SOURCES) $(depsys_boot_SOURCES)

depsys_objects = nocompil.$(OBJEXT) bookvol5.$(OBJEXT) \
		util.$(OBJEXT) postpar.$(OBJEXT) parse.$(OBJEXT) \
		parsing.$(OBJEXT) metalex.$(OBJEXT) bootlex.$(OBJEXT) \
		newaux.$(OBJEXT) preparse.$(OBJEXT) postprop.$(OBJEXT) \
		metameta.$(OBJEXT) fnewmeta.$(OBJEXT) clam.$(OBJEXT) \
		slam.$(OBJEXT) g-boot.$(OBJEXT) c-util.$(OBJEXT) \
		g-util.$(OBJEXT)

${DEPSYS}:	${DEP} sys-pkg.lisp nocompil.lisp \
	        bookvol5.lisp util.lisp \
	        postpar.clisp parse.clisp \
	        parsing.lisp metalex.lisp \
	        bootlex.lisp newaux.lisp \
	        preparse.lisp \
	        postprop.lisp def.lisp \
	        metameta.lisp fnewmeta.lisp \
	        g-boot.${LISP} c-util.${LISP} \
	        g-util.${LISP} \
	        clam.${LISP} \
	        slam.${LISP}
	@ echo 3 making ${DEPSYS} 
	@ $(mkinstalldirs) $(axiom_build_bindir)
	@ echo '${PROCLAIMS}' > makedep.lisp
	@ echo '(push :oldboot *features*)' >> makedep.lisp
	@ echo '(load "nocompil.lisp")' >> makedep.lisp
	@ echo '(load "bookvol5.lisp")' >> makedep.lisp
	@ echo '(load "util.lisp")' >> makedep.lisp
	@ echo '(in-package "BOOT")' >> makedep.lisp
	@ echo '(build-depsys (quote ($(patsubst %, "%", ${DEP}))) "${AXIOM}" "$(builddir)")' >> makedep.lisp
	@ echo '(unless (probe-file "postpar.$(OBJEXT)") (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "postpar")' >> makedep.lisp
	@ echo '(unless (probe-file "parse.$(OBJEXT)") (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "parse")' >> makedep.lisp
	@ echo '(unless (probe-file "parsing.$(OBJEXT)") (compile-file "parsing.lisp" :output-file "parsing.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "parsing")' >> makedep.lisp
	@ echo '(unless (probe-file "metalex.$(OBJEXT)") (compile-file "metalex.lisp" :output-file "metalex.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "metalex")' >> makedep.lisp
	@ echo '(unless (probe-file "bootlex.$(OBJEXT)") (compile-file "bootlex.lisp" :output-file "bootlex.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "bootlex")' >> makedep.lisp
	@ echo '(unless (probe-file "newaux.$(OBJEXT)") (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "newaux")' >> makedep.lisp
	@ echo '(unless (probe-file "preparse.$(OBJEXT)") (compile-file "preparse.lisp" :output-file "preparse.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "preparse")' >> makedep.lisp
	@ echo '(unless (probe-file "postprop.$(OBJEXT)") (compile-file "postprop.lisp" :output-file "postprop.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "postprop")' >> makedep.lisp
	@ echo '(unless (probe-file "def.$(OBJEXT)") (compile-file "def.lisp" :output-file "def.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "def")' >> makedep.lisp
	@ echo '(unless (probe-file "metameta.$(OBJEXT)") (compile-file "metameta.lisp" :output-file "metameta.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "metameta")' >> makedep.lisp
	@ echo '(unless (probe-file "fnewmeta.$(OBJEXT)") (compile-file "fnewmeta.lisp" :output-file "fnewmeta.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "fnewmeta")' >> makedep.lisp
	@ echo '(unless (probe-file "clam.$(OBJEXT)") (compile-file "clam.${LISP}" :output-file "clam.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "clam")' >> makedep.lisp
	@ echo '(unless (probe-file "slam.$(OBJEXT)") (compile-file "slam.${LISP}" :output-file "slam.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "slam")' >> makedep.lisp
	@ echo '(unless (probe-file "g-boot.$(OBJEXT)") (compile-file "g-boot.${LISP}" :output-file "g-boot.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "g-boot")' >> makedep.lisp
	@ echo '(unless (probe-file "c-util.$(OBJEXT)") (compile-file "c-util.${LISP}" :output-file "c-util.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "c-util")' >> makedep.lisp
	@ echo '(unless (probe-file "g-util.$(OBJEXT)") (compile-file "g-util.${LISP}" :output-file "g-util.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "g-util")' >> makedep.lisp
<<save depsys image>>
	@ echo 4 ${DEPSYS} created
@

\section{Building SAVESYS and AXIOMSYS}

GCL likes to tell you when it has replaced a function call by a 
tail-recursive call. This happens when the last form in a function
is a call to the same function. In general, we don't care so we set
compiler::*suppress-compiler-notes* to true in order to reduce the noise.

Notice that when Axiom uses GCL as the Lisp platform, it is usually not 
a good idea to mess with GCL's internal variables.  In particular, GCL
has its own idea about what to do with [[si::*system-directory*]], which 
should not be set here just because we happen to save an GCL-based image.
Doing otherwise causes havoc.

<<savesys>>=
makeint.lisp:	${DEPSYS} ${OBJS} bookvol5.$(OBJEXT) util.$(OBJEXT) \
                nocompil.lisp sys-pkg.lisp \
	        ${OUTINTERP} ${OCOBJS} ${OPOBJS} ${BROBJS} obey.$(OBJEXT) \
		database.date ${INOBJS} ${ASCOMP} ${ASAUTO} \
		${NAGBROBJS} ${TRANOBJS} \
	        ${LOADSYS} \
		$(axiom_targetdir)/algebra/exposed.$(OBJEXT) \
		$(axiom_src_docdir)/msgs/s2-us.msgs \
	        ./$(top_builddir)/int/algebra/warm.data
	@ echo 5 invoking make in `pwd` with parms:
	@ echo SYS= ${SYS} 
	@ echo LISP=${LISP} BYE=${BYE}
	$(mkinstalldirs) $(axiom_target_datadir)/msgs
	$(INSTALL_DATA) $(axiom_src_docdir)/msgs/s2-us.msgs \
		 $(axiom_target_datadir)/msgs
	@ echo '${PROCLAIMS}' > makeint.lisp
	@ echo '(load "nocompil.lisp")' >> makeint.lisp
	@ echo '(load "bookvol5")' >> makeint.lisp
	@ echo '(load "util")' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ touch ${TIMESTAMP}
	@ echo '${YEARWEEK}' >> makeint.lisp
	@ echo '(build-interpsys (append (quote ($(patsubst %, "%", ${OBJS}))) (quote ($(patsubst %, "%", ${ASCOMP}))) (quote ($(patsubst %, "%", ${INOBJS})))) (quote ($(patsubst %, "%", ${OPOBJS}))) (quote ($(patsubst %, "%", ${OCOBJS}))) (quote ($(patsubst %, "%", ${BROBJS}))) (quote ($(patsubst %, "%", ${TRANOBJS}))) (quote ($(patsubst %, "%", ${NAGBROBJS}))) (quote ($(patsubst %, "%", ${ASAUTO})))  "${AXIOM}")' >> makeint.lisp
	@ echo '(in-package "SCRATCHPAD-COMPILER")' >> makeint.lisp
	@ echo '(boot::set-restart-hook)' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ echo '(load "./$(top_builddir)/int/algebra/warm.data")' >> makeint.lisp
	@ echo '(|clearClams|)' >> makeint.lisp
	@ echo '(load "obey")' >> makeint.lisp
	@ echo '#+:akcl (setq compiler::*suppress-compiler-notes* t)' >> makeint.lisp
	@ echo '#+:akcl (si::gbc-time 0)' >> makeint.lisp

${SAVESYS}: makeint.lisp
	echo '(progn (gbc t) (load "makeint.lisp") (gbc t) (user::spad-save "$@"))' | DAASE="$(axiom_src_datadir)" ${LISPSYS}
	@ echo 6 ${SAVESYS} created
	$(mkinstalldirs) $(axiom_target_bindir)
@

\section{Building SAVESYS and AXIOMSYS}

We want to cache database data in the final image, so we dump it only
after databases are build (triggered from \File{etc/Makefile.pamphlet}).
Note that having dependency on databases is not enough, since databases
are re-generated after leaving \File{interp/} directory.

<<axiomsys>>=
.PHONY: all-axiomsys

all-axiomsys: ${AXIOMSYS}

${AXIOMSYS}: makeint.lisp
	echo '(progn (gbc t) (load "makeint.lisp") (gbc t)' \
	   '(user::spad-save "$@"))' | DAASE="$(axiom_targetdir)" ${LISPSYS}
	@ echo 6a ${AXIOMSYS} created
@

\section{Building debugsys}
Note that we assume you've already built interpsys so all of the
files are known to exist and be up to date. We don't list any of
the preconditions here. 
<<debugsys>>=
${DEBUGSYS}: debugsys.lisp
	@ echo 7 building debugsys
	@ echo '(progn (gbc t) (load "debugsys.lisp") (user::spad-save "$@"))' | ${LISPSYS}
	@ echo 8 ${DEBUGSYS} created

@

\section{The Interpreter files}

\subsection{DVI files from pmaphlet files}
<<DVI from pamphlet>>=
.PRECIOUS: $(builddir)/%.tex
.PRECIOUS: $(builddir)/%.dvi

$(DOCFILES): $(DOC) $(axiom_build_texdir)/diagrams.tex

$(DOC):
	$(mkinstalldirs) $@

$(DOC)/%.dvi: $(builddir)/%.dvi
	$(INSTALL_DATA) $< $@

$(builddir)/%.dvi: $(axiom_build_texdir)/axiom.sty

$(builddir)/%.dvi: $(builddir)/%.tex
	$(axiom_build_document) --latex $< $(SINK_NOISE)

$(builddir)/%.tex: $(srcdir)/%.pamphlet
	$(axiom_build_document) --weave --output=$@ $<

$(axiom_build_texdir)/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	$(INSTALL_DATA) $< $@
@

\subsection{apply.boot \cite{7}}
<<apply.o (AUTO from OUT)>>=
${AUTO}/apply.$(OBJEXT): apply.$(OBJEXT)
	@ echo 9 making ${AUTO}/apply.$(OBJEXT) from apply.$(OBJEXT)
	@ cp apply.$(OBJEXT) ${AUTO}

@
<<apply.o (OUT from MID)>>=
apply.$(OBJEXT): apply.clisp 
	@ echo 10 making apply.$(OBJEXT) from apply.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "apply.clisp" :output-file "apply.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "apply.clisp" :output-file "apply.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<apply.clisp>>=
apply.clisp: apply.boot
	@ echo 11 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "apply.boot"))' | ${DEPSYS} ; \
	   else \
	   echo '(progn (boottran::boottocl "apply.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
           fi ;

@

\subsection{bootlex.lisp \cite{9}}
<<bootlex.o (AUTO from OUT)>>=
${AUTO}/bootlex.$(OBJEXT): bootlex.$(OBJEXT)
	@ echo 19 making ${AUTO}/bootlex.$(OBJEXT) from bootlex.$(OBJEXT)
	@ cp bootlex.$(OBJEXT) ${AUTO}

@

\subsection{debugsys.lisp \cite{14}}
The {\bf debugsys.lisp} file is used to create a {\bf debugsys} runnable image.
This image contains almost all of the lisp code that make up the axiom
interpreter in lisp form. It is useful for deep system debugging but
otherwise worthless. This file is certain to drift over time as changes
are made elsewhere to add or remove files. It is assumed that you know
what you are doing if you change this file or use debugsys.

This file is basically the same as the one created during the build of
interpsys. See the echo lines in the {\bf SAVESYS} block above. These
are echoed into a temporary file which gets loaded into the lisp image.
We simply captured that temporary file, replaced the .o files with .lisp
files (or .lsp or .clisp) and saved it here.
<<debugsys.lisp>>=
debugsys.lisp: $(srcdir)/debugsys.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<
@

\subsection{def.lisp \cite{15}}
<<def.o (AUTO from OUT)>>=
${AUTO}/def.$(OBJEXT): def.$(OBJEXT)
	@ echo 41 making ${AUTO}/def.$(OBJEXT) from def.$(OBJEXT)
	@ cp def.$(OBJEXT) ${AUTO}

@

\subsection{fnewmeta.lisp \cite{18}}
<<fnewmeta.o (AUTO from OUT)>>=
${AUTO}/fnewmeta.$(OBJEXT): fnewmeta.$(OBJEXT)
	@ echo 49 making ${AUTO}/fnewmeta.$(OBJEXT) from fnewmeta.$(OBJEXT)
	@ cp fnewmeta.$(OBJEXT) ${AUTO}

@

\subsection{fortcall.boot \cite{16}}
<<fortcall.o (OUT from MID)>>=
fortcall.$(OBJEXT): fortcall.clisp 
	@ echo 54 making fortcall.$(OBJEXT) from fortcall.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "fortcall.clisp" :output-file "fortcall.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "fortcall.clisp" :output-file "fortcall.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<fortcall.clisp>>=
fortcall.clisp: fortcall.boot
	@ echo 55 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "fortcall.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "fortcall.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{metalex.lisp \cite{22}}
<<metalex.o (AUTO from OUT)>>=
${AUTO}/metalex.$(OBJEXT): metalex.$(OBJEXT)
	@ echo 66 making ${AUTO}/metalex.$(OBJEXT) from metalex.$(OBJEXT)
	@ cp metalex.$(OBJEXT) ${AUTO}

@

\subsection{metameta.lisp \cite{23}}
<<metameta.o (AUTO from OUT)>>=
${AUTO}/metameta.$(OBJEXT): metameta.$(OBJEXT)
	@ echo 71 making ${AUTO}/metameta.$(OBJEXT) from metameta.$(OBJEXT)
	@ cp metameta.$(OBJEXT) ${AUTO}

@

\subsection{newaux.lisp \cite{25}}
<<newaux.o (OUT from MID)>>=
newaux.$(OBJEXT): newaux.lisp
	@ echo 79 making newaux.$(OBJEXT) from newaux.lisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<newaux.lisp (OUT from MID)>>=
newaux.${LISP}: newaux.lisp
	@ echo 80 making newaux.${LISP} from newaux.lisp
	@cp newaux.lisp newaux.${LISP}

@
<<newaux.lisp>>=
newaux.lisp: $(srcdir)/newaux.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<
@

\subsection{nspadaux.lisp \cite{28}}
<<nspadaux.o (AUTO from OUT)>>=
${AUTO}/nspadaux.$(OBJEXT): nspadaux.$(OBJEXT)
	@ echo 89 making ${AUTO}/nspadaux.$(OBJEXT) from nspadaux.$(OBJEXT)
	@ cp nspadaux.$(OBJEXT) ${AUTO}

@

\subsection{parsing.lisp \cite{29}}
<<parsing.o (AUTO from OUT)>>=
${AUTO}/parsing.$(OBJEXT): parsing.$(OBJEXT)
	@ echo 94 making ${AUTO}/parsing.$(OBJEXT) from parsing.$(OBJEXT)
	@ cp parsing.$(OBJEXT) ${AUTO}

@

\subsection{postprop.lisp \cite{30}}
<<postprop.lisp (AUTO from OUT)>>=
${AUTO}/postprop.$(OBJEXT): postprop.$(OBJEXT)
	@ echo 102 making $@ from $<
	@ cp $< ${AUTO}

@

\subsection{preparse.lisp \cite{31}}
<<preparse.o (AUTO from OUT)>>=
${AUTO}/preparse.$(OBJEXT): preparse.$(OBJEXT)
	@ echo 106 making ${AUTO}/preparse.$(OBJEXT) from preparse.$(OBJEXT)
	@ cp preparse.$(OBJEXT) ${AUTO}

@

\subsection{buildom.boot \cite{41}}
<<buildom.o (OUT from MID)>>=
buildom.$(OBJEXT): buildom.clisp 
	@ echo 142 making buildom.$(OBJEXT) from buildom.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "buildom.clisp" :output-file "buildom.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "buildom.clisp" :output-file "buildom.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<buildom.clisp>>=
buildom.clisp: buildom.boot
	@ echo 143 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "buildom.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "buildom.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{c-util.boot \cite{42}}
<<c-util.o (AUTO from OUT)>>=
${AUTO}/c-util.$(OBJEXT): c-util.$(OBJEXT)
	@ echo 145 making ${AUTO}/c-util.$(OBJEXT) from c-util.$(OBJEXT)
	@ cp c-util.$(OBJEXT) ${AUTO}

@
Note that the {\bf c-util.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf c-util.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN C-UTIL.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE C-UTIL.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<c-util.lisp (OUT from IN)>>=
c-util.${LISP}: $(srcdir)/c-util.boot.pamphlet
	@ echo 146 making c-util.${LISP} from $(srcdir)/c-util.boot.pamphlet
	@ rm -f c-util.$(OBJEXT)
	$(axiom_build_document) --tangle=c-util.clisp --output=$@ $<

@
<<c-util.o (OUT from MID)>>=
c-util.$(OBJEXT): c-util.clisp 
	@ echo 147 making c-util.$(OBJEXT) from c-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "c-util.clisp" :output-file "c-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "c-util.clisp" :output-file "c-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<c-util.clisp>>=
c-util.clisp: c-util.boot
	@ echo 148 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "c-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "c-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nag-c02.boot \cite{43}}
<<nag-c02.o (AUTO from OUT)>>=
${AUTO}/nag-c02.$(OBJEXT): nag-c02.$(OBJEXT)
	@ echo 150 making${AUTO}/nag-c02.$(OBJEXT) from nag-c02.$(OBJEXT)
	@ cp nag-c02.$(OBJEXT) ${AUTO}

@
<<nag-c02.o (OUT from MID)>>=
nag-c02.$(OBJEXT): nag-c02.clisp
	@ echo 151 making nag-c02.$(OBJEXT) from nag-c02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-c02.clisp" :output-file "nag-c02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-c02.clisp" :output-file "nag-c02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-c02.clisp>>=
nag-c02.clisp: nag-c02.boot
	@ echo 152 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nag-c05.boot \cite{44}}
<<nag-c05.o (AUTO from OUT)>>=
${AUTO}/nag-c05.$(OBJEXT): nag-c05.$(OBJEXT)
	@ echo 154 making ${AUTO}/nag-c05.$(OBJEXT) from nag-c05.$(OBJEXT)
	@ cp nag-c05.$(OBJEXT) ${AUTO}

@
<<nag-c05.o (OUT from MID)>>=
nag-c05.$(OBJEXT): nag-c05.clisp
	@ echo 155 making nag-c05.$(OBJEXT) from nag-c05.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-c05.clisp" :output-file "nag-c05.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-c05.clisp" :output-file "nag-c05.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-c05.clisp>>=
nag-c05.clisp: nag-c05.boot
	@ echo 156 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c05.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c05.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nag-c06.boot \cite{45}}
<<nag-c06.o (AUTO from OUT)>>=
${AUTO}/nag-c06.$(OBJEXT): nag-c06.$(OBJEXT)
	@ echo 158 making${AUTO}/nag-c06.$(OBJEXT) from nag-c06.$(OBJEXT)
	@ cp nag-c06.$(OBJEXT) ${AUTO}

@
<<nag-c06.o (OUT from MID)>>=
nag-c06.$(OBJEXT): nag-c06.clisp
	@ echo 159 making nag-c06.$(OBJEXT) from nag-c06.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-c06.clisp" :output-file "nag-c06.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-c06.clisp" :output-file "nag-c06.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-c06.clisp>>=
nag-c06.clisp: nag-c06.boot
	@ echo 160 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c06.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c06.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-d01.boot \cite{46}}
<<nag-d01.o (AUTO from OUT)>>=
${AUTO}/nag-d01.$(OBJEXT): nag-d01.$(OBJEXT)
	@ echo 162 making${AUTO}/nag-d01.$(OBJEXT) from nag-d01.$(OBJEXT)
	@ cp nag-d01.$(OBJEXT) ${AUTO}

@
<<nag-d01.o (OUT from MID)>>=
nag-d01.$(OBJEXT): nag-d01.clisp
	@ echo 163 making nag-d01.$(OBJEXT) from nag-d01.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-d01.clisp" :output-file "nag-d01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-d01.clisp" :output-file "nag-d01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-d01.clisp>>=
nag-d01.clisp: nag-d01.boot
	@ echo 164 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-d02.boot \cite{47}}
<<nag-d02.o (AUTO from OUT)>>=
${AUTO}/nag-d02.$(OBJEXT): nag-d02.$(OBJEXT)
	@ echo 166 making${AUTO}/nag-d02.$(OBJEXT) from nag-d02.$(OBJEXT)
	@ cp nag-d02.$(OBJEXT) ${AUTO}

@
<<nag-d02.o (OUT from MID)>>=
nag-d02.$(OBJEXT): nag-d02.clisp
	@ echo 167 making nag-d02.$(OBJEXT) from nag-d02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-d02.clisp" :output-file "nag-d02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-d02.clisp" :output-file "nag-d02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-d02.clisp>>=
nag-d02.clisp: nag-d02.boot
	@ echo 168 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-d03.boot \cite{48}}
<<nag-d03.o (AUTO from OUT)>>=
${AUTO}/nag-d03.$(OBJEXT): nag-d03.$(OBJEXT)
	@ echo 170 making${AUTO}/nag-d03.$(OBJEXT) from nag-d03.$(OBJEXT)
	@ cp nag-d03.$(OBJEXT) ${AUTO}

@
<<nag-d03.o (OUT from MID)>>=
nag-d03.$(OBJEXT): nag-d03.clisp
	@ echo 171 making nag-d03.$(OBJEXT) from nag-d03.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-d03.clisp" :output-file "nag-d03.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-d03.clisp" :output-file "nag-d03.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-d03.clisp>>=
nag-d03.clisp: nag-d03.boot
	@ echo 172 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d03.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d03.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-e01.boot \cite{49}}
<<nag-e01.o (AUTO from OUT)>>=
${AUTO}/nag-e01.$(OBJEXT): nag-e01.$(OBJEXT)
	@ echo 174 making ${AUTO}/nag-e01.$(OBJEXT) from nag-e01.$(OBJEXT)
	@ cp nag-e01.$(OBJEXT) ${AUTO}

@
<<nag-e01.o (OUT from MID)>>=
nag-e01.$(OBJEXT): nag-e01.clisp
	@ echo 175 making nag-e01.$(OBJEXT) from nag-e01.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-e01.clisp" :output-file "nag-e01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-e01.clisp" :output-file "nag-e01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-e01.clisp>>=
nag-e01.clisp: nag-e01.boot
	@ echo 176 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-e02.boot \cite{51}}
<<nag-e02.o (AUTO from OUT)>>=
${AUTO}/nag-e02.$(OBJEXT): nag-e02.$(OBJEXT)
	@ echo 182 making ${AUTO}/nag-e02.$(OBJEXT) from nag-e02.$(OBJEXT)
	@ cp nag-e02.$(OBJEXT) ${AUTO}

@
<<nag-e02.o (OUT from MID)>>=
nag-e02.$(OBJEXT): nag-e02.clisp
	@ echo 183 making nag-e02.$(OBJEXT) from nag-e02.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-e02.clisp" :output-file "nag-e02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-e02.clisp" :output-file "nag-e02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-e02.clisp>>=
nag-e02.clisp: nag-e02.boot
	@ echo 184 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-e04.boot \cite{52}}
<<nag-e04.o (AUTO from OUT)>>=
${AUTO}/nag-e04.$(OBJEXT): nag-e04.$(OBJEXT)
	@ echo 186 making ${AUTO}/nag-e04.$(OBJEXT) from nag-e04.$(OBJEXT)
	@ cp nag-e04.$(OBJEXT) ${AUTO}

@
<<nag-e04.o (OUT from MID)>>=
nag-e04.$(OBJEXT): nag-e04.clisp
	@ echo 187 making nag-e04.$(OBJEXT) from nag-e04.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-e04.clisp" :output-file "nag-e04.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-e04.clisp" :output-file "nag-e04.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-e04.clisp>>=
nag-e04.clisp: nag-e04.boot
	@ echo 188 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e04.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e04.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-f01.boot \cite{53}}
<<nag-f01.o (AUTO from OUT)>>=
${AUTO}/nag-f01.$(OBJEXT): nag-f01.$(OBJEXT)
	@ echo 190 making ${AUTO}/nag-f01.$(OBJEXT) from nag-f01.$(OBJEXT)
	@ cp nag-f01.$(OBJEXT) ${AUTO}

@
<<nag-f01.o (OUT from MID)>>=
nag-f01.$(OBJEXT): nag-f01.clisp
	@ echo 191 making nag-f01.$(OBJEXT) from nag-f01.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f01.clisp" :output-file "nag-f01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f01.clisp" :output-file "nag-f01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-f01.clisp>>=
nag-f01.clisp: nag-f01.boot
	@ echo 192 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-f02.boot \cite{54}}
<<nag-f02.o (AUTO from OUT)>>=
${AUTO}/nag-f02.$(OBJEXT): nag-f02.$(OBJEXT)
	@ echo 194 making ${AUTO}/nag-f02.$(OBJEXT) from nag-f02.$(OBJEXT)
	@ cp nag-f02.$(OBJEXT) ${AUTO}

@
<<nag-f02.o (OUT from MID)>>=
nag-f02.$(OBJEXT): nag-f02.clisp
	@ echo 195 making nag-f02.$(OBJEXT) from nag-f02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f02.clisp" :output-file "nag-f02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f02.clisp" :output-file "nag-f02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-f02.clisp>>=
nag-f02.clisp: nag-f02.boot
	@ echo 196 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-f04.boot \cite{55}}
<<nag-f04.o (AUTO from OUT)>>=
${AUTO}/nag-f04.$(OBJEXT): nag-f04.$(OBJEXT)
	@ echo 198 making ${AUTO}/nag-f04.$(OBJEXT) from nag-f04.$(OBJEXT)
	@ cp nag-f04.$(OBJEXT) ${AUTO}

@
<<nag-f04.o (OUT from MID)>>=
nag-f04.$(OBJEXT): nag-f04.clisp
	@ echo 199 making nag-f04.$(OBJEXT) from nag-f04.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-f04.clisp" :output-file "nag-f04.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-f04.clisp" :output-file "nag-f04.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-f04.clisp>>=
nag-f04.clisp: nag-f04.boot
	@ echo 200 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f04.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f04.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nag-f07.boot \cite{56}}
<<nag-f07.o (AUTO from OUT)>>=
${AUTO}/nag-f07.$(OBJEXT): nag-f07.$(OBJEXT)
	@ echo 202 making ${AUTO}/nag-f07.$(OBJEXT) from nag-f07.$(OBJEXT)
	@ cp nag-f07.$(OBJEXT) ${AUTO}

@
<<nag-f07.o (OUT from MID)>>=
nag-f07.$(OBJEXT): nag-f07.clisp
	@ echo 203 making nag-f07.$(OBJEXT) from nag-f07.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f07.clisp" :output-file "nag-f07.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f07.clisp" :output-file "nag-f07.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-f07.clisp>>=
nag-f07.clisp: nag-f07.boot
	@ echo 204 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f07.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f07.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{nag-s.boot \cite{57}}
<<nag-s.o (AUTO from OUT)>>=
${AUTO}/nag-s.$(OBJEXT): nag-s.$(OBJEXT)
	@ echo 206 making ${AUTO}/nag-s.$(OBJEXT) from nag-s.$(OBJEXT)
	@ cp nag-s.$(OBJEXT) ${AUTO}

@
<<nag-s.o (OUT from MID)>>=
nag-s.$(OBJEXT): nag-s.clisp
	@ echo 207 making nag-s.$(OBJEXT) from nag-s.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-s.clisp" :output-file "nag-s.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-s.clisp" :output-file "nag-s.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nag-s.clisp>>=
nag-s.clisp: nag-s.boot
	@ echo 208 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-s.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-s.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{category.boot \cite{58}}
<<category.o (AUTO from OUT)>>=
${AUTO}/category.$(OBJEXT): category.$(OBJEXT)
	@ echo 210 making ${AUTO}/ category.$(OBJEXT) from category.$(OBJEXT)
	@ cp category.$(OBJEXT) ${AUTO}

@
<<category.o (OUT from MID)>>=
category.$(OBJEXT): category.clisp 
	@ echo 211 making category.$(OBJEXT) from category.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "category.clisp" :output-file "category.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "category.clisp" :output-file "category.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<category.clisp>>=
category.clisp: category.boot
	@ echo 212 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "category.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "category.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{cattable.boot \cite{59}}
<<cattable.o (OUT from MID)>>=
cattable.$(OBJEXT): cattable.clisp 
	@ echo 214 making cattable.$(OBJEXT) from cattable.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "cattable.clisp" :output-file "cattable.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "cattable.clisp" :output-file "cattable.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<cattable.clisp>>=
cattable.clisp: cattable.boot
	@ echo 215 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "cattable.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "cattable.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{c-doc.boot \cite{60}}
<<c-doc.o (AUTO from OUT)>>=
${AUTO}/c-doc.$(OBJEXT): c-doc.$(OBJEXT)
	@ echo 217 making ${AUTO}/c-doc.$(OBJEXT) from c-doc.$(OBJEXT)
	@ cp c-doc.$(OBJEXT) ${AUTO}

@
<<c-doc.o (OUT from MID)>>=
c-doc.$(OBJEXT): c-doc.clisp 
	@ echo 218 making c-doc.$(OBJEXT) from c-doc.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "c-doc.clisp" :output-file "c-doc.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "c-doc.clisp" :output-file "c-doc.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<c-doc.clisp>>=
c-doc.clisp: c-doc.boot
	@ echo 219 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "c-doc.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "c-doc.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{clam.boot \cite{61}}
Note that the {\bf clam.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf clam.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN CLAM.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE CLAM.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<clam.lisp (OUT from IN)>>=
clam.${LISP}: $(srcdir)/clam.boot.pamphlet
	@ echo 221 making clam.${LISP} from $(srcdir)/clam.boot.pamphlet
	@ rm -f clam.$(OBJEXT)
	$(axiom_build_document) --tangle=clam.clisp --output=$@ $<
@

<<clam.o (OUT from MID)>>=
clam.$(OBJEXT): clam.clisp 
	@ echo 222 making clam.$(OBJEXT) from clam.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "clam.clisp" :output-file "clam.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "clam.clisp" :output-file "clam.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<clam.clisp>>=
clam.clisp: clam.boot
	@ echo 223 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "clam.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "clam.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{clammed.boot \cite{62}}
<<clammed.o (OUT from MID)>>=
clammed.$(OBJEXT): clammed.clisp 
	@ echo 225 making clammed.$(OBJEXT) from clammed.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "clammed.clisp" :output-file "clammed.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "clammed.clisp" :output-file "clammed.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<clammed.clisp>>=
clammed.clisp: clammed.boot
	@ echo 226 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "clammed.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "clammed.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{compat.boot \cite{63}}
<<compat.o (OUT from MID)>>=
compat.$(OBJEXT): compat.clisp 
	@ echo 228 making compat.$(OBJEXT) from compat.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compat.clisp" :output-file "compat.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "compat.clisp" :output-file "compat.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<compat.clisp>>=
compat.clisp: compat.boot
	@ echo 229 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compat.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compat.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{compiler.boot \cite{64}}
<<compiler.o (AUTO from OUT)>>=
${AUTO}/compiler.$(OBJEXT): compiler.$(OBJEXT)
	@ echo 231 making ${AUTO}/compiler.$(OBJEXT) from compiler.$(OBJEXT)
	@ cp compiler.$(OBJEXT) ${AUTO}

@
<<compiler.o (OUT from MID)>>=
compiler.$(OBJEXT): compiler.clisp 
	@ echo 232 making compiler.$(OBJEXT) from compiler.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compiler.clisp" :output-file "compiler.$(OBJEXT)"))' | ${DEPSYS} ; \
          else \
	   echo '(progn  (compile-file "compiler.clisp" :output-file "compiler.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<compiler.clisp>>=
compiler.clisp: compiler.boot
	@ echo 233 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compiler.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compiler.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{profile.boot \cite{65}}
<<profile.o (AUTO from OUT)>>=
${AUTO}/profile.$(OBJEXT): profile.$(OBJEXT)
	@ echo 235 making ${AUTO}/profile.$(OBJEXT) from profile.$(OBJEXT)
	@ cp profile.$(OBJEXT) ${AUTO}

@
<<profile.o (OUT from MID)>>=
profile.$(OBJEXT): profile.clisp 
	@ echo 236 making profile.$(OBJEXT) from profile.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "profile.clisp" :output-file "profile.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "profile.clisp" :output-file "profile.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<profile.clisp>>=
profile.clisp: profile.boot
	@ echo 237 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "profile.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "profile.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{compress.boot \cite{66}}
<<compress.o (OUT from MID)>>=
compress.$(OBJEXT): compress.clisp 
	@ echo 239 making compress.$(OBJEXT) from compress.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compress.clisp" :output-file "compress.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "compress.clisp" :output-file "compress.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<compress.clisp>>=
compress.clisp: compress.boot
	@ echo 240 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compress.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compress.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{database.boot \cite{67}}
<<database.o (OUT from MID)>>=
database.$(OBJEXT): database.clisp 
	@ echo 242 making database.$(OBJEXT) from database.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "database.clisp" :output-file "database.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "database.clisp" :output-file "database.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<database.clisp>>=
database.clisp: database.boot
	@ echo 243 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "database.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "database.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{define.boot}
<<define.o (AUTO from OUT)>>=
${AUTO}/define.$(OBJEXT): define.$(OBJEXT)
	@ echo 245 making ${AUTO}/define.$(OBJEXT) from define.$(OBJEXT)
	@ cp define.$(OBJEXT) ${AUTO}

@
<<define.o (OUT from MID)>>=
define.$(OBJEXT): define.clisp 
	@ echo 246 making define.$(OBJEXT) from define.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "define.clisp" :output-file "define.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "define.clisp" :output-file "define.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<define.clisp>>=
define.clisp: define.boot
	@ echo 247 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "define.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "define.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{format.boot}
<<format.o (OUT from MID)>>=
format.$(OBJEXT): format.clisp 
	@ echo 249 making format.$(OBJEXT) from format.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "format.clisp" :output-file "format.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "format.clisp" :output-file "format.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<format.clisp>>=
format.clisp: format.boot
	@ echo 250 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "format.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "format.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{functor.boot}
<<functor.o (AUTO from OUT)>>=
${AUTO}/functor.$(OBJEXT): functor.$(OBJEXT)
	@ echo 252 making ${AUTO}/functor.$(OBJEXT) from functor.$(OBJEXT)
	@ cp functor.$(OBJEXT) ${AUTO}

@
<<functor.o (OUT from MID)>>=
functor.$(OBJEXT): functor.clisp 
	@ echo 253 making functor.$(OBJEXT) from functor.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "functor.clisp" :output-file "functor.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "functor.clisp" :output-file "functor.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<functor.clisp>>=
functor.clisp: functor.boot
	@ echo 254 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "functor.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "functor.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-boot.boot}
Note that the {\bf g-boot.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf g-boot.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN G-BOOT.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE G-BOOT.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<g-boot.lisp (OUT from IN)>>=
g-boot.${LISP}: $(srcdir)/g-boot.boot.pamphlet
	@ echo 256 making g-boot.${LISP} from $(srcdir)/g-boot.boot.pamphlet
	@ rm -f g-boot.$(OBJEXT)
	$(axiom_build_document) --tangle=g-boot.clisp --output=$@ $<
@
<<g-boot.o (OUT from MID)>>=
g-boot.$(OBJEXT): g-boot.clisp 
	@ echo 257 making g-boot.$(OBJEXT) from g-boot.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-boot.clisp" :output-file "g-boot.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-boot.clisp" :output-file "g-boot.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-boot.clisp>>=
g-boot.clisp: g-boot.boot
	@ echo 258 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-boot.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-boot.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-cndata.boot}
<<g-cndata.o (OUT from MID)>>=
g-cndata.$(OBJEXT): g-cndata.clisp 
	@ echo 260 making g-cndata.$(OBJEXT) from g-cndata.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-cndata.clisp" :output-file "g-cndata.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-cndata.clisp" :output-file "g-cndata.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-cndata.clisp>>=
g-cndata.clisp: g-cndata.boot
	@ echo 261 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-cndata.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-cndata.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-error.boot}
<<g-error.o (OUT from MID)>>=
g-error.$(OBJEXT): g-error.clisp 
	@ echo 263 making g-error.$(OBJEXT) from g-error.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-error.clisp" :output-file "g-error.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-error.clisp" :output-file "g-error.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-error.clisp>>=
g-error.clisp: g-error.boot
	@ echo 264 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-error.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-error.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-opt.boot}
<<g-opt.o (OUT from MID)>>=
g-opt.$(OBJEXT): g-opt.clisp 
	@ echo 266 making g-opt.$(OBJEXT) from g-opt.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-opt.clisp" :output-file "g-opt.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-opt.clisp" :output-file "g-opt.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-opt.clisp>>=
g-opt.clisp: g-opt.boot
	@ echo 267 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-opt.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-opt.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-timer.boot}
<<g-timer.o (OUT from MID)>>=
g-timer.$(OBJEXT): g-timer.clisp 
	@ echo 269 making g-timer.$(OBJEXT) from g-timer.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-timer.clisp" :output-file "g-timer.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-timer.clisp" :output-file "g-timer.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-timer.clisp>>=
g-timer.clisp: g-timer.boot
	@ echo 270 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-timer.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-timer.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{g-util.boot}
Note that the {\bf g-util.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf g-util.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN G-UTIL.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE G-UTIL.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<g-util.lisp (OUT from IN)>>=
g-util.${LISP}: $(srcdir)/g-util.boot.pamphlet
	@ echo 272 making g-util.${LISP} from $(srcdir)/g-util.boot.pamphlet
	@ rm -f g-util.$(OBJEXT)
	$(axiom_build_document) --tangle=g-util.clisp --output=$@ $<
@
<<g-util.o (OUT from MID)>>=
g-util.$(OBJEXT): g-util.clisp 
	@ echo 273 making g-util.$(OBJEXT) from g-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-util.clisp" :output-file "g-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-util.clisp" :output-file "g-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<g-util.clisp>>=
g-util.clisp: g-util.boot
	@ echo 274 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{hypertex.boot}
<<hypertex.o (OUT from MID)>>=
hypertex.$(OBJEXT): hypertex.clisp 
	@ echo 276 making hypertex.$(OBJEXT) from hypertex.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "hypertex.clisp" :output-file "hypertex.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "hypertex.clisp" :output-file "hypertex.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<hypertex.clisp>>=
hypertex.clisp: hypertex.boot
	@ echo 277 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "hypertex.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "hypertex.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-analy.boot}
<<i-analy.o (OUT from MID)>>=
i-analy.$(OBJEXT): i-analy.clisp 
	@ echo 279 making i-analy.$(OBJEXT) from i-analy.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-analy.clisp" :output-file "i-analy.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-analy.clisp" :output-file "i-analy.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-analy.clisp>>=
i-analy.clisp: i-analy.boot
	@ echo 280 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-analy.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-analy.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-code.boot}
<<i-code.o (OUT from MID)>>=
i-code.$(OBJEXT): i-code.clisp 
	@ echo 282 making i-code.$(OBJEXT) from i-code.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-code.clisp" :output-file "i-code.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-code.clisp" :output-file "i-code.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-code.clisp>>=
i-code.clisp: i-code.boot
	@ echo 283 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-code.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-code.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-coerce.boot}
<<i-coerce.o (OUT from MID)>>=
i-coerce.$(OBJEXT): i-coerce.clisp 
	@ echo 285 making i-coerce.$(OBJEXT) from i-coerce.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-coerce.clisp" :output-file "i-coerce.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-coerce.clisp" :output-file "i-coerce.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-coerce.clisp>>=
i-coerce.clisp: i-coerce.boot
	@ echo 286 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-coerce.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-coerce.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-coerfn.boot}
<<i-coerfn.o (OUT from MID)>>=
i-coerfn.$(OBJEXT): i-coerfn.clisp 
	@ echo 288 making i-coerfn.$(OBJEXT) from i-coerfn.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-coerfn.clisp" :output-file "i-coerfn.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-coerfn.clisp" :output-file "i-coerfn.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-coerfn.clisp>>=
i-coerfn.clisp: i-coerfn.boot
	@ echo 289 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-coerfn.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-coerfn.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-eval.boot}
<<i-eval.o (OUT from MID)>>=
i-eval.$(OBJEXT): i-eval.clisp 
	@ echo 291 making i-eval.$(OBJEXT) from i-eval.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-eval.clisp" :output-file "i-eval.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-eval.clisp" :output-file "i-eval.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-eval.clisp>>=
i-eval.clisp: i-eval.boot
	@ echo 292 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-eval.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-eval.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-funsel.boot}
<<i-funsel.o (OUT from MID)>>=
i-funsel.$(OBJEXT): i-funsel.clisp 
	@ echo 294 making i-funsel.$(OBJEXT) from i-funsel.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-funsel.clisp" :output-file "i-funsel.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-funsel.clisp" :output-file "i-funsel.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-funsel.clisp>>=
i-funsel.clisp: i-funsel.boot
	@ echo 295 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-funsel.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-funsel.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{bookvol5.lsp}
<<bookvol5.o (OUT from MID)>>=
bookvol5.$(OBJEXT): bookvol5.lisp
	@ echo 297 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bookvol5.lisp" :output-file "bookvol5.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bookvol5.lisp" :output-file "bookvol5.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

<<bookvol5.lisp>>=
bookvol5.lisp: $(srcdir)/bookvol5.pamphlet
	@ echo 298 making $@ from $<
	$(axiom_build_document) --tangle=Interpreter --output=$@ $<
@

\subsection{i-intern.boot}
<<i-intern.o (OUT from MID)>>=
i-intern.$(OBJEXT): i-intern.clisp 
	@ echo 300 making i-intern.$(OBJEXT) from i-intern.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-intern.clisp" :output-file "i-intern.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-intern.clisp" :output-file "i-intern.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	 fi

@
<<i-intern.clisp>>=
i-intern.clisp: i-intern.boot
	@ echo 301 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-intern.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-intern.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-map.boot}
<<i-map.o (OUT from MID)>>=
i-map.$(OBJEXT): i-map.clisp 
	@ echo 303 making i-map.$(OBJEXT) from i-map.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-map.clisp" :output-file "i-map.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-map.clisp" :output-file "i-map.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-map.clisp>>=
i-map.clisp: i-map.boot
	@ echo 304 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-map.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-map.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-output.boot}
<<i-output.o (OUT from MID)>>=
i-output.$(OBJEXT): i-output.clisp 
	@ echo 306 making i-output.$(OBJEXT) from i-output.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-output.clisp" :output-file "i-output.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-output.clisp" :output-file "i-output.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-output.clisp>>=
i-output.clisp: i-output.boot
	@ echo 307 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-output.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-output.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{i-resolv.boot}
<<i-resolv.o (OUT from MID)>>=
i-resolv.$(OBJEXT): i-resolv.clisp 
	@ echo 309 making i-resolv.$(OBJEXT) from i-resolv.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-resolv.clisp" :output-file "i-resolv.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-resolv.clisp" :output-file "i-resolv.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-resolv.clisp>>=
i-resolv.clisp: i-resolv.boot
	@ echo 310 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-resolv.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-resolv.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-spec1.boot}
<<i-spec1.o (OUT from MID)>>=
i-spec1.$(OBJEXT): i-spec1.clisp 
	@ echo 312 making i-spec1.$(OBJEXT) from i-spec1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-spec1.clisp" :output-file "i-spec1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-spec1.clisp" :output-file "i-spec1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-spec1.clisp>>=
i-spec1.clisp: i-spec1.boot
	@ echo 313 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-spec1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-spec1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-spec2.boot}
<<i-spec2.o (OUT from MID)>>=
i-spec2.$(OBJEXT): i-spec2.clisp 
	@ echo 315 making i-spec2.$(OBJEXT) from i-spec2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-spec2.clisp" :output-file "i-spec2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-spec2.clisp" :output-file "i-spec2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-spec2.clisp>>=
i-spec2.clisp: i-spec2.boot
	@ echo 316 making $@ from i-spec2.boot
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-spec2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-spec2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-syscmd.boot}
<<i-syscmd.o (OUT from MID)>>=
i-syscmd.$(OBJEXT): i-syscmd.clisp 
	@ echo 318 making i-syscmd.$(OBJEXT) from i-syscmd.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-syscmd.clisp" :output-file "i-syscmd.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-syscmd.clisp" :output-file "i-syscmd.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<i-syscmd.clisp>>=
i-syscmd.clisp: i-syscmd.boot
	@ echo 319 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-syscmd.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-syscmd.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-toplev.boot}
<<i-toplev.o (OUT from MID)>>=
i-toplev.$(OBJEXT): i-toplev.clisp 
	@ echo 321 making i-toplev.$(OBJEXT) from i-toplev.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-toplev.clisp" :output-file "i-toplev.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-toplev.clisp" :output-file "i-toplev.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
          fi

@
<<i-toplev.clisp>>=
i-toplev.clisp: i-toplev.boot
	@ echo 322 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-toplev.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-toplev.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{i-util.boot}
<<i-util.o (OUT from MID)>>=
i-util.$(OBJEXT): i-util.clisp 
	@ echo 324 making i-util.$(OBJEXT) from i-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-util.clisp" :output-file "i-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-util.clisp" :output-file "i-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
          fi

@
<<i-util.clisp>>=
i-util.clisp: i-util.boot
	@ echo 325 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{info.boot}
<<info.o (AUTO from OUT)>>=
${AUTO}/info.$(OBJEXT): info.$(OBJEXT)
	@ echo 327 making ${AUTO}/info.$(OBJEXT) from info.$(OBJEXT)
	@ cp info.$(OBJEXT) ${AUTO}

@
<<info.o (OUT from MID)>>=
info.$(OBJEXT): info.clisp 
	@ echo 328 making info.$(OBJEXT) from info.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "info.clisp" :output-file "info.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "info.clisp" :output-file "info.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<info.clisp>>=
info.clisp: info.boot
	@ echo 329 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "info.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "info.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{iterator.boot}
<<iterator.o (AUTO from OUT)>>=
${AUTO}/iterator.$(OBJEXT): iterator.$(OBJEXT)
	@ echo 331 making ${AUTO}/iterator.$(OBJEXT) from iterator.$(OBJEXT)
	@ cp iterator.$(OBJEXT) ${AUTO}

@
<<iterator.o (OUT from MID)>>=
iterator.$(OBJEXT): iterator.clisp 
	@ echo 332 making iterator.$(OBJEXT) from iterator.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "iterator.clisp" :output-file "iterator.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "iterator.clisp" :output-file "iterator.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<iterator.clisp>>=
iterator.clisp: iterator.boot
	@ echo 333 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "iterator.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "iterator.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{lisplib.boot}
<<lisplib.o (OUT from MID)>>=
lisplib.$(OBJEXT): lisplib.clisp 
	@ echo 335 making lisplib.$(OBJEXT) from lisplib.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "lisplib.clisp" :output-file "lisplib.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "lisplib.clisp" :output-file "lisplib.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<lisplib.clisp>>=
lisplib.clisp: lisplib.boot
	@ echo 336 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "lisplib.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "lisplib.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{match.boot}
<<match.o (OUT from MID)>>=
match.$(OBJEXT): match.clisp 
	@ echo 338 making match.$(OBJEXT) from match.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "match.clisp" :output-file "match.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "match.clisp" :output-file "match.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<match.clisp>>=
match.clisp: match.boot
	@ echo 339 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "match.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "match.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{modemap.boot}
<<modemap.o (AUTO from OUT)>>=
${AUTO}/modemap.$(OBJEXT): modemap.$(OBJEXT)
	@ echo 341 making ${AUTO}/modemap.$(OBJEXT) from modemap.$(OBJEXT)
	@ cp modemap.$(OBJEXT) ${AUTO}

@
<<modemap.o (OUT from MID)>>=
modemap.$(OBJEXT): modemap.clisp 
	@ echo 342 making modemap.$(OBJEXT) from modemap.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "modemap.clisp" :output-file "modemap.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "modemap.clisp" :output-file "modemap.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<modemap.clisp>>=
modemap.clisp: modemap.boot
	@ echo 343 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "modemap.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "modemap.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{msgdb.boot}
<<msgdb.o (OUT from MID)>>=
msgdb.$(OBJEXT): msgdb.clisp 
	@ echo 345 making msgdb.$(OBJEXT) from msgdb.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "msgdb.clisp" :output-file "msgdb.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "msgdb.clisp" :output-file "msgdb.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<msgdb.clisp>>=
msgdb.clisp: msgdb.boot
	@ echo 346 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "msgdb.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "msgdb.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{newfort.boot}
<<newfort.o (OUT from MID)>>=
newfort.$(OBJEXT): newfort.clisp 
	@ echo 348 making newfort.$(OBJEXT) from newfort.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "newfort.clisp" :output-file "newfort.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "newfort.clisp" :output-file "newfort.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<newfort.clisp>>=
newfort.clisp: newfort.boot
	@ echo 349 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "newfort.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "newfort.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nruncomp.boot}
<<nruncomp.o (AUTO from OUT)>>=
${AUTO}/nruncomp.$(OBJEXT): nruncomp.$(OBJEXT)
	@ echo 351 making ${AUTO}/nruncomp.$(OBJEXT) from nruncomp.$(OBJEXT)
	@ cp nruncomp.$(OBJEXT) ${AUTO}

@
<<nruncomp.o (OUT from MID)>>=
nruncomp.$(OBJEXT): nruncomp.clisp 
	@ echo 352 making nruncomp.$(OBJEXT) from nruncomp.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nruncomp.clisp" :output-file "nruncomp.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nruncomp.clisp" :output-file "nruncomp.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nruncomp.clisp>>=
nruncomp.clisp: nruncomp.boot
	@ echo 353 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nruncomp.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nruncomp.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nrunfast.boot}
<<nrunfast.o (OUT from MID)>>=
nrunfast.$(OBJEXT): nrunfast.clisp 
	@ echo 355 making nrunfast.$(OBJEXT) from nrunfast.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrunfast.clisp" :output-file "nrunfast.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrunfast.clisp" :output-file "nrunfast.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nrunfast.clisp>>=
nrunfast.clisp: nrunfast.boot
	@ echo 356 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrunfast.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrunfast.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nrungo.boot}
<<nrungo.o (OUT from MID)>>=
nrungo.$(OBJEXT): nrungo.clisp 
	@ echo 358 making nrungo.$(OBJEXT) from nrungo.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrungo.clisp" :output-file "nrungo.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrungo.clisp" :output-file "nrungo.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nrungo.clisp>>=
nrungo.clisp: nrungo.boot
	@ echo 359 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrungo.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrungo.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nruntime.boot}
<<nruntime.o (OUT from MID)>>=
nruntime.$(OBJEXT): nruntime.clisp 
	@ echo 361 making nruntime.$(OBJEXT) from nruntime.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nruntime.clisp" :output-file "nruntime.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nruntime.clisp" :output-file "nruntime.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nruntime.clisp>>=
nruntime.clisp: nruntime.boot
	@ echo 362 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nruntime.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nruntime.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{nrunopt.boot}
<<nrunopt.o (OUT from MID)>>=
nrunopt.$(OBJEXT): nrunopt.clisp 
	@ echo 364 making nrunopt.$(OBJEXT) from nrunopt.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrunopt.clisp" :output-file "nrunopt.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrunopt.clisp" :output-file "nrunopt.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<nrunopt.clisp>>=
nrunopt.clisp: nrunopt.boot
	@ echo 365 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrunopt.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrunopt.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{package.boot}
<<package.o (AUTO from OUT)>>=
${AUTO}/package.$(OBJEXT): package.$(OBJEXT)
	@ echo 370 making ${AUTO}/package.$(OBJEXT) from package.$(OBJEXT)
	@ cp package.$(OBJEXT) ${AUTO}

@
<<package.o (OUT from MID)>>=
package.$(OBJEXT): package.clisp 
	@ echo 371 making package.$(OBJEXT) from package.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "package.clisp" :output-file "package.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "package.clisp" :output-file "package.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<package.clisp>>=
package.clisp: package.boot
	@ echo 372 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "package.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "package.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{parse.boot}
\begin{verbatim}
NOTE: this is used to build a bootsys on a virgin copy of the system
notice that the file placed in ${OUT} is a .lisp file
this is to allow the depsys to be built even if the .$(OBJEXT) file does
not exist on the new system
\end{verbatim}
<<parse.o (AUTO from OUT)>>=
${AUTO}/parse.$(OBJEXT): parse.$(OBJEXT)
	@ echo 374 making ${AUTO}/parse.$(OBJEXT) from parse.$(OBJEXT)
	@ cp parse.$(OBJEXT) ${AUTO}

@
<<parse.o (OUT from MID)>>=
parse.$(OBJEXT): parse.clisp 
	@ echo 375 making parse.$(OBJEXT) from parse.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
Note that the {\bf parse.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf parse.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN PARSE.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE PARSE.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<parse.lisp (OUT from IN)>>=
parse.clisp: $(srcdir)/parse.boot.pamphlet
	@ echo 376 making $@ from $<
	@ rm -f parse.$(OBJEXT)
	$(axiom_build_document) --tangle=parse.clisp --output=$@ $<
@
<<parse.clisp>>=
## FIXME: Temporily disabled.
# parse.clisp: $(srcdir)/parse.boot.pamphlet
# 	@ echo 377 making parse.clisp from $(srcdir)/parse.boot.pamphlet
# 	@ ($(axiom_build_document) --tangle --output=parse.boot $<;\
# 	  if [ -z "${NOISE}" ] ; then \
# 	   echo '(progn (boottran::boottocl "parse.boot"))' | ${DEPSYS} ; \
# 	  else \
# 	   echo '(progn (boottran::boottocl "parse.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
# 	  fi ; \
# 	  rm parse.boot )

@

\subsection{pathname.boot}
\begin{verbatim}
NOTE: the .clisp file is copies back into the src directory so that
it is possible to create a new obootsys system from scratch for a 
new platform. parse.clisp needs to be compiled in a depsys.
two things need to be done to create an obootsys by hand:
  :oldboot must be on the *features* list BEFORE util.lisp is loaded
  parse and postpar must be loaded along with the depsys files
     into a bare lisp system.
if these two things are done then a obootsys image can be bootstrapped
to a new platform.
\end{verbatim}
<<pathname.o (OUT from MID)>>=
pathname.$(OBJEXT): pathname.clisp 
	@ echo 379 making pathname.$(OBJEXT) from pathname.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pathname.clisp" :output-file "pathname.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pathname.clisp" :output-file "pathname.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<pathname.clisp>>=
pathname.clisp: pathname.boot
	@ echo 380 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pathname.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pathname.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{postpar.boot}
\begin{verbatim}
NOTE: this is used to build a bootsys on a virgin copy of the system
notice that the file placed in ${OUT} is a .lisp file
this is to allow the depsys to be built even if the .$(OBJEXT) file does
not exist on the new system
\end{verbatim}
<<postpar.o (AUTO from OUT)>>=
${AUTO}/postpar.$(OBJEXT): postpar.$(OBJEXT)
	@ echo 382 making ${AUTO}/postpar.$(OBJEXT) from postpar.$(OBJEXT)
	@ cp postpar.$(OBJEXT) ${AUTO}

@
Note that the {\bf postpar.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf postpar.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN POSTPAR.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE POSTPAR.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<postpar.lisp (OUT from IN)>>=
postpar.clisp: $(srcdir)/postpar.boot.pamphlet
	@ echo 383 making $@ from $<
	@ rm -f postpar.$(OBJEXT)
	$(axiom_build_document) --tangle=postpar.clisp --output=$@ $<
@
<<postpar.o (OUT from MID)>>=
postpar.$(OBJEXT): postpar.clisp 
	@ echo 384 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
\begin{verbatim}
NOTE: the .clisp file is copies back into the src directory so that
it is possible to create a new DEPSYS system from scratch for a 
new platform. parse.clisp needs to be compiled in a depsys.
two things need to be done to create an DEPSYS by hand:
  :oldboot must be on the *features* list BEFORE util.lisp is loaded
  parse and postpar must be loaded along with the depsys files
     into a bare lisp system.
if these two things are done then a DEPSYS image can be bootstrapped
to a new platform.
\end{verbatim}
<<postpar.clisp>>=
## FIXME: temporarily commented
# postpar.clisp: $(srcdir)/postpar.boot.pamphlet
# 	@ echo 385 making postpar.clisp from $(srcdir)/postpar.boot.pamphlet
# 	@ ($(axiom_build_document) --tangle --output=postpar.boot $<;\
# 	  if [ -z "${NOISE}" ] ; then \
# 	   echo '(progn (boottran::boottocl "postpar.boot"))' | ${DEPSYS} ; \
# 	  else \
# 	   echo '(progn (boottran::boottocl "postpar.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
# 	  fi ; \
# 	  rm postpar.boot )

@

\subsection{rulesets.boot}
<<rulesets.o (OUT from MID)>>=
rulesets.$(OBJEXT): rulesets.clisp 
	@ echo 387 making rulesets.$(OBJEXT) from rulesets.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "rulesets.clisp" :output-file "rulesets.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "rulesets.clisp" :output-file "rulesets.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<rulesets.clisp>>=
rulesets.clisp: rulesets.boot
	@ echo 388 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "rulesets.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "rulesets.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{server.boot}
<<server.o (OUT from MID)>>=
server.$(OBJEXT): server.clisp 
	@ echo 390 making server.$(OBJEXT) from server.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "server.clisp" :output-file "server.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "server.clisp" :output-file "server.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<server.clisp>>=
server.clisp: server.boot
	@ echo 391 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "server.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "server.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{setvars.boot}
Note that the {\bf setvars.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf setvars.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN SETVARS.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE SETVARS.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<setvars.lisp (OUT from IN)>>=
setvars.${LISP}: $(srcdir)/setvars.boot.pamphlet
	@ echo 393 making setvars.${LISP} from $(srcdir)/setvars.boot.pamphlet
	@ rm -f setvars.$(OBJEXT)
	$(axiom_build_document) --tangle=setvars.clisp --output=$@ S<
@
<<setvars.o (OUT from MID)>>=
setvars.$(OBJEXT): setvars.clisp 
	@ echo 394 making setvars.$(OBJEXT) from setvars.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "setvars.clisp" :output-file "setvars.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "setvars.clisp" :output-file "setvars.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<setvars.clisp>>=
setvars.clisp: setvars.boot
	@ echo 395 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "setvars.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "setvars.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{setvart.boot}
<<setvart.o (OUT from MID)>>=
setvart.$(OBJEXT): setvart.clisp 
	@ echo 397 making setvart.$(OBJEXT) from setvart.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "setvart.clisp" :output-file "setvart.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "setvart.clisp" :output-file "setvart.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<setvart.clisp>>=
setvart.clisp: setvart.boot
	@ echo 398 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "setvart.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "setvart.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{simpbool.boot}
<<simpbool.o (OUT from MID)>>=
simpbool.$(OBJEXT): simpbool.clisp 
	@ echo 400 making simpbool.$(OBJEXT) from simpbool.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "simpbool.clisp" :output-file "simpbool.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "simpbool.clisp" :output-file "simpbool.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<simpbool.clisp>>=
simpbool.clisp: simpbool.boot
	@ echo 401 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "simpbool.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "simpbool.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{slam.boot}
Note that the {\bf slam.boot.pamphlet} file contains both the
original {\bf boot} code and a saved copy of the {\bf slam.clisp}
code. We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated so we
can build the boot translator.

{\bf NOTE WELL: IF YOU CHANGE THE BOOT CODE IN SLAM.BOOT.PAMPHLET
YOU MUST TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP
CODE BACK INTO THE SLAM.BOOT.PAMPHLET FILE. THIS IS NOT AUTOMATED.}
<<slam.lisp (OUT from IN)>>=
slam.${LISP}: $(srcdir)/slam.boot.pamphlet
	@ echo 403 making slam.${LISP} from $(srcdir)/slam.boot.pamphlet
	@ rm -f slam.$(OBJEXT)
	$(axiom_build_document) --tangle=slam.clisp --output=$@ $<
@
<<slam.o (OUT from MID)>>=
slam.$(OBJEXT): slam.clisp 
	@ echo 404 making slam.$(OBJEXT) from slam.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "slam.clisp" :output-file "slam.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "slam.clisp" :output-file "slam.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<slam.clisp>>=
slam.clisp: slam.boot
	@ echo 405 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "slam.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "slam.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{template.boot}
<<template.o (OUT from MID)>>=
template.$(OBJEXT): template.clisp 
	@ echo 407 making template.$(OBJEXT) from template.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "template.clisp" :output-file "template.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "template.clisp" :output-file "template.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<template.clisp>>=
template.clisp: template.boot
	@ echo 408 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "template.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "template.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{termrw.boot}
<<termrw.o (OUT from MID)>>=
termrw.$(OBJEXT): termrw.clisp 
	@ echo 410 making termrw.$(OBJEXT) from termrw.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "termrw.clisp" :output-file "termrw.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "termrw.clisp" :output-file "termrw.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<termrw.clisp>>=
termrw.clisp: termrw.boot
	@ echo 411 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "termrw.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "termrw.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{trace.boot}
<<trace.o (OUT from MID)>>=
trace.$(OBJEXT): trace.clisp 
	@ echo 413 making trace.$(OBJEXT) from trace.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "trace.clisp" :output-file "trace.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "trace.clisp" :output-file "trace.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<trace.clisp>>=
trace.clisp: trace.boot
	@ echo 414 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "trace.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "trace.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{as.boot}
<<as.o (OUT from MID)>>=
as.$(OBJEXT): as.clisp 
	@ echo 416 making as.$(OBJEXT) from as.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "as.clisp" :output-file "as.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "as.clisp" :output-file "as.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<as.clisp>>=
as.clisp: as.boot
	@ echo 417 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "as.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "as.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{bc-matrix.boot}
<<bc-matrix.o (AUTO from OUT)>>=
${AUTO}/bc-matrix.$(OBJEXT): bc-matrix.$(OBJEXT)
	@ echo 422 making ${AUTO}/bc-matrix.$(OBJEXT) from bc-matrix.$(OBJEXT)
	@ cp bc-matrix.$(OBJEXT) ${AUTO}

@
<<bc-matrix.o (OUT from MID)>>=
bc-matrix.$(OBJEXT): bc-matrix.clisp 
	@ echo 423 making bc-matrix.$(OBJEXT) from bc-matrix.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-matrix.clisp" :output-file "bc-matrix.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-matrix.clisp" :output-file "bc-matrix.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<bc-matrix.clisp>>=
bc-matrix.clisp: bc-matrix.boot
	@ echo 424 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-matrix.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-matrix.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{bc-misc.boot}
<<bc-misc.o (AUTO from OUT)>>=
${AUTO}/bc-misc.$(OBJEXT): bc-misc.$(OBJEXT)
	@ echo 426 making ${AUTO}/bc-misc.$(OBJEXT) from bc-misc.$(OBJEXT)
	@ cp bc-misc.$(OBJEXT) ${AUTO}

@
<<bc-misc.o (OUT from MID)>>=
bc-misc.$(OBJEXT): bc-misc.clisp 
	@ echo 427 making bc-misc.$(OBJEXT) from bc-misc.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-misc.clisp" :output-file "bc-misc.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-misc.clisp" :output-file "bc-misc.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<bc-misc.clisp>>=
bc-misc.clisp: bc-misc.boot
	@ echo 428 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-misc.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-misc.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{bc-solve.boot}
<<bc-solve.o (AUTO from OUT)>>=
${AUTO}/bc-solve.$(OBJEXT): bc-solve.$(OBJEXT)
	@ echo 430 making ${AUTO}/bc-solve.$(OBJEXT) from bc-solve.$(OBJEXT)
	@ cp bc-solve.$(OBJEXT) ${AUTO}

@
<<bc-solve.o (OUT from MID)>>=
bc-solve.$(OBJEXT): bc-solve.clisp 
	@ echo 431 making bc-solve.$(OBJEXT) from bc-solve.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-solve.clisp" :output-file "bc-solve.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-solve.clisp" :output-file "bc-solve.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<bc-solve.clisp>>=
bc-solve.clisp: bc-solve.boot
	@ echo 432 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-solve.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-solve.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{bc-util.boot}
<<bc-util.o (AUTO from OUT)>>=
${AUTO}/bc-util.$(OBJEXT): bc-util.$(OBJEXT)
	@ echo 434 making ${AUTO}/bc-util.$(OBJEXT) from bc-util.$(OBJEXT)
	@ cp bc-util.$(OBJEXT) ${AUTO}

@
<<bc-util.o (OUT from MID)>>=
bc-util.$(OBJEXT): bc-util.clisp 
	@ echo 435 making bc-util.$(OBJEXT) from bc-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-util.clisp" :output-file "bc-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-util.clisp" :output-file "bc-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<bc-util.clisp>>=
bc-util.clisp: bc-util.boot
	@ echo 436 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{ht-util.boot}
<<ht-util.o (AUTO from OUT)>>=
${AUTO}/ht-util.$(OBJEXT): ht-util.$(OBJEXT)
	@ echo 438 making ${AUTO}/ht-util.$(OBJEXT) from ht-util.$(OBJEXT)
	@ cp ht-util.$(OBJEXT) ${AUTO}

@
<<ht-util.o (OUT from MID)>>=
ht-util.$(OBJEXT): ht-util.clisp 
	@ echo 439 making ht-util.$(OBJEXT) from ht-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ht-util.clisp" :output-file "ht-util.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ht-util.clisp" :output-file "ht-util.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<ht-util.clisp>>=
ht-util.clisp: ht-util.boot
	@ echo 440 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ht-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ht-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{htsetvar.boot}
<<htsetvar.o (AUTO from OUT)>>=
${AUTO}/htsetvar.$(OBJEXT): htsetvar.$(OBJEXT)
	@ echo 442 making ${AUTO}/htsetvar.$(OBJEXT) from htsetvar.$(OBJEXT)
	@ cp htsetvar.$(OBJEXT) ${AUTO}

@
<<htsetvar.o (OUT from MID)>>=
htsetvar.$(OBJEXT): htsetvar.clisp 
	@ echo 443 making htsetvar.$(OBJEXT) from htsetvar.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "htsetvar.clisp" :output-file "htsetvar.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "htsetvar.clisp" :output-file "htsetvar.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<htsetvar.clisp>>=
htsetvar.clisp: htsetvar.boot
	@ echo 444 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "htsetvar.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "htsetvar.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{record.boot}
<<record.o (OUT from MID)>>=
record.$(OBJEXT): record.clisp 
	@ echo 446 making record.$(OBJEXT) from record.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "record.clisp" :output-file "record.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "record.clisp" :output-file "record.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<record.clisp>>=
record.clisp: record.boot
	@ echo 447 making $@ $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "record.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "record.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{ht-root.boot}
<<ht-root.o (AUTO from OUT)>>=
${AUTO}/ht-root.$(OBJEXT): ht-root.$(OBJEXT)
	@ echo 449 making ${AUTO}/ht-root.$(OBJEXT) from ht-root.$(OBJEXT)
	@ cp ht-root.$(OBJEXT) ${AUTO}

@
<<ht-root.o (OUT from MID)>>=
ht-root.$(OBJEXT): ht-root.clisp 
	@ echo 450 making ht-root.$(OBJEXT) from ht-root.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ht-root.clisp" :output-file "ht-root.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ht-root.clisp" :output-file "ht-root.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<ht-root.clisp>>=
ht-root.clisp: ht-root.boot
	@ echo 451 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ht-root.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ht-root.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{htcheck.boot}
<<htcheck.o (AUTO from OUT)>>=
${AUTO}/htcheck.$(OBJEXT): htcheck.$(OBJEXT)
	@ echo 453 making ${AUTO}/htcheck.$(OBJEXT) from htcheck.$(OBJEXT)
	@ cp htcheck.$(OBJEXT) ${AUTO}

@
<<htcheck.o (OUT from MID)>>=
htcheck.$(OBJEXT): htcheck.clisp 
	@ echo 454 making htcheck.$(OBJEXT) from htcheck.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "htcheck.clisp" :output-file "htcheck.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "htcheck.clisp" :output-file "htcheck.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<htcheck.clisp>>=
htcheck.clisp: htcheck.boot
	@ echo 455 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "htcheck.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "htcheck.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{xruncomp.boot}
<<xruncomp.o (AUTO from OUT)>>=
${AUTO}/xruncomp.$(OBJEXT): xruncomp.$(OBJEXT)
	@ echo 457 making ${AUTO}/xruncomp.$(OBJEXT) from xruncomp.$(OBJEXT)
	@ cp xruncomp.$(OBJEXT) ${AUTO}

@
<<xruncomp.o (OUT from MID)>>=
xruncomp.$(OBJEXT): xruncomp.clisp 
	@ echo 458 making xruncomp.$(OBJEXT) from xruncomp.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "xruncomp.clisp" :output-file "xruncomp.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "xruncomp.clisp" :output-file "xruncomp.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<xruncomp.clisp>>=
xruncomp.clisp: xruncomp.boot
	@ echo 459 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "xruncomp.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "xruncomp.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{ax.boot}
<<ax.o (AUTO from OUT)>>=
${AUTO}/ax.$(OBJEXT): ax.$(OBJEXT)
	@ echo 461 making ${AUTO}/ax.$(OBJEXT) from ax.$(OBJEXT)
	@ cp ax.$(OBJEXT) ${AUTO}

@
<<ax.o (OUT from MID)>>=
ax.$(OBJEXT): ax.clisp 
	@ echo 462 making ax.$(OBJEXT) from ax.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ax.clisp" :output-file "ax.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ax.clisp" :output-file "ax.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<ax.clisp>>=
ax.clisp: ax.boot
	@ echo 463 making $@ $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ax.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ax.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{br-con.boot}
<<br-con.o (AUTO from OUT)>>=
${AUTO}/br-con.$(OBJEXT): br-con.$(OBJEXT)
	@ echo 465 making ${AUTO}/br-con.$(OBJEXT) from br-con.$(OBJEXT)
	@ cp br-con.$(OBJEXT) ${AUTO}

@
<<br-con.o (OUT from MID)>>=
br-con.$(OBJEXT): br-con.clisp 
	@ echo 466 making br-con.$(OBJEXT) from br-con.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-con.clisp" :output-file "br-con.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-con.clisp" :output-file "br-con.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-con.clisp>>=
br-con.clisp: br-con.boot
	@ echo 467 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-con.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-con.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{br-search.boot}
<<br-search.o (AUTO from OUT)>>=
${AUTO}/br-search.$(OBJEXT): br-search.$(OBJEXT)
	@ echo 469 making ${AUTO}/br-search.$(OBJEXT) from br-search.$(OBJEXT)
	@ cp br-search.$(OBJEXT) ${AUTO}

@
<<br-search.o (OUT from MID)>>=
br-search.$(OBJEXT): br-search.clisp 
	@ echo 470 making br-search.$(OBJEXT) from br-search.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-search.clisp" :output-file "br-search.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-search.clisp" :output-file "br-search.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-search.clisp>>=
br-search.clisp: br-search.boot
	@ echo 471 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-search.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-search.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{br-op1.boot}
<<br-op1.o (AUTO from OUT)>>=
${AUTO}/br-op1.$(OBJEXT): br-op1.$(OBJEXT)
	@ echo 473 making ${AUTO}/br-op1.$(OBJEXT) from br-op1.$(OBJEXT)
	@ cp br-op1.$(OBJEXT) ${AUTO}

@
<<br-op1.o (OUT from MID)>>=
br-op1.$(OBJEXT): br-op1.clisp 
	@ echo 474 making br-op1.$(OBJEXT) from br-op1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-op1.clisp" :output-file "br-op1.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-op1.clisp" :output-file "br-op1.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-op1.clisp>>=
br-op1.clisp: br-op1.boot
	@ echo 475 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-op1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-op1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{br-op2.boot}
<<br-op2.o (AUTO from OUT)>>=
${AUTO}/br-op2.$(OBJEXT): br-op2.$(OBJEXT)
	@ echo 477 making ${AUTO}/br-op2.$(OBJEXT) from br-op2.$(OBJEXT)
	@ cp br-op2.$(OBJEXT) ${AUTO}

@
<<br-op2.o (OUT from MID)>>=
br-op2.$(OBJEXT): br-op2.clisp 
	@ echo 478 making br-op2.$(OBJEXT) from br-op2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-op2.clisp" :output-file "br-op2.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-op2.clisp" :output-file "br-op2.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-op2.clisp>>=
br-op2.clisp: br-op2.boot
	@ echo 479 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-op2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-op2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{br-data.boot}
<<br-data.o (AUTO from OUT)>>=
${AUTO}/br-data.$(OBJEXT): br-data.$(OBJEXT)
	@ echo 481 making ${AUTO}/br-data.$(OBJEXT) from br-data.$(OBJEXT)
	@ cp br-data.$(OBJEXT) ${AUTO}

@
<<br-data.o (OUT from MID)>>=
br-data.$(OBJEXT): br-data.clisp 
	@ echo 482 making br-data.$(OBJEXT) from br-data.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-data.clisp" :output-file "br-data.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-data.clisp" :output-file "br-data.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-data.clisp>>=
br-data.clisp: br-data.boot
	@ echo 483 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-data.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-data.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{br-util.boot}
<<br-util.o (AUTO from OUT)>>=
${AUTO}/br-util.$(OBJEXT): br-util.$(OBJEXT)
	@ echo 485 making ${AUTO}/br-util.$(OBJEXT) from br-util.$(OBJEXT)
	@ cp br-util.$(OBJEXT) ${AUTO}

@
<<br-util.o (OUT from MID)>>=
br-util.$(OBJEXT): br-util.clisp 
	@ echo 486 making br-util.$(OBJEXT) from br-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-util.clisp" :output-file "br-util.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-util.clisp" :output-file "br-util.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-util.clisp>>=
br-util.clisp: br-util.boot
	@ echo 487 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{br-saturn.boot}
<<br-saturn.o (AUTO from OUT)>>=
${AUTO}/br-saturn.$(OBJEXT): br-saturn.$(OBJEXT)
	@ echo 489 making ${AUTO}/br-saturn.$(OBJEXT) from br-saturn.$(OBJEXT)
	@ cp br-saturn.$(OBJEXT) ${AUTO}

@
<<br-saturn.o (OUT from MID)>>=
br-saturn.$(OBJEXT): br-saturn.clisp 
	@ echo 490 making br-saturn.$(OBJEXT) from br-saturn.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-saturn.clisp" :output-file "br-saturn.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-saturn.clisp" :output-file "br-saturn.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-saturn.clisp>>=
br-saturn.clisp: br-saturn.boot
	@ echo 491 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-saturn.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-saturn.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{topics.boot}
<<topics.o (AUTO from OUT)>>=
${AUTO}/topics.$(OBJEXT): topics.$(OBJEXT)
	@ echo 493 making ${AUTO}/topics.$(OBJEXT) from topics.$(OBJEXT)
	@ cp topics.$(OBJEXT) ${AUTO}

@
<<topics.o (OUT from MID)>>=
topics.$(OBJEXT): topics.clisp 
	@ echo 494 making topics.$(OBJEXT) from topics.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "topics.clisp" :output-file "topics.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "topics.clisp" :output-file "topics.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<topics.clisp>>=
topics.clisp: topics.boot
	@ echo 495 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "topics.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "topics.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{br-prof.boot}
<<br-prof.o (AUTO from OUT)>>=
${AUTO}/br-prof.$(OBJEXT): br-prof.$(OBJEXT)
	@ echo 497 making ${AUTO}/br-prof.$(OBJEXT) from br-prof.$(OBJEXT)
	@ cp br-prof.$(OBJEXT) ${AUTO}

@
<<br-prof.o (OUT from MID)>>=
br-prof.$(OBJEXT): br-prof.clisp 
	@ echo 498 making br-prof.$(OBJEXT) from br-prof.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-prof.clisp" :output-file "br-prof.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-prof.clisp" :output-file "br-prof.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<br-prof.clisp>>=
br-prof.clisp: br-prof.boot
	@ echo 499 making $@ from $<
	@ ($(axiom_build_document) --tangle --output=br-prof.boot $< ;\
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-prof.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-prof.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi ; \
	  rm br-prof.boot )

@

\subsection{showimp.boot}
system level hacking files
<<showimp.o (AUTO from OUT)>>=
${AUTO}/showimp.$(OBJEXT): showimp.$(OBJEXT)
	@ echo 579 making ${AUTO}/showimp.$(OBJEXT) from showimp.$(OBJEXT)
	@ cp showimp.$(OBJEXT) ${AUTO}

@

\subsection{hashcode.boot}
files for the new compiler
<<hashcode.o (OUT from MID)>>=

hashcode.$(OBJEXT): hashcode.clisp 
	@ echo 583 making hashcode.$(OBJEXT) from hashcode.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "hashcode.clisp" :output-file "hashcode.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "hashcode.clisp" :output-file "hashcode.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<hashcode.clisp>>=
hashcode.clisp: hashcode.boot
	@ echo 584 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "hashcode.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "hashcode.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{interop.boot}
<<interop.o (OUT from MID)>>=
interop.$(OBJEXT): interop.clisp
	@ echo 586 making interop.$(OBJEXT) from interop.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "interop.clisp" :output-file "interop.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "interop.clisp" :output-file "interop.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<interop.clisp>>=
interop.clisp: interop.boot
	@ echo 587 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "interop.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "interop.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{xrun.boot}
<<xrun.o (OUT from MID)>>=
xrun.$(OBJEXT): xrun.clisp 
	@ echo 589 making xrun.$(OBJEXT) from xrun.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "xrun.clisp" :output-file "xrun.$(OBJEXT)"))' | ${DEPSYS} ; \
	   else \
	   echo '(progn  (compile-file "xrun.clisp" :output-file "xrun.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	   fi

@
<<xrun.clisp>>=
xrun.clisp: xrun.boot
	@ echo 590 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "xrun.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "xrun.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{wi1.boot}
translate files
<<wi1.o (AUTO from MID)>>=
${AUTO}/wi1.$(OBJEXT): wi1.clisp 
	@ echo 592 making ${AUTO}/wi1.$(OBJEXT) from wi1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "wi1.clisp" :output-file "${AUTO}/wi1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "wi1.clisp" :output-file "${AUTO}/wi1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<wi1.clisp>>=
wi1.clisp: wi1.boot
	@ echo 593 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{wi2.boot}
<<wi2.o (AUTO from MID)>>=
${AUTO}/wi2.$(OBJEXT): wi2.clisp 
	@ echo 595 making ${AUTO}/wi2.$(OBJEXT) from wi2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "wi2.clisp" :output-file "${AUTO}/wi2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "wi2.clisp" :output-file "${AUTO}/wi2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<wi2.clisp>>=
wi2.clisp: wi2.boot
	@ echo 596 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{pspad1.boot}
<<pspad1.o (AUTO from MID)>>=
${AUTO}/pspad1.$(OBJEXT): pspad1.clisp 
	@ echo 598 making ${AUTO}/pspad1.$(OBJEXT) from pspad1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pspad1.clisp" :output-file "${AUTO}/pspad1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pspad1.clisp" :output-file "${AUTO}/pspad1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<pspad1.clisp>>=
pspad1.clisp: pspad1.boot
	@ echo 599 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\subsection{pspad2.boot}
<<pspad2.o (AUTO from MID)>>=
${AUTO}/pspad2.$(OBJEXT): pspad2.clisp 
	@ echo 601 making ${AUTO}/pspad2.$(OBJEXT) from pspad2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pspad2.clisp" :output-file "${AUTO}/pspad2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pspad2.clisp" :output-file "${AUTO}/pspad2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<pspad2.clisp>>=
pspad2.clisp: pspad2.boot
	@ echo 602 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 

@

\subsection{mark.boot}
<<mark.o (AUTO from MID)>>=
${AUTO}/mark.$(OBJEXT): mark.clisp 
	@ echo 604 making ${AUTO}/mark.$(OBJEXT) from mark.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "mark.clisp" :output-file "${AUTO}/mark.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "mark.clisp" :output-file "${AUTO}/mark.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@
<<mark.clisp>>=
mark.clisp: mark.boot
	@ echo 605 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "mark.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "mark.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

@

\section{The databases}
\begin{verbatim}
 autoload dependencies

 if you are adding a file which is to be autoloaded the following step
 information is useful:
  there are 2 cases:
   1) adding files to currently autoloaded parts
      (as of 2/92: browser old parser and old compiler)
   2) adding new files
   case 1:
     a) you have to add the file to the list of files currently there
        (e.g. see BROBJS above)
     b) add an autolaod rule
        (e.g. ${AUTO}/parsing.$(OBJEXT): parsing.$(OBJEXT))
     c) edit util.lisp to add the 'external' function (those that
        should trigger the autoload
   case 2:
     build-interpsys (in util.lisp) needs an extra argument for the
     new autoload things and several functions in util.lisp need hacking.

 database.date is a marker file used to force a rebuild of interpsys if the
 database is rebuilt (src/algebra/Makefile).

\end{verbatim}
<<databases>>=
exposed.lsp: $(axiom_src_algdir)/exposed.lsp.pamphlet
	@ echo 615 making exposed.lsp from $(axiom_src_algdir)/exposed.lsp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

$(axiom_targetdir)/algebra/exposed.$(OBJEXT) : exposed.lsp ${LISPSYS}
	@ echo 616 making $@ from exposed.lsp
	$(mkinstalldirs) $(axiom_targetdir)/algebra
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "exposed.lsp" :output-file "$(axiom_targetdir)/algebra/exposed.$(OBJEXT)"))' | ${LISPSYS} ; \
	  else \
	   echo '(progn  (compile-file "exposed.lsp" :output-file "$(axiom_targetdir)/algebra/exposed.$(OBJEXT)"))' | ${LISPSYS} >> ${TMP}/trace ; \
	  fi

database.date:
	@ echo 617 the database was updated...remaking interpsys
	@ touch database.date

@

\section{The Makefile}
<<*>>=

subdir = src/interp/

<<environment>>

.SUFFIXES:
.SUFFIXES: .boot .clisp .lisp .pamphlet

.PHONY: all all-ax all-depsys all-interpsys all-axiomsys all-debugsys

all: all-ax

all-ax: stamp
	@echo finished $(srcdir)

stamp: $(AUTO) remove-stamp build-images
	$(STAMP) stamp

.PHONY: remove-stamp
remove-stamp:
	-rm -f stamp

.PHONY: build-images
build-images: remove-stamp all-interpsys all-debugsys

all-interpsys: all-depsys 
	$(mkinstalldirs) $(AUTO)
	$(ENV) $(MAKE) $(AX_FLAGS) $(SAVESYS)

all-axiomsys: all-depsys 
	$(ENV) $(MAKE) $(AX_FLAGS) $(AXIOMSYS)

all-debugsys: all-interpsys
	$(ENV) $(MAKE) $(AX_FLAGS) $(DEBUGSYS)

all-depsys: $(DEPSYS)

<<extract source codes>>

mostlyclean-local:
	@rm -f *.fn *.data *.o

clean-local: mostlyclean-local
	@rm -f *.clisp *.lsp

distclean-local: clean-local

<<savesys>>
<<depsys>>
<<axiomsys>>
<<debugsys>>
<<databases>>

<<apply.o (AUTO from OUT)>>
<<apply.o (OUT from MID)>>
<<apply.clisp>>

<<as.o (OUT from MID)>>
<<as.clisp>>

<<ax.o (AUTO from OUT)>>
<<ax.o (OUT from MID)>>
<<ax.clisp>>

<<bc-matrix.o (AUTO from OUT)>>
<<bc-matrix.o (OUT from MID)>>
<<bc-matrix.clisp>>

<<bc-misc.o (AUTO from OUT)>>
<<bc-misc.o (OUT from MID)>>
<<bc-misc.clisp>>

<<bc-solve.o (AUTO from OUT)>>
<<bc-solve.o (OUT from MID)>>
<<bc-solve.clisp>>

<<bc-util.o (AUTO from OUT)>>
<<bc-util.o (OUT from MID)>>
<<bc-util.clisp>>

<<bootlex.o (AUTO from OUT)>>

<<br-con.o (AUTO from OUT)>>
<<br-con.o (OUT from MID)>>
<<br-con.clisp>>

<<br-data.o (AUTO from OUT)>>
<<br-data.o (OUT from MID)>>
<<br-data.clisp>>

<<br-op1.o (AUTO from OUT)>>
<<br-op1.o (OUT from MID)>>
<<br-op1.clisp>>

<<br-op2.o (AUTO from OUT)>>
<<br-op2.o (OUT from MID)>>
<<br-op2.clisp>>

<<br-prof.o (AUTO from OUT)>>
<<br-prof.o (OUT from MID)>>
<<br-prof.clisp>>

<<br-saturn.o (AUTO from OUT)>>
<<br-saturn.o (OUT from MID)>>
<<br-saturn.clisp>>

<<br-search.o (AUTO from OUT)>>
<<br-search.o (OUT from MID)>>
<<br-search.clisp>>

<<br-util.o (AUTO from OUT)>>
<<br-util.o (OUT from MID)>>
<<br-util.clisp>>

<<buildom.o (OUT from MID)>>
<<buildom.clisp>>

<<category.o (AUTO from OUT)>>
<<category.o (OUT from MID)>>
<<category.clisp>>

<<cattable.o (OUT from MID)>>
<<cattable.clisp>>

<<c-doc.o (AUTO from OUT)>>
<<c-doc.o (OUT from MID)>>
<<c-doc.clisp>>

<<clam.lisp (OUT from IN)>>
<<clam.o (OUT from MID)>>
<<clam.clisp>>

<<clammed.o (OUT from MID)>>
<<clammed.clisp>>

<<compat.o (OUT from MID)>>
<<compat.clisp>>

<<compiler.o (AUTO from OUT)>>
<<compiler.o (OUT from MID)>>
<<compiler.clisp>>

<<compress.o (OUT from MID)>>
<<compress.clisp>>

<<c-util.o (AUTO from OUT)>>
<<c-util.lisp (OUT from IN)>>
<<c-util.o (OUT from MID)>>
<<c-util.clisp>>

<<database.o (OUT from MID)>>
<<database.clisp>>

<<debugsys.lisp>>

<<def.o (AUTO from OUT)>>

<<define.o (AUTO from OUT)>>
<<define.o (OUT from MID)>>
<<define.clisp>>

<<fnewmeta.o (AUTO from OUT)>>

<<format.o (OUT from MID)>>
<<format.clisp>>

<<fortcall.o (OUT from MID)>>
<<fortcall.clisp>>

<<functor.o (AUTO from OUT)>>
<<functor.o (OUT from MID)>>
<<functor.clisp>>

<<g-boot.lisp (OUT from IN)>>
<<g-boot.o (OUT from MID)>>
<<g-boot.clisp>>

<<g-cndata.o (OUT from MID)>>
<<g-cndata.clisp>>

<<g-error.o (OUT from MID)>>
<<g-error.clisp>>

<<g-opt.o (OUT from MID)>>
<<g-opt.clisp>>

<<g-timer.o (OUT from MID)>>
<<g-timer.clisp>>

<<g-util.lisp (OUT from IN)>>
<<g-util.o (OUT from MID)>>
<<g-util.clisp>>

<<hashcode.o (OUT from MID)>>
<<hashcode.clisp>>

<<htcheck.o (AUTO from OUT)>>
<<htcheck.o (OUT from MID)>>
<<htcheck.clisp>>

<<ht-root.o (AUTO from OUT)>>
<<ht-root.o (OUT from MID)>>
<<ht-root.clisp>>

<<htsetvar.o (AUTO from OUT)>>
<<htsetvar.o (OUT from MID)>>
<<htsetvar.clisp>>

<<ht-util.o (AUTO from OUT)>>
<<ht-util.o (OUT from MID)>>
<<ht-util.clisp>>

<<hypertex.o (OUT from MID)>>
<<hypertex.clisp>>

<<i-analy.o (OUT from MID)>>
<<i-analy.clisp>>

<<i-code.o (OUT from MID)>>
<<i-code.clisp>>

<<i-coerce.o (OUT from MID)>>
<<i-coerce.clisp>>

<<i-coerfn.o (OUT from MID)>>
<<i-coerfn.clisp>>

<<i-eval.o (OUT from MID)>>
<<i-eval.clisp>>

<<i-funsel.o (OUT from MID)>>
<<i-funsel.clisp>>

<<bookvol5.o (OUT from MID)>>
<<bookvol5.lisp>>

<<i-intern.o (OUT from MID)>>
<<i-intern.clisp>>

<<interop.o (OUT from MID)>>
<<interop.clisp>>

<<i-map.o (OUT from MID)>>
<<i-map.clisp>>

<<info.o (AUTO from OUT)>>
<<info.o (OUT from MID)>>
<<info.clisp>>

<<i-output.o (OUT from MID)>>
<<i-output.clisp>>

<<i-resolv.o (OUT from MID)>>
<<i-resolv.clisp>>

<<i-spec1.o (OUT from MID)>>
<<i-spec1.clisp>>

<<i-spec2.o (OUT from MID)>>
<<i-spec2.clisp>>

<<i-syscmd.o (OUT from MID)>>
<<i-syscmd.clisp>>

<<iterator.o (AUTO from OUT)>>
<<iterator.o (OUT from MID)>>
<<iterator.clisp>>

<<i-toplev.o (OUT from MID)>>
<<i-toplev.clisp>>

<<i-util.o (OUT from MID)>>
<<i-util.clisp>>

<<lisplib.o (OUT from MID)>>
<<lisplib.clisp>>

<<mark.o (AUTO from MID)>>
<<mark.clisp>>

<<match.o (OUT from MID)>>
<<match.clisp>>

<<metalex.o (AUTO from OUT)>>

<<metameta.o (AUTO from OUT)>>

<<modemap.o (AUTO from OUT)>>
<<modemap.o (OUT from MID)>>
<<modemap.clisp>>

<<msgdb.o (OUT from MID)>>
<<msgdb.clisp>>

<<nag-c02.o (AUTO from OUT)>>
<<nag-c02.o (OUT from MID)>>
<<nag-c02.clisp>>

<<nag-c05.o (AUTO from OUT)>>
<<nag-c05.o (OUT from MID)>>
<<nag-c05.clisp>>

<<nag-c06.o (AUTO from OUT)>>
<<nag-c06.o (OUT from MID)>>
<<nag-c06.clisp>>

<<nag-d01.o (AUTO from OUT)>>
<<nag-d01.o (OUT from MID)>>
<<nag-d01.clisp>>

<<nag-d02.o (AUTO from OUT)>>
<<nag-d02.o (OUT from MID)>>
<<nag-d02.clisp>>

<<nag-d03.o (AUTO from OUT)>>
<<nag-d03.o (OUT from MID)>>
<<nag-d03.clisp>>

<<nag-e01.o (AUTO from OUT)>>
<<nag-e01.o (OUT from MID)>>
<<nag-e01.clisp>>

<<nag-e02.o (AUTO from OUT)>>
<<nag-e02.o (OUT from MID)>>
<<nag-e02.clisp>>

<<nag-e04.o (AUTO from OUT)>>
<<nag-e04.o (OUT from MID)>>
<<nag-e04.clisp>>

<<nag-f01.o (AUTO from OUT)>>
<<nag-f01.o (OUT from MID)>>
<<nag-f01.clisp>>

<<nag-f02.o (AUTO from OUT)>>
<<nag-f02.o (OUT from MID)>>
<<nag-f02.clisp>>

<<nag-f04.o (AUTO from OUT)>>
<<nag-f04.o (OUT from MID)>>
<<nag-f04.clisp>>

<<nag-f07.o (AUTO from OUT)>>
<<nag-f07.o (OUT from MID)>>
<<nag-f07.clisp>>

<<nag-s.o (AUTO from OUT)>>
<<nag-s.o (OUT from MID)>>
<<nag-s.clisp>>

<<newaux.o (OUT from MID)>>
<<newaux.lisp (OUT from MID)>>
<<newaux.lisp>>

<<newfort.o (OUT from MID)>>
<<newfort.clisp>>

<<nruncomp.o (AUTO from OUT)>>
<<nruncomp.o (OUT from MID)>>
<<nruncomp.clisp>>

<<nrunfast.o (OUT from MID)>>
<<nrunfast.clisp>>

<<nrungo.o (OUT from MID)>>
<<nrungo.clisp>>

<<nruntime.o (OUT from MID)>>
<<nruntime.clisp>>

<<nrunopt.o (OUT from MID)>>
<<nrunopt.clisp>>

<<nspadaux.o (AUTO from OUT)>>

<<package.o (AUTO from OUT)>>
<<package.o (OUT from MID)>>
<<package.clisp>>

<<parse.o (AUTO from OUT)>>
<<parse.o (OUT from MID)>>
<<parse.lisp (OUT from IN)>>
<<parse.clisp>>

<<parsing.o (AUTO from OUT)>>

<<pathname.o (OUT from MID)>>
<<pathname.clisp>>

<<postpar.o (AUTO from OUT)>>
<<postpar.lisp (OUT from IN)>>
<<postpar.o (OUT from MID)>>
<<postpar.clisp>>

<<postprop.lisp (AUTO from OUT)>>

<<preparse.o (AUTO from OUT)>>

<<profile.o (AUTO from OUT)>>
<<profile.o (OUT from MID)>>
<<profile.clisp>>

<<pspad1.o (AUTO from MID)>>
<<pspad1.clisp>>

<<pspad2.o (AUTO from MID)>>
<<pspad2.clisp>>

<<record.o (OUT from MID)>>
<<record.clisp>>

<<rulesets.o (OUT from MID)>>
<<rulesets.clisp>>

<<server.o (OUT from MID)>>
<<server.clisp>>

<<setvars.o (OUT from MID)>>
<<setvars.lisp (OUT from IN)>>
<<setvars.clisp>>

<<setvart.o (OUT from MID)>>
<<setvart.clisp>>

<<showimp.o (AUTO from OUT)>>

<<simpbool.o (OUT from MID)>>
<<simpbool.clisp>>

<<slam.o (OUT from MID)>>
<<slam.clisp>>
<<slam.lisp (OUT from IN)>>

<<template.o (OUT from MID)>>
<<template.clisp>>

<<termrw.o (OUT from MID)>>
<<termrw.clisp>>

<<topics.o (AUTO from OUT)>>
<<topics.o (OUT from MID)>>
<<topics.clisp>>

<<trace.o (OUT from MID)>>
<<trace.clisp>>

<<warm.data.stanza>>

<<wi1.o (AUTO from MID)>>
<<wi1.clisp>>

<<wi2.o (AUTO from MID)>>
<<wi2.clisp>>

<<xrun.o (OUT from MID)>>
<<xrun.clisp>>

<<xruncomp.o (AUTO from OUT)>>
<<xruncomp.o (OUT from MID)>>
<<xruncomp.clisp>>

<<DVI from pamphlet>>

@
pp
\eject
\begin{thebibliography}{99}
\bibitem{1} \File{Makefile.pamphlet}
\bibitem{2} \File{src/boot/Makefile.pamphlet}
\bibitem{3} \File{src/interp/bootfuns.lisp.pamphlet}
\bibitem{4} \File{src/interp/setq.lisp.pamphlet}
\bibitem{5} \File{src/interp/patches.lisp.pamphlet}
\bibitem{6} {\bf www.aldor.org}
\bibitem{7} \File{src/interp/apply.boot.pamphlet}
\bibitem{8} \File{src/interp/bits.lisp.pamphlet}
\bibitem{9} \File{src/interp/bootlex.lisp.pamphlet}
\bibitem{10} \File{src/interp/cfuns.lisp.pamphlet}
\bibitem{11} \File{src/interp/comp.lisp.pamphlet}
\bibitem{12} \File{src/interp/construc.lisp.pamphlet}
\bibitem{13} \File{src/interp/daase.lisp.pamphlet}
\bibitem{14} \File{src/interp/debug.lisp.pamphlet}
\bibitem{15} \File{src/interp/def.lisp.pamphlet}
\bibitem{16} \File{src/interp/fortcall.boot.pamphlet}
\bibitem{17} \File{src/interp/fname.lisp.pamphlet}
\bibitem{18} \File{src/interp/fnewmeta.lisp.pamphlet}
\bibitem{19} \File{src/interp/ggreater.lisp.pamphlet}
\bibitem{20} \File{src/interp/hash.lisp.pamphlet}
\bibitem{21} \File{src/interp/macros.lisp.pamphlet}
\bibitem{22} \File{src/interp/metalex.lisp.pamphlet}
\bibitem{23} \File{src/interp/metameta.lisp.pamphlet}
\bibitem{24} \File{src/interp/monitor.lisp.pamphlet}
\bibitem{25} \File{src/interp/newaux.lisp.pamphlet}
\bibitem{26} \File{src/interp/nlib.lisp.pamphlet}
\bibitem{27} \File{src/interp/nocompil.lisp.pamphlet}
\bibitem{28} \File{src/interp/nspadaux.lisp.pamphlet}
\bibitem{29} \File{src/interp/parsing.lisp.pamphlet}
\bibitem{30} \File{src/interp/postprop.lisp.pamphlet}
\bibitem{31} \File{src/interp/preparse.lisp.pamphlet}
\bibitem{32} \File{src/interp/property.lisp.pamphlet}
\bibitem{33} \File{src/interp/sockio.lisp.pamphlet}
\bibitem{34} \File{src/interp/spad.lisp.pamphlet}
\bibitem{35} \File{src/interp/spaderror.lisp.pamphlet}
\bibitem{36} \File{src/interp/sys-pkg.lisp.pamphlet}
\bibitem{37} \File{src/interp/union.lisp.pamphlet}
\bibitem{38} \File{src/interp/util.lisp.pamphlet}
\bibitem{39} \File{src/interp/vmlisp.lisp.pamphlet}
\bibitem{40} \File{src/interp/alql.boot.pamphlet}
\bibitem{41} \File{src/interp/buildom.boot.pamphlet}
\bibitem{42} \File{src/interp/c-util.boot.pamphlet}
\bibitem{43} \File{src/interp/nag-c02.boot.pamphlet}
\bibitem{44} \File{src/interp/nag-c05.boot.pamphlet}
\bibitem{45} \File{src/interp/nag-c06.boot.pamphlet}
\bibitem{46} \File{src/interp/nag-d01.boot.pamphlet}
\bibitem{47} \File{src/interp/nag-d02.boot.pamphlet}
\bibitem{48} \File{src/interp/nag-d03.boot.pamphlet}
\bibitem{49} \File{src/interp/nag-e01.boot.pamphlet}
\bibitem{51} \File{src/interp/nag-e02.boot.pamphlet}
\bibitem{52} \File{src/interp/nag-e04.boot.pamphlet}
\bibitem{53} \File{src/interp/nag-f01.boot.pamphlet}
\bibitem{54} \File{src/interp/nag-f02.boot.pamphlet}
\bibitem{55} \File{src/interp/nag-f04.boot.pamphlet}
\bibitem{56} \File{src/interp/nag-f07.boot.pamphlet}
\bibitem{57} \File{src/interp/nag-s.boot.pamphlet}
\bibitem{58} \File{src/interp/category.boot.pamphlet}
\bibitem{59} \File{src/interp/cattable.boot.pamphlet}
\bibitem{60} \File{src/interp/c-doc.boot.pamphlet}
\bibitem{61} \File{src/interp/clam.boot.pamphlet}
\bibitem{62} \File{src/interp/clammed.boot.pamphlet}
\bibitem{63} \File{src/interp/compat.boot.pamphlet}
\bibitem{64} \File{src/interp/compiler.boot.pamphlet}
\bibitem{65} \File{src/interp/profile.boot.pamphlet}
\bibitem{66} \File{src/interp/compress.boot.pamphlet}
\bibitem{67} \File{src/interp/database.boot.pamphlet}
\end{thebibliography}
\end{document}
