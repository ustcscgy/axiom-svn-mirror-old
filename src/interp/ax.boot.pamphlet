\documentclass{article}
\usepackage{axiom}
\newcommand{\file}[1]{\texttt{#1}}
\begin{document}
\title{\$SPAD/src/interp ax.boot}
\author{Ralf Hemmecke}
\maketitle
\begin{abstract}
We give an overview of what \file{ax.boot} does and in particular
describe the function \verb'makeAxExportForm'.
\end{abstract}
\eject
\tableofcontents
\eject
\section{New Aldor compiler changes}
This was changed so the open source version of axiom can work with the new
aldor compiler.
This used to read:
\begin{verbatim}
  axForm := ['Sequence, ['Import, [], 'AxiomLib], :axForms]
\end{verbatim}
but was changed to read:
<<aldor mod 1>>=
  axForm := ['Sequence, _
               ['Import, [], 'AxiomLib], ['Import, [], 'Boolean], :axForms]
@
\section{Overview}
\subsection{makeAxExportForm}
The most important function in \file{ax.boot} is the function
\verb'makeAxExportForm'.

The function takes as input a filename and a list of constructors.
Via LISP it would be called like
\begin{verbatim}
(|makeAxExportForm| filename constructors)
\end{verbatim}
where \verb'filename' is actually unused and could be removed and
\verb'constructors' should be a list of constructor names, i.e., names
of categories, domains, and packages in their unabbreviated form.

It returns a list that represents the \texttt{.ap} (parsed source)
(see \verb'aldor -hall') form of the constructors. However, since the
output is only needed for a construction of an Aldor-Axiom
interaction, \verb'makeAxExportForm' will only construct the category
part of the constructor.

The function is actually used in \file{src/aldor/genax.lsp} and is an
auxiliary part in the construction of the interface for the
interaction of the Aldor compiler with Axiom.
<<makeAxExportForm>>=
makeAxExportForm(filename, constructors) ==
  $defaultFlag : local := false
  $literals := []
  axForms :=
     [modemapToAx(modemap) for cname in constructors |
            (modemap:=GETDATABASE(cname,'CONSTRUCTORMODEMAP)) and
              (not cname in '(Tuple Exit Type)) and
                not isDefaultPackageName cname]
  if $baseForms then
     axForms := [:$baseForms, :axForms]
  if $defaultFlag then
     axForms :=
        [['Foreign, ['Declare, 'dummyDefault, 'Exit], 'Lisp], :axForms]
  axForms := APPEND(axDoLiterals(), axForms)
  axForm := ['Sequence, _
               ['Import, [], 'AxiomLib], ['Import, [], 'Boolean], :axForms]
  axForm

@
The basic translation is easily demonstrated with a few examples. For
better readability, we look at the corresponding SPAD form of the
constructor (instead of its internal LISP representation).

Let us first state what different situations we identified.
\begin{enumerate}
\item Ordinary domains. See Section~\ref{sec:Domain}.
\item Ordinary categories. See Section~\ref{sec:Category}.
\item Ordinary categories with default packages. See
  Section~\ref{sec:Category+Default}.
\item Initial domains, i.e., domains that will be extended in the
  course of building \file{libaxiom.al}. These domains are listed in
  the variable \verb'$extendedDomains'. %$

  See Sections~\ref{sec:InitDomain} and
  \ref{sec:ParametrizedInitDomain}. There is a subdivision for these
  domains.
  \begin{enumerate}
  \item For domains that take no arguments, see
    Section~\ref{sec:InitDomain}.
  \item For domains that take arguments, see
    Section~\ref{sec:ParametrizedInitDomain}.
  \end{enumerate}
\end{enumerate}
\section{Ordinary Domains}\label{sec:Domain}
The domain \verb'Stack'.
\begin{verbatim}
Stack(S:SetCategory): StackAggregate S with
    stack: List S -> %
  == add
    Rep := Reference List S
    ...
\end{verbatim}
It is translated into \ldots
\begin{verbatim}
(|Sequence| (|Import| NIL |AxiomLib|) (|Import| NIL |Boolean|)
    (|Export|
        (|Declare| |Stack|
            (|Apply| -> (|Declare| |#1| |SetCategory|)
                     (|With| NIL
                             (|Sequence|
                                 (|Apply| |StackAggregate| |#1|)
                                 (|Declare| |stack|
                                     (|Apply| ->
                                      (|Comma| (|Apply| |List| |#1|))
                                      %))))))
        NIL NIL))
\end{verbatim}
That is the parsed source of the Aldor code \ldots
\begin{verbatim}
import from AxiomLib;
import from Boolean;
export Stack: (T: SetCategory) -> with {
                                        StackAggregate T;
                                        stack: List T -> %;
                                  }
\end{verbatim}
Note that nothing appears before the \verb'with'. No problem because
that is equivalent to a \verb'Join' in Aldor.
\section{Ordinary Categories}\label{sec:Category}
The category \verb'SquareFreeNormalizedTriangularSetCategory' without
a default package.
\begin{verbatim}
SquareFreeNormalizedTriangularSetCategory(_
        R: GcdDomain,_
        E: OrderedAbelianMonoidSup,_
        V: OrderedSet,_
        P:RecursivePolynomialCategory(R, E, V)): Category ==
    Join(_
        SquareFreeRegularTriangularSetCategory(R,E,V,P),_
         NormalizedTriangularSetCategory(R,E,V,P))
\end{verbatim}
It is translated into \ldots
\begin{verbatim}
(|Sequence| (|Import| NIL |AxiomLib|) (|Import| NIL |Boolean|)
    (|Define|
        (|Declare| |SquareFreeNormalizedTriangularSetCategory|
            (|Apply| ->
                     (|Comma| (|Declare| |#1| |GcdDomain|)
                              (|Declare| |#2|
                                  |OrderedAbelianMonoidSup|)
                              (|Declare| |#3| |OrderedSet|)
                              (|Declare| |#4|
                                  (|Apply| |RecursivePolynomialCategory|
                                           |#1| |#2| |#3|)))
                     |Category|))
        (|Lambda|
            (|Comma| (|Declare| |#1| |GcdDomain|)
                     (|Declare| |#2| |OrderedAbelianMonoidSup|)
                     (|Declare| |#3| |OrderedSet|)
                     (|Declare| |#4|
                         (|Apply| |RecursivePolynomialCategory| |#1|
                                  |#2| |#3|)))
            |Category|
            (|Label| |SquareFreeNormalizedTriangularSetCategory|
                     (|With| NIL
                             (|Sequence|
                                 (|Apply| |SquareFreeRegularTriangularSetCategory|
                                          |#1| |#2| |#3| |#4|)
                                 (|Apply| |NormalizedTriangularSetCategory|
                                          |#1| |#2| |#3| |#4|)))))))
\end{verbatim}
That is the parsed source of the Aldor code \ldots
\begin{verbatim}
import from AxiomLib;
import from Boolean;
SquareFreeNormalizedTriangularSetCategory: (
        R: GcdDomain,
        E: OrderedAbelianMonoidSup,
        V: OrderedSet,
        P: RecursivePolynomialCategory(R, E, V)
) -> Category == (
        R: GcdDomain,
        E: OrderedAbelianMonoidSup,
        V: OrderedSet,
        P: RecursivePolynomialCategory(R, E, V)
): Category +-> with {
        SquareFreeRegularTriangularSetCategory(R, E, V, P),
        NormalizedTriangularSetCategory(R, E, V, P)
}
\end{verbatim}
  Again, nothing appears in front of the \verb'with'. No problem
  because that is equivalent to a \verb'Join' in Aldor.
\section{Ordinary Categories with Default Packages}
\label{sec:Category+Default}
The category \verb'StringAggregate' with default package.
\begin{verbatim}
StringAggregate: Category == OneDimensionalArrayAggregate Character with
    lowerCase       : % -> %
    lowerCase_!: % -> %
    upperCase       : % -> %
    ...
    rightTrim: (%, CharacterClass) -> %
    elt: (%, %) -> %
 add
   trim(s: %, c:  Character)      == leftTrim(rightTrim(s, c),  c)
   trim(s: %, cc: CharacterClass) == leftTrim(rightTrim(s, cc), cc)
   lowerCase s           == lowerCase_! copy s
   upperCase s           == upperCase_! copy s
   prefix?(s, t)         == substring?(s, t, minIndex t)
   coerce(c:Character):% == new(1, c)
   elt(s:%, t:%): %      == concat(s,t)$%
\end{verbatim}
It is translated into \ldots
\begin{verbatim}
(|Sequence| (|Import| NIL |AxiomLib|) (|Import| NIL |Boolean|)
    (|Foreign| (|Declare| |dummyDefault| |Exit|) |Lisp|)
    (|Define| (|Declare| |StringAggregate| |Category|)
        (|With| NIL
                (|Sequence|
                    (|Apply| |OneDimensionalArrayAggregate|
                             |Character|)
                    (|Declare| |lowerCase| (|Apply| -> (|Comma| %) %))
                    (|Declare| |lowerCase!| (|Apply| -> (|Comma| %) %))
                    (|Declare| |upperCase| (|Apply| -> (|Comma| %) %))
                    ...
                    (|Declare| |rightTrim|
                        (|Apply| -> (|Comma| % |CharacterClass|) %))
                    (|Declare| |apply| (|Apply| -> (|Comma| % %) %))
                    (|Default|
                        (|Sequence|
                            (|Define|
                                (|Declare| |coerce|
                                    (|Apply| -> (|Comma| |Character|)
                                     %))
                                (|Lambda|
                                    (|Comma|
                                     (|Declare| |t#1| |Character|))
                                    %
                                    (|Label| |coerce| |dummyDefault|)))
                            (|Define|
                                (|Declare| |apply|
                                    (|Apply| -> (|Comma| % %) %))
                                (|Lambda|
                                    (|Comma| (|Declare| |t#1| %)
                                     (|Declare| |t#2| %))
                                    % (|Label| |apply| |dummyDefault|)))
                            (|Define|
                                (|Declare| |lowerCase|
                                    (|Apply| -> (|Comma| %) %))
                                (|Lambda| (|Comma| (|Declare| |t#1| %))
                                    %
                                    (|Label| |lowerCase|
                                     |dummyDefault|)))
                            ...
                            ))))))
\end{verbatim}
That is the parsed source of the Aldor code \ldots
\begin{verbatim}
import from AxiomLib;
import from Boolean;
import dummyDefault: Exit from Foreign Lisp;
StringAggregate: Category == with {
    OneDimensionalArrayAggregate Character;
    lowerCase: % -> %;
    lowerCase!: % -> %;
    upperCase: % -> %;
    ...
    rightTrim: (%, CharacterClass) -> %;
    apply: (%, %) -> %
 default {
   coerce: Character -> % == (t: Character): % +-> dummyDefault;
   apply: (%, %) -> %     == (t1: %, t2: %): % +-> dummyDefault;
   lowerCase: % -> %      == (t: %): %         +-> dummyDefault;
   ...
}
\end{verbatim}
It is important to note that the actual default functions are given by
a dummy implementation that is imported from LISP.

And again, nothing appears in front of the \verb'with'. No problem
because that is equivalent to a \verb'Join' in Aldor.

Note that the \verb'elt' function is translated into \verb'apply'.
\section{Initial Domains without Arguments}
\label{sec:InitDomain}
\begin{verbatim}
SingleInteger(): Join(IntegerNumberSystem,Logic,OpenMath) with
   canonical
   canonicalsClosed
   noetherian
   max      : () -> %
   min      : () -> %
   "not":   % -> %
   "~"  :   % -> %
   "/\": (%, %) -> %
   "\/" : (%, %) -> %
   "xor": (%, %) -> %
   Not  : % -> %
   And  : (%,%) -> %
   Or   : (%,%) -> %
 == add
   ...
\end{verbatim}
It is translated into \ldots
\begin{verbatim}
(|Sequence| (|Import| NIL |AxiomLib|) (|Import| NIL |Boolean|)
    (|Extend|
        (|Define|
            (|Declare| |SingleInteger|
                (|With| NIL
                        (|Sequence| |IntegerNumberSystem| |Logic|
                            |OpenMath|
                            (|RestrictTo| |canonical| |Category|)
                            (|RestrictTo| |canonicalsClosed|
                                |Category|)
                            (|RestrictTo| |noetherian| |Category|)
                            (|Declare| |max| (|Apply| -> (|Comma|) %))
                            (|Declare| |min| (|Apply| -> (|Comma|) %))
                            (|Declare| |not|
                                (|Apply| -> (|Comma| %) %))
                            (|Declare| ~ (|Apply| -> (|Comma| %) %))
                            (|Declare| |/\\|
                                (|Apply| -> (|Comma| % %) %))
                            (|Declare| |\\/|
                                (|Apply| -> (|Comma| % %) %))
                            (|Declare| |xor|
                                (|Apply| -> (|Comma| % %) %))
                            (|Declare| |Not|
                                (|Apply| -> (|Comma| %) %))
                            (|Declare| |And|
                                (|Apply| -> (|Comma| % %) %))
                            (|Declare| |Or|
                                (|Apply| -> (|Comma| % %) %)))))
            (|Add| (|PretendTo| (|Add| NIL NIL)
                       (|With| NIL
                               (|Sequence| |IntegerNumberSystem|
                                   |Logic| |OpenMath|
                                   (|RestrictTo| |canonical|
                                    |Category|)
                                   (|RestrictTo| |canonicalsClosed|
                                    |Category|)
                                   (|RestrictTo| |noetherian|
                                    |Category|)
                                   (|Declare| |max|
                                    (|Apply| -> (|Comma|) %))
                                   (|Declare| |min|
                                    (|Apply| -> (|Comma|) %))
                                   (|Declare| |not|
                                    (|Apply| -> (|Comma| %) %))
                                   (|Declare| ~
                                    (|Apply| -> (|Comma| %) %))
                                   (|Declare| |/\\|
                                    (|Apply| -> (|Comma| % %) %))
                                   (|Declare| |\\/|
                                    (|Apply| -> (|Comma| % %) %))
                                   (|Declare| |xor|
                                    (|Apply| -> (|Comma| % %) %))
                                   (|Declare| |Not|
                                    (|Apply| -> (|Comma| %) %))
                                   (|Declare| |And|
                                    (|Apply| -> (|Comma| % %) %))
                                   (|Declare| |Or|
                                    (|Apply| -> (|Comma| % %) %)))))
                   NIL))))
\end{verbatim}
That is the parsed source of the Aldor code \ldots
\begin{verbatim}
import from AxiomLib;
import from Boolean;
extend SingleInteger: with {
        IntegerNumberSystem;
        Logic;
        OpenMath;
        canonical @ Category;
        canonicalsClosed @ Category;
        noetherian @ Category;
        max: () -> %;
        min: () -> %;
        _not: % -> %;
        ~:   % -> %;
        /\:  (%, %) -> %;
        \/:  (%, %) -> %;
        xor: (%, %) -> %;
        Not: % -> %;
        And: (%,%) -> %;
        Or : (%,%) -> %;
}
 == (add pretend with {
        IntegerNumberSystem;
        Logic;
        OpenMath;
        canonical @ Category;
        canonicalsClosed @ Category;
        noetherian @ Category;
        max: () -> %;
        min: () -> %;
        _not: % -> %;
        ~:   % -> %;
        /\:  (%, %) -> %;
        \/:  (%, %) -> %;
        xor: (%, %) -> %;
        Not: % -> %;
        And: (%,%) -> %;
        Or : (%,%) -> %;
}) add;
\end{verbatim}
\section{Initial Domains with Arguments}
\label{sec:ParametrizedInitDomain}
\begin{verbatim}
SegmentBinding(S:Type): Type with
  equation: (Symbol, Segment S) -> %
  variable: % -> Symbol
  segment : % -> Segment S
  if S has SetCategory then SetCategory
 == add
  Rep := Record(var:Symbol, seg:Segment S)
  ...
\end{verbatim}
It is translated into \ldots
\begin{verbatim}
(|Sequence| (|Import| NIL |AxiomLib|) (|Import| NIL |Boolean|)
    (|Sequence|
        (|Define|
            (|Declare| |SegmentBindingExtendCategory|
                (|Apply| -> (|Declare| |#1| |Type|) |Category|))
            (|Lambda| (|Comma| (|Declare| |#1| |Type|)) |Category|
                (|Label| |SegmentBindingExtendCategory|
                         (|With| NIL
                                 (|Sequence|
                                     (|Declare| |equation|
                                      (|Apply| ->
                                       (|Comma| |Symbol|
                                        (|Apply| |Segment| |#1|))
                                       %))
                                     (|Declare| |variable|
                                      (|Apply| -> (|Comma| %) |Symbol|))
                                     (|Declare| |segment|
                                      (|Apply| -> (|Comma| %)
                                       (|Apply| |Segment| |#1|)))
                                     (|If|
                                      (|Test|
                                       (|Has| |#1| |SetCategory|))
                                      |SetCategory| NIL))))))
        (|Extend|
            (|Define|
                (|Declare| |SegmentBinding|
                    (|Apply| -> (|Declare| |#1| |Type|)
                             (|Apply| |SegmentBindingExtendCategory|
                                      |#1|)))
                (|Lambda| (|Comma| (|Declare| |#1| |Type|))
                    (|Apply| |SegmentBindingExtendCategory| |#1|)
                    (|Label| |SegmentBinding|
                             (|Add| (|PretendTo| (|Add| NIL NIL)
                                     (|Apply|
                                      |SegmentBindingExtendCategory|
                                      |#1|))
                                    NIL)))))))
\end{verbatim}
That is the parsed source of the Aldor code \ldots
\begin{verbatim}
import from AxiomLib;
import from Boolean;
SegmentBindingExtendCategory: (S: Type) -> Category ==
  (T: Type): Category +-> with {
  equation: (Symbol, Segment S) -> %;
  variable: % -> Symbol;
  segment : % -> Segment S;
  if S has SetCategory then SetCategory;
}
extend SegmentBinding: (S: Type) -> SegmentBindingExtendCategory S ==
  (S: Type): SegmentBindingExtendCategory S +->
    (add pretend SegmentBindingExtendCategory S) add;
\end{verbatim}
The last lines are actually equivalent to
\begin{verbatim}
extend SegmentBinding(S: Type): SegmentBindingExtendCategory S ==
    (add pretend SegmentBindingExtendCategory S) add;
\end{verbatim}

\section{axFormatPref}
Here we add an else clause. The original code read:
\begin{verbatim}
      if name = '$ then name := '%
\end{verbatim}
It appears that Aldor allows a richer syntax for [[has]]
conditions since the call to [[axFormatOp]] appears to allow
nested IF conditions.OQ
<<axFormatPred aldor change>>=
axFormatPred pred ==
   atom pred => pred
   [op,:args] := pred
   op = 'IF => axFormatOp pred
   op = 'has =>
      [name,type] := args
      if name = '$ then name := '%
      else name := axFormatOp name
      ftype := axFormatOp type
      if ftype is ['Declare,:.] then
           ftype := ['With, [], ftype]
      ['Test,['Has,name, ftype]]
   axArglist := [axFormatPred arg for arg in args]
   op = 'AND => ['And,:axArglist]
   op = 'OR  => ['Or,:axArglist]
   op = 'NOT => ['Not,:axArglist]
   error "unknown predicate"

@
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

$stripTypes := false
$pretendFlag := false
$defaultFlag := false
$baseForms := nil
$literals  := nil

spad2AxTranslatorAutoloadOnceTrigger any == true

sourceFilesToAxFile(filename, sourceFiles) ==
  makeAxFile(filename, MAPCAN('fileConstructors, sourceFiles))


$extendedDomains := nil

setExtendedDomains(l) == 
	$extendedDomains := l

fileConstructors name ==
   [INTERN(con,"BOOT") for con in SRCABBREVS SOURCEPATH STRING name]

makeAxFile(filename, constructors) ==
  $defaultFlag : local := false
  $literals := []
  axForms :=
     [modemapToAx(modemap) for cname in constructors |
            (modemap:=GETDATABASE(cname,'CONSTRUCTORMODEMAP)) and
              (not cname in '(Tuple Exit Type)) and
                not isDefaultPackageName cname]
  if $baseForms then
     axForms := [:$baseForms, :axForms]
  if $defaultFlag then
     axForms :=
        [['Foreign, ['Declare, 'dummyDefault, 'Exit], 'Lisp], :axForms]
  axForms := APPEND(axDoLiterals(), axForms)
<<aldor mod 1>>
  st := MAKE_-OUTSTREAM(filename)
  PPRINT(axForm,st)
  CLOSE st

<<makeAxExportForm>>

stripType type ==
  $stripTypes =>
     categoryForm? type => 'Type
     type
  type

modemapToAx(modemap) ==
  modemap is [[consform, target,:argtypes],.]
  consform is [constructor,:args]
  argdecls:=['Comma, : [axFormatDecl(a,stripType t) for a in args for t in argtypes]]
  resultType :=  axFormatType stripType target
  categoryForm? constructor =>
      categoryInfo := GETDATABASE(constructor,'CONSTRUCTORCATEGORY)
      categoryInfo := SUBLISLIS($FormalMapVariableList, $TriangleVariableList,
                       categoryInfo)
      NULL args =>
          ['Define,['Declare, constructor,'Category],
               addDefaults(constructor, axFormatType categoryInfo)]
      ['Define,
          ['Declare, constructor, ['Apply, "->", optcomma argdecls, 'Category]],
           ['Lambda, argdecls, 'Category,
 	     ['Label, constructor,
               addDefaults(constructor, axFormatType categoryInfo)]]]
  constructor in $extendedDomains =>
     NULL args =>
        ['Extend, ['Define, ['Declare, constructor, resultType],
            ['Add, ['PretendTo, ['Add, [], []], resultType], []]]]
     conscat := INTERN(STRCONC(SYMBOL_-NAME(constructor), "ExtendCategory"),"BOOT")
     rtype := ['Apply, conscat, :args]
--     if resultType is ['With,a,b] then
--        if not(b is ['Sequence,:withseq]) then withseq := [b]
--        cosigs := rest GETDATABASE(constructor, 'COSIG)
--        exportargs := [['Export, [], arg, []] for arg in args for p in cosigs | p]
--        resultType := ['With,a,['Sequence,:APPEND(exportargs, withseq)]]
     consdef := ['Define,
        ['Declare, conscat, ['Apply, "->", optcomma argdecls, 'Category]],
          ['Lambda, argdecls, 'Category, ['Label, conscat, resultType]]]
     ['Sequence, consdef,
      ['Extend, ['Define,
        ['Declare, constructor, ['Apply, "->", optcomma argdecls, rtype]],
          ['Lambda, argdecls, rtype,
            ['Label, constructor,
                ['Add, ['PretendTo, ['Add, [], []], rtype], []]]]]]]
  NULL args =>
     ['Export, ['Declare, constructor, resultType],[],[]]
--  if resultType is ['With,a,b] then
--     if not(b is ['Sequence,:withseq]) then withseq := [b]
--     cosigs := rest GETDATABASE(constructor, 'COSIG)
--     exportargs := [['Export, [], arg, []] for arg in args for p in cosigs | p]
--     resultType := ['With,a,['Sequence,:APPEND(exportargs, withseq)]]
  ['Export, ['Declare, constructor, ['Apply, "->", optcomma argdecls, resultType]],[],[]]

optcomma [op,:args] ==
   # args = 1 => first args
   [op,:args]

axFormatDecl(sym, type) ==
   if sym = '$ then sym := '%
   opOf type in '(StreamAggregate FiniteLinearAggregate) =>
        ['Declare, sym, 'Type]
   ['Declare, sym, axFormatType type]

makeTypeSequence l ==
   ['Sequence,: delete('Type, l)]

axFormatAttrib(typeform) ==
  atom typeform => typeform
  axFormatType typeform

axFormatType(typeform) ==
  atom typeform =>
     typeform = '$ => '%
     STRINGP typeform =>
        ['Apply,'Enumeration, INTERN typeform]
     INTEGERP typeform =>
       -- need to test for PositiveInteger vs Integer
        axAddLiteral('integer, 'PositiveInteger, 'Literal)
        ['RestrictTo, ['LitInteger, STRINGIMAGE typeform ], 'PositiveInteger]
     FLOATP typeform => ['LitFloat, STRINGIMAGE typeform]
     MEMQ(typeform,$TriangleVariableList) =>
        SUBLISLIS($FormalMapVariableList, $TriangleVariableList, typeform)
     MEMQ(typeform, $FormalMapVariableList) => typeform
     axAddLiteral('string, 'Symbol, 'Literal)
     ['RestrictTo, ['LitString, PNAME typeform], 'Symbol]
  typeform is ['construct,: args] =>
      axAddLiteral('bracket, ['Apply, 'List, 'Symbol], [ 'Apply, 'Tuple, 'Symbol])
      axAddLiteral('string, 'Symbol, 'Literal)
      ['RestrictTo, ['Apply, 'bracket, 
         		:[axFormatType a for a in args]],
			  ['Apply, 'List, 'Symbol] ]
  typeform is [op] =>
    op = '$ => '%
    op = 'Void => ['Comma]
    op
  typeform is ['local, val] => axFormatType val
  typeform is ['QUOTE, val] => axFormatType val
  typeform is ['Join,:cats,lastcat] =>
      lastcat is ['CATEGORY,type,:ops] =>
         ['With, [],
            makeTypeSequence(
               APPEND([axFormatType c for c in cats],
               	        [axFormatOp op for op in ops]))]
      ['With, [], makeTypeSequence([axFormatType c for c in rest typeform])]
  typeform is ['CATEGORY, type, :ops] =>
      ['With, [],  axFormatOpList ops]
  typeform is ['Mapping, target, :argtypes] =>
      ['Apply, "->",
               ['Comma, :[axFormatType t for t in argtypes]],
                axFormatType target]
  typeform is ['_:, name, type] => axFormatDecl(name,type)
  typeform is ['Union, :args] =>
      first args is ['_:,.,.] =>
         ['Apply, 'Union, :[axFormatType a for a in args]]
      taglist := []
      valueCount := 0
      for x in args repeat
          tag :=
            STRINGP x => INTERN x
            x is ['QUOTE,val] and STRINGP val => INTERN val
            valueCount := valueCount + 1
            INTERNL("value", STRINGIMAGE valueCount)
          taglist := [tag ,: taglist]
      ['Apply, 'Union, :[axFormatDecl(name,type) for name in reverse taglist
                                for type in args]]
  typeform is ['Dictionary,['Record,:args]] =>
      ['Apply, 'Dictionary,
          ['PretendTo, axFormatType CADR typeform, 'SetCategory]]
  typeform is ['FileCategory,xx,['Record,:args]] =>
      ['Apply, 'FileCategory, axFormatType xx,
          ['PretendTo, axFormatType CADDR typeform, 'SetCategory]]
  typeform is [op,:args] =>
      $pretendFlag and constructor? op and
        GETDATABASE(op,'CONSTRUCTORMODEMAP) is [[.,target,:argtypes],.] =>
          ['Apply, op,
               :[['PretendTo, axFormatType a, axFormatType t]
                     for a in args for t in argtypes]]
      MEMQ(op, '(SquareMatrix SquareMatrixCategory DirectProduct
         DirectProductCategory RadixExpansion)) and
            GETDATABASE(op,'CONSTRUCTORMODEMAP) is [[.,target,arg1type,:restargs],.] =>
               ['Apply, op,
                  ['PretendTo, axFormatType first args, axFormatType arg1type],
                     :[axFormatType a for a in rest args]]
      ['Apply, op, :[axFormatType a for a in args]]
  error "unknown entry type"

axFormatOpList ops == ['Sequence,:[axFormatOp o for o in ops]]

axOpTran(name) ==
   ATOM name =>
      name = 'elt => 'apply
      name = 'setelt => 'set!
      name = 'SEGMENT => ".."
      name = 1 => '_1
      name = 0 => '_0
      name
   opOf name = 'Zero => '_0
   opOf name = 'One => '_1
   error "bad op name"

axFormatOpSig(name, [result,:argtypes]) ==
   ['Declare, axOpTran name,
         ['Apply, "->", ['Comma, :[axFormatType t for t in argtypes]],
                        axFormatType result]]

axFormatConstantOp(name, [result]) ==
   ['Declare, axOpTran name, axFormatType result]

<<axFormatPred aldor change>>

axFormatCondOp op ==
  $pretendFlag:local := true
  axFormatOp op


axFormatOp op ==
   op is ['IF, pred, trueops, falseops] =>
      NULL(trueops) or trueops='noBranch =>
         ['If, ['Test,['Not, axFormatPred pred]],
              axFormatCondOp falseops,
                axFormatCondOp trueops]
      ['If, axFormatPred pred,
             axFormatCondOp trueops,
              axFormatCondOp falseops]
       -- ops are either single op or ['PROGN, ops]
   op is ['SIGNATURE, name, type] => axFormatOpSig(name,type)
   op is ['SIGNATURE, name, type, 'constant] =>
            axFormatConstantOp(name,type)
   op is ['ATTRIBUTE, attributeOrCategory] =>
       categoryForm? attributeOrCategory =>
           axFormatType attributeOrCategory
       ['RestrictTo, axFormatAttrib attributeOrCategory, 'Category]
   op is ['PROGN, :ops] => axFormatOpList ops
   op is 'noBranch => []
   axFormatType op

addDefaults(catname, withform) ==
  withform isnt ['With, joins, ['Sequence,: oplist]] =>
     error "bad category body"
  null(defaults := getDefaultingOps catname) => withform
  defaultdefs := [makeDefaultDef(decl) for decl in defaults]
  ['With, joins,
     ['Sequence, :oplist, ['Default, ['Sequence,: defaultdefs]]]]

makeDefaultDef(decl) ==
  decl isnt ['Declare, op, type] =>
       error "bad default definition"
  $defaultFlag := true
  type is ['Apply, "->", args, result] =>
       ['Define, decl, ['Lambda, makeDefaultArgs args, result,
                    ['Label, op, 'dummyDefault]]]
  ['Define, ['Declare, op, type], 'dummyDefault]

makeDefaultArgs args ==
  args isnt ['Comma,:argl] => error "bad default argument list"
  ['Comma,: [['Declare,v,t] for v in $TriangleVariableList for t in argl]]

getDefaultingOps catname ==
  not(name:=hasDefaultPackage catname) => nil
  $infovec: local := getInfovec name
  opTable := $infovec.1
  $opList:local  := nil
  for i in 0..MAXINDEX opTable repeat
    op := opTable.i
    i := i + 1
    startIndex := opTable.i
    stopIndex :=
      i + 1 > MAXINDEX opTable => MAXINDEX getCodeVector()
      opTable.(i + 2)
    curIndex := startIndex
    while curIndex < stopIndex repeat
      curIndex := get1defaultOp(op,curIndex)
  $pretendFlag : local := true
  catops := GETDATABASE(catname, 'OPERATIONALIST)
  [axFormatDefaultOpSig(op,sig,catops) for opsig in $opList | opsig is [op,sig]]

axFormatDefaultOpSig(op, sig, catops) ==
  #sig > 1 => axFormatOpSig(op,sig)
  nsig := MSUBST('$,'($), sig) -- dcSig listifies '$ ??
  (catsigs := LASSOC(op, catops)) and
    (catsig := assoc(nsig, catsigs)) and last(catsig) = 'CONST =>
       axFormatConstantOp(op, sig)
  axFormatOpSig(op,sig)

get1defaultOp(op,index) ==
  numvec := getCodeVector()
  segment := getOpSegment index
  numOfArgs := numvec.index
  index := index + 1
  predNumber := numvec.index
  index := index + 1
  signumList :=
 -- following substitution fixes the problem that default packages
 -- have $ added as a first arg, thus other arg counts are off by 1.
    SUBLISLIS($FormalMapVariableList, rest $FormalMapVariableList,
             dcSig(numvec,index,numOfArgs))
  index := index + numOfArgs + 1
  slotNumber := numvec.index
  if not([op,signumList] in $opList) then
     $opList := [[op,signumList],:$opList]
  index + 1

axAddLiteral(name, type, dom) == 
  elt := [name, type, dom]
  if not member( elt, $literals) then
     $literals := [elt, :$literals]

axDoLiterals() == 
  [ [ 'Import,
	  [ 'With, [], 
 	    ['Declare, name, [ 'Apply, '_-_> , dom , '_% ]]],
		 type ] for [name, type, dom] in $literals]

@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
