\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp postpar.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
This file contains both the {\bf boot} code and the {\bf Lisp}
code that is the result of the {\bf boot to lisp} translation.
We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated
so we can build the boot translator. 

{\bf NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST TRANSLATE
THIS CODE TO LISP AND STORE THE RESULTING LISP CODE BACK INTO
THIS FILE.}

See the {\bf postpar.clisp} section below.
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>

--% Yet Another Parser Transformation File
--These functions are used by for BOOT and SPAD code
--(see new2OldLisp, e.g.)

postTransform y ==
  x:= y
  u:= postTran x
  if u is ['Tuple,:l,[":",y,t]] and (and/[IDENTP x for x in l]) then u:=
    [":",['LISTOF,:l,y],t]
  postTransformCheck u
  aplTran u

displayPreCompilationErrors() ==
  n:= #($postStack:= REMDUP NREVERSE $postStack)
  n=0 => nil
  errors:=
    1<n => '"errors"
    '"error"
  if $InteractiveMode
    then sayBrightly ['"   Semantic ",errors,'" detected: "]
    else
      heading:=
        $topOp ^= '$topOp => ['"   ",$topOp,'" has"]
        ['"   You have"]
      sayBrightly [:heading,'%b,n,'%d,'"precompilation ",errors,'":"]
  if 1<n then
    (for x in $postStack for i in 1.. repeat sayMath ['"   ",i,'"_) ",:x])
    else sayMath ['"    ",:first $postStack]
  TERPRI()

postTran x ==
  atom x =>
    postAtom x
  op := first x
  atom op and (f:= GET(op,'postTran)) => FUNCALL(f,x)
  op is ['elt,a,b] =>
    u:= postTran [b,:rest x]
    [postTran op,:rest u]
  op is ['Scripts,:.] =>
    postScriptsForm(op,"append"/[unTuple postTran y for y in rest x])
  op^=(y:= postOp op) => [y,:postTranList rest x]
  postForm x

postTranList x == [postTran y for y in x]

postBigFloat x ==
  [.,mant,:expon] := x
  $BOOT => INT2RNUM(mant) * INT2RNUM(10) ** expon
  eltword := if $InteractiveMode then "$elt" else 'elt
  postTran [[eltword,'(Float),'float],[",",[",",mant,expon],10]]

postAdd ['add,a,:b] ==
  null b => postCapsule a
  ['add,postTran a,postCapsule first b]

checkWarning msg == postError concat('"Parsing error: ",msg)
 
checkWarningIndentation() ==
  checkWarning ['"Apparent indentation error following",:bright "add"]

postCapsule x ==
  x isnt [op,:.] => checkWarningIndentation()
  INTEGERP op or op = "==" => ['CAPSULE,postBlockItem x]
  op = ";" => ['CAPSULE,:postBlockItemList postFlatten(x,";")]
  op = "if" => ['CAPSULE,postBlockItem x]
  checkWarningIndentation()

postQUOTE x == x

postColon u ==
  u is [":",x] => [":",postTran x]
  u is [":",x,y] => [":",postTran x,:postType y]

postColonColon u ==
  -- for Lisp package calling
  -- boot syntax is package::fun but probably need to parenthesize it
  $BOOT and u is ["::",package,fun] =>
    INTERN(STRINGIMAGE fun, package)
  postForm u

postAtSign ["@",x,y] == ["@",postTran x,:postType y]

postPretend ['pretend,x,y] == ['pretend,postTran x,:postType y]

postConstruct u ==
  u is ['construct,b] =>
    a:= (b is [",",:.] => comma2Tuple b; b)
    a is ['SEGMENT,p,q] => ['construct,postTranSegment(p,q)]
    a is ['Tuple,:l] =>
      or/[x is [":",y] for x in l] => postMakeCons l
      or/[x is ['SEGMENT,:.] for x in l] => tuple2List l
      ['construct,:postTranList l]
    ['construct,postTran a]
  u

postError msg ==
  BUMPERRORCOUNT 'precompilation
  xmsg:=
    $defOp ^= '$defOp and not InteractiveMode => [$defOp,'": ",:msg]
    msg
  $postStack:= [xmsg,:$postStack]
  nil

postMakeCons l ==
  null l => 'nil
  l is [[":",a],:l'] =>
    l' => ['append,postTran a,postMakeCons l']
    postTran a
  ['cons,postTran first l,postMakeCons rest l]

postAtom x ==
  $BOOT => x
  x=0 => '(Zero)
  x=1 => '(One)
  EQ(x,'T) => 'T_$ -- rename T in spad code to T$
  IDENTP x and GETDATABASE(x,'NILADIC) => LIST x
  x

postBlock ['Block,:l,x] ==
  ['SEQ,:postBlockItemList l,['exit,postTran x]]

postBlockItemList l == [postBlockItem x for x in l]

postBlockItem x ==
  x:= postTran x
  x is ['Tuple,:l,[":",y,t]] and (and/[IDENTP x for x in l]) =>
    [":",['LISTOF,:l,y],t]
  x

postCategory (u is ['CATEGORY,:l]) ==
  --RDJ: ugh_ please -- someone take away need for PROGN as soon as possible
  null l => u
  op :=
    $insidePostCategoryIfTrue = true => 'PROGN
    'CATEGORY
  [op,:[fn x for x in l]] where fn x ==
    $insidePostCategoryIfTrue: local := true
    postTran x

postComma u == postTuple comma2Tuple u

comma2Tuple u == ['Tuple,:postFlatten(u,",")]

postDef [defOp,lhs,rhs] ==
--+
  lhs is ["macro",name] => postMDef ["==>",name,rhs]

  if not($BOOT) then recordHeaderDocumentation nil
  if $maxSignatureLineNumber ^= 0 then
    $docList := [['constructor,:$headerDocumentation],:$docList]
    $maxSignatureLineNumber := 0
    --reset this for next constructor; see recordDocumentation
  lhs:= postTran lhs
  [form,targetType]:=
    lhs is [":",:.] => rest lhs
    [lhs,nil]
  if null $InteractiveMode and atom form then form := LIST form
  newLhs:=
    atom form => form
    [op,:argl]:= [(x is [":",a,.] => a; x) for x in form]
    [op,:postDefArgs argl]
  argTypeList:=
    atom form => nil
    [(x is [":",.,t] => t; nil) for x in rest form]
  typeList:= [targetType,:argTypeList]
  if atom form then form := [form]
  specialCaseForm := [nil for x in form]
  ['DEF,newLhs,typeList,specialCaseForm,postTran rhs]

postDefArgs argl ==
  null argl => argl
  argl is [[":",a],:b] =>
    b => postError
      ['"   Argument",:bright a,'"of indefinite length must be last"]
    atom a or a is ['QUOTE,:.] => a
    postError
      ['"   Argument",:bright a,'"of indefinite length must be a name"]
  [first argl,:postDefArgs rest argl]

postMDef(t) ==
  [.,lhs,rhs] := t
  $InteractiveMode and not $BOOT =>
    lhs := postTran lhs
    null IDENTP lhs => throwKeyedMsg("S2IP0001",NIL)
    ['MDEF,lhs,NIL,NIL,postTran rhs]
  lhs:= postTran lhs
  [form,targetType]:=
    lhs is [":",:.] => rest lhs
    [lhs,nil]
  form:=
    atom form => LIST form
    form
  newLhs:= [(x is [":",a,:.] => a; x) for x in form]
  typeList:= [targetType,:[(x is [":",.,t] => t; nil) for x in rest form]]
  ['MDEF,newLhs,typeList,[nil for x in form],postTran rhs]

postElt (u is [.,a,b]) ==
  a:= postTran a
  b is ['Sequence,:.] => [['elt,a,'makeRecord],:postTranList rest b]
  ['elt,a,postTran b]

postExit ["=>",a,b] == ['IF,postTran a,['exit,postTran b],'noBranch]


postFlatten(x,op) ==
  x is [ =op,a,b] => [:postFlatten(a,op),:postFlatten(b,op)]
  LIST x

postForm (u is [op,:argl]) ==
  x:=
    atom op =>
      argl':= postTranList argl
      op':=
        true=> op
        $BOOT => op
        GET(op,'Led) or GET(op,'Nud) or op = 'IN => op
        numOfArgs:= (argl' is [['Tuple,:l]] => #l; 1)
        INTERNL("*",STRINGIMAGE numOfArgs,PNAME op)
      [op',:argl']
    op is ['Scripts,:.] => [:postTran op,:postTranList argl]
    u:= postTranList u
    if u is [['Tuple,:.],:.] then
      postError ['"  ",:bright u,
        '"is illegal because tuples cannot be applied!",'%l,
          '"   Did you misuse infix dot?"]
    u
  x is [.,['Tuple,:y]] => [first x,:y]
  x

postQuote [.,a] == ['QUOTE,a]

postScriptsForm(['Scripts,op,a],argl) ==
  [getScriptName(op,a,#argl),:postTranScripts a,:argl]

postScripts ['Scripts,op,a] ==
  [getScriptName(op,a,0),:postTranScripts a]

getScriptName(op,a,numberOfFunctionalArgs) ==
  if null IDENTP op then
    postError ['"   ",op,'" cannot have scripts"]
  INTERNL("*",STRINGIMAGE numberOfFunctionalArgs,
    decodeScripts a,PNAME op)

postTranScripts a ==
  a is ['PrefixSC,b] => postTranScripts b
  a is [";",:b] => "append"/[postTranScripts y for y in b]
  a is [",",:b] =>
    ("append"/[fn postTran y for y in b]) where
      fn x ==
        x is ['Tuple,:y] => y
        LIST x
  LIST postTran a

decodeScripts a ==
  a is ['PrefixSC,b] => STRCONC(STRINGIMAGE 0,decodeScripts b)
  a is [";",:b] => APPLX('STRCONC,[decodeScripts x for x in b])
  a is [",",:b] =>
    STRINGIMAGE fn a where fn a == (a is [",",:b] => +/[fn x for x in b]; 1)
  STRINGIMAGE 1

postIf t ==
  t isnt ['if,:l] => t
  ['IF,:[(null (x:= postTran x) and null $BOOT => 'noBranch; x)
    for x in l]]

postJoin ['Join,a,:l] ==
  a:= postTran a
  l:= postTranList l
  if l is [b] and b is [name,:.] and MEMQ(name,'(ATTRIBUTE SIGNATURE)) then l
    := LIST ['CATEGORY,b]
  al:=
    a is ['Tuple,:c] => c
    LIST a
  ['Join,:al,:l]

postMapping u  ==
  u isnt ["->",source,target] => u
  ['Mapping,postTran target,:unTuple postTran source]

postOp x ==
  x=":=" =>
    $BOOT => 'SPADLET
    'LET
  x=":-" => 'LETD
  x='Attribute => 'ATTRIBUTE
  x

postRepeat ['REPEAT,:m,x] == ['REPEAT,:postIteratorList m,postTran x]

postSEGMENT ['SEGMENT,a,b] ==
  key:= [a,'"..",:(b => [b]; nil)]
  postError ['"   Improper placement of segment",:bright key]

postCollect [constructOp,:m,x] ==
  x is [['elt,D,'construct],:y] =>
    postCollect [['elt,D,'COLLECT],:m,['construct,:y]]
  itl:= postIteratorList m
  x:= (x is ['construct,r] => r; x)  --added 84/8/31
  y:= postTran x
  finish(constructOp,itl,y) where
    finish(op,itl,y) ==
      y is [":",a] => ['REDUCE,'append,0,[op,:itl,a]]
      y is ['Tuple,:l] =>
        newBody:=
          or/[x is [":",y] for x in l] => postMakeCons l
          or/[x is ['SEGMENT,:.] for x in l] => tuple2List l
          ['construct,:postTranList l]
        ['REDUCE,'append,0,[op,:itl,newBody]]
      [op,:itl,y]

postTupleCollect [constructOp,:m,x] ==
  postCollect [constructOp,:m,['construct,x]]

postIteratorList x ==
  x is [p,:l] =>
    (p:= postTran p) is ['IN,y,u] =>
      u is ["|",a,b] => [['IN,y,postInSeq a],["|",b],:postIteratorList l]
      [['IN,y,postInSeq u],:postIteratorList l]
    [p,:postIteratorList l]
  x

postin arg ==
  arg isnt ['in,i,seq] => systemErrorHere '"postin"
  ['in,postTran i, postInSeq seq]

postIn arg ==
  arg isnt ['IN,i,seq] => systemErrorHere '"postIn"
  ['IN,postTran i,postInSeq seq]

postInSeq seq ==
  seq is ['SEGMENT,p,q] => postTranSegment(p,q)
  seq is ['Tuple,:l] => tuple2List l
  postTran seq

postTranSegment(p,q) == ['SEGMENT,postTran p,(q => postTran q; nil)]

tuple2List l ==
  l is [a,:l'] =>
    u:= tuple2List l'
    a is ['SEGMENT,p,q] =>
      null u => ['construct,postTranSegment(p,q)]
      $InteractiveMode and null $BOOT =>
        ['append,['construct,postTranSegment(p,q)],tuple2List l']
      ["nconc",['construct,postTranSegment(p,q)],tuple2List l']
    null u => ['construct,postTran a]
    ["cons",postTran a,tuple2List l']
  nil

SEGMENT(a,b) == [i for i in a..b]

postReduce ['Reduce,op,expr] ==
  $InteractiveMode or expr is ['COLLECT,:.] =>
    ['REDUCE,op,0,postTran expr]
  postReduce ['Reduce,op,['COLLECT,['IN,g:= GENSYM(),expr],
    ['construct,  g]]]

postFlattenLeft(x,op) ==--
  x is [ =op,a,b] => [:postFlattenLeft(a,op),b]
  [x]

postSemiColon u == postBlock ['Block,:postFlattenLeft(u,";")]

postSequence ['Sequence,:l] == ['(elt $ makeRecord),:postTranList l]

--------------------> NEW DEFINITION (see br-saturn.boot.pamphlet)
postSignature ['Signature,op,sig] ==
  sig is ["->",:.] =>
    sig1:= postType sig
    op:= postAtom (STRINGP op => INTERN op; op)
    ["SIGNATURE",op,:removeSuperfluousMapping killColons sig1]

killColons x ==
  atom x => x
  x is ['Record,:.] => x
  x is ['Union,:.] => x
  x is [":",.,y] => killColons y
  [killColons first x,:killColons rest x]

postSlash ['_/,a,b] ==
  STRINGP a => postTran ['Reduce,INTERN a,b]
  ['_/,postTran a,postTran b]

removeSuperfluousMapping sig1 ==
  --get rid of this asap
  sig1 is [x,:y] and x is ['Mapping,:.] => [rest x,:y]
  sig1

postType typ ==
  typ is ["->",source,target] =>
    source="constant" => [LIST postTran target,"constant"]
    LIST ['Mapping,postTran target,:unTuple postTran source]
  typ is ["->",target] => LIST ['Mapping,postTran target]
  LIST postTran typ

postTuple u ==
  u is ['Tuple] => u
  u is ['Tuple,:l,a] => (['Tuple,:postTranList rest u])
--u is ['Tuple,:l,a] => (--a:= postTran a; ['Tuple,:postTranList rest u])
    --RDJ: don't understand need for above statement that is commented out

postWhere ['where,a,b] ==
  x:=
    b is ['Block,:c] => c
    LIST b
  ['where,postTran a,:postTranList x]

postWith ['with,a] ==
  $insidePostCategoryIfTrue: local := true
  a:= postTran a
  a is [op,:.] and MEMQ(op,'(SIGNATURE ATTRIBUTE IF)) => ['CATEGORY,a]
  a is ['PROGN,:b] => ['CATEGORY,:b]
  a

postTransformCheck x ==
  $defOp: local:= nil
  postcheck x

postcheck x ==
  atom x => nil
  x is ['DEF,form,[target,:.],:.] =>
    (setDefOp form; postcheckTarget target; postcheck rest rest x)
  x is ['QUOTE,:.] => nil
  postcheck first x
  postcheck rest x

setDefOp f ==
  if f is [":",g,:.] then f := g
  f := (atom f => f; first f)
  if $topOp then $defOp:= f else $topOp:= f

postcheckTarget x ==
  -- doesn't seem that useful!
  isPackageType x => nil
  x is ['Join,:.] => nil
  NIL

isPackageType x == not CONTAINED("$",x)

unTuple x ==
  x is ['Tuple,:y] => y
  LIST x

--% APL TRANSFORMATION OF INPUT

aplTran x ==
  $BOOT => x
  $GENNO: local := 0
  u:= aplTran1 x
  containsBang u => throwKeyedMsg("S2IP0002",NIL)
  u

containsBang u ==
  atom u => EQ(u,"!")
  u is [='QUOTE,.] => false
  or/[containsBang x for x in u]

aplTran1 x ==
  atom x => x
  [op,:argl1] := x
  argl := aplTranList argl1
  -- unary case f ! y
  op = "_!" =>
    argl is [f,y] =>
      y is [op',:y'] and op' = "_!" => aplTran1 [op,op,f,:y']
      $BOOT => ['COLLECT,['IN,g:=GENVAR(),aplTran1 y],[f,g]]
      ['map,f,aplTran1 y]
    x    --do not handle yet
  -- multiple argument case
  hasAplExtension argl is [arglAssoc,:futureArgl] =>
    -- choose the last aggregate type to be result of reshape
    ['reshape,['COLLECT,:[['IN,g,['ravel,a]] for [g,:a] in arglAssoc],
      aplTran1 [op,:futureArgl]],CDAR arglAssoc]
  [op,:argl]

aplTranList x ==
  atom x => x
  [aplTran1 first x,:aplTranList rest x]

hasAplExtension argl ==
  or/[x is ["_!",:.] for x in argl] =>
    u:= [futureArg for x in argl] where futureArg ==
      x is ["_!",y] =>
        z:= deepestExpression y
        arglAssoc := [[g := GENVAR(),:aplTran1 z],:arglAssoc]
        substitute(g,z,y)
      x
    [arglAssoc,:u]
  nil

deepestExpression x ==
  x is ["_!",y] => deepestExpression y
  x
@
\section{postpar.clisp}
<<postpar.clisp>>=

(IN-PACKAGE "BOOT" )

;--% Yet Another Parser Transformation File
;--These functions are used by for BOOT and SPAD code
;--(see new2OldLisp, e.g.)
;postTransform y ==
;  x:= y
;  u:= postTran x
;  if u is ['Tuple,:l,[":",y,t]] and (and/[IDENTP x for x in l]) then u:=
;    [":",['LISTOF,:l,y],t]
;  postTransformCheck u
;  aplTran u

;;;     ***       |postTransform| REDEFINED

(DEFUN |postTransform| (|y|) (PROG (|x| |ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |ISTMP#5| |t| |l| |u|) (RETURN (SEQ (PROGN (SPADLET |x| |y|) (SPADLET |u| (|postTran| |x|)) (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |Tuple|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (PROGN (SPADLET |y| (QCAR |ISTMP#4|)) (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQ (QCDR |ISTMP#5|) NIL) (PROGN (SPADLET |t| (QCAR |ISTMP#5|)) (QUOTE T)))))))) (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) (QUOTE T)) (PROGN (SPADLET |l| (NREVERSE |l|)) (QUOTE T)))) (PROG (#0=#:G2336) (SPADLET #0# (QUOTE T)) (RETURN (DO ((#1=#:G2342 NIL (NULL #0#)) (#2=#:G2343 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (AND #0# (IDENTP |x|))))))))) (SPADLET |u| (CONS (QUOTE |:|) (CONS (CONS (QUOTE LISTOF) (APPEND |l| (CONS |y| NIL))) (CONS |t| NIL)))))) (|postTransformCheck| |u|) (|aplTran| |u|)))))) 
;displayPreCompilationErrors() ==
;  n:= #($postStack:= REMDUP NREVERSE $postStack)
;  n=0 => nil
;  errors:=
;    1<n => '"errors"
;    '"error"
;  if $InteractiveMode
;    then sayBrightly ['"   Semantic ",errors,'" detected: "]
;    else
;      heading:=
;        $topOp ^= '$topOp => ['"   ",$topOp,'" has"]
;        ['"   You have"]
;      sayBrightly [:heading,'%b,n,'%d,'"precompilation ",errors,'":"]
;  if 1<n then
;    (for x in $postStack for i in 1.. repeat sayMath ['"   ",i,'"_) ",:x])
;    else sayMath ['"    ",:first $postStack]
;  TERPRI()

;;;     ***       |displayPreCompilationErrors| REDEFINED

(DEFUN |displayPreCompilationErrors| NIL (PROG (|n| |errors| |heading|) (RETURN (SEQ (PROGN (SPADLET |n| (|#| (SPADLET |$postStack| (REMDUP (NREVERSE |$postStack|))))) (COND ((EQL |n| 0) NIL) ((QUOTE T) (SPADLET |errors| (COND ((> |n| 1) (MAKESTRING "errors")) ((QUOTE T) (MAKESTRING "error")))) (COND (|$InteractiveMode| (|sayBrightly| (CONS (MAKESTRING "   Semantic ") (CONS |errors| (CONS (MAKESTRING " detected: ") NIL))))) ((QUOTE T) (SPADLET |heading| (COND ((NEQUAL |$topOp| (QUOTE |$topOp|)) (CONS (MAKESTRING "   ") (CONS |$topOp| (CONS (MAKESTRING " has") NIL)))) ((QUOTE T) (CONS (MAKESTRING "   You have") NIL)))) (|sayBrightly| (APPEND |heading| (CONS (QUOTE |%b|) (CONS |n| (CONS (QUOTE |%d|) (CONS (MAKESTRING "precompilation ") (CONS |errors| (CONS (MAKESTRING ":") NIL)))))))))) (COND ((> |n| 1) (DO ((#0=#:G2374 |$postStack| (CDR #0#)) (|x| NIL) (|i| 1 (QSADD1 |i|))) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (|sayMath| (CONS (MAKESTRING "   ") (CONS |i| (CONS (MAKESTRING ") ") |x|)))))))) ((QUOTE T) (|sayMath| (CONS (MAKESTRING "    ") (CAR |$postStack|))))) (TERPRI)))))))) 
;postTran x ==
;  atom x =>
;    postAtom x
;  op := first x
;  atom op and (f:= GET(op,'postTran)) => FUNCALL(f,x)
;  op is ['elt,a,b] =>
;    u:= postTran [b,:rest x]
;    [postTran op,:rest u]
;  op is ['Scripts,:.] =>
;    postScriptsForm(op,"append"/[unTuple postTran y for y in rest x])
;  op^=(y:= postOp op) => [y,:postTranList rest x]
;  postForm x

;;;     ***       |postTran| REDEFINED

(DEFUN |postTran| (|x|) (PROG (|op| |f| |ISTMP#1| |a| |ISTMP#2| |b| |u| |y|) (RETURN (SEQ (COND ((ATOM |x|) (|postAtom| |x|)) ((QUOTE T) (SPADLET |op| (CAR |x|)) (COND ((AND (ATOM |op|) (SPADLET |f| (GETL |op| (QUOTE |postTran|)))) (FUNCALL |f| |x|)) ((AND (PAIRP |op|) (EQ (QCAR |op|) (QUOTE |elt|)) (PROGN (SPADLET |ISTMP#1| (QCDR |op|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (SPADLET |u| (|postTran| (CONS |b| (CDR |x|)))) (CONS (|postTran| |op|) (CDR |u|))) ((AND (PAIRP |op|) (EQ (QCAR |op|) (QUOTE |Scripts|))) (|postScriptsForm| |op| (PROG (#0=#:G2405) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2410 (CDR |x|) (CDR #1#)) (|y| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (APPEND #0# (|unTuple| (|postTran| |y|))))))))))) ((NEQUAL |op| (SPADLET |y| (|postOp| |op|))) (CONS |y| (|postTranList| (CDR |x|)))) ((QUOTE T) (|postForm| |x|))))))))) 
;postTranList x == [postTran y for y in x]

;;;     ***       |postTranList| REDEFINED

(DEFUN |postTranList| (|x|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G2432) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2437 |x| (CDR #1#)) (|y| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|postTran| |y|) #0#))))))))))) 
;postBigFloat x ==
;  [.,mant,:expon] := x
;  $BOOT => INT2RNUM(mant) * INT2RNUM(10) ** expon
;  eltword := if $InteractiveMode then "$elt" else 'elt
;  postTran [[eltword,'(Float),'float],[",",[",",mant,expon],10]]

;;;     ***       |postBigFloat| REDEFINED

(DEFUN |postBigFloat| (|x|) (PROG (|mant| |expon| |eltword|) (RETURN (PROGN (SPADLET |mant| (CADR |x|)) (SPADLET |expon| (CDDR |x|)) (COND ($BOOT (TIMES (INT2RNUM |mant|) (EXPT (INT2RNUM 10) |expon|))) ((QUOTE T) (SPADLET |eltword| (COND (|$InteractiveMode| (QUOTE |$elt|)) ((QUOTE T) (QUOTE |elt|)))) (|postTran| (CONS (CONS |eltword| (CONS (QUOTE (|Float|)) (CONS (QUOTE |float|) NIL))) (CONS (CONS (QUOTE |,|) (CONS (CONS (QUOTE |,|) (CONS |mant| (CONS |expon| NIL))) (CONS 10 NIL))) NIL))))))))) 
;postAdd ['add,a,:b] ==
;  null b => postCapsule a
;  ['add,postTran a,postCapsule first b]

;;;     ***       |postAdd| REDEFINED

(DEFUN |postAdd| (#0=#:G2458) (PROG (|a| |b|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |b| (CDDR #0#)) (COND ((NULL |b|) (|postCapsule| |a|)) ((QUOTE T) (CONS (QUOTE |add|) (CONS (|postTran| |a|) (CONS (|postCapsule| (CAR |b|)) NIL))))))))) 
;checkWarning msg == postError concat('"Parsing error: ",msg)

(DEFUN |checkWarning| (|msg|) (|postError| (|concat| (MAKESTRING "Parsing error: ") |msg|))) 
;
;checkWarningIndentation() ==
;  checkWarning ['"Apparent indentation error following",:bright "add"]

(DEFUN |checkWarningIndentation| NIL (|checkWarning| (CONS (MAKESTRING "Apparent indentation error following") (|bright| (QUOTE |add|))))) 
;postCapsule x ==
;  x isnt [op,:.] => checkWarningIndentation()
;  INTEGERP op or op = "==" => ['CAPSULE,postBlockItem x]
;  op = ";" => ['CAPSULE,:postBlockItemList postFlatten(x,";")]
;  op = "if" => ['CAPSULE,postBlockItem x]
;  checkWarningIndentation()

;;;     ***       |postCapsule| REDEFINED

(DEFUN |postCapsule| (|x|) (PROG (|op|) (RETURN (COND ((NULL (AND (PAIRP |x|) (PROGN (SPADLET |op| (QCAR |x|)) (QUOTE T)))) (|checkWarningIndentation|)) ((OR (INTEGERP |op|) (BOOT-EQUAL |op| (QUOTE ==))) (CONS (QUOTE CAPSULE) (CONS (|postBlockItem| |x|) NIL))) ((BOOT-EQUAL |op| (QUOTE |;|)) (CONS (QUOTE CAPSULE) (|postBlockItemList| (|postFlatten| |x| (QUOTE |;|))))) ((BOOT-EQUAL |op| (QUOTE |if|)) (CONS (QUOTE CAPSULE) (CONS (|postBlockItem| |x|) NIL))) ((QUOTE T) (|checkWarningIndentation|)))))) 
;postQUOTE x == x

;;;     ***       |postQUOTE| REDEFINED

(DEFUN |postQUOTE| (|x|) |x|) 
;postColon u ==
;  u is [":",x] => [":",postTran x]
;  u is [":",x,y] => [":",postTran x,:postType y]

;;;     ***       |postColon| REDEFINED

(DEFUN |postColon| (|u|) (PROG (|ISTMP#1| |x| |ISTMP#2| |y|) (RETURN (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (QUOTE T))))) (CONS (QUOTE |:|) (CONS (|postTran| |x|) NIL))) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |x| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (CONS (QUOTE |:|) (CONS (|postTran| |x|) (|postType| |y|)))))))) 
;postColonColon u ==
;  -- for Lisp package calling
;  -- boot syntax is package::fun but probably need to parenthesize it
;  $BOOT and u is ["::",package,fun] =>
;    INTERN(STRINGIMAGE fun, package)
;  postForm u

;;;     ***       |postColonColon| REDEFINED

(DEFUN |postColonColon| (|u|) (PROG (|ISTMP#1| |package| |ISTMP#2| |fun|) (RETURN (COND ((AND $BOOT (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |::|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |package| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fun| (QCAR |ISTMP#2|)) (QUOTE T))))))) (INTERN (STRINGIMAGE |fun|) |package|)) ((QUOTE T) (|postForm| |u|)))))) 
;postAtSign ["@",x,y] == ["@",postTran x,:postType y]

;;;     ***       |postAtSign| REDEFINED

(DEFUN |postAtSign| (#0=#:G2540) (PROG (|x| |y|) (RETURN (PROGN (COND ((EQ (CAR #0#) (QUOTE @)) (CAR #0#))) (SPADLET |x| (CADR #0#)) (SPADLET |y| (CADDR #0#)) (CONS (QUOTE @) (CONS (|postTran| |x|) (|postType| |y|))))))) 
;postPretend ['pretend,x,y] == ['pretend,postTran x,:postType y]

;;;     ***       |postPretend| REDEFINED

(DEFUN |postPretend| (#0=#:G2556) (PROG (|x| |y|) (RETURN (PROGN (SPADLET |x| (CADR #0#)) (SPADLET |y| (CADDR #0#)) (CONS (QUOTE |pretend|) (CONS (|postTran| |x|) (|postType| |y|))))))) 
;postConstruct u ==
;  u is ['construct,b] =>
;    a:= (b is [",",:.] => comma2Tuple b; b)
;    a is ['SEGMENT,p,q] => ['construct,postTranSegment(p,q)]
;    a is ['Tuple,:l] =>
;      or/[x is [":",y] for x in l] => postMakeCons l
;      or/[x is ['SEGMENT,:.] for x in l] => tuple2List l
;      ['construct,:postTranList l]
;    ['construct,postTran a]
;  u

;;;     ***       |postConstruct| REDEFINED

(DEFUN |postConstruct| (|u|) (PROG (|b| |a| |p| |ISTMP#2| |q| |l| |ISTMP#1| |y|) (RETURN (SEQ (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |construct|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) (QUOTE T))))) (SPADLET |a| (COND ((AND (PAIRP |b|) (EQ (QCAR |b|) (QUOTE |,|))) (|comma2Tuple| |b|)) ((QUOTE T) |b|))) (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE SEGMENT)) (PROGN (SPADLET |ISTMP#1| (QCDR |a|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#2|)) (QUOTE T))))))) (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL))) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |Tuple|)) (PROGN (SPADLET |l| (QCDR |a|)) (QUOTE T))) (COND ((PROG (#0=#:G2598) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2608 NIL #0#) (#2=#:G2609 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (OR #0# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T)))))))))))) (|postMakeCons| |l|)) ((PROG (#3=#:G2616) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G2622 NIL #3#) (#5=#:G2623 |l| (CDR #5#)) (|x| NIL)) ((OR #4# (ATOM #5#) (PROGN (SETQ |x| (CAR #5#)) NIL)) #3#) (SEQ (EXIT (SETQ #3# (OR #3# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE SEGMENT)))))))))) (|tuple2List| |l|)) ((QUOTE T) (CONS (QUOTE |construct|) (|postTranList| |l|))))) ((QUOTE T) (CONS (QUOTE |construct|) (CONS (|postTran| |a|) NIL))))) ((QUOTE T) |u|)))))) 
;postError msg ==
;  BUMPERRORCOUNT 'precompilation
;  xmsg:=
;    $defOp ^= '$defOp and not InteractiveMode => [$defOp,'": ",:msg]
;    msg
;  $postStack:= [xmsg,:$postStack]
;  nil

;;;     ***       |postError| REDEFINED

(DEFUN |postError| (|msg|) (PROG (|xmsg|) (RETURN (PROGN (BUMPERRORCOUNT (QUOTE |precompilation|)) (SPADLET |xmsg| (COND ((AND (NEQUAL |$defOp| (QUOTE |$defOp|)) (NULL |InteractiveMode|)) (CONS |$defOp| (CONS (MAKESTRING ": ") |msg|))) ((QUOTE T) |msg|))) (SPADLET |$postStack| (CONS |xmsg| |$postStack|)) NIL)))) 
;postMakeCons l ==
;  null l => 'nil
;  l is [[":",a],:l'] =>
;    l' => ['append,postTran a,postMakeCons l']
;    postTran a
;  ['cons,postTran first l,postMakeCons rest l]

;;;     ***       |postMakeCons| REDEFINED

(DEFUN |postMakeCons| (|l|) (PROG (|ISTMP#1| |ISTMP#2| |a| |l'|) (RETURN (COND ((NULL |l|) (QUOTE |nil|)) ((AND (PAIRP |l|) (PROGN (SPADLET |ISTMP#1| (QCAR |l|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |a| (QCAR |ISTMP#2|)) (QUOTE T)))))) (PROGN (SPADLET |l'| (QCDR |l|)) (QUOTE T))) (COND (|l'| (CONS (QUOTE |append|) (CONS (|postTran| |a|) (CONS (|postMakeCons| |l'|) NIL)))) ((QUOTE T) (|postTran| |a|)))) ((QUOTE T) (CONS (QUOTE |cons|) (CONS (|postTran| (CAR |l|)) (CONS (|postMakeCons| (CDR |l|)) NIL)))))))) 
;postAtom x ==
;  $BOOT => x
;  x=0 => '(Zero)
;  x=1 => '(One)
;  EQ(x,'T) => 'T_$ -- rename T in spad code to T$
;  IDENTP x and GETDATABASE(x,'NILADIC) => LIST x
;  x

;;;     ***       |postAtom| REDEFINED

(DEFUN |postAtom| (|x|) (COND ($BOOT |x|) ((EQL |x| 0) (QUOTE (|Zero|))) ((EQL |x| 1) (QUOTE (|One|))) ((EQ |x| (QUOTE T)) (QUOTE T$)) ((AND (IDENTP |x|) (GETDATABASE |x| (QUOTE NILADIC))) (LIST |x|)) ((QUOTE T) |x|))) 
;postBlock ['Block,:l,x] ==
;  ['SEQ,:postBlockItemList l,['exit,postTran x]]

;;;     ***       |postBlock| REDEFINED

(DEFUN |postBlock| (#0=#:G2675) (PROG (|LETTMP#1| |x| |l|) (RETURN (PROGN (SPADLET |LETTMP#1| (REVERSE (CDR #0#))) (SPADLET |x| (CAR |LETTMP#1|)) (SPADLET |l| (NREVERSE (CDR |LETTMP#1|))) (CONS (QUOTE SEQ) (APPEND (|postBlockItemList| |l|) (CONS (CONS (QUOTE |exit|) (CONS (|postTran| |x|) NIL)) NIL))))))) 
;postBlockItemList l == [postBlockItem x for x in l]

;;;     ***       |postBlockItemList| REDEFINED

(DEFUN |postBlockItemList| (|l|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G2696) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2701 |l| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|postBlockItem| |x|) #0#))))))))))) 
;postBlockItem x ==
;  x:= postTran x
;  x is ['Tuple,:l,[":",y,t]] and (and/[IDENTP x for x in l]) =>
;    [":",['LISTOF,:l,y],t]
;  x

;;;     ***       |postBlockItem| REDEFINED

(DEFUN |postBlockItem| (|x|) (PROG (|ISTMP#1| |ISTMP#2| |ISTMP#3| |ISTMP#4| |y| |ISTMP#5| |t| |l|) (RETURN (SEQ (PROGN (SPADLET |x| (|postTran| |x|)) (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Tuple|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCAR |ISTMP#3|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#4| (QCDR |ISTMP#3|)) (AND (PAIRP |ISTMP#4|) (PROGN (SPADLET |y| (QCAR |ISTMP#4|)) (SPADLET |ISTMP#5| (QCDR |ISTMP#4|)) (AND (PAIRP |ISTMP#5|) (EQ (QCDR |ISTMP#5|) NIL) (PROGN (SPADLET |t| (QCAR |ISTMP#5|)) (QUOTE T)))))))) (PROGN (SPADLET |l| (QCDR |ISTMP#2|)) (QUOTE T)) (PROGN (SPADLET |l| (NREVERSE |l|)) (QUOTE T)))) (PROG (#0=#:G2754) (SPADLET #0# (QUOTE T)) (RETURN (DO ((#1=#:G2760 NIL (NULL #0#)) (#2=#:G2761 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (AND #0# (IDENTP |x|))))))))) (CONS (QUOTE |:|) (CONS (CONS (QUOTE LISTOF) (APPEND |l| (CONS |y| NIL))) (CONS |t| NIL)))) ((QUOTE T) |x|))))))) 
;postCategory (u is ['CATEGORY,:l]) ==
;  --RDJ: ugh_ please -- someone take away need for PROGN as soon as possible
;  null l => u
;  op :=
;    $insidePostCategoryIfTrue = true => 'PROGN
;    'CATEGORY
;  [op,:[fn x for x in l]] where fn x ==
;    $insidePostCategoryIfTrue: local := true
;    postTran x

;;;     ***       |postCategory,fn| REDEFINED

(DEFUN |postCategory,fn| (|x|) (PROG (|$insidePostCategoryIfTrue|) (DECLARE (SPECIAL |$insidePostCategoryIfTrue|)) (RETURN (SEQ (SPADLET |$insidePostCategoryIfTrue| (QUOTE T)) (EXIT (|postTran| |x|)))))) 

;;;     ***       |postCategory| REDEFINED

(DEFUN |postCategory| (|u|) (PROG (|l| |op|) (RETURN (SEQ (PROGN (SPADLET |l| (CDR |u|)) (COND ((NULL |l|) |u|) ((QUOTE T) (SPADLET |op| (COND ((BOOT-EQUAL |$insidePostCategoryIfTrue| (QUOTE T)) (QUOTE PROGN)) ((QUOTE T) (QUOTE CATEGORY)))) (CONS |op| (PROG (#0=#:G2802) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2807 |l| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|postCategory,fn| |x|) #0#))))))))))))))) 
;postComma u == postTuple comma2Tuple u

;;;     ***       |postComma| REDEFINED

(DEFUN |postComma| (|u|) (|postTuple| (|comma2Tuple| |u|))) 
;comma2Tuple u == ['Tuple,:postFlatten(u,",")]

;;;     ***       |comma2Tuple| REDEFINED

(DEFUN |comma2Tuple| (|u|) (CONS (QUOTE |Tuple|) (|postFlatten| |u| (QUOTE |,|)))) 
;postDef [defOp,lhs,rhs] ==
;--+
;  lhs is ["macro",name] => postMDef ["==>",name,rhs]
;  if not($BOOT) then recordHeaderDocumentation nil
;  if $maxSignatureLineNumber ^= 0 then
;    $docList := [['constructor,:$headerDocumentation],:$docList]
;    $maxSignatureLineNumber := 0
;    --reset this for next constructor; see recordDocumentation
;  lhs:= postTran lhs
;  [form,targetType]:=
;    lhs is [":",:.] => rest lhs
;    [lhs,nil]
;  if null $InteractiveMode and atom form then form := LIST form
;  newLhs:=
;    atom form => form
;    [op,:argl]:= [(x is [":",a,.] => a; x) for x in form]
;    [op,:postDefArgs argl]
;  argTypeList:=
;    atom form => nil
;    [(x is [":",.,t] => t; nil) for x in rest form]
;  typeList:= [targetType,:argTypeList]
;  if atom form then form := [form]
;  specialCaseForm := [nil for x in form]
;  ['DEF,newLhs,typeList,specialCaseForm,postTran rhs]

;;;     ***       |postDef| REDEFINED

(DEFUN |postDef| (#0=#:G2875) (PROG (|defOp| |rhs| |name| |lhs| |targetType| |a| |LETTMP#1| |op| |argl| |newLhs| |ISTMP#1| |ISTMP#2| |t| |argTypeList| |typeList| |form| |specialCaseForm|) (RETURN (SEQ (PROGN (SPADLET |defOp| (CAR #0#)) (SPADLET |lhs| (CADR #0#)) (SPADLET |rhs| (CADDR #0#)) (COND ((AND (PAIRP |lhs|) (EQ (QCAR |lhs|) (QUOTE |macro|)) (PROGN (SPADLET |ISTMP#1| (QCDR |lhs|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |name| (QCAR |ISTMP#1|)) (QUOTE T))))) (|postMDef| (CONS (QUOTE ==>) (CONS |name| (CONS |rhs| NIL))))) ((QUOTE T) (COND ((NULL $BOOT) (|recordHeaderDocumentation| NIL))) (COND ((NEQUAL |$maxSignatureLineNumber| 0) (SPADLET |$docList| (CONS (CONS (QUOTE |constructor|) |$headerDocumentation|) |$docList|)) (SPADLET |$maxSignatureLineNumber| 0))) (SPADLET |lhs| (|postTran| |lhs|)) (SPADLET |LETTMP#1| (COND ((AND (PAIRP |lhs|) (EQ (QCAR |lhs|) (QUOTE |:|))) (CDR |lhs|)) ((QUOTE T) (CONS |lhs| (CONS NIL NIL))))) (SPADLET |form| (CAR |LETTMP#1|)) (SPADLET |targetType| (CADR |LETTMP#1|)) (COND ((AND (NULL |$InteractiveMode|) (ATOM |form|)) (SPADLET |form| (LIST |form|)))) (SPADLET |newLhs| (COND ((ATOM |form|) |form|) ((QUOTE T) (SPADLET |LETTMP#1| (PROG (#1=#:G2918) (SPADLET #1# NIL) (RETURN (DO ((#2=#:G2928 |form| (CDR #2#)) (|x| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) (NREVERSE0 #1#)) (SEQ (EXIT (SETQ #1# (CONS (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL)))))) |a|) ((QUOTE T) |x|)) #1#)))))))) (SPADLET |op| (CAR |LETTMP#1|)) (SPADLET |argl| (CDR |LETTMP#1|)) (CONS |op| (|postDefArgs| |argl|))))) (SPADLET |argTypeList| (COND ((ATOM |form|) NIL) ((QUOTE T) (PROG (#3=#:G2944) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G2955 (CDR |form|) (CDR #4#)) (|x| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |x| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |t| (QCAR |ISTMP#2|)) (QUOTE T))))))) |t|) ((QUOTE T) NIL)) #3#)))))))))) (SPADLET |typeList| (CONS |targetType| |argTypeList|)) (COND ((ATOM |form|) (SPADLET |form| (CONS |form| NIL)))) (SPADLET |specialCaseForm| (PROG (#5=#:G2965) (SPADLET #5# NIL) (RETURN (DO ((#6=#:G2970 |form| (CDR #6#)) (|x| NIL)) ((OR (ATOM #6#) (PROGN (SETQ |x| (CAR #6#)) NIL)) (NREVERSE0 #5#)) (SEQ (EXIT (SETQ #5# (CONS NIL #5#)))))))) (CONS (QUOTE DEF) (CONS |newLhs| (CONS |typeList| (CONS |specialCaseForm| (CONS (|postTran| |rhs|) NIL)))))))))))) 
;postDefArgs argl ==
;  null argl => argl
;  argl is [[":",a],:b] =>
;    b => postError
;      ['"   Argument",:bright a,'"of indefinite length must be last"]
;    atom a or a is ['QUOTE,:.] => a
;    postError
;      ['"   Argument",:bright a,'"of indefinite length must be a name"]
;  [first argl,:postDefArgs rest argl]

;;;     ***       |postDefArgs| REDEFINED

(DEFUN |postDefArgs| (|argl|) (PROG (|ISTMP#1| |ISTMP#2| |a| |b|) (RETURN (COND ((NULL |argl|) |argl|) ((AND (PAIRP |argl|) (PROGN (SPADLET |ISTMP#1| (QCAR |argl|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |a| (QCAR |ISTMP#2|)) (QUOTE T)))))) (PROGN (SPADLET |b| (QCDR |argl|)) (QUOTE T))) (COND (|b| (|postError| (CONS (MAKESTRING "   Argument") (APPEND (|bright| |a|) (CONS (MAKESTRING "of indefinite length must be last") NIL))))) ((OR (ATOM |a|) (AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE QUOTE)))) |a|) ((QUOTE T) (|postError| (CONS (MAKESTRING "   Argument") (APPEND (|bright| |a|) (CONS (MAKESTRING "of indefinite length must be a name") NIL))))))) ((QUOTE T) (CONS (CAR |argl|) (|postDefArgs| (CDR |argl|)))))))) 
;postMDef(t) ==
;  [.,lhs,rhs] := t
;  $InteractiveMode and not $BOOT =>
;    lhs := postTran lhs
;    null IDENTP lhs => throwKeyedMsg("S2IP0001",NIL)
;    ['MDEF,lhs,NIL,NIL,postTran rhs]
;  lhs:= postTran lhs
;  [form,targetType]:=
;    lhs is [":",:.] => rest lhs
;    [lhs,nil]
;  form:=
;    atom form => LIST form
;    form
;  newLhs:= [(x is [":",a,:.] => a; x) for x in form]
;  typeList:= [targetType,:[(x is [":",.,t] => t; nil) for x in rest form]]
;  ['MDEF,newLhs,typeList,[nil for x in form],postTran rhs]

;;;     ***       |postMDef| REDEFINED

(DEFUN |postMDef| (|t|) (PROG (|rhs| |lhs| |LETTMP#1| |targetType| |form| |a| |newLhs| |ISTMP#1| |ISTMP#2| |typeList|) (RETURN (SEQ (PROGN (SPADLET |lhs| (CADR |t|)) (SPADLET |rhs| (CADDR |t|)) (COND ((AND |$InteractiveMode| (NULL $BOOT)) (SPADLET |lhs| (|postTran| |lhs|)) (COND ((NULL (IDENTP |lhs|)) (|throwKeyedMsg| (QUOTE S2IP0001) NIL)) ((QUOTE T) (CONS (QUOTE MDEF) (CONS |lhs| (CONS NIL (CONS NIL (CONS (|postTran| |rhs|) NIL)))))))) ((QUOTE T) (SPADLET |lhs| (|postTran| |lhs|)) (SPADLET |LETTMP#1| (COND ((AND (PAIRP |lhs|) (EQ (QCAR |lhs|) (QUOTE |:|))) (CDR |lhs|)) ((QUOTE T) (CONS |lhs| (CONS NIL NIL))))) (SPADLET |form| (CAR |LETTMP#1|)) (SPADLET |targetType| (CADR |LETTMP#1|)) (SPADLET |form| (COND ((ATOM |form|) (LIST |form|)) ((QUOTE T) |form|))) (SPADLET |newLhs| (PROG (#0=#:G3065) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G3074 |form| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (QUOTE T))))) |a|) ((QUOTE T) |x|)) #0#)))))))) (SPADLET |typeList| (CONS |targetType| (PROG (#2=#:G3090) (SPADLET #2# NIL) (RETURN (DO ((#3=#:G3101 (CDR |form|) (CDR #3#)) (|x| NIL)) ((OR (ATOM #3#) (PROGN (SETQ |x| (CAR #3#)) NIL)) (NREVERSE0 #2#)) (SEQ (EXIT (SETQ #2# (CONS (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |t| (QCAR |ISTMP#2|)) (QUOTE T))))))) |t|) ((QUOTE T) NIL)) #2#))))))))) (CONS (QUOTE MDEF) (CONS |newLhs| (CONS |typeList| (CONS (PROG (#4=#:G3111) (SPADLET #4# NIL) (RETURN (DO ((#5=#:G3116 |form| (CDR #5#)) (|x| NIL)) ((OR (ATOM #5#) (PROGN (SETQ |x| (CAR #5#)) NIL)) (NREVERSE0 #4#)) (SEQ (EXIT (SETQ #4# (CONS NIL #4#))))))) (CONS (|postTran| |rhs|) NIL)))))))))))) 
;postElt (u is [.,a,b]) ==
;  a:= postTran a
;  b is ['Sequence,:.] => [['elt,a,'makeRecord],:postTranList rest b]
;  ['elt,a,postTran b]

;;;     ***       |postElt| REDEFINED

(DEFUN |postElt| (|u|) (PROG (|b| |a|) (RETURN (PROGN (SPADLET |a| (CADR |u|)) (SPADLET |b| (CADDR |u|)) (SPADLET |a| (|postTran| |a|)) (COND ((AND (PAIRP |b|) (EQ (QCAR |b|) (QUOTE |Sequence|))) (CONS (CONS (QUOTE |elt|) (CONS |a| (CONS (QUOTE |makeRecord|) NIL))) (|postTranList| (CDR |b|)))) ((QUOTE T) (CONS (QUOTE |elt|) (CONS |a| (CONS (|postTran| |b|) NIL))))))))) 
;postExit ["=>",a,b] == ['IF,postTran a,['exit,postTran b],'noBranch]

;;;     ***       |postExit| REDEFINED

(DEFUN |postExit| (#0=#:G3158) (PROG (|a| |b|) (RETURN (PROGN (COND ((EQ (CAR #0#) (QUOTE =>)) (CAR #0#))) (SPADLET |a| (CADR #0#)) (SPADLET |b| (CADDR #0#)) (CONS (QUOTE IF) (CONS (|postTran| |a|) (CONS (CONS (QUOTE |exit|) (CONS (|postTran| |b|) NIL)) (CONS (QUOTE |noBranch|) NIL)))))))) 
;postFlatten(x,op) ==
;  x is [ =op,a,b] => [:postFlatten(a,op),:postFlatten(b,op)]
;  LIST x

;;;     ***       |postFlatten| REDEFINED

(DEFUN |postFlatten| (|x| |op|) (PROG (|ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (EQUAL (QCAR |x|) |op|) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (APPEND (|postFlatten| |a| |op|) (|postFlatten| |b| |op|))) ((QUOTE T) (LIST |x|)))))) 
;postForm (u is [op,:argl]) ==
;  x:=
;    atom op =>
;      argl':= postTranList argl
;      op':=
;        true=> op
;        $BOOT => op
;        GET(op,'Led) or GET(op,'Nud) or op = 'IN => op
;        numOfArgs:= (argl' is [['Tuple,:l]] => #l; 1)
;        INTERNL("*",STRINGIMAGE numOfArgs,PNAME op)
;      [op',:argl']
;    op is ['Scripts,:.] => [:postTran op,:postTranList argl]
;    u:= postTranList u
;    if u is [['Tuple,:.],:.] then
;      postError ['"  ",:bright u,
;        '"is illegal because tuples cannot be applied!",'%l,
;          '"   Did you misuse infix dot?"]
;    u
;  x is [.,['Tuple,:y]] => [first x,:y]
;  x

;;;     ***       |postForm| REDEFINED

(DEFUN |postForm| (|u|) (PROG (|op| |argl| |argl'| |l| |numOfArgs| |op'| |x| |ISTMP#1| |ISTMP#2| |y|) (RETURN (SEQ (PROGN (SPADLET |op| (CAR |u|)) (SPADLET |argl| (CDR |u|)) (SPADLET |x| (COND ((ATOM |op|) (SPADLET |argl'| (|postTranList| |argl|)) (SPADLET |op'| (SEQ (EXIT |op|) (COND ($BOOT (EXIT |op|))) (COND ((OR (GETL |op| (QUOTE |Led|)) (GETL |op| (QUOTE |Nud|)) (BOOT-EQUAL |op| (QUOTE IN))) (EXIT |op|))) (SPADLET |numOfArgs| (COND ((AND (PAIRP |argl'|) (EQ (QCDR |argl'|) NIL) (PROGN (SPADLET |ISTMP#1| (QCAR |argl'|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |Tuple|)) (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) (QUOTE T))))) (|#| |l|)) ((QUOTE T) 1))) (INTERNL (QUOTE *) (STRINGIMAGE |numOfArgs|) (PNAME |op|)))) (CONS |op'| |argl'|)) ((AND (PAIRP |op|) (EQ (QCAR |op|) (QUOTE |Scripts|))) (APPEND (|postTran| |op|) (|postTranList| |argl|))) ((QUOTE T) (SPADLET |u| (|postTranList| |u|)) (COND ((AND (PAIRP |u|) (PROGN (SPADLET |ISTMP#1| (QCAR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |Tuple|))))) (|postError| (CONS (MAKESTRING "  ") (APPEND (|bright| |u|) (CONS (MAKESTRING "is illegal because tuples cannot be applied!") (CONS (QUOTE |%l|) (CONS (MAKESTRING "   Did you misuse infix dot?") NIL)))))))) |u|))) (COND ((AND (PAIRP |x|) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ISTMP#2| (QCAR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCAR |ISTMP#2|) (QUOTE |Tuple|)) (PROGN (SPADLET |y| (QCDR |ISTMP#2|)) (QUOTE T))))))) (CONS (CAR |x|) |y|)) ((QUOTE T) |x|))))))) 
;postQuote [.,a] == ['QUOTE,a]

;;;     ***       |postQuote| REDEFINED

(DEFUN |postQuote| (#0=#:G3255) (PROG (|a|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (CONS (QUOTE QUOTE) (CONS |a| NIL)))))) 
;postScriptsForm(['Scripts,op,a],argl) ==
;  [getScriptName(op,a,#argl),:postTranScripts a,:argl]

;;;     ***       |postScriptsForm| REDEFINED

(DEFUN |postScriptsForm| (#0=#:G3266 |argl|) (PROG (|op| |a|) (RETURN (PROGN (SPADLET |op| (CADR #0#)) (SPADLET |a| (CADDR #0#)) (CONS (|getScriptName| |op| |a| (|#| |argl|)) (APPEND (|postTranScripts| |a|) |argl|)))))) 
;postScripts ['Scripts,op,a] ==
;  [getScriptName(op,a,0),:postTranScripts a]

;;;     ***       |postScripts| REDEFINED

(DEFUN |postScripts| (#0=#:G3280) (PROG (|op| |a|) (RETURN (PROGN (SPADLET |op| (CADR #0#)) (SPADLET |a| (CADDR #0#)) (CONS (|getScriptName| |op| |a| 0) (|postTranScripts| |a|)))))) 
;getScriptName(op,a,numberOfFunctionalArgs) ==
;  if null IDENTP op then
;    postError ['"   ",op,'" cannot have scripts"]
;  INTERNL("*",STRINGIMAGE numberOfFunctionalArgs,
;    decodeScripts a,PNAME op)

;;;     ***       |getScriptName| REDEFINED

(DEFUN |getScriptName| (|op| |a| |numberOfFunctionalArgs|) (PROGN (COND ((NULL (IDENTP |op|)) (|postError| (CONS (MAKESTRING "   ") (CONS |op| (CONS (MAKESTRING " cannot have scripts") NIL)))))) (INTERNL (QUOTE *) (STRINGIMAGE |numberOfFunctionalArgs|) (|decodeScripts| |a|) (PNAME |op|)))) 
;postTranScripts a ==
;  a is ['PrefixSC,b] => postTranScripts b
;  a is [";",:b] => "append"/[postTranScripts y for y in b]
;  a is [",",:b] =>
;    ("append"/[fn postTran y for y in b]) where
;      fn x ==
;        x is ['Tuple,:y] => y
;        LIST x
;  LIST postTran a

;;;     ***       |postTranScripts,fn| REDEFINED

(DEFUN |postTranScripts,fn| (|x|) (PROG (|y|) (RETURN (SEQ (IF (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Tuple|)) (PROGN (SPADLET |y| (QCDR |x|)) (QUOTE T))) (EXIT |y|)) (EXIT (LIST |x|)))))) 

;;;     ***       |postTranScripts| REDEFINED

(DEFUN |postTranScripts| (|a|) (PROG (|ISTMP#1| |b|) (RETURN (SEQ (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |PrefixSC|)) (PROGN (SPADLET |ISTMP#1| (QCDR |a|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) (QUOTE T))))) (|postTranScripts| |b|)) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |;|)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (PROG (#0=#:G3309) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G3314 |b| (CDR #1#)) (|y| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |y| (CAR #1#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (APPEND #0# (|postTranScripts| |y|))))))))) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |,|)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (PROG (#2=#:G3320) (SPADLET #2# NIL) (RETURN (DO ((#3=#:G3325 |b| (CDR #3#)) (|y| NIL)) ((OR (ATOM #3#) (PROGN (SETQ |y| (CAR #3#)) NIL)) #2#) (SEQ (EXIT (SETQ #2# (APPEND #2# (|postTranScripts,fn| (|postTran| |y|)))))))))) ((QUOTE T) (LIST (|postTran| |a|)))))))) 
;decodeScripts a ==
;  a is ['PrefixSC,b] => STRCONC(STRINGIMAGE 0,decodeScripts b)
;  a is [";",:b] => APPLX('STRCONC,[decodeScripts x for x in b])
;  a is [",",:b] =>
;    STRINGIMAGE fn a where fn a == (a is [",",:b] => +/[fn x for x in b]; 1)
;  STRINGIMAGE 1

;;;     ***       |decodeScripts,fn| REDEFINED

(DEFUN |decodeScripts,fn| (|a|) (PROG (|b|) (RETURN (SEQ (IF (AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |,|)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (EXIT (PROG (#0=#:G3345) (SPADLET #0# 0) (RETURN (DO ((#1=#:G3350 |b| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (PLUS #0# (|decodeScripts,fn| |x|)))))))))) (EXIT 1))))) 

;;;     ***       |decodeScripts| REDEFINED

(DEFUN |decodeScripts| (|a|) (PROG (|ISTMP#1| |b|) (RETURN (SEQ (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |PrefixSC|)) (PROGN (SPADLET |ISTMP#1| (QCDR |a|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#1|)) (QUOTE T))))) (STRCONC (STRINGIMAGE 0) (|decodeScripts| |b|))) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |;|)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (APPLX (QUOTE STRCONC) (PROG (#0=#:G3367) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G3372 |b| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|decodeScripts| |x|) #0#))))))))) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |,|)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (STRINGIMAGE (|decodeScripts,fn| |a|))) ((QUOTE T) (STRINGIMAGE 1))))))) 
;postIf t ==
;  t isnt ['if,:l] => t
;  ['IF,:[(null (x:= postTran x) and null $BOOT => 'noBranch; x)
;    for x in l]]

;;;     ***       |postIf| REDEFINED

(DEFUN |postIf| (|t|) (PROG (|l| |x|) (RETURN (SEQ (COND ((NULL (AND (PAIRP |t|) (EQ (QCAR |t|) (QUOTE |if|)) (PROGN (SPADLET |l| (QCDR |t|)) (QUOTE T)))) |t|) ((QUOTE T) (CONS (QUOTE IF) (PROG (#0=#:G3392) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G3397 |l| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (COND ((AND (NULL (SPADLET |x| (|postTran| |x|))) (NULL $BOOT)) (QUOTE |noBranch|)) ((QUOTE T) |x|)) #0#)))))))))))))) 
;postJoin ['Join,a,:l] ==
;  a:= postTran a
;  l:= postTranList l
;  if l is [b] and b is [name,:.] and MEMQ(name,'(ATTRIBUTE SIGNATURE)) then l
;    := LIST ['CATEGORY,b]
;  al:=
;    a is ['Tuple,:c] => c
;    LIST a
;  ['Join,:al,:l]

;;;     ***       |postJoin| REDEFINED

(DEFUN |postJoin| (#0=#:G3411) (PROG (|a| |b| |name| |l| |c| |al|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |l| (CDDR #0#)) (SPADLET |a| (|postTran| |a|)) (SPADLET |l| (|postTranList| |l|)) (COND ((AND (PAIRP |l|) (EQ (QCDR |l|) NIL) (PROGN (SPADLET |b| (QCAR |l|)) (QUOTE T)) (PAIRP |b|) (PROGN (SPADLET |name| (QCAR |b|)) (QUOTE T)) (MEMQ |name| (QUOTE (ATTRIBUTE SIGNATURE)))) (SPADLET |l| (LIST (CONS (QUOTE CATEGORY) (CONS |b| NIL)))))) (SPADLET |al| (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE |Tuple|)) (PROGN (SPADLET |c| (QCDR |a|)) (QUOTE T))) |c|) ((QUOTE T) (LIST |a|)))) (CONS (QUOTE |Join|) (APPEND |al| |l|)))))) 
;postMapping u  ==
;  u isnt ["->",source,target] => u
;  ['Mapping,postTran target,:unTuple postTran source]

;;;     ***       |postMapping| REDEFINED

(DEFUN |postMapping| (|u|) (PROG (|ISTMP#1| |source| |ISTMP#2| |target|) (RETURN (COND ((NULL (AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE ->)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |source| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |target| (QCAR |ISTMP#2|)) (QUOTE T)))))))) |u|) ((QUOTE T) (CONS (QUOTE |Mapping|) (CONS (|postTran| |target|) (|unTuple| (|postTran| |source|))))))))) 
;postOp x ==
;  x=":=" =>
;    $BOOT => 'SPADLET
;    'LET
;  x=":-" => 'LETD
;  x='Attribute => 'ATTRIBUTE
;  x

;;;     ***       |postOp| REDEFINED

(DEFUN |postOp| (|x|) (COND ((BOOT-EQUAL |x| (QUOTE |:=|)) (COND ($BOOT (QUOTE SPADLET)) ((QUOTE T) (QUOTE LET)))) ((BOOT-EQUAL |x| (QUOTE |:-|)) (QUOTE LETD)) ((BOOT-EQUAL |x| (QUOTE |Attribute|)) (QUOTE ATTRIBUTE)) ((QUOTE T) |x|))) 
;postRepeat ['REPEAT,:m,x] == ['REPEAT,:postIteratorList m,postTran x]

;;;     ***       |postRepeat| REDEFINED

(DEFUN |postRepeat| (#0=#:G3467) (PROG (|LETTMP#1| |x| |m|) (RETURN (PROGN (SPADLET |LETTMP#1| (REVERSE (CDR #0#))) (SPADLET |x| (CAR |LETTMP#1|)) (SPADLET |m| (NREVERSE (CDR |LETTMP#1|))) (CONS (QUOTE REPEAT) (APPEND (|postIteratorList| |m|) (CONS (|postTran| |x|) NIL))))))) 
;postSEGMENT ['SEGMENT,a,b] ==
;  key:= [a,'"..",:(b => [b]; nil)]
;  postError ['"   Improper placement of segment",:bright key]

;;;     ***       |postSEGMENT| REDEFINED

(DEFUN |postSEGMENT| (#0=#:G3486) (PROG (|a| |b| |key|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |b| (CADDR #0#)) (SPADLET |key| (CONS |a| (CONS (MAKESTRING "..") (COND (|b| (CONS |b| NIL)) ((QUOTE T) NIL))))) (|postError| (CONS (MAKESTRING "   Improper placement of segment") (|bright| |key|))))))) 
;postCollect [constructOp,:m,x] ==
;  x is [['elt,D,'construct],:y] =>
;    postCollect [['elt,D,'COLLECT],:m,['construct,:y]]
;  itl:= postIteratorList m
;  x:= (x is ['construct,r] => r; x)  --added 84/8/31
;  y:= postTran x
;  finish(constructOp,itl,y) where
;    finish(op,itl,y) ==
;      y is [":",a] => ['REDUCE,'append,0,[op,:itl,a]]
;      y is ['Tuple,:l] =>
;        newBody:=
;          or/[x is [":",y] for x in l] => postMakeCons l
;          or/[x is ['SEGMENT,:.] for x in l] => tuple2List l
;          ['construct,:postTranList l]
;        ['REDUCE,'append,0,[op,:itl,newBody]]
;      [op,:itl,y]

;;;     ***       |postCollect,finish| REDEFINED

(DEFUN |postCollect,finish| (|op| |itl| |y|) (PROG (|a| |l| |ISTMP#1| |newBody|) (RETURN (SEQ (IF (AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |y|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (QUOTE T))))) (EXIT (CONS (QUOTE REDUCE) (CONS (QUOTE |append|) (CONS 0 (CONS (CONS |op| (APPEND |itl| (CONS |a| NIL))) NIL)))))) (IF (AND (PAIRP |y|) (EQ (QCAR |y|) (QUOTE |Tuple|)) (PROGN (SPADLET |l| (QCDR |y|)) (QUOTE T))) (EXIT (SEQ (SPADLET |newBody| (SEQ (IF (PROG (#0=#:G3534) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G3544 NIL #0#) (#2=#:G3545 |l| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (OR #0# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T)))))))))))) (EXIT (|postMakeCons| |l|))) (IF (PROG (#3=#:G3552) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G3558 NIL #3#) (#5=#:G3559 |l| (CDR #5#)) (|x| NIL)) ((OR #4# (ATOM #5#) (PROGN (SETQ |x| (CAR #5#)) NIL)) #3#) (SEQ (EXIT (SETQ #3# (OR #3# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE SEGMENT)))))))))) (EXIT (|tuple2List| |l|))) (EXIT (CONS (QUOTE |construct|) (|postTranList| |l|))))) (EXIT (CONS (QUOTE REDUCE) (CONS (QUOTE |append|) (CONS 0 (CONS (CONS |op| (APPEND |itl| (CONS |newBody| NIL))) NIL)))))))) (EXIT (CONS |op| (APPEND |itl| (CONS |y| NIL)))))))) 

;;;     ***       |postCollect| REDEFINED

(DEFUN |postCollect| (#0=#:G3579) (PROG (|constructOp| |LETTMP#1| |m| |ISTMP#2| D |ISTMP#3| |itl| |ISTMP#1| |r| |x| |y|) (RETURN (PROGN (SPADLET |constructOp| (CAR #0#)) (SPADLET |LETTMP#1| (REVERSE (CDR #0#))) (SPADLET |x| (CAR |LETTMP#1|)) (SPADLET |m| (NREVERSE (CDR |LETTMP#1|))) (COND ((AND (PAIRP |x|) (PROGN (SPADLET |ISTMP#1| (QCAR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |elt|)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET D (QCAR |ISTMP#2|)) (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL) (EQ (QCAR |ISTMP#3|) (QUOTE |construct|)))))))) (PROGN (SPADLET |y| (QCDR |x|)) (QUOTE T))) (|postCollect| (CONS (CONS (QUOTE |elt|) (CONS D (CONS (QUOTE COLLECT) NIL))) (APPEND |m| (CONS (CONS (QUOTE |construct|) |y|) NIL))))) ((QUOTE T) (SPADLET |itl| (|postIteratorList| |m|)) (SPADLET |x| (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |construct|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |r| (QCAR |ISTMP#1|)) (QUOTE T))))) |r|) ((QUOTE T) |x|))) (SPADLET |y| (|postTran| |x|)) (|postCollect,finish| |constructOp| |itl| |y|))))))) 
;postTupleCollect [constructOp,:m,x] ==
;  postCollect [constructOp,:m,['construct,x]]

;;;     ***       |postTupleCollect| REDEFINED

(DEFUN |postTupleCollect| (#0=#:G3622) (PROG (|constructOp| |LETTMP#1| |x| |m|) (RETURN (PROGN (SPADLET |constructOp| (CAR #0#)) (SPADLET |LETTMP#1| (REVERSE (CDR #0#))) (SPADLET |x| (CAR |LETTMP#1|)) (SPADLET |m| (NREVERSE (CDR |LETTMP#1|))) (|postCollect| (CONS |constructOp| (APPEND |m| (CONS (CONS (QUOTE |construct|) (CONS |x| NIL)) NIL)))))))) 
;postIteratorList x ==
;  x is [p,:l] =>
;    (p:= postTran p) is ['IN,y,u] =>
;      u is ["|",a,b] => [['IN,y,postInSeq a],["|",b],:postIteratorList l]
;      [['IN,y,postInSeq u],:postIteratorList l]
;    [p,:postIteratorList l]
;  x

;;;     ***       |postIteratorList| REDEFINED

(DEFUN |postIteratorList| (|x|) (PROG (|l| |p| |y| |ISTMP#3| |u| |ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (PROGN (SPADLET |p| (QCAR |x|)) (SPADLET |l| (QCDR |x|)) (QUOTE T))) (COND ((PROGN (SPADLET |ISTMP#1| (SPADLET |p| (|postTran| |p|))) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE IN)) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (SPADLET |ISTMP#3| (QCDR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (EQ (QCDR |ISTMP#3|) NIL) (PROGN (SPADLET |u| (QCAR |ISTMP#3|)) (QUOTE T)))))))) (COND ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |\||)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (CONS (CONS (QUOTE IN) (CONS |y| (CONS (|postInSeq| |a|) NIL))) (CONS (CONS (QUOTE |\||) (CONS |b| NIL)) (|postIteratorList| |l|)))) ((QUOTE T) (CONS (CONS (QUOTE IN) (CONS |y| (CONS (|postInSeq| |u|) NIL))) (|postIteratorList| |l|))))) ((QUOTE T) (CONS |p| (|postIteratorList| |l|))))) ((QUOTE T) |x|))))) 
;postin arg ==
;  arg isnt ['in,i,seq] => systemErrorHere '"postin"
;  ['in,postTran i, postInSeq seq]

;;;     ***       |postin| REDEFINED

(DEFUN |postin| (|arg|) (PROG (|ISTMP#1| |i| |ISTMP#2| |seq|) (RETURN (COND ((NULL (AND (PAIRP |arg|) (EQ (QCAR |arg|) (QUOTE |in|)) (PROGN (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |i| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |seq| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (|systemErrorHere| (MAKESTRING "postin"))) ((QUOTE T) (CONS (QUOTE |in|) (CONS (|postTran| |i|) (CONS (|postInSeq| |seq|) NIL)))))))) 
;postIn arg ==
;  arg isnt ['IN,i,seq] => systemErrorHere '"postIn"
;  ['IN,postTran i,postInSeq seq]

;;;     ***       |postIn| REDEFINED

(DEFUN |postIn| (|arg|) (PROG (|ISTMP#1| |i| |ISTMP#2| |seq|) (RETURN (COND ((NULL (AND (PAIRP |arg|) (EQ (QCAR |arg|) (QUOTE IN)) (PROGN (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |i| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |seq| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (|systemErrorHere| (MAKESTRING "postIn"))) ((QUOTE T) (CONS (QUOTE IN) (CONS (|postTran| |i|) (CONS (|postInSeq| |seq|) NIL)))))))) 
;postInSeq seq ==
;  seq is ['SEGMENT,p,q] => postTranSegment(p,q)
;  seq is ['Tuple,:l] => tuple2List l
;  postTran seq

;;;     ***       |postInSeq| REDEFINED

(DEFUN |postInSeq| (|seq|) (PROG (|ISTMP#1| |p| |ISTMP#2| |q| |l|) (RETURN (COND ((AND (PAIRP |seq|) (EQ (QCAR |seq|) (QUOTE SEGMENT)) (PROGN (SPADLET |ISTMP#1| (QCDR |seq|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#2|)) (QUOTE T))))))) (|postTranSegment| |p| |q|)) ((AND (PAIRP |seq|) (EQ (QCAR |seq|) (QUOTE |Tuple|)) (PROGN (SPADLET |l| (QCDR |seq|)) (QUOTE T))) (|tuple2List| |l|)) ((QUOTE T) (|postTran| |seq|)))))) 
;postTranSegment(p,q) == ['SEGMENT,postTran p,(q => postTran q; nil)]

;;;     ***       |postTranSegment| REDEFINED

(DEFUN |postTranSegment| (|p| |q|) (CONS (QUOTE SEGMENT) (CONS (|postTran| |p|) (CONS (COND (|q| (|postTran| |q|)) ((QUOTE T) NIL)) NIL)))) 
;tuple2List l ==
;  l is [a,:l'] =>
;    u:= tuple2List l'
;    a is ['SEGMENT,p,q] =>
;      null u => ['construct,postTranSegment(p,q)]
;      $InteractiveMode and null $BOOT =>
;        ['append,['construct,postTranSegment(p,q)],tuple2List l']
;      ["nconc",['construct,postTranSegment(p,q)],tuple2List l']
;    null u => ['construct,postTran a]
;    ["cons",postTran a,tuple2List l']
;  nil

;;;     ***       |tuple2List| REDEFINED

(DEFUN |tuple2List| (|l|) (PROG (|a| |l'| |u| |ISTMP#1| |p| |ISTMP#2| |q|) (RETURN (COND ((AND (PAIRP |l|) (PROGN (SPADLET |a| (QCAR |l|)) (SPADLET |l'| (QCDR |l|)) (QUOTE T))) (SPADLET |u| (|tuple2List| |l'|)) (COND ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE SEGMENT)) (PROGN (SPADLET |ISTMP#1| (QCDR |a|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |p| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |q| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((NULL |u|) (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL))) ((AND |$InteractiveMode| (NULL $BOOT)) (CONS (QUOTE |append|) (CONS (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL)) (CONS (|tuple2List| |l'|) NIL)))) ((QUOTE T) (CONS (QUOTE |nconc|) (CONS (CONS (QUOTE |construct|) (CONS (|postTranSegment| |p| |q|) NIL)) (CONS (|tuple2List| |l'|) NIL)))))) ((NULL |u|) (CONS (QUOTE |construct|) (CONS (|postTran| |a|) NIL))) ((QUOTE T) (CONS (QUOTE |cons|) (CONS (|postTran| |a|) (CONS (|tuple2List| |l'|) NIL)))))) ((QUOTE T) NIL))))) 
;SEGMENT(a,b) == [i for i in a..b]

;;;     ***       SEGMENT REDEFINED

(DEFUN SEGMENT (|a| |b|) (PROG NIL (RETURN (SEQ (PROG (#0=#:G3817) (SPADLET #0# NIL) (RETURN (DO ((|i| |a| (+ |i| 1))) ((> |i| |b|) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS |i| #0#))))))))))) 
;postReduce ['Reduce,op,expr] ==
;  $InteractiveMode or expr is ['COLLECT,:.] =>
;    ['REDUCE,op,0,postTran expr]
;  postReduce ['Reduce,op,['COLLECT,['IN,g:= GENSYM(),expr],
;    ['construct,  g]]]

;;;     ***       |postReduce| REDEFINED

(DEFUN |postReduce| (#0=#:G3830) (PROG (|op| |expr| |g|) (RETURN (PROGN (SPADLET |op| (CADR #0#)) (SPADLET |expr| (CADDR #0#)) (COND ((OR |$InteractiveMode| (AND (PAIRP |expr|) (EQ (QCAR |expr|) (QUOTE COLLECT)))) (CONS (QUOTE REDUCE) (CONS |op| (CONS 0 (CONS (|postTran| |expr|) NIL))))) ((QUOTE T) (|postReduce| (CONS (QUOTE |Reduce|) (CONS |op| (CONS (CONS (QUOTE COLLECT) (CONS (CONS (QUOTE IN) (CONS (SPADLET |g| (GENSYM)) (CONS |expr| NIL))) (CONS (CONS (QUOTE |construct|) (CONS |g| NIL)) NIL))) NIL)))))))))) 
;postFlattenLeft(x,op) ==--
;  x is [ =op,a,b] => [:postFlattenLeft(a,op),b]
;  [x]

;;;     ***       |postFlattenLeft| REDEFINED

(DEFUN |postFlattenLeft| (|x| |op|) (PROG (|ISTMP#1| |a| |ISTMP#2| |b|) (RETURN (COND ((AND (PAIRP |x|) (EQUAL (QCAR |x|) |op|) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |a| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |b| (QCAR |ISTMP#2|)) (QUOTE T))))))) (APPEND (|postFlattenLeft| |a| |op|) (CONS |b| NIL))) ((QUOTE T) (CONS |x| NIL)))))) 
;postSemiColon u == postBlock ['Block,:postFlattenLeft(u,";")]

;;;     ***       |postSemiColon| REDEFINED

(DEFUN |postSemiColon| (|u|) (|postBlock| (CONS (QUOTE |Block|) (|postFlattenLeft| |u| (QUOTE |;|))))) 
;postSequence ['Sequence,:l] == ['(elt $ makeRecord),:postTranList l]

;;;     ***       |postSequence| REDEFINED

(DEFUN |postSequence| (#0=#:G3872) (PROG (|l|) (RETURN (PROGN (SPADLET |l| (CDR #0#)) (CONS (QUOTE (|elt| $ |makeRecord|)) (|postTranList| |l|)))))) 
;postSignature ['Signature,op,sig] ==
;  sig is ["->",:.] =>
;    sig1:= postType sig
;    op:= postAtom (STRINGP op => INTERN op; op)
;    ["SIGNATURE",op,:removeSuperfluousMapping killColons sig1]

;;;     ***       |postSignature| REDEFINED

(DEFUN |postSignature| (#0=#:G3885) (PROG (|sig| |sig1| |op|) (RETURN (PROGN (SPADLET |op| (CADR #0#)) (SPADLET |sig| (CADDR #0#)) (COND ((AND (PAIRP |sig|) (EQ (QCAR |sig|) (QUOTE ->))) (PROGN (SPADLET |sig1| (|postType| |sig|)) (SPADLET |op| (|postAtom| (COND ((STRINGP |op|) (INTERN |op|)) ((QUOTE T) |op|)))) (CONS (QUOTE SIGNATURE) (CONS |op| (|removeSuperfluousMapping| (|killColons| |sig1|))))))))))) 
;killColons x ==
;  atom x => x
;  x is ['Record,:.] => x
;  x is ['Union,:.] => x
;  x is [":",.,y] => killColons y
;  [killColons first x,:killColons rest x]

;;;     ***       |killColons| REDEFINED

(DEFUN |killColons| (|x|) (PROG (|ISTMP#1| |ISTMP#2| |y|) (RETURN (COND ((ATOM |x|) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Record|))) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Union|))) |x|) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#2|)) (QUOTE T))))))) (|killColons| |y|)) ((QUOTE T) (CONS (|killColons| (CAR |x|)) (|killColons| (CDR |x|)))))))) 
;postSlash ['_/,a,b] ==
;  STRINGP a => postTran ['Reduce,INTERN a,b]
;  ['_/,postTran a,postTran b]

;;;     ***       |postSlash| REDEFINED

(DEFUN |postSlash| (#0=#:G3919) (PROG (|a| |b|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |b| (CADDR #0#)) (COND ((STRINGP |a|) (|postTran| (CONS (QUOTE |Reduce|) (CONS (INTERN |a|) (CONS |b| NIL))))) ((QUOTE T) (CONS (QUOTE /) (CONS (|postTran| |a|) (CONS (|postTran| |b|) NIL))))))))) 
;removeSuperfluousMapping sig1 ==
;  --get rid of this asap
;  sig1 is [x,:y] and x is ['Mapping,:.] => [rest x,:y]
;  sig1

;;;     ***       |removeSuperfluousMapping| REDEFINED

(DEFUN |removeSuperfluousMapping| (|sig1|) (PROG (|x| |y|) (RETURN (COND ((AND (PAIRP |sig1|) (PROGN (SPADLET |x| (QCAR |sig1|)) (SPADLET |y| (QCDR |sig1|)) (QUOTE T)) (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Mapping|))) (CONS (CDR |x|) |y|)) ((QUOTE T) |sig1|))))) 
;postType typ ==
;  typ is ["->",source,target] =>
;    source="constant" => [LIST postTran target,"constant"]
;    LIST ['Mapping,postTran target,:unTuple postTran source]
;  typ is ["->",target] => LIST ['Mapping,postTran target]
;  LIST postTran typ

;;;     ***       |postType| REDEFINED

(DEFUN |postType| (|typ|) (PROG (|source| |ISTMP#2| |ISTMP#1| |target|) (RETURN (COND ((AND (PAIRP |typ|) (EQ (QCAR |typ|) (QUOTE ->)) (PROGN (SPADLET |ISTMP#1| (QCDR |typ|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |source| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |target| (QCAR |ISTMP#2|)) (QUOTE T))))))) (COND ((BOOT-EQUAL |source| (QUOTE |constant|)) (CONS (LIST (|postTran| |target|)) (CONS (QUOTE |constant|) NIL))) ((QUOTE T) (LIST (CONS (QUOTE |Mapping|) (CONS (|postTran| |target|) (|unTuple| (|postTran| |source|)))))))) ((AND (PAIRP |typ|) (EQ (QCAR |typ|) (QUOTE ->)) (PROGN (SPADLET |ISTMP#1| (QCDR |typ|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |target| (QCAR |ISTMP#1|)) (QUOTE T))))) (LIST (CONS (QUOTE |Mapping|) (CONS (|postTran| |target|) NIL)))) ((QUOTE T) (LIST (|postTran| |typ|))))))) 
;postTuple u ==
;  u is ['Tuple] => u
;  u is ['Tuple,:l,a] => (['Tuple,:postTranList rest u])

;;;     ***       |postTuple| REDEFINED

(DEFUN |postTuple| (|u|) (PROG (|ISTMP#1| |ISTMP#2| |a| |l|) (RETURN (COND ((AND (PAIRP |u|) (EQ (QCDR |u|) NIL) (EQ (QCAR |u|) (QUOTE |Tuple|))) |u|) ((AND (PAIRP |u|) (EQ (QCAR |u|) (QUOTE |Tuple|)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ISTMP#2| (REVERSE |ISTMP#1|)) (QUOTE T)) (PAIRP |ISTMP#2|) (PROGN (SPADLET |a| (QCAR |ISTMP#2|)) (SPADLET |l| (QCDR |ISTMP#2|)) (QUOTE T)) (PROGN (SPADLET |l| (NREVERSE |l|)) (QUOTE T))))) (CONS (QUOTE |Tuple|) (|postTranList| (CDR |u|)))))))) 
;--u is ['Tuple,:l,a] => (--a:= postTran a; ['Tuple,:postTranList rest u])
;    --RDJ: don't understand need for above statement that is commented out
;postWhere ['where,a,b] ==
;  x:=
;    b is ['Block,:c] => c
;    LIST b
;  ['where,postTran a,:postTranList x]

;;;     ***       |postWhere| REDEFINED

(DEFUN |postWhere| (#0=#:G3996) (PROG (|a| |b| |c| |x|) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |b| (CADDR #0#)) (SPADLET |x| (COND ((AND (PAIRP |b|) (EQ (QCAR |b|) (QUOTE |Block|)) (PROGN (SPADLET |c| (QCDR |b|)) (QUOTE T))) |c|) ((QUOTE T) (LIST |b|)))) (CONS (QUOTE |where|) (CONS (|postTran| |a|) (|postTranList| |x|))))))) 
;postWith ['with,a] ==
;  $insidePostCategoryIfTrue: local := true
;  a:= postTran a
;  a is [op,:.] and MEMQ(op,'(SIGNATURE ATTRIBUTE IF)) => ['CATEGORY,a]
;  a is ['PROGN,:b] => ['CATEGORY,:b]
;  a

;;;     ***       |postWith| REDEFINED

(DEFUN |postWith| (#0=#:G4015) (PROG (|$insidePostCategoryIfTrue| |a| |op| |b|) (DECLARE (SPECIAL |$insidePostCategoryIfTrue|)) (RETURN (PROGN (SPADLET |a| (CADR #0#)) (SPADLET |$insidePostCategoryIfTrue| (QUOTE T)) (SPADLET |a| (|postTran| |a|)) (COND ((AND (PAIRP |a|) (PROGN (SPADLET |op| (QCAR |a|)) (QUOTE T)) (MEMQ |op| (QUOTE (SIGNATURE ATTRIBUTE IF)))) (CONS (QUOTE CATEGORY) (CONS |a| NIL))) ((AND (PAIRP |a|) (EQ (QCAR |a|) (QUOTE PROGN)) (PROGN (SPADLET |b| (QCDR |a|)) (QUOTE T))) (CONS (QUOTE CATEGORY) |b|)) ((QUOTE T) |a|)))))) 
;postTransformCheck x ==
;  $defOp: local:= nil
;  postcheck x

;;;     ***       |postTransformCheck| REDEFINED

(DEFUN |postTransformCheck| (|x|) (PROG (|$defOp|) (DECLARE (SPECIAL |$defOp|)) (RETURN (PROGN (SPADLET |$defOp| NIL) (|postcheck| |x|))))) 
;postcheck x ==
;  atom x => nil
;  x is ['DEF,form,[target,:.],:.] =>
;    (setDefOp form; postcheckTarget target; postcheck rest rest x)
;  x is ['QUOTE,:.] => nil
;  postcheck first x
;  postcheck rest x

;;;     ***       |postcheck| REDEFINED

(DEFUN |postcheck| (|x|) (PROG (|ISTMP#1| |form| |ISTMP#2| |ISTMP#3| |target|) (RETURN (COND ((ATOM |x|) NIL) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE DEF)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |form| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (PROGN (SPADLET |ISTMP#3| (QCAR |ISTMP#2|)) (AND (PAIRP |ISTMP#3|) (PROGN (SPADLET |target| (QCAR |ISTMP#3|)) (QUOTE T))))))))) (|setDefOp| |form|) (|postcheckTarget| |target|) (|postcheck| (CDR (CDR |x|)))) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE QUOTE))) NIL) ((QUOTE T) (|postcheck| (CAR |x|)) (|postcheck| (CDR |x|))))))) 
;setDefOp f ==
;  if f is [":",g,:.] then f := g
;  f := (atom f => f; first f)
;  if $topOp then $defOp:= f else $topOp:= f

;;;     ***       |setDefOp| REDEFINED

(DEFUN |setDefOp| (|f|) (PROG (|ISTMP#1| |g|) (RETURN (PROGN (COND ((AND (PAIRP |f|) (EQ (QCAR |f|) (QUOTE |:|)) (PROGN (SPADLET |ISTMP#1| (QCDR |f|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |g| (QCAR |ISTMP#1|)) (QUOTE T))))) (SPADLET |f| |g|))) (SPADLET |f| (COND ((ATOM |f|) |f|) ((QUOTE T) (CAR |f|)))) (COND (|$topOp| (SPADLET |$defOp| |f|)) ((QUOTE T) (SPADLET |$topOp| |f|))))))) 
;postcheckTarget x ==
;  -- doesn't seem that useful!
;  isPackageType x => nil
;  x is ['Join,:.] => nil
;  NIL

;;;     ***       |postcheckTarget| REDEFINED

(DEFUN |postcheckTarget| (|x|) (COND ((|isPackageType| |x|) NIL) ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Join|))) NIL) ((QUOTE T) NIL))) 
;isPackageType x == not CONTAINED("$",x)

;;;     ***       |isPackageType| REDEFINED

(DEFUN |isPackageType| (|x|) (NULL (CONTAINED (QUOTE $) |x|))) 
;unTuple x ==
;  x is ['Tuple,:y] => y
;  LIST x

;;;     ***       |unTuple| REDEFINED

(DEFUN |unTuple| (|x|) (PROG (|y|) (RETURN (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE |Tuple|)) (PROGN (SPADLET |y| (QCDR |x|)) (QUOTE T))) |y|) ((QUOTE T) (LIST |x|)))))) 
;--% APL TRANSFORMATION OF INPUT
;aplTran x ==
;  $BOOT => x
;  $GENNO: local := 0
;  u:= aplTran1 x
;  containsBang u => throwKeyedMsg("S2IP0002",NIL)
;  u

;;;     ***       |aplTran| REDEFINED

(DEFUN |aplTran| (|x|) (PROG ($GENNO |u|) (DECLARE (SPECIAL $GENNO)) (RETURN (COND ($BOOT |x|) ((QUOTE T) (SPADLET $GENNO 0) (SPADLET |u| (|aplTran1| |x|)) (COND ((|containsBang| |u|) (|throwKeyedMsg| (QUOTE S2IP0002) NIL)) ((QUOTE T) |u|))))))) 
;containsBang u ==
;  atom u => EQ(u,"!")
;  u is [='QUOTE,.] => false
;  or/[containsBang x for x in u]

;;;     ***       |containsBang| REDEFINED

(DEFUN |containsBang| (|u|) (PROG (|ISTMP#1|) (RETURN (SEQ (COND ((ATOM |u|) (EQ |u| (QUOTE !))) ((AND (PAIRP |u|) (EQUAL (QCAR |u|) (QUOTE QUOTE)) (PROGN (SPADLET |ISTMP#1| (QCDR |u|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL)))) NIL) ((QUOTE T) (PROG (#0=#:G4117) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G4123 NIL #0#) (#2=#:G4124 |u| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (OR #0# (|containsBang| |x|)))))))))))))) 
;aplTran1 x ==
;  atom x => x
;  [op,:argl1] := x
;  argl := aplTranList argl1
;  -- unary case f ! y
;  op = "_!" =>
;    argl is [f,y] =>
;      y is [op',:y'] and op' = "_!" => aplTran1 [op,op,f,:y']
;      $BOOT => ['COLLECT,['IN,g:=GENVAR(),aplTran1 y],[f,g]]
;      ['map,f,aplTran1 y]
;    x    --do not handle yet
;  -- multiple argument case
;  hasAplExtension argl is [arglAssoc,:futureArgl] =>
;    -- choose the last aggregate type to be result of reshape
;    ['reshape,['COLLECT,:[['IN,g,['ravel,a]] for [g,:a] in arglAssoc],
;      aplTran1 [op,:futureArgl]],CDAR arglAssoc]
;  [op,:argl]

;;;     ***       |aplTran1| REDEFINED

(DEFUN |aplTran1| (|x|) (PROG (|op| |argl1| |argl| |f| |y| |op'| |y'| |ISTMP#1| |arglAssoc| |futureArgl| |g| |a|) (RETURN (SEQ (COND ((ATOM |x|) |x|) ((QUOTE T) (SPADLET |op| (CAR |x|)) (SPADLET |argl1| (CDR |x|)) (SPADLET |argl| (|aplTranList| |argl1|)) (COND ((BOOT-EQUAL |op| (QUOTE !)) (COND ((AND (PAIRP |argl|) (PROGN (SPADLET |f| (QCAR |argl|)) (SPADLET |ISTMP#1| (QCDR |argl|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T))))) (COND ((AND (PAIRP |y|) (PROGN (SPADLET |op'| (QCAR |y|)) (SPADLET |y'| (QCDR |y|)) (QUOTE T)) (BOOT-EQUAL |op'| (QUOTE !))) (|aplTran1| (CONS |op| (CONS |op| (CONS |f| |y'|))))) ($BOOT (CONS (QUOTE COLLECT) (CONS (CONS (QUOTE IN) (CONS (SPADLET |g| (GENVAR)) (CONS (|aplTran1| |y|) NIL))) (CONS (CONS |f| (CONS |g| NIL)) NIL)))) ((QUOTE T) (CONS (QUOTE |map|) (CONS |f| (CONS (|aplTran1| |y|) NIL)))))) ((QUOTE T) |x|))) ((PROGN (SPADLET |ISTMP#1| (|hasAplExtension| |argl|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |arglAssoc| (QCAR |ISTMP#1|)) (SPADLET |futureArgl| (QCDR |ISTMP#1|)) (QUOTE T)))) (CONS (QUOTE |reshape|) (CONS (CONS (QUOTE COLLECT) (APPEND (PROG (#0=#:G4171) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G4177 |arglAssoc| (CDR #1#)) (#2=#:G4161 NIL)) ((OR (ATOM #1#) (PROGN (SETQ #2# (CAR #1#)) NIL) (PROGN (PROGN (SPADLET |g| (CAR #2#)) (SPADLET |a| (CDR #2#)) #2#) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (CONS (QUOTE IN) (CONS |g| (CONS (CONS (QUOTE |ravel|) (CONS |a| NIL)) NIL))) #0#))))))) (CONS (|aplTran1| (CONS |op| |futureArgl|)) NIL))) (CONS (CDAR |arglAssoc|) NIL)))) ((QUOTE T) (CONS |op| |argl|))))))))) 
;aplTranList x ==
;  atom x => x
;  [aplTran1 first x,:aplTranList rest x]

;;;     ***       |aplTranList| REDEFINED

(DEFUN |aplTranList| (|x|) (COND ((ATOM |x|) |x|) ((QUOTE T) (CONS (|aplTran1| (CAR |x|)) (|aplTranList| (CDR |x|)))))) 
;hasAplExtension argl ==
;  or/[x is ["_!",:.] for x in argl] =>
;    u:= [futureArg for x in argl] where futureArg ==
;      x is ["_!",y] =>
;        z:= deepestExpression y
;        arglAssoc := [[g := GENVAR(),:aplTran1 z],:arglAssoc]
;        substitute(g,z,y)
;      x
;    [arglAssoc,:u]
;  nil

;;;     ***       |hasAplExtension| REDEFINED

(DEFUN |hasAplExtension| (|argl|) (PROG (|ISTMP#1| |y| |z| |g| |arglAssoc| |u|) (RETURN (SEQ (COND ((PROG (#0=#:G4219) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G4225 NIL #0#) (#2=#:G4226 |argl| (CDR #2#)) (|x| NIL)) ((OR #1# (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) #0#) (SEQ (EXIT (SETQ #0# (OR #0# (AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE !)))))))))) (SPADLET |u| (PROG (#3=#:G4241) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G4250 |argl| (CDR #4#)) (|x| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |x| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE !)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T))))) (SPADLET |z| (|deepestExpression| |y|)) (SPADLET |arglAssoc| (CONS (CONS (SPADLET |g| (GENVAR)) (|aplTran1| |z|)) |arglAssoc|)) (MSUBST |g| |z| |y|)) ((QUOTE T) |x|)) #3#)))))))) (CONS |arglAssoc| |u|)) ((QUOTE T) NIL)))))) 
;deepestExpression x ==
;  x is ["_!",y] => deepestExpression y
;  x

;;;     ***       |deepestExpression| REDEFINED

(DEFUN |deepestExpression| (|x|) (PROG (|ISTMP#1| |y|) (RETURN (COND ((AND (PAIRP |x|) (EQ (QCAR |x|) (QUOTE !)) (PROGN (SPADLET |ISTMP#1| (QCDR |x|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |y| (QCAR |ISTMP#1|)) (QUOTE T))))) (|deepestExpression| |y|)) ((QUOTE T) |x|))))) 
;;;Boot translation finished for postpar.boot
@
\eject
\begin{thebibliography}{99}
\bibitem{1} nothing
\end{thebibliography}
\end{document}
