
subdir = src/interp/

IN=$(srcdir)
DOC=$(axiom_target_docdir)/src/interp
BOOK=$(axiom_target_docdir)

# Command to translate Boot to Common Lisp
BOOT_TO_LISP = \
	$(axiom_build_document) --tag=boot --mode=translate \
		--use=$(BOOTSYS) $< >> $(TMP)/trace

# Command to translate Common Lisp to native object code
COMPILE_LISP = \
	$(axiom_build_document) --tag=lisp --mode=compile \
		--output=$@ --use=$(DEPSYS) $< >> $(TMP)/trace
AUTO=$(axiom_targetdir)/autoload

autoload_objects =

# Build platform-dependent Lisp image, at the base of other
# derived Lisp images (depsys, interpsys, AXIOMsys)
LISPSYS= $(axiom_build_bindir)/lisp

BOOTSYS= $(axiom_build_bindir)/bootsys    

DEPSYS=	$(axiom_build_bindir)/depsys

depsys_lisp_noncompiled_sources += sys-pkg.lisp nocompil.lisp \
	ncompil.lisp bookvol5.lisp util.lisp

depsys_lisp_compiled_sources += parsing.lisp metalex.lisp bootlex.lisp \
	newaux.lisp preparse.lisp postprop.lisp def.lisp metameta.lisp \
	fnewmeta.lisp

depsys_lisp_sources = $(depsys_lisp_noncompiled_sources) \
			$(depsys_lisp_compiled_sources)

depsys_boot_sources = postpar.boot parse.boot clam.boot slam.boot \
	g-boot.boot c-util.boot g-util.boot
DEP=	vmlisp.lisp	ggreater.lisp	\
	hash.lisp	bootfuns.lisp	\
	union.lisp	nlib.lisp	\
	macros.lisp	comp.lisp	\
	spaderror.lisp	debug.lisp	\
	spad.lisp	bits.lisp	\
	setq.lisp	property.lisp	\
	unlisp.lisp      foam_l.lisp      \
	axext_l.lisp

depsys_lisp_macro_sources = vmlisp.lisp ggreater.lisp hash.lisp \
	bootfuns.lisp union.lisp nlib.lisp macros.lisp	\
	comp.lisp spaderror.lisp debug.lisp \
	spad.lisp bits.lisp setq.lisp property.lisp \
	unlisp.lisp foam_l.lisp axext_l.lisp

depsys_lisp_noncompiled_sources += $(depsys_lisp_macro_sources)
depsys_lisp_SOURCES = $(addsuffix .pamphlet, $(depsys_lisp_sources))
LOADSYS= $(axiom_build_bindir)/lisp$(EXEEXT)
SAVESYS= $(axiom_build_bindir)/interpsys$(EXEEXT)
AXIOMSYS= $(axiom_target_bindir)/AXIOMsys$(EXEEXT)

DEBUGSYS=$(axiom_build_bindir)/debugsys$(EXEEXT)

OBJS=	vmlisp.$(OBJEXT)	hash.$(OBJEXT)	\
	bootfuns.lisp	macros.$(OBJEXT)	\
	unlisp.$(OBJEXT)	setq.lisp	\
	astr.$(OBJEXT)	bits.$(OBJEXT)	\
	alql.$(OBJEXT)	buildom.$(OBJEXT)	\
	cattable.$(OBJEXT)				\
	cformat.$(OBJEXT)	cfuns.$(OBJEXT)	\
	clam.$(OBJEXT)	clammed.$(OBJEXT)	\
	comp.$(OBJEXT)	\
	compat.$(OBJEXT)	compress.$(OBJEXT)	\
	cparse.$(OBJEXT)	cstream.$(OBJEXT)	\
	database.$(OBJEXT)	\
	debug.$(OBJEXT)	dq.$(OBJEXT)		\
	fname.$(OBJEXT)	format.$(OBJEXT)	\
	g-boot.$(OBJEXT)	g-cndata.$(OBJEXT)	\
	g-error.$(OBJEXT)	g-opt.$(OBJEXT)	\
	g-timer.$(OBJEXT)	g-util.$(OBJEXT)	\
	ggreater.$(OBJEXT)				\
	hypertex.$(OBJEXT)	i-analy.$(OBJEXT)	\
	i-code.$(OBJEXT)	i-coerce.$(OBJEXT)	\
	i-coerfn.$(OBJEXT)	i-eval.$(OBJEXT)	\
	i-funsel.$(OBJEXT)	bookvol5.$(OBJEXT)	\
	i-intern.$(OBJEXT)	i-map.$(OBJEXT)	\
	i-output.$(OBJEXT)	i-resolv.$(OBJEXT)	\
	i-spec1.$(OBJEXT)				\
	i-spec2.$(OBJEXT)	i-syscmd.$(OBJEXT)	\
	i-toplev.$(OBJEXT)	i-util.$(OBJEXT)	\
	incl.$(OBJEXT)	int-top.$(OBJEXT)	\
	intfile.$(OBJEXT)				\
	lisplib.$(OBJEXT)	macex.$(OBJEXT)	\
	match.$(OBJEXT)				\
	monitor.$(OBJEXT)	msg.$(OBJEXT)		\
	msgdb.$(OBJEXT)	nci.$(OBJEXT)		\
	newaux.$(OBJEXT)	newfort.$(OBJEXT)	\
	nlib.$(OBJEXT)	nrunfast.$(OBJEXT)	\
	nrungo.$(OBJEXT)	nrunopt.$(OBJEXT)	\
	nruntime.$(OBJEXT)	osyscmd.$(OBJEXT)	\
	packtran.$(OBJEXT)	pathname.$(OBJEXT)	\
	pf2sex.$(OBJEXT)	pile.$(OBJEXT)	\
	posit.$(OBJEXT)	property.lisp	\
	ptrees.$(OBJEXT)	ptrop.$(OBJEXT)	\
	record.$(OBJEXT)				\
	rulesets.$(OBJEXT)	\
	scan.$(OBJEXT)	serror.$(OBJEXT)	\
	server.$(OBJEXT)				\
	setvars.$(OBJEXT)	\
	sfsfun-l.$(OBJEXT)	sfsfun.$(OBJEXT)	\
	simpbool.$(OBJEXT)	slam.$(OBJEXT)	\
	sockio.$(OBJEXT)	spad.$(OBJEXT)	\
	spaderror.$(OBJEXT)				\
	template.$(OBJEXT)	termrw.$(OBJEXT)	\
	trace.$(OBJEXT)	\
	union.$(OBJEXT)       daase.$(OBJEXT)  	\
	fortcall.$(OBJEXT)

AXIOMsys_noncompiled_lisp_sources = bootfuns.lisp nocompil.lisp \
	postprop.lisp property.lisp setq.lisp 

AXIOMsys_compiled_lisp_sources = bits.lisp \
	bootlex.lisp cfuns.lisp comp.lisp construc.lisp daase.lisp \
	debug.lisp def.lisp fname.lisp fnewmeta.lisp ggreater.lisp \
	hash.lisp macros.lisp metalex.lisp monitor.lisp newaux.lisp \
	nlib.lisp nspadaux.lisp parsing.lisp \
	patches.lisp preparse.lisp \
	sockio.lisp spad.lisp spaderror.lisp \
	union.lisp util.lisp vmlisp.lisp obey.lisp \
	unlisp.lisp intint.lisp nci.lisp sfsfun-l.lisp \
	axext_l.lisp foam_l.lisp

AXIOMsys_boot_sources = astr.boot alql.boot buildom.boot cattable.boot \
	cformat.boot clam.boot clammed.boot compat.boot compress.boot \
	cparse.boot cstream.boot database.boot dq.boot format.boot \
	g-boot.boot g-cndata.boot g-error.boot g-opt.boot g-timer.boot \
	g-util.boot hypertex.boot i-analy.boot i-code.boot i-coerce.boot \
	i-coerfn.boot i-eval.boot i-funsel.boot i-intern.boot i-map.boot \
	i-output.boot i-resolv.boot i-spec1.boot i-spec2.boot \
	i-syscmd.boot i-toplev.boot i-util.boot incl.boot int-top.boot \
	intfile.boot lisplib.boot macex.boot match.boot msg.boot \
	msgdb.boot newfort.boot nrunfast.boot nrungo.boot nrunopt.boot \
	nruntime.boot osyscmd.boot packtran.boot pathname.boot \
	pf2sex.boot pile.boot posit.boot ptrees.boot ptrop.boot \
	record.boot rulesets.boot scan.boot serror.boot server.boot \
	setvars.boot sfsfun.boot simpbool.boot slam.boot template.boot \
	termrw.boot trace.boot fortcall.boot
INOBJS=	varini.$(OBJEXT)	parini.$(OBJEXT)	\
	setvart.$(OBJEXT)	intint.$(OBJEXT)	\
        xrun.$(OBJEXT)        interop.$(OBJEXT)     \
        patches.$(OBJEXT)

# These are autloaded old parser files
OPOBJS=	${AUTO}/parsing.$(OBJEXT)	${AUTO}/bootlex.$(OBJEXT)	\
        ${AUTO}/def.$(OBJEXT)	\
	${AUTO}/fnewmeta.$(OBJEXT)	${AUTO}/metalex.$(OBJEXT)	\
	${AUTO}/metameta.$(OBJEXT)	\
	${AUTO}/parse.$(OBJEXT)	${AUTO}/postpar.$(OBJEXT)	\
	${AUTO}/postprop.$(OBJEXT)	${AUTO}/preparse.$(OBJEXT)

autoload_objects += $(OPBJS)
OCOBJS=	${AUTO}/apply.$(OBJEXT)	${AUTO}/c-doc.$(OBJEXT)	\
	${AUTO}/c-util.$(OBJEXT)	${AUTO}/profile.$(OBJEXT)	\
	${AUTO}/category.$(OBJEXT)	${AUTO}/compiler.$(OBJEXT)	\
	${AUTO}/define.$(OBJEXT)	${AUTO}/functor.$(OBJEXT)	\
	${AUTO}/info.$(OBJEXT)	${AUTO}/iterator.$(OBJEXT)	\
	${AUTO}/modemap.$(OBJEXT)	${AUTO}/nruncomp.$(OBJEXT)	\
	${AUTO}/package.$(OBJEXT)	${AUTO}/htcheck.$(OBJEXT)	\
        ${AUTO}/xruncomp.$(OBJEXT)   

autoload_objects += $(OCOBJS)

BROBJS=	${AUTO}/bc-matrix.$(OBJEXT)				\
	${AUTO}/bc-misc.$(OBJEXT)	${AUTO}/bc-solve.$(OBJEXT)	\
	${AUTO}/bc-util.$(OBJEXT)				\
	${AUTO}/ht-util.$(OBJEXT)	${AUTO}/htsetvar.$(OBJEXT)	\
	${AUTO}/ht-root.$(OBJEXT)	\
	${AUTO}/br-con.$(OBJEXT)	\
	${AUTO}/br-data.$(OBJEXT)	${AUTO}/showimp.$(OBJEXT)    \
	${AUTO}/br-op1.$(OBJEXT)	${AUTO}/br-op2.$(OBJEXT)	\
	${AUTO}/br-search.$(OBJEXT)	${AUTO}/br-util.$(OBJEXT)	\
	${AUTO}/topics.$(OBJEXT)     ${AUTO}/br-prof.$(OBJEXT)    \
	${AUTO}/br-saturn.$(OBJEXT)

autoload_objects += $(BFOBJS)

TRANOBJS= ${AUTO}/wi1.$(OBJEXT) ${AUTO}/wi2.$(OBJEXT) ${AUTO}/pspad1.$(OBJEXT) \
	  ${AUTO}/pspad2.$(OBJEXT) ${AUTO}/mark.$(OBJEXT) ${AUTO}/nspadaux.$(OBJEXT) \
	  ${AUTO}/def.$(OBJEXT)

autoload_objects += $(TRANOBJS)

NAGBROBJS= ${AUTO}/nag-c02.$(OBJEXT)   ${AUTO}/nag-c05.$(OBJEXT) \
           ${AUTO}/nag-c06.$(OBJEXT)   ${AUTO}/nag-d01.$(OBJEXT) \
           ${AUTO}/nag-d02.$(OBJEXT)   ${AUTO}/nag-d03.$(OBJEXT) \
           ${AUTO}/nag-e01.$(OBJEXT)   ${AUTO}/nag-e02.$(OBJEXT) \
           ${AUTO}/nag-e04.$(OBJEXT)   ${AUTO}/nag-f01.$(OBJEXT) \
           ${AUTO}/nag-f02.$(OBJEXT)   ${AUTO}/nag-f04.$(OBJEXT) \
           ${AUTO}/nag-f07.$(OBJEXT)   ${AUTO}/nag-s.$(OBJEXT) 

autoload_objects += $(NAGBROBJS)

ASCOMP= hashcode.$(OBJEXT) as.$(OBJEXT) \
	foam_l.$(OBJEXT) axext_l.$(OBJEXT)

ASAUTO= ${AUTO}/ax.$(OBJEXT)

autoload_objects += $(ASAUTO)
TIMESTAMP=$(axiom_targetdir)/timestamp
YEARWEEK=(progn (setq timestamp "${TIMESTAMP}") \
                (setq boot::*build-version* "$(PACKAGE_STRING)") \
                (yearweek))


.PRECIOUS:	${DEPSYS}
.PRECIOUS:	${SAVESYS}
.PRECIOUS:	${AXIOMSYS}

PROCLAIMS=(progn (load "sys-pkg.lisp") (load "$(srcdir)/interp-proclaims.lisp"))

DOCFILES=${DOC}/alql.boot.dvi \
	 ${DOC}/apply.boot.dvi ${DOC}/as.boot.dvi \
	 ${DOC}/astr.boot.dvi ${DOC}/ax.boot.dvi \
	 ${DOC}/axext_l.lisp.dvi \
	 ${DOC}/bc-matrix.boot.dvi ${DOC}/bc-misc.boot.dvi \
	 ${DOC}/bc-solve.boot.dvi ${DOC}/bc-util.boot.dvi \
	 ${DOC}/bits.lisp.dvi ${DOC}/bootfuns.lisp.dvi \
	 ${DOC}/bootlex.lisp.dvi ${DOC}/br-con.boot.dvi \
	 ${DOC}/br-data.boot.dvi ${DOC}/br-op1.boot.dvi \
	 ${DOC}/br-op2.boot.dvi ${DOC}/br-prof.boot.dvi \
	 ${DOC}/br-saturn.boot.dvi ${DOC}/br-search.boot.dvi \
	 ${DOC}/br-util.boot.dvi ${DOC}/buildom.boot.dvi \
	 ${DOC}/category.boot.dvi ${DOC}/cattable.boot.dvi \
	 ${DOC}/c-doc.boot.dvi ${DOC}/cformat.boot.dvi \
	 ${DOC}/cfuns.lisp.dvi ${DOC}/clam.boot.dvi \
	 ${DOC}/clammed.boot.dvi ${DOC}/compat.boot.dvi \
	 ${DOC}/compiler.boot.dvi ${DOC}/comp.lisp.dvi \
	 ${DOC}/compress.boot.dvi \
	 ${DOC}/cparse.boot.dvi ${DOC}/cstream.boot.dvi \
	 ${DOC}/c-util.boot.dvi ${DOC}/daase.lisp.dvi \
	 ${DOC}/database.boot.dvi ${DOC}/debug.lisp.dvi \
	 ${DOC}/define.boot.dvi \
	 ${DOC}/dq.boot.dvi \
	 ${DOC}/fname.lisp.dvi ${DOC}/fnewmeta.lisp.dvi \
	 ${DOC}/foam_l.lisp.dvi \
	 ${DOC}/format.boot.dvi ${DOC}/fortcall.boot.dvi \
	 ${DOC}/functor.boot.dvi ${DOC}/g-boot.boot.dvi \
	 ${DOC}/g-cndata.boot.dvi ${DOC}/g-error.boot.dvi \
	 ${DOC}/ggreater.lisp.dvi ${DOC}/g-opt.boot.dvi \
	 ${DOC}/g-timer.boot.dvi \
	 ${DOC}/g-util.boot.dvi ${DOC}/hashcode.boot.dvi \
	 ${DOC}/hash.lisp.dvi ${DOC}/htcheck.boot.dvi \
	 ${DOC}/ht-root.boot.dvi ${DOC}/htsetvar.boot.dvi \
	 ${DOC}/ht-util.boot.dvi ${DOC}/hypertex.boot.dvi \
	 ${DOC}/i-analy.boot.dvi ${DOC}/i-code.boot.dvi \
	 ${DOC}/i-coerce.boot.dvi ${DOC}/i-coerfn.boot.dvi \
	 ${DOC}/i-eval.boot.dvi ${DOC}/i-funsel.boot.dvi \
	 ${BOOK}/bookvol5.dvi ${DOC}/i-intern.boot.dvi \
	 ${DOC}/i-map.boot.dvi ${DOC}/incl.boot.dvi \
	 ${DOC}/info.boot.dvi ${DOC}/interop.boot.dvi \
	 ${DOC}/intfile.boot.dvi \
	 ${DOC}/intint.lisp.dvi ${DOC}/int-top.boot.dvi \
	 ${DOC}/i-output.boot.dvi ${DOC}/i-resolv.boot.dvi \
	 ${DOC}/i-spec1.boot.dvi ${DOC}/i-spec2.boot.dvi \
	 ${DOC}/i-syscmd.boot.dvi ${DOC}/iterator.boot.dvi \
	 ${DOC}/i-toplev.boot.dvi ${DOC}/i-util.boot.dvi \
	 ${DOC}/lisplib.boot.dvi ${DOC}/macex.boot.dvi \
	 ${DOC}/macros.lisp.dvi ${DOC}/Makefile.dvi \
	 ${DOC}/mark.boot.dvi ${DOC}/match.boot.dvi \
	 ${DOC}/metalex.lisp.dvi ${DOC}/metameta.lisp.dvi \
	 ${DOC}/modemap.boot.dvi ${DOC}/monitor.lisp.dvi \
	 ${DOC}/msg.boot.dvi ${DOC}/msgdb.boot.dvi \
	 ${DOC}/nag-c02.boot.dvi ${DOC}/nag-c05.boot.dvi \
	 ${DOC}/nag-c06.boot.dvi ${DOC}/nag-d01.boot.dvi \
	 ${DOC}/nag-d02.boot.dvi ${DOC}/nag-d03.boot.dvi \
	 ${DOC}/nag-e01.boot.dvi \
	 ${DOC}/nag-e02.boot.dvi \
	 ${DOC}/nag-e04.boot.dvi ${DOC}/nag-f01.boot.dvi \
	 ${DOC}/nag-f02.boot.dvi ${DOC}/nag-f04.boot.dvi \
	 ${DOC}/nag-f07.boot.dvi ${DOC}/nag-s.boot.dvi \
	 ${DOC}/nci.lisp.dvi ${DOC}/newaux.lisp.dvi \
	 ${DOC}/newfort.boot.dvi \
	 ${DOC}/nlib.lisp.dvi ${DOC}/nocompil.lisp.dvi \
	 ${DOC}/nruncomp.boot.dvi ${DOC}/nrunfast.boot.dvi \
	 ${DOC}/nrungo.boot.dvi ${DOC}/nrunopt.boot.dvi \
	 ${DOC}/nruntime.boot.dvi ${DOC}/nspadaux.lisp.dvi \
	 ${DOC}/obey.lisp.dvi ${DOC}/osyscmd.boot.dvi \
	 ${DOC}/package.boot.dvi ${DOC}/packtran.boot.dvi \
	 ${DOC}/parini.boot.dvi ${DOC}/parse.boot.dvi \
	 ${DOC}/parsing.lisp.dvi ${DOC}/patches.lisp.dvi \
	 ${DOC}/pathname.boot.dvi \
	 ${DOC}/pf2sex.boot.dvi ${DOC}/pile.boot.dvi \
	 ${DOC}/posit.boot.dvi ${DOC}/postpar.boot.dvi \
	 ${DOC}/postprop.lisp.dvi ${DOC}/preparse.lisp.dvi \
	 ${DOC}/profile.boot.dvi ${DOC}/property.lisp.dvi \
	 ${DOC}/pspad1.boot.dvi ${DOC}/pspad2.boot.dvi \
	 ${DOC}/ptrees.boot.dvi ${DOC}/ptrop.boot.dvi \
	 ${DOC}/record.boot.dvi \
	 ${DOC}/rulesets.boot.dvi ${DOC}/scan.boot.dvi \
	 ${DOC}/serror.boot.dvi ${DOC}/server.boot.dvi \
	 ${DOC}/setq.lisp.dvi ${DOC}/setvars.boot.dvi \
	 ${DOC}/setvart.boot.dvi ${DOC}/sfsfun.boot.dvi \
	 ${DOC}/sfsfun-l.lisp.dvi \
	 ${DOC}/showimp.boot.dvi ${DOC}/simpbool.boot.dvi \
	 ${DOC}/slam.boot.dvi ${DOC}/sockio.lisp.dvi \
	 ${DOC}/spaderror.lisp.dvi ${DOC}/spad.lisp.dvi \
	 ${DOC}/sys-pkg.lisp.dvi ${DOC}/template.boot.dvi \
	 ${DOC}/termrw.boot.dvi ${DOC}/topics.boot.dvi \
	 ${DOC}/trace.boot.dvi \
	 ${DOC}/union.lisp.dvi ${DOC}/unlisp.lisp.dvi \
	 ${DOC}/util.lisp.dvi ${DOC}/varini.boot.dvi \
	 ${DOC}/vmlisp.lisp.dvi ${DOC}/wi1.boot.dvi \
	 ${DOC}/wi2.boot.dvi \
	 ${DOC}/xrun.boot.dvi ${DOC}/xruncomp.boot.dvi 

UNUSED= ${DOC}/anna.boot.dvi ${DOC}/construc.lisp.dvi \
	${DOC}/domain.lisp.dvi 	${DOC}/guess.boot.dvi \
	${DOC}/interp-fix.boot.dvi \
	${DOC}/nhyper.boot.dvi ${DOC}/pf2atree.boot.dvi \
	${DOC}/redefs.boot.dvi 	${DOC}/word.boot.dvi 


.SUFFIXES:
.SUFFIXES: .boot .clisp .lisp .pamphlet

.PHONY: all all-ax all-depsys all-interpsys all-axiomsys all-debugsys

all: all-ax

all-ax: stamp
	@echo finished $(srcdir)

stamp: $(AUTO) remove-stamp build-images
	$(STAMP) stamp

.PHONY: remove-stamp
remove-stamp:
	-rm -f stamp

.PHONY: build-images
build-images: remove-stamp all-interpsys all-debugsys

all-interpsys: all-depsys 
	$(mkinstalldirs) $(AUTO)
	$(MAKE) $(AX_FLAGS) $(SAVESYS)

all-axiomsys: all-depsys 
	$(MAKE) $(AX_FLAGS) $(AXIOMSYS)

all-debugsys: all-interpsys
	$(MAKE) $(AX_FLAGS) $(DEBUGSYS)

all-depsys: $(DEPSYS)

.PRECIOUS: %.boot
%.boot: $(srcdir)/%.boot.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<
.PRECIOUS: %.clisp
%.clisp: %.boot
	$(BOOT_TO_LISP)
.PRECIOUS: %.$(OBJEXT)
%.$(OBJEXT): %.clisp
	$(COMPILE_LISP)
# Extract and compile the part of the interpreter written
# in Common Lisp
.PRECIOUS: %.lisp
%.$(OBJEXT): %.lisp
	$(COMPILE_LISP)

%.lisp: $(srcdir)/%.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

mostlyclean-local:
	@rm -f *.fn *.data *.o

clean-local: mostlyclean-local
	@rm -f *.clisp *.lsp

distclean-local: clean-local

makeint.lisp:	${DEPSYS} ${OBJS} bookvol5.$(OBJEXT) util.$(OBJEXT) \
                nocompil.lisp sys-pkg.lisp \
	        ${OUTINTERP} ${OCOBJS} ${OPOBJS} ${BROBJS} obey.$(OBJEXT) \
		database.date ${INOBJS} ${ASCOMP} ${ASAUTO} \
		${NAGBROBJS} ${TRANOBJS} \
	        ${LOADSYS} \
		$(axiom_targetdir)/algebra/exposed.$(OBJEXT) \
		$(axiom_src_docdir)/msgs/s2-us.msgs \
	        ../algebra/warm.data
	@ echo 5 invoking make in `pwd` with parms:
	@ echo SYS= ${SYS} 
	@ echo LISP=${LISP} BYE=${BYE}
	$(mkinstalldirs) $(axiom_target_datadir)/msgs
	$(INSTALL_DATA) $(axiom_src_docdir)/msgs/s2-us.msgs \
		 $(axiom_target_datadir)/msgs
	@ echo '${PROCLAIMS}' > makeint.lisp
	@ echo '(load "nocompil.lisp")' >> makeint.lisp
	@ echo '(load "bookvol5")' >> makeint.lisp
	@ echo '(load "util")' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ touch ${TIMESTAMP}
	@ echo '${YEARWEEK}' >> makeint.lisp
	@ echo '(build-interpsys (append (quote ($(patsubst %, "%", ${OBJS}))) (quote ($(patsubst %, "%", ${ASCOMP}))) (quote ($(patsubst %, "%", ${INOBJS})))) (quote ($(patsubst %, "%", ${OPOBJS}))) (quote ($(patsubst %, "%", ${OCOBJS}))) (quote ($(patsubst %, "%", ${BROBJS}))) (quote ($(patsubst %, "%", ${TRANOBJS}))) (quote ($(patsubst %, "%", ${NAGBROBJS}))) (quote ($(patsubst %, "%", ${ASAUTO})))  "${AXIOM}")' >> makeint.lisp
	@ echo '(in-package "SCRATCHPAD-COMPILER")' >> makeint.lisp
	@ echo '(boot::set-restart-hook)' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ echo '(load "../algebra/warm.data")' >> makeint.lisp
	@ echo '(|clearClams|)' >> makeint.lisp
	@ echo '(load "obey")' >> makeint.lisp
	@ echo '#+:akcl (setq compiler::*suppress-compiler-notes* t)' >> makeint.lisp
	@ echo '#+:akcl (si::gbc-time 0)' >> makeint.lisp

${SAVESYS}: makeint.lisp
	echo '(progn (gbc t) (load "makeint.lisp") (gbc t) (user::spad-save "$@"))' | AXIOM="$(AXIOM)" DAASE="$(axiom_src_datadir)" ${LISPSYS}
	@ echo 6 ${SAVESYS} created
	$(mkinstalldirs) $(axiom_target_bindir)
depsys_lisp_sources += parsing.lisp metalex.lisp bootlex.lisp \
			newaux.lisp preparse.lisp postprop.lisp \
			metameta.lisp fnewmeta.lisp

depsys_boot_sources = postpar.boot parse.boot clam.boot slam.boot \
			g-boot.boot c-util.boot g-util.boot

depsys_SOURCES = $(depsys_lisp_SOURCES) $(depsys_boot_SOURCES)

depsys_objects = nocompil.$(OBJEXT) bookvol5.$(OBJEXT) \
		util.$(OBJEXT) postpar.$(OBJEXT) parse.$(OBJEXT) \
		parsing.$(OBJEXT) metalex.$(OBJEXT) bootlex.$(OBJEXT) \
		newaux.$(OBJEXT) preparse.$(OBJEXT) postprop.$(OBJEXT) \
		metameta.$(OBJEXT) fnewmeta.$(OBJEXT) clam.$(OBJEXT) \
		slam.$(OBJEXT) g-boot.$(OBJEXT) c-util.$(OBJEXT) \
		g-util.$(OBJEXT)

${DEPSYS}:	${DEP} sys-pkg.lisp nocompil.lisp \
	        bookvol5.lisp util.lisp \
	        postpar.clisp parse.clisp \
	        parsing.lisp metalex.lisp \
	        bootlex.lisp newaux.lisp \
	        preparse.lisp \
	        postprop.lisp def.lisp \
	        metameta.lisp fnewmeta.lisp \
	        g-boot.${LISP} c-util.${LISP} \
	        g-util.${LISP} \
	        clam.${LISP} \
	        slam.${LISP}
	@ echo 3 making ${DEPSYS} 
	@ $(mkinstalldirs) $(axiom_build_bindir)
	@ echo '(load "sys-pkg.lisp")' > makedep.lisp
	@ echo '(push :oldboot *features*)' >> makedep.lisp
	@ echo '(load "nocompil.lisp")' >> makedep.lisp
	@ echo '(load "bookvol5.lisp")' >> makedep.lisp
	@ echo '(load "util.lisp")' >> makedep.lisp
	@ echo '(in-package "BOOT")' >> makedep.lisp
	@ echo '(build-depsys (quote ($(patsubst %, "%", ${DEP}))) "${AXIOM}" "$(builddir)")' >> makedep.lisp
	@ echo '(unless (probe-file "postpar.$(OBJEXT)") (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "postpar")' >> makedep.lisp
	@ echo '(unless (probe-file "parse.$(OBJEXT)") (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "parse")' >> makedep.lisp
	@ echo '(unless (probe-file "parsing.$(OBJEXT)") (compile-file "parsing.lisp" :output-file "parsing.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "parsing")' >> makedep.lisp
	@ echo '(unless (probe-file "metalex.$(OBJEXT)") (compile-file "metalex.lisp" :output-file "metalex.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "metalex")' >> makedep.lisp
	@ echo '(unless (probe-file "bootlex.$(OBJEXT)") (compile-file "bootlex.lisp" :output-file "bootlex.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "bootlex")' >> makedep.lisp
	@ echo '(unless (probe-file "newaux.$(OBJEXT)") (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "newaux")' >> makedep.lisp
	@ echo '(unless (probe-file "preparse.$(OBJEXT)") (compile-file "preparse.lisp" :output-file "preparse.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "preparse")' >> makedep.lisp
	@ echo '(unless (probe-file "postprop.$(OBJEXT)") (compile-file "postprop.lisp" :output-file "postprop.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "postprop")' >> makedep.lisp
	@ echo '(unless (probe-file "def.$(OBJEXT)") (compile-file "def.lisp" :output-file "def.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "def")' >> makedep.lisp
	@ echo '(unless (probe-file "metameta.$(OBJEXT)") (compile-file "metameta.lisp" :output-file "metameta.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "metameta")' >> makedep.lisp
	@ echo '(unless (probe-file "fnewmeta.$(OBJEXT)") (compile-file "fnewmeta.lisp" :output-file "fnewmeta.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "fnewmeta")' >> makedep.lisp
	@ echo '(unless (probe-file "clam.$(OBJEXT)") (compile-file "clam.${LISP}" :output-file "clam.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "clam")' >> makedep.lisp
	@ echo '(unless (probe-file "slam.$(OBJEXT)") (compile-file "slam.${LISP}" :output-file "slam.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "slam")' >> makedep.lisp
	@ echo '(unless (probe-file "g-boot.$(OBJEXT)") (compile-file "g-boot.${LISP}" :output-file "g-boot.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "g-boot")' >> makedep.lisp
	@ echo '(unless (probe-file "c-util.$(OBJEXT)") (compile-file "c-util.${LISP}" :output-file "c-util.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "c-util")' >> makedep.lisp
	@ echo '(unless (probe-file "g-util.$(OBJEXT)") (compile-file "g-util.${LISP}" :output-file "g-util.$(OBJEXT)"))' >> makedep.lisp
	@ echo '(load "g-util")' >> makedep.lisp
	@ echo '(progn (load "makedep.lisp") (spad-save "$@"))' \
               | AXIOM="$(AXIOM)" $(LISPSYS)
	@ echo 4 ${DEPSYS} created
.PHONY: all-axiomsys

all-axiomsys: ${AXIOMSYS}

${AXIOMSYS}: makeint.lisp
	echo '(progn (gbc t) (load "makeint.lisp") (gbc t)' \
	   '(user::spad-save "$@"))' | \
		AXIOM="$(AXIOM)" DAASE="$(axiom_targetdir)" ${LISPSYS}
	@ echo 6a ${AXIOMSYS} created
${DEBUGSYS}: debugsys.lisp
	@ echo 7 building debugsys
	@ echo '(progn (gbc t) (load "debugsys.lisp") (user::spad-save "$@"))' | ${LISPSYS}
	@ echo 8 ${DEBUGSYS} created

exposed.lsp: $(axiom_src_algdir)/exposed.lsp.pamphlet
	@ echo 615 making exposed.lsp from $(axiom_src_algdir)/exposed.lsp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

$(axiom_targetdir)/algebra/exposed.$(OBJEXT) : exposed.lsp ${LISPSYS}
	@ echo 616 making $@ from exposed.lsp
	$(mkinstalldirs) $(axiom_targetdir)/algebra
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "exposed.lsp" :output-file "$(axiom_targetdir)/algebra/exposed.$(OBJEXT)"))' | ${LISPSYS} ; \
	  else \
	   echo '(progn  (compile-file "exposed.lsp" :output-file "$(axiom_targetdir)/algebra/exposed.$(OBJEXT)"))' | ${LISPSYS} >> ${TMP}/trace ; \
	  fi

database.date:
	@ echo 617 the database was updated...remaking interpsys
	@ touch database.date


${AUTO}/apply.$(OBJEXT): apply.$(OBJEXT)
	@ echo 9 making ${AUTO}/apply.$(OBJEXT) from apply.$(OBJEXT)
	@ cp apply.$(OBJEXT) ${AUTO}

apply.$(OBJEXT): apply.clisp 
	@ echo 10 making apply.$(OBJEXT) from apply.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "apply.clisp" :output-file "apply.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "apply.clisp" :output-file "apply.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

apply.clisp: apply.boot
	@ echo 11 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "apply.boot"))' | ${DEPSYS} ; \
	   else \
	   echo '(progn (boottran::boottocl "apply.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
           fi ;


as.$(OBJEXT): as.clisp 
	@ echo 416 making as.$(OBJEXT) from as.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "as.clisp" :output-file "as.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "as.clisp" :output-file "as.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

as.clisp: as.boot
	@ echo 417 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "as.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "as.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/ax.$(OBJEXT): ax.$(OBJEXT)
	@ echo 461 making ${AUTO}/ax.$(OBJEXT) from ax.$(OBJEXT)
	@ cp ax.$(OBJEXT) ${AUTO}

ax.$(OBJEXT): ax.clisp 
	@ echo 462 making ax.$(OBJEXT) from ax.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ax.clisp" :output-file "ax.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ax.clisp" :output-file "ax.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

ax.clisp: ax.boot
	@ echo 463 making $@ $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ax.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ax.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/bc-matrix.$(OBJEXT): bc-matrix.$(OBJEXT)
	@ echo 422 making ${AUTO}/bc-matrix.$(OBJEXT) from bc-matrix.$(OBJEXT)
	@ cp bc-matrix.$(OBJEXT) ${AUTO}

bc-matrix.$(OBJEXT): bc-matrix.clisp 
	@ echo 423 making bc-matrix.$(OBJEXT) from bc-matrix.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-matrix.clisp" :output-file "bc-matrix.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-matrix.clisp" :output-file "bc-matrix.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

bc-matrix.clisp: bc-matrix.boot
	@ echo 424 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-matrix.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-matrix.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/bc-misc.$(OBJEXT): bc-misc.$(OBJEXT)
	@ echo 426 making ${AUTO}/bc-misc.$(OBJEXT) from bc-misc.$(OBJEXT)
	@ cp bc-misc.$(OBJEXT) ${AUTO}

bc-misc.$(OBJEXT): bc-misc.clisp 
	@ echo 427 making bc-misc.$(OBJEXT) from bc-misc.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-misc.clisp" :output-file "bc-misc.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-misc.clisp" :output-file "bc-misc.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

bc-misc.clisp: bc-misc.boot
	@ echo 428 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-misc.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-misc.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/bc-solve.$(OBJEXT): bc-solve.$(OBJEXT)
	@ echo 430 making ${AUTO}/bc-solve.$(OBJEXT) from bc-solve.$(OBJEXT)
	@ cp bc-solve.$(OBJEXT) ${AUTO}

bc-solve.$(OBJEXT): bc-solve.clisp 
	@ echo 431 making bc-solve.$(OBJEXT) from bc-solve.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-solve.clisp" :output-file "bc-solve.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-solve.clisp" :output-file "bc-solve.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

bc-solve.clisp: bc-solve.boot
	@ echo 432 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-solve.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-solve.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/bc-util.$(OBJEXT): bc-util.$(OBJEXT)
	@ echo 434 making ${AUTO}/bc-util.$(OBJEXT) from bc-util.$(OBJEXT)
	@ cp bc-util.$(OBJEXT) ${AUTO}

bc-util.$(OBJEXT): bc-util.clisp 
	@ echo 435 making bc-util.$(OBJEXT) from bc-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bc-util.clisp" :output-file "bc-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bc-util.clisp" :output-file "bc-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

bc-util.clisp: bc-util.boot
	@ echo 436 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "bc-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "bc-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/bootlex.$(OBJEXT): bootlex.$(OBJEXT)
	@ echo 19 making ${AUTO}/bootlex.$(OBJEXT) from bootlex.$(OBJEXT)
	@ cp bootlex.$(OBJEXT) ${AUTO}


${AUTO}/br-con.$(OBJEXT): br-con.$(OBJEXT)
	@ echo 465 making ${AUTO}/br-con.$(OBJEXT) from br-con.$(OBJEXT)
	@ cp br-con.$(OBJEXT) ${AUTO}

br-con.$(OBJEXT): br-con.clisp 
	@ echo 466 making br-con.$(OBJEXT) from br-con.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-con.clisp" :output-file "br-con.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-con.clisp" :output-file "br-con.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-con.clisp: br-con.boot
	@ echo 467 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-con.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-con.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/br-data.$(OBJEXT): br-data.$(OBJEXT)
	@ echo 481 making ${AUTO}/br-data.$(OBJEXT) from br-data.$(OBJEXT)
	@ cp br-data.$(OBJEXT) ${AUTO}

br-data.$(OBJEXT): br-data.clisp 
	@ echo 482 making br-data.$(OBJEXT) from br-data.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-data.clisp" :output-file "br-data.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-data.clisp" :output-file "br-data.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-data.clisp: br-data.boot
	@ echo 483 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-data.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-data.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/br-op1.$(OBJEXT): br-op1.$(OBJEXT)
	@ echo 473 making ${AUTO}/br-op1.$(OBJEXT) from br-op1.$(OBJEXT)
	@ cp br-op1.$(OBJEXT) ${AUTO}

br-op1.$(OBJEXT): br-op1.clisp 
	@ echo 474 making br-op1.$(OBJEXT) from br-op1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-op1.clisp" :output-file "br-op1.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-op1.clisp" :output-file "br-op1.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-op1.clisp: br-op1.boot
	@ echo 475 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-op1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-op1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/br-op2.$(OBJEXT): br-op2.$(OBJEXT)
	@ echo 477 making ${AUTO}/br-op2.$(OBJEXT) from br-op2.$(OBJEXT)
	@ cp br-op2.$(OBJEXT) ${AUTO}

br-op2.$(OBJEXT): br-op2.clisp 
	@ echo 478 making br-op2.$(OBJEXT) from br-op2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-op2.clisp" :output-file "br-op2.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-op2.clisp" :output-file "br-op2.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-op2.clisp: br-op2.boot
	@ echo 479 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-op2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-op2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/br-prof.$(OBJEXT): br-prof.$(OBJEXT)
	@ echo 497 making ${AUTO}/br-prof.$(OBJEXT) from br-prof.$(OBJEXT)
	@ cp br-prof.$(OBJEXT) ${AUTO}

br-prof.$(OBJEXT): br-prof.clisp 
	@ echo 498 making br-prof.$(OBJEXT) from br-prof.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-prof.clisp" :output-file "br-prof.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-prof.clisp" :output-file "br-prof.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-prof.clisp: br-prof.boot
	@ echo 499 making $@ from $<
	@ ($(axiom_build_document) --tangle --output=br-prof.boot $< ;\
	  if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-prof.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-prof.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi ; \
	  rm br-prof.boot )


${AUTO}/br-saturn.$(OBJEXT): br-saturn.$(OBJEXT)
	@ echo 489 making ${AUTO}/br-saturn.$(OBJEXT) from br-saturn.$(OBJEXT)
	@ cp br-saturn.$(OBJEXT) ${AUTO}

br-saturn.$(OBJEXT): br-saturn.clisp 
	@ echo 490 making br-saturn.$(OBJEXT) from br-saturn.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-saturn.clisp" :output-file "br-saturn.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-saturn.clisp" :output-file "br-saturn.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-saturn.clisp: br-saturn.boot
	@ echo 491 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-saturn.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-saturn.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/br-search.$(OBJEXT): br-search.$(OBJEXT)
	@ echo 469 making ${AUTO}/br-search.$(OBJEXT) from br-search.$(OBJEXT)
	@ cp br-search.$(OBJEXT) ${AUTO}

br-search.$(OBJEXT): br-search.clisp 
	@ echo 470 making br-search.$(OBJEXT) from br-search.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-search.clisp" :output-file "br-search.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-search.clisp" :output-file "br-search.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-search.clisp: br-search.boot
	@ echo 471 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-search.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-search.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/br-util.$(OBJEXT): br-util.$(OBJEXT)
	@ echo 485 making ${AUTO}/br-util.$(OBJEXT) from br-util.$(OBJEXT)
	@ cp br-util.$(OBJEXT) ${AUTO}

br-util.$(OBJEXT): br-util.clisp 
	@ echo 486 making br-util.$(OBJEXT) from br-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "br-util.clisp" :output-file "br-util.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "br-util.clisp" :output-file "br-util.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

br-util.clisp: br-util.boot
	@ echo 487 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "br-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "br-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


buildom.$(OBJEXT): buildom.clisp 
	@ echo 142 making buildom.$(OBJEXT) from buildom.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "buildom.clisp" :output-file "buildom.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "buildom.clisp" :output-file "buildom.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

buildom.clisp: buildom.boot
	@ echo 143 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "buildom.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "buildom.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/category.$(OBJEXT): category.$(OBJEXT)
	@ echo 210 making ${AUTO}/ category.$(OBJEXT) from category.$(OBJEXT)
	@ cp category.$(OBJEXT) ${AUTO}

category.$(OBJEXT): category.clisp 
	@ echo 211 making category.$(OBJEXT) from category.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "category.clisp" :output-file "category.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "category.clisp" :output-file "category.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

category.clisp: category.boot
	@ echo 212 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "category.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "category.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


cattable.$(OBJEXT): cattable.clisp 
	@ echo 214 making cattable.$(OBJEXT) from cattable.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "cattable.clisp" :output-file "cattable.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "cattable.clisp" :output-file "cattable.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

cattable.clisp: cattable.boot
	@ echo 215 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "cattable.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "cattable.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/c-doc.$(OBJEXT): c-doc.$(OBJEXT)
	@ echo 217 making ${AUTO}/c-doc.$(OBJEXT) from c-doc.$(OBJEXT)
	@ cp c-doc.$(OBJEXT) ${AUTO}

c-doc.$(OBJEXT): c-doc.clisp 
	@ echo 218 making c-doc.$(OBJEXT) from c-doc.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "c-doc.clisp" :output-file "c-doc.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "c-doc.clisp" :output-file "c-doc.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

c-doc.clisp: c-doc.boot
	@ echo 219 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "c-doc.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "c-doc.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


clam.${LISP}: $(srcdir)/clam.boot.pamphlet
	@ echo 221 making clam.${LISP} from $(srcdir)/clam.boot.pamphlet
	@ rm -f clam.$(OBJEXT)
	$(axiom_build_document) --tangle=clam.clisp --output=$@ $<
clam.$(OBJEXT): clam.clisp 
	@ echo 222 making clam.$(OBJEXT) from clam.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "clam.clisp" :output-file "clam.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "clam.clisp" :output-file "clam.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

clam.clisp: clam.boot
	@ echo 223 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "clam.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "clam.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


clammed.$(OBJEXT): clammed.clisp 
	@ echo 225 making clammed.$(OBJEXT) from clammed.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "clammed.clisp" :output-file "clammed.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "clammed.clisp" :output-file "clammed.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

clammed.clisp: clammed.boot
	@ echo 226 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "clammed.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "clammed.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


compat.$(OBJEXT): compat.clisp 
	@ echo 228 making compat.$(OBJEXT) from compat.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compat.clisp" :output-file "compat.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "compat.clisp" :output-file "compat.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

compat.clisp: compat.boot
	@ echo 229 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compat.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compat.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/compiler.$(OBJEXT): compiler.$(OBJEXT)
	@ echo 231 making ${AUTO}/compiler.$(OBJEXT) from compiler.$(OBJEXT)
	@ cp compiler.$(OBJEXT) ${AUTO}

compiler.$(OBJEXT): compiler.clisp 
	@ echo 232 making compiler.$(OBJEXT) from compiler.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compiler.clisp" :output-file "compiler.$(OBJEXT)"))' | ${DEPSYS} ; \
          else \
	   echo '(progn  (compile-file "compiler.clisp" :output-file "compiler.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

compiler.clisp: compiler.boot
	@ echo 233 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compiler.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compiler.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


compress.$(OBJEXT): compress.clisp 
	@ echo 239 making compress.$(OBJEXT) from compress.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "compress.clisp" :output-file "compress.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "compress.clisp" :output-file "compress.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

compress.clisp: compress.boot
	@ echo 240 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "compress.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "compress.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/c-util.$(OBJEXT): c-util.$(OBJEXT)
	@ echo 145 making ${AUTO}/c-util.$(OBJEXT) from c-util.$(OBJEXT)
	@ cp c-util.$(OBJEXT) ${AUTO}

c-util.${LISP}: $(srcdir)/c-util.boot.pamphlet
	@ echo 146 making c-util.${LISP} from $(srcdir)/c-util.boot.pamphlet
	@ rm -f c-util.$(OBJEXT)
	$(axiom_build_document) --tangle=c-util.clisp --output=$@ $<

c-util.$(OBJEXT): c-util.clisp 
	@ echo 147 making c-util.$(OBJEXT) from c-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "c-util.clisp" :output-file "c-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "c-util.clisp" :output-file "c-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

c-util.clisp: c-util.boot
	@ echo 148 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "c-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "c-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


database.$(OBJEXT): database.clisp 
	@ echo 242 making database.$(OBJEXT) from database.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "database.clisp" :output-file "database.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "database.clisp" :output-file "database.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

database.clisp: database.boot
	@ echo 243 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "database.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "database.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


debugsys.lisp: $(srcdir)/debugsys.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

${AUTO}/def.$(OBJEXT): def.$(OBJEXT)
	@ echo 41 making ${AUTO}/def.$(OBJEXT) from def.$(OBJEXT)
	@ cp def.$(OBJEXT) ${AUTO}


${AUTO}/define.$(OBJEXT): define.$(OBJEXT)
	@ echo 245 making ${AUTO}/define.$(OBJEXT) from define.$(OBJEXT)
	@ cp define.$(OBJEXT) ${AUTO}

define.$(OBJEXT): define.clisp 
	@ echo 246 making define.$(OBJEXT) from define.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "define.clisp" :output-file "define.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "define.clisp" :output-file "define.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

define.clisp: define.boot
	@ echo 247 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "define.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "define.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/fnewmeta.$(OBJEXT): fnewmeta.$(OBJEXT)
	@ echo 49 making ${AUTO}/fnewmeta.$(OBJEXT) from fnewmeta.$(OBJEXT)
	@ cp fnewmeta.$(OBJEXT) ${AUTO}


format.$(OBJEXT): format.clisp 
	@ echo 249 making format.$(OBJEXT) from format.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "format.clisp" :output-file "format.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "format.clisp" :output-file "format.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

format.clisp: format.boot
	@ echo 250 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "format.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "format.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


fortcall.$(OBJEXT): fortcall.clisp 
	@ echo 54 making fortcall.$(OBJEXT) from fortcall.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "fortcall.clisp" :output-file "fortcall.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "fortcall.clisp" :output-file "fortcall.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

fortcall.clisp: fortcall.boot
	@ echo 55 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "fortcall.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "fortcall.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/functor.$(OBJEXT): functor.$(OBJEXT)
	@ echo 252 making ${AUTO}/functor.$(OBJEXT) from functor.$(OBJEXT)
	@ cp functor.$(OBJEXT) ${AUTO}

functor.$(OBJEXT): functor.clisp 
	@ echo 253 making functor.$(OBJEXT) from functor.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "functor.clisp" :output-file "functor.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "functor.clisp" :output-file "functor.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

functor.clisp: functor.boot
	@ echo 254 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "functor.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "functor.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-boot.${LISP}: $(srcdir)/g-boot.boot.pamphlet
	@ echo 256 making g-boot.${LISP} from $(srcdir)/g-boot.boot.pamphlet
	@ rm -f g-boot.$(OBJEXT)
	$(axiom_build_document) --tangle=g-boot.clisp --output=$@ $<
g-boot.$(OBJEXT): g-boot.clisp 
	@ echo 257 making g-boot.$(OBJEXT) from g-boot.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-boot.clisp" :output-file "g-boot.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-boot.clisp" :output-file "g-boot.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-boot.clisp: g-boot.boot
	@ echo 258 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-boot.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-boot.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-cndata.$(OBJEXT): g-cndata.clisp 
	@ echo 260 making g-cndata.$(OBJEXT) from g-cndata.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-cndata.clisp" :output-file "g-cndata.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-cndata.clisp" :output-file "g-cndata.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-cndata.clisp: g-cndata.boot
	@ echo 261 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-cndata.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-cndata.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-error.$(OBJEXT): g-error.clisp 
	@ echo 263 making g-error.$(OBJEXT) from g-error.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-error.clisp" :output-file "g-error.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-error.clisp" :output-file "g-error.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-error.clisp: g-error.boot
	@ echo 264 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-error.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-error.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-opt.$(OBJEXT): g-opt.clisp 
	@ echo 266 making g-opt.$(OBJEXT) from g-opt.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-opt.clisp" :output-file "g-opt.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-opt.clisp" :output-file "g-opt.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-opt.clisp: g-opt.boot
	@ echo 267 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-opt.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-opt.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-timer.$(OBJEXT): g-timer.clisp 
	@ echo 269 making g-timer.$(OBJEXT) from g-timer.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-timer.clisp" :output-file "g-timer.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-timer.clisp" :output-file "g-timer.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-timer.clisp: g-timer.boot
	@ echo 270 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-timer.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-timer.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


g-util.${LISP}: $(srcdir)/g-util.boot.pamphlet
	@ echo 272 making g-util.${LISP} from $(srcdir)/g-util.boot.pamphlet
	@ rm -f g-util.$(OBJEXT)
	$(axiom_build_document) --tangle=g-util.clisp --output=$@ $<
g-util.$(OBJEXT): g-util.clisp 
	@ echo 273 making g-util.$(OBJEXT) from g-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "g-util.clisp" :output-file "g-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "g-util.clisp" :output-file "g-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

g-util.clisp: g-util.boot
	@ echo 274 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "g-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "g-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi



hashcode.$(OBJEXT): hashcode.clisp 
	@ echo 583 making hashcode.$(OBJEXT) from hashcode.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "hashcode.clisp" :output-file "hashcode.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "hashcode.clisp" :output-file "hashcode.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

hashcode.clisp: hashcode.boot
	@ echo 584 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "hashcode.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "hashcode.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/htcheck.$(OBJEXT): htcheck.$(OBJEXT)
	@ echo 453 making ${AUTO}/htcheck.$(OBJEXT) from htcheck.$(OBJEXT)
	@ cp htcheck.$(OBJEXT) ${AUTO}

htcheck.$(OBJEXT): htcheck.clisp 
	@ echo 454 making htcheck.$(OBJEXT) from htcheck.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "htcheck.clisp" :output-file "htcheck.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "htcheck.clisp" :output-file "htcheck.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

htcheck.clisp: htcheck.boot
	@ echo 455 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "htcheck.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "htcheck.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/ht-root.$(OBJEXT): ht-root.$(OBJEXT)
	@ echo 449 making ${AUTO}/ht-root.$(OBJEXT) from ht-root.$(OBJEXT)
	@ cp ht-root.$(OBJEXT) ${AUTO}

ht-root.$(OBJEXT): ht-root.clisp 
	@ echo 450 making ht-root.$(OBJEXT) from ht-root.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ht-root.clisp" :output-file "ht-root.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ht-root.clisp" :output-file "ht-root.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

ht-root.clisp: ht-root.boot
	@ echo 451 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ht-root.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ht-root.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/htsetvar.$(OBJEXT): htsetvar.$(OBJEXT)
	@ echo 442 making ${AUTO}/htsetvar.$(OBJEXT) from htsetvar.$(OBJEXT)
	@ cp htsetvar.$(OBJEXT) ${AUTO}

htsetvar.$(OBJEXT): htsetvar.clisp 
	@ echo 443 making htsetvar.$(OBJEXT) from htsetvar.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "htsetvar.clisp" :output-file "htsetvar.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "htsetvar.clisp" :output-file "htsetvar.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

htsetvar.clisp: htsetvar.boot
	@ echo 444 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "htsetvar.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "htsetvar.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/ht-util.$(OBJEXT): ht-util.$(OBJEXT)
	@ echo 438 making ${AUTO}/ht-util.$(OBJEXT) from ht-util.$(OBJEXT)
	@ cp ht-util.$(OBJEXT) ${AUTO}

ht-util.$(OBJEXT): ht-util.clisp 
	@ echo 439 making ht-util.$(OBJEXT) from ht-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "ht-util.clisp" :output-file "ht-util.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "ht-util.clisp" :output-file "ht-util.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

ht-util.clisp: ht-util.boot
	@ echo 440 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "ht-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "ht-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


hypertex.$(OBJEXT): hypertex.clisp 
	@ echo 276 making hypertex.$(OBJEXT) from hypertex.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "hypertex.clisp" :output-file "hypertex.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "hypertex.clisp" :output-file "hypertex.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

hypertex.clisp: hypertex.boot
	@ echo 277 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "hypertex.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "hypertex.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-analy.$(OBJEXT): i-analy.clisp 
	@ echo 279 making i-analy.$(OBJEXT) from i-analy.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-analy.clisp" :output-file "i-analy.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-analy.clisp" :output-file "i-analy.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-analy.clisp: i-analy.boot
	@ echo 280 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-analy.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-analy.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-code.$(OBJEXT): i-code.clisp 
	@ echo 282 making i-code.$(OBJEXT) from i-code.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-code.clisp" :output-file "i-code.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-code.clisp" :output-file "i-code.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-code.clisp: i-code.boot
	@ echo 283 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-code.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-code.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-coerce.$(OBJEXT): i-coerce.clisp 
	@ echo 285 making i-coerce.$(OBJEXT) from i-coerce.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-coerce.clisp" :output-file "i-coerce.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-coerce.clisp" :output-file "i-coerce.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-coerce.clisp: i-coerce.boot
	@ echo 286 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-coerce.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-coerce.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-coerfn.$(OBJEXT): i-coerfn.clisp 
	@ echo 288 making i-coerfn.$(OBJEXT) from i-coerfn.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-coerfn.clisp" :output-file "i-coerfn.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-coerfn.clisp" :output-file "i-coerfn.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-coerfn.clisp: i-coerfn.boot
	@ echo 289 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-coerfn.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-coerfn.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-eval.$(OBJEXT): i-eval.clisp 
	@ echo 291 making i-eval.$(OBJEXT) from i-eval.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-eval.clisp" :output-file "i-eval.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-eval.clisp" :output-file "i-eval.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-eval.clisp: i-eval.boot
	@ echo 292 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-eval.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-eval.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-funsel.$(OBJEXT): i-funsel.clisp 
	@ echo 294 making i-funsel.$(OBJEXT) from i-funsel.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-funsel.clisp" :output-file "i-funsel.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-funsel.clisp" :output-file "i-funsel.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-funsel.clisp: i-funsel.boot
	@ echo 295 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-funsel.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-funsel.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


bookvol5.$(OBJEXT): bookvol5.lisp
	@ echo 297 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "bookvol5.lisp" :output-file "bookvol5.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "bookvol5.lisp" :output-file "bookvol5.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

bookvol5.lisp: $(srcdir)/bookvol5.pamphlet
	@ echo 298 making $@ from $<
	$(axiom_build_document) --tangle=Interpreter --output=$@ $<

i-intern.$(OBJEXT): i-intern.clisp 
	@ echo 300 making i-intern.$(OBJEXT) from i-intern.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-intern.clisp" :output-file "i-intern.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-intern.clisp" :output-file "i-intern.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	 fi

i-intern.clisp: i-intern.boot
	@ echo 301 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-intern.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-intern.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


interop.$(OBJEXT): interop.clisp
	@ echo 586 making interop.$(OBJEXT) from interop.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "interop.clisp" :output-file "interop.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "interop.clisp" :output-file "interop.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

interop.clisp: interop.boot
	@ echo 587 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "interop.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "interop.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-map.$(OBJEXT): i-map.clisp 
	@ echo 303 making i-map.$(OBJEXT) from i-map.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-map.clisp" :output-file "i-map.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-map.clisp" :output-file "i-map.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-map.clisp: i-map.boot
	@ echo 304 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-map.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-map.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/info.$(OBJEXT): info.$(OBJEXT)
	@ echo 327 making ${AUTO}/info.$(OBJEXT) from info.$(OBJEXT)
	@ cp info.$(OBJEXT) ${AUTO}

info.$(OBJEXT): info.clisp 
	@ echo 328 making info.$(OBJEXT) from info.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "info.clisp" :output-file "info.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "info.clisp" :output-file "info.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

info.clisp: info.boot
	@ echo 329 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "info.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "info.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-output.$(OBJEXT): i-output.clisp 
	@ echo 306 making i-output.$(OBJEXT) from i-output.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-output.clisp" :output-file "i-output.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-output.clisp" :output-file "i-output.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-output.clisp: i-output.boot
	@ echo 307 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-output.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-output.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


i-resolv.$(OBJEXT): i-resolv.clisp 
	@ echo 309 making i-resolv.$(OBJEXT) from i-resolv.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-resolv.clisp" :output-file "i-resolv.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-resolv.clisp" :output-file "i-resolv.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-resolv.clisp: i-resolv.boot
	@ echo 310 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-resolv.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-resolv.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-spec1.$(OBJEXT): i-spec1.clisp 
	@ echo 312 making i-spec1.$(OBJEXT) from i-spec1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-spec1.clisp" :output-file "i-spec1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-spec1.clisp" :output-file "i-spec1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-spec1.clisp: i-spec1.boot
	@ echo 313 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-spec1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-spec1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-spec2.$(OBJEXT): i-spec2.clisp 
	@ echo 315 making i-spec2.$(OBJEXT) from i-spec2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-spec2.clisp" :output-file "i-spec2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-spec2.clisp" :output-file "i-spec2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-spec2.clisp: i-spec2.boot
	@ echo 316 making $@ from i-spec2.boot
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-spec2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-spec2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-syscmd.$(OBJEXT): i-syscmd.clisp 
	@ echo 318 making i-syscmd.$(OBJEXT) from i-syscmd.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-syscmd.clisp" :output-file "i-syscmd.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-syscmd.clisp" :output-file "i-syscmd.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

i-syscmd.clisp: i-syscmd.boot
	@ echo 319 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-syscmd.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-syscmd.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/iterator.$(OBJEXT): iterator.$(OBJEXT)
	@ echo 331 making ${AUTO}/iterator.$(OBJEXT) from iterator.$(OBJEXT)
	@ cp iterator.$(OBJEXT) ${AUTO}

iterator.$(OBJEXT): iterator.clisp 
	@ echo 332 making iterator.$(OBJEXT) from iterator.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "iterator.clisp" :output-file "iterator.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "iterator.clisp" :output-file "iterator.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

iterator.clisp: iterator.boot
	@ echo 333 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "iterator.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "iterator.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-toplev.$(OBJEXT): i-toplev.clisp 
	@ echo 321 making i-toplev.$(OBJEXT) from i-toplev.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-toplev.clisp" :output-file "i-toplev.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-toplev.clisp" :output-file "i-toplev.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
          fi

i-toplev.clisp: i-toplev.boot
	@ echo 322 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-toplev.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-toplev.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


i-util.$(OBJEXT): i-util.clisp 
	@ echo 324 making i-util.$(OBJEXT) from i-util.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "i-util.clisp" :output-file "i-util.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "i-util.clisp" :output-file "i-util.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
          fi

i-util.clisp: i-util.boot
	@ echo 325 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "i-util.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "i-util.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


lisplib.$(OBJEXT): lisplib.clisp 
	@ echo 335 making lisplib.$(OBJEXT) from lisplib.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "lisplib.clisp" :output-file "lisplib.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "lisplib.clisp" :output-file "lisplib.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

lisplib.clisp: lisplib.boot
	@ echo 336 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "lisplib.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "lisplib.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/mark.$(OBJEXT): mark.clisp 
	@ echo 604 making ${AUTO}/mark.$(OBJEXT) from mark.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "mark.clisp" :output-file "${AUTO}/mark.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "mark.clisp" :output-file "${AUTO}/mark.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

mark.clisp: mark.boot
	@ echo 605 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "mark.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "mark.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


match.$(OBJEXT): match.clisp 
	@ echo 338 making match.$(OBJEXT) from match.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "match.clisp" :output-file "match.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "match.clisp" :output-file "match.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

match.clisp: match.boot
	@ echo 339 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "match.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "match.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/metalex.$(OBJEXT): metalex.$(OBJEXT)
	@ echo 66 making ${AUTO}/metalex.$(OBJEXT) from metalex.$(OBJEXT)
	@ cp metalex.$(OBJEXT) ${AUTO}


${AUTO}/metameta.$(OBJEXT): metameta.$(OBJEXT)
	@ echo 71 making ${AUTO}/metameta.$(OBJEXT) from metameta.$(OBJEXT)
	@ cp metameta.$(OBJEXT) ${AUTO}


${AUTO}/modemap.$(OBJEXT): modemap.$(OBJEXT)
	@ echo 341 making ${AUTO}/modemap.$(OBJEXT) from modemap.$(OBJEXT)
	@ cp modemap.$(OBJEXT) ${AUTO}

modemap.$(OBJEXT): modemap.clisp 
	@ echo 342 making modemap.$(OBJEXT) from modemap.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "modemap.clisp" :output-file "modemap.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "modemap.clisp" :output-file "modemap.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

modemap.clisp: modemap.boot
	@ echo 343 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "modemap.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "modemap.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


msgdb.$(OBJEXT): msgdb.clisp 
	@ echo 345 making msgdb.$(OBJEXT) from msgdb.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "msgdb.clisp" :output-file "msgdb.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "msgdb.clisp" :output-file "msgdb.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

msgdb.clisp: msgdb.boot
	@ echo 346 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "msgdb.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "msgdb.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nag-c02.$(OBJEXT): nag-c02.$(OBJEXT)
	@ echo 150 making${AUTO}/nag-c02.$(OBJEXT) from nag-c02.$(OBJEXT)
	@ cp nag-c02.$(OBJEXT) ${AUTO}

nag-c02.$(OBJEXT): nag-c02.clisp
	@ echo 151 making nag-c02.$(OBJEXT) from nag-c02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-c02.clisp" :output-file "nag-c02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-c02.clisp" :output-file "nag-c02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-c02.clisp: nag-c02.boot
	@ echo 152 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nag-c05.$(OBJEXT): nag-c05.$(OBJEXT)
	@ echo 154 making ${AUTO}/nag-c05.$(OBJEXT) from nag-c05.$(OBJEXT)
	@ cp nag-c05.$(OBJEXT) ${AUTO}

nag-c05.$(OBJEXT): nag-c05.clisp
	@ echo 155 making nag-c05.$(OBJEXT) from nag-c05.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-c05.clisp" :output-file "nag-c05.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-c05.clisp" :output-file "nag-c05.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-c05.clisp: nag-c05.boot
	@ echo 156 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c05.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c05.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nag-c06.$(OBJEXT): nag-c06.$(OBJEXT)
	@ echo 158 making${AUTO}/nag-c06.$(OBJEXT) from nag-c06.$(OBJEXT)
	@ cp nag-c06.$(OBJEXT) ${AUTO}

nag-c06.$(OBJEXT): nag-c06.clisp
	@ echo 159 making nag-c06.$(OBJEXT) from nag-c06.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-c06.clisp" :output-file "nag-c06.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-c06.clisp" :output-file "nag-c06.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-c06.clisp: nag-c06.boot
	@ echo 160 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c06.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-c06.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-d01.$(OBJEXT): nag-d01.$(OBJEXT)
	@ echo 162 making${AUTO}/nag-d01.$(OBJEXT) from nag-d01.$(OBJEXT)
	@ cp nag-d01.$(OBJEXT) ${AUTO}

nag-d01.$(OBJEXT): nag-d01.clisp
	@ echo 163 making nag-d01.$(OBJEXT) from nag-d01.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-d01.clisp" :output-file "nag-d01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-d01.clisp" :output-file "nag-d01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-d01.clisp: nag-d01.boot
	@ echo 164 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-d02.$(OBJEXT): nag-d02.$(OBJEXT)
	@ echo 166 making${AUTO}/nag-d02.$(OBJEXT) from nag-d02.$(OBJEXT)
	@ cp nag-d02.$(OBJEXT) ${AUTO}

nag-d02.$(OBJEXT): nag-d02.clisp
	@ echo 167 making nag-d02.$(OBJEXT) from nag-d02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-d02.clisp" :output-file "nag-d02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-d02.clisp" :output-file "nag-d02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-d02.clisp: nag-d02.boot
	@ echo 168 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-d03.$(OBJEXT): nag-d03.$(OBJEXT)
	@ echo 170 making${AUTO}/nag-d03.$(OBJEXT) from nag-d03.$(OBJEXT)
	@ cp nag-d03.$(OBJEXT) ${AUTO}

nag-d03.$(OBJEXT): nag-d03.clisp
	@ echo 171 making nag-d03.$(OBJEXT) from nag-d03.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-d03.clisp" :output-file "nag-d03.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-d03.clisp" :output-file "nag-d03.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-d03.clisp: nag-d03.boot
	@ echo 172 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d03.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-d03.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-e01.$(OBJEXT): nag-e01.$(OBJEXT)
	@ echo 174 making ${AUTO}/nag-e01.$(OBJEXT) from nag-e01.$(OBJEXT)
	@ cp nag-e01.$(OBJEXT) ${AUTO}

nag-e01.$(OBJEXT): nag-e01.clisp
	@ echo 175 making nag-e01.$(OBJEXT) from nag-e01.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-e01.clisp" :output-file "nag-e01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-e01.clisp" :output-file "nag-e01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-e01.clisp: nag-e01.boot
	@ echo 176 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-e02.$(OBJEXT): nag-e02.$(OBJEXT)
	@ echo 182 making ${AUTO}/nag-e02.$(OBJEXT) from nag-e02.$(OBJEXT)
	@ cp nag-e02.$(OBJEXT) ${AUTO}

nag-e02.$(OBJEXT): nag-e02.clisp
	@ echo 183 making nag-e02.$(OBJEXT) from nag-e02.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-e02.clisp" :output-file "nag-e02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-e02.clisp" :output-file "nag-e02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-e02.clisp: nag-e02.boot
	@ echo 184 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-e04.$(OBJEXT): nag-e04.$(OBJEXT)
	@ echo 186 making ${AUTO}/nag-e04.$(OBJEXT) from nag-e04.$(OBJEXT)
	@ cp nag-e04.$(OBJEXT) ${AUTO}

nag-e04.$(OBJEXT): nag-e04.clisp
	@ echo 187 making nag-e04.$(OBJEXT) from nag-e04.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-e04.clisp" :output-file "nag-e04.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-e04.clisp" :output-file "nag-e04.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-e04.clisp: nag-e04.boot
	@ echo 188 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e04.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-e04.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-f01.$(OBJEXT): nag-f01.$(OBJEXT)
	@ echo 190 making ${AUTO}/nag-f01.$(OBJEXT) from nag-f01.$(OBJEXT)
	@ cp nag-f01.$(OBJEXT) ${AUTO}

nag-f01.$(OBJEXT): nag-f01.clisp
	@ echo 191 making nag-f01.$(OBJEXT) from nag-f01.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f01.clisp" :output-file "nag-f01.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f01.clisp" :output-file "nag-f01.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-f01.clisp: nag-f01.boot
	@ echo 192 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f01.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f01.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-f02.$(OBJEXT): nag-f02.$(OBJEXT)
	@ echo 194 making ${AUTO}/nag-f02.$(OBJEXT) from nag-f02.$(OBJEXT)
	@ cp nag-f02.$(OBJEXT) ${AUTO}

nag-f02.$(OBJEXT): nag-f02.clisp
	@ echo 195 making nag-f02.$(OBJEXT) from nag-f02.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f02.clisp" :output-file "nag-f02.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f02.clisp" :output-file "nag-f02.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-f02.clisp: nag-f02.boot
	@ echo 196 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f02.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f02.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-f04.$(OBJEXT): nag-f04.$(OBJEXT)
	@ echo 198 making ${AUTO}/nag-f04.$(OBJEXT) from nag-f04.$(OBJEXT)
	@ cp nag-f04.$(OBJEXT) ${AUTO}

nag-f04.$(OBJEXT): nag-f04.clisp
	@ echo 199 making nag-f04.$(OBJEXT) from nag-f04.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-f04.clisp" :output-file "nag-f04.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-f04.clisp" :output-file "nag-f04.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-f04.clisp: nag-f04.boot
	@ echo 200 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f04.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f04.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nag-f07.$(OBJEXT): nag-f07.$(OBJEXT)
	@ echo 202 making ${AUTO}/nag-f07.$(OBJEXT) from nag-f07.$(OBJEXT)
	@ cp nag-f07.$(OBJEXT) ${AUTO}

nag-f07.$(OBJEXT): nag-f07.clisp
	@ echo 203 making nag-f07.$(OBJEXT) from nag-f07.clisp
	@ if [ -z "${NOISE}" ] ; then \
           echo '(progn  (compile-file "nag-f07.clisp" :output-file "nag-f07.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
           echo '(progn  (compile-file "nag-f07.clisp" :output-file "nag-f07.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-f07.clisp: nag-f07.boot
	@ echo 204 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f07.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-f07.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/nag-s.$(OBJEXT): nag-s.$(OBJEXT)
	@ echo 206 making ${AUTO}/nag-s.$(OBJEXT) from nag-s.$(OBJEXT)
	@ cp nag-s.$(OBJEXT) ${AUTO}

nag-s.$(OBJEXT): nag-s.clisp
	@ echo 207 making nag-s.$(OBJEXT) from nag-s.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nag-s.clisp" :output-file "nag-s.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nag-s.clisp" :output-file "nag-s.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nag-s.clisp: nag-s.boot
	@ echo 208 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-s.boot"))' | ${DEPSYS} ; \
	  else \
	    echo '(progn (boot::reroot "${AXIOM}") (boottran::boottocl "nag-s.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


newaux.$(OBJEXT): newaux.lisp
	@ echo 79 making newaux.$(OBJEXT) from newaux.lisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "newaux.lisp" :output-file "newaux.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

newaux.${LISP}: newaux.lisp
	@ echo 80 making newaux.${LISP} from newaux.lisp
	@cp newaux.lisp newaux.${LISP}

newaux.lisp: $(srcdir)/newaux.lisp.pamphlet
	$(axiom_build_document) --tangle --output=$@ $<

newfort.$(OBJEXT): newfort.clisp 
	@ echo 348 making newfort.$(OBJEXT) from newfort.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "newfort.clisp" :output-file "newfort.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "newfort.clisp" :output-file "newfort.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

newfort.clisp: newfort.boot
	@ echo 349 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "newfort.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "newfort.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nruncomp.$(OBJEXT): nruncomp.$(OBJEXT)
	@ echo 351 making ${AUTO}/nruncomp.$(OBJEXT) from nruncomp.$(OBJEXT)
	@ cp nruncomp.$(OBJEXT) ${AUTO}

nruncomp.$(OBJEXT): nruncomp.clisp 
	@ echo 352 making nruncomp.$(OBJEXT) from nruncomp.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nruncomp.clisp" :output-file "nruncomp.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nruncomp.clisp" :output-file "nruncomp.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nruncomp.clisp: nruncomp.boot
	@ echo 353 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nruncomp.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nruncomp.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


nrunfast.$(OBJEXT): nrunfast.clisp 
	@ echo 355 making nrunfast.$(OBJEXT) from nrunfast.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrunfast.clisp" :output-file "nrunfast.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrunfast.clisp" :output-file "nrunfast.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nrunfast.clisp: nrunfast.boot
	@ echo 356 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrunfast.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrunfast.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


nrungo.$(OBJEXT): nrungo.clisp 
	@ echo 358 making nrungo.$(OBJEXT) from nrungo.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrungo.clisp" :output-file "nrungo.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrungo.clisp" :output-file "nrungo.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nrungo.clisp: nrungo.boot
	@ echo 359 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrungo.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrungo.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


nruntime.$(OBJEXT): nruntime.clisp 
	@ echo 361 making nruntime.$(OBJEXT) from nruntime.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nruntime.clisp" :output-file "nruntime.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nruntime.clisp" :output-file "nruntime.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nruntime.clisp: nruntime.boot
	@ echo 362 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nruntime.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nruntime.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


nrunopt.$(OBJEXT): nrunopt.clisp 
	@ echo 364 making nrunopt.$(OBJEXT) from nrunopt.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "nrunopt.clisp" :output-file "nrunopt.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "nrunopt.clisp" :output-file "nrunopt.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

nrunopt.clisp: nrunopt.boot
	@ echo 365 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "nrunopt.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "nrunopt.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/nspadaux.$(OBJEXT): nspadaux.$(OBJEXT)
	@ echo 89 making ${AUTO}/nspadaux.$(OBJEXT) from nspadaux.$(OBJEXT)
	@ cp nspadaux.$(OBJEXT) ${AUTO}


${AUTO}/package.$(OBJEXT): package.$(OBJEXT)
	@ echo 370 making ${AUTO}/package.$(OBJEXT) from package.$(OBJEXT)
	@ cp package.$(OBJEXT) ${AUTO}

package.$(OBJEXT): package.clisp 
	@ echo 371 making package.$(OBJEXT) from package.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "package.clisp" :output-file "package.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "package.clisp" :output-file "package.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

package.clisp: package.boot
	@ echo 372 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "package.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "package.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/parse.$(OBJEXT): parse.$(OBJEXT)
	@ echo 374 making ${AUTO}/parse.$(OBJEXT) from parse.$(OBJEXT)
	@ cp parse.$(OBJEXT) ${AUTO}

parse.$(OBJEXT): parse.clisp 
	@ echo 375 making parse.$(OBJEXT) from parse.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "parse.clisp" :output-file "parse.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

parse.clisp: $(srcdir)/parse.boot.pamphlet
	@ echo 376 making $@ from $<
	@ rm -f parse.$(OBJEXT)
	$(axiom_build_document) --tangle=parse.clisp --output=$@ $<
## FIXME: Temporily disabled.
# parse.clisp: $(srcdir)/parse.boot.pamphlet
# 	@ echo 377 making parse.clisp from $(srcdir)/parse.boot.pamphlet
# 	@ ($(axiom_build_document) --tangle --output=parse.boot $<;\
# 	  if [ -z "${NOISE}" ] ; then \
# 	   echo '(progn (boottran::boottocl "parse.boot"))' | ${DEPSYS} ; \
# 	  else \
# 	   echo '(progn (boottran::boottocl "parse.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
# 	  fi ; \
# 	  rm parse.boot )


${AUTO}/parsing.$(OBJEXT): parsing.$(OBJEXT)
	@ echo 94 making ${AUTO}/parsing.$(OBJEXT) from parsing.$(OBJEXT)
	@ cp parsing.$(OBJEXT) ${AUTO}


pathname.$(OBJEXT): pathname.clisp 
	@ echo 379 making pathname.$(OBJEXT) from pathname.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pathname.clisp" :output-file "pathname.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pathname.clisp" :output-file "pathname.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

pathname.clisp: pathname.boot
	@ echo 380 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pathname.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pathname.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/postpar.$(OBJEXT): postpar.$(OBJEXT)
	@ echo 382 making ${AUTO}/postpar.$(OBJEXT) from postpar.$(OBJEXT)
	@ cp postpar.$(OBJEXT) ${AUTO}

postpar.clisp: $(srcdir)/postpar.boot.pamphlet
	@ echo 383 making $@ from $<
	@ rm -f postpar.$(OBJEXT)
	$(axiom_build_document) --tangle=postpar.clisp --output=$@ $<
postpar.$(OBJEXT): postpar.clisp 
	@ echo 384 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "postpar.clisp" :output-file "postpar.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

## FIXME: temporarily commented
# postpar.clisp: $(srcdir)/postpar.boot.pamphlet
# 	@ echo 385 making postpar.clisp from $(srcdir)/postpar.boot.pamphlet
# 	@ ($(axiom_build_document) --tangle --output=postpar.boot $<;\
# 	  if [ -z "${NOISE}" ] ; then \
# 	   echo '(progn (boottran::boottocl "postpar.boot"))' | ${DEPSYS} ; \
# 	  else \
# 	   echo '(progn (boottran::boottocl "postpar.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
# 	  fi ; \
# 	  rm postpar.boot )


${AUTO}/postprop.$(OBJEXT): postprop.$(OBJEXT)
	@ echo 102 making $@ from $<
	@ cp $< ${AUTO}


${AUTO}/preparse.$(OBJEXT): preparse.$(OBJEXT)
	@ echo 106 making ${AUTO}/preparse.$(OBJEXT) from preparse.$(OBJEXT)
	@ cp preparse.$(OBJEXT) ${AUTO}


${AUTO}/profile.$(OBJEXT): profile.$(OBJEXT)
	@ echo 235 making ${AUTO}/profile.$(OBJEXT) from profile.$(OBJEXT)
	@ cp profile.$(OBJEXT) ${AUTO}

profile.$(OBJEXT): profile.clisp 
	@ echo 236 making profile.$(OBJEXT) from profile.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "profile.clisp" :output-file "profile.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "profile.clisp" :output-file "profile.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

profile.clisp: profile.boot
	@ echo 237 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "profile.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "profile.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


${AUTO}/pspad1.$(OBJEXT): pspad1.clisp 
	@ echo 598 making ${AUTO}/pspad1.$(OBJEXT) from pspad1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pspad1.clisp" :output-file "${AUTO}/pspad1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pspad1.clisp" :output-file "${AUTO}/pspad1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

pspad1.clisp: pspad1.boot
	@ echo 599 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/pspad2.$(OBJEXT): pspad2.clisp 
	@ echo 601 making ${AUTO}/pspad2.$(OBJEXT) from pspad2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "pspad2.clisp" :output-file "${AUTO}/pspad2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "pspad2.clisp" :output-file "${AUTO}/pspad2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

pspad2.clisp: pspad2.boot
	@ echo 602 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "pspad2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "pspad2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


record.$(OBJEXT): record.clisp 
	@ echo 446 making record.$(OBJEXT) from record.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "record.clisp" :output-file "record.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "record.clisp" :output-file "record.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

record.clisp: record.boot
	@ echo 447 making $@ $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "record.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "record.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


rulesets.$(OBJEXT): rulesets.clisp 
	@ echo 387 making rulesets.$(OBJEXT) from rulesets.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "rulesets.clisp" :output-file "rulesets.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "rulesets.clisp" :output-file "rulesets.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

rulesets.clisp: rulesets.boot
	@ echo 388 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "rulesets.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "rulesets.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


server.$(OBJEXT): server.clisp 
	@ echo 390 making server.$(OBJEXT) from server.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "server.clisp" :output-file "server.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "server.clisp" :output-file "server.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

server.clisp: server.boot
	@ echo 391 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "server.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "server.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


setvars.$(OBJEXT): setvars.clisp 
	@ echo 394 making setvars.$(OBJEXT) from setvars.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "setvars.clisp" :output-file "setvars.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "setvars.clisp" :output-file "setvars.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

setvars.${LISP}: $(srcdir)/setvars.boot.pamphlet
	@ echo 393 making setvars.${LISP} from $(srcdir)/setvars.boot.pamphlet
	@ rm -f setvars.$(OBJEXT)
	$(axiom_build_document) --tangle=setvars.clisp --output=$@ S<
setvars.clisp: setvars.boot
	@ echo 395 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "setvars.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "setvars.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


setvart.$(OBJEXT): setvart.clisp 
	@ echo 397 making setvart.$(OBJEXT) from setvart.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "setvart.clisp" :output-file "setvart.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "setvart.clisp" :output-file "setvart.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

setvart.clisp: setvart.boot
	@ echo 398 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "setvart.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "setvart.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/showimp.$(OBJEXT): showimp.$(OBJEXT)
	@ echo 579 making ${AUTO}/showimp.$(OBJEXT) from showimp.$(OBJEXT)
	@ cp showimp.$(OBJEXT) ${AUTO}


simpbool.$(OBJEXT): simpbool.clisp 
	@ echo 400 making simpbool.$(OBJEXT) from simpbool.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "simpbool.clisp" :output-file "simpbool.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "simpbool.clisp" :output-file "simpbool.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

simpbool.clisp: simpbool.boot
	@ echo 401 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "simpbool.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "simpbool.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


slam.$(OBJEXT): slam.clisp 
	@ echo 404 making slam.$(OBJEXT) from slam.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "slam.clisp" :output-file "slam.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "slam.clisp" :output-file "slam.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

slam.clisp: slam.boot
	@ echo 405 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "slam.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "slam.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

slam.${LISP}: $(srcdir)/slam.boot.pamphlet
	@ echo 403 making slam.${LISP} from $(srcdir)/slam.boot.pamphlet
	@ rm -f slam.$(OBJEXT)
	$(axiom_build_document) --tangle=slam.clisp --output=$@ $<

template.$(OBJEXT): template.clisp 
	@ echo 407 making template.$(OBJEXT) from template.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "template.clisp" :output-file "template.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "template.clisp" :output-file "template.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

template.clisp: template.boot
	@ echo 408 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "template.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "template.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


termrw.$(OBJEXT): termrw.clisp 
	@ echo 410 making termrw.$(OBJEXT) from termrw.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "termrw.clisp" :output-file "termrw.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "termrw.clisp" :output-file "termrw.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

termrw.clisp: termrw.boot
	@ echo 411 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "termrw.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "termrw.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/topics.$(OBJEXT): topics.$(OBJEXT)
	@ echo 493 making ${AUTO}/topics.$(OBJEXT) from topics.$(OBJEXT)
	@ cp topics.$(OBJEXT) ${AUTO}

topics.$(OBJEXT): topics.clisp 
	@ echo 494 making topics.$(OBJEXT) from topics.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "topics.clisp" :output-file "topics.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "topics.clisp" :output-file "topics.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

topics.clisp: topics.boot
	@ echo 495 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "topics.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "topics.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi 


trace.$(OBJEXT): trace.clisp 
	@ echo 413 making trace.$(OBJEXT) from trace.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "trace.clisp" :output-file "trace.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "trace.clisp" :output-file "trace.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

trace.clisp: trace.boot
	@ echo 414 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "trace.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "trace.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


../algebra/warm.data: $(srcdir)/Makefile.pamphlet
	@ echo 2 building warm.data
	$(axiom_build_document) --tangle=warm.data --output=$@ $<


${AUTO}/wi1.$(OBJEXT): wi1.clisp 
	@ echo 592 making ${AUTO}/wi1.$(OBJEXT) from wi1.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "wi1.clisp" :output-file "${AUTO}/wi1.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "wi1.clisp" :output-file "${AUTO}/wi1.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

wi1.clisp: wi1.boot
	@ echo 593 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi1.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi1.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/wi2.$(OBJEXT): wi2.clisp 
	@ echo 595 making ${AUTO}/wi2.$(OBJEXT) from wi2.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "wi2.clisp" :output-file "${AUTO}/wi2.$(OBJEXT)"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "wi2.clisp" :output-file "${AUTO}/wi2.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi

wi2.clisp: wi2.boot
	@ echo 596 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "wi2.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "wi2.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


xrun.$(OBJEXT): xrun.clisp 
	@ echo 589 making xrun.$(OBJEXT) from xrun.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "xrun.clisp" :output-file "xrun.$(OBJEXT)"))' | ${DEPSYS} ; \
	   else \
	   echo '(progn  (compile-file "xrun.clisp" :output-file "xrun.$(OBJEXT)"))' | ${DEPSYS} >> ${TMP}/trace ; \
	   fi

xrun.clisp: xrun.boot
	@ echo 590 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "xrun.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "xrun.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


${AUTO}/xruncomp.$(OBJEXT): xruncomp.$(OBJEXT)
	@ echo 457 making ${AUTO}/xruncomp.$(OBJEXT) from xruncomp.$(OBJEXT)
	@ cp xruncomp.$(OBJEXT) ${AUTO}

xruncomp.$(OBJEXT): xruncomp.clisp 
	@ echo 458 making xruncomp.$(OBJEXT) from xruncomp.clisp
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn  (compile-file "xruncomp.clisp" :output-file "xruncomp.$(OBJEXT)"))' |  ${DEPSYS} ; \
	  else \
	   echo '(progn  (compile-file "xruncomp.clisp" :output-file "xruncomp.$(OBJEXT)"))' |  ${DEPSYS} >> ${TMP}/trace ; \
	  fi

xruncomp.clisp: xruncomp.boot
	@ echo 459 making $@ from $<
	@ if [ -z "${NOISE}" ] ; then \
	   echo '(progn (boottran::boottocl "xruncomp.boot"))' | ${DEPSYS} ; \
	  else \
	   echo '(progn (boottran::boottocl "xruncomp.boot"))' | ${DEPSYS} >> ${TMP}/trace ; \
	  fi


.PRECIOUS: $(builddir)/%.tex
.PRECIOUS: $(builddir)/%.dvi

$(DOCFILES): $(DOC) $(axiom_build_texdir)/diagrams.tex

$(DOC):
	$(mkinstalldirs) $@

$(DOC)/%.dvi: $(builddir)/%.dvi
	$(INSTALL_DATA) $< $@

$(builddir)/%.dvi: $(axiom_build_texdir)/axiom.sty

$(builddir)/%.dvi: $(builddir)/%.tex
	$(axiom_build_document) --latex $< $(SINK_NOISE)

$(builddir)/%.tex: $(srcdir)/%.pamphlet
	$(axiom_build_document) --weave --output=$@ $<

$(axiom_build_texdir)/diagrams.tex: $(axiom_src_docdir)/diagrams.tex
	$(INSTALL_DATA) $< $@

