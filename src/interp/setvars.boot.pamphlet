\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp setvars.boot}
\author{The Axiom Team}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Bootstrap information}
This file contains both the {\bf boot} code and the {\bf Lisp}
code that is the result of the {\bf boot to lisp} translation.
We need to keep the translated code around so we can bootstrap
the system. In other words, we need this boot code translated
so we can build the boot translator. 

{\bf NOTE WELL: IF YOU CHANGE THIS BOOT CODE YOU MUST 
TRANSLATE THIS CODE TO LISP AND STORE THE RESULTING LISP 
CODE BACK INTO THIS FILE.}

See the {\bf setvars.clisp} section below.
\section{Top level function calling conventions}
Conventions:
\begin{list}{}
\item when called with argument "\%initialize", a function will
set the appropriate variables to their default states.
\item when called with argument "\%display\%", a function will return a
current state information suitable for sayBrightly
\item when called with argument "\%describe\%", a function will print
a description of itself and any conditions it imposes.
\item otherwise, a function may interpret its arguments as it sees
appropriate.
\end{list}
Also by convention each top level function named in the FUNCTION 
slot (see the data structure in setvart.boot.pamphlet\cite{1}) has an
associated describe function. Thus, for example,
setOutputFortran is accompanied by function to describe 
its arguments, such as describeSetOutputFortran.
\section{Top level set functions}
The {\bf set} function in this file handles the top level {\bf )set}
command line functions.

\section{expose}
See the section expose in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
---------------------- The expose Option ----------------------

 Description: control interpreter constructor exposure

   The following groups are explicitly exposed in the current 
   frame (called initial ):
                                   basic                                   
                                categories                                 
                                  naglink                                  
                                   anna                                    
 
   The following constructors are explicitly exposed in the 
   current frame:
               there are no explicitly exposed constructors                
 
   The following constructors are explicitly hidden in the 
   current frame:
                there are no explicitly hidden constructors                
 
   When )set expose is followed by no arguments, the information
   you now see is displayed. When followed by the initialize 
   argument, the exposure group data in the file interp.exposed 
   is read and is then available. The arguments add and drop are 
   used to add or drop exposure groups or explicit constructors 
   from the local frame exposure data. Issue
                  )set expose add    or    )set expose drop 
   for more information.
\end{verbatim}
<<exposeCode>>=
<<setExpose>>
<<setExposeAdd>>
<<setExposeAddGroup>>
<<setExposeAddConstr>>
<<setExposeDrop>>
<<setExposeDropGroup>>
<<setExposeDropConstr>>
@
\subsection{setExpose}
<<setExpose>>=
setExpose arg ==
  arg = "%initialize%" => loadExposureGroupData()
  arg = "%display%" => '"..."

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    --  give msg about exposure groups
    displayExposedGroups()
    --  give msg about explicitly exposed constructors
    sayMSG '" "
    displayExposedConstructors()
    --  give msg about explicitly hidden constructors
    sayMSG '" "
    displayHiddenConstructors()
    -- give some more details
    sayMSG '" "
    sayKeyedMsg("S2IZ0049D",[namestring pathname ["interp","exposed"]])

  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
    '(add drop initialize),NIL)) =>
      fn = 'add  =>  setExposeAdd fnargs
      fn = 'drop =>  setExposeDrop fnargs
      fn = 'initialize => setExpose "%initialize%"
      NIL
  setExpose NIL

@
\subsection{setExposeAdd}
<<setExposeAdd>>=
setExposeAdd arg ==
  (null arg) =>
    centerAndHighlight ("The add Option",$LINELENGTH,specialChar 'hbar)
    --  give msg about exposure groups
    displayExposedGroups()
    --  give msg about explicitly exposed constructors
    sayMSG '" "
    displayExposedConstructors()
    sayMSG '" "
    sayKeyedMsg("S2IZ0049E",NIL)
  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
    '(group constructor),NIL)) =>
      fn = 'group  =>  setExposeAddGroup fnargs
      fn = 'constructor =>  setExposeAddConstr fnargs
      NIL
  setExposeAdd NIL

@
\subsection{setExposeAddGroup}
<<setExposeAddGroup>>=
setExposeAddGroup arg ==
  (null arg) =>
    centerAndHighlight("The group Option",$LINELENGTH,specialChar 'hbar)
    --  give msg about exposure groups
    displayExposedGroups()
    sayMSG '" "
    sayKeyedMsg("S2IZ0049G",[namestring pathname ["interp","exposed"]])
    sayMSG '" "
    sayAsManyPerLineAsPossible [object2String first x for x in
      $globalExposureGroupAlist]
  for x in arg repeat
    if PAIRP x then x := QCAR x
    x = 'all =>
      $localExposureData.0 :=[first x for x in $globalExposureGroupAlist]
      $localExposureData.1 :=NIL
      $localExposureData.2 :=NIL
      displayExposedGroups()
      sayMSG '" "
      displayExposedConstructors()
      sayMSG '" "
      displayHiddenConstructors()
      clearClams()
    null GETALIST($globalExposureGroupAlist,x) =>
      sayKeyedMsg("S2IZ0049H",[x])
    member(x,$localExposureData.0) =>
      sayKeyedMsg("S2IZ0049I",[x,$interpreterFrameName])
    $localExposureData.0 := MSORT cons(x,$localExposureData.0)
    sayKeyedMsg("S2IZ0049R",[x,$interpreterFrameName])
    clearClams()

@
\subsection{setExposeAddConstr}
<<setExposeAddConstr>>=
setExposeAddConstr arg ==
  (null arg) =>
    centerAndHighlight ("The constructor Option",$LINELENGTH,
      specialChar 'hbar)
    --  give msg about explicitly exposed constructors
    displayExposedConstructors()
  for x in arg repeat
    x := unabbrev x
    if PAIRP x then x := QCAR x
    -- if the constructor is known, we know what type it is
    null GETDATABASE(x,'CONSTRUCTORKIND) =>
      sayKeyedMsg("S2IZ0049J",[x])
    member(x,$localExposureData.1) =>
      sayKeyedMsg("S2IZ0049K",[x,$interpreterFrameName])
    -- if the constructor is explicitly hidden, then remove that
    if member(x,$localExposureData.2) then
      $localExposureData.2 := DELETE(x,$localExposureData.2)
    $localExposureData.1 := MSORT cons(x,$localExposureData.1)
    clearClams()
    sayKeyedMsg("S2IZ0049P",[x,$interpreterFrameName])

@
\subsection{setExposeDrop}
<<setExposeDrop>>=
setExposeDrop arg ==
  (null arg) =>
    centerAndHighlight ("The drop Option",$LINELENGTH,specialChar 'hbar)
    --  give msg about explicitly hidden constructors
    displayHiddenConstructors()
    sayMSG '" "
    sayKeyedMsg("S2IZ0049F",NIL)
  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
    '(group constructor),NIL)) =>
      fn = 'group  =>  setExposeDropGroup fnargs
      fn = 'constructor =>  setExposeDropConstr fnargs
      NIL
  setExposeDrop NIL

@
\subsection{setExposeDropGroup}
<<setExposeDropGroup>>=
setExposeDropGroup arg ==
  (null arg) =>
    centerAndHighlight ("The group Option",$LINELENGTH,specialChar 'hbar)
    sayKeyedMsg("S2IZ0049L",NIL)
    sayMSG '" "
    displayExposedGroups()
  for x in arg repeat
    if PAIRP x then x := QCAR x
    x = 'all =>
      $localExposureData.0 := NIL
      $localExposureData.1 := NIL
      $localExposureData.2 := NIL
      displayExposedGroups()
      sayMSG '" "
      displayExposedConstructors()
      sayMSG '" "
      displayHiddenConstructors()
      clearClams()
    member(x,$localExposureData.0) =>
      $localExposureData.0 := DELETE(x,$localExposureData.0)
      clearClams()
      sayKeyedMsg("S2IZ0049S",[x,$interpreterFrameName])
    GETALIST($globalExposureGroupAlist,x) =>
      sayKeyedMsg("S2IZ0049I",[x,$interpreterFrameName])
    sayKeyedMsg("S2IZ0049H",[x])

@
\subsection{setExposeDropConstr}
<<setExposeDropConstr>>=
setExposeDropConstr arg ==
  (null arg) =>
    centerAndHighlight ("The constructor Option",$LINELENGTH,
      specialChar 'hbar)
    sayKeyedMsg("S2IZ0049N",NIL)
    sayMSG '" "
    displayExposedConstructors()
    sayMSG '" "
    displayHiddenConstructors()
  for x in arg repeat
    x := unabbrev x
    if PAIRP x then x := QCAR x
    -- if the constructor is known, we know what type it is
    null GETDATABASE(x,'CONSTRUCTORKIND) =>
      sayKeyedMsg("S2IZ0049J",[x])
    member(x,$localExposureData.2) =>
      sayKeyedMsg("S2IZ0049O",[x,$interpreterFrameName])
    if member(x,$localExposureData.1) then
      $localExposureData.1 := DELETE(x,$localExposureData.1)
    $localExposureData.2 := MSORT cons(x,$localExposureData.2)
    clearClams()
    sayKeyedMsg("S2IZ0049Q",[x,$interpreterFrameName])

@
\section{fortran calling}
See the section calling in servart.boot.pamphlet.
\begin{verbatim}
              Current Values of  calling  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
tempfile     set location of temporary data files       /tmp/ 
directory    set location of generated FORTRAN files    ./ 
linker       linker arguments (e.g. libraries to search) -lxlf 

\end{verbatim}
<<fortrancallingCode>>=
<<setFortTmpDir>>
<<validateOutputDirectory>>
<<describeSetFortTmpDir>>
<<setFortDir>>
<<describeSetFortDir>>
<<setLinkerArgs>>
<<describeSetLinkerArgs>>
@
\subsection{setFortTmpDir}
<<setFortTmpDir>>=
setFortTmpDir arg ==

  arg = "%initialize%" =>
    $fortranTmpDir := '"/tmp/"

  arg = "%display%" =>
    STRINGP $fortranTmpDir => $fortranTmpDir
    PNAME $fortranTmpDir

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetFortTmpDir()

  -- try to figure out what the argument is

  -- VM code - must be an accessed disk mode [mode]
  not (mode := validateOutputDirectory arg) =>
    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
      '"is(are) not valid.",'%l]
    describeSetFortTmpDir()
  $fortranTmpDir := mode

@
\subsection{validateOutputDirectory}
<<validateOutputDirectory>>=
validateOutputDirectory x ==
  AND(PATHNAME_-DIRECTORY(PROBE_-FILE(CAR(x))), NOT PATHNAME_-NAME  (PROBE_-FILE(CAR(x)))) =>
    CAR(x)
  NIL

@
\subsection{describeSetFortTmpDir}
<<describeSetFortTmpDir>>=
describeSetFortTmpDir() ==
  sayBrightly LIST (
   '%b,'")set fortran calling tempfile",'%d,_
   '" is used to tell AXIOM where",'%l,_
   '" to place intermediate FORTRAN data files . This must be the ",'%l,_
   '" name of a valid existing directory to which you have permission ",'%l,_
   '" to write (including the final slash).",'%l,'%l,_
   '" Syntax:",'%l,_
   '"   )set fortran calling tempfile DIRECTORYNAME",'%l,'%l,_
   '" The current setting is",'%b,$fortranTmpDir,'%d)

@
\subsection{setFortDir}
<<setFortDir>>=
setFortDir arg ==
  arg = "%initialize%" =>
    $fortranDirectory := '"./"

  arg = "%display%" =>
    STRINGP $fortranDirectory => $fortranDirectory
    PNAME $fortranDirectory

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetFortDir()

  -- try to figure out what the argument is

  -- VM code - must be an accessed disk mode [mode]
  not (mode := validateOutputDirectory arg) =>
    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
      '"is(are) not valid.",'%l]
    describeSetFortDir()
  $fortranDirectory := mode

@
\subsection{describeSetFortDir}
<<describeSetFortDir>>=
describeSetFortDir() ==
  sayBrightly LIST (
   '%b,'")set fortran calling directory",'%d,_
   '" is used to tell AXIOM where",'%l,_
   '" to place generated FORTRAN files. This must be the name ",'%l,_
   '" of a valid existing directory to which you have permission ",'%l,_
   '" to write (including the final slash).",'%l,'%l,_
   '" Syntax:",'%l,_
   '"   )set fortran calling directory DIRECTORYNAME",'%l,'%l,_
   '" The current setting is",'%b,$fortranDirectory,'%d)

@
\subsection{setLinkerArgs}
<<setLinkerArgs>>=
setLinkerArgs arg ==

  arg = "%initialize%" =>
    $fortranLibraries := '"-lxlf"
  arg = "%display%" => object2String $fortranLibraries
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetLinkerArgs()
  LISTP(arg) and STRINGP(first arg) => 
    $fortranLibraries := first(arg)
  describeSetLinkerArgs()

@
\subsection{describeSetLinkerArgs}
<<describeSetLinkerArgs>>=
describeSetLinkerArgs() ==
  sayBrightly LIST (
   '%b,'")set fortran calling linkerargs",'%d,_
   '" is used to pass arguments to the linker",'%l,_
   '" when using ",'%b,'"mkFort",'%d,_
   '" to create functions which call Fortran code.",'%l,_
   '" For example, it might give a list of libraries to be searched,",'%l,_
   '" and their locations.",'%l,_
   '" The string is passed verbatim, so must be the correct syntax for",'%l,_
   '" the particular linker being used.",'%l,'%l,_
   '" Example: )set fortran calling linker _"-lxlf_"",'%l,'%l,_
   '" The current setting is",'%b,$fortranLibraries,'%d)

@
\section{functions}
See the section functions in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
             Current Values of  functions  Variables                  

Variable     Description                           Current Value
-----------------------------------------------------------------
cache        number of function results to cache        0 
compile      compile, don't just define function bodies off 
recurrence   specially compile recurrence relations     on 

\end{verbatim}
<<functionsCode>>=
<<setFunctionsCache>>
<<countCache>>
<<describeSetFunctionsCache>>
<<sayAllCacheCounts>>
<<sayCacheCount>>
@
\subsection{setFunctionsCache}
<<setFunctionsCache>>=
setFunctionsCache arg ==
  $options : local := NIL
  arg = "%initialize%" =>
    $cacheCount := 0
    $cacheAlist := NIL
  arg = "%display%" =>
    null $cacheAlist => object2String $cacheCount
    '"..."
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetFunctionsCache()
    TERPRI()
    sayAllCacheCounts()
  n := first arg
  (n ^= 'all) and ((not FIXP n) or (n < 0)) =>
    sayMessage ['"Your value of",:bright n,'"is invalid because ..."]
    describeSetFunctionsCache()
    terminateSystemCommand()
  if (rest arg) then $options := [['vars,:rest arg]]
  countCache n

@
\subsection{countCache}
<<countCache>>=
countCache n ==
  $options =>
    $options is [["vars",:l]] =>
      for x in l repeat
        NULL IDENTP x => sayKeyedMsg("S2IF0007",[x])
        $cacheAlist:= insertAlist(x,n,$cacheAlist)
        cacheCountName:= INTERNL(x,'";COUNT")
        SET(cacheCountName,n)
        sayCacheCount(x,n)
    optionError(CAAR $options,nil)
  sayCacheCount(nil,$cacheCount:= n)

@
\subsection{describeSetFunctionsCache}
<<describeSetFunctionsCache>>=
describeSetFunctionsCache() ==
  sayBrightly LIST(
    '%b,'")set functions cache",'%d,'"is used to tell AXIOM how many",'%l,_
    '" values computed by interpreter functions should be saved.  This can save ",'%l, _
    '" quite a bit of time in recursive functions, though one must consider that",'%l,_
    '" the cached values will take up (perhaps valuable) room in the workspace.",'%l,'%l,_
    '" The value given  after",'%b,'"cache",'%d,'"must either be the",_
    '" word",'%b,'"all",'%d,'"or a positive",'%l,_
    '" integer.  This may be followed by any number of function names whose cache",'%l,_
    '" sizes you wish to so set.  If no functions are given, the default cache",'%l,_
    '" size is set.",'%l,'" Examples:",_
    '"   )set fun cache all         )set fun cache 10 f g Legendre")

@
\subsection{sayAllCacheCounts}
<<sayAllCacheCounts>>=
sayAllCacheCounts () ==
  sayCacheCount(nil,$cacheCount)
  $cacheAlist =>
    TERPRI()
--    SAY '" However,"
    for [x,:n] in $cacheAlist | n ^= $cacheCount repeat sayCacheCount(x,n)

@
\subsection{sayCacheCount}
<<sayCacheCount>>=
sayCacheCount(fn,n) ==
  prefix:=
    fn => ["function",:bright linearFormatName fn]
    n = 0 => ["interpreter functions "]
    ["In general, interpreter functions "]
  n = 0 =>
    fn =>
      sayBrightly ['"   Caching for ",:prefix,
        '"is turned off"]
    sayBrightly '" In general, functions will cache no returned values."
  phrase:=
    n="all" => [:bright "all","values."]
    n=1 => [" only the last value."]
    [" the last",:bright n,"values."]
  sayBrightly ['"   ",:prefix,'"will cache",:phrase]

@
\section{history}
See the section history in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
--------------------- The history Option ----------------------

 Description: save workspace values in a history file

 The history option may be followed by any one of the 
 following:

 -> on 
    off

 The current setting is indicated within the list.

\end{verbatim}
<<historyCode>>=
<<setHistory>>
@
\subsection{setHistory}
<<setHistory>>=
setHistory arg ==
  -- this is just a front end for the history functions
  arg = "%initialize%" => nil

  current := object2String translateTrueFalse2YesNo $HiFiAccess
  arg = "%display%" => current

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    sayMessage ['" The",:bright '"history",'"option",
      '" may be followed by any one of the following:"]
    for name in '("on" "off" "yes" "no") repeat
      if name = current
        then sayBrightly ['" ->",:bright name]
        else sayBrightly ['"    ",name]
    TERPRI()
    sayBrightly '" The current setting is indicated within the list."
    sayBrightly [:bright '"yes",'"and",:bright '"no",
     '"have the same effect as",:bright '"on",'"and",:bright '"off",
       '"respectively."]
    if $useInternalHistoryTable
      then wh := '"memory"
      else wh := '"a file"
    sayBrightly ['%l,'" When the history facility is active, the data",
      '" is kept in ",wh,'"."]
    sayMessage ['" Issue",:bright '")help history",
      '"for more information."]

  arg is [fn] and
   (fn := DOWNCASE(fn)) in '(y n ye yes no on of off) =>
    $options := [[fn]]
    historySpad2Cmd()
  setHistory NIL

@
\section{kernel}
See the section kernel in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
              Current Values of  kernel  Variables                    

Variable     Description                           Current Value
-----------------------------------------------------------------
warn         warn when re-definition is attempted       off 
protect      prevent re-definition of kernel functions  off 

\end{verbatim}
<<kernelCode>>=
<<describeProtectedSymbolsWarning>>
<<protectedSymbolsWarning>>
<<describeProtectSymbols>>
<<protectSymbols>>
@
\subsection{describeProtectedSymbolsWarning}
<<describeProtectedSymbolsWarning>>=
describeProtectedSymbolsWarning() ==
 sayBrightly LIST(
  '"Some AXIOM library functions are compiled into the kernel for efficiency",_
  '%l,'"reasons.  To prevent them being re-defined when loaded from a library",_
  '%l,'"they are specially protected.  If a user wishes to know when an attempt",_
  '%l,'"is made to re-define such a function, he or she should issue the command:",_
  '%l,'"	)set kernel warn on",_
  '%l,'"To restore the default behaviour, he or she should issue the command:",_
  '%l,'"	)set kernel warn off")

@
\subsection{protectedSymbolsWarning}
<<protectedSymbolsWarning>>=
protectedSymbolsWarning arg ==
  arg = "%initialize%" => PROTECTED_-SYMBOL_-WARN(false)
  arg = "%display%" =>
    v := PROTECTED_-SYMBOL_-WARN(true)
    PROTECTED_-SYMBOL_-WARN(v)
    v => '"on" 
    '"off"
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeProtectedSymbolsWarning()
  PROTECTED_-SYMBOL_-WARN translateYesNo2TrueFalse first arg

@
\subsection{describeProtectSymbols}
<<describeProtectSymbols>>=
describeProtectSymbols() ==
 sayBrightly LIST(
  '"Some AXIOM library functions are compiled into the kernel for efficiency",_
  '%l,'"reasons.  To prevent them being re-defined when loaded from a library",_
  '%l,'"they are specially protected.  If a user wishes to re-define these",_
  '%l,'"functions, he or she should issue the command:",_
  '%l,'"	)set kernel protect off",_
  '%l,'"To restore the default behaviour, he or she should issue the command:",_
  '%l,'"	)set kernel protect on")

@
\subsection{protectSymbols}
<<protectSymbols>>=
protectSymbols arg ==
  arg = "%initialize%" => PROTECT_-SYMBOLS(true)
  arg = "%display%" =>
    v := PROTECT_-SYMBOLS(true)
    PROTECT_-SYMBOLS(v)
    v => '"on" 
    '"off"
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeProtectSymbols()
  PROTECT_-SYMBOLS translateYesNo2TrueFalse first arg

@
\section{naglink}
See the section naglink in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
              Current Values of  naglink  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
host         internet address of host for NAGLink       localhost 
persistence  number of (fortran) functions to remember  1 
messages     show NAGLink messages                      on 
double       enforce DOUBLE PRECISION ASPs              on 

\end{verbatim}
<<naglinkCode>>=
<<setNagHost>>
<<describeSetNagHost>>
<<setFortPers>>
<<describeFortPersistence>>
@
\subsection{setNagHost}
<<setNagHost>>=
setNagHost arg ==
  arg = "%initialize%" =>
    $nagHost := '"localhost"
  arg = "%display%" =>
    object2String $nagHost
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetNagHost()
  $nagHost := object2String arg

@
\subsection{describeSetNagHost}
<<describeSetNagHost>>=
describeSetNagHost() ==
  sayBrightly LIST (
   '%b,'")set naglink host",'%d,_
   '"is used to tell  AXIOM which  host to contact for",'%l,_
   '" a NAGLink request. An Internet address should be supplied. The host",'%l,_
   '" specified must be running the NAGLink daemon.",'%l,'%l,_
   '" The current setting is",'%b,$nagHost,'%d)

@
\subsection{setFortPers}
<<setFortPers>>=
setFortPers arg ==
  arg = "%initialize%" =>
    $fortPersistence := 1
  arg = "%display%" =>
    $fortPersistence
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeFortPersistence()
  n := first arg
  ((not FIXP n) or (n < 0)) =>
    sayMessage ['"Your value of",:bright n,'"is invalid because ..."]
    describeFortPersistence()
    terminateSystemCommand()
  $fortPersistence := first(arg)

@
\subsection{describeFortPersistence}
<<describeFortPersistence>>=
describeFortPersistence() ==
  sayBrightly LIST (
   '%b,'")set naglink persistence",'%d,_
   '"is used to tell  the ",'%b,"nagd",'%d," daemon how  many ASP",'%l,_
   '" source and object files to keep around in case you reuse them. This helps",'%l,_
   '" to avoid needless recompilations. The number specified should be a ",'%l,_
   '" non-negative integer.", '%l,'%l,_
   '" The current setting is",'%b,$fortPersistence,'%d)

@
\section{output algebra}
See the subsection output algebra in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
--------------------- The algebra Option ----------------------

 Description: display output in algebraic form

 )set output algebra is used to tell AXIOM to turn algebra-style
  output printing on and off, and where to place the output.  By
  default, the destination for the output is the screen but 
  printing is turned off.

Syntax:   )set output algebra <arg>
    where arg can be one of
  on          turn algebra printing on (default state)
  off         turn algebra printing off
  console     send algebra output to screen (default state)
  fp<.fe>     send algebra output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .spout.

If you wish to send the output to a file, you may need to issue
this command twice: once with on and once with the file name. 
For example, to send algebra output to the file polymer.spout,
issue the two commands

  )set output algebra on
  )set output algebra polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  On:CONSOLE 
\end{verbatim}
<<outputalgebraCode>>=
<<setOutputAlgebra>>
<<describeSetOutputAlgebra>>
@
\subsection{setOutputAlgebra}
<<setOutputAlgebra>>=
setOutputAlgebra arg ==
  arg = "%initialize%" =>
    $algebraOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $algebraOutputFile := '"CONSOLE"
    $algebraFormat := true

  arg = "%display%" =>
    if $algebraFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$algebraOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputAlgebra()

  -- try to figure out what the argument is

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'spout]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(algebra algebra))
    UPCASE(fn) in '(NO OFF)  => $algebraFormat := NIL
    UPCASE(fn) in '(YES ON) => $algebraFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $algebraOutputStream
      $algebraOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $algebraOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename =>
      sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
      SHUT $algebraOutputStream
      $algebraOutputStream := testStream
      $algebraOutputFile := object2String filename
      sayKeyedMsg("S2IV0004",['"Algebra",$algebraOutputFile])
    sayKeyedMsg("S2IV0003",[fn,ft,fm])

  sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputAlgebra()

@
\subsection{describeSetOutputAlgebra}
<<describeSetOutputAlgebra>>=
describeSetOutputAlgebra() ==
  sayBrightly LIST ('%b,'")set output algebra",'%d,_
   '"is used to tell AXIOM to turn algebra-style output",'%l,_
   '"printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Syntax:   )set output algebra <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn algebra printing on (default state)",'%l,_
  '"  off         turn algebra printing off",'%l,_
  '"  console     send algebra output to screen (default state)",'%l,_
  '"  fp<.fe>     send algebra output to file with file prefix fp",'%l,_
  '"              and file extension .fe. If not given, .fe defaults to .spout.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you may need to issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"algebra output to the file",'%b,'"polymer.spout,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output algebra on",'%l,_
  '"  )set output algebra polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputAlgebra "%display%",'%d)


@
\section{output characters}
See the subsection output characters in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
-------------------- The characters Option --------------------

 Description: choose special output character set


 The characters option may be followed by any one of the 
 following:

    default
 -> plain 

 The current setting is indicated within the list.  This 
 option  determines the special characters used for algebraic 
 output. This is what the current choice of special characters 
 looks like:
   ulc is shown as +          urc is shown as +       
   llc is shown as +          lrc is shown as +       
   vbar is shown as |         hbar is shown as -      
   quad is shown as ?         lbrk is shown as [      
   rbrk is shown as ]         lbrc is shown as {      
   rbrc is shown as }         ttee is shown as +      
   btee is shown as +         rtee is shown as +      
   ltee is shown as +         ctee is shown as +      
   bslash is shown as \    
\end{verbatim}
<<outputcharactersCode>>=
<<setOutputCharacters>>
@
\subsection{setOutputCharacters}
<<setOutputCharacters>>=
setOutputCharacters arg ==
  -- this sets the special character set
  arg = "%initialize%" =>
    $specialCharacters := $plainRTspecialCharacters

  current :=
    $specialCharacters = $RTspecialCharacters      => '"default"
    $specialCharacters = $plainRTspecialCharacters => '"plain"
    '"unknown"
  arg = "%display%" => current

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    sayMessage ['" The",:bright '"characters",'"option",
      '" may be followed by any one of the following:"]
    for name in '("default" "plain") repeat
      if name = current
        then sayBrightly ['" ->",:bright name]
        else sayBrightly ['"    ",name]
    TERPRI()
    sayBrightly '" The current setting is indicated within the list.  This option determines "
    sayBrightly '" the special characters used for algebraic output.  This is what the"
    sayBrightly '" current choice of special characters looks like:"
    l := NIL
    for [char,:.] in $specialCharacterAlist repeat
      s := STRCONC('"   ",PNAME char,'" is shown as ",
        PNAME specialChar(char))
      l := cons(s,l)
    sayAsManyPerLineAsPossible reverse l

  arg is [fn] and (fn := DOWNCASE(fn)) =>
    fn = 'default => $specialCharacters := $RTspecialCharacters
    fn = 'plain   => $specialCharacters := $plainRTspecialCharacters
    setOutputCharacters NIL
  setOutputCharacters NIL

@
\section{output fortran}
See the subsection output fortran in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
--------------------- The fortran Option ----------------------

 Description: create output in FORTRAN format

 )set output fortran is used to tell AXIOM to turn FORTRAN-style
  output printing on and off, and where to place the output.  By
  default, the destination for the output is the screen but 
  printing is turned off.

Also See: )set fortran

Syntax:   )set output fortran <arg>
    where arg can be one of
  on          turn FORTRAN printing on
  off         turn FORTRAN printing off (default state)
  console     send FORTRAN output to screen (default state)
  fp<.fe>     send FORTRAN output to file with file prefix 
              fp and file extension .fe. If not given, 
              .fe defaults to .sfort.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name.
For example, to send FORTRAN output to the file polymer.sfort,
 issue the two commands

  )set output fortran on
  )set output fortran polymer

The output is placed in the directory from which you invoked
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
<<outputfortranCode>>=
<<makeStream>>
<<setOutputFortran>>
<<describeSetOutputFortran>>
@
\subsection{makeStream}
<<makeStream>>=
makeStream(append,filename,i,j) ==
  append => MAKE_-APPENDSTREAM(filename,i,j)
  MAKE_-OUTSTREAM(filename,i,j)

@
\subsection{setOutputFortran}
<<setOutputFortran>>=
setOutputFortran arg ==
  arg = "%initialize%" =>
    $fortranOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $fortranOutputFile := '"CONSOLE"
    $fortranFormat := NIL

  arg = "%display%" =>
    if $fortranFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$fortranOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputFortran()

  -- try to figure out what the argument is

  append := NIL
  quiet := NIL
  while LISTP arg and UPCASE(first arg) in '(APPEND QUIET) repeat
    if UPCASE first(arg) = 'APPEND then append := true
    else if UPCASE first(arg) = 'QUIET then quiet := true
    arg := rest(arg)

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'sfort]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(FORTRAN fortran))
    UPCASE(fn) in '(NO OFF)  => $fortranFormat := NIL
    UPCASE(fn) in '(YES ON)  => $fortranFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $fortranOutputStream
      $fortranOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $fortranOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename => sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := makeStream(append,filename,255,0)) =>
      SHUT $fortranOutputStream
      $fortranOutputStream := testStream
      $fortranOutputFile := object2String filename
      if null quiet then sayKeyedMsg("S2IV0004",['FORTRAN,$fortranOutputFile])
    if null quiet then sayKeyedMsg("S2IV0003",[fn,ft,fm])
  if null quiet then sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputFortran()

@
\subsection{describeSetOutputFortran}
<<describeSetOutputFortran>>=
describeSetOutputFortran() ==
  sayBrightly LIST ('%b,'")set output fortran",'%d,_
   '"is used to tell AXIOM to turn FORTRAN-style output",'%l,_
   '"printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Also See: )set fortran",'%l,
   '%l,_
   '"Syntax:   )set output fortran <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn FORTRAN printing on",'%l,_
  '"  off         turn FORTRAN printing off (default state)",'%l,_
  '"  console     send FORTRAN output to screen (default state)",'%l,_
  '"  fp<.fe>     send FORTRAN output to file with file prefix fp and file",'%l,_
  '"              extension .fe. If not given, .fe defaults to .sfort.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you must issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"FORTRAN output to the file",'%b,'"polymer.sfort,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output fortran on",'%l,_
  '"  )set output fortran polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputFortran "%display%",'%d)

@
\section{output mathml}
See the section mathml in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
----------------------- The mathml Option ------------------------

 Description: create output in MathML style

 )set output mathml is used to tell AXIOM to turn MathML-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output mathml <arg>
    where arg can be one of
  on          turn MathML printing on
  off         turn MathML printing off (default state)
  console     send MathML output to screen (default state)
  fp<.fe>     send MathML output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .stex.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send MathML output to the file polymer.stex, 
issue the two commands

  )set output mathml on
  )set output mathml polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
<<outputmathmlCode>>=
<<setOutputMathml>>
<<describeSetOutputMathml>>
@
\subsection{setOutputMathml}
<<setOutputMathml>>=
setOutputMathml arg ==
  arg = "%initialize%" =>
    $mathmlOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $mathmlOutputFile := '"CONSOLE"
    $mathmlFormat := NIL

  arg = "%display%" =>
    if $mathmlFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$mathmlOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputMathml()

  -- try to figure out what the argument is

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'smml]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(MathML mathml))
    UPCASE(fn) in '(NO OFF)  => $mathmlFormat := NIL
    UPCASE(fn) in '(YES ON) => $mathmlFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $mathmlOutputStream
      $mathmlOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $mathmlOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename =>
      sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
      SHUT $mathmlOutputStream
      $mathmlOutputStream := testStream
      $mathmlOutputFile := object2String filename
      sayKeyedMsg("S2IV0004",['"MathML",$mathmlOutputFile])
    sayKeyedMsg("S2IV0003",[fn,ft,fm])

  sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputMathml()

@
\subsection{describeSetOutputMathml}
<<describeSetOutputMathml>>=
describeSetOutputMathml() ==
  sayBrightly LIST ('%b,'")set output mathml",'%d,_
   '"is used to tell AXIOM to turn MathML-style output",'%l,_
   '"printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Syntax:   )set output mathml <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn MathML printing on",'%l,_
  '"  off         turn MathML printing off (default state)",'%l,_
  '"  console     send MathML output to screen (default state)",'%l,_
  '"  fp<.fe>     send MathML output to file with file prefix fp and file",'%l,_
  '"              extension .fe. If not given, .fe defaults to .stex.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you must issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"MathML output to the file",'%b,'"polymer.smml,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output mathml on",'%l,_
  '"  )set output mathml polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputMathml "%display%",'%d)


@
\section{output openmath}
See the subsection output openmath in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
------------------ The openmath Option ------------------------

 Description: create output in OpenMath style

 )set output tex is used to tell AXIOM to turn TeX-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output tex <arg>
    where arg can be one of
  on          turn TeX printing on
  off         turn TeX printing off (default state)
  console     send TeX output to screen (default state)
  fp<.fe>     send TeX output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .som.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send TeX output to the file polymer.som, 
issue the two commands

  )set output tex on
  )set output tex polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
<<outputopenmathCode>>=
<<setOutputOpenMath>>
<<describeSetOutputOpenMath>>
@
\subsection{setOutputOpenMath}
<<setOutputOpenMath>>=
setOutputOpenMath arg ==
  arg = "%initialize%" =>
    $openMathOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $openMathOutputFile := '"CONSOLE"
    $openMathFormat := NIL

  arg = "%display%" =>
    if $openMathFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$openMathOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputOpenMath()

  -- try to figure out what the argument is

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'som]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(OpenMath openmath))
    UPCASE(fn) in '(NO OFF)  => $openMathFormat := NIL
    UPCASE(fn) in '(YES ON) => $openMathFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $openMathOutputStream
      $openMathOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $openMathOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename =>
      sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
      SHUT $openMathOutputStream
      $openMathOutputStream := testStream
      $openMathOutputFile := object2String filename
      sayKeyedMsg("S2IV0004",['"OpenMath",$openMathOutputFile])
    sayKeyedMsg("S2IV0003",[fn,ft,fm])

  sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputOpenMath()

@
\subsection{describeSetOutputOpenMath}
<<describeSetOutputOpenMath>>=
describeSetOutputOpenMath() ==
  sayBrightly LIST ('%b,'")set output openmath",'%d,_
   '"is used to tell AXIOM to turn OpenMath output",'%l,_
   '"printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Syntax:   )set output openmath <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn OpenMath printing on",'%l,_
  '"  off         turn OpenMath printing off (default state)",'%l,_
  '"  console     send OpenMath output to screen (default state)",'%l,_
  '"  fp<.fe>     send OpenMath output to file with file prefix fp and file",'%l,_
  '"              extension .fe. If not given, .fe defaults to .som.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you must issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"OpenMath output to the file",'%b,'"polymer.som,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output openmath on",'%l,_
  '"  )set output openmath polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputOpenMath "%display%",'%d)

@
\section{output script}
See the subsection output script in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
---------------------- The script Option ----------------------

 Description: display output in SCRIPT formula format

 )set output script is used to tell AXIOM to turn IBM Script
 formula-style output printing on and off, and where to place
 the output.  By default, the destination for the output is the 
 screen but printing is turned off.

Syntax:   )set output script <arg>
    where arg can be one of
  on      turn IBM Script formula printing on
  off     turn IBM Script formula printing off 
          (default state)
  console send IBM Script formula output to screen 
          (default state)
  fp<.fe> send IBM Script formula output to file with file 
          prefix fp and file extension .fe. If not given, 
          .fe defaults to .sform.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file 
name. For example, to send IBM Script formula output to 
the file polymer.sform, issue the two commands

  )set output script on
  )set output script polymer

The output is placed in the directory from which you 
invoked AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
<<outputscriptCode>>=
<<setOutputFormula>>
<<describeSetOutputFormula>>
@
\subsection{setOutputFormula}
<<setOutputFormula>>=
setOutputFormula arg ==
  arg = "%initialize%" =>
    $formulaOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $formulaOutputFile := '"CONSOLE"
    $formulaFormat := NIL

  arg = "%display%" =>
    if $formulaFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$formulaOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputFormula()

  -- try to figure out what the argument is

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'sform]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(script script))
    UPCASE(fn) in '(NO OFF)  => $formulaFormat := NIL
    UPCASE(fn) in '(YES ON) => $formulaFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $formulaOutputStream
      $formulaOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $formulaOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename =>
      sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
      SHUT $formulaOutputStream
      $formulaOutputStream := testStream
      $formulaOutputFile := object2String filename
      sayKeyedMsg("S2IV0004",['"IBM Script formula",$formulaOutputFile])
    sayKeyedMsg("S2IV0003",[fn,ft,fm])

  sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputFormula()

@
\subsection{describeSetOutputFormula}
<<describeSetOutputFormula>>=
describeSetOutputFormula() ==
  sayBrightly LIST ('%b,'")set output script",'%d,_
   '"is used to tell AXIOM to turn IBM Script formula-style",'%l,_
   '"output printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Syntax:   )set output script <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn IBM Script formula printing on",'%l,_
  '"  off         turn IBM Script formula printing off (default state)",'%l,_
  '"  console     send IBM Script formula output to screen (default state)",'%l,_
  '"  fp<.fe>     send IBM Script formula output to file with file prefix fp",'%l,_
  '"              and file extension .fe. If not given, .fe defaults to .sform.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you must issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"IBM Script formula output to the file",'%b,'"polymer.sform,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output script on",'%l,_
  '"  )set output script polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputFormula "%display%",'%d)

@
\section{output tex}
See the section tex in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
----------------------- The tex Option ------------------------

 Description: create output in TeX style

 )set output tex is used to tell AXIOM to turn TeX-style output
printing on and off, and where to place the output.  By default,
the destination for the output is the screen but printing is 
turned off.

Syntax:   )set output tex <arg>
    where arg can be one of
  on          turn TeX printing on
  off         turn TeX printing off (default state)
  console     send TeX output to screen (default state)
  fp<.fe>     send TeX output to file with file prefix fp
              and file extension .fe. If not given, 
              .fe defaults to .stex.

If you wish to send the output to a file, you must issue 
this command twice: once with on and once with the file name. 
For example, to send TeX output to the file polymer.stex, 
issue the two commands

  )set output tex on
  )set output tex polymer

The output is placed in the directory from which you invoked 
AXIOM or the one you set with the )cd system command.
The current setting is:  Off:CONSOLE 
\end{verbatim}
<<outputtexCode>>=
<<setOutputTex>>
<<describeSetOutputTex>>
@
\subsection{setOutputTex}
<<setOutputTex>>=
setOutputTex arg ==
  arg = "%initialize%" =>
    $texOutputStream :=
      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
    $texOutputFile := '"CONSOLE"
    $texFormat := NIL

  arg = "%display%" =>
    if $texFormat then label := '"On:" else label := '"Off:"
    STRCONC(label,$texOutputFile)

  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetOutputTex()

  -- try to figure out what the argument is

  if arg is [fn] and
    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
      then 'ok
      else arg := [fn,'stex]

  arg is [fn] =>
    UPCASE(fn) in '(Y N YE O OF) =>
      sayKeyedMsg("S2IV0002",'(TeX tex))
    UPCASE(fn) in '(NO OFF)  => $texFormat := NIL
    UPCASE(fn) in '(YES ON) => $texFormat := true
    UPCASE(fn) = 'CONSOLE =>
      SHUT $texOutputStream
      $texOutputStream :=
        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
      $texOutputFile := '"CONSOLE"

  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
    if (ptype := pathnameType fn) then
      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
      ft := ptype
    if null fm then fm := 'A
    filename := $FILEP(fn,ft,fm)
    null filename =>
      sayKeyedMsg("S2IV0003",[fn,ft,fm])
    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
      SHUT $texOutputStream
      $texOutputStream := testStream
      $texOutputFile := object2String filename
      sayKeyedMsg("S2IV0004",['"TeX",$texOutputFile])
    sayKeyedMsg("S2IV0003",[fn,ft,fm])

  sayKeyedMsg("S2IV0005",NIL)
  describeSetOutputTex()

@
\subsection{describeSetOutputTex}
<<describeSetOutputTex>>=
describeSetOutputTex() ==
  sayBrightly LIST ('%b,'")set output tex",'%d,_
   '"is used to tell AXIOM to turn TeX-style output",'%l,_
   '"printing on and off, and where to place the output.  By default, the",'%l,_
   '"destination for the output is the screen but printing is turned off.",'%l,_
   '%l,_
   '"Syntax:   )set output tex <arg>",'%l,_
  '"    where arg can be one of",'%l,_
  '"  on          turn TeX printing on",'%l,_
  '"  off         turn TeX printing off (default state)",'%l,_
  '"  console     send TeX output to screen (default state)",'%l,_
  '"  fp<.fe>     send TeX output to file with file prefix fp and file",'%l,_
  '"              extension .fe. If not given, .fe defaults to .stex.",'%l,
  '%l,_
  '"If you wish to send the output to a file, you must issue this command",'%l,_
  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
  '"TeX output to the file",'%b,'"polymer.stex,",'%d,'"issue the two commands",'%l,_
  '%l,_
  '"  )set output tex on",'%l,_
  '"  )set output tex polymer",'%l,_
  '%l,_
  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
  '"the one you set with the )cd system command.",'%l,_
  '"The current setting is: ",'%b,setOutputTex "%display%",'%d)

@
\section{streams calculate}
See the section streams in setvart.boot.pamphlet\cite{1}
\begin{verbatim}
              Current Values of  streams  Variables                   

Variable     Description                           Current Value
-----------------------------------------------------------------
calculate    specify number of elements to calculate    10 
showall      display all stream elements computed       off 

\end{verbatim}
<<streamscalculateCode>>=
<<setStreamsCalculate>>
<<describeSetStreamsCalculate>>
@
\subsection{setStreamsCalculate}
<<setStreamsCalculate>>=
setStreamsCalculate arg ==
  arg = "%initialize%" =>
    $streamCount := 10
  arg = "%display%" =>
    object2String $streamCount
  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
    describeSetStreamsCalculate()
  n := first arg
  (n ^= 'all) and ((not FIXP n) or (n < 0)) =>
    sayMessage ['"Your value of",:bright n,'"is invalid because ..."]
    describeSetStreamsCalculate()
    terminateSystemCommand()
  $streamCount := n

@
\subsection{describeSetStreamsCalculate}
<<describeSetStreamsCalculate>>=
describeSetStreamsCalculate() == sayKeyedMsg("S2IV0001",[$streamCount])

@
\section{License}
<<license>>=
-- Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
-- All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     - Redistributions of source code must retain the above copyright
--       notice, this list of conditions and the following disclaimer.
--
--     - Redistributions in binary form must reproduce the above copyright
--       notice, this list of conditions and the following disclaimer in
--       the documentation and/or other materials provided with the
--       distribution.
--
--     - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--       names of its contributors may be used to endorse or promote products
--       derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-- IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-- TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-- PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-- OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-- PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-- LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-- NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@
<<*>>=
<<license>>
<<exposeCode>>
<<fortrancallingCode>>
<<functionsCode>>
<<historyCode>>
<<kernelCode>>
<<naglinkCode>>
<<outputalgebraCode>>
<<outputcharactersCode>>
<<outputfortranCode>>
<<outputmathmlCode>>
<<outputopenmathCode>>
<<outputscriptCode>>
<<outputtexCode>>
<<streamscalculateCode>>
@
\section{setvars.clisp}
<<setvars.clisp>>=

(IN-PACKAGE "BOOT" )

;setExpose arg ==
;  arg = "%initialize%" => loadExposureGroupData()
;  arg = "%display%" => '"..."
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    --  give msg about exposure groups
;    displayExposedGroups()
;    --  give msg about explicitly exposed constructors
;    sayMSG '" "
;    displayExposedConstructors()
;    --  give msg about explicitly hidden constructors
;    sayMSG '" "
;    displayHiddenConstructors()
;    -- give some more details
;    sayMSG '" "
;    sayKeyedMsg("S2IZ0049D",[namestring pathname ["interp","exposed"]])
;  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
;    '(add drop initialize),NIL)) =>
;      fn = 'add  =>  setExposeAdd fnargs
;      fn = 'drop =>  setExposeDrop fnargs
;      fn = 'initialize => setExpose "%initialize%"
;      NIL
;  setExpose NIL

(DEFUN |setExpose| (|arg|) (PROG (|fnargs| |fn|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (|loadExposureGroupData|)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (MAKESTRING "...")) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|displayExposedGroups|) (|sayMSG| (MAKESTRING " ")) (|displayExposedConstructors|) (|sayMSG| (MAKESTRING " ")) (|displayHiddenConstructors|) (|sayMSG| (MAKESTRING " ")) (|sayKeyedMsg| (QUOTE S2IZ0049D) (CONS (|namestring| (|pathname| (CONS "interp" (CONS "exposed" NIL)))) NIL))) ((AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |fnargs| (QCDR |arg|)) (QUOTE T)) (SPADLET |fn| (|selectOptionLC| |fn| (QUOTE (|add| |drop| |initialize|)) NIL))) (COND ((BOOT-EQUAL |fn| (QUOTE |add|)) (|setExposeAdd| |fnargs|)) ((BOOT-EQUAL |fn| (QUOTE |drop|)) (|setExposeDrop| |fnargs|)) ((BOOT-EQUAL |fn| (QUOTE |initialize|)) (|setExpose| (QUOTE |%initialize%|))) ((QUOTE T) NIL))) ((QUOTE T) (|setExpose| NIL)))))) 
;setExposeAdd arg ==
;  (null arg) =>
;    centerAndHighlight ("The add Option",$LINELENGTH,specialChar 'hbar)
;    --  give msg about exposure groups
;    displayExposedGroups()
;    --  give msg about explicitly exposed constructors
;    sayMSG '" "
;    displayExposedConstructors()
;    sayMSG '" "
;    sayKeyedMsg("S2IZ0049E",NIL)
;  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
;    '(group constructor),NIL)) =>
;      fn = 'group  =>  setExposeAddGroup fnargs
;      fn = 'constructor =>  setExposeAddConstr fnargs
;      NIL
;  setExposeAdd NIL

(DEFUN |setExposeAdd| (|arg|) (PROG (|fnargs| |fn|) (RETURN (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The add Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|displayExposedGroups|) (|sayMSG| (MAKESTRING " ")) (|displayExposedConstructors|) (|sayMSG| (MAKESTRING " ")) (|sayKeyedMsg| (QUOTE S2IZ0049E) NIL)) ((AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |fnargs| (QCDR |arg|)) (QUOTE T)) (SPADLET |fn| (|selectOptionLC| |fn| (QUOTE (|group| |constructor|)) NIL))) (COND ((BOOT-EQUAL |fn| (QUOTE |group|)) (|setExposeAddGroup| |fnargs|)) ((BOOT-EQUAL |fn| (QUOTE |constructor|)) (|setExposeAddConstr| |fnargs|)) ((QUOTE T) NIL))) ((QUOTE T) (|setExposeAdd| NIL)))))) 
;setExposeAddGroup arg ==
;  (null arg) =>
;    centerAndHighlight("The group Option",$LINELENGTH,specialChar 'hbar)
;    --  give msg about exposure groups
;    displayExposedGroups()
;    sayMSG '" "
;    sayKeyedMsg("S2IZ0049G",[namestring pathname ["interp","exposed"]])
;    sayMSG '" "
;    sayAsManyPerLineAsPossible [object2String first x for x in
;      $globalExposureGroupAlist]
;  for x in arg repeat
;    if PAIRP x then x := QCAR x
;    x = 'all =>
;      $localExposureData.0 :=[first x for x in $globalExposureGroupAlist]
;      $localExposureData.1 :=NIL
;      $localExposureData.2 :=NIL
;      displayExposedGroups()
;      sayMSG '" "
;      displayExposedConstructors()
;      sayMSG '" "
;      displayHiddenConstructors()
;      clearClams()
;    null GETALIST($globalExposureGroupAlist,x) =>
;      sayKeyedMsg("S2IZ0049H",[x])
;    member(x,$localExposureData.0) =>
;      sayKeyedMsg("S2IZ0049I",[x,$interpreterFrameName])
;    $localExposureData.0 := MSORT cons(x,$localExposureData.0)
;    sayKeyedMsg("S2IZ0049R",[x,$interpreterFrameName])
;    clearClams()

(DEFUN |setExposeAddGroup| (|arg|) (PROG (|x|) (RETURN (SEQ (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The group Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|displayExposedGroups|) (|sayMSG| (MAKESTRING " ")) (|sayKeyedMsg| (QUOTE S2IZ0049G) (CONS (|namestring| (|pathname| (CONS "interp" (CONS "exposed" NIL)))) NIL)) (|sayMSG| (MAKESTRING " ")) (|sayAsManyPerLineAsPossible| (PROG (#0=#:G2946) (SPADLET #0# NIL) (RETURN (DO ((#1=#:G2951 |$globalExposureGroupAlist| (CDR #1#)) (|x| NIL)) ((OR (ATOM #1#) (PROGN (SETQ |x| (CAR #1#)) NIL)) (NREVERSE0 #0#)) (SEQ (EXIT (SETQ #0# (CONS (|object2String| (CAR |x|)) #0#))))))))) ((QUOTE T) (DO ((#2=#:G2962 |arg| (CDR #2#)) (|x| NIL)) ((OR (ATOM #2#) (PROGN (SETQ |x| (CAR #2#)) NIL)) NIL) (SEQ (EXIT (PROGN (COND ((PAIRP |x|) (SPADLET |x| (QCAR |x|)))) (COND ((BOOT-EQUAL |x| (QUOTE |all|)) (SETELT |$localExposureData| 0 (PROG (#3=#:G2972) (SPADLET #3# NIL) (RETURN (DO ((#4=#:G2977 |$globalExposureGroupAlist| (CDR #4#)) (|x| NIL)) ((OR (ATOM #4#) (PROGN (SETQ |x| (CAR #4#)) NIL)) (NREVERSE0 #3#)) (SEQ (EXIT (SETQ #3# (CONS (CAR |x|) #3#)))))))) (SETELT |$localExposureData| 1 NIL) (SETELT |$localExposureData| 2 NIL) (|displayExposedGroups|) (|sayMSG| (MAKESTRING " ")) (|displayExposedConstructors|) (|sayMSG| (MAKESTRING " ")) (|displayHiddenConstructors|) (|clearClams|)) ((NULL (GETALIST |$globalExposureGroupAlist| |x|)) (|sayKeyedMsg| (QUOTE S2IZ0049H) (CONS |x| NIL))) ((|member| |x| (ELT |$localExposureData| 0)) (|sayKeyedMsg| (QUOTE S2IZ0049I) (CONS |x| (CONS |$interpreterFrameName| NIL)))) ((QUOTE T) (SETELT |$localExposureData| 0 (MSORT (CONS |x| (ELT |$localExposureData| 0)))) (|sayKeyedMsg| (QUOTE S2IZ0049R) (CONS |x| (CONS |$interpreterFrameName| NIL))) (|clearClams|))))))))))))) 
;setExposeAddConstr arg ==
;  (null arg) =>
;    centerAndHighlight ("The constructor Option",$LINELENGTH,
;      specialChar 'hbar)
;    --  give msg about explicitly exposed constructors
;    displayExposedConstructors()
;  for x in arg repeat
;    x := unabbrev x
;    if PAIRP x then x := QCAR x
;    -- if the constructor is known, we know what type it is
;    null GETDATABASE(x,'CONSTRUCTORKIND) =>
;      sayKeyedMsg("S2IZ0049J",[x])
;    member(x,$localExposureData.1) =>
;      sayKeyedMsg("S2IZ0049K",[x,$interpreterFrameName])
;    -- if the constructor is explicitly hidden, then remove that
;    if member(x,$localExposureData.2) then
;      $localExposureData.2 := DELETE(x,$localExposureData.2)
;    $localExposureData.1 := MSORT cons(x,$localExposureData.1)
;    clearClams()
;    sayKeyedMsg("S2IZ0049P",[x,$interpreterFrameName])

(DEFUN |setExposeAddConstr| (|arg|) (PROG (|x|) (RETURN (SEQ (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The constructor Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|displayExposedConstructors|)) ((QUOTE T) (DO ((#0=#:G2998 |arg| (CDR #0#)) (|x| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (PROGN (SPADLET |x| (|unabbrev| |x|)) (COND ((PAIRP |x|) (SPADLET |x| (QCAR |x|)))) (COND ((NULL (GETDATABASE |x| (QUOTE CONSTRUCTORKIND))) (|sayKeyedMsg| (QUOTE S2IZ0049J) (CONS |x| NIL))) ((|member| |x| (ELT |$localExposureData| 1)) (|sayKeyedMsg| (QUOTE S2IZ0049K) (CONS |x| (CONS |$interpreterFrameName| NIL)))) ((QUOTE T) (COND ((|member| |x| (ELT |$localExposureData| 2)) (SETELT |$localExposureData| 2 (|delete| |x| (ELT |$localExposureData| 2))))) (SETELT |$localExposureData| 1 (MSORT (CONS |x| (ELT |$localExposureData| 1)))) (|clearClams|) (|sayKeyedMsg| (QUOTE S2IZ0049P) (CONS |x| (CONS |$interpreterFrameName| NIL))))))))))))))) 
;setExposeDrop arg ==
;  (null arg) =>
;    centerAndHighlight ("The drop Option",$LINELENGTH,specialChar 'hbar)
;    --  give msg about explicitly hidden constructors
;    displayHiddenConstructors()
;    sayMSG '" "
;    sayKeyedMsg("S2IZ0049F",NIL)
;  arg is [fn,:fnargs] and (fn := selectOptionLC(fn,
;    '(group constructor),NIL)) =>
;      fn = 'group  =>  setExposeDropGroup fnargs
;      fn = 'constructor =>  setExposeDropConstr fnargs
;      NIL
;  setExposeDrop NIL

(DEFUN |setExposeDrop| (|arg|) (PROG (|fnargs| |fn|) (RETURN (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The drop Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|displayHiddenConstructors|) (|sayMSG| (MAKESTRING " ")) (|sayKeyedMsg| (QUOTE S2IZ0049F) NIL)) ((AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |fnargs| (QCDR |arg|)) (QUOTE T)) (SPADLET |fn| (|selectOptionLC| |fn| (QUOTE (|group| |constructor|)) NIL))) (COND ((BOOT-EQUAL |fn| (QUOTE |group|)) (|setExposeDropGroup| |fnargs|)) ((BOOT-EQUAL |fn| (QUOTE |constructor|)) (|setExposeDropConstr| |fnargs|)) ((QUOTE T) NIL))) ((QUOTE T) (|setExposeDrop| NIL)))))) 
;setExposeDropGroup arg ==
;  (null arg) =>
;    centerAndHighlight ("The group Option",$LINELENGTH,specialChar 'hbar)
;    sayKeyedMsg("S2IZ0049L",NIL)
;    sayMSG '" "
;    displayExposedGroups()
;  for x in arg repeat
;    if PAIRP x then x := QCAR x
;    x = 'all =>
;      $localExposureData.0 := NIL
;      $localExposureData.1 := NIL
;      $localExposureData.2 := NIL
;      displayExposedGroups()
;      sayMSG '" "
;      displayExposedConstructors()
;      sayMSG '" "
;      displayHiddenConstructors()
;      clearClams()
;    member(x,$localExposureData.0) =>
;      $localExposureData.0 := DELETE(x,$localExposureData.0)
;      clearClams()
;      sayKeyedMsg("S2IZ0049S",[x,$interpreterFrameName])
;    GETALIST($globalExposureGroupAlist,x) =>
;      sayKeyedMsg("S2IZ0049I",[x,$interpreterFrameName])
;    sayKeyedMsg("S2IZ0049H",[x])

(DEFUN |setExposeDropGroup| (|arg|) (PROG (|x|) (RETURN (SEQ (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The group Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|sayKeyedMsg| (QUOTE S2IZ0049L) NIL) (|sayMSG| (MAKESTRING " ")) (|displayExposedGroups|)) ((QUOTE T) (DO ((#0=#:G3031 |arg| (CDR #0#)) (|x| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (PROGN (COND ((PAIRP |x|) (SPADLET |x| (QCAR |x|)))) (COND ((BOOT-EQUAL |x| (QUOTE |all|)) (SETELT |$localExposureData| 0 NIL) (SETELT |$localExposureData| 1 NIL) (SETELT |$localExposureData| 2 NIL) (|displayExposedGroups|) (|sayMSG| (MAKESTRING " ")) (|displayExposedConstructors|) (|sayMSG| (MAKESTRING " ")) (|displayHiddenConstructors|) (|clearClams|)) ((|member| |x| (ELT |$localExposureData| 0)) (SETELT |$localExposureData| 0 (|delete| |x| (ELT |$localExposureData| 0))) (|clearClams|) (|sayKeyedMsg| (QUOTE S2IZ0049S) (CONS |x| (CONS |$interpreterFrameName| NIL)))) ((GETALIST |$globalExposureGroupAlist| |x|) (|sayKeyedMsg| (QUOTE S2IZ0049I) (CONS |x| (CONS |$interpreterFrameName| NIL)))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IZ0049H) (CONS |x| NIL)))))))))))))) 
;setExposeDropConstr arg ==
;  (null arg) =>
;    centerAndHighlight ("The constructor Option",$LINELENGTH,
;      specialChar 'hbar)
;    sayKeyedMsg("S2IZ0049N",NIL)
;    sayMSG '" "
;    displayExposedConstructors()
;    sayMSG '" "
;    displayHiddenConstructors()
;  for x in arg repeat
;    x := unabbrev x
;    if PAIRP x then x := QCAR x
;    -- if the constructor is known, we know what type it is
;    null GETDATABASE(x,'CONSTRUCTORKIND) =>
;      sayKeyedMsg("S2IZ0049J",[x])
;    member(x,$localExposureData.2) =>
;      sayKeyedMsg("S2IZ0049O",[x,$interpreterFrameName])
;    if member(x,$localExposureData.1) then
;      $localExposureData.1 := DELETE(x,$localExposureData.1)
;    $localExposureData.2 := MSORT cons(x,$localExposureData.2)
;    clearClams()
;    sayKeyedMsg("S2IZ0049Q",[x,$interpreterFrameName])

(DEFUN |setExposeDropConstr| (|arg|) (PROG (|x|) (RETURN (SEQ (COND ((NULL |arg|) (|centerAndHighlight| (QUOTE |The constructor Option|) $LINELENGTH (|specialChar| (QUOTE |hbar|))) (|sayKeyedMsg| (QUOTE S2IZ0049N) NIL) (|sayMSG| (MAKESTRING " ")) (|displayExposedConstructors|) (|sayMSG| (MAKESTRING " ")) (|displayHiddenConstructors|)) ((QUOTE T) (DO ((#0=#:G3050 |arg| (CDR #0#)) (|x| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (PROGN (SPADLET |x| (|unabbrev| |x|)) (COND ((PAIRP |x|) (SPADLET |x| (QCAR |x|)))) (COND ((NULL (GETDATABASE |x| (QUOTE CONSTRUCTORKIND))) (|sayKeyedMsg| (QUOTE S2IZ0049J) (CONS |x| NIL))) ((|member| |x| (ELT |$localExposureData| 2)) (|sayKeyedMsg| (QUOTE S2IZ0049O) (CONS |x| (CONS |$interpreterFrameName| NIL)))) ((QUOTE T) (COND ((|member| |x| (ELT |$localExposureData| 1)) (SETELT |$localExposureData| 1 (|delete| |x| (ELT |$localExposureData| 1))))) (SETELT |$localExposureData| 2 (MSORT (CONS |x| (ELT |$localExposureData| 2)))) (|clearClams|) (|sayKeyedMsg| (QUOTE S2IZ0049Q) (CONS |x| (CONS |$interpreterFrameName| NIL))))))))))))))) 
;setFortTmpDir arg ==
;  arg = "%initialize%" =>
;    $fortranTmpDir := '"/tmp/"
;  arg = "%display%" =>
;    STRINGP $fortranTmpDir => $fortranTmpDir
;    PNAME $fortranTmpDir
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetFortTmpDir()
;  -- try to figure out what the argument is
;  -- VM code - must be an accessed disk mode [mode]
;  not (mode := validateOutputDirectory arg) =>
;    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
;      '"is(are) not valid.",'%l]
;    describeSetFortTmpDir()
;  $fortranTmpDir := mode

(DEFUN |setFortTmpDir| (|arg|) (PROG (|mode|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranTmpDir| (MAKESTRING "/tmp/"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND ((STRINGP |$fortranTmpDir|) |$fortranTmpDir|) ((QUOTE T) (PNAME |$fortranTmpDir|)))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetFortTmpDir|)) ((NULL (SPADLET |mode| (|validateOutputDirectory| |arg|))) (|sayBrightly| (CONS (MAKESTRING " Sorry, but your argument(s)") (APPEND (|bright| |arg|) (CONS (MAKESTRING "is(are) not valid.") (CONS (QUOTE |%l|) NIL))))) (|describeSetFortTmpDir|)) ((QUOTE T) (SPADLET |$fortranTmpDir| |mode|)))))) 
;validateOutputDirectory x ==
;  AND(PATHNAME_-DIRECTORY(PROBE_-FILE(CAR(x))), NOT PATHNAME_-NAME  (PROBE_-FILE(CAR(x)))) =>
;    CAR(x)
;  NIL

(DEFUN |validateOutputDirectory| (|x|) (COND ((AND (PATHNAME-DIRECTORY (PROBE-FILE (CAR |x|))) (NULL (PATHNAME-NAME (PROBE-FILE (CAR |x|))))) (CAR |x|)) ((QUOTE T) NIL))) 
;describeSetFortTmpDir() ==
;  sayBrightly LIST (
;   '%b,'")set fortran calling tempfile",'%d,_
;   '" is used to tell AXIOM where",'%l,_
;   '" to place intermediate FORTRAN data files . This must be the ",'%l,_
;   '" name of a valid existing directory to which you have permission ",'%l,_
;   '" to write (including the final slash).",'%l,'%l,_
;   '" Syntax:",'%l,_
;   '"   )set fortran calling tempfile DIRECTORYNAME",'%l,'%l,_
;   '" The current setting is",'%b,$fortranTmpDir,'%d)

(DEFUN |describeSetFortTmpDir| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling tempfile") (QUOTE |%d|) (MAKESTRING " is used to tell AXIOM where") (QUOTE |%l|) (MAKESTRING " to place intermediate FORTRAN data files . This must be the ") (QUOTE |%l|) (MAKESTRING " name of a valid existing directory to which you have permission ") (QUOTE |%l|) (MAKESTRING " to write (including the final slash).") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Syntax:") (QUOTE |%l|) (MAKESTRING "   )set fortran calling tempfile DIRECTORYNAME") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranTmpDir| (QUOTE |%d|)))) 
;setFortDir arg ==
;  arg = "%initialize%" =>
;    $fortranDirectory := '"./"
;  arg = "%display%" =>
;    STRINGP $fortranDirectory => $fortranDirectory
;    PNAME $fortranDirectory
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetFortDir()
;  -- try to figure out what the argument is
;  -- VM code - must be an accessed disk mode [mode]
;  not (mode := validateOutputDirectory arg) =>
;    sayBrightly ['" Sorry, but your argument(s)",:bright arg,
;      '"is(are) not valid.",'%l]
;    describeSetFortDir()
;  $fortranDirectory := mode

(DEFUN |setFortDir| (|arg|) (PROG (|mode|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranDirectory| (MAKESTRING "./"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND ((STRINGP |$fortranDirectory|) |$fortranDirectory|) ((QUOTE T) (PNAME |$fortranDirectory|)))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetFortDir|)) ((NULL (SPADLET |mode| (|validateOutputDirectory| |arg|))) (|sayBrightly| (CONS (MAKESTRING " Sorry, but your argument(s)") (APPEND (|bright| |arg|) (CONS (MAKESTRING "is(are) not valid.") (CONS (QUOTE |%l|) NIL))))) (|describeSetFortDir|)) ((QUOTE T) (SPADLET |$fortranDirectory| |mode|)))))) 
;describeSetFortDir() ==
;  sayBrightly LIST (
;   '%b,'")set fortran calling directory",'%d,_
;   '" is used to tell AXIOM where",'%l,_
;   '" to place generated FORTRAN files. This must be the name ",'%l,_
;   '" of a valid existing directory to which you have permission ",'%l,_
;   '" to write (including the final slash).",'%l,'%l,_
;   '" Syntax:",'%l,_
;   '"   )set fortran calling directory DIRECTORYNAME",'%l,'%l,_
;   '" The current setting is",'%b,$fortranDirectory,'%d)

(DEFUN |describeSetFortDir| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling directory") (QUOTE |%d|) (MAKESTRING " is used to tell AXIOM where") (QUOTE |%l|) (MAKESTRING " to place generated FORTRAN files. This must be the name ") (QUOTE |%l|) (MAKESTRING " of a valid existing directory to which you have permission ") (QUOTE |%l|) (MAKESTRING " to write (including the final slash).") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Syntax:") (QUOTE |%l|) (MAKESTRING "   )set fortran calling directory DIRECTORYNAME") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranDirectory| (QUOTE |%d|)))) 
;setLinkerArgs arg ==
;  arg = "%initialize%" =>
;    $fortranLibraries := '"-lxlf"
;  arg = "%display%" => object2String $fortranLibraries
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetLinkerArgs()
;  LISTP(arg) and STRINGP(first arg) =>
;    $fortranLibraries := first(arg)
;  describeSetLinkerArgs()

(DEFUN |setLinkerArgs| (|arg|) (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranLibraries| (MAKESTRING "-lxlf"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (|object2String| |$fortranLibraries|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetLinkerArgs|)) ((AND (LISTP |arg|) (STRINGP (CAR |arg|))) (SPADLET |$fortranLibraries| (CAR |arg|))) ((QUOTE T) (|describeSetLinkerArgs|)))) 
;describeSetLinkerArgs() ==
;  sayBrightly LIST (
;   '%b,'")set fortran calling linkerargs",'%d,_
;   '" is used to pass arguments to the linker",'%l,_
;   '" when using ",'%b,'"mkFort",'%d,_
;   '" to create functions which call Fortran code.",'%l,_
;   '" For example, it might give a list of libraries to be searched,",'%l,_
;   '" and their locations.",'%l,_
;   '" The string is passed verbatim, so must be the correct syntax for",'%l,_
;   '" the particular linker being used.",'%l,'%l,_
;   '" Example: )set fortran calling linker _"-lxlf_"",'%l,'%l,_
;   '" The current setting is",'%b,$fortranLibraries,'%d)

(DEFUN |describeSetLinkerArgs| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set fortran calling linkerargs") (QUOTE |%d|) (MAKESTRING " is used to pass arguments to the linker") (QUOTE |%l|) (MAKESTRING " when using ") (QUOTE |%b|) (MAKESTRING "mkFort") (QUOTE |%d|) (MAKESTRING " to create functions which call Fortran code.") (QUOTE |%l|) (MAKESTRING " For example, it might give a list of libraries to be searched,") (QUOTE |%l|) (MAKESTRING " and their locations.") (QUOTE |%l|) (MAKESTRING " The string is passed verbatim, so must be the correct syntax for") (QUOTE |%l|) (MAKESTRING " the particular linker being used.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " Example: )set fortran calling linker \"-lxlf\"") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortranLibraries| (QUOTE |%d|)))) 
;setFunctionsCache arg ==
;  $options : local := NIL
;  arg = "%initialize%" =>
;    $cacheCount := 0
;    $cacheAlist := NIL
;  arg = "%display%" =>
;    null $cacheAlist => object2String $cacheCount
;    '"..."
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetFunctionsCache()
;    TERPRI()
;    sayAllCacheCounts()
;  n := first arg
;  (n ^= 'all) and ((not FIXP n) or (n < 0)) =>
;    sayMessage ['"Your value of",:bright n,'"is invalid because ..."]
;    describeSetFunctionsCache()
;    terminateSystemCommand()
;  if (rest arg) then $options := [['vars,:rest arg]]
;  countCache n

(DEFUN |setFunctionsCache| (|arg|) (PROG (|$options| |n|) (DECLARE (SPECIAL |$options|)) (RETURN (PROGN (SPADLET |$options| NIL) (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$cacheCount| 0) (SPADLET |$cacheAlist| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND ((NULL |$cacheAlist|) (|object2String| |$cacheCount|)) ((QUOTE T) (MAKESTRING "...")))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetFunctionsCache|) (TERPRI) (|sayAllCacheCounts|)) ((QUOTE T) (SPADLET |n| (CAR |arg|)) (COND ((AND (NEQUAL |n| (QUOTE |all|)) (OR (NULL (FIXP |n|)) (MINUSP |n|))) (|sayMessage| (CONS (MAKESTRING "Your value of") (APPEND (|bright| |n|) (CONS (MAKESTRING "is invalid because ...") NIL)))) (|describeSetFunctionsCache|) (|terminateSystemCommand|)) ((QUOTE T) (COND ((CDR |arg|) (SPADLET |$options| (CONS (CONS (QUOTE |vars|) (CDR |arg|)) NIL)))) (|countCache| |n|))))))))) 
;countCache n ==
;  $options =>
;    $options is [["vars",:l]] =>
;      for x in l repeat
;        NULL IDENTP x => sayKeyedMsg("S2IF0007",[x])
;        $cacheAlist:= insertAlist(x,n,$cacheAlist)
;        cacheCountName:= INTERNL(x,'";COUNT")
;        SET(cacheCountName,n)
;        sayCacheCount(x,n)
;    optionError(CAAR $options,nil)
;  sayCacheCount(nil,$cacheCount:= n)

(DEFUN |countCache| (|n|) (PROG (|ISTMP#1| |l| |cacheCountName|) (RETURN (SEQ (COND (|$options| (COND ((AND (PAIRP |$options|) (EQ (QCDR |$options|) NIL) (PROGN (SPADLET |ISTMP#1| (QCAR |$options|)) (AND (PAIRP |ISTMP#1|) (EQ (QCAR |ISTMP#1|) (QUOTE |vars|)) (PROGN (SPADLET |l| (QCDR |ISTMP#1|)) (QUOTE T))))) (DO ((#0=#:G3123 |l| (CDR #0#)) (|x| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |x| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (COND ((NULL (IDENTP |x|)) (|sayKeyedMsg| (QUOTE S2IF0007) (CONS |x| NIL))) ((QUOTE T) (SPADLET |$cacheAlist| (|insertAlist| |x| |n| |$cacheAlist|)) (SPADLET |cacheCountName| (INTERNL |x| (MAKESTRING ";COUNT"))) (SET |cacheCountName| |n|) (|sayCacheCount| |x| |n|))))))) ((QUOTE T) (|optionError| (CAAR |$options|) NIL)))) ((QUOTE T) (|sayCacheCount| NIL (SPADLET |$cacheCount| |n|)))))))) 
;describeSetFunctionsCache() ==
;  sayBrightly LIST(
;    '%b,'")set functions cache",'%d,'"is used to tell AXIOM how many",'%l,_
;    '" values computed by interpreter functions should be saved.  This can save ",'%l, _
;    '" quite a bit of time in recursive functions, though one must consider that",'%l,_
;    '" the cached values will take up (perhaps valuable) room in the workspace.",'%l,'%l,_
;    '" The value given  after",'%b,'"cache",'%d,'"must either be the",_
;    '" word",'%b,'"all",'%d,'"or a positive",'%l,_
;    '" integer.  This may be followed by any number of function names whose cache",'%l,_
;    '" sizes you wish to so set.  If no functions are given, the default cache",'%l,_
;    '" size is set.",'%l,'" Examples:",_
;    '"   )set fun cache all         )set fun cache 10 f g Legendre")

(DEFUN |describeSetFunctionsCache| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set functions cache") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM how many") (QUOTE |%l|) (MAKESTRING " values computed by interpreter functions should be saved.  This can save ") (QUOTE |%l|) (MAKESTRING " quite a bit of time in recursive functions, though one must consider that") (QUOTE |%l|) (MAKESTRING " the cached values will take up (perhaps valuable) room in the workspace.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The value given  after") (QUOTE |%b|) (MAKESTRING "cache") (QUOTE |%d|) (MAKESTRING "must either be the") (MAKESTRING " word") (QUOTE |%b|) (MAKESTRING "all") (QUOTE |%d|) (MAKESTRING "or a positive") (QUOTE |%l|) (MAKESTRING " integer.  This may be followed by any number of function names whose cache") (QUOTE |%l|) (MAKESTRING " sizes you wish to so set.  If no functions are given, the default cache") (QUOTE |%l|) (MAKESTRING " size is set.") (QUOTE |%l|) (MAKESTRING " Examples:") (MAKESTRING "   )set fun cache all         )set fun cache 10 f g Legendre")))) 
;sayAllCacheCounts () ==
;  sayCacheCount(nil,$cacheCount)
;  $cacheAlist =>
;    TERPRI()
;--    SAY '" However,"
;    for [x,:n] in $cacheAlist | n ^= $cacheCount repeat sayCacheCount(x,n)

(DEFUN |sayAllCacheCounts| NIL (PROG (|x| |n|) (RETURN (SEQ (PROGN (|sayCacheCount| NIL |$cacheCount|) (COND (|$cacheAlist| (PROGN (TERPRI) (DO ((#0=#:G3151 |$cacheAlist| (CDR #0#)) (#1=#:G3140 NIL)) ((OR (ATOM #0#) (PROGN (SETQ #1# (CAR #0#)) NIL) (PROGN (PROGN (SPADLET |x| (CAR #1#)) (SPADLET |n| (CDR #1#)) #1#) NIL)) NIL) (SEQ (EXIT (COND ((NEQUAL |n| |$cacheCount|) (|sayCacheCount| |x| |n|)))))))))))))) 
;sayCacheCount(fn,n) ==
;  prefix:=
;    fn => ["function",:bright linearFormatName fn]
;    n = 0 => ["interpreter functions "]
;    ["In general, interpreter functions "]
;  n = 0 =>
;    fn =>
;      sayBrightly ['"   Caching for ",:prefix,
;        '"is turned off"]
;    sayBrightly '" In general, functions will cache no returned values."
;  phrase:=
;    n="all" => [:bright "all","values."]
;    n=1 => [" only the last value."]
;    [" the last",:bright n,"values."]
;  sayBrightly ['"   ",:prefix,'"will cache",:phrase]

(DEFUN |sayCacheCount| (|fn| |n|) (PROG (|prefix| |phrase|) (RETURN (PROGN (SPADLET |prefix| (COND (|fn| (CONS (QUOTE |function|) (|bright| (|linearFormatName| |fn|)))) ((EQL |n| 0) (CONS (QUOTE |interpreter functions |) NIL)) ((QUOTE T) (CONS (QUOTE |In general, interpreter functions |) NIL)))) (COND ((EQL |n| 0) (COND (|fn| (|sayBrightly| (CONS (MAKESTRING "   Caching for ") (APPEND |prefix| (CONS (MAKESTRING "is turned off") NIL))))) ((QUOTE T) (|sayBrightly| (MAKESTRING " In general, functions will cache no returned values."))))) ((QUOTE T) (SPADLET |phrase| (COND ((BOOT-EQUAL |n| (QUOTE |all|)) (APPEND (|bright| (QUOTE |all|)) (CONS (QUOTE |values.|) NIL))) ((EQL |n| 1) (CONS (QUOTE | only the last value.|) NIL)) ((QUOTE T) (CONS (QUOTE | the last|) (APPEND (|bright| |n|) (CONS (QUOTE |values.|) NIL)))))) (|sayBrightly| (CONS (MAKESTRING "   ") (APPEND |prefix| (CONS (MAKESTRING "will cache") |phrase|)))))))))) 
;setHistory arg ==
;  -- this is just a front end for the history functions
;  arg = "%initialize%" => nil
;  current := object2String translateTrueFalse2YesNo $HiFiAccess
;  arg = "%display%" => current
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    sayMessage ['" The",:bright '"history",'"option",
;      '" may be followed by any one of the following:"]
;    for name in '("on" "off" "yes" "no") repeat
;      if name = current
;        then sayBrightly ['" ->",:bright name]
;        else sayBrightly ['"    ",name]
;    TERPRI()
;    sayBrightly '" The current setting is indicated within the list."
;    sayBrightly [:bright '"yes",'"and",:bright '"no",
;     '"have the same effect as",:bright '"on",'"and",:bright '"off",
;       '"respectively."]
;    if $useInternalHistoryTable
;      then wh := '"memory"
;      else wh := '"a file"
;    sayBrightly ['%l,'" When the history facility is active, the data",
;      '" is kept in ",wh,'"."]
;    sayMessage ['" Issue",:bright '")help history",
;      '"for more information."]
;  arg is [fn] and
;   (fn := DOWNCASE(fn)) in '(y n ye yes no on of off) =>
;    $options := [[fn]]
;    historySpad2Cmd()
;  setHistory NIL

(DEFUN |setHistory| (|arg|) (PROG (|current| |wh| |fn|) (RETURN (SEQ (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) NIL) ((QUOTE T) (SPADLET |current| (|object2String| (|translateTrueFalse2YesNo| |$HiFiAccess|))) (COND ((BOOT-EQUAL |arg| (QUOTE |%display%|)) |current|) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|sayMessage| (CONS (MAKESTRING " The") (APPEND (|bright| (MAKESTRING "history")) (CONS (MAKESTRING "option") (CONS (MAKESTRING " may be followed by any one of the following:") NIL))))) (DO ((#0=#:G3178 (QUOTE ("on" "off" "yes" "no")) (CDR #0#)) (|name| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |name| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (COND ((BOOT-EQUAL |name| |current|) (|sayBrightly| (CONS (MAKESTRING " ->") (|bright| |name|)))) ((QUOTE T) (|sayBrightly| (CONS (MAKESTRING "    ") (CONS |name| NIL)))))))) (TERPRI) (|sayBrightly| (MAKESTRING " The current setting is indicated within the list.")) (|sayBrightly| (APPEND (|bright| (MAKESTRING "yes")) (CONS (MAKESTRING "and") (APPEND (|bright| (MAKESTRING "no")) (CONS (MAKESTRING "have the same effect as") (APPEND (|bright| (MAKESTRING "on")) (CONS (MAKESTRING "and") (APPEND (|bright| (MAKESTRING "off")) (CONS (MAKESTRING "respectively.") NIL))))))))) (COND (|$useInternalHistoryTable| (SPADLET |wh| (MAKESTRING "memory"))) ((QUOTE T) (SPADLET |wh| (MAKESTRING "a file")))) (|sayBrightly| (CONS (QUOTE |%l|) (CONS (MAKESTRING " When the history facility is active, the data") (CONS (MAKESTRING " is kept in ") (CONS |wh| (CONS (MAKESTRING ".") NIL)))))) (|sayMessage| (CONS (MAKESTRING " Issue") (APPEND (|bright| (MAKESTRING ")help history")) (CONS (MAKESTRING "for more information.") NIL))))) ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| (SPADLET |fn| (DOWNCASE |fn|)) (QUOTE (|y| |n| |ye| |yes| |no| |on| |of| |off|)))) (SPADLET |$options| (CONS (CONS |fn| NIL) NIL)) (|historySpad2Cmd|)) ((QUOTE T) (|setHistory| NIL))))))))) 
;describeProtectedSymbolsWarning() ==
; sayBrightly LIST(
;  '"Some AXIOM library functions are compiled into the kernel for efficiency",_
;  '%l,'"reasons.  To prevent them being re-defined when loaded from a library",_
;  '%l,'"they are specially protected.  If a user wishes to know when an attempt",_
;  '%l,'"is made to re-define such a function, he or she should issue the command:",_
;  '%l,'"        )set kernel warn on",_
;  '%l,'"To restore the default behaviour, he or she should issue the command:",_
;  '%l,'"        )set kernel warn off")

(DEFUN |describeProtectedSymbolsWarning| NIL (|sayBrightly| (LIST (MAKESTRING "Some AXIOM library functions are compiled into the kernel for efficiency") (QUOTE |%l|) (MAKESTRING "reasons.  To prevent them being re-defined when loaded from a library") (QUOTE |%l|) (MAKESTRING "they are specially protected.  If a user wishes to know when an attempt") (QUOTE |%l|) (MAKESTRING "is made to re-define such a function, he or she should issue the command:") (QUOTE |%l|) (MAKESTRING "        )set kernel warn on") (QUOTE |%l|) (MAKESTRING "To restore the default behaviour, he or she should issue the command:") (QUOTE |%l|) (MAKESTRING "        )set kernel warn off")))) 
;protectedSymbolsWarning arg ==
;  arg = "%initialize%" => PROTECTED_-SYMBOL_-WARN(false)
;  arg = "%display%" =>
;    v := PROTECTED_-SYMBOL_-WARN(true)
;    PROTECTED_-SYMBOL_-WARN(v)
;    v => '"on"
;    '"off"
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeProtectedSymbolsWarning()
;  PROTECTED_-SYMBOL_-WARN translateYesNo2TrueFalse first arg

(DEFUN |protectedSymbolsWarning| (|arg|) (PROG (|v|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (PROTECTED-SYMBOL-WARN NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (SPADLET |v| (PROTECTED-SYMBOL-WARN (QUOTE T))) (PROTECTED-SYMBOL-WARN |v|) (COND (|v| (MAKESTRING "on")) ((QUOTE T) (MAKESTRING "off")))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeProtectedSymbolsWarning|)) ((QUOTE T) (PROTECTED-SYMBOL-WARN (|translateYesNo2TrueFalse| (CAR |arg|)))))))) 
;describeProtectSymbols() ==
; sayBrightly LIST(
;  '"Some AXIOM library functions are compiled into the kernel for efficiency",_
;  '%l,'"reasons.  To prevent them being re-defined when loaded from a library",_
;  '%l,'"they are specially protected.  If a user wishes to re-define these",_
;  '%l,'"functions, he or she should issue the command:",_
;  '%l,'"        )set kernel protect off",_
;  '%l,'"To restore the default behaviour, he or she should issue the command:",_
;  '%l,'"        )set kernel protect on")

(DEFUN |describeProtectSymbols| NIL (|sayBrightly| (LIST (MAKESTRING "Some AXIOM library functions are compiled into the kernel for efficiency") (QUOTE |%l|) (MAKESTRING "reasons.  To prevent them being re-defined when loaded from a library") (QUOTE |%l|) (MAKESTRING "they are specially protected.  If a user wishes to re-define these") (QUOTE |%l|) (MAKESTRING "functions, he or she should issue the command:") (QUOTE |%l|) (MAKESTRING "        )set kernel protect off") (QUOTE |%l|) (MAKESTRING "To restore the default behaviour, he or she should issue the command:") (QUOTE |%l|) (MAKESTRING "        )set kernel protect on")))) 
;protectSymbols arg ==
;  arg = "%initialize%" => PROTECT_-SYMBOLS(true)
;  arg = "%display%" =>
;    v := PROTECT_-SYMBOLS(true)
;    PROTECT_-SYMBOLS(v)
;    v => '"on"
;    '"off"
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeProtectSymbols()
;  PROTECT_-SYMBOLS translateYesNo2TrueFalse first arg

(DEFUN |protectSymbols| (|arg|) (PROG (|v|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (PROTECT-SYMBOLS (QUOTE T))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (SPADLET |v| (PROTECT-SYMBOLS (QUOTE T))) (PROTECT-SYMBOLS |v|) (COND (|v| (MAKESTRING "on")) ((QUOTE T) (MAKESTRING "off")))) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeProtectSymbols|)) ((QUOTE T) (PROTECT-SYMBOLS (|translateYesNo2TrueFalse| (CAR |arg|)))))))) 
;setNagHost arg ==
;  arg = "%initialize%" =>
;    $nagHost := '"localhost"
;  arg = "%display%" =>
;    object2String $nagHost
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetNagHost()
;  $nagHost := object2String arg

(DEFUN |setNagHost| (|arg|) (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$nagHost| (MAKESTRING "localhost"))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (|object2String| |$nagHost|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetNagHost|)) ((QUOTE T) (SPADLET |$nagHost| (|object2String| |arg|))))) 
;describeSetNagHost() ==
;  sayBrightly LIST (
;   '%b,'")set naglink host",'%d,_
;   '"is used to tell  AXIOM which  host to contact for",'%l,_
;   '" a NAGLink request. An Internet address should be supplied. The host",'%l,_
;   '" specified must be running the NAGLink daemon.",'%l,'%l,_
;   '" The current setting is",'%b,$nagHost,'%d)

(DEFUN |describeSetNagHost| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set naglink host") (QUOTE |%d|) (MAKESTRING "is used to tell  AXIOM which  host to contact for") (QUOTE |%l|) (MAKESTRING " a NAGLink request. An Internet address should be supplied. The host") (QUOTE |%l|) (MAKESTRING " specified must be running the NAGLink daemon.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$nagHost| (QUOTE |%d|)))) 
;setFortPers arg ==
;  arg = "%initialize%" =>
;    $fortPersistence := 1
;  arg = "%display%" =>
;    $fortPersistence
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeFortPersistence()
;  n := first arg
;  ((not FIXP n) or (n < 0)) =>
;    sayMessage ['"Your value of",:bright n,'"is invalid because ..."]
;    describeFortPersistence()
;    terminateSystemCommand()
;  $fortPersistence := first(arg)

(DEFUN |setFortPers| (|arg|) (PROG (|n|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortPersistence| 1)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) |$fortPersistence|) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeFortPersistence|)) ((QUOTE T) (SPADLET |n| (CAR |arg|)) (COND ((OR (NULL (FIXP |n|)) (MINUSP |n|)) (|sayMessage| (CONS (MAKESTRING "Your value of") (APPEND (|bright| |n|) (CONS (MAKESTRING "is invalid because ...") NIL)))) (|describeFortPersistence|) (|terminateSystemCommand|)) ((QUOTE T) (SPADLET |$fortPersistence| (CAR |arg|))))))))) 
;describeFortPersistence() ==
;  sayBrightly LIST (
;   '%b,'")set naglink persistence",'%d,_
;   '"is used to tell  the ",'%b,"nagd",'%d," daemon how  many ASP",'%l,_
;   '" source and object files to keep around in case you reuse them. This helps",'%l,_
;   '" to avoid needless recompilations. The number specified should be a ",'%l,_
;   '" non-negative integer.", '%l,'%l,_
;   '" The current setting is",'%b,$fortPersistence,'%d)

(DEFUN |describeFortPersistence| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set naglink persistence") (QUOTE |%d|) (MAKESTRING "is used to tell  the ") (QUOTE |%b|) (QUOTE |nagd|) (QUOTE |%d|) (QUOTE | daemon how  many ASP|) (QUOTE |%l|) (MAKESTRING " source and object files to keep around in case you reuse them. This helps") (QUOTE |%l|) (MAKESTRING " to avoid needless recompilations. The number specified should be a ") (QUOTE |%l|) (MAKESTRING " non-negative integer.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING " The current setting is") (QUOTE |%b|) |$fortPersistence| (QUOTE |%d|)))) 
;setOutputAlgebra arg ==
;  arg = "%initialize%" =>
;    $algebraOutputStream :=
;      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;    $algebraOutputFile := '"CONSOLE"
;    $algebraFormat := true
;  arg = "%display%" =>
;    if $algebraFormat then label := '"On:" else label := '"Off:"
;    STRCONC(label,$algebraOutputFile)
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetOutputAlgebra()
;  -- try to figure out what the argument is
;  if arg is [fn] and
;    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
;      then 'ok
;      else arg := [fn,'spout]
;  arg is [fn] =>
;    UPCASE(fn) in '(Y N YE O OF) =>
;      sayKeyedMsg("S2IV0002",'(algebra algebra))
;    UPCASE(fn) in '(NO OFF)  => $algebraFormat := NIL
;    UPCASE(fn) in '(YES ON) => $algebraFormat := true
;    UPCASE(fn) = 'CONSOLE =>
;      SHUT $algebraOutputStream
;      $algebraOutputStream :=
;        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;      $algebraOutputFile := '"CONSOLE"
;  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
;    if (ptype := pathnameType fn) then
;      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
;      ft := ptype
;    if null fm then fm := 'A
;    filename := $FILEP(fn,ft,fm)
;    null filename =>
;      sayKeyedMsg("S2IV0003",[fn,ft,fm])
;    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
;      SHUT $algebraOutputStream
;      $algebraOutputStream := testStream
;      $algebraOutputFile := object2String filename
;      sayKeyedMsg("S2IV0004",['"Algebra",$algebraOutputFile])
;    sayKeyedMsg("S2IV0003",[fn,ft,fm])
;  sayKeyedMsg("S2IV0005",NIL)
;  describeSetOutputAlgebra()

(DEFUN |setOutputAlgebra| (|arg|) (PROG (|label| |ISTMP#1| |ISTMP#2| |ptype| |fn| |ft| |fm| |filename| |testStream|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$algebraOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$algebraOutputFile| (MAKESTRING "CONSOLE")) (SPADLET |$algebraFormat| (QUOTE T))) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND (|$algebraFormat| (SPADLET |label| (MAKESTRING "On:"))) ((QUOTE T) (SPADLET |label| (MAKESTRING "Off:")))) (STRCONC |label| |$algebraOutputFile|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetOutputAlgebra|)) ((QUOTE T) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| |fn| (QUOTE (Y N YE YES NO O ON OF OFF CONSOLE |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))) (QUOTE |ok|)) ((QUOTE T) (SPADLET |arg| (CONS |fn| (CONS (QUOTE |spout|) NIL))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T))) (COND ((|member| (UPCASE |fn|) (QUOTE (Y N YE O OF))) (|sayKeyedMsg| (QUOTE S2IV0002) (QUOTE (|algebra| |algebra|)))) ((|member| (UPCASE |fn|) (QUOTE (NO OFF))) (SPADLET |$algebraFormat| NIL)) ((|member| (UPCASE |fn|) (QUOTE (YES ON))) (SPADLET |$algebraFormat| (QUOTE T))) ((BOOT-EQUAL (UPCASE |fn|) (QUOTE CONSOLE)) (PROGN (SHUT |$algebraOutputStream|) (SPADLET |$algebraOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$algebraOutputFile| (MAKESTRING "CONSOLE")))))) ((OR (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (QUOTE T))))) (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fm| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (COND ((SPADLET |ptype| (|pathnameType| |fn|)) (SPADLET |fn| (STRCONC (|pathnameDirectory| |fn|) (|pathnameName| |fn|))) (SPADLET |ft| |ptype|))) (COND ((NULL |fm|) (SPADLET |fm| (QUOTE A)))) (SPADLET |filename| ($FILEP |fn| |ft| |fm|)) (COND ((NULL |filename|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((SPADLET |testStream| (MAKE-OUTSTREAM |filename| 255 0)) (SHUT |$algebraOutputStream|) (SPADLET |$algebraOutputStream| |testStream|) (SPADLET |$algebraOutputFile| (|object2String| |filename|)) (|sayKeyedMsg| (QUOTE S2IV0004) (CONS (MAKESTRING "Algebra") (CONS |$algebraOutputFile| NIL)))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0005) NIL) (|describeSetOutputAlgebra|)))))))) 
;describeSetOutputAlgebra() ==
;  sayBrightly LIST ('%b,'")set output algebra",'%d,_
;   '"is used to tell AXIOM to turn algebra-style output",'%l,_
;   '"printing on and off, and where to place the output.  By default, the",'%l,_
;   '"destination for the output is the screen but printing is turned off.",'%l,_
;   '%l,_
;   '"Syntax:   )set output algebra <arg>",'%l,_
;  '"    where arg can be one of",'%l,_
;  '"  on          turn algebra printing on (default state)",'%l,_
;  '"  off         turn algebra printing off",'%l,_
;  '"  console     send algebra output to screen (default state)",'%l,_
;  '"  fp<.fe>     send algebra output to file with file prefix fp",'%l,_
;  '"              and file extension .fe. If not given, .fe defaults to .spout.",'%l,
;  '%l,_
;  '"If you wish to send the output to a file, you may need to issue this command",'%l,_
;  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
;  '"algebra output to the file",'%b,'"polymer.spout,",'%d,'"issue the two commands",'%l,_
;  '%l,_
;  '"  )set output algebra on",'%l,_
;  '"  )set output algebra polymer",'%l,_
;  '%l,_
;  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
;  '"the one you set with the )cd system command.",'%l,_
;  '"The current setting is: ",'%b,setOutputAlgebra "%display%",'%d)

(DEFUN |describeSetOutputAlgebra| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set output algebra") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to turn algebra-style output") (QUOTE |%l|) (MAKESTRING "printing on and off, and where to place the output.  By default, the") (QUOTE |%l|) (MAKESTRING "destination for the output is the screen but printing is turned off.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Syntax:   )set output algebra <arg>") (QUOTE |%l|) (MAKESTRING "    where arg can be one of") (QUOTE |%l|) (MAKESTRING "  on          turn algebra printing on (default state)") (QUOTE |%l|) (MAKESTRING "  off         turn algebra printing off") (QUOTE |%l|) (MAKESTRING "  console     send algebra output to screen (default state)") (QUOTE |%l|) (MAKESTRING "  fp<.fe>     send algebra output to file with file prefix fp") (QUOTE |%l|) (MAKESTRING "              and file extension .fe. If not given, .fe defaults to .spout.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "If you wish to send the output to a file, you may need to issue this command") (QUOTE |%l|) (MAKESTRING "twice: once with") (QUOTE |%b|) (MAKESTRING "on") (QUOTE |%d|) (MAKESTRING "and once with the file name. For example, to send") (QUOTE |%l|) (MAKESTRING "algebra output to the file") (QUOTE |%b|) (MAKESTRING "polymer.spout,") (QUOTE |%d|) (MAKESTRING "issue the two commands") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "  )set output algebra on") (QUOTE |%l|) (MAKESTRING "  )set output algebra polymer") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "The output is placed in the directory from which you invoked AXIOM or") (QUOTE |%l|) (MAKESTRING "the one you set with the )cd system command.") (QUOTE |%l|) (MAKESTRING "The current setting is: ") (QUOTE |%b|) (|setOutputAlgebra| (QUOTE |%display%|)) (QUOTE |%d|)))) 
;setOutputCharacters arg ==
;  -- this sets the special character set
;  arg = "%initialize%" =>
;    $specialCharacters := $plainRTspecialCharacters
;  current :=
;    $specialCharacters = $RTspecialCharacters      => '"default"
;    $specialCharacters = $plainRTspecialCharacters => '"plain"
;    '"unknown"
;  arg = "%display%" => current
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    sayMessage ['" The",:bright '"characters",'"option",
;      '" may be followed by any one of the following:"]
;    for name in '("default" "plain") repeat
;      if name = current
;        then sayBrightly ['" ->",:bright name]
;        else sayBrightly ['"    ",name]
;    TERPRI()
;    sayBrightly '" The current setting is indicated within the list.  This option determines "
;    sayBrightly '" the special characters used for algebraic output.  This is what the"
;    sayBrightly '" current choice of special characters looks like:"
;    l := NIL
;    for [char,:.] in $specialCharacterAlist repeat
;      s := STRCONC('"   ",PNAME char,'" is shown as ",
;        PNAME specialChar(char))
;      l := cons(s,l)
;    sayAsManyPerLineAsPossible reverse l
;  arg is [fn] and (fn := DOWNCASE(fn)) =>
;    fn = 'default => $specialCharacters := $RTspecialCharacters
;    fn = 'plain   => $specialCharacters := $plainRTspecialCharacters
;    setOutputCharacters NIL
;  setOutputCharacters NIL

(DEFUN |setOutputCharacters| (|arg|) (PROG (|current| |char| |s| |l| |fn|) (RETURN (SEQ (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$specialCharacters| |$plainRTspecialCharacters|)) ((QUOTE T) (SPADLET |current| (COND ((BOOT-EQUAL |$specialCharacters| |$RTspecialCharacters|) (MAKESTRING "default")) ((BOOT-EQUAL |$specialCharacters| |$plainRTspecialCharacters|) (MAKESTRING "plain")) ((QUOTE T) (MAKESTRING "unknown")))) (COND ((BOOT-EQUAL |arg| (QUOTE |%display%|)) |current|) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|sayMessage| (CONS (MAKESTRING " The") (APPEND (|bright| (MAKESTRING "characters")) (CONS (MAKESTRING "option") (CONS (MAKESTRING " may be followed by any one of the following:") NIL))))) (DO ((#0=#:G3317 (QUOTE ("default" "plain")) (CDR #0#)) (|name| NIL)) ((OR (ATOM #0#) (PROGN (SETQ |name| (CAR #0#)) NIL)) NIL) (SEQ (EXIT (COND ((BOOT-EQUAL |name| |current|) (|sayBrightly| (CONS (MAKESTRING " ->") (|bright| |name|)))) ((QUOTE T) (|sayBrightly| (CONS (MAKESTRING "    ") (CONS |name| NIL)))))))) (TERPRI) (|sayBrightly| (MAKESTRING " The current setting is indicated within the list.  This option determines ")) (|sayBrightly| (MAKESTRING " the special characters used for algebraic output.  This is what the")) (|sayBrightly| (MAKESTRING " current choice of special characters looks like:")) (SPADLET |l| NIL) (DO ((#1=#:G3329 |$specialCharacterAlist| (CDR #1#)) (#2=#:G3308 NIL)) ((OR (ATOM #1#) (PROGN (SETQ #2# (CAR #1#)) NIL) (PROGN (PROGN (SPADLET |char| (CAR #2#)) #2#) NIL)) NIL) (SEQ (EXIT (PROGN (SPADLET |s| (STRCONC (MAKESTRING "   ") (PNAME |char|) (MAKESTRING " is shown as ") (PNAME (|specialChar| |char|)))) (SPADLET |l| (CONS |s| |l|)))))) (|sayAsManyPerLineAsPossible| (REVERSE |l|))) ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (SPADLET |fn| (DOWNCASE |fn|))) (COND ((BOOT-EQUAL |fn| (QUOTE |default|)) (SPADLET |$specialCharacters| |$RTspecialCharacters|)) ((BOOT-EQUAL |fn| (QUOTE |plain|)) (SPADLET |$specialCharacters| |$plainRTspecialCharacters|)) ((QUOTE T) (|setOutputCharacters| NIL)))) ((QUOTE T) (|setOutputCharacters| NIL))))))))) 
;makeStream(append,filename,i,j) ==
;  append => MAKE_-APPENDSTREAM(filename,i,j)
;  MAKE_-OUTSTREAM(filename,i,j)

(DEFUN |makeStream| (APPEND |filename| |i| |j|) (COND (APPEND (MAKE-APPENDSTREAM |filename| |i| |j|)) ((QUOTE T) (MAKE-OUTSTREAM |filename| |i| |j|)))) 
;setOutputFortran arg ==
;  arg = "%initialize%" =>
;    $fortranOutputStream :=
;      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;    $fortranOutputFile := '"CONSOLE"
;    $fortranFormat := NIL
;  arg = "%display%" =>
;    if $fortranFormat then label := '"On:" else label := '"Off:"
;    STRCONC(label,$fortranOutputFile)
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetOutputFortran()
;  -- try to figure out what the argument is
;  append := NIL
;  quiet := NIL
;  while LISTP arg and UPCASE(first arg) in '(APPEND QUIET) repeat
;    if UPCASE first(arg) = 'APPEND then append := true
;    else if UPCASE first(arg) = 'QUIET then quiet := true
;    arg := rest(arg)
;  if arg is [fn] and
;    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
;      then 'ok
;      else arg := [fn,'sfort]
;  arg is [fn] =>
;    UPCASE(fn) in '(Y N YE O OF) =>
;      sayKeyedMsg("S2IV0002",'(FORTRAN fortran))
;    UPCASE(fn) in '(NO OFF)  => $fortranFormat := NIL
;    UPCASE(fn) in '(YES ON)  => $fortranFormat := true
;    UPCASE(fn) = 'CONSOLE =>
;      SHUT $fortranOutputStream
;      $fortranOutputStream :=
;        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;      $fortranOutputFile := '"CONSOLE"
;  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
;    if (ptype := pathnameType fn) then
;      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
;      ft := ptype
;    if null fm then fm := 'A
;    filename := $FILEP(fn,ft,fm)
;    null filename => sayKeyedMsg("S2IV0003",[fn,ft,fm])
;    (testStream := makeStream(append,filename,255,0)) =>
;      SHUT $fortranOutputStream
;      $fortranOutputStream := testStream
;      $fortranOutputFile := object2String filename
;      if null quiet then sayKeyedMsg("S2IV0004",['FORTRAN,$fortranOutputFile])
;    if null quiet then sayKeyedMsg("S2IV0003",[fn,ft,fm])
;  if null quiet then sayKeyedMsg("S2IV0005",NIL)
;  describeSetOutputFortran()

(DEFUN |setOutputFortran| (|arg|) (PROG (|label| APPEND |quiet| |ISTMP#1| |ISTMP#2| |ptype| |fn| |ft| |fm| |filename| |testStream|) (RETURN (SEQ (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$fortranOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$fortranOutputFile| (MAKESTRING "CONSOLE")) (SPADLET |$fortranFormat| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND (|$fortranFormat| (SPADLET |label| (MAKESTRING "On:"))) ((QUOTE T) (SPADLET |label| (MAKESTRING "Off:")))) (STRCONC |label| |$fortranOutputFile|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetOutputFortran|)) ((QUOTE T) (SPADLET APPEND NIL) (SPADLET |quiet| NIL) (DO NIL ((NULL (AND (LISTP |arg|) (|member| (UPCASE (CAR |arg|)) (QUOTE (APPEND QUIET))))) NIL) (SEQ (EXIT (PROGN (COND ((BOOT-EQUAL (UPCASE (CAR |arg|)) (QUOTE APPEND)) (SPADLET APPEND (QUOTE T))) ((BOOT-EQUAL (UPCASE (CAR |arg|)) (QUOTE QUIET)) (SPADLET |quiet| (QUOTE T))) ((QUOTE T) NIL)) (SPADLET |arg| (CDR |arg|)))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| |fn| (QUOTE (Y N YE YES NO O ON OF OFF CONSOLE |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))) (QUOTE |ok|)) ((QUOTE T) (SPADLET |arg| (CONS |fn| (CONS (QUOTE |sfort|) NIL))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T))) (COND ((|member| (UPCASE |fn|) (QUOTE (Y N YE O OF))) (|sayKeyedMsg| (QUOTE S2IV0002) (QUOTE (FORTRAN |fortran|)))) ((|member| (UPCASE |fn|) (QUOTE (NO OFF))) (SPADLET |$fortranFormat| NIL)) ((|member| (UPCASE |fn|) (QUOTE (YES ON))) (SPADLET |$fortranFormat| (QUOTE T))) ((BOOT-EQUAL (UPCASE |fn|) (QUOTE CONSOLE)) (PROGN (SHUT |$fortranOutputStream|) (SPADLET |$fortranOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$fortranOutputFile| (MAKESTRING "CONSOLE")))))) ((OR (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (QUOTE T))))) (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fm| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (COND ((SPADLET |ptype| (|pathnameType| |fn|)) (SPADLET |fn| (STRCONC (|pathnameDirectory| |fn|) (|pathnameName| |fn|))) (SPADLET |ft| |ptype|))) (COND ((NULL |fm|) (SPADLET |fm| (QUOTE A)))) (SPADLET |filename| ($FILEP |fn| |ft| |fm|)) (COND ((NULL |filename|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((SPADLET |testStream| (|makeStream| APPEND |filename| 255 0)) (SHUT |$fortranOutputStream|) (SPADLET |$fortranOutputStream| |testStream|) (SPADLET |$fortranOutputFile| (|object2String| |filename|)) (COND ((NULL |quiet|) (|sayKeyedMsg| (QUOTE S2IV0004) (CONS (QUOTE FORTRAN) (CONS |$fortranOutputFile| NIL)))) ((QUOTE T) NIL))) ((NULL |quiet|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((QUOTE T) NIL))) ((QUOTE T) (COND ((NULL |quiet|) (|sayKeyedMsg| (QUOTE S2IV0005) NIL))) (|describeSetOutputFortran|))))))))) 
;describeSetOutputFortran() ==
;  sayBrightly LIST ('%b,'")set output fortran",'%d,_
;   '"is used to tell AXIOM to turn FORTRAN-style output",'%l,_
;   '"printing on and off, and where to place the output.  By default, the",'%l,_
;   '"destination for the output is the screen but printing is turned off.",'%l,_
;   '%l,_
;   '"Also See: )set fortran",'%l,
;   '%l,_
;   '"Syntax:   )set output fortran <arg>",'%l,_
;  '"    where arg can be one of",'%l,_
;  '"  on          turn FORTRAN printing on",'%l,_
;  '"  off         turn FORTRAN printing off (default state)",'%l,_
;  '"  console     send FORTRAN output to screen (default state)",'%l,_
;  '"  fp<.fe>     send FORTRAN output to file with file prefix fp and file",'%l,_
;  '"              extension .fe. If not given, .fe defaults to .sfort.",'%l,
;  '%l,_
;  '"If you wish to send the output to a file, you must issue this command",'%l,_
;  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
;  '"FORTRAN output to the file",'%b,'"polymer.sfort,",'%d,'"issue the two commands",'%l,_
;  '%l,_
;  '"  )set output fortran on",'%l,_
;  '"  )set output fortran polymer",'%l,_
;  '%l,_
;  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
;  '"the one you set with the )cd system command.",'%l,_
;  '"The current setting is: ",'%b,setOutputFortran "%display%",'%d)

(DEFUN |describeSetOutputFortran| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set output fortran") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to turn FORTRAN-style output") (QUOTE |%l|) (MAKESTRING "printing on and off, and where to place the output.  By default, the") (QUOTE |%l|) (MAKESTRING "destination for the output is the screen but printing is turned off.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Also See: )set fortran") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Syntax:   )set output fortran <arg>") (QUOTE |%l|) (MAKESTRING "    where arg can be one of") (QUOTE |%l|) (MAKESTRING "  on          turn FORTRAN printing on") (QUOTE |%l|) (MAKESTRING "  off         turn FORTRAN printing off (default state)") (QUOTE |%l|) (MAKESTRING "  console     send FORTRAN output to screen (default state)") (QUOTE |%l|) (MAKESTRING "  fp<.fe>     send FORTRAN output to file with file prefix fp and file") (QUOTE |%l|) (MAKESTRING "              extension .fe. If not given, .fe defaults to .sfort.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "If you wish to send the output to a file, you must issue this command") (QUOTE |%l|) (MAKESTRING "twice: once with") (QUOTE |%b|) (MAKESTRING "on") (QUOTE |%d|) (MAKESTRING "and once with the file name. For example, to send") (QUOTE |%l|) (MAKESTRING "FORTRAN output to the file") (QUOTE |%b|) (MAKESTRING "polymer.sfort,") (QUOTE |%d|) (MAKESTRING "issue the two commands") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "  )set output fortran on") (QUOTE |%l|) (MAKESTRING "  )set output fortran polymer") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "The output is placed in the directory from which you invoked AXIOM or") (QUOTE |%l|) (MAKESTRING "the one you set with the )cd system command.") (QUOTE |%l|) (MAKESTRING "The current setting is: ") (QUOTE |%b|) (|setOutputFortran| (QUOTE |%display%|)) (QUOTE |%d|)))) 
;setOutputOpenMath arg ==
;  arg = "%initialize%" =>
;    $openMathOutputStream :=
;      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;    $openMathOutputFile := '"CONSOLE"
;    $openMathFormat := NIL
;  arg = "%display%" =>
;    if $openMathFormat then label := '"On:" else label := '"Off:"
;    STRCONC(label,$openMathOutputFile)
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetOutputOpenMath()
;  -- try to figure out what the argument is
;  if arg is [fn] and
;    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
;      then 'ok
;      else arg := [fn,'som]
;  arg is [fn] =>
;    UPCASE(fn) in '(Y N YE O OF) =>
;      sayKeyedMsg("S2IV0002",'(OpenMath openmath))
;    UPCASE(fn) in '(NO OFF)  => $openMathFormat := NIL
;    UPCASE(fn) in '(YES ON) => $openMathFormat := true
;    UPCASE(fn) = 'CONSOLE =>
;      SHUT $openMathOutputStream
;      $openMathOutputStream :=
;        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;      $openMathOutputFile := '"CONSOLE"
;  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
;    if (ptype := pathnameType fn) then
;      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
;      ft := ptype
;    if null fm then fm := 'A
;    filename := $FILEP(fn,ft,fm)
;    null filename =>
;      sayKeyedMsg("S2IV0003",[fn,ft,fm])
;    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
;      SHUT $openMathOutputStream
;      $openMathOutputStream := testStream
;      $openMathOutputFile := object2String filename
;      sayKeyedMsg("S2IV0004",['"OpenMath",$openMathOutputFile])
;    sayKeyedMsg("S2IV0003",[fn,ft,fm])
;  sayKeyedMsg("S2IV0005",NIL)
;  describeSetOutputOpenMath()

(DEFUN |setOutputOpenMath| (|arg|) (PROG (|label| |ISTMP#1| |ISTMP#2| |ptype| |fn| |ft| |fm| |filename| |testStream|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$openMathOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$openMathOutputFile| (MAKESTRING "CONSOLE")) (SPADLET |$openMathFormat| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND (|$openMathFormat| (SPADLET |label| (MAKESTRING "On:"))) ((QUOTE T) (SPADLET |label| (MAKESTRING "Off:")))) (STRCONC |label| |$openMathOutputFile|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetOutputOpenMath|)) ((QUOTE T) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| |fn| (QUOTE (Y N YE YES NO O ON OF OFF CONSOLE |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))) (QUOTE |ok|)) ((QUOTE T) (SPADLET |arg| (CONS |fn| (CONS (QUOTE |som|) NIL))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T))) (COND ((|member| (UPCASE |fn|) (QUOTE (Y N YE O OF))) (|sayKeyedMsg| (QUOTE S2IV0002) (QUOTE (|OpenMath| |openmath|)))) ((|member| (UPCASE |fn|) (QUOTE (NO OFF))) (SPADLET |$openMathFormat| NIL)) ((|member| (UPCASE |fn|) (QUOTE (YES ON))) (SPADLET |$openMathFormat| (QUOTE T))) ((BOOT-EQUAL (UPCASE |fn|) (QUOTE CONSOLE)) (PROGN (SHUT |$openMathOutputStream|) (SPADLET |$openMathOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$openMathOutputFile| (MAKESTRING "CONSOLE")))))) ((OR (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (QUOTE T))))) (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fm| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (COND ((SPADLET |ptype| (|pathnameType| |fn|)) (SPADLET |fn| (STRCONC (|pathnameDirectory| |fn|) (|pathnameName| |fn|))) (SPADLET |ft| |ptype|))) (COND ((NULL |fm|) (SPADLET |fm| (QUOTE A)))) (SPADLET |filename| ($FILEP |fn| |ft| |fm|)) (COND ((NULL |filename|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((SPADLET |testStream| (MAKE-OUTSTREAM |filename| 255 0)) (SHUT |$openMathOutputStream|) (SPADLET |$openMathOutputStream| |testStream|) (SPADLET |$openMathOutputFile| (|object2String| |filename|)) (|sayKeyedMsg| (QUOTE S2IV0004) (CONS (MAKESTRING "OpenMath") (CONS |$openMathOutputFile| NIL)))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0005) NIL) (|describeSetOutputOpenMath|)))))))) 
;describeSetOutputOpenMath() ==
;  sayBrightly LIST ('%b,'")set output openmath",'%d,_
;   '"is used to tell AXIOM to turn OpenMath output",'%l,_
;   '"printing on and off, and where to place the output.  By default, the",'%l,_
;   '"destination for the output is the screen but printing is turned off.",'%l,_
;   '%l,_
;   '"Syntax:   )set output openmath <arg>",'%l,_
;  '"    where arg can be one of",'%l,_
;  '"  on          turn OpenMath printing on",'%l,_
;  '"  off         turn OpenMath printing off (default state)",'%l,_
;  '"  console     send OpenMath output to screen (default state)",'%l,_
;  '"  fp<.fe>     send OpenMath output to file with file prefix fp and file",'%l,_
;  '"              extension .fe. If not given, .fe defaults to .som.",'%l,
;  '%l,_
;  '"If you wish to send the output to a file, you must issue this command",'%l,_
;  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
;  '"OpenMath output to the file",'%b,'"polymer.som,",'%d,'"issue the two commands",'%l,_
;  '%l,_
;  '"  )set output openmath on",'%l,_
;  '"  )set output openmath polymer",'%l,_
;  '%l,_
;  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
;  '"the one you set with the )cd system command.",'%l,_
;  '"The current setting is: ",'%b,setOutputOpenMath "%display%",'%d)

(DEFUN |describeSetOutputOpenMath| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set output openmath") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to turn OpenMath output") (QUOTE |%l|) (MAKESTRING "printing on and off, and where to place the output.  By default, the") (QUOTE |%l|) (MAKESTRING "destination for the output is the screen but printing is turned off.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Syntax:   )set output openmath <arg>") (QUOTE |%l|) (MAKESTRING "    where arg can be one of") (QUOTE |%l|) (MAKESTRING "  on          turn OpenMath printing on") (QUOTE |%l|) (MAKESTRING "  off         turn OpenMath printing off (default state)") (QUOTE |%l|) (MAKESTRING "  console     send OpenMath output to screen (default state)") (QUOTE |%l|) (MAKESTRING "  fp<.fe>     send OpenMath output to file with file prefix fp and file") (QUOTE |%l|) (MAKESTRING "              extension .fe. If not given, .fe defaults to .som.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "If you wish to send the output to a file, you must issue this command") (QUOTE |%l|) (MAKESTRING "twice: once with") (QUOTE |%b|) (MAKESTRING "on") (QUOTE |%d|) (MAKESTRING "and once with the file name. For example, to send") (QUOTE |%l|) (MAKESTRING "OpenMath output to the file") (QUOTE |%b|) (MAKESTRING "polymer.som,") (QUOTE |%d|) (MAKESTRING "issue the two commands") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "  )set output openmath on") (QUOTE |%l|) (MAKESTRING "  )set output openmath polymer") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "The output is placed in the directory from which you invoked AXIOM or") (QUOTE |%l|) (MAKESTRING "the one you set with the )cd system command.") (QUOTE |%l|) (MAKESTRING "The current setting is: ") (QUOTE |%b|) (|setOutputOpenMath| (QUOTE |%display%|)) (QUOTE |%d|)))) 
;setOutputFormula arg ==
;  arg = "%initialize%" =>
;    $formulaOutputStream :=
;      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;    $formulaOutputFile := '"CONSOLE"
;    $formulaFormat := NIL
;  arg = "%display%" =>
;    if $formulaFormat then label := '"On:" else label := '"Off:"
;    STRCONC(label,$formulaOutputFile)
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetOutputFormula()
;  -- try to figure out what the argument is
;  if arg is [fn] and
;    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
;      then 'ok
;      else arg := [fn,'sform]
;  arg is [fn] =>
;    UPCASE(fn) in '(Y N YE O OF) =>
;      sayKeyedMsg("S2IV0002",'(script script))
;    UPCASE(fn) in '(NO OFF)  => $formulaFormat := NIL
;    UPCASE(fn) in '(YES ON) => $formulaFormat := true
;    UPCASE(fn) = 'CONSOLE =>
;      SHUT $formulaOutputStream
;      $formulaOutputStream :=
;        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;      $formulaOutputFile := '"CONSOLE"
;  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
;    if (ptype := pathnameType fn) then
;      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
;      ft := ptype
;    if null fm then fm := 'A
;    filename := $FILEP(fn,ft,fm)
;    null filename =>
;      sayKeyedMsg("S2IV0003",[fn,ft,fm])
;    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
;      SHUT $formulaOutputStream
;      $formulaOutputStream := testStream
;      $formulaOutputFile := object2String filename
;      sayKeyedMsg("S2IV0004",['"IBM Script formula",$formulaOutputFile])
;    sayKeyedMsg("S2IV0003",[fn,ft,fm])
;  sayKeyedMsg("S2IV0005",NIL)
;  describeSetOutputFormula()

(DEFUN |setOutputFormula| (|arg|) (PROG (|label| |ISTMP#1| |ISTMP#2| |ptype| |fn| |ft| |fm| |filename| |testStream|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$formulaOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$formulaOutputFile| (MAKESTRING "CONSOLE")) (SPADLET |$formulaFormat| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND (|$formulaFormat| (SPADLET |label| (MAKESTRING "On:"))) ((QUOTE T) (SPADLET |label| (MAKESTRING "Off:")))) (STRCONC |label| |$formulaOutputFile|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetOutputFormula|)) ((QUOTE T) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| |fn| (QUOTE (Y N YE YES NO O ON OF OFF CONSOLE |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))) (QUOTE |ok|)) ((QUOTE T) (SPADLET |arg| (CONS |fn| (CONS (QUOTE |sform|) NIL))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T))) (COND ((|member| (UPCASE |fn|) (QUOTE (Y N YE O OF))) (|sayKeyedMsg| (QUOTE S2IV0002) (QUOTE (|script| |script|)))) ((|member| (UPCASE |fn|) (QUOTE (NO OFF))) (SPADLET |$formulaFormat| NIL)) ((|member| (UPCASE |fn|) (QUOTE (YES ON))) (SPADLET |$formulaFormat| (QUOTE T))) ((BOOT-EQUAL (UPCASE |fn|) (QUOTE CONSOLE)) (PROGN (SHUT |$formulaOutputStream|) (SPADLET |$formulaOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$formulaOutputFile| (MAKESTRING "CONSOLE")))))) ((OR (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (QUOTE T))))) (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fm| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (COND ((SPADLET |ptype| (|pathnameType| |fn|)) (SPADLET |fn| (STRCONC (|pathnameDirectory| |fn|) (|pathnameName| |fn|))) (SPADLET |ft| |ptype|))) (COND ((NULL |fm|) (SPADLET |fm| (QUOTE A)))) (SPADLET |filename| ($FILEP |fn| |ft| |fm|)) (COND ((NULL |filename|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((SPADLET |testStream| (MAKE-OUTSTREAM |filename| 255 0)) (SHUT |$formulaOutputStream|) (SPADLET |$formulaOutputStream| |testStream|) (SPADLET |$formulaOutputFile| (|object2String| |filename|)) (|sayKeyedMsg| (QUOTE S2IV0004) (CONS (MAKESTRING "IBM Script formula") (CONS |$formulaOutputFile| NIL)))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0005) NIL) (|describeSetOutputFormula|)))))))) 
;describeSetOutputFormula() ==
;  sayBrightly LIST ('%b,'")set output script",'%d,_
;   '"is used to tell AXIOM to turn IBM Script formula-style",'%l,_
;   '"output printing on and off, and where to place the output.  By default, the",'%l,_
;   '"destination for the output is the screen but printing is turned off.",'%l,_
;   '%l,_
;   '"Syntax:   )set output script <arg>",'%l,_
;  '"    where arg can be one of",'%l,_
;  '"  on          turn IBM Script formula printing on",'%l,_
;  '"  off         turn IBM Script formula printing off (default state)",'%l,_
;  '"  console     send IBM Script formula output to screen (default state)",'%l,_
;  '"  fp<.fe>     send IBM Script formula output to file with file prefix fp",'%l,_
;  '"              and file extension .fe. If not given, .fe defaults to .sform.",'%l,
;  '%l,_
;  '"If you wish to send the output to a file, you must issue this command",'%l,_
;  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
;  '"IBM Script formula output to the file",'%b,'"polymer.sform,",'%d,'"issue the two commands",'%l,_
;  '%l,_
;  '"  )set output script on",'%l,_
;  '"  )set output script polymer",'%l,_
;  '%l,_
;  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
;  '"the one you set with the )cd system command.",'%l,_
;  '"The current setting is: ",'%b,setOutputFormula "%display%",'%d)

(DEFUN |describeSetOutputFormula| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set output script") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to turn IBM Script formula-style") (QUOTE |%l|) (MAKESTRING "output printing on and off, and where to place the output.  By default, the") (QUOTE |%l|) (MAKESTRING "destination for the output is the screen but printing is turned off.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Syntax:   )set output script <arg>") (QUOTE |%l|) (MAKESTRING "    where arg can be one of") (QUOTE |%l|) (MAKESTRING "  on          turn IBM Script formula printing on") (QUOTE |%l|) (MAKESTRING "  off         turn IBM Script formula printing off (default state)") (QUOTE |%l|) (MAKESTRING "  console     send IBM Script formula output to screen (default state)") (QUOTE |%l|) (MAKESTRING "  fp<.fe>     send IBM Script formula output to file with file prefix fp") (QUOTE |%l|) (MAKESTRING "              and file extension .fe. If not given, .fe defaults to .sform.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "If you wish to send the output to a file, you must issue this command") (QUOTE |%l|) (MAKESTRING "twice: once with") (QUOTE |%b|) (MAKESTRING "on") (QUOTE |%d|) (MAKESTRING "and once with the file name. For example, to send") (QUOTE |%l|) (MAKESTRING "IBM Script formula output to the file") (QUOTE |%b|) (MAKESTRING "polymer.sform,") (QUOTE |%d|) (MAKESTRING "issue the two commands") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "  )set output script on") (QUOTE |%l|) (MAKESTRING "  )set output script polymer") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "The output is placed in the directory from which you invoked AXIOM or") (QUOTE |%l|) (MAKESTRING "the one you set with the )cd system command.") (QUOTE |%l|) (MAKESTRING "The current setting is: ") (QUOTE |%b|) (|setOutputFormula| (QUOTE |%display%|)) (QUOTE |%d|)))) 
;setOutputTex arg ==
;  arg = "%initialize%" =>
;    $texOutputStream :=
;      DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;    $texOutputFile := '"CONSOLE"
;    $texFormat := NIL
;  arg = "%display%" =>
;    if $texFormat then label := '"On:" else label := '"Off:"
;    STRCONC(label,$texOutputFile)
;  (null arg) or (arg = "%describe%") or (first arg = '_?) =>
;    describeSetOutputTex()
;  -- try to figure out what the argument is
;  if arg is [fn] and
;    fn in '(Y N YE YES NO O ON OF OFF CONSOLE y n ye yes no o on of off console)
;      then 'ok
;      else arg := [fn,'stex]
;  arg is [fn] =>
;    UPCASE(fn) in '(Y N YE O OF) =>
;      sayKeyedMsg("S2IV0002",'(TeX tex))
;    UPCASE(fn) in '(NO OFF)  => $texFormat := NIL
;    UPCASE(fn) in '(YES ON) => $texFormat := true
;    UPCASE(fn) = 'CONSOLE =>
;      SHUT $texOutputStream
;      $texOutputStream :=
;        DEFIOSTREAM('((MODE . OUTPUT) (DEVICE . CONSOLE)),255,0)
;      $texOutputFile := '"CONSOLE"
;  (arg is [fn,ft]) or (arg is [fn,ft,fm]) => -- aha, a file
;    if (ptype := pathnameType fn) then
;      fn := STRCONC(pathnameDirectory fn,pathnameName fn)
;      ft := ptype
;    if null fm then fm := 'A
;    filename := $FILEP(fn,ft,fm)
;    null filename =>
;      sayKeyedMsg("S2IV0003",[fn,ft,fm])
;    (testStream := MAKE_-OUTSTREAM(filename,255,0)) =>
;      SHUT $texOutputStream
;      $texOutputStream := testStream
;      $texOutputFile := object2String filename
;      sayKeyedMsg("S2IV0004",['"TeX",$texOutputFile])
;    sayKeyedMsg("S2IV0003",[fn,ft,fm])
;  sayKeyedMsg("S2IV0005",NIL)
;  describeSetOutputTex()

(DEFUN |setOutputTex| (|arg|) (PROG (|label| |ISTMP#1| |ISTMP#2| |ptype| |fn| |ft| |fm| |filename| |testStream|) (RETURN (COND ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$texOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$texOutputFile| (MAKESTRING "CONSOLE")) (SPADLET |$texFormat| NIL)) ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (COND (|$texFormat| (SPADLET |label| (MAKESTRING "On:"))) ((QUOTE T) (SPADLET |label| (MAKESTRING "Off:")))) (STRCONC |label| |$texOutputFile|)) ((OR (NULL |arg|) (BOOT-EQUAL |arg| (QUOTE |%describe%|)) (BOOT-EQUAL (CAR |arg|) (QUOTE ?))) (|describeSetOutputTex|)) ((QUOTE T) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T)) (|member| |fn| (QUOTE (Y N YE YES NO O ON OF OFF CONSOLE |y| |n| |ye| |yes| |no| |o| |on| |of| |off| |console|)))) (QUOTE |ok|)) ((QUOTE T) (SPADLET |arg| (CONS |fn| (CONS (QUOTE |stex|) NIL))))) (COND ((AND (PAIRP |arg|) (EQ (QCDR |arg|) NIL) (PROGN (SPADLET |fn| (QCAR |arg|)) (QUOTE T))) (COND ((|member| (UPCASE |fn|) (QUOTE (Y N YE O OF))) (|sayKeyedMsg| (QUOTE S2IV0002) (QUOTE (|TeX| |tex|)))) ((|member| (UPCASE |fn|) (QUOTE (NO OFF))) (SPADLET |$texFormat| NIL)) ((|member| (UPCASE |fn|) (QUOTE (YES ON))) (SPADLET |$texFormat| (QUOTE T))) ((BOOT-EQUAL (UPCASE |fn|) (QUOTE CONSOLE)) (PROGN (SHUT |$texOutputStream|) (SPADLET |$texOutputStream| (DEFIOSTREAM (QUOTE ((MODE . OUTPUT) (DEVICE . CONSOLE))) 255 0)) (SPADLET |$texOutputFile| (MAKESTRING "CONSOLE")))))) ((OR (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (EQ (QCDR |ISTMP#1|) NIL) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (QUOTE T))))) (AND (PAIRP |arg|) (PROGN (SPADLET |fn| (QCAR |arg|)) (SPADLET |ISTMP#1| (QCDR |arg|)) (AND (PAIRP |ISTMP#1|) (PROGN (SPADLET |ft| (QCAR |ISTMP#1|)) (SPADLET |ISTMP#2| (QCDR |ISTMP#1|)) (AND (PAIRP |ISTMP#2|) (EQ (QCDR |ISTMP#2|) NIL) (PROGN (SPADLET |fm| (QCAR |ISTMP#2|)) (QUOTE T)))))))) (COND ((SPADLET |ptype| (|pathnameType| |fn|)) (SPADLET |fn| (STRCONC (|pathnameDirectory| |fn|) (|pathnameName| |fn|))) (SPADLET |ft| |ptype|))) (COND ((NULL |fm|) (SPADLET |fm| (QUOTE A)))) (SPADLET |filename| ($FILEP |fn| |ft| |fm|)) (COND ((NULL |filename|) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))) ((SPADLET |testStream| (MAKE-OUTSTREAM |filename| 255 0)) (SHUT |$texOutputStream|) (SPADLET |$texOutputStream| |testStream|) (SPADLET |$texOutputFile| (|object2String| |filename|)) (|sayKeyedMsg| (QUOTE S2IV0004) (CONS (MAKESTRING "TeX") (CONS |$texOutputFile| NIL)))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0003) (CONS |fn| (CONS |ft| (CONS |fm| NIL))))))) ((QUOTE T) (|sayKeyedMsg| (QUOTE S2IV0005) NIL) (|describeSetOutputTex|)))))))) 
;describeSetOutputTex() ==
;  sayBrightly LIST ('%b,'")set output tex",'%d,_
;   '"is used to tell AXIOM to turn TeX-style output",'%l,_
;   '"printing on and off, and where to place the output.  By default, the",'%l,_
;   '"destination for the output is the screen but printing is turned off.",'%l,_
;   '%l,_
;   '"Syntax:   )set output tex <arg>",'%l,_
;  '"    where arg can be one of",'%l,_
;  '"  on          turn TeX printing on",'%l,_
;  '"  off         turn TeX printing off (default state)",'%l,_
;  '"  console     send TeX output to screen (default state)",'%l,_
;  '"  fp<.fe>     send TeX output to file with file prefix fp and file",'%l,_
;  '"              extension .fe. If not given, .fe defaults to .stex.",'%l,
;  '%l,_
;  '"If you wish to send the output to a file, you must issue this command",'%l,_
;  '"twice: once with",'%b,'"on",'%d,'"and once with the file name. For example, to send",'%l,_
;  '"TeX output to the file",'%b,'"polymer.stex,",'%d,'"issue the two commands",'%l,_
;  '%l,_
;  '"  )set output tex on",'%l,_
;  '"  )set output tex polymer",'%l,_
;  '%l,_
;  '"The output is placed in the directory from which you invoked AXIOM or",'%l,_
;  '"the one you set with the )cd system command.",'%l,_
;  '"The current setting is: ",'%b,setOutputTex "%display%",'%d)

(DEFUN |describeSetOutputTex| NIL (|sayBrightly| (LIST (QUOTE |%b|) (MAKESTRING ")set output tex") (QUOTE |%d|) (MAKESTRING "is used to tell AXIOM to turn TeX-style output") (QUOTE |%l|) (MAKESTRING "printing on and off, and where to place the output.  By default, the") (QUOTE |%l|) (MAKESTRING "destination for the output is the screen but printing is turned off.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "Syntax:   )set output tex <arg>") (QUOTE |%l|) (MAKESTRING "    where arg can be one of") (QUOTE |%l|) (MAKESTRING "  on          turn TeX printing on") (QUOTE |%l|) (MAKESTRING "  off         turn TeX printing off (default state)") (QUOTE |%l|) (MAKESTRING "  console     send TeX output to screen (default state)") (QUOTE |%l|) (MAKESTRING "  fp<.fe>     send TeX output to file with file prefix fp and file") (QUOTE |%l|) (MAKESTRING "              extension .fe. If not given, .fe defaults to .stex.") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "If you wish to send the output to a file, you must issue this command") (QUOTE |%l|) (MAKESTRING "twice: once with") (QUOTE |%b|) (MAKESTRING "on") (QUOTE |%d|) (MAKESTRING "and once with the file name. For example, to send") (QUOTE |%l|) (MAKESTRING "TeX output to the file") (QUOTE |%b|) (MAKESTRING "polymer.stex,") (QUOTE |%d|) (MAKESTRING "issue the two commands") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "  )set output tex on") (QUOTE |%l|) (MAKESTRING "  )set output tex polymer") (QUOTE |%l|) (QUOTE |%l|) (MAKESTRING "The output is placed in the directory from which you invoked AXIOM or") (QUOTE |%l|) (MAKESTRING "the one you set with the )cd system command.") (QUOTE |%l|) (MAKESTRING "The current setting is: ") (QUOTE |%b|) (|setOutputTex| (QUOTE |%display%|)) (QUOTE |%d|)))) 

(DEFUN |setStreamsCalculate| (|arg|) 
 (PROG (|n|) 
  (RETURN 
   (COND 
    ((BOOT-EQUAL |arg| (QUOTE |%initialize%|)) (SPADLET |$streamCount| 10))
    ((BOOT-EQUAL |arg| (QUOTE |%display%|)) (|object2String| |$streamCount|))
    ((OR 
      (NULL |arg|)
      (BOOT-EQUAL |arg| (QUOTE |%describe%|))
      (BOOT-EQUAL (CAR |arg|) (QUOTE ?)))
       (|describeSetStreamsCalculate|))
    ((QUOTE T)
      (SPADLET |n| (CAR |arg|))
      (COND 
       ((AND 
         (NEQUAL |n| (QUOTE |all|))
         (OR 
          (NULL (FIXP |n|))
          (MINUSP |n|)))
           (|sayMessage| 
            (CONS 
             (MAKESTRING "Your value of")
             (APPEND 
              (|bright| |n|)
              (CONS 
               (MAKESTRING "is invalid because ...")
               NIL))))
           (|describeSetStreamsCalculate|)
           (|terminateSystemCommand|))
       ((QUOTE T) (SPADLET |$streamCount| |n|)))))))) 

(DEFUN |describeSetStreamsCalculate| NIL 
 (|sayKeyedMsg| (QUOTE S2IV0001) (CONS |$streamCount| NIL))) 
@
\eject
\begin{thebibliography}{99}
\bibitem{1} setvart.boot.pamphlet
\end{thebibliography}
\end{document}
