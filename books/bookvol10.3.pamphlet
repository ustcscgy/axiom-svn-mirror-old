\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% Note that this file will eventually generate a dvi file
%% which will eventually be processed by dvipdfm to create a pdf.
%% The categories/domains/packages will be placed in a graphviz graph.
%% The graphviz dot syntax allows an href parameter.
%% The href parameter will reference this file. 
%% pdf href syntax allows named destinations.
%% This macro creates a named destination using \special
%% Thus, you reference http://thispdf#nameddest=ABBREV 
%% and you end up at the right page.
%% This macro is called implicitly by \pagehead so every 
%% category/domain/package can be referenced by fullname or abbrev.
%%
%% dest will give the ability to use nameddest= in html pdfs
%%
\newcommand{\dest}[1]{% e.g. \dest{abb}
\special{pdf:dest (#1) [ @thispage /FitH @ypos ]}}
%%
%%
%% pagehead consolidates standard page indexing
%%
\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
\dest{#1}%
\dest{#2}%
\subsection{{\bf #1} (#2)}
\label{#1}%
\label{#2}%
\index{{#1}}%
\index{{#2}}}%
%%
%% pagepic adds an image and an index entry
%%
\newcommand{\pagepic}[3]{% e.g. \pagepic{pathandfile}{abb}{scale}
\includegraphics[scale=#3]{#1}%
\index{images!#2}}
%%
%% \refto is a link to a referenced page that returns it arg
%%
\newcommand{\refto}[1]{% e.g. \refto{name}
(p\pageref{#1}) #1}
%%
%% pageto is a forward link to a referenced page
%%
\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% pagefrom is a backward link to a referencing page
%%
\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% cross will put the category and function in the index
%% cross will leave the funcname so it can be put inline.
%%
\newcommand{\cross}[2]{% e.g. \pagefrom{cat}{funcname}
\index{#1!#2}%
\index{#2!#1}%
#2}


% special meanings for math characters
\providecommand{\N}{\mbox{\bbold N}}
\providecommand{\Natural}{\mbox{\bbold N}}
\providecommand{\Z}{\mbox{\bbold Z}}
\providecommand{\Integer}{\mbox{\bbold Z}}
\providecommand{\Rational}{\mbox{\bbold Q}}
\providecommand{\Q}{\mbox{\bbold Q}}
\providecommand{\Complex}{\mbox{\bbold C}}
\providecommand{\C}{{\mathcal C}}
\providecommand{\Real}{\mbox{\bbold R}}
\providecommand{\F}{{\mathcal F}}
\providecommand{\R}{{\mathcal R}}
\mathchardef\bigp="3250
\mathchardef\bigq="3251
\mathchardef\bigslash="232C
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 10: Axiom Algebra: Domains}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\pagehead{Domain}{ABB}
%\pagepic{ps/v103domain.ps}{ABB}{1.00}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter A}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ANY Any}
<<dot>>=
"ANY" -> "SETCAT"
"Any()" -> "SetCategory()"
@
\pagehead{Any}{ANY}
\pagepic{ps/v103any.ps}{ANY}{1.00}
<<domain ANY Any>>=
)abbrev domain ANY Any
++ Author: Robert S. Sutor
++ Date Created:
++ Change History:
++ Basic Functions: any, domainOf, objectOf, dom, obj, showTypeInOutput
++ Related Constructors: AnyFunctions1
++ Also See: None
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{Any} implements a type that packages up objects and their
++   types in objects of \spadtype{Any}. Roughly speaking that means
++   that if \spad{s : S} then when converted to \spadtype{Any}, the new
++   object will include both the original object and its type. This is
++   a way of converting arbitrary objects into a single type without
++   losing any of the original information. Any object can be converted
++   to one of \spadtype{Any}.

Any(): SetCategory with
        any             : (SExpression, None) -> %
          ++ any(type,object) is a technical function for creating
          ++ an object of \spadtype{Any}. Arugment \spad{type} is a 
          ++ \spadgloss{LISP} form for the type of \spad{object}.
        domainOf        : % -> OutputForm
          ++ domainOf(a) returns a printable form of the type of the
          ++ original object that was converted to \spadtype{Any}.
        objectOf        : % -> OutputForm
          ++ objectOf(a) returns a printable form of the
          ++ original object that was converted to \spadtype{Any}.
        dom             : % -> SExpression
          ++ dom(a) returns a \spadgloss{LISP} form of the type of the
          ++ original object that was converted to \spadtype{Any}.
        obj             : % -> None
          ++ obj(a) essentially returns the original object that was
          ++ converted to \spadtype{Any} except that the type is forced
          ++ to be \spadtype{None}.
        showTypeInOutput: Boolean -> String
          ++ showTypeInOutput(bool) affects the way objects of
          ++ \spadtype{Any} are displayed. If \spad{bool} is true
          ++ then the type of the original object that was converted
          ++ to \spadtype{Any} will be printed. If \spad{bool} is
          ++ false, it will not be printed.

 == add
     Rep := Record(dm: SExpression, ob: None)

     printTypeInOutputP:Reference(Boolean) := ref false

     obj x      == x.ob
     dom x      == x.dm
     domainOf x == x.dm pretend OutputForm
     x = y      == (x.dm = y.dm) and EQ(x.ob, y.ob)$Lisp

     objectOf(x : %) : OutputForm ==
       spad2BootCoerce(x.ob, x.dm,
          list("OutputForm"::Symbol)$List(Symbol))$Lisp

     showTypeInOutput(b : Boolean) : String ==
      printTypeInOutputP := ref b
      b=> "Type of object will be displayed in output of a member of Any"
      "Type of object will not be displayed in output of a member of Any"

     coerce(x):OutputForm ==
       obj1 : OutputForm := objectOf x
       not deref printTypeInOutputP => obj1
       dom1 :=
         p:Symbol := prefix2String(devaluate(x.dm)$Lisp)$Lisp
         atom?(p pretend SExpression) => list(p)$List(Symbol)
         list(p)$Symbol
       hconcat cons(obj1,
         cons(":"::OutputForm, [a::OutputForm for a in dom1]))

     any(domain, object) ==
       (isValidType(domain)$Lisp)@Boolean => [domain, object]
       domain := devaluate(domain)$Lisp
       (isValidType(domain)$Lisp)@Boolean => [domain, object]
       error "function any must have a domain as first argument"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASTACK ArrayStack}
<<dot>>=
"ASTACK" -> "STACK"
"ArrayStack(a:SetCategory)" -> "Stack(a:SetCategory)"
@
\pagehead{ArrayStack}{ASTACK}
\pagepic{ps/v103arraystack.ps}{ASTACK}{1.00}
<<domain ASTACK ArrayStack>>=
)abbrev domain ASTACK ArrayStack
++ Author: Michael Monagan and Stephen Watt
++ Date Created:June 86 and July 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
 
++ A stack represented as a flexible array.
--% Dequeue and Heap data types
 
ArrayStack(S:SetCategory): StackAggregate(S) with
    arrayStack: List S -> %
      ++ arrayStack([x,y,...,z]) creates an array stack with first (top)
      ++ element x, second element y,...,and last element z.
      ++
      ++E c:ArrayStack INT:= arrayStack [1,2,3,4,5]

  == add
    Rep := IndexedFlexibleArray(S,0)
 
    -- system operations
    # s == _#(s)$Rep
    s = t == s =$Rep t
    copy s == copy(s)$Rep
    coerce(d):OutputForm ==
        empty? d => empty()$(List S) ::OutputForm
        [(d.i::OutputForm) for i in 0..#d-1] ::OutputForm
 
    -- stack operations
    depth s == # s
    empty? s == empty?(s)$Rep 
    extract_! s == pop_! s
    insert_!(e,s) == (push_!(e,s);s)
    push_!(e,s) == (concat(e,s); e)
    pop_! s ==
        if empty? s then error "empty stack"
        m := maxIndex s
        r := s.m
        delete_!(s,m)
        r
    top s == if empty? s then error "empty stack" else s.maxIndex(s)
    arrayStack l == construct(l)$Rep
    empty() == new(0,0 pretend S)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP1 Asp1}
\pagehead{Asp1}{ASP1}
\pagepic{ps/v103asp1.ps}{ASP1}{1.00}
<<domain ASP1 Asp1>>=
)abbrev domain ASP1 Asp1
++ Author: Mike Dewar, Grant Keady, Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranFunctionCategory, FortranProgramCategory.
++ Description: 
++ \spadtype{Asp1} produces Fortran for Type 1 ASPs, needed for various
++ NAG routines. Type 1 ASPs take a univariate expression (in the symbol
++ X) and turn it into a Fortran Function like the following:
++\begin{verbatim}
++      DOUBLE PRECISION FUNCTION F(X)
++      DOUBLE PRECISION X
++      F=DSIN(X)
++      RETURN
++      END
++\end{verbatim}


Asp1(name): Exports == Implementation where
  name : Symbol

  FEXPR  ==> FortranExpression
  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float

  Exports ==> FortranFunctionCategory with
    coerce : FEXPR(['X],[],MachineFloat) -> $
      ++coerce(f) takes an object from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns it into an ASP.

  Implementation ==> add

    -- Build Symbol Table for Rep
    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal()$FT,syms)$SYMTAB
    real : FST := "real"::FST

    Rep := FortranProgram(name,[real]$Union(fst:FST,void:"void"),[X],syms)

    retract(u:FRAC POLY INT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:FRAC POLY INT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    retract(u:FRAC POLY FLOAT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:FRAC POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    retract(u:EXPR FLOAT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:EXPR FLOAT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    retract(u:EXPR INT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:EXPR INT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    retract(u:POLY FLOAT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    retract(u:POLY INT):$ == (retract(u)@FEXPR(['X],[],MachineFloat))::$
    retractIfCan(u:POLY INT):Union($,"failed") ==
      foo : Union(FEXPR(['X],[],MachineFloat),"failed") 
      foo := retractIfCan(u)$FEXPR(['X],[],MachineFloat)
      foo case "failed" => "failed"
      foo::FEXPR(['X],[],MachineFloat)::$

    coerce(u:FEXPR(['X],[],MachineFloat)):$ ==
      coerce((u::Expression(MachineFloat))$FEXPR(['X],[],MachineFloat))$Rep

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void == 
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP10 Asp10}
\pagehead{Asp10}{ASP10}
\pagepic{ps/v103asp10.ps}{ASP10}{1.00}
<<domain ASP10 Asp10>>=
)abbrev domain ASP10 Asp10
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description: 
++\spadtype{ASP10} produces Fortran for Type 10 ASPs, needed for NAG routine 
++\axiomOpFrom{d02kef}{d02Package}. This ASP computes the values of a set of functions, for example: 
++\begin{verbatim}
++      SUBROUTINE COEFFN(P,Q,DQDL,X,ELAM,JINT)
++      DOUBLE PRECISION ELAM,P,Q,X,DQDL
++      INTEGER JINT
++      P=1.0D0
++      Q=((-1.0D0*X**3)+ELAM*X*X-2.0D0)/(X*X)
++      DQDL=1.0D0
++      RETURN
++      END
++\end{verbatim}

Asp10(name): Exports == Implementation where
  name : Symbol

  FST  ==> FortranScalarType
  FT   ==> FortranType
  SYMTAB ==> SymbolTable
  EXF ==> Expression Float
  RSFC ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FEXPR ==> FortranExpression(['JINT,'X,'ELAM],[],MFLOAT)
  MFLOAT ==> MachineFloat
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2

  Exports ==> FortranVectorFunctionCategory with
    coerce : Vector FEXPR -> %
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FST := "real"::FST
    syms : SYMTAB := empty()$SYMTAB
    declare!(P,fortranReal()$FT,syms)$SYMTAB
    declare!(Q,fortranReal()$FT,syms)$SYMTAB
    declare!(DQDL,fortranReal()$FT,syms)$SYMTAB
    declare!(X,fortranReal()$FT,syms)$SYMTAB
    declare!(ELAM,fortranReal()$FT,syms)$SYMTAB
    declare!(JINT,fortranInteger()$FT,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$Union(fst:FST,void:"void"),
                          [P,Q,DQDL,X,ELAM,JINT],syms)

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    coerce(c:FortranCode):% == coerce(c)$Rep

    coerce(r:RSFC):% == coerce(r)$Rep

    coerce(c:List FortranCode):% == coerce(c)$Rep

    -- To help the poor old compiler!
    localAssign(s:Symbol,u:Expression MFLOAT):FortranCode == 
      assign(s,u)$FortranCode

    coerce(u:Vector FEXPR):% ==
      import Vector FEXPR
      not (#u = 3) => error "Incorrect Dimension For Vector"
      ([localAssign(P,elt(u,1)::Expression MFLOAT),_
        localAssign(Q,elt(u,2)::Expression MFLOAT),_
        localAssign(DQDL,elt(u,3)::Expression MFLOAT),_
        returns()$FortranCode ]$List(FortranCode))::Rep

    coerce(u:%):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP12 Asp12}
\pagehead{Asp12}{ASP12}
\pagepic{ps/v103asp12.ps}{ASP12}{1.00}
<<domain ASP12 Asp12>>=
)abbrev domain ASP12 Asp12
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Oct 1993
++ Date Last Updated: 18 March 1994
++                    21 June 1994 Changed print to printStatement
++ Related Constructors:
++ Description:
++\spadtype{Asp12} produces Fortran for Type 12 ASPs, needed for NAG routine 
++\axiomOpFrom{d02kef}{d02Package} etc., for example: 
++\begin{verbatim}
++      SUBROUTINE MONIT (MAXIT,IFLAG,ELAM,FINFO)
++      DOUBLE PRECISION ELAM,FINFO(15)
++      INTEGER MAXIT,IFLAG
++      IF(MAXIT.EQ.-1)THEN
++        PRINT*,"Output from Monit"
++      ENDIF
++      PRINT*,MAXIT,IFLAG,ELAM,(FINFO(I),I=1,4)
++      RETURN
++      END
++\end{verbatim}
Asp12(name): Exports == Implementation where
  name : Symbol

  O      ==> OutputForm
  S      ==> Symbol
  FST    ==> FortranScalarType
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  EXI    ==> Expression Integer
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  U      ==> Union(I: Expression Integer,F: Expression Float,_
                   CF: Expression Complex Float,switch:Switch)
  UFST   ==> Union(fst:FST,void:"void")

  Exports ==> FortranProgramCategory with
     outputAsFortran:() -> Void
      ++outputAsFortran() generates the default code for \spadtype{ASP12}.
    
  Implementation ==> add

    import FC
    import Switch

    real : FST := "real"::FST
    syms : SYMTAB := empty()$SYMTAB
    declare!(MAXIT,fortranInteger()$FT,syms)$SYMTAB
    declare!(IFLAG,fortranInteger()$FT,syms)$SYMTAB
    declare!(ELAM,fortranReal()$FT,syms)$SYMTAB
    fType : FT := construct([real]$UFST,["15"::Symbol],false)$FT
    declare!(FINFO,fType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[MAXIT,IFLAG,ELAM,FINFO],syms)

    -- eqn : O := (I::O)=(1@Integer::EXI::O)
    code:=([cond(EQ([MAXIT@S::EXI]$U,[-1::EXI]$U),
                 printStatement(["_"Output from Monit_""::O])),
            printStatement([MAXIT::O,IFLAG::O,ELAM::O,subscript("(FINFO"::S,[I::O])::O,"I=1"::S::O,"4)"::S::O]), -- YUCK!
            returns()]$List(FortranCode))::Rep

    coerce(u:%):OutputForm == coerce(u)$Rep

    outputAsFortran(u:%):Void == outputAsFortran(u)$Rep
    outputAsFortran():Void == outputAsFortran(code)$Rep  

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP19 Asp19}
\pagehead{Asp19}{ASP19}
\pagepic{ps/v103asp19.ps}{ASP19}{1.00}
<<domain ASP19 Asp19>>=
)abbrev domain ASP19 Asp19
++ Author: Mike Dewar, Godfrey Nolan, Grant Keady
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp19} produces Fortran for Type 19 ASPs, evaluating a set of
++functions and their jacobian at a given point, for example:
++\begin{verbatim}
++      SUBROUTINE LSFUN2(M,N,XC,FVECC,FJACC,LJC)
++      DOUBLE PRECISION FVECC(M),FJACC(LJC,N),XC(N)
++      INTEGER M,N,LJC
++      INTEGER I,J
++      DO 25003 I=1,LJC
++        DO 25004 J=1,N
++          FJACC(I,J)=0.0D0
++25004   CONTINUE
++25003 CONTINUE
++      FVECC(1)=((XC(1)-0.14D0)*XC(3)+(15.0D0*XC(1)-2.1D0)*XC(2)+1.0D0)/(
++     &XC(3)+15.0D0*XC(2))
++      FVECC(2)=((XC(1)-0.18D0)*XC(3)+(7.0D0*XC(1)-1.26D0)*XC(2)+1.0D0)/(
++     &XC(3)+7.0D0*XC(2))
++      FVECC(3)=((XC(1)-0.22D0)*XC(3)+(4.333333333333333D0*XC(1)-0.953333
++     &3333333333D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))
++      FVECC(4)=((XC(1)-0.25D0)*XC(3)+(3.0D0*XC(1)-0.75D0)*XC(2)+1.0D0)/(
++     &XC(3)+3.0D0*XC(2))
++      FVECC(5)=((XC(1)-0.29D0)*XC(3)+(2.2D0*XC(1)-0.6379999999999999D0)*
++     &XC(2)+1.0D0)/(XC(3)+2.2D0*XC(2))
++      FVECC(6)=((XC(1)-0.32D0)*XC(3)+(1.666666666666667D0*XC(1)-0.533333
++     &3333333333D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))
++      FVECC(7)=((XC(1)-0.35D0)*XC(3)+(1.285714285714286D0*XC(1)-0.45D0)*
++     &XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))
++      FVECC(8)=((XC(1)-0.39D0)*XC(3)+(XC(1)-0.39D0)*XC(2)+1.0D0)/(XC(3)+
++     &XC(2))
++      FVECC(9)=((XC(1)-0.37D0)*XC(3)+(XC(1)-0.37D0)*XC(2)+1.285714285714
++     &286D0)/(XC(3)+XC(2))
++      FVECC(10)=((XC(1)-0.58D0)*XC(3)+(XC(1)-0.58D0)*XC(2)+1.66666666666
++     &6667D0)/(XC(3)+XC(2))
++      FVECC(11)=((XC(1)-0.73D0)*XC(3)+(XC(1)-0.73D0)*XC(2)+2.2D0)/(XC(3)
++     &+XC(2))
++      FVECC(12)=((XC(1)-0.96D0)*XC(3)+(XC(1)-0.96D0)*XC(2)+3.0D0)/(XC(3)
++     &+XC(2))
++      FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333
++     &3333D0)/(XC(3)+XC(2))
++      FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X
++     &C(2))
++      FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3
++     &)+XC(2))
++      FJACC(1,1)=1.0D0
++      FJACC(1,2)=-15.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)
++      FJACC(1,3)=-1.0D0/(XC(3)**2+30.0D0*XC(2)*XC(3)+225.0D0*XC(2)**2)
++      FJACC(2,1)=1.0D0
++      FJACC(2,2)=-7.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)
++      FJACC(2,3)=-1.0D0/(XC(3)**2+14.0D0*XC(2)*XC(3)+49.0D0*XC(2)**2)
++      FJACC(3,1)=1.0D0
++      FJACC(3,2)=((-0.1110223024625157D-15*XC(3))-4.333333333333333D0)/(
++     &XC(3)**2+8.666666666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)
++     &**2)
++      FJACC(3,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+8.666666
++     &666666666D0*XC(2)*XC(3)+18.77777777777778D0*XC(2)**2)
++      FJACC(4,1)=1.0D0
++      FJACC(4,2)=-3.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)
++      FJACC(4,3)=-1.0D0/(XC(3)**2+6.0D0*XC(2)*XC(3)+9.0D0*XC(2)**2)
++      FJACC(5,1)=1.0D0
++      FJACC(5,2)=((-0.1110223024625157D-15*XC(3))-2.2D0)/(XC(3)**2+4.399
++     &999999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)
++      FJACC(5,3)=(0.1110223024625157D-15*XC(2)-1.0D0)/(XC(3)**2+4.399999
++     &999999999D0*XC(2)*XC(3)+4.839999999999998D0*XC(2)**2)
++      FJACC(6,1)=1.0D0
++      FJACC(6,2)=((-0.2220446049250313D-15*XC(3))-1.666666666666667D0)/(
++     &XC(3)**2+3.333333333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)
++     &**2)
++      FJACC(6,3)=(0.2220446049250313D-15*XC(2)-1.0D0)/(XC(3)**2+3.333333
++     &333333333D0*XC(2)*XC(3)+2.777777777777777D0*XC(2)**2)
++      FJACC(7,1)=1.0D0
++      FJACC(7,2)=((-0.5551115123125783D-16*XC(3))-1.285714285714286D0)/(
++     &XC(3)**2+2.571428571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)
++     &**2)
++      FJACC(7,3)=(0.5551115123125783D-16*XC(2)-1.0D0)/(XC(3)**2+2.571428
++     &571428571D0*XC(2)*XC(3)+1.653061224489796D0*XC(2)**2)
++      FJACC(8,1)=1.0D0
++      FJACC(8,2)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(8,3)=-1.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(9,1)=1.0D0
++      FJACC(9,2)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*
++     &*2)
++      FJACC(9,3)=-1.285714285714286D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)*
++     &*2)
++      FJACC(10,1)=1.0D0
++      FJACC(10,2)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)
++     &**2)
++      FJACC(10,3)=-1.666666666666667D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)
++     &**2)
++      FJACC(11,1)=1.0D0
++      FJACC(11,2)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(11,3)=-2.2D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(12,1)=1.0D0
++      FJACC(12,2)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(12,3)=-3.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(13,1)=1.0D0
++      FJACC(13,2)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)
++     &**2)
++      FJACC(13,3)=-4.333333333333333D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)
++     &**2)
++      FJACC(14,1)=1.0D0
++      FJACC(14,2)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(14,3)=-7.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(15,1)=1.0D0
++      FJACC(15,2)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      FJACC(15,3)=-15.0D0/(XC(3)**2+2.0D0*XC(2)*XC(3)+XC(2)**2)
++      RETURN
++      END
++\end{verbatim}

Asp19(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FC))
  FSTU   ==> Union(fst:FST,void:"void")
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  MFLOAT ==> MachineFloat
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,Matrix FEXPR,EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,Matrix EXPR MFLOAT)
  FEXPR  ==> FortranExpression([],['XC],MFLOAT)
  S      ==> Symbol

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(M,fortranInteger()$FT,syms)$SYMTAB
    declare!(N,fortranInteger()$FT,syms)$SYMTAB
    declare!(LJC,fortranInteger()$FT,syms)$SYMTAB
    xcType : FT := construct(real,[N],false)$FT
    declare!(XC,xcType,syms)$SYMTAB
    fveccType : FT := construct(real,[M],false)$FT
    declare!(FVECC,fveccType,syms)$SYMTAB
    fjaccType : FT := construct(real,[LJC,N],false)$FT
    declare!(FJACC,fjaccType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,[M,N,XC,FVECC,FJACC,LJC],syms)

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    -- Take a symbol, pull of the script and turn it into an integer!!
    o2int(u:S):Integer ==
      o : OutputForm := first elt(scripts(u)$S,sub)
      o pretend Integer

    -- To help the poor old compiler!
    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign1(s:S,j:Matrix FEXPR):FC == 
      j' : Matrix EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FC

    localAssign2(s:S,j:VEC FEXPR):FC ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FC

    coerce(u:VEC FEXPR):$ ==
      -- First zero the Jacobian matrix in case we miss some derivatives which
      -- are zero.
      import POLY INT
      seg1 : Segment (POLY INT) := segment(1::(POLY INT),LJC@S::(POLY INT))
      seg2 : Segment (POLY INT) := segment(1::(POLY INT),N@S::(POLY INT))
      s1 : SegmentBinding POLY INT := equation(I@S,seg1)
      s2 : SegmentBinding POLY INT := equation(J@S,seg2)
      as : FC := assign(FJACC,[I@S::(POLY INT),J@S::(POLY INT)],0.0::EXPR FLOAT)
      clear : FC := forLoop(s1,forLoop(s2,as))
      j:Integer
      x:S := XC::S
      pu:List(S) := []
      -- Work out which variables appear in the expressions
      for e in entries(u) repeat
        pu := setUnion(pu,variables(e)$FEXPR)
      scriptList : List Integer := map(o2int,pu)$ListFunctions2(S,Integer)
      -- This should be the maximum XC_n which occurs (there may be others
      -- which don't):
      n:Integer := reduce(max,scriptList)$List(Integer)
      p:List(S) := []
      for j in 1..n repeat p:= cons(subscript(x,[j::OutputForm])$S,p)
      p:= reverse(p)
      jac:Matrix(FEXPR) := _
      jacobian(u,p)$MultiVariableCalculusFunctions(S,FEXPR,VEC FEXPR,List(S))
      c1:FC := localAssign2(FVECC,u)
      c2:FC := localAssign1(FJACC,jac)
      [clear,c1,c2,returns()]$List(FC)::$

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage


    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP20 Asp20}
\pagehead{Asp20}{ASP20}
\pagepic{ps/v103asp20.ps}{ASP20}{1.00}
<<domain ASP20 Asp20>>=
)abbrev domain ASP20 Asp20
++ Author: Mike Dewar and Godfrey Nolan and Grant Keady
++ Date Created: Dec 1993
++ Date Last Updated: 21 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp20} produces Fortran for Type 20 ASPs, for example:
++\begin{verbatim}
++      SUBROUTINE QPHESS(N,NROWH,NCOLH,JTHCOL,HESS,X,HX)
++      DOUBLE PRECISION HX(N),X(N),HESS(NROWH,NCOLH)
++      INTEGER JTHCOL,N,NROWH,NCOLH
++      HX(1)=2.0D0*X(1)
++      HX(2)=2.0D0*X(2)
++      HX(3)=2.0D0*X(4)+2.0D0*X(3)
++      HX(4)=2.0D0*X(4)+2.0D0*X(3)
++      HX(5)=2.0D0*X(5)
++      HX(6)=(-2.0D0*X(7))+(-2.0D0*X(6))
++      HX(7)=(-2.0D0*X(7))+(-2.0D0*X(6))
++      RETURN
++      END
++\end{verbatim}

Asp20(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  PI     ==> PositiveInteger
  UFST   ==> Union(fst:FST,void:"void")
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  MAT    ==> Matrix
  VF2    ==> VectorFunctions2
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression([],['X,'HESS],MFLOAT)
  O      ==> OutputForm
  M2     ==> MatrixCategoryFunctions2
  MF2a   ==> M2(FRAC POLY INT,VEC FRAC POLY INT,VEC FRAC POLY INT,
                MAT FRAC POLY INT,FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2b   ==> M2(FRAC POLY FLOAT,VEC FRAC POLY FLOAT,VEC FRAC POLY FLOAT,
                MAT FRAC POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2c   ==> M2(POLY INT,VEC POLY INT,VEC POLY INT,MAT POLY INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2d   ==> M2(POLY FLOAT,VEC POLY FLOAT,VEC POLY FLOAT,
                MAT POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2e   ==> M2(EXPR INT,VEC EXPR INT,VEC EXPR INT,MAT EXPR INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2f   ==> M2(EXPR FLOAT,VEC EXPR FLOAT,VEC EXPR FLOAT,
                MAT EXPR FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)


  Exports ==> FortranMatrixFunctionCategory with
    coerce: MAT FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()
    declare!(N,fortranInteger(),syms)$SYMTAB
    declare!(NROWH,fortranInteger(),syms)$SYMTAB
    declare!(NCOLH,fortranInteger(),syms)$SYMTAB
    declare!(JTHCOL,fortranInteger(),syms)$SYMTAB
    hessType : FT := construct(real,[NROWH,NCOLH],false)$FT
    declare!(HESS,hessType,syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(X,xType,syms)$SYMTAB
    declare!(HX,xType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,
                          [N,NROWH,NCOLH,JTHCOL,HESS,X,HX],syms)

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    -- To help the poor old compiler!
    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign(s:Symbol,j:VEC FEXPR):FortranCode ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FortranCode

    coerce(u:MAT FEXPR):$ ==
      j:Integer
      x:Symbol := X::Symbol
      n := nrows(u)::PI
      p:VEC FEXPR := [retract(subscript(x,[j::O])$Symbol)@FEXPR for j in 1..n]
      prod:VEC FEXPR := u*p
      ([localAssign(HX,prod),returns()$FortranCode]$List(FortranCode))::$

    retract(u:MAT FRAC POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2a
      v::$

    retractIfCan(u:MAT FRAC POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2a
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT FRAC POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2b
      v::$

    retractIfCan(u:MAT FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2b
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2e
      v::$

    retractIfCan(u:MAT EXPR INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2e
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2f
      v::$

    retractIfCan(u:MAT EXPR FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2f
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2c
      v::$

    retractIfCan(u:MAT POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2c
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2d
      v::$

    retractIfCan(u:MAT POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2d
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    coerce(u:$):O == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP24 Asp24}
\pagehead{Asp24}{ASP24}
\pagepic{ps/v103asp24.ps}{ASP24}{1.00}
<<domain ASP24 Asp24>>=
)abbrev domain ASP24 Asp24
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 21 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp24} produces Fortran for Type 24 ASPs which evaluate a 
++multivariate function at a point (needed for NAG routine \axiomOpFrom{e04jaf}{e04Package}), for example:
++\begin{verbatim}
++      SUBROUTINE FUNCT1(N,XC,FC)
++      DOUBLE PRECISION FC,XC(N)
++      INTEGER N
++      FC=10.0D0*XC(4)**4+(-40.0D0*XC(1)*XC(4)**3)+(60.0D0*XC(1)**2+5
++     &.0D0)*XC(4)**2+((-10.0D0*XC(3))+(-40.0D0*XC(1)**3))*XC(4)+16.0D0*X
++     &C(3)**4+(-32.0D0*XC(2)*XC(3)**3)+(24.0D0*XC(2)**2+5.0D0)*XC(3)**2+
++     &(-8.0D0*XC(2)**3*XC(3))+XC(2)**4+100.0D0*XC(2)**2+20.0D0*XC(1)*XC(
++     &2)+10.0D0*XC(1)**4+XC(1)**2
++      RETURN
++      END
++\end{verbatim}

Asp24(name): Exports == Implementation where
  name : Symbol

  FST  ==> FortranScalarType
  FT   ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FSTU ==> Union(fst:FST,void:"void")
  FEXPR ==> FortranExpression([],['XC],MachineFloat)
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float

  Exports ==> FortranFunctionCategory with
      coerce : FEXPR -> $
	++ coerce(f) takes an object from the appropriate instantiation of
      	++ \spadtype{FortranExpression} and turns it into an ASP.


  Implementation ==> add


    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()
    declare!(N,fortranInteger(),syms)$SYMTAB
    xcType : FT := construct(real,[N::Symbol],false)$FT
    declare!(XC,xcType,syms)$SYMTAB
    declare!(FC,fortranReal(),syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,[N,XC,FC],syms)

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:FEXPR):$ ==
      coerce(assign(FC,u::Expression(MachineFloat))$FortranCode)$Rep

    retract(u:FRAC POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:FRAC POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP27 Asp27}
\pagehead{Asp27}{ASP27}
\pagepic{ps/v103asp27.ps}{ASP27}{1.00}
<<domain ASP27 Asp27>>=
)abbrev domain ASP27 Asp27
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Nov 1993
++ Date Last Updated: 27 April 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp27} produces Fortran for Type 27 ASPs, needed for NAG routine
++\axiomOpFrom{f02fjf}{f02Package} ,for example:
++\begin{verbatim}
++      FUNCTION DOT(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)
++      DOUBLE PRECISION W(N),Z(N),RWORK(LRWORK)
++      INTEGER N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)
++      DOT=(W(16)+(-0.5D0*W(15)))*Z(16)+((-0.5D0*W(16))+W(15)+(-0.5D0*W(1
++     &4)))*Z(15)+((-0.5D0*W(15))+W(14)+(-0.5D0*W(13)))*Z(14)+((-0.5D0*W(
++     &14))+W(13)+(-0.5D0*W(12)))*Z(13)+((-0.5D0*W(13))+W(12)+(-0.5D0*W(1
++     &1)))*Z(12)+((-0.5D0*W(12))+W(11)+(-0.5D0*W(10)))*Z(11)+((-0.5D0*W(
++     &11))+W(10)+(-0.5D0*W(9)))*Z(10)+((-0.5D0*W(10))+W(9)+(-0.5D0*W(8))
++     &)*Z(9)+((-0.5D0*W(9))+W(8)+(-0.5D0*W(7)))*Z(8)+((-0.5D0*W(8))+W(7)
++     &+(-0.5D0*W(6)))*Z(7)+((-0.5D0*W(7))+W(6)+(-0.5D0*W(5)))*Z(6)+((-0.
++     &5D0*W(6))+W(5)+(-0.5D0*W(4)))*Z(5)+((-0.5D0*W(5))+W(4)+(-0.5D0*W(3
++     &)))*Z(4)+((-0.5D0*W(4))+W(3)+(-0.5D0*W(2)))*Z(3)+((-0.5D0*W(3))+W(
++     &2)+(-0.5D0*W(1)))*Z(2)+((-0.5D0*W(2))+W(1))*Z(1)
++      RETURN
++      END
++\end{verbatim}

Asp27(name): Exports == Implementation where
  name : Symbol

  O      ==> OutputForm
  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  UFST   ==> Union(fst:FST,void:"void")
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  EXPR   ==> Expression
  MAT    ==> Matrix
  MFLOAT ==> MachineFloat



  Exports == FortranMatrixCategory

  Implementation == add


    real : UFST := ["real"::FST]$UFST
    integer : UFST := ["integer"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(IFLAG,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    declare!(LRWORK,fortranInteger(),syms)$SYMTAB
    declare!(LIWORK,fortranInteger(),syms)$SYMTAB
    zType : FT := construct(real,[N],false)$FT
    declare!(Z,zType,syms)$SYMTAB
    declare!(W,zType,syms)$SYMTAB
    rType : FT := construct(real,[LRWORK],false)$FT
    declare!(RWORK,rType,syms)$SYMTAB
    iType : FT := construct(integer,[LIWORK],false)$FT
    declare!(IWORK,iType,syms)$SYMTAB
    Rep := FortranProgram(name,real,
                          [IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK],syms)

    -- To help the poor old compiler!
    localCoerce(u:Symbol):EXPR(MFLOAT) == coerce(u)$EXPR(MFLOAT)

    coerce (u:MAT MFLOAT):$ ==
      Ws: Symbol := W
      Zs: Symbol := Z
      code : List FC
      l:EXPR MFLOAT := "+"/ _
          [("+"/[localCoerce(elt(Ws,[j::O])$Symbol) * u(j,i)_
                                              for j in 1..nrows(u)::PI])_
           *localCoerce(elt(Zs,[i::O])$Symbol) for i in 1..ncols(u)::PI]
      c := assign(name,l)$FC
      code := [c,returns()]$List(FC)
      code::$

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP28 Asp28}
\pagehead{Asp28}{ASP28}
\pagepic{ps/v103asp28.ps}{ASP28}{1.00}
<<domain ASP28 Asp28>>=
)abbrev domain ASP28 Asp28
++ Author: Mike Dewar
++ Date Created: 21 March 1994
++ Date Last Updated: 28 April 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp28} produces Fortran for Type 28 ASPs, used in NAG routine 
++\axiomOpFrom{f02fjf}{f02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE IMAGE(IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK)
++      DOUBLE PRECISION Z(N),W(N),IWORK(LRWORK),RWORK(LRWORK)
++      INTEGER N,LIWORK,IFLAG,LRWORK
++      W(1)=0.01707454969713436D0*Z(16)+0.001747395874954051D0*Z(15)+0.00
++     &2106973900813502D0*Z(14)+0.002957434991769087D0*Z(13)+(-0.00700554
++     &0882865317D0*Z(12))+(-0.01219194009813166D0*Z(11))+0.0037230647365
++     &3087D0*Z(10)+0.04932374658377151D0*Z(9)+(-0.03586220812223305D0*Z(
++     &8))+(-0.04723268012114625D0*Z(7))+(-0.02434652144032987D0*Z(6))+0.
++     &2264766947290192D0*Z(5)+(-0.1385343580686922D0*Z(4))+(-0.116530050
++     &8238904D0*Z(3))+(-0.2803531651057233D0*Z(2))+1.019463911841327D0*Z
++     &(1)
++      W(2)=0.0227345011107737D0*Z(16)+0.008812321197398072D0*Z(15)+0.010
++     &94012210519586D0*Z(14)+(-0.01764072463999744D0*Z(13))+(-0.01357136
++     &72105995D0*Z(12))+0.00157466157362272D0*Z(11)+0.05258889186338282D
++     &0*Z(10)+(-0.01981532388243379D0*Z(9))+(-0.06095390688679697D0*Z(8)
++     &)+(-0.04153119955569051D0*Z(7))+0.2176561076571465D0*Z(6)+(-0.0532
++     &5555586632358D0*Z(5))+(-0.1688977368984641D0*Z(4))+(-0.32440166056
++     &67343D0*Z(3))+0.9128222941872173D0*Z(2)+(-0.2419652703415429D0*Z(1
++     &))
++      W(3)=0.03371198197190302D0*Z(16)+0.02021603150122265D0*Z(15)+(-0.0
++     &06607305534689702D0*Z(14))+(-0.03032392238968179D0*Z(13))+0.002033
++     &305231024948D0*Z(12)+0.05375944956767728D0*Z(11)+(-0.0163213312502
++     &9967D0*Z(10))+(-0.05483186562035512D0*Z(9))+(-0.04901428822579872D
++     &0*Z(8))+0.2091097927887612D0*Z(7)+(-0.05760560341383113D0*Z(6))+(-
++     &0.1236679206156403D0*Z(5))+(-0.3523683853026259D0*Z(4))+0.88929961
++     &32269974D0*Z(3)+(-0.2995429545781457D0*Z(2))+(-0.02986582812574917
++     &D0*Z(1))
++      W(4)=0.05141563713660119D0*Z(16)+0.005239165960779299D0*Z(15)+(-0.
++     &01623427735779699D0*Z(14))+(-0.01965809746040371D0*Z(13))+0.054688
++     &97337339577D0*Z(12)+(-0.014224695935687D0*Z(11))+(-0.0505181779315
++     &6355D0*Z(10))+(-0.04353074206076491D0*Z(9))+0.2012230497530726D0*Z
++     &(8)+(-0.06630874514535952D0*Z(7))+(-0.1280829963720053D0*Z(6))+(-0
++     &.305169742604165D0*Z(5))+0.8600427128450191D0*Z(4)+(-0.32415033802
++     &68184D0*Z(3))+(-0.09033531980693314D0*Z(2))+0.09089205517109111D0*
++     &Z(1)
++      W(5)=0.04556369767776375D0*Z(16)+(-0.001822737697581869D0*Z(15))+(
++     &-0.002512226501941856D0*Z(14))+0.02947046460707379D0*Z(13)+(-0.014
++     &45079632086177D0*Z(12))+(-0.05034242196614937D0*Z(11))+(-0.0376966
++     &3291725935D0*Z(10))+0.2171103102175198D0*Z(9)+(-0.0824949256021352
++     &4D0*Z(8))+(-0.1473995209288945D0*Z(7))+(-0.315042193418466D0*Z(6))
++     &+0.9591623347824002D0*Z(5)+(-0.3852396953763045D0*Z(4))+(-0.141718
++     &5427288274D0*Z(3))+(-0.03423495461011043D0*Z(2))+0.319820917706851
++     &6D0*Z(1)
++      W(6)=0.04015147277405744D0*Z(16)+0.01328585741341559D0*Z(15)+0.048
++     &26082005465965D0*Z(14)+(-0.04319641116207706D0*Z(13))+(-0.04931323
++     &319055762D0*Z(12))+(-0.03526886317505474D0*Z(11))+0.22295383396730
++     &01D0*Z(10)+(-0.07375317649315155D0*Z(9))+(-0.1589391311991561D0*Z(
++     &8))+(-0.328001910890377D0*Z(7))+0.952576555482747D0*Z(6)+(-0.31583
++     &09975786731D0*Z(5))+(-0.1846882042225383D0*Z(4))+(-0.0703762046700
++     &4427D0*Z(3))+0.2311852964327382D0*Z(2)+0.04254083491825025D0*Z(1)
++      W(7)=0.06069778964023718D0*Z(16)+0.06681263884671322D0*Z(15)+(-0.0
++     &2113506688615768D0*Z(14))+(-0.083996867458326D0*Z(13))+(-0.0329843
++     &8523869648D0*Z(12))+0.2276878326327734D0*Z(11)+(-0.067356038933017
++     &95D0*Z(10))+(-0.1559813965382218D0*Z(9))+(-0.3363262957694705D0*Z(
++     &8))+0.9442791158560948D0*Z(7)+(-0.3199955249404657D0*Z(6))+(-0.136
++     &2463839920727D0*Z(5))+(-0.1006185171570586D0*Z(4))+0.2057504515015
++     &423D0*Z(3)+(-0.02065879269286707D0*Z(2))+0.03160990266745513D0*Z(1
++     &)
++      W(8)=0.126386868896738D0*Z(16)+0.002563370039476418D0*Z(15)+(-0.05
++     &581757739455641D0*Z(14))+(-0.07777893205900685D0*Z(13))+0.23117338
++     &45834199D0*Z(12)+(-0.06031581134427592D0*Z(11))+(-0.14805474755869
++     &52D0*Z(10))+(-0.3364014128402243D0*Z(9))+0.9364014128402244D0*Z(8)
++     &+(-0.3269452524413048D0*Z(7))+(-0.1396841886557241D0*Z(6))+(-0.056
++     &1733845834199D0*Z(5))+0.1777789320590069D0*Z(4)+(-0.04418242260544
++     &359D0*Z(3))+(-0.02756337003947642D0*Z(2))+0.07361313110326199D0*Z(
++     &1)
++      W(9)=0.07361313110326199D0*Z(16)+(-0.02756337003947642D0*Z(15))+(-
++     &0.04418242260544359D0*Z(14))+0.1777789320590069D0*Z(13)+(-0.056173
++     &3845834199D0*Z(12))+(-0.1396841886557241D0*Z(11))+(-0.326945252441
++     &3048D0*Z(10))+0.9364014128402244D0*Z(9)+(-0.3364014128402243D0*Z(8
++     &))+(-0.1480547475586952D0*Z(7))+(-0.06031581134427592D0*Z(6))+0.23
++     &11733845834199D0*Z(5)+(-0.07777893205900685D0*Z(4))+(-0.0558175773
++     &9455641D0*Z(3))+0.002563370039476418D0*Z(2)+0.126386868896738D0*Z(
++     &1)
++      W(10)=0.03160990266745513D0*Z(16)+(-0.02065879269286707D0*Z(15))+0
++     &.2057504515015423D0*Z(14)+(-0.1006185171570586D0*Z(13))+(-0.136246
++     &3839920727D0*Z(12))+(-0.3199955249404657D0*Z(11))+0.94427911585609
++     &48D0*Z(10)+(-0.3363262957694705D0*Z(9))+(-0.1559813965382218D0*Z(8
++     &))+(-0.06735603893301795D0*Z(7))+0.2276878326327734D0*Z(6)+(-0.032
++     &98438523869648D0*Z(5))+(-0.083996867458326D0*Z(4))+(-0.02113506688
++     &615768D0*Z(3))+0.06681263884671322D0*Z(2)+0.06069778964023718D0*Z(
++     &1)
++      W(11)=0.04254083491825025D0*Z(16)+0.2311852964327382D0*Z(15)+(-0.0
++     &7037620467004427D0*Z(14))+(-0.1846882042225383D0*Z(13))+(-0.315830
++     &9975786731D0*Z(12))+0.952576555482747D0*Z(11)+(-0.328001910890377D
++     &0*Z(10))+(-0.1589391311991561D0*Z(9))+(-0.07375317649315155D0*Z(8)
++     &)+0.2229538339673001D0*Z(7)+(-0.03526886317505474D0*Z(6))+(-0.0493
++     &1323319055762D0*Z(5))+(-0.04319641116207706D0*Z(4))+0.048260820054
++     &65965D0*Z(3)+0.01328585741341559D0*Z(2)+0.04015147277405744D0*Z(1)
++      W(12)=0.3198209177068516D0*Z(16)+(-0.03423495461011043D0*Z(15))+(-
++     &0.1417185427288274D0*Z(14))+(-0.3852396953763045D0*Z(13))+0.959162
++     &3347824002D0*Z(12)+(-0.315042193418466D0*Z(11))+(-0.14739952092889
++     &45D0*Z(10))+(-0.08249492560213524D0*Z(9))+0.2171103102175198D0*Z(8
++     &)+(-0.03769663291725935D0*Z(7))+(-0.05034242196614937D0*Z(6))+(-0.
++     &01445079632086177D0*Z(5))+0.02947046460707379D0*Z(4)+(-0.002512226
++     &501941856D0*Z(3))+(-0.001822737697581869D0*Z(2))+0.045563697677763
++     &75D0*Z(1)
++      W(13)=0.09089205517109111D0*Z(16)+(-0.09033531980693314D0*Z(15))+(
++     &-0.3241503380268184D0*Z(14))+0.8600427128450191D0*Z(13)+(-0.305169
++     &742604165D0*Z(12))+(-0.1280829963720053D0*Z(11))+(-0.0663087451453
++     &5952D0*Z(10))+0.2012230497530726D0*Z(9)+(-0.04353074206076491D0*Z(
++     &8))+(-0.05051817793156355D0*Z(7))+(-0.014224695935687D0*Z(6))+0.05
++     &468897337339577D0*Z(5)+(-0.01965809746040371D0*Z(4))+(-0.016234277
++     &35779699D0*Z(3))+0.005239165960779299D0*Z(2)+0.05141563713660119D0
++     &*Z(1)
++      W(14)=(-0.02986582812574917D0*Z(16))+(-0.2995429545781457D0*Z(15))
++     &+0.8892996132269974D0*Z(14)+(-0.3523683853026259D0*Z(13))+(-0.1236
++     &679206156403D0*Z(12))+(-0.05760560341383113D0*Z(11))+0.20910979278
++     &87612D0*Z(10)+(-0.04901428822579872D0*Z(9))+(-0.05483186562035512D
++     &0*Z(8))+(-0.01632133125029967D0*Z(7))+0.05375944956767728D0*Z(6)+0
++     &.002033305231024948D0*Z(5)+(-0.03032392238968179D0*Z(4))+(-0.00660
++     &7305534689702D0*Z(3))+0.02021603150122265D0*Z(2)+0.033711981971903
++     &02D0*Z(1)
++      W(15)=(-0.2419652703415429D0*Z(16))+0.9128222941872173D0*Z(15)+(-0
++     &.3244016605667343D0*Z(14))+(-0.1688977368984641D0*Z(13))+(-0.05325
++     &555586632358D0*Z(12))+0.2176561076571465D0*Z(11)+(-0.0415311995556
++     &9051D0*Z(10))+(-0.06095390688679697D0*Z(9))+(-0.01981532388243379D
++     &0*Z(8))+0.05258889186338282D0*Z(7)+0.00157466157362272D0*Z(6)+(-0.
++     &0135713672105995D0*Z(5))+(-0.01764072463999744D0*Z(4))+0.010940122
++     &10519586D0*Z(3)+0.008812321197398072D0*Z(2)+0.0227345011107737D0*Z
++     &(1)
++      W(16)=1.019463911841327D0*Z(16)+(-0.2803531651057233D0*Z(15))+(-0.
++     &1165300508238904D0*Z(14))+(-0.1385343580686922D0*Z(13))+0.22647669
++     &47290192D0*Z(12)+(-0.02434652144032987D0*Z(11))+(-0.04723268012114
++     &625D0*Z(10))+(-0.03586220812223305D0*Z(9))+0.04932374658377151D0*Z
++     &(8)+0.00372306473653087D0*Z(7)+(-0.01219194009813166D0*Z(6))+(-0.0
++     &07005540882865317D0*Z(5))+0.002957434991769087D0*Z(4)+0.0021069739
++     &00813502D0*Z(3)+0.001747395874954051D0*Z(2)+0.01707454969713436D0*
++     &Z(1)
++      RETURN
++      END
++\end{verbatim}

Asp28(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  EXPR   ==> Expression
  MFLOAT ==> MachineFloat
  VEC    ==> Vector
  UFST   ==> Union(fst:FST,void:"void")
  MAT    ==> Matrix

  Exports == FortranMatrixCategory 

  Implementation == add


    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()
    declare!(IFLAG,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    declare!(LRWORK,fortranInteger(),syms)$SYMTAB
    declare!(LIWORK,fortranInteger(),syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(Z,xType,syms)$SYMTAB
    declare!(W,xType,syms)$SYMTAB
    rType : FT := construct(real,[LRWORK],false)$FT
    declare!(RWORK,rType,syms)$SYMTAB
    iType : FT := construct(real,[LIWORK],false)$FT
    declare!(IWORK,rType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,
                          [IFLAG,N,Z,W,RWORK,LRWORK,IWORK,LIWORK],syms)

    -- To help the poor old compiler!
    localCoerce(u:Symbol):EXPR(MFLOAT) == coerce(u)$EXPR(MFLOAT)

    coerce (u:MAT MFLOAT):$ ==
      Zs: Symbol := Z
      code : List FC
      r: List EXPR MFLOAT
      r := ["+"/[u(j,i)*localCoerce(elt(Zs,[i::OutputForm])$Symbol)_
                         for i in 1..ncols(u)$MAT(MFLOAT)::PI]_
                         for j in 1..nrows(u)$MAT(MFLOAT)::PI]
      code := [assign(W@Symbol,vector(r)$VEC(EXPR MFLOAT)),returns()]$List(FC)
      code::$

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP29 Asp29}
\pagehead{Asp29}{ASP29}
\pagepic{ps/v103asp29.ps}{ASP29}{1.00}
<<domain ASP29 Asp29>>=
)abbrev domain ASP29 Asp29
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Nov 1993
++ Date Last Updated: 18 March 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp29} produces Fortran for Type 29 ASPs, needed for NAG routine
++\axiomOpFrom{f02fjf}{f02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE MONIT(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)
++      DOUBLE PRECISION D(K),F(K)
++      INTEGER K,NEXTIT,NEVALS,NVECS,ISTATE
++      CALL F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)
++      RETURN
++      END
++\end{verbatim}

Asp29(name): Exports == Implementation where
  name : Symbol

  FST  ==> FortranScalarType
  FT   ==> FortranType
  FSTU   ==> Union(fst:FST,void:"void")
  SYMTAB ==> SymbolTable
  FC   ==> FortranCode
  PI   ==> PositiveInteger
  EXF   ==> Expression Float
  EXI   ==> Expression Integer
  VEF  ==> Vector Expression Float
  VEI  ==> Vector Expression Integer
  MEI  ==> Matrix Expression Integer
  MEF  ==> Matrix Expression Float
  UEXPR ==> Union(I: Expression Integer,F: Expression Float,_
                  CF: Expression Complex Float)
  RSFC ==> Record(localSymbols:SymbolTable,code:List(FortranCode))

  Exports == FortranProgramCategory  with
     outputAsFortran:() -> Void
       ++outputAsFortran() generates the default code for \spadtype{ASP29}.


  Implementation == add

    import FST
    import FT
    import FC    
    import SYMTAB

    real : FSTU := ["real"::FST]$FSTU
    integer : FSTU := ["integer"::FST]$FSTU
    syms : SYMTAB := empty()
    declare!(ISTATE,fortranInteger(),syms)
    declare!(NEXTIT,fortranInteger(),syms)    
    declare!(NEVALS,fortranInteger(),syms)
    declare!(NVECS,fortranInteger(),syms)
    declare!(K,fortranInteger(),syms)
    kType : FT := construct(real,[K],false)$FT
    declare!(F,kType,syms)
    declare!(D,kType,syms)
    Rep := FortranProgram(name,["void"]$FSTU,
                          [ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D],syms)


    outputAsFortran():Void ==
      callOne := call("F02FJZ(ISTATE,NEXTIT,NEVALS,NEVECS,K,F,D)")
      code : List FC := [callOne,returns()]$List(FC)
      outputAsFortran(coerce(code)@Rep)$Rep

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP30 Asp30}
\pagehead{Asp30}{ASP30}
\pagepic{ps/v103asp30.ps}{ASP30}{1.00}
<<domain ASP30 Asp30>>=
)abbrev domain ASP30 Asp30
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Nov 1993
++ Date Last Updated: 28 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp30} produces Fortran for Type 30 ASPs, needed for NAG routine
++\axiomOpFrom{f04qaf}{f04Package}, for example:
++\begin{verbatim}
++      SUBROUTINE APROD(MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)
++      DOUBLE PRECISION X(N),Y(M),RWORK(LRWORK)
++      INTEGER M,N,LIWORK,IFAIL,LRWORK,IWORK(LIWORK),MODE
++      DOUBLE PRECISION A(5,5)
++      EXTERNAL F06PAF
++      A(1,1)=1.0D0
++      A(1,2)=0.0D0
++      A(1,3)=0.0D0
++      A(1,4)=-1.0D0
++      A(1,5)=0.0D0
++      A(2,1)=0.0D0
++      A(2,2)=1.0D0
++      A(2,3)=0.0D0
++      A(2,4)=0.0D0
++      A(2,5)=-1.0D0
++      A(3,1)=0.0D0
++      A(3,2)=0.0D0
++      A(3,3)=1.0D0
++      A(3,4)=-1.0D0
++      A(3,5)=0.0D0
++      A(4,1)=-1.0D0
++      A(4,2)=0.0D0
++      A(4,3)=-1.0D0
++      A(4,4)=4.0D0
++      A(4,5)=-1.0D0
++      A(5,1)=0.0D0
++      A(5,2)=-1.0D0
++      A(5,3)=0.0D0
++      A(5,4)=-1.0D0
++      A(5,5)=4.0D0
++      IF(MODE.EQ.1)THEN
++        CALL F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)
++      ELSEIF(MODE.EQ.2)THEN
++        CALL F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)
++      ENDIF
++      RETURN
++      END
++\end{verbatim}

Asp30(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  UFST   ==> Union(fst:FST,void:"void")
  MAT    ==> Matrix
  MFLOAT ==> MachineFloat
  EXI    ==> Expression Integer
  UEXPR  ==> Union(I:Expression Integer,F:Expression Float,_
                   CF:Expression Complex Float,switch:Switch)
  S      ==> Symbol

  Exports == FortranMatrixCategory 

  Implementation == add

    import FC    
    import FT    
    import Switch

    real : UFST := ["real"::FST]$UFST
    integer : UFST := ["integer"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(MODE,fortranInteger()$FT,syms)$SYMTAB
    declare!(M,fortranInteger()$FT,syms)$SYMTAB
    declare!(N,fortranInteger()$FT,syms)$SYMTAB
    declare!(LRWORK,fortranInteger()$FT,syms)$SYMTAB
    declare!(LIWORK,fortranInteger()$FT,syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(X,xType,syms)$SYMTAB
    yType : FT := construct(real,[M],false)$FT
    declare!(Y,yType,syms)$SYMTAB
    rType : FT := construct(real,[LRWORK],false)$FT
    declare!(RWORK,rType,syms)$SYMTAB
    iType : FT := construct(integer,[LIWORK],false)$FT
    declare!(IWORK,iType,syms)$SYMTAB
    declare!(IFAIL,fortranInteger()$FT,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,
                          [MODE,M,N,X,Y,RWORK,LRWORK,IWORK,LIWORK],syms)

    coerce(a:MAT MFLOAT):$ ==
      locals : SYMTAB := empty()
      numRows := nrows(a) :: Polynomial Integer
      numCols := ncols(a) :: Polynomial Integer
      declare!(A,[real,[numRows,numCols],false]$FT,locals)
      declare!(F06PAF@S,construct(["void"]$UFST,[]@List(S),true)$FT,locals)
      ptA:UEXPR := [("MODE"::S)::EXI]
      ptB:UEXPR := [1::EXI]
      ptC:UEXPR := [2::EXI]
      sw1 : Switch := EQ(ptA,ptB)$Switch
      sw2 : Switch := EQ(ptA,ptC)$Switch
      callOne := call("F06PAF('N',M,N,1.0D0,A,M,X,1,1.0D0,Y,1)")
      callTwo := call("F06PAF('T',M,N,1.0D0,A,M,Y,1,1.0D0,X,1)")
      c : FC := cond(sw1,callOne,cond(sw2,callTwo))
      code : List FC := [assign(A,a),c,returns()]
      ([locals,code]$RSFC)::$

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP31 Asp31}
\pagehead{Asp31}{ASP31}
\pagepic{ps/v103asp31.ps}{ASP31}{1.00}
<<domain ASP31 Asp31>>=
)abbrev domain ASP31 Asp31
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 22 March 1994
++                     6 October 1994
++ Related Constructors: FortranMatrixFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp31} produces Fortran for Type 31 ASPs, needed for NAG routine 
++\axiomOpFrom{d02ejf}{d02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE PEDERV(X,Y,PW)
++      DOUBLE PRECISION X,Y(*)
++      DOUBLE PRECISION PW(3,3)
++      PW(1,1)=-0.03999999999999999D0
++      PW(1,2)=10000.0D0*Y(3)
++      PW(1,3)=10000.0D0*Y(2)
++      PW(2,1)=0.03999999999999999D0
++      PW(2,2)=(-10000.0D0*Y(3))+(-60000000.0D0*Y(2))
++      PW(2,3)=-10000.0D0*Y(2)
++      PW(3,1)=0.0D0
++      PW(3,2)=60000000.0D0*Y(2)
++      PW(3,3)=0.0D0
++      RETURN
++      END
++\end{verbatim}

Asp31(name): Exports == Implementation where
  name : Symbol

  O      ==> OutputForm
  FST    ==> FortranScalarType
  UFST   ==> Union(fst:FST,void:"void")
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X],['Y],MFLOAT)
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  MAT    ==> Matrix
  VF2    ==> VectorFunctions2
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR,
                    EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,MAT EXPR MFLOAT)



  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add


    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()
    declare!(X,fortranReal(),syms)$SYMTAB
    yType : FT := construct(real,["*"::Symbol],false)$FT
    declare!(Y,yType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[X,Y,PW],syms)

    -- To help the poor old compiler!
    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign(s:Symbol,j:MAT FEXPR):FC ==
      j' : MAT EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FC

    makeXList(n:Integer):List(Symbol) ==
      j:Integer
      y:Symbol := Y::Symbol
      p:List(Symbol) := []
      for j in 1 .. n repeat p:= cons(subscript(y,[j::OutputForm])$Symbol,p)
      p:= reverse(p)

    coerce(u:VEC FEXPR):$ == 
      dimension := #u::Polynomial Integer
      locals : SYMTAB := empty()
      declare!(PW,[real,[dimension,dimension],false]$FT,locals)$SYMTAB
      n:Integer := maxIndex(u)$VEC(FEXPR)
      p:List(Symbol) := makeXList(n)
      jac: MAT FEXPR := jacobian(u,p)$MultiVariableCalculusFunctions(_
                                     Symbol,FEXPR ,VEC FEXPR,List(Symbol))
      code : List FC := [localAssign(PW,jac),returns()$FC]$List(FC)
      ([locals,code]$RSFC)::$

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    coerce(u:$):O == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP33 Asp33}
\pagehead{Asp33}{ASP33}
\pagepic{ps/v103asp33.ps}{ASP33}{1.00}
<<domain ASP33 Asp33>>=
)abbrev domain ASP33 Asp33
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Nov 1993
++ Date Last Updated: 30 March 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory.
++ Description:
++\spadtype{Asp33} produces Fortran for Type 33 ASPs, needed for NAG routine 
++\axiomOpFrom{d02kef}{d02Package}.  The code is a dummy ASP:
++\begin{verbatim}
++      SUBROUTINE REPORT(X,V,JINT)
++      DOUBLE PRECISION V(3),X
++      INTEGER JINT
++      RETURN
++      END
++\end{verbatim}

Asp33(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  UFST   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))

  Exports ==> FortranProgramCategory with
     outputAsFortran:() -> Void
      ++outputAsFortran() generates the default code for \spadtype{ASP33}.


  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()
    declare!(JINT,fortranInteger(),syms)$SYMTAB
    declare!(X,fortranReal(),syms)$SYMTAB
    vType : FT := construct(real,["3"::Symbol],false)$FT
    declare!(V,vType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[X,V,JINT],syms)

    outputAsFortran():Void == 
      outputAsFortran( (returns()$FortranCode)::Rep )$Rep

    outputAsFortran(u):Void == outputAsFortran(u)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP34 Asp34}
\pagehead{Asp34}{ASP34}
\pagepic{ps/v103asp34.ps}{ASP34}{1.00}
<<domain ASP34 Asp34>>=
)abbrev domain ASP34 Asp34
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Nov 1993
++ Date Last Updated: 14 June 1994 (Themos Tsikas)
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp34} produces Fortran for Type 34 ASPs, needed for NAG routine 
++\axiomOpFrom{f04mbf}{f04Package}, for example:
++\begin{verbatim}
++      SUBROUTINE MSOLVE(IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK)
++      DOUBLE PRECISION RWORK(LRWORK),X(N),Y(N)
++      INTEGER I,J,N,LIWORK,IFLAG,LRWORK,IWORK(LIWORK)
++      DOUBLE PRECISION W1(3),W2(3),MS(3,3)
++      IFLAG=-1
++      MS(1,1)=2.0D0
++      MS(1,2)=1.0D0
++      MS(1,3)=0.0D0
++      MS(2,1)=1.0D0
++      MS(2,2)=2.0D0
++      MS(2,3)=1.0D0
++      MS(3,1)=0.0D0
++      MS(3,2)=1.0D0
++      MS(3,3)=2.0D0
++      CALL F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)
++      IFLAG=-IFLAG
++      RETURN
++      END
++\end{verbatim}

Asp34(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  UFST   ==> Union(fst:FST,void:"void")
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  EXI    ==> Expression Integer
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))

  Exports == FortranMatrixCategory 

  Implementation == add

    real : UFST := ["real"::FST]$UFST
    integer : UFST := ["integer"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(IFLAG,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(X,xType,syms)$SYMTAB
    declare!(Y,xType,syms)$SYMTAB
    declare!(LRWORK,fortranInteger(),syms)$SYMTAB
    declare!(LIWORK,fortranInteger(),syms)$SYMTAB
    rType : FT := construct(real,[LRWORK],false)$FT
    declare!(RWORK,rType,syms)$SYMTAB
    iType : FT := construct(integer,[LIWORK],false)$FT
    declare!(IWORK,iType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,
                          [IFLAG,N,X,Y,RWORK,LRWORK,IWORK,LIWORK],syms)

    -- To help the poor old compiler
    localAssign(s:Symbol,u:EXI):FC == assign(s,u)$FC

    coerce(u:Matrix MachineFloat):$ == 
      dimension := nrows(u) ::Polynomial Integer
      locals : SYMTAB := empty()$SYMTAB
      declare!(I,fortranInteger(),syms)$SYMTAB
      declare!(J,fortranInteger(),syms)$SYMTAB
      declare!(W1,[real,[dimension],false]$FT,locals)$SYMTAB
      declare!(W2,[real,[dimension],false]$FT,locals)$SYMTAB
      declare!(MS,[real,[dimension,dimension],false]$FT,locals)$SYMTAB
      assign1 : FC := localAssign(IFLAG@Symbol,(-1)@EXI)
      call : FC := call("F04ASF(MS,N,X,N,Y,W1,W2,IFLAG)")$FC
      assign2 : FC := localAssign(IFLAG::Symbol,-(IFLAG@Symbol::EXI))
      assign3 : FC := assign(MS,u)$FC
      code : List FC := [assign1,assign3,call,assign2,returns()]$List(FC)
      ([locals,code]$RSFC)::$

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP35 Asp35}
\pagehead{Asp35}{ASP35}
\pagepic{ps/v103asp35.ps}{ASP35}{1.00}
<<domain ASP35 Asp35>>=
)abbrev domain ASP35 Asp35
++ Author: Mike Dewar, Godfrey Nolan, Grant Keady
++ Date Created: Mar 1993
++ Date Last Updated: 22 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp35} produces Fortran for Type 35 ASPs, needed for NAG routines 
++\axiomOpFrom{c05pbf}{c05Package}, \axiomOpFrom{c05pcf}{c05Package}, for example:
++\begin{verbatim}
++      SUBROUTINE FCN(N,X,FVEC,FJAC,LDFJAC,IFLAG)
++      DOUBLE PRECISION X(N),FVEC(N),FJAC(LDFJAC,N)
++      INTEGER LDFJAC,N,IFLAG
++      IF(IFLAG.EQ.1)THEN
++        FVEC(1)=(-1.0D0*X(2))+X(1)
++        FVEC(2)=(-1.0D0*X(3))+2.0D0*X(2)
++        FVEC(3)=3.0D0*X(3)
++      ELSEIF(IFLAG.EQ.2)THEN
++        FJAC(1,1)=1.0D0
++        FJAC(1,2)=-1.0D0
++        FJAC(1,3)=0.0D0
++        FJAC(2,1)=0.0D0
++        FJAC(2,2)=2.0D0
++        FJAC(2,3)=-1.0D0
++        FJAC(3,1)=0.0D0
++        FJAC(3,2)=0.0D0
++        FJAC(3,3)=3.0D0
++      ENDIF
++      END
++\end{verbatim}

Asp35(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  UFST   ==> Union(fst:FST,void:"void")
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  MAT    ==> Matrix
  VF2    ==> VectorFunctions2
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression([],['X],MFLOAT)
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR,
                    EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,MAT EXPR MFLOAT)
  SWU    ==> Union(I:Expression Integer,F:Expression Float,
                   CF:Expression Complex Float,switch:Switch)

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(X,xType,syms)$SYMTAB
    declare!(FVEC,xType,syms)$SYMTAB
    declare!(LDFJAC,fortranInteger(),syms)$SYMTAB
    jType : FT := construct(real,[LDFJAC,N],false)$FT
    declare!(FJAC,jType,syms)$SYMTAB
    declare!(IFLAG,fortranInteger(),syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[N,X,FVEC,FJAC,LDFJAC,IFLAG],syms)

    coerce(u:$):OutputForm == coerce(u)$Rep

    makeXList(n:Integer):List(Symbol) ==
      x:Symbol := X::Symbol
      [subscript(x,[j::OutputForm])$Symbol for j in 1..n]

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign1(s:Symbol,j:MAT FEXPR):FC ==
      j' : MAT EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FC

    localAssign2(s:Symbol,j:VEC FEXPR):FC ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FC

    coerce(u:VEC FEXPR):$ ==
      n:Integer := maxIndex(u)
      p:List(Symbol) := makeXList(n)
      jac: MAT FEXPR := jacobian(u,p)$MultiVariableCalculusFunctions(_
                                         Symbol,FEXPR,VEC FEXPR,List(Symbol))
      assf:FC := localAssign2(FVEC,u)
      assj:FC := localAssign1(FJAC,jac)
      iflag:SWU := [IFLAG@Symbol::EXPR(INT)]$SWU
      sw1:Switch := EQ(iflag,[1::EXPR(INT)]$SWU)
      sw2:Switch := EQ(iflag,[2::EXPR(INT)]$SWU)
      cond(sw1,assf,cond(sw2,assj)$FC)$FC::$

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP4 Asp4}
\pagehead{Asp4}{ASP4}
\pagepic{ps/v103asp4.ps}{ASP4}{1.00}
<<domain ASP4 Asp4>>=
)abbrev domain ASP4 Asp4
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp4} produces Fortran for Type 4 ASPs, which take an expression
++in X(1) .. X(NDIM) and produce a real function of the form:
++\begin{verbatim}
++      DOUBLE PRECISION FUNCTION FUNCTN(NDIM,X)
++      DOUBLE PRECISION X(NDIM)
++      INTEGER NDIM
++      FUNCTN=(4.0D0*X(1)*X(3)**2*DEXP(2.0D0*X(1)*X(3)))/(X(4)**2+(2.0D0*
++     &X(2)+2.0D0)*X(4)+X(2)**2+2.0D0*X(2)+1.0D0)
++      RETURN
++      END
++\end{verbatim}

Asp4(name): Exports == Implementation where
  name : Symbol

  FEXPR  ==> FortranExpression([],['X],MachineFloat)
  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FSTU   ==> Union(fst:FST,void:"void")
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float

  Exports ==> FortranFunctionCategory with
    coerce : FEXPR -> $
      ++coerce(f) takes an object from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns it into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(NDIM,fortranInteger(),syms)$SYMTAB
    xType : FT := construct(real,[NDIM],false)$FT
    declare!(X,xType,syms)$SYMTAB
    Rep := FortranProgram(name,real,[NDIM,X],syms)

    retract(u:FRAC POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    retract(u:FRAC POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    retract(u:EXPR FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    retract(u:EXPR INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    retract(u:POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    retract(u:POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed") 
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      foo::FEXPR::$

    coerce(u:FEXPR):$ ==
      coerce((u::Expression(MachineFloat))$FEXPR)$Rep

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP41 Asp41}
\pagehead{Asp41}{ASP41}
\pagepic{ps/v103asp41.ps}{ASP41}{1.00}
<<domain ASP41 Asp41>>=
)abbrev domain ASP41 Asp41
++ Author: Mike Dewar, Godfrey Nolan
++ Date Created: 
++ Date Last Updated: 29 March 1994
++                     6 October 1994
++ Related Constructors: FortranFunctionCategory, FortranProgramCategory.
++ Description:
++\spadtype{Asp41} produces Fortran for Type 41 ASPs, needed for NAG
++routines \axiomOpFrom{d02raf}{d02Package} and \axiomOpFrom{d02saf}{d02Package}
++in particular.  These ASPs are in fact 
++three Fortran routines which return a vector of functions, and their
++derivatives wrt Y(i) and also a continuation parameter EPS, for example:
++\begin{verbatim}
++      SUBROUTINE FCN(X,EPS,Y,F,N)
++      DOUBLE PRECISION EPS,F(N),X,Y(N)
++      INTEGER N
++      F(1)=Y(2)
++      F(2)=Y(3)
++      F(3)=(-1.0D0*Y(1)*Y(3))+2.0D0*EPS*Y(2)**2+(-2.0D0*EPS)
++      RETURN
++      END
++      SUBROUTINE JACOBF(X,EPS,Y,F,N)
++      DOUBLE PRECISION EPS,F(N,N),X,Y(N)
++      INTEGER N
++      F(1,1)=0.0D0
++      F(1,2)=1.0D0
++      F(1,3)=0.0D0
++      F(2,1)=0.0D0
++      F(2,2)=0.0D0
++      F(2,3)=1.0D0
++      F(3,1)=-1.0D0*Y(3)
++      F(3,2)=4.0D0*EPS*Y(2)
++      F(3,3)=-1.0D0*Y(1)
++      RETURN
++      END
++      SUBROUTINE JACEPS(X,EPS,Y,F,N)
++      DOUBLE PRECISION EPS,F(N),X,Y(N)
++      INTEGER N
++      F(1)=0.0D0
++      F(2)=0.0D0
++      F(3)=2.0D0*Y(2)**2-2.0D0
++      RETURN
++      END
++\end{verbatim}

Asp41(nameOne,nameTwo,nameThree): Exports == Implementation where
  nameOne : Symbol
  nameTwo : Symbol
  nameThree : Symbol

  D      ==> differentiate
  FST    ==> FortranScalarType
  UFST   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X,'EPS],['Y],MFLOAT)
  S      ==> Symbol
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,Matrix FEXPR,
                 EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,Matrix EXPR MFLOAT)

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add
    real : UFST := ["real"::FST]$UFST

    symOne : SYMTAB := empty()$SYMTAB
    declare!(N,fortranInteger(),symOne)$SYMTAB
    declare!(X,fortranReal(),symOne)$SYMTAB
    declare!(EPS,fortranReal(),symOne)$SYMTAB
    yType : FT := construct(real,[N],false)$FT
    declare!(Y,yType,symOne)$SYMTAB
    declare!(F,yType,symOne)$SYMTAB

    symTwo : SYMTAB := empty()$SYMTAB
    declare!(N,fortranInteger(),symTwo)$SYMTAB
    declare!(X,fortranReal(),symTwo)$SYMTAB
    declare!(EPS,fortranReal(),symTwo)$SYMTAB
    declare!(Y,yType,symTwo)$SYMTAB
    fType : FT := construct(real,[N,N],false)$FT
    declare!(F,fType,symTwo)$SYMTAB

    symThree : SYMTAB := empty()$SYMTAB
    declare!(N,fortranInteger(),symThree)$SYMTAB
    declare!(X,fortranReal(),symThree)$SYMTAB
    declare!(EPS,fortranReal(),symThree)$SYMTAB
    declare!(Y,yType,symThree)$SYMTAB
    declare!(F,yType,symThree)$SYMTAB

    R1:=FortranProgram(nameOne,["void"]$UFST,[X,EPS,Y,F,N],symOne)
    R2:=FortranProgram(nameTwo,["void"]$UFST,[X,EPS,Y,F,N],symTwo)
    R3:=FortranProgram(nameThree,["void"]$UFST,[X,EPS,Y,F,N],symThree)
    Rep := Record(f:R1,fJacob:R2,eJacob:R3)
    Fsym:Symbol:=coerce "F"

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign1(s:S,j:Matrix FEXPR):FC ==
      j' : Matrix EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FC

    localAssign2(s:S,j:VEC FEXPR):FC ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FC

    makeCodeOne(u:VEC FEXPR):FortranCode ==
      -- simple assign
      localAssign2(Fsym,u)

    makeCodeThree(u:VEC FEXPR):FortranCode ==
      -- compute jacobian wrt to eps
      jacEps:VEC FEXPR := [D(v,EPS) for v in entries(u)]$VEC(FEXPR)
      makeCodeOne(jacEps)

    makeYList(n:Integer):List(Symbol) ==
      j:Integer
      y:Symbol := Y::Symbol
      p:List(Symbol) := []
      [subscript(y,[j::OutputForm])$Symbol for j in 1..n]

    makeCodeTwo(u:VEC FEXPR):FortranCode ==
      -- compute jacobian wrt to f
      n:Integer := maxIndex(u)$VEC(FEXPR)
      p:List(Symbol) := makeYList(n)
      jac:Matrix(FEXPR) := _
      jacobian(u,p)$MultiVariableCalculusFunctions(S,FEXPR,VEC FEXPR,List(S))
      localAssign1(Fsym,jac)

    coerce(u:VEC FEXPR):$ == 
      aF:FortranCode := makeCodeOne(u)
      bF:FortranCode := makeCodeTwo(u)
      cF:FortranCode := makeCodeThree(u)
      -- add returns() to complete subroutines
      aLF:List(FortranCode) := [aF,returns()$FortranCode]$List(FortranCode)
      bLF:List(FortranCode) := [bF,returns()$FortranCode]$List(FortranCode)
      cLF:List(FortranCode) := [cF,returns()$FortranCode]$List(FortranCode)
      [coerce(aLF)$R1,coerce(bLF)$R2,coerce(cLF)$R3]

    coerce(u:$):OutputForm == 
      bracket commaSeparate 
        [nameOne::OutputForm,nameTwo::OutputForm,nameThree::OutputForm]

    outputAsFortran(u:$):Void ==  
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran elt(u,f)$Rep
      outputAsFortran elt(u,fJacob)$Rep
      outputAsFortran elt(u,eJacob)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP42 Asp42}
\pagehead{Asp42}{ASP42}
\pagepic{ps/v103asp42.ps}{ASP42}{1.00}
<<domain ASP42 Asp42>>=
)abbrev domain ASP42 Asp42
++ Author: Mike Dewar, Godfrey Nolan
++ Date Created:
++ Date Last Updated: 29 March 1994
++                     6 October 1994
++ Related Constructors: FortranFunctionCategory, FortranProgramCategory.
++ Description:
++\spadtype{Asp42} produces Fortran for Type 42 ASPs, needed for NAG
++routines \axiomOpFrom{d02raf}{d02Package} and \axiomOpFrom{d02saf}{d02Package}
++in particular.  These ASPs are in fact
++three Fortran routines which return a vector of functions, and their
++derivatives wrt Y(i) and also a continuation parameter EPS, for example:
++\begin{verbatim}
++      SUBROUTINE G(EPS,YA,YB,BC,N)
++      DOUBLE PRECISION EPS,YA(N),YB(N),BC(N)
++      INTEGER N
++      BC(1)=YA(1)
++      BC(2)=YA(2)
++      BC(3)=YB(2)-1.0D0
++      RETURN
++      END
++      SUBROUTINE JACOBG(EPS,YA,YB,AJ,BJ,N)
++      DOUBLE PRECISION EPS,YA(N),AJ(N,N),BJ(N,N),YB(N)
++      INTEGER N
++      AJ(1,1)=1.0D0
++      AJ(1,2)=0.0D0
++      AJ(1,3)=0.0D0
++      AJ(2,1)=0.0D0
++      AJ(2,2)=1.0D0
++      AJ(2,3)=0.0D0
++      AJ(3,1)=0.0D0
++      AJ(3,2)=0.0D0
++      AJ(3,3)=0.0D0
++      BJ(1,1)=0.0D0
++      BJ(1,2)=0.0D0
++      BJ(1,3)=0.0D0
++      BJ(2,1)=0.0D0
++      BJ(2,2)=0.0D0
++      BJ(2,3)=0.0D0
++      BJ(3,1)=0.0D0
++      BJ(3,2)=1.0D0
++      BJ(3,3)=0.0D0
++      RETURN
++      END
++      SUBROUTINE JACGEP(EPS,YA,YB,BCEP,N)
++      DOUBLE PRECISION EPS,YA(N),YB(N),BCEP(N)
++      INTEGER N
++      BCEP(1)=0.0D0
++      BCEP(2)=0.0D0
++      BCEP(3)=0.0D0
++      RETURN
++      END
++\end{verbatim}

Asp42(nameOne,nameTwo,nameThree): Exports == Implementation where
  nameOne : Symbol
  nameTwo : Symbol
  nameThree : Symbol

  D      ==> differentiate
  FST    ==> FortranScalarType
  FT     ==> FortranType
  FP     ==> FortranProgram
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  NNI    ==> NonNegativeInteger
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  UFST   ==> Union(fst:FST,void:"void")
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['EPS],['YA,'YB],MFLOAT)
  S      ==> Symbol
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,Matrix FEXPR,
                 EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,Matrix EXPR MFLOAT)

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add
    real : UFST := ["real"::FST]$UFST

    symOne : SYMTAB := empty()$SYMTAB
    declare!(EPS,fortranReal(),symOne)$SYMTAB
    declare!(N,fortranInteger(),symOne)$SYMTAB
    yType : FT := construct(real,[N],false)$FT
    declare!(YA,yType,symOne)$SYMTAB
    declare!(YB,yType,symOne)$SYMTAB
    declare!(BC,yType,symOne)$SYMTAB

    symTwo : SYMTAB := empty()$SYMTAB
    declare!(EPS,fortranReal(),symTwo)$SYMTAB
    declare!(N,fortranInteger(),symTwo)$SYMTAB
    declare!(YA,yType,symTwo)$SYMTAB
    declare!(YB,yType,symTwo)$SYMTAB
    ajType : FT := construct(real,[N,N],false)$FT
    declare!(AJ,ajType,symTwo)$SYMTAB
    declare!(BJ,ajType,symTwo)$SYMTAB

    symThree : SYMTAB := empty()$SYMTAB
    declare!(EPS,fortranReal(),symThree)$SYMTAB
    declare!(N,fortranInteger(),symThree)$SYMTAB
    declare!(YA,yType,symThree)$SYMTAB
    declare!(YB,yType,symThree)$SYMTAB
    declare!(BCEP,yType,symThree)$SYMTAB

    rt := ["void"]$UFST
    R1:=FortranProgram(nameOne,rt,[EPS,YA,YB,BC,N],symOne)
    R2:=FortranProgram(nameTwo,rt,[EPS,YA,YB,AJ,BJ,N],symTwo)
    R3:=FortranProgram(nameThree,rt,[EPS,YA,YB,BCEP,N],symThree)
    Rep := Record(g:R1,gJacob:R2,geJacob:R3)
    BCsym:Symbol:=coerce "BC"
    AJsym:Symbol:=coerce "AJ"
    BJsym:Symbol:=coerce "BJ"
    BCEPsym:Symbol:=coerce "BCEP"

    makeList(n:Integer,s:Symbol):List(Symbol) ==
      j:Integer
      p:List(Symbol) := []
      for j in 1 .. n repeat p:= cons(subscript(s,[j::OutputForm])$Symbol,p)
      reverse(p)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign1(s:S,j:Matrix FEXPR):FC ==
      j' : Matrix EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FC

    localAssign2(s:S,j:VEC FEXPR):FC ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FC

    makeCodeOne(u:VEC FEXPR):FortranCode ==
      -- simple assign
      localAssign2(BCsym,u)

    makeCodeTwo(u:VEC FEXPR):List(FortranCode) ==
      -- compute jacobian wrt to ya
      n:Integer := maxIndex(u)
      p:List(Symbol) := makeList(n,YA::Symbol)
      jacYA:Matrix(FEXPR) := _
        jacobian(u,p)$MultiVariableCalculusFunctions(S,FEXPR,VEC FEXPR,List(S))
      -- compute jacobian wrt to yb
      p:List(Symbol) := makeList(n,YB::Symbol)
      jacYB: Matrix(FEXPR) := _
        jacobian(u,p)$MultiVariableCalculusFunctions(S,FEXPR,VEC FEXPR,List(S))
      -- assign jacobians to AJ & BJ
      [localAssign1(AJsym,jacYA),localAssign1(BJsym,jacYB),returns()$FC]$List(FC)

    makeCodeThree(u:VEC FEXPR):FortranCode ==
      -- compute jacobian wrt to eps
      jacEps:VEC FEXPR := [D(v,EPS) for v in entries u]$VEC(FEXPR)
      localAssign2(BCEPsym,jacEps)

    coerce(u:VEC FEXPR):$ == 
      aF:FortranCode := makeCodeOne(u)
      bF:List(FortranCode) := makeCodeTwo(u)
      cF:FortranCode := makeCodeThree(u)
      -- add returns() to complete subroutines
      aLF:List(FortranCode) := [aF,returns()$FC]$List(FortranCode)
      cLF:List(FortranCode) := [cF,returns()$FC]$List(FortranCode)
      [coerce(aLF)$R1,coerce(bF)$R2,coerce(cLF)$R3]

    coerce(u:$) : OutputForm ==
      bracket commaSeparate 
        [nameOne::OutputForm,nameTwo::OutputForm,nameThree::OutputForm]

    outputAsFortran(u:$):Void ==  
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran elt(u,g)$Rep
      outputAsFortran elt(u,gJacob)$Rep
      outputAsFortran elt(u,geJacob)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP49 Asp49}
\pagehead{Asp49}{ASP49}
\pagepic{ps/v103asp49.ps}{ASP49}{1.00}
<<domain ASP49 Asp49>>=
)abbrev domain ASP49 Asp49
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 23 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp49} produces Fortran for Type 49 ASPs, needed for NAG routines
++\axiomOpFrom{e04dgf}{e04Package}, \axiomOpFrom{e04ucf}{e04Package}, for example:
++\begin{verbatim}
++      SUBROUTINE OBJFUN(MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER)
++      DOUBLE PRECISION X(N),OBJF,OBJGRD(N),USER(*)
++      INTEGER N,IUSER(*),MODE,NSTATE
++      OBJF=X(4)*X(9)+((-1.0D0*X(5))+X(3))*X(8)+((-1.0D0*X(3))+X(1))*X(7)
++     &+(-1.0D0*X(2)*X(6))
++      OBJGRD(1)=X(7)
++      OBJGRD(2)=-1.0D0*X(6)
++      OBJGRD(3)=X(8)+(-1.0D0*X(7))
++      OBJGRD(4)=X(9)
++      OBJGRD(5)=-1.0D0*X(8)
++      OBJGRD(6)=-1.0D0*X(2)
++      OBJGRD(7)=(-1.0D0*X(3))+X(1)
++      OBJGRD(8)=(-1.0D0*X(5))+X(3)
++      OBJGRD(9)=X(4)
++      RETURN
++      END
++\end{verbatim}

Asp49(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  UFST   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FC))
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression([],['X],MFLOAT)
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  S      ==> Symbol

  Exports ==> FortranFunctionCategory with
    coerce : FEXPR -> $
      ++coerce(f) takes an object from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns it into an ASP.

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    integer : UFST := ["integer"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(MODE,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    xType : FT := construct(real,[N::S],false)$FT
    declare!(X,xType,syms)$SYMTAB
    declare!(OBJF,fortranReal(),syms)$SYMTAB
    declare!(OBJGRD,xType,syms)$SYMTAB
    declare!(NSTATE,fortranInteger(),syms)$SYMTAB
    iuType : FT := construct(integer,["*"::S],false)$FT
    declare!(IUSER,iuType,syms)$SYMTAB
    uType : FT := construct(real,["*"::S],false)$FT
    declare!(USER,uType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,
                          [MODE,N,X,OBJF,OBJGRD,NSTATE,IUSER,USER],syms)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign(s:S,j:VEC FEXPR):FC ==
      j' : VEC EXPR MFLOAT := map(fexpr2expr,j)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,j')$FC

    coerce(u:FEXPR):$ ==
      vars:List(S) := variables(u)
      grd:VEC FEXPR := gradient(u,vars)$MultiVariableCalculusFunctions(_
                                           S,FEXPR,VEC FEXPR,List(S))
      code : List(FC) := [assign(OBJF@S,fexpr2expr u)$FC,_
                          localAssign(OBJGRD@S,grd),_
                          returns()$FC]
      code::$

    coerce(u:$):OutputForm == coerce(u)$Rep

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:FRAC POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:FRAC POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP50 Asp50}
\pagehead{Asp50}{ASP50}
\pagepic{ps/v103asp50.ps}{ASP50}{1.00}
<<domain ASP50 Asp50>>=
)abbrev domain ASP50 Asp50
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 23 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp50} produces Fortran for Type 50 ASPs, needed for NAG routine 
++\axiomOpFrom{e04fdf}{e04Package}, for example:
++\begin{verbatim}
++      SUBROUTINE LSFUN1(M,N,XC,FVECC)
++      DOUBLE PRECISION FVECC(M),XC(N)
++      INTEGER I,M,N
++      FVECC(1)=((XC(1)-2.4D0)*XC(3)+(15.0D0*XC(1)-36.0D0)*XC(2)+1.0D0)/(
++     &XC(3)+15.0D0*XC(2))
++      FVECC(2)=((XC(1)-2.8D0)*XC(3)+(7.0D0*XC(1)-19.6D0)*XC(2)+1.0D0)/(X
++     &C(3)+7.0D0*XC(2))
++      FVECC(3)=((XC(1)-3.2D0)*XC(3)+(4.333333333333333D0*XC(1)-13.866666
++     &66666667D0)*XC(2)+1.0D0)/(XC(3)+4.333333333333333D0*XC(2))
++      FVECC(4)=((XC(1)-3.5D0)*XC(3)+(3.0D0*XC(1)-10.5D0)*XC(2)+1.0D0)/(X
++     &C(3)+3.0D0*XC(2))
++      FVECC(5)=((XC(1)-3.9D0)*XC(3)+(2.2D0*XC(1)-8.579999999999998D0)*XC
++     &(2)+1.0D0)/(XC(3)+2.2D0*XC(2))
++      FVECC(6)=((XC(1)-4.199999999999999D0)*XC(3)+(1.666666666666667D0*X
++     &C(1)-7.0D0)*XC(2)+1.0D0)/(XC(3)+1.666666666666667D0*XC(2))
++      FVECC(7)=((XC(1)-4.5D0)*XC(3)+(1.285714285714286D0*XC(1)-5.7857142
++     &85714286D0)*XC(2)+1.0D0)/(XC(3)+1.285714285714286D0*XC(2))
++      FVECC(8)=((XC(1)-4.899999999999999D0)*XC(3)+(XC(1)-4.8999999999999
++     &99D0)*XC(2)+1.0D0)/(XC(3)+XC(2))
++      FVECC(9)=((XC(1)-4.699999999999999D0)*XC(3)+(XC(1)-4.6999999999999
++     &99D0)*XC(2)+1.285714285714286D0)/(XC(3)+XC(2))
++      FVECC(10)=((XC(1)-6.8D0)*XC(3)+(XC(1)-6.8D0)*XC(2)+1.6666666666666
++     &67D0)/(XC(3)+XC(2))
++      FVECC(11)=((XC(1)-8.299999999999999D0)*XC(3)+(XC(1)-8.299999999999
++     &999D0)*XC(2)+2.2D0)/(XC(3)+XC(2))
++      FVECC(12)=((XC(1)-10.6D0)*XC(3)+(XC(1)-10.6D0)*XC(2)+3.0D0)/(XC(3)
++     &+XC(2))
++      FVECC(13)=((XC(1)-1.34D0)*XC(3)+(XC(1)-1.34D0)*XC(2)+4.33333333333
++     &3333D0)/(XC(3)+XC(2))
++      FVECC(14)=((XC(1)-2.1D0)*XC(3)+(XC(1)-2.1D0)*XC(2)+7.0D0)/(XC(3)+X
++     &C(2))
++      FVECC(15)=((XC(1)-4.39D0)*XC(3)+(XC(1)-4.39D0)*XC(2)+15.0D0)/(XC(3
++     &)+XC(2))
++      END
++\end{verbatim}

Asp50(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  UFST   ==> Union(fst:FST,void:"void")
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  FEXPR  ==> FortranExpression([],['XC],MFLOAT)
  MFLOAT ==> MachineFloat

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(M,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    xcType : FT := construct(real,[N],false)$FT
    declare!(XC,xcType,syms)$SYMTAB
    fveccType : FT := construct(real,[M],false)$FT
    declare!(FVECC,fveccType,syms)$SYMTAB
    declare!(I,fortranInteger(),syms)$SYMTAB
    tType : FT := construct(real,[M,N],false)$FT
--    declare!(TC,tType,syms)$SYMTAB
--    declare!(Y,fveccType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST, [M,N,XC,FVECC],syms)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    coerce(u:VEC FEXPR):$ ==
      u' : VEC EXPR MFLOAT := map(fexpr2expr,u)$VF2(FEXPR,EXPR MFLOAT)
      assign(FVECC,u')$FortranCode::$

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP55 Asp55}
\pagehead{Asp55}{ASP55}
\pagepic{ps/v103asp55.ps}{ASP55}{1.00}
<<domain ASP55 Asp55>>=
)abbrev domain ASP55 Asp55
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: June 1993
++ Date Last Updated: 23 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp55} produces Fortran for Type 55 ASPs, needed for NAG routines 
++\axiomOpFrom{e04dgf}{e04Package} and \axiomOpFrom{e04ucf}{e04Package}, for example:
++\begin{verbatim}
++      SUBROUTINE CONFUN(MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER
++     &,USER)
++      DOUBLE PRECISION C(NCNLN),X(N),CJAC(NROWJ,N),USER(*)
++      INTEGER N,IUSER(*),NEEDC(NCNLN),NROWJ,MODE,NCNLN,NSTATE
++      IF(NEEDC(1).GT.0)THEN
++        C(1)=X(6)**2+X(1)**2
++        CJAC(1,1)=2.0D0*X(1)
++        CJAC(1,2)=0.0D0
++        CJAC(1,3)=0.0D0
++        CJAC(1,4)=0.0D0
++        CJAC(1,5)=0.0D0
++        CJAC(1,6)=2.0D0*X(6)
++      ENDIF
++      IF(NEEDC(2).GT.0)THEN
++        C(2)=X(2)**2+(-2.0D0*X(1)*X(2))+X(1)**2
++        CJAC(2,1)=(-2.0D0*X(2))+2.0D0*X(1)
++        CJAC(2,2)=2.0D0*X(2)+(-2.0D0*X(1))
++        CJAC(2,3)=0.0D0
++        CJAC(2,4)=0.0D0
++        CJAC(2,5)=0.0D0
++        CJAC(2,6)=0.0D0
++      ENDIF
++      IF(NEEDC(3).GT.0)THEN
++        C(3)=X(3)**2+(-2.0D0*X(1)*X(3))+X(2)**2+X(1)**2
++        CJAC(3,1)=(-2.0D0*X(3))+2.0D0*X(1)
++        CJAC(3,2)=2.0D0*X(2)
++        CJAC(3,3)=2.0D0*X(3)+(-2.0D0*X(1))
++        CJAC(3,4)=0.0D0
++        CJAC(3,5)=0.0D0
++        CJAC(3,6)=0.0D0
++      ENDIF
++      RETURN
++      END
++\end{verbatim}

Asp55(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  FSTU   ==> Union(fst:FST,void:"void")
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  S      ==> Symbol
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  MAT    ==> Matrix
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression([],['X],MFLOAT)
  MF2    ==> MatrixCategoryFunctions2(FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR,
                    EXPR MFLOAT,VEC EXPR MFLOAT,VEC EXPR MFLOAT,MAT EXPR MFLOAT)
  SWU    ==> Union(I:Expression Integer,F:Expression Float,
                   CF:Expression Complex Float,switch:Switch)

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    integer : FSTU := ["integer"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(MODE,fortranInteger(),syms)$SYMTAB
    declare!(NCNLN,fortranInteger(),syms)$SYMTAB
    declare!(N,fortranInteger(),syms)$SYMTAB
    declare!(NROWJ,fortranInteger(),syms)$SYMTAB
    needcType : FT := construct(integer,[NCNLN::Symbol],false)$FT
    declare!(NEEDC,needcType,syms)$SYMTAB
    xType : FT := construct(real,[N::Symbol],false)$FT
    declare!(X,xType,syms)$SYMTAB
    cType : FT := construct(real,[NCNLN::Symbol],false)$FT
    declare!(C,cType,syms)$SYMTAB
    cjacType : FT := construct(real,[NROWJ::Symbol,N::Symbol],false)$FT
    declare!(CJAC,cjacType,syms)$SYMTAB
    declare!(NSTATE,fortranInteger(),syms)$SYMTAB
    iuType : FT := construct(integer,["*"::Symbol],false)$FT
    declare!(IUSER,iuType,syms)$SYMTAB
    uType : FT := construct(real,["*"::Symbol],false)$FT
    declare!(USER,uType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,
                    [MODE,NCNLN,N,NROWJ,NEEDC,X,C,CJAC,NSTATE,IUSER,USER],syms)

    -- Take a symbol, pull of the script and turn it into an integer!!
    o2int(u:S):Integer ==
      o : OutputForm := first elt(scripts(u)$S,sub)
      o pretend Integer

    localAssign(s:Symbol,dim:List POLY INT,u:FEXPR):FC ==
      assign(s,dim,(u::EXPR MFLOAT)$FEXPR)$FC

    makeCond(index:INT,fun:FEXPR,jac:VEC FEXPR):FC ==
      needc : EXPR INT := (subscript(NEEDC,[index::OutputForm])$S)::EXPR(INT)
      sw : Switch := GT([needc]$SWU,[0::EXPR(INT)]$SWU)$Switch
      ass : List FC := [localAssign(CJAC,[index::POLY INT,i::POLY INT],jac.i)_
                                                    for i in 1..maxIndex(jac)]
      cond(sw,block([localAssign(C,[index::POLY INT],fun),:ass])$FC)$FC
      
    coerce(u:VEC FEXPR):$ ==
      ncnln:Integer := maxIndex(u)
      x:S := X::S
      pu:List(S) := []
      -- Work out which variables appear in the expressions
      for e in entries(u) repeat
        pu := setUnion(pu,variables(e)$FEXPR)
      scriptList : List Integer := map(o2int,pu)$ListFunctions2(S,Integer)
      -- This should be the maximum X_n which occurs (there may be others
      -- which don't):
      n:Integer := reduce(max,scriptList)$List(Integer)
      p:List(S) := []
      for j in 1..n repeat p:= cons(subscript(x,[j::OutputForm])$S,p)
      p:= reverse(p)
      jac:MAT FEXPR := _
         jacobian(u,p)$MultiVariableCalculusFunctions(S,FEXPR,VEC FEXPR,List(S))
      code : List FC := [makeCond(j,u.j,row(jac,j)) for j in 1..ncnln]
      [:code,returns()$FC]::$

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP6 Asp6}
\pagehead{Asp6}{ASP6}
\pagepic{ps/v103asp6.ps}{ASP6}{1.00}
<<domain ASP6 Asp6>>=
)abbrev domain ASP6 Asp6
++ Author: Mike Dewar and Godfrey Nolan and Grant Keady
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++ \spadtype{Asp6} produces Fortran for Type 6 ASPs, needed for NAG routines
++ \axiomOpFrom{c05nbf}{c05Package}, \axiomOpFrom{c05ncf}{c05Package}.
++ These represent vectors of functions of X(i) and look like:
++ \begin{verbatim}
++      SUBROUTINE FCN(N,X,FVEC,IFLAG)
++      DOUBLE PRECISION X(N),FVEC(N)
++      INTEGER N,IFLAG
++      FVEC(1)=(-2.0D0*X(2))+(-2.0D0*X(1)**2)+3.0D0*X(1)+1.0D0
++      FVEC(2)=(-2.0D0*X(3))+(-2.0D0*X(2)**2)+3.0D0*X(2)+(-1.0D0*X(1))+1.
++     &0D0
++      FVEC(3)=(-2.0D0*X(4))+(-2.0D0*X(3)**2)+3.0D0*X(3)+(-1.0D0*X(2))+1.
++     &0D0
++      FVEC(4)=(-2.0D0*X(5))+(-2.0D0*X(4)**2)+3.0D0*X(4)+(-1.0D0*X(3))+1.
++     &0D0
++      FVEC(5)=(-2.0D0*X(6))+(-2.0D0*X(5)**2)+3.0D0*X(5)+(-1.0D0*X(4))+1.
++     &0D0
++      FVEC(6)=(-2.0D0*X(7))+(-2.0D0*X(6)**2)+3.0D0*X(6)+(-1.0D0*X(5))+1.
++     &0D0
++      FVEC(7)=(-2.0D0*X(8))+(-2.0D0*X(7)**2)+3.0D0*X(7)+(-1.0D0*X(6))+1.
++     &0D0
++      FVEC(8)=(-2.0D0*X(9))+(-2.0D0*X(8)**2)+3.0D0*X(8)+(-1.0D0*X(7))+1.
++     &0D0
++      FVEC(9)=(-2.0D0*X(9)**2)+3.0D0*X(9)+(-1.0D0*X(8))+1.0D0
++      RETURN
++      END
++ \end{verbatim}

Asp6(name): Exports == Implementation where
  name : Symbol

  FEXPR  ==> FortranExpression([],['X],MFLOAT)
  MFLOAT ==> MachineFloat
  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  UFST   ==> Union(fst:FST,void:"void")
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2

  Exports == FortranVectorFunctionCategory with
    coerce: Vector FEXPR -> %
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation == add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(N,fortranInteger()$FT,syms)$SYMTAB
    xType : FT := construct(real,[N],false)$FT
    declare!(X,xType,syms)$SYMTAB
    declare!(FVEC,xType,syms)$SYMTAB
    declare!(IFLAG,fortranInteger()$FT,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$Union(fst:FST,void:"void"),
                          [N,X,FVEC,IFLAG],syms)

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VectorFunctions2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VectorFunctions2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VectorFunctions2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VectorFunctions2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VectorFunctions2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    fexpr2expr(u:FEXPR):EXPR MFLOAT ==
      (u::EXPR MFLOAT)$FEXPR

    coerce(u:VEC FEXPR):% ==
      v : VEC EXPR MFLOAT
      v := map(fexpr2expr,u)$VF2(FEXPR,EXPR MFLOAT)
      ([assign(FVEC,v)$FortranCode,returns()$FortranCode]$List(FortranCode))::$

    coerce(c:List FortranCode):% == coerce(c)$Rep

    coerce(r:RSFC):% == coerce(r)$Rep

    coerce(c:FortranCode):% == coerce(c)$Rep

    coerce(u:%):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP7 Asp7}
\pagehead{Asp7}{ASP7}
\pagepic{ps/v103asp7.ps}{ASP7}{1.00}
<<domain ASP7 Asp7>>=
)abbrev domain ASP7 Asp7
++ Author: Mike Dewar and Godfrey Nolan and Grant Keady
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++ \spadtype{Asp7} produces Fortran for Type 7 ASPs, needed for NAG routines
++ \axiomOpFrom{d02bbf}{d02Package}, \axiomOpFrom{d02gaf}{d02Package}.
++ These represent a vector of functions of the scalar X and
++ the array Z, and look like:
++ \begin{verbatim}
++      SUBROUTINE FCN(X,Z,F)
++      DOUBLE PRECISION F(*),X,Z(*)
++      F(1)=DTAN(Z(3))
++      F(2)=((-0.03199999999999999D0*DCOS(Z(3))*DTAN(Z(3)))+(-0.02D0*Z(2)
++     &**2))/(Z(2)*DCOS(Z(3)))
++      F(3)=-0.03199999999999999D0/(X*Z(2)**2)
++      RETURN
++      END
++ \end{verbatim}

Asp7(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X],['Y],MFLOAT)
  UFST   ==> Union(fst:FST,void:"void")
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2

  Exports ==> FortranVectorFunctionCategory with
    coerce : Vector FEXPR -> %
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal(),syms)$SYMTAB
    yType : FT := construct(real,["*"::Symbol],false)$FT
    declare!(Y,yType,syms)$SYMTAB
    declare!(F,yType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[X,Y,F],syms)

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    fexpr2expr(u:FEXPR):EXPR MFLOAT ==
      (u::EXPR MFLOAT)$FEXPR

    coerce(u:Vector FEXPR ):% ==
      v : Vector EXPR MFLOAT
      v:=map(fexpr2expr,u)$VF2(FEXPR,EXPR MFLOAT)
      ([assign(F,v)$FortranCode,returns()$FortranCode]$List(FortranCode))::%

    coerce(c:List FortranCode):% == coerce(c)$Rep

    coerce(r:RSFC):% == coerce(r)$Rep

    coerce(c:FortranCode):% == coerce(c)$Rep

    coerce(u:%):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP73 Asp73}
\pagehead{Asp73}{ASP73}
\pagepic{ps/v103asp73.ps}{ASP73}{1.00}
<<domain ASP73 Asp73>>=
)abbrev domain ASP73 Asp73
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 30 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp73} produces Fortran for Type 73 ASPs, needed for NAG routine
++\axiomOpFrom{d03eef}{d03Package}, for example:
++\begin{verbatim}
++      SUBROUTINE PDEF(X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI)
++      DOUBLE PRECISION ALPHA,EPSOLN,PHI,X,Y,BETA,DELTA,GAMMA,PSI
++      ALPHA=DSIN(X)
++      BETA=Y
++      GAMMA=X*Y
++      DELTA=DCOS(X)*DSIN(Y)
++      EPSOLN=Y+X
++      PHI=X
++      PSI=Y
++      RETURN
++      END
++\end{verbatim}

Asp73(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FSTU   ==> Union(fst:FST,void:"void")
  FEXPR  ==> FortranExpression(['X,'Y],[],MachineFloat)
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal(),syms) $SYMTAB
    declare!(Y,fortranReal(),syms) $SYMTAB
    declare!(ALPHA,fortranReal(),syms)$SYMTAB
    declare!(BETA,fortranReal(),syms) $SYMTAB
    declare!(GAMMA,fortranReal(),syms) $SYMTAB
    declare!(DELTA,fortranReal(),syms) $SYMTAB
    declare!(EPSOLN,fortranReal(),syms) $SYMTAB
    declare!(PHI,fortranReal(),syms) $SYMTAB
    declare!(PSI,fortranReal(),syms) $SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,
                          [X,Y,ALPHA,BETA,GAMMA,DELTA,EPSOLN,PHI,PSI],syms)

    -- To help the poor compiler!
    localAssign(u:Symbol,v:FEXPR):FortranCode ==
      assign(u,(v::EXPR MachineFloat)$FEXPR)$FortranCode

    coerce(u:VEC FEXPR):$ ==
      maxIndex(u) ^= 7 => error "Vector is not of dimension 7"
      [localAssign(ALPHA@Symbol,elt(u,1)),_
       localAssign(BETA@Symbol,elt(u,2)),_
       localAssign(GAMMA@Symbol,elt(u,3)),_
       localAssign(DELTA@Symbol,elt(u,4)),_
       localAssign(EPSOLN@Symbol,elt(u,5)),_
       localAssign(PHI@Symbol,elt(u,6)),_
       localAssign(PSI@Symbol,elt(u,7)),_
       returns()$FortranCode]$List(FortranCode)::$

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP74 Asp74}
\pagehead{Asp74}{ASP74}
\pagepic{ps/v103asp74.ps}{ASP74}{1.00}
<<domain ASP74 Asp74>>=
)abbrev domain ASP74 Asp74
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Oct 1993
++ Date Last Updated: 30 March 1994
++                     6 October 1994
++ Related Constructors: FortranScalarFunctionCategory, FortranProgramCategory.
++ Description:
++\spadtype{Asp74} produces Fortran for Type 74 ASPs, needed for NAG routine 
++\axiomOpFrom{d03eef}{d03Package}, for example:
++\begin{verbatim}
++      SUBROUTINE BNDY(X,Y,A,B,C,IBND)
++      DOUBLE PRECISION A,B,C,X,Y
++      INTEGER IBND
++      IF(IBND.EQ.0)THEN
++        A=0.0D0
++        B=1.0D0
++        C=-1.0D0*DSIN(X)
++      ELSEIF(IBND.EQ.1)THEN
++        A=1.0D0
++        B=0.0D0
++        C=DSIN(X)*DSIN(Y)
++      ELSEIF(IBND.EQ.2)THEN
++        A=1.0D0
++        B=0.0D0
++        C=DSIN(X)*DSIN(Y)
++      ELSEIF(IBND.EQ.3)THEN
++        A=0.0D0
++        B=1.0D0
++        C=-1.0D0*DSIN(Y)
++      ENDIF
++      END
++\end{verbatim}

Asp74(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FSTU   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  SYMTAB ==> SymbolTable
  FC     ==> FortranCode
  PI     ==> PositiveInteger
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X,'Y],[],MFLOAT)
  U      ==> Union(I: Expression Integer,F: Expression Float,_
                   CF: Expression Complex Float,switch:Switch)
  VEC    ==> Vector
  MAT    ==> Matrix
  M2     ==> MatrixCategoryFunctions2
  MF2a   ==> M2(FRAC POLY INT,VEC FRAC POLY INT,VEC FRAC POLY INT,
                MAT FRAC POLY INT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2b   ==> M2(FRAC POLY FLOAT,VEC FRAC POLY FLOAT,VEC FRAC POLY FLOAT,
                MAT FRAC POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2c   ==> M2(POLY INT,VEC POLY INT,VEC POLY INT,MAT POLY INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2d   ==> M2(POLY FLOAT,VEC POLY FLOAT,VEC POLY FLOAT,
                MAT POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2e   ==> M2(EXPR INT,VEC EXPR INT,VEC EXPR INT,MAT EXPR INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2f   ==> M2(EXPR FLOAT,VEC EXPR FLOAT,VEC EXPR FLOAT,
                MAT EXPR FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)

  Exports ==> FortranMatrixFunctionCategory with
    coerce : MAT FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal(),syms)$SYMTAB
    declare!(Y,fortranReal(),syms)$SYMTAB
    declare!(A,fortranReal(),syms)$SYMTAB
    declare!(B,fortranReal(),syms)$SYMTAB
    declare!(C,fortranReal(),syms)$SYMTAB
    declare!(IBND,fortranInteger(),syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,[X,Y,A,B,C,IBND],syms)

    -- To help the poor compiler!
    localAssign(u:Symbol,v:FEXPR):FC == assign(u,(v::EXPR MFLOAT)$FEXPR)$FC

    coerce(u:MAT FEXPR):$ == 
      (nrows(u) ^= 4 or ncols(u) ^= 3) => error "Not a 4X3 matrix"
      flag:U := [IBND@Symbol::EXPR INT]$U
      pt0:U  := [0::EXPR INT]$U
      pt1:U  := [1::EXPR INT]$U
      pt2:U  := [2::EXPR INT]$U
      pt3:U  := [3::EXPR INT]$U
      sw1: Switch := EQ(flag,pt0)$Switch
      sw2: Switch := EQ(flag,pt1)$Switch
      sw3: Switch := EQ(flag,pt2)$Switch
      sw4: Switch := EQ(flag,pt3)$Switch
      a11 : FC := localAssign(A,u(1,1))
      a12 : FC := localAssign(B,u(1,2))
      a13 : FC := localAssign(C,u(1,3))
      a21 : FC := localAssign(A,u(2,1))
      a22 : FC := localAssign(B,u(2,2))
      a23 : FC := localAssign(C,u(2,3))
      a31 : FC := localAssign(A,u(3,1))
      a32 : FC := localAssign(B,u(3,2))
      a33 : FC := localAssign(C,u(3,3))
      a41 : FC := localAssign(A,u(4,1))
      a42 : FC := localAssign(B,u(4,2))
      a43 : FC := localAssign(C,u(4,3))
      c : FC := cond(sw1,block([a11,a12,a13])$FC,
                     cond(sw2,block([a21,a22,a23])$FC,
                          cond(sw3,block([a31,a32,a33])$FC,
                               cond(sw4,block([a41,a42,a43])$FC)$FC)$FC)$FC)$FC
      c::$

    coerce(u:$):OutputForm == coerce(u)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:List FortranCode):$ == coerce(c)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:MAT FRAC POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2a
      v::$

    retractIfCan(u:MAT FRAC POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2a
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT FRAC POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2b
      v::$

    retractIfCan(u:MAT FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2b
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2e
      v::$

    retractIfCan(u:MAT EXPR INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2e
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2f
      v::$

    retractIfCan(u:MAT EXPR FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2f
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2c
      v::$

    retractIfCan(u:MAT POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2c
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2d
      v::$

    retractIfCan(u:MAT POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2d
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP77 Asp77}
\pagehead{Asp77}{ASP77}
\pagepic{ps/v103asp77.ps}{ASP77}{1.00}
<<domain ASP77 Asp77>>=
)abbrev domain ASP77 Asp77
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 30 March 1994
++                     6 October 1994
++ Related Constructors: FortranMatrixFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp77} produces Fortran for Type 77 ASPs, needed for NAG routine 
++\axiomOpFrom{d02gbf}{d02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE FCNF(X,F)
++      DOUBLE PRECISION X
++      DOUBLE PRECISION F(2,2)
++      F(1,1)=0.0D0
++      F(1,2)=1.0D0
++      F(2,1)=0.0D0
++      F(2,2)=-10.0D0
++      RETURN
++      END
++\end{verbatim}

Asp77(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FSTU   ==> Union(fst:FST,void:"void") 
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FC))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X],[],MFLOAT)
  VEC    ==> Vector
  MAT    ==> Matrix
  M2     ==> MatrixCategoryFunctions2
  MF2    ==> M2(FEXPR,VEC FEXPR,VEC FEXPR,Matrix FEXPR,EXPR MFLOAT,
                VEC EXPR MFLOAT,VEC EXPR MFLOAT,Matrix EXPR MFLOAT)
  MF2a   ==> M2(FRAC POLY INT,VEC FRAC POLY INT,VEC FRAC POLY INT,
                MAT FRAC POLY INT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2b   ==> M2(FRAC POLY FLOAT,VEC FRAC POLY FLOAT,VEC FRAC POLY FLOAT,
                MAT FRAC POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2c   ==> M2(POLY INT,VEC POLY INT,VEC POLY INT,MAT POLY INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2d   ==> M2(POLY FLOAT,VEC POLY FLOAT,VEC POLY FLOAT,
                MAT POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2e   ==> M2(EXPR INT,VEC EXPR INT,VEC EXPR INT,MAT EXPR INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2f   ==> M2(EXPR FLOAT,VEC EXPR FLOAT,VEC EXPR FLOAT,
                MAT EXPR FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)


  Exports ==> FortranMatrixFunctionCategory with
    coerce : MAT FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal(),syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,[X,F],syms)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    localAssign(s:Symbol,j:MAT FEXPR):FortranCode ==
      j' : MAT EXPR MFLOAT := map(fexpr2expr,j)$MF2
      assign(s,j')$FortranCode

    coerce(u:MAT FEXPR):$ ==
      dimension := nrows(u)::POLY(INT)
      locals : SYMTAB := empty()
      declare!(F,[real,[dimension,dimension]$List(POLY(INT)),false]$FT,locals)
      code : List FC := [localAssign(F,u),returns()$FC]
      ([locals,code]$RSFC)::$

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:MAT FRAC POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2a
      v::$

    retractIfCan(u:MAT FRAC POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2a
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT FRAC POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2b
      v::$

    retractIfCan(u:MAT FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2b
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2e
      v::$

    retractIfCan(u:MAT EXPR INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2e
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2f
      v::$

    retractIfCan(u:MAT EXPR FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2f
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2c
      v::$

    retractIfCan(u:MAT POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2c
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2d
      v::$

    retractIfCan(u:MAT POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2d
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP78 Asp78}
\pagehead{Asp78}{ASP78}
\pagepic{ps/v103asp78.ps}{ASP78}{1.00}
<<domain ASP78 Asp78>>=
)abbrev domain ASP78 Asp78
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 30 March 1994
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp78} produces Fortran for Type 78 ASPs, needed for NAG routine 
++\axiomOpFrom{d02gbf}{d02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE FCNG(X,G)
++      DOUBLE PRECISION G(*),X
++      G(1)=0.0D0
++      G(2)=0.0D0
++      END
++\end{verbatim}

Asp78(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FSTU   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FC))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  VEC    ==> Vector
  VF2    ==> VectorFunctions2
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['X],[],MFLOAT)

  Exports ==> FortranVectorFunctionCategory with
    coerce : VEC FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal(),syms)$SYMTAB
    gType : FT := construct(real,["*"::Symbol],false)$FT
    declare!(G,gType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU,[X,G],syms)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    coerce(u:VEC FEXPR):$ ==
      u' : VEC EXPR MFLOAT := map(fexpr2expr,u)$VF2(FEXPR,EXPR MFLOAT)
      (assign(G,u')$FC)::$

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    coerce(c:List FC):$ == coerce(c)$Rep

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FC):$ == coerce(c)$Rep

    retract(u:VEC FRAC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC FRAC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(FRAC POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR INT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC EXPR FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(EXPR FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC EXPR FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(EXPR FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY INT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY INT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY INT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY INT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

    retract(u:VEC POLY FLOAT):$ ==
      v : VEC FEXPR := map(retract,u)$VF2(POLY FLOAT,FEXPR)
      v::$

    retractIfCan(u:VEC POLY FLOAT):Union($,"failed") ==
      v:Union(VEC FEXPR,"failed"):=map(retractIfCan,u)$VF2(POLY FLOAT,FEXPR)
      v case "failed" => "failed"
      (v::VEC FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP8 Asp8}
\pagehead{Asp8}{ASP8}
\pagepic{ps/v103asp8.ps}{ASP8}{1.00}
<<domain ASP8 Asp8>>=
)abbrev domain ASP8 Asp8
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: 11 February 1994
++ Date Last Updated: 18 March 1994
++                    31 May 1994 to use alternative interface. MCD
++                    30 June 1994 to handle the end condition correctly. MCD
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp8} produces Fortran for Type 8 ASPs, needed for NAG routine
++\axiomOpFrom{d02bbf}{d02Package}.  This ASP prints intermediate values of the computed solution of
++an ODE and might look like:
++\begin{verbatim}
++      SUBROUTINE OUTPUT(XSOL,Y,COUNT,M,N,RESULT,FORWRD)
++      DOUBLE PRECISION Y(N),RESULT(M,N),XSOL
++      INTEGER M,N,COUNT
++      LOGICAL FORWRD
++      DOUBLE PRECISION X02ALF,POINTS(8)
++      EXTERNAL X02ALF
++      INTEGER I
++      POINTS(1)=1.0D0
++      POINTS(2)=2.0D0
++      POINTS(3)=3.0D0
++      POINTS(4)=4.0D0
++      POINTS(5)=5.0D0
++      POINTS(6)=6.0D0
++      POINTS(7)=7.0D0
++      POINTS(8)=8.0D0
++      COUNT=COUNT+1
++      DO 25001 I=1,N
++        RESULT(COUNT,I)=Y(I)
++25001 CONTINUE
++      IF(COUNT.EQ.M)THEN
++        IF(FORWRD)THEN
++          XSOL=X02ALF()
++        ELSE
++          XSOL=-X02ALF()
++        ENDIF
++      ELSE
++        XSOL=POINTS(COUNT)
++      ENDIF
++      END
++\end{verbatim}

Asp8(name): Exports == Implementation where
  name : Symbol

  O      ==> OutputForm
  S      ==> Symbol
  FST    ==> FortranScalarType
  UFST   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  EX     ==> Expression Integer
  MFLOAT ==> MachineFloat
  EXPR   ==> Expression
  PI     ==> Polynomial Integer
  EXU    ==> Union(I: EXPR Integer,F: EXPR Float,CF: EXPR Complex Float,
                   switch: Switch)

  Exports ==> FortranVectorCategory 

  Implementation ==> add

    real : UFST := ["real"::FST]$UFST
    syms : SYMTAB := empty()$SYMTAB
    declare!([COUNT,M,N],fortranInteger(),syms)$SYMTAB
    declare!(XSOL,fortranReal(),syms)$SYMTAB
    yType : FT := construct(real,[N],false)$FT
    declare!(Y,yType,syms)$SYMTAB
    declare!(FORWRD,fortranLogical(),syms)$SYMTAB
    declare!(RESULT,construct(real,[M,N],false)$FT,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$UFST,[XSOL,Y,COUNT,M,N,RESULT,FORWRD],syms)

    coerce(c:List FC):% == coerce(c)$Rep

    coerce(r:RSFC):% == coerce(r)$Rep

    coerce(c:FC):% == coerce(c)$Rep

    coerce(u:%):O == coerce(u)$Rep

    outputAsFortran(u:%):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage


    f2ex(u:MFLOAT):EXPR MFLOAT == (u::EXPR MFLOAT)$EXPR(MFLOAT)

    coerce(points:Vector MFLOAT):% ==
      import PI
      import EXPR Integer
      -- Create some extra declarations
      locals : SYMTAB := empty()$SYMTAB
      nPol : PI := "N"::S::PI
      iPol : PI := "I"::S::PI
      countPol : PI := "COUNT"::S::PI
      pointsDim : PI := max(#points,1)::PI
      declare!(POINTS,[real,[pointsDim],false]$FT,locals)$SYMTAB
      declare!(X02ALF,[real,[],true]$FT,locals)$SYMTAB
      -- Now build up the code fragments
      index : SegmentBinding PI := equation(I@S,1::PI..nPol)$SegmentBinding(PI)
      ySym : EX := (subscript("Y"::S,[I::O])$S)::EX
      loop := forLoop(index,assign(RESULT,[countPol,iPol],ySym)$FC)$FC
      v:Vector EXPR MFLOAT
      v := map(f2ex,points)$VectorFunctions2(MFLOAT,EXPR MFLOAT)
      assign1 : FC := assign(POINTS,v)$FC
      countExp: EX := COUNT@S::EX
      newValue: EX := 1 + countExp
      assign2 : FC := assign(COUNT,newValue)$FC
      newSymbol : S := subscript(POINTS,[COUNT]@List(O))$S
      assign3 : FC := assign(XSOL, newSymbol::EX )$FC
      fphuge : EX := kernel(operator X02ALF,empty()$List(EX))
      assign4 : FC := assign(XSOL, fphuge)$FC
      assign5 : FC := assign(XSOL, -fphuge)$FC
      innerCond : FC := cond("FORWRD"::Symbol::Switch,assign4,assign5)
      mExp : EX := M@S::EX
      endCase : FC := cond(EQ([countExp]$EXU,[mExp]$EXU)$Switch,innerCond,assign3)
      code := [assign1, assign2, loop, endCase]$List(FC)
      ([locals,code]$RSFC)::%

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP80 Asp80}
\pagehead{Asp80}{ASP80}
\pagepic{ps/v103asp80.ps}{ASP80}{1.00}
<<domain ASP80 Asp80>>=
)abbrev domain ASP80 Asp80
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created: Oct 1993
++ Date Last Updated: 30 March 1994
++                     6 October 1994
++ Related Constructors: FortranMatrixFunctionCategory, FortranProgramCategory
++ Description:
++\spadtype{Asp80} produces Fortran for Type 80 ASPs, needed for NAG routine 
++\axiomOpFrom{d02kef}{d02Package}, for example:
++\begin{verbatim}
++      SUBROUTINE BDYVAL(XL,XR,ELAM,YL,YR)
++      DOUBLE PRECISION ELAM,XL,YL(3),XR,YR(3)
++      YL(1)=XL
++      YL(2)=2.0D0
++      YR(1)=1.0D0
++      YR(2)=-1.0D0*DSQRT(XR+(-1.0D0*ELAM))
++      RETURN
++      END
++\end{verbatim}

Asp80(name): Exports == Implementation where
  name : Symbol

  FST    ==> FortranScalarType
  FSTU   ==> Union(fst:FST,void:"void")
  FT     ==> FortranType
  FC     ==> FortranCode
  SYMTAB ==> SymbolTable
  RSFC   ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  FRAC   ==> Fraction
  POLY   ==> Polynomial
  EXPR   ==> Expression
  INT    ==> Integer
  FLOAT  ==> Float
  MFLOAT ==> MachineFloat
  FEXPR  ==> FortranExpression(['XL,'XR,'ELAM],[],MFLOAT)
  VEC    ==> Vector
  MAT    ==> Matrix
  VF2    ==> VectorFunctions2
  M2     ==> MatrixCategoryFunctions2
  MF2a   ==> M2(FRAC POLY INT,VEC FRAC POLY INT,VEC FRAC POLY INT,
                MAT FRAC POLY INT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2b   ==> M2(FRAC POLY FLOAT,VEC FRAC POLY FLOAT,VEC FRAC POLY FLOAT,
                MAT FRAC POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2c   ==> M2(POLY INT,VEC POLY INT,VEC POLY INT,MAT POLY INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2d   ==> M2(POLY FLOAT,VEC POLY FLOAT,VEC POLY FLOAT,
                MAT POLY FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2e   ==> M2(EXPR INT,VEC EXPR INT,VEC EXPR INT,MAT EXPR INT,
                FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)
  MF2f   ==> M2(EXPR FLOAT,VEC EXPR FLOAT,VEC EXPR FLOAT,
                MAT EXPR FLOAT, FEXPR,VEC FEXPR,VEC FEXPR,MAT FEXPR)

  Exports ==> FortranMatrixFunctionCategory with
    coerce : MAT FEXPR -> $
      ++coerce(f) takes objects from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns them into an ASP.

  Implementation ==> add

    real : FSTU := ["real"::FST]$FSTU
    syms : SYMTAB := empty()$SYMTAB
    declare!(XL,fortranReal(),syms)$SYMTAB
    declare!(XR,fortranReal(),syms)$SYMTAB
    declare!(ELAM,fortranReal(),syms)$SYMTAB
    yType : FT := construct(real,["3"::Symbol],false)$FT
    declare!(YL,yType,syms)$SYMTAB
    declare!(YR,yType,syms)$SYMTAB
    Rep := FortranProgram(name,["void"]$FSTU, [XL,XR,ELAM,YL,YR],syms)

    fexpr2expr(u:FEXPR):EXPR MFLOAT == coerce(u)$FEXPR

    vecAssign(s:Symbol,u:VEC FEXPR):FC ==
      u' : VEC EXPR MFLOAT := map(fexpr2expr,u)$VF2(FEXPR,EXPR MFLOAT)
      assign(s,u')$FC

    coerce(u:MAT FEXPR):$ ==
      [vecAssign(YL,row(u,1)),vecAssign(YR,row(u,2)),returns()$FC]$List(FC)::$

    coerce(c:List FortranCode):$ == coerce(c)$Rep  

    coerce(r:RSFC):$ == coerce(r)$Rep

    coerce(c:FortranCode):$ == coerce(c)$Rep

    coerce(u:$):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

    retract(u:MAT FRAC POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2a
      v::$

    retractIfCan(u:MAT FRAC POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2a
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT FRAC POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2b
      v::$

    retractIfCan(u:MAT FRAC POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2b
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2e
      v::$

    retractIfCan(u:MAT EXPR INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2e
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT EXPR FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2f
      v::$

    retractIfCan(u:MAT EXPR FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2f
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY INT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2c
      v::$

    retractIfCan(u:MAT POLY INT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2c
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

    retract(u:MAT POLY FLOAT):$ ==
      v : MAT FEXPR := map(retract,u)$MF2d
      v::$

    retractIfCan(u:MAT POLY FLOAT):Union($,"failed") ==
      v:Union(MAT FEXPR,"failed"):=map(retractIfCan,u)$MF2d
      v case "failed" => "failed"
      (v::MAT FEXPR)::$

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ASP9 Asp9}
\pagehead{Asp9}{ASP9}
\pagepic{ps/v103asp9.ps}{ASP9}{1.00}
<<domain ASP9 Asp9>>=
)abbrev domain ASP9 Asp9
++ Author: Mike Dewar, Grant Keady and Godfrey Nolan
++ Date Created: Mar 1993
++ Date Last Updated: 18 March 1994
++                    12 July 1994 added COMMON blocks for d02cjf, d02ejf
++                     6 October 1994
++ Related Constructors: FortranVectorFunctionCategory, FortranProgramCategory
++ Description:
++ \spadtype{Asp9} produces Fortran for Type 9 ASPs, needed for NAG routines
++ \axiomOpFrom{d02bhf}{d02Package}, 
++ \axiomOpFrom{d02cjf}{d02Package}, 
++ \axiomOpFrom{d02ejf}{d02Package}.
++ These ASPs represent a function of a scalar X and a vector Y, for example:
++ \begin{verbatim}
++      DOUBLE PRECISION FUNCTION G(X,Y)
++      DOUBLE PRECISION X,Y(*)
++      G=X+Y(1)
++      RETURN
++      END
++ \end{verbatim}
++ If the user provides a constant value for G, then extra information is added
++ via COMMON blocks used by certain routines.  This specifies that the value
++ returned by G in this case is to be ignored.

Asp9(name): Exports == Implementation where
  name : Symbol

  FEXPR   ==> FortranExpression(['X],['Y],MFLOAT)
  MFLOAT  ==> MachineFloat
  FC      ==> FortranCode
  FST     ==> FortranScalarType
  FT      ==> FortranType
  SYMTAB  ==> SymbolTable
  RSFC    ==> Record(localSymbols:SymbolTable,code:List(FortranCode))
  UFST    ==> Union(fst:FST,void:"void")
  FRAC    ==> Fraction
  POLY    ==> Polynomial
  EXPR    ==> Expression
  INT     ==> Integer
  FLOAT   ==> Float

  Exports ==> FortranFunctionCategory with
    coerce : FEXPR -> %
      ++coerce(f) takes an object from the appropriate instantiation of
      ++\spadtype{FortranExpression} and turns it into an ASP.

  Implementation ==> add

    real : FST := "real"::FST
    syms : SYMTAB := empty()$SYMTAB
    declare!(X,fortranReal()$FT,syms)$SYMTAB
    yType : FT := construct([real]$UFST,["*"::Symbol],false)$FT
    declare!(Y,yType,syms)$SYMTAB
    Rep := FortranProgram(name,[real]$UFST,[X,Y],syms)

    retract(u:FRAC POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:FRAC POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:FRAC POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:EXPR INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:EXPR INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY FLOAT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY FLOAT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    retract(u:POLY INT):$ == (retract(u)@FEXPR)::$
    retractIfCan(u:POLY INT):Union($,"failed") ==
      foo : Union(FEXPR,"failed")
      foo := retractIfCan(u)$FEXPR
      foo case "failed" => "failed"
      (foo::FEXPR)::$

    coerce(u:FEXPR):% ==
      expr : Expression MachineFloat := (u::Expression(MachineFloat))$FEXPR
      (retractIfCan(u)@Union(MFLOAT,"failed"))$FEXPR case "failed" => 
          coerce(expr)$Rep
      locals : SYMTAB := empty()
      charType : FT := construct(["character"::FST]$UFST,[6::POLY(INT)],false)$FT
      declare!([CHDUM1,CHDUM2,GOPT1,CHDUM,GOPT2],charType,locals)$SYMTAB
      common1 := common(CD02EJ,[CHDUM1,CHDUM2,GOPT1] )$FC
      common2 := common(AD02CJ,[CHDUM,GOPT2] )$FC
      assign1 := assign(GOPT1,"NOGOPT")$FC
      assign2 := assign(GOPT2,"NOGOPT")$FC
      result  := assign(name,expr)$FC
      code : List FC := [common1,common2,assign1,assign2,result]
      ([locals,code]$RSFC)::Rep

    coerce(c:List FortranCode):% == coerce(c)$Rep

    coerce(r:RSFC):% == coerce(r)$Rep

    coerce(c:FortranCode):% == coerce(c)$Rep

    coerce(u:%):OutputForm == coerce(u)$Rep

    outputAsFortran(u):Void ==
      p := checkPrecision()$NAGLinkSupportPackage
      outputAsFortran(u)$Rep
      p => restorePrecision()$NAGLinkSupportPackage

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter B}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain BITS Bits}
<<dot>>=
"BITS" -> "BTAGG"
"Bits()" -> "BitAggregate()"
@
\pagehead{Bits}{BITS}
\pagepic{ps/v103bits.ps}{BITS}{1.00}
<<domain BITS Bits>>=
)abbrev domain BITS Bits
++ Author: Stephen M. Watt
++ Date Created:
++ Change History:
++ Basic Operations: And, Not, Or
++ Related Constructors:
++ Keywords: bits
++ Description:  \spadtype{Bits} provides logical functions for Indexed Bits.

Bits(): Exports == Implementation where
  Exports == BitAggregate() with
    bits: (NonNegativeInteger, Boolean) -> %
	++ bits(n,b) creates bits with n values of b
  Implementation == IndexedBits(1) add
    bits(n,b)    == new(n,b)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain BOOLEAN Boolean}
<<dot>>=
"BOOLEAN" -> "ORDSET"
"Boolean()" -> "OrderedSet()"
"BOOLEAN" -> "FINITE"
"Boolean()" -> "Finite()"
"BOOLEAN" -> "LOGIC"
"Boolean()" -> "Logic()"
"BOOLEAN" -> "KONVERT"
"Boolean()" -> "ConvertibleTo(InputForm)"
@
\pagehead{Boolean}{BOOLEAN}
\pagepic{ps/v103boolean.ps}{BOOLEAN}{1.00}
<<domain BOOLEAN Boolean>>=
)abbrev domain BOOLEAN Boolean
++ Author: Stephen M. Watt
++ Date Created:
++ Change History:
++ Basic Operations: true, false, not, and, or, xor, nand, nor, implies, ^
++ Related Constructors:
++ Keywords: boolean
++ Description:  \spadtype{Boolean} is the elementary logic with 2 values:
++ true and false

Boolean(): Join(OrderedSet, Finite, Logic, ConvertibleTo InputForm) with
    true   : constant -> %
      ++ true is a logical constant.
    false  : constant -> %
      ++ false is a logical constant.
    _^    : % -> %
      ++ ^ n returns the negation of n.
    _not : % -> %
      ++ not n returns the negation of n.
    _and  : (%, %) -> %
      ++ a and b  returns the logical {\em and} of Boolean \spad{a} and b.
    _or  : (%, %) -> %
      ++ a or b returns the logical inclusive {\em or}
      ++ of Boolean \spad{a} and b.
    xor    : (%, %) -> %
      ++ xor(a,b) returns the logical exclusive {\em or}
      ++ of Boolean \spad{a} and b.
    nand   : (%, %) -> %
      ++ nand(a,b) returns the logical negation of \spad{a} and b.
    nor    : (%, %) -> %
      ++ nor(a,b) returns the logical negation of \spad{a} or b.
    implies: (%, %) -> %
      ++ implies(a,b) returns the logical implication
      ++ of Boolean \spad{a} and b.
    test: % -> Boolean
      ++ test(b) returns b and is provided for compatibility with the 
      ++ new compiler.
  == add
    nt: % -> %

    test a        == a pretend Boolean

    nt b          == (b pretend Boolean => false; true)
    true          == EQ(2,2)$Lisp   --well, 1 is rather special
    false         == NIL$Lisp
    sample()      == true
    not b         == (test b => false; true)
    _^ b          == (test b => false; true)
    _~ b          == (test b => false; true)
    _and(a, b)    == (test a => b; false)
    _/_\(a, b)    == (test a => b; false)
    _or(a, b)     == (test a => true; b)
    _\_/(a, b)     == (test a => true; b)
    xor(a, b)     == (test a => nt b; b)
    nor(a, b)     == (test a => false; nt b)
    nand(a, b)    == (test a => nt b; true)
    a = b         == BooleanEquality(a, b)$Lisp
    implies(a, b) == (test a => b; true)
    a < b         == (test b => not(test a);false)

    size()        == 2
    index i       ==
      even?(i::Integer) => false
      true
    lookup a      ==
      a pretend Boolean => 1
      2
    random()      ==
      even?(random()$Integer) => false
      true

    convert(x:%):InputForm ==
      x pretend Boolean => convert("true"::Symbol)
      convert("false"::Symbol)

    coerce(x:%):OutputForm ==
      x pretend Boolean => message "true"
      message "false"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter C}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain DBASE Database}
<<dot>>=
"DBASE" -> "SETCAT"
"Database(a:OrderedSet)" -> "SetCategory()"
@
\pagehead{Database}{DBASE}
\pagepic{ps/v103database.ps}{DBASE}{1.00}
<<domain DBASE Database>>=
)abbrev domain DBASE Database
++ This domain implements a simple view of a database whose fields are 
++ indexed by symbols
Database(S): Exports == Implementation where
  S: OrderedSet with 
    elt: (%,Symbol) -> String
	++ elt(x,s) returns an element of x indexed by s
    display: % -> Void
	++ display(x) displays x in some form
    fullDisplay: % -> Void
	++ fullDisplay(x) displays x in detail
  Exports == SetCategory with
    elt: (%,QueryEquation) -> %
      ++ elt(db,q) returns all elements of \axiom{db} which satisfy \axiom{q}.
    elt: (%,Symbol) -> DataList String
      ++ elt(db,s) returns the \axiom{s} field of each element of \axiom{db}.
    _+: (%,%) -> %
      ++ db1+db2 returns the merge of databases db1 and db2
    _-: (%,%) -> %
      ++ db1-db2 returns the difference of databases db1 and db2 i.e. consisting
      ++ of elements in db1 but not in db2 
    coerce: List S -> %
      ++ coerce(l) makes a database out of a list
    display: % -> Void
      ++ display(db) prints a summary line for each entry in \axiom{db}.
    fullDisplay: % -> Void
      ++ fullDisplay(db) prints full details of each entry in \axiom{db}.
    fullDisplay: (%,PositiveInteger,PositiveInteger) -> Void
      ++ fullDisplay(db,start,end ) prints full details of entries in the range
      ++ \axiom{start..end} in \axiom{db}.
  Implementation == List S add
    s: Symbol
    Rep := List S
    coerce(u: List S):% == u@%
    elt(data: %,s: Symbol) == [x.s for x in data] :: DataList(String)
    elt(data: %,eq: QueryEquation) ==
      field := variable eq
      val := value eq
      [x for x in data | stringMatches?(val,x.field)$Lisp]
    x+y==removeDuplicates_! merge(x,y)
    x-y==mergeDifference(copy(x::Rep),y::Rep)$MergeThing(S)
    coerce(data): OutputForm == (#data):: OutputForm
    display(data) ==  for x in data repeat display x
    fullDisplay(data) == for x in data repeat fullDisplay x
    fullDisplay(data,n,m) == for x in data for i in 1..m repeat
      if i >= n then fullDisplay x

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain DLIST DataList}
<<dot>>=
"DLIST" -> "LSAGG"
"DataList(a:OrderedSet)" -> "ListAggregate(a:Type)"
@
\pagehead{DataList}{DLIST}
\pagepic{ps/v103datalist.ps}{DLIST}{1.00}
<<domain DLIST DataList>>=
)abbrev domain DLIST DataList
++ This domain provides some nice functions on lists
DataList(S:OrderedSet) : Exports == Implementation where
  Exports == ListAggregate(S) with
    coerce: List S -> %
      ++ coerce(l) creates a datalist from l  	
    coerce: % -> List S
      ++ coerce(x) returns the list of elements in x
    datalist: List S -> %
      ++ datalist(l) creates a datalist from l 
    elt: (%,"unique") -> %
      ++ \axiom{l.unique} returns \axiom{l} with duplicates removed.
      ++ Note: \axiom{l.unique = removeDuplicates(l)}.
    elt: (%,"sort") -> %
      ++ \axiom{l.sort} returns \axiom{l} with elements sorted.
      ++ Note: \axiom{l.sort = sort(l)}
    elt: (%,"count") -> NonNegativeInteger
      ++ \axiom{l."count"} returns the number of elements in \axiom{l}.
  Implementation == List(S) add
    elt(x,"unique") == removeDuplicates(x)
    elt(x,"sort") == sort(x)
    elt(x,"count") == #x
    coerce(x:List S) == x pretend %
    coerce(x:%):List S == x pretend (List S)
    coerce(x:%): OutputForm == (x :: List S) :: OutputForm
    datalist(x:List S) == x::%

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Denavit-Hartenberg Matrices}
\subsection{Homogeneous Transformations}
The study of robot manipulation is concerned with the relationship between
objects, and between objects and manipulators. In this chapter we will
develop the representation necessary to describe these relationships. Similar
problems of representation have already been solved in the field of computer
graphics, where the relationship between objects must also be described.
Homogeneous transformations are used in this field and in computer vision
[Duda] [Robserts63] [Roberts65]. These transformations were employed by 
Denavit to describe linkages [Denavit] and are now used to describe 
manipulators [Pieper] [Paul72] [Paul77b].

We will first establish notation for vectors and planes and then introduce
transformations on them. These transformations consist primarily of
translation and rotation. We will then show that these transformations
can also be considered as coordinate frames in which to represent
objects, including the manipulator. The inverse transformation will
then be introduced. A later section describes the general rotation
transformation representing a rotation about a vector. An algorithm is
then described to find the equivalent axis and angle of rotations
represented by any given transformation. A brief section on stretching
and scaling transforms is included together with a section on the
perspective transformation. The chapter concludes with a section on
transformation equations.

\subsection{Notation}

In describing the relationship between objects we will make use of
point vectors, planes, and coordinate frames. Point vectors are
denoted by lower case, bold face characters. Planes are denoted by
script characters, and coordinate frames by upper case, bold face
characters. For example:

\begin{tabular}{ll}
vectors & {\bf v}, {\bf x1}, {\bf x} \\
planes  & $\bigp$, $\bigq$ \\
coordinate frames & {\bf I}, {\bf A}, {\bf CONV}\\
\end{tabular}\\

We will use point vectors, planes, and coordinate frames as variables
which have associated values. For example, a point vector has as value
its three Cartesian coordinate components.

If we wish to describe a point in space, which we will call {\sl p},
with respect to a coordinate frame {\bf E}, we will use a vector which
we will call {\bf v}. We will write this as

$$^E{\bf v}$$

\noindent
The leading superscript describes the defining coordinate frame.

We might also wish to describe this same point, {\sl p}, with respect
to a different coordinate frame, for example {\bf H}, using a vector
{\bf w} as

$$^H{\bf w}$$

\noindent
{\bf v} and {\bf w} are two vectors which probably have different
component values and ${\bf v} \ne {\bf w}$ even though both vectors
describe the same point {\sl p}. The case might also exist of a vector
{\bf a} describing a point 3 inches above any frame

$${^{F^1}}{\bf a}\qquad {^{F^2}}{\bf a}$$

\noindent
In this case the vectors are identical but describe different
points. Frequently, the defining frame will be obvious from the text
and the superscripts will be left off. In many cases the name of the
vector will be the same as the name of the object described, for
example, the tip of a pin might be described by a vector {\bf tip}
with respect to a frame {\bf BASE} as

$${^{BASE}}{\bf tip}$$

\noindent
If it were obvious from the text that we were describing the vector
with respect to {\bf BASE} then we might simply write

$${\bf tip}$$

If we also wish to describe this point with respect to another
coordinate frame say, {\bf HAND}, then we must use another vector to
describe this relationship, for example

$${^{HAND}{\bf tv}}$$

\noindent
${^{HAND}{\bf tv}}$ and {\bf tip} both describe the same feature but
have different values. In order to refer to individual components of
coordinate frames, point vectors, or planes, we add subscripts to
indicate the particular component. For example, the vector
${^{HAND}{\bf tv}}$ has components ${^{HAND}{\bf tv}}_{\bf x}$,
${^{HAND}{\bf tv}}_{\bf y}$, ${^{HAND}{\bf tv}}_{\bf z}$.

\subsection{Vectors}

The homogeneous coordinate representation of objects in $n$-space
is an $(n + 1)$-space entity such that a particular perspective
projection recreates the $n$-space. This can also be viewed as the
addition of an extra coordinate to each vector, a scale factor, such
that the vector has the same meaning if each component, including the
scale factor, is multiplied by a constant.

A point vector

$${\bf v} = a{\bf i} + b{\bf j} + c{\bf k}\eqno(1.1)$$

\noindent
where {\bf i}, {\bf j}, and {\bf k} are unit vectors along the $x$,
$y$, and $z$ coordinate axes, respectively, is represented in
homogeneous coordinates as a column matrix

$${\bf v} = \left[\matrix{{\bf x}\cr
                          {\bf y}\cr
                          {\bf z}\cr
                          {\bf w}\cr}
            \right]\eqno(1.2)$$

\noindent
where

$${{\bf a} = {\bf x}/{\bf w}}$$
$${{\bf b} = {\bf y}/{\bf w}}\eqno(1.3)$$
$${{\bf c} = {\bf z}/{\bf w}}$$

\noindent
Thus the vector $3{\bf i} + 4{\bf j} + 5{\bf k}$ can be represented as
$[3,4,5,1]^{\rm T}$ or as $[6,8,10,2]^{\rm T}$ or again 
as $[-30,-40,-50,-10]^{\rm T}$,
etc. The superscript $T$ indicates the transpose of the row vector
into a column vector. The vector at the origin, the null vector, is
represented as $[0,0,0,n]^{\rm T}$ where $n$ is any non-zero scale
factor. The vector $[0,0,0,0]^{\rm T}$ is undefined. Vectors of the form
$[a,b,c,0]^{\rm T}$ represent vectors at infinity and are used to represent
directions; the addition of any other finite vector does not change
their value in any way.

We will also make use of the vector dot and cross products. Given two
vectors

$${\bf a} = a_x{\bf i} + a_y{\bf j} + a_z{\bf k}\eqno(1.4)$$
$${\bf b} = b_x{\bf i} + b_y{\bf j} + b_z{\bf k}$$

\noindent
we define the vector dot product, indicated by ``$\cdot$'' as

$${\bf a} \cdot {\bf b} = {a_x}{b_x} + {a_y}{b_y} + {a_z}{b_z}\eqno(1.5)$$

\noindent
The dot product of two vectors is a scalar. The cross product,
indicated by an ``$\times$'', is another vector perpendicular to the
plane formed by the vectors of the product and is defined by

$${\bf a} \times {\bf b} = ({a_y}{b_z} - {a_z}{b_y}){\bf i} +
                         ({a_z}{b_x} - {a_x}{b_z}){\bf j} +
                         ({a_x}{b_y} - {a_y}{b_x}){\bf k}\eqno(1.6)$$

\noindent
This definition is easily remembered as the expansion of the
determinant

$${\bf a} \times {\bf b} = 
  \left|\matrix{{\bf i}&{\bf j}&{\bf k}\cr
                 {a_x}&{a_y}&{a_z}\cr
                 {b_x}&{b_y}&{b_z}\cr}\right|\eqno(1.7)$$

\subsection{Planes}
A plane is represented as a row matrix

$$\bigp=[a,b,c,d]\eqno(1.8)$$

\noindent
such that if a point {\bf v} lies in a plane $\bigp$ the matrix
product

$$\bigp{\bf v} = 0\eqno(1.9)$$

\noindent
or in expanded form

$$xa + yb + zc + wd = 0\eqno(1.10)$$

\noindent
If we define a constant

$$m = +\sqrt{a^2 + b^2 + c^2}\eqno(1.11)$$

\noindent
and divide Equation 1.10 by $wm$ we obtain

$${x\over w}{a\over m} + {y\over w}{b\over m} + {z\over w}{c\over m} 
   = -{d\over m}\eqno(1.12)$$

\noindent
The left hand side of Equation 1.12 is the vector dot product of two
vectors $(x/w){\bf i} + (y/w){\bf j} + (z/w){\bf k}$ and 
$(a/m){\bf i} + (b/m){\bf j} + (c/m){\bf k}$ and represents the
directed distance of the point 
$(x/w){\bf i} + (y/w){\bf j} + (z/w){\bf k}$ along the vector\\
$(a/m){\bf i} + (b/m){\bf j} + (c/m){\bf k}$. The vector
$(a/m){\bf i} + (b/m){\bf j} + (c/m){\bf k}$ can be interpreted as the
outward pointing normal of a plane situated a distance $-d/m$ from the
origin in the direction of the normal. Thus a plane $\bigp$ parallel
to the $x$,$y$ plane, one unit along the $z$ axis, is represented as

$${\rm {\ \ \ \ \ \ \ \ \ }} \bigp = [0,0,1,-1]\eqno(1.13)$$
$${\rm {or\  as\ \ \ }} \bigp = [0,0,2,-2]\eqno(1.14)$$
$${\rm {\ \ \ \ \ or\  as\ \ \ }} \bigp = [0,0,-100,100]\eqno(1.15)$$

\noindent
A point ${\bf v} = [10,20,1,1]$ should lie in this plane

$$[0,0,-100,100]\left[\matrix{10\cr
                              20\cr
                               1\cr
                               1\cr}
                \right]
     = 0\eqno(1.16)$$

\noindent
or

$$[0,0,1,-1]\left[\matrix{ -5\cr
                          -10\cr
                          -.5\cr
                          -.5\cr}
             \right]
     = 0\eqno(1.17)$$

\noindent
The point ${\bf v} = [0,0,2,1]$ lies above the plane

$$[0,0,2,-2]\left[\matrix{0\cr
                          0\cr
                          2\cr
                          1\cr}
             \right]
     = 2\eqno(1.18)$$

and $\bigp{\bf v}$ is indeed positive, indicating that the point is
outside the plane in the direction of the outward pointing normal. A
point ${\bf v} = [0,0,0,1]$ lies below the plane

$$[0,0,1,-1]\left[\matrix{0\cr
                          0\cr
                          0\cr
                          1\cr}
             \right]
     = -1\eqno(1.19)$$

\noindent
The plane $[0,0,0,0]$ is undefined.

\subsection{Transformations}

\noindent
A transformation of the space {\bf H} is a 4x4 matrix and can
represent translation, rotation, stretching, and perspective
transformations. Given a point {\bf u}, its transformation {\bf v} is
represented by the matrix product

$${\bf v} = {\bf H}{\bf u}\eqno(1.20)$$

\noindent
The corresponding plane transformation $\bigp$ to $\bigq$ is

$$\bigq = \bigp{\bf H^{-1}}\eqno(1.21)$$

\noindent
as we requre that the condition

$$\bigq{\bf v} = \bigp{\bf u}\eqno(1.22)$$

\noindent
is invariant under all transformations. To verify this we substitute
from Equations 1.20 and 1.21 into the left hand side of 1.22 and we
obtain on the right hand side ${\bf H^{-1}}{\bf H}$ which is the
identity matrix {\bf I}

$$\bigp{\bf H^{-1}}{\bf H}{\bf u} = \bigp{\bf u}\eqno(1.23)$$

\subsection{Translation Transformation}

\noindent
The transformation {\bf H} corresponding to a translation by a vector
$a{\bf i} + b{\bf j} + c{\bf k}$ is

$${\bf H} = {\bf Trans(a,b,c)} = 
   \left[\matrix{1&0&0&a\cr
                 0&1&0&b\cr
                 0&0&1&c\cr
                 0&0&0&1\cr}
   \right]\eqno(1.24)$$

\noindent
Given a vector ${\bf u} = [x,y,z,w]^{\rm T}$ the transformed vector {\bf v}
is given by

$${\bf H} = {\bf Trans(a,b,c)} = 
   \left[\matrix{1&0&0&a\cr
                 0&1&0&b\cr
                 0&0&1&c\cr
                 0&0&0&1\cr}
   \right]
   \left[\matrix{x\cr
                 y\cr
                 z\cr
                 w\cr}
   \right]\eqno(1.25)$$

$${\bf v} = \left[\matrix{x + aw\cr
                          y + bw\cr
                          z + cw\cr
                          w\cr}
            \right]
          = \left[\matrix{x/w + a\cr
                          y/w + b\cr
                          z/w + c\cr
                          1\cr}
            \right]\eqno(1.26)$$

\noindent
The translation may also be interpreted as the addition of the two
vectors $(x/w){\bf i} + (y/w){\bf j} + (z/w){\bf k}$ and 
$a{\bf i} + b{\bf j} + c{\bf k}$.

Every element of a transformation matrix may be multiplied by a
non-zero constant without changing the transformation, in the same
manner as points and planes. Consider the vector $2{\bf i} + 3{\bf j}
+ 2{\bf k}$ translated by, or added to\\
4{\bf i} - 3{\bf j} + 7{\bf k}

$$\left[\matrix{6\cr
                0\cr
                9\cr
                1\cr}
  \right] =
  \left[\matrix{1 & 0 & 0 & 4\cr
                0 & 1 & 0 & -3\cr
                0 & 0 & 1 & 7\cr
                0 & 0 & 0 & 1\cr}
  \right]
  \left[\matrix{2\cr
                3\cr
                2\cr
                1\cr}
  \right]\eqno(1.27)$$

\noindent
If we multiply the transmation matrix elements by, say, -5, and the
vector elements by 2, we obtain

$$\left[\matrix{-60\cr
                0\cr
                -90\cr
                -10\cr}
  \right] =
  \left[\matrix{-5 & 0 &  0 & -20\cr
                0 & -5 &  0 &  15\cr
                0 &  0 & -5 & -35\cr
                0 &  0 &  0 &  -5\cr}
  \right]
  \left[\matrix{4\cr
                6\cr
                4\cr
                2\cr}
  \right]\eqno(1.28)$$

\noindent
which corresponds to the vector $[6,0,9,1]^{\rm T}$ as before. The point
$[2,3,2,1]$ lies in the plane $[1,0,0,-2]$

$$[1,0,0,-2]\left[\matrix{2\cr
                          3\cr
                          2\cr
                          1\cr}
            \right] = 0\eqno(1.29)$$

\noindent
The transformed point is, as we have already found, $[6,0,9,1]^{\rm T}$. We
will now compute the transformed plane. The inverse of the transform
is 

$$\left[\matrix{1 & 0 & 0 & -4\cr
                0 & 1 & 0 &  3\cr
                0 & 0 & 1 & -7\cr
                0 & 0 & 0 &  1\cr}\right]$$

\noindent
and the transformed plane

$$[1\ 0\ 0\ -6] = [1\ 0\ 0\ -2]\left[\matrix{1 & 0 & 0 & -4\cr
                                        0 & 1 & 0 &  3\cr
                                        0 & 0 & 1 & -7\cr
                                        0 & 0 & 0 &  1\cr}
                         \right]\eqno(1.30)$$

\noindent
Once again the transformed point lies in the transformed plane

$$[1\ 0\ 0\ -6] \left[\matrix{6\cr
                              0\cr
                              9\cr
                              1\cr}\right] = 0\eqno(1.31)$$

The general translation operation can be represented in Axiom as

<<translate>>=
    translate(x,y,z) ==
     matrix(_
      [[1,0,0,x],_
       [0,1,0,y],_
       [0,0,1,z],_
       [0,0,0,1]])
@
\subsection{Rotation Transformations}

\noindent
The transformations corresponding to rotations about the $x$, $y$, and
$z$ axes by an angle $\theta$ are

$${\bf Rot(x,\theta)} = 
    \left[\matrix{1 &             0 &              0 & 0\cr
                  0 & {cos\ \theta} & {-sin\ \theta} & 0\cr
                  0 & {sin\ \theta} & {cos\ \theta}  & 0\cr
                  0 &             0 &              0 & 1}\right]
   \eqno(1.32)$$

Rotations can be described in Axiom as functions that return
matrices. We can define a function for each of the rotation matrices
that correspond to the rotations about each axis. Note that the
sine and cosine functions in Axiom expect their argument to be in
radians rather than degrees. This conversion is

$$radians = {{degrees * \pi}\over{180}}$$

\noindent
The Axiom code for ${\bf Rot(x,degree)}$ is

<<rotatex>>=
    rotatex(degree) ==
     angle := degree * pi() / 180::R
     cosAngle := cos(angle)
     sinAngle := sin(angle)
     matrix(_
      [[1,     0,           0,      0], _
       [0, cosAngle, -sinAngle, 0], _
       [0, sinAngle,  cosAngle, 0], _
       [0,     0,           0,      1]])
@

$${\bf Rot(y,\theta)} = 
    \left[\matrix{{cos\ \theta}  & 0 & {sin\ \theta} & 0\cr
                               0 & 1 &             0 & 0\cr
                  {-sin\ \theta} & 0 & {cos\ \theta} & 0\cr
                               0 & 0 &             0 & 1\cr}\right]
   \eqno(1.33)$$

\noindent 
The Axiom code for ${\bf Rot(y,degree)}$ is

<<rotatey>>=
    rotatey(degree) ==
     angle := degree * pi() / 180::R
     cosAngle := cos(angle)
     sinAngle := sin(angle)
     matrix(_
      [[ cosAngle, 0, sinAngle, 0], _
       [    0,       1,     0,      0], _
       [-sinAngle, 0, cosAngle, 0], _
       [    0,       0,     0,      1]])
@

$${\bf Rot(z,\theta)} = 
    \left[\matrix{{cos\ \theta} & {-sin\ \theta} & 0 & 0\cr
                  {sin\ \theta} &  {cos\ \theta} & 0 & 0\cr
                              0 &              0 & 1 & 0\cr
                              0 &              0 & 0 & 1}\right]
   \eqno(1.34)$$

\noindent 
And the Axiom code for ${\bf Rot(z,degree)}$ is

<<rotatez>>=
    rotatez(degree) ==
     angle := degree * pi() / 180::R
     cosAngle := cos(angle)
     sinAngle := sin(angle)
     matrix(_
      [[cosAngle, -sinAngle, 0, 0], _
       [sinAngle,  cosAngle, 0, 0], _
       [   0,           0,       1, 0], _
       [   0,           0,       0, 1]])
@
\noindent
Let us interpret these rotations by means of an example. Given a point
${\bf u} = 7{\bf i} + 3{\bf j} + 2{\bf k}$ what is the effect of
rotating it $90^\circ$ about the ${\bf z}$ axis to ${\bf v}$? The
transform is obtained from Equation 1.34 with $sin\ \theta = 1$ and 
$cos\ \theta = 0$. 

$$\left[\matrix{-3\cr
                 7\cr
                 2\cr
                 1\cr}
  \right] =
  \left[\matrix{0 & -1 &  0 & 0\cr
                1 &  0 &  0 & 0\cr
                0 &  0 &  1 & 0\cr
                0 &  0 &  0 & 1\cr}
  \right]
  \left[\matrix{7\cr
                3\cr
                2\cr
                1\cr}
  \right]\eqno(1.35)$$

\noindent
Let us now rotate {\bf v} $90^\circ$ about the $y$ axis to 
{\bf w}. The transform is obtained from Equation 1.33 and we have

$$\left[\matrix{2\cr
                7\cr
                3\cr
                1\cr}
  \right] =
  \left[\matrix{ 0 &  0 &  1 & 0\cr
                 0 &  1 &  0 & 0\cr
                -1 &  0 &  0 & 0\cr
                 0 &  0 &  0 & 1\cr}
  \right]
  \left[\matrix{-3\cr
                 7\cr
                 2\cr
                 1\cr}
  \right]\eqno(1.36)$$

\noindent
If we combine these two rotations we have

$${\rm \ \ \ \ \ \ \ } {\bf v} = {\bf Rot(z,90)}{\bf u}\eqno(1.37)$$

$${\rm and\ \ \ } {\bf w} = {\bf Rot(y,90)}{\bf v}\eqno(1.38)$$

\noindent
Substituting for {\bf v} from Equation 1.37 into Equation 1.38 we
obtain 

$${\bf w} = {\bf Rot(y,90)}\ {\bf Rot(z,90)}\ {\bf u}\eqno(1.39)$$

$${\bf Rot(y,90)}\ {\bf Rot(z,90)} = 
   \left[\matrix{ 0 & 0 & 1 & 0\cr
                  0 & 1 & 0 & 0\cr
                 -1 & 0 & 0 & 0\cr
                  0 & 0 & 0 & 1}
   \right]
   \left[\matrix{0 & -1 & 0 & 0\cr
                 1 &  0 & 0 & 0\cr
                 0 &  0 & 1 & 0\cr
                 0 &  0 & 0 & 1}
   \right]\eqno(1.40)$$

$${\bf Rot(y,90)}\ {\bf Rot(z,90)} = 
   \left[\matrix{0 &  0 & 1 & 0\cr
                 1 &  0 & 0 & 0\cr
                 0 &  1 & 0 & 0\cr
                 0 &  0 & 0 & 1}
   \right]\eqno(1.41)$$

\noindent
thus

$${\bf w} = \left[\matrix{2\cr
                          7\cr
                          3\cr
                          1}\right]
          = \left[\matrix{0 & 0 & 1 & 0\cr
                          1 & 0 & 0 & 0\cr
                          0 & 1 & 0 & 0\cr
                          0 & 0 & 0 & 1}\right]
            \left[\matrix{7\cr
                          3\cr
                          2\cr
                          1}\right]\eqno(1.42)$$

\noindent
as we obtained before.

If we reverse the order of rotations and first rotate $90^\circ$ about
the $y$ axis and then $90^\circ$ about the $z$ axis, we obtain a
different position

$${\bf Rot(z,90)}{\bf Rot(y,90)} =
    \left[\matrix{0 & -1 & 0 & 0\cr
                  1 &  0 & 0 & 0\cr
                  0 &  0 & 1 & 0\cr
                  0 &  0 & 0 & 1}
    \right]
    \left[\matrix{ 0 & 0 & 1 & 0\cr
                   0 & 1 & 0 & 0\cr
                  -1 & 0 & 0 & 0\cr
                   0 & 0 & 0 & 1}
    \right]
  = \left[\matrix{ 0 & -1 & 0 & 0\cr
                   0 &  0 & 1 & 0\cr
                  -1 &  0 & 0 & 0\cr
                   0 &  0 & 0 & 1}
    \right]\eqno(1.43)$$

\noindent
and the point {\bf u} transforms into {\bf w} as

$$\left[\matrix{-3\cr
                 2\cr
                -7\cr
                 1}
  \right]
 = \left[\matrix{ 0 & -1 & 0 & 0\cr
                  0 &  0 & 1 & 0\cr
                 -1 &  0 & 0 & 0\cr
                  0 &  0 & 0 & 1}
   \right]
   \left[\matrix{7\cr
                 3\cr
                 2\cr
                 1}
   \right]\eqno(1.44)$$

\noindent
We should expect this, as matrix multiplication is noncommutative.

$${\bf A}{\bf B} \ne {\bf B}{\bf A}\eqno(1.45)$$

We will now combine the original rotation with a translation 
$4{\bf i}-3{\bf j}+7{\bf k}$. We obtain the translation from Equation
1.27 and the rotation from Equation 1.41. The matrix expression is

$${\bf Trans(4,-3,7)}{\bf Rot(y,90)}{\bf Rot(z,90)}
   = \left[\matrix{1 & 0 & 0 &  4\cr
                   0 & 1 & 0 & -3\cr
                   0 & 0 & 1 &  7\cr
                   0 & 0 & 0 &  1}
     \right]
     \left[\matrix{0 & 0 & 1 & 0\cr
                   1 & 0 & 0 & 0\cr
                   0 & 1 & 0 & 0\cr
                   0 & 0 & 0 & 1}
     \right]
   = \left[\matrix{0 & 0 & 1 &  4\cr
                   1 & 0 & 0 & -3\cr
                   0 & 1 & 0 &  7\cr
                   0 & 0 & 0 &  1}
     \right]\eqno(1.46)$$

\noindent
and our point ${\bf w} = 7{\bf i}+3{\bf j}+2{\bf k}$ transforms into
{\bf x} as

$$\left[\matrix{ 6\cr
                 4\cr
                10\cr
                 1}
  \right]
 = \left[\matrix{0 & 0 & 1 &  4\cr
                 1 & 0 & 0 & -3\cr
                 0 & 1 & 0 &  7\cr
                 0 & 0 & 0 &  1}
  \right]
  \left[\matrix{7\cr
                3\cr
                2\cr
                1}
  \right]\eqno(1.47)$$

\subsection{Coordinate Frames}

\noindent
We can interpret the elements of the homogeneous transformation as
four vectors describing a second coordinate frame. The vector
$[0,0,0,1]^{\rm T}$ lies at the origin of the second coordinate frame. Its
transformation corresponds to the right hand column of the
transformation matrix. Consider the transform in Equation 1.47

$$\left[\matrix{ 4\cr
                -3\cr
                 7\cr
                 1}
  \right]
 = \left[\matrix{0 & 0 & 1 &  4\cr
                 1 & 0 & 0 & -3\cr
                 0 & 1 & 0 &  7\cr
                 0 & 0 & 0 &  1}
   \right]
   \left[\matrix{0\cr
                 0\cr
                 0\cr
                 1}
   \right]\eqno(1.48)$$

\noindent
The transform of the null vector is $[4,-3,7,1]^{\rm T}$, the right
hand column. If we transform vectors corresponding to unit vectors
along the $x$, $y$, and $z$ axes, we obtain $[4,-2,7,1]^{\rm T}$,
$[4,-3,8,1]^{\rm T}$, and $[5,-3,7,1]^{\rm T}$, respectively. Those
four vectors form a coordinate frame.

The direction of these unit vectors is formed by subtracting the
vector representing the origin of this coordinate frame and extending
the vectors to infinity by reducing their scale factors to zero. The
direction of the $x$, $y$, and $z$ axes of this frame are
$[0,1,0,0]^{\rm T}$, $[0,0,1,0]^{\rm T}$, and $[1,0,0,0]^{\rm T}$,
respectively. These direction vectors correspond to the first three
columns of the transformation matrix. The transformation matrix thus
describes the three axis directions and the position of the origin of
a coordinate frame rotated and translated away from the reference
coordinate frame. When a vector is transformed, as in Equation 1.47,
the original vector can be considered as a vector described in the
coordinate frame. The transformed vector is the same vector described
with respect to the reference coordinate frame.

\subsection{Relative Transformations}

\noindent
The rotations and translations we have been describing have all been
made with respect to the fixed reference coordinate frame. Thus, in
the example given, 

$${\bf Trans(4,-3,7)}{\bf Rot(y,90)}{\bf Rot(z,90)}
   = \left[\matrix{0 & 0 & 1 &  4\cr
                   1 & 0 & 0 & -3\cr
                   0 & 1 & 0 &  7\cr
                   0 & 0 & 0 &  1}
     \right]\eqno(1.49)$$

\noindent
the frame is first rotated around the reference $z$ axis by
$90^\circ$, then rotated $90^\circ$ around the reference $y$ axis, and
finally translated by $4{\bf i}-3{\bf j}+7{\bf k}$. We may also
interpret the operation in the reverse order, from left to right, as
follows: the object is first translated by 
$4{\bf i}-3{\bf j}+7{\bf k}$; it is then rotated $90^\circ$ around the
current frames axes, which in this case are the same as the reference
axes; it is then rotated $90^\circ$ about the newly rotated (current)
frames axes.

In general, if we postmultiply a transform representing a frame by a
second transformation describing a rotation and/or translation, we
make that translation and/or rotation with respect to the frame axes
described by the first transformation. If we premultiply the frame
transformation by a transformation representing a translation and/or
rotation, then that translation and/or rotation is made with respect to
the base reference coordinate frame. Thus, given a frame {\bf C} and a
transformation {\bf T}, corresponding to a rotation of $90^\circ$
about the $z$ axis, and a translation of 10 units in the $x$
direction, we obtain a new position {\bf X} when the change is made in
the base coordinates ${\bf X} = {\bf T} {\bf C}$

$$\left[\matrix{0 & 0 & 1 &  0\cr
                1 & 0 & 0 & 20\cr
                0 & 1 & 0 &  0\cr
                0 & 0 & 0 &  1}
  \right]
 = \left[\matrix{0 & -1 & 0 & 10\cr
                 1 &  0 & 0 &  0\cr
                 0 &  0 & 1 &  0\cr
                 0 &  0 & 0 &  1}
  \right]
  \left[\matrix{1 & 0 &  0 & 20\cr
                0 & 0 & -1 & 10\cr
                0 & 1 &  0 &  0\cr
                0 & 0 &  0 &  1}
  \right]\eqno(1.50)$$

\noindent
and a new position {\bf Y} when the change is made relative to the
frame axes as ${\bf Y} = {\bf C} {\bf T}$

$$\left[\matrix{0 & -1 &  0 & 30\cr
                0 &  0 & -1 & 10\cr
                1 &  0 &  0 &  0\cr
                0 &  0 &  0 &  1}
  \right]
 = \left[\matrix{1 &  0 &  0 & 20\cr
                 0 &  0 & -1 & 10\cr
                 0 &  1 &  0 &  0\cr
                 0 &  0 &  0 &  1}
  \right]
  \left[\matrix{0 & -1 &  0 & 10\cr
                1 &  0 &  0 &  0\cr
                0 &  0 &  1 &  0\cr
                0 &  0 &  0 &  1}
  \right]\eqno(1.51)$$

\subsection{Objects}

\noindent
Transformations are used to describe the position and orientation of
objects. An object is described by six points with respect to a
coordinate frame fixed in the object.

If we rotate the object $90^\circ$ about the $z$ axis and then
$90^\circ$ about the $y$ axis, followed by a translation of four units
in the $x$ direction, we can describe the transformation as

$${\bf Trans(4,0,0)}{\bf Rot(y,90)}{\bf Rot(z,90)} =
   \left[\matrix{0 & 0 & 1 & 4\cr
                 1 & 0 & 0 & 0\cr
                 0 & 1 & 0 & 0\cr
                 0 & 0 & 0 & 1}
   \right]\eqno(1.52)$$

\noindent
The transformation matrix represents the operation of rotation and
translation on a coordinate frame originally aligned with the
reference coordinate frame. We may transform the six points of the
object as

$$\left[\matrix{4 &  4 &  6 & 6 &  4 &  4\cr
                1 & -1 & -1 & 1 &  1 & -1\cr
                0 &  0 &  0 & 0 &  4 &  4\cr
                1 &  1 &  1 & 1 &  1 &  1}
  \right]
 = \left[\matrix{0 & 0 & 1 & 4\cr
                 1 & 0 & 0 & 0\cr
                 0 & 1 & 0 & 0\cr
                 0 & 0 & 0 & 1}
  \right]
  \left[\matrix{1 & -1 & -1 & 1 & 1 & -1\cr
                0 &  0 &  0 & 0 & 4 &  4\cr
                0 &  0 &  2 & 2 & 0 &  0\cr
                1 &  1 &  1 & 1 & 1 &  1}
  \right]\eqno(1.53)$$

It can be seen that the object described bears the same fixed
relationship to its coordinate frame, whose position and orientation
are described by the transformation. Given an object described by a
reference coordinate frame, and a transformation representing the
position and orientation of the object's axes, the object can be
simply reconstructed, without the necessity of transforming all the
points, by noting the direction and orientation of key features with
respect to the describing frame's coordinate axes. By drawing the
transformed coordinate frame, the object can be related to the new
axis directions.

\subsection{Inverse Transformations}

\noindent
We are now in a position to develop the inverse transformation as the
transform which carries the transformed coordinate frame back to the
original frame. This is simply the description of the reference
coordinate frame with respect to the transformed frame. Suppose the
direction of the reference frame $x$ axis is $[0,0,1,0]^{\rm T}$ with
respect to the transformed frame. The $y$ and $z$ axes are 
$[1,0,0,0]^{\rm T}$ and $[0,1,0,0]^{\rm T}$, respectively. The
location of the origin is $[0,0,-4,1]^{\rm T}$ with respect to the
transformed frame and thus the inverse transformation is

$${\bf T^{-1}} = \left[\matrix{0 & 1 & 0 &  0\cr
                               0 & 0 & 1 &  0\cr
                               1 & 0 & 0 & -4\cr
                               0 & 0 & 0 &  1}
                 \right]\eqno(1.54)$$

\noindent
That this is indeed the tranform inverse is easily verifyed by
multiplying it by the transform {\bf T} to obtain the identity
transform 

$$\left[\matrix{1 & 0 & 0 & 0\cr
                0 & 1 & 0 & 0\cr
                0 & 0 & 1 & 0\cr
                0 & 0 & 0 & 1}
  \right]
 = \left[\matrix{0 & 1 & 0 &  0\cr
                 0 & 0 & 1 &  0\cr
                 1 & 0 & 0 & -4\cr
                 0 & 0 & 0 &  1}
   \right]
   \left[\matrix{0 & 0 & 1 & 4\cr
                 1 & 0 & 0 & 0\cr
                 0 & 1 & 0 & 0\cr
                 0 & 0 & 0 & 1}
   \right]\eqno(1.55)$$ 

\noindent
In general, given a transform with elements

$${\bf T} = \left[\matrix{n_x & o_x & a_x & p_x\cr
                          n_y & o_y & a_y & p_y\cr
                          n_z & o_z & a_z & p_z\cr
                            0 &   0 &   0 &   1}
            \right]\eqno(1.56)$$

\noindent
then the inverse is

$${\bf T^{-1}} = \left[\matrix{n_x & n_y & n_z & -{\bf p} \cdot {\bf n}\cr
                               o_x & o_y & o_z & -{\bf p} \cdot {\bf o}\cr
                               a_x & a_y & a_z & -{\bf p} \cdot {\bf a}\cr
                                 0 &   0 &   0 &   1}
                 \right]\eqno(1.57)$$

\noindent
where {\bf p}, {\bf n}, {\bf o}, and {\bf a} are the four column
vectors and ``$\cdot$'' represents the vector dot product. This result
is easily verified by postmultiplying Equation 1.56 by Equation 1.57.

\subsection{General Rotation Transformation}

\noindent
We state the rotation transformations for rotations about the $x$,
$y$, and $z$ axes (Equations 1.32, 1.33 and 1.34). These
transformations have a simple geometric interpretation. For example,
in the case of a rotation about the $z$ axis, the column representing
the $z$ axis will remain constant, while the column elements
representing the $x$ and $y$ axes will vary.

\noindent
We will now develop the transformation matrix representing a rotation
around an arbitrary vector {\bf k} located at the origin. In order to
do this we will imagine that {\bf k} is the $z$ axis unit vector of a
coordinate frame {\bf C} 

$${\bf C} = \left[\matrix{n_x & o_x & a_x & p_x\cr
                          n_y & o_y & a_y & p_y\cr
                          n_z & o_z & a_z & p_z\cr
                            0 &   0 &   0 &   1}
            \right]\eqno(1.58)$$

$${\bf k} = a_x{\bf i} + a_y{\bf j} + a_z{\bf k}\eqno(1.59)$$

\noindent
Rotating around the vector {\bf k} is then equivalent to rotating
around the $z$ axis of the frame {\bf C}.

$${\bf Rot(k,\theta)} = {\bf Rot(^C{\bf z},\theta)}\eqno(1.60)$$

\noindent
If we are given a frame {\bf T} described with respect to the
reference coordinate frame, we can find a frame {\bf X} which
describes the same frame with respect to frame {\bf C} as

$${\bf T} = {\bf C} {\bf X}\eqno(1.61)$$

\noindent
where {\bf X} describes the position of {\bf T} with respect to frame
{\bf C}. Solving for {\bf X} we obtain

$${\bf X} = {\bf C^{-1}} {\bf T}\eqno(1.62)$$

\noindent
Rotation {\bf T} around {\bf k} is equivalent to rotating {\bf X}
around the $z$ axis of frame {\bf C}

$${\bf Rot(k,\theta)} {\bf T}
    = {\bf C} {\bf Rot(z,\theta)} {\bf X}\eqno(1.63)$$

$${\bf Rot(k,\theta)} {\bf T}
    = {\bf C} {\bf Rot(z,\theta)} {\bf C^{-1}} {\bf T}.\eqno(1.64)$$

\noindent
Thus

$${\bf Rot(k,\theta)} 
    = {\bf C} {\bf Rot(z,\theta)} {\bf C^{-1}}\eqno(1.65)$$

\noindent
However, we have only {\bf k}, the $z$ axis of the frame {\bf C}. By
expanding equation 1.65 we will discover that 
${\bf C} {\bf Rot(z,\theta)} {\bf C^{-1}}$ is a function of {\bf k}
only. 

Multiplying ${\bf Rot(z,\theta)}$ on the right by ${\bf C^{-1}}$ we
obtain 

$${\bf Rot(z,\theta)} {\bf C^{-1}}
   = \left[\matrix{cos \theta & -sin \theta & 0 & 0\cr
                   sin \theta &  cos \theta & 0 & 0\cr
                            0 &           0 & 1 & 0\cr
                            0 &           0 & 0 & 1}
     \right]
     \left[\matrix{n_x & n_y & n_z & 0\cr
                   o_x & o_x & o_z & 0\cr
                   a_x & a_y & a_z & 0\cr
                     0 &   0 &   0 & 1}
      \right]$$

$$ = \left[\matrix{n_x cos \theta - o_x sin \theta & 
                   n_y cos \theta - o_y sin \theta &
                   n_z cos \theta - o_z sin \theta & 0\cr
                   n_x sin \theta + o_x cos \theta &
                   n_y sin \theta + o_y cos \theta &
                   n_z sin \theta + o_z cos \theta & 0\cr
                   a_x & a_y & a_z & 0\cr
                     0 &   0 &   0 & 1}
     \right]\eqno(1.66)$$

\noindent
premultiplying by

$${\bf C} = \left[\matrix{n_x & o_x & a_x & 0\cr
                          n_y & o_y & a_y & 0\cr
                          n_z & o_z & a_z & 0\cr
                            0 &   0 &   0 & 1}
            \right]\eqno(1.67)$$

\noindent
we obtain ${\bf C} {\bf Rot(z,\theta)} {\bf C^{-1}}$

$$\left[\matrix{
n_x n_x cos \theta - n_x o_x sin \theta + n_x o_x sin \theta + o_x o_x
cos \theta + a_x a_x\cr
n_y n_x cos \theta - n_y o_x sin \theta + n_x o_y sin \theta + o_x o_y
cos \theta + a_y a_x\cr
n_z n_x cos \theta - n_z o_x sin \theta + n_x o_z sin \theta + o_x o_z
cos \theta + a_z a_x\cr
0}
\right.$$

$$\matrix{
n_x n_y cos \theta - n_x o_y sin \theta + n_y o_x sin \theta + o_y o_x
cos \theta + a_x a_y\cr
n_y n_y cos \theta - n_y o_y sin \theta + n_y o_y sin \theta + o_y o_y
cos \theta + a_y a_y\cr
n_z n_y cos \theta - n_z o_y sin \theta + n_y o_z sin \theta + o_y o_z
cos \theta + a_z a_y\cr
0}\eqno(1.68)$$

$$\left.\matrix{
n_x n_z cos \theta - n_x o_z sin \theta + n_z o_x sin \theta + o_z o_x
cos \theta + a_x a_x & 0\cr
n_y n_z cos \theta - n_y o_z sin \theta + n_z o_y sin \theta + o_z o_y
cos \theta + a_y a_z & 0\cr
n_z n_z cos \theta - n_z o_z sin \theta + n_z o_z sin \theta + o_z o_z
cos \theta + a_z a_z & 0\cr
0 & 1}
\right]$$

\noindent
Simplifying, using the following relationships:\\
the dot product of any row or column of {\bf C} with any other row or
column is zero, as the vectors are orthogonal;\\
the dot product of any row or column of {\bf C} with itself is {\bf 1}
as the vectors are of unit magnitude;\\
the $z$ unit vector is the vector cross product of the $x$ and $y$
vectors or
$${\bf a} = {\bf n} \times {\bf o}\eqno(1.69)$$

\noindent
which has components

$$a_x = n_y o_z - n_z o_y$$
$$a_y = n_z o_x - n_x o_z$$
$$a_z = n_x o_y - n_y o_x$$

\noindent
the versine, abbreviated ${\bf vers \ \theta}$, is defined as 
${\bf vers \ \theta} = (1 - cos \ \theta)$,
${k_x = a_x}$, ${k_y = a_y}$ and ${k_z = a_z}$. 
We obtain ${\bf Rot(k,\theta)} =$
$$\left[\matrix{
k_x k_x vers \theta + cos \theta & 
k_y k_x vers \theta - k_z sin \theta &
k_z k_x vers \theta + k_y sin \theta & 
0\cr
k_x k_y vers \theta + k_z sin \theta &
k_y k_y vers \theta + cos \theta &
k_z k_y vers \theta - k_x sin \theta & 
0\cr
k_x k_z vers \theta - k_y sin \theta &
k_y k_z vers \theta + k_x sin \theta &
k_z k_z vers \theta + cos \theta &
0\cr
0 & 0 & 0 & 1}
\right]\eqno(1.70)$$

\noindent
This is an important result and should be thoroughly understood before
proceeding further.

From this general rotation transformation we can obtain each of the
elementary rotation transforms. For example ${\bf Rot(x,\theta)}$ is 
${\bf Rot(k,\theta)}$ where ${k_x = 1}$, ${k_y = 0}$, and 
${k_z = 0}$. Substituting these values of {\bf k} into Equation 1.70
we obtain

$${\bf Rot(x,\theta)} = 
\left[\matrix{1 & 0 & 0 & 0\cr
              0 & cos \theta & -sin \theta & 0\cr
              0 & sin \theta &  cos \theta & 0\cr
              0 &          0 &           0 & 1}
\right]\eqno(1.71)$$

\noindent
as before.

\subsection{Equivalent Angle and Axis of Rotation}

\noindent
Given any arbitrary rotational transformation, we can use Equation
1.70 to obtain an axis about which an equivalent rotation $\theta$ is
made as follows. Given a rotational transformation {\bf R}

$${\bf R} = 
\left[\matrix{n_x & o_x & a_x & 0\cr
              n_y & o_y & a_y & 0\cr
              n_z & o_z & a_z & 0\cr
                0 &   0 &   0 & 1}
\right]\eqno(1.72)$$

\noindent
we may equate {\bf R} to {\bf Rot(k,$\theta$)}

$$\left[\matrix{n_x & o_x & a_x & 0\cr
                n_y & o_y & a_y & 0\cr
                n_z & o_z & a_z & 0\cr
                  0 &   0 &   0 & 1}
  \right] = $$
$$\left[\matrix{
k_x k_x vers \theta + cos \theta & 
k_y k_x vers \theta - k_z sin \theta &
k_z k_x vers \theta + k_y sin \theta & 
0\cr
k_x k_y vers \theta + k_z sin \theta &
k_y k_y vers \theta + cos \theta &
k_z k_y vers \theta - k_x sin \theta & 
0\cr
k_x k_z vers \theta - k_y sin \theta &
k_y k_z vers \theta + k_x sin \theta &
k_z k_z vers \theta + cos \theta &
0\cr
0 & 0 & 0 & 1}
\right]\eqno(1.73)$$

\noindent
Summing the diagonal terms of Equation 1.73 we obtain

$$n_x+o_y+a_z+1=
k_x^2 vers \theta + cos \theta + 
k_y^2 vers \theta + cos \theta +
k_z^2 vers \theta + cos \theta + 1\eqno(1.74)$$

$$\left.\matrix{ n_x+o_y+a_z & = & 
                   (k_x^2+k_y^2+k_z^2)vers \theta + 3 cos \theta\cr
                             & = & 1 + 2 cos \theta}
  \right.\eqno(1.75)$$

\noindent
and the cosine of the angle of rotation is

$$cos \theta = {1\over 2}(n_x+o_y+a_z-1)\eqno(1.76)$$

\noindent
Differencing pairs of off-diagonal terms in Equation 1.73 we obtain 

$$o_z - a_y = 2 k_x sin \theta\eqno(1.77)$$
$$a_x - n_z = 2 k_y sin \theta\eqno(1.78)$$
$$n_y - o_x = 2 k_z sin \theta\eqno(1.79)$$

\noindent
Squaring and adding Equations 1.77-1.79 we obtain an expression for
$sin \theta$

$$(o_z - a_y)^2 + (a_x - n_z)^2 + (n_y - o_x)^2
    = 4 sin^2 \theta\eqno(1.80)$$ 

\noindent
and the sine of the angle of rotation is

$$sin \ \theta = 
  \pm {1\over 2} \sqrt{(o_z - a_y)^2 + (a_x - n_z)^2 + (n_y - o_x)^2}
  \eqno(1.81)$$

\noindent
We may define the rotation to be positive about the vector {\bf k}
such that $0 \leq \theta \leq 180^\circ$. In this case the $+$ sign
is appropriate in Equation 1.81 and thus the angle of rotation
$\theta$ is uniquely defined as

$$tan \ \theta =
 {\sqrt{(o_z - a_y)^2 + (a_x - n_z)^2 + (n_y - o_x)^2}
  \over
  {(n_x + o_y + a_z -1)}}\eqno(1.82)$$

\noindent
The components of {\bf k} may be obtained from Equations 1.77-1.79 as

$$k_x = {{o_z - a_y}\over{2 sin \theta}}\eqno(1.83)$$
$$k_y = {{a_x - n_z}\over{2 sin \theta}}\eqno(1.84)$$
$$k_z = {{n_y - o_x}\over{2 sin \theta}}\eqno(1.85)$$

When the angle of rotation is very small, the axis of rotation is
physically not well defined due to the small magnitude of both
numerator and denominator in Equations 1.83-1.85. If the resulting
angle is small, the vector {\bf k} should be renormalized to ensure
that $\left|{\bf k}\right| = 1$. When the angle of rotation approaches
$180^\circ$ the vector {\bf k} is once again poorly defined by
Equation 1.83-1.85 as the magnitude of the sine is again
decreasing. The axis of rotation is, however, physically well defined
in this case. When $\theta < 150^\circ$, the denominator of
Equations 1.83-1.85 is less than 1. As the angle increases to
$180^\circ$ the rapidly decreasing magnitude of both numerator and
denominator leads to considerable inaccuracies in the determination of
{\bf k}. At $\theta = 180^\circ$, Equations 1.83-1.85 are of the form
$0/0$, yielding no information at all about a physically well defined
vector {\bf k}. If the angle of rotation is greater than $90^\circ$,
then we must follow a different approach in determining {\bf
k}. Equating the diagonal elements of Equation 1.73 we obtain

$$k_x^2 vers \theta + cos \theta = n_x\eqno(1.86)$$
$$k_y^2 vers \theta + cos \theta = o_y\eqno(1.87)$$
$$k_z^2 vers \theta + cos \theta = a_z\eqno(1.88)$$

Substituting for $cos \theta$ and $vers \theta$ from Equation 1.76 and
solving for the elements of {\bf k} we obtain further

$$k_x = 
 \pm \sqrt{{{n_x - cos \theta}\over{1 - cos \theta}}}\eqno(1.89)$$
$$k_y = 
 \pm \sqrt{{{o_y - cos \theta}\over{1 - cos \theta}}}\eqno(1.90)$$
$$k_z = 
 \pm \sqrt{{{a_z - cos \theta}\over{1 - cos \theta}}}\eqno(1.91)$$

\noindent
The largest component of {\bf k} defined by Equations 1.89-1.91
corresponds to the most positive component of $n_x$, $o_y$, and
$a_z$. For this largest element, the sign of the radical can be
obtained from Equations 1.77-1.79. As the sine of the angle of
rotation $\theta$ must be positive, then the sign of the component of
{\bf k} defined by Equations 1.77-1.79 must be the same as the sign of
the left hand side of these equations. Thus we may combine Equations
1.89-1.91 with the information contained in Equations 1.77-1.79 as
follows 

$$k_x = sgn(o_z-a_y)\sqrt{{{(n_x-cos \theta)}
                          \over
                          {1-cos \theta}}}\eqno(1.92)$$ 

$$k_y = sgn(a_x-n_z)\sqrt{{{(o_y-cos \theta)}
                          \over
                          {1-cos \theta}}}\eqno(1.93)$$

$$k_z = sgn(n_y-o_x)\sqrt{{{(a_z-cos \theta)}
                          \over
                          {1-cos \theta}}}\eqno(1.94)$$

\noindent
where $sgn(e) = +1$ if $e \ge 0$ and $sgn(e) = -1$ if $e \le 0$.

Only the largest element of {\bf k} is determined from Equations
1.92-1.94, corresponding to the most positive element of $n_x$, $o_y$,
and $a_z$. The remaining elements are more accurately determined by
the following equations formed by summing pairs of off-diagonal
elements of Equation 1.73

$$n_y + o_x = 2 k_x k_y vers \theta\eqno(1.95)$$
$$o_z + a_y = 2 k_y k_z vers \theta\eqno(1.96)$$
$$n_z + a_x = 2 k_z k_x vers \theta\eqno(1.97)$$

\noindent
If $k_x$ is largest then

$$k_y = {{n_y + o_x}\over{2 k_x vers \theta}} 
  {\rm \ \ \ \ \ from \ Equation \ 1.95}\eqno(1.98)$$

$$k_z = {{a_x + n_z}\over{2 k_x vers \theta}} 
  {\rm \ \ \ \ \ from \ Equation \ 1.97}\eqno(1.99)$$

\noindent
If $k_y$ is largest then

$$k_x = {{n_y + o_x}\over{2 k_y vers \theta}}
  {\rm \ \ \ \ \ from \ Equation \ 1.95}\eqno(1.100)$$

$$k_z = {{o_z + a_y}\over{2 k_y vers \theta}}
  {\rm \ \ \ \ \ from \ Equation \ 1.96}\eqno(1.101)$$

\noindent
If $k_z$ is largest then

$$k_x = {{a_x + n_z}\over{2 k_z vers \theta}}
  {\rm \ \ \ \ \ from \ Equation \ 1.97}\eqno(1.102)$$

$$k_y = {{o_z + a_y}\over{2 k_z vers \theta}}
  {\rm \ \ \ \ \ from \ Equation \ 1.96}\eqno(1.103)$$

\subsection{Example 1.1}

\noindent
Determine the equivalent axis and angle of rotation for the matrix
given in Equations 1.41

$${\bf Rot(y,90)}{\bf Rot(z,90)} 
  = \left[\matrix{0 & 0 & 1 & 0\cr
                  1 & 0 & 0 & 0\cr
                  0 & 1 & 0 & 0\cr
                  0 & 0 & 0 & 1}
    \right]\eqno(1.104)$$

\noindent
We first determine ${\bf cos \ \theta}$ from Equation 1.76

$$cos \theta = {{1}\over{2}}(0 + 0 + 0 - 1) 
             = -{{1}\over{2}}\eqno(1.105)$$

\noindent
and $sin \ \theta$ from Equation 1.81

$$sin \theta = {{1}\over{2}}\sqrt{(1-0)^2+(1-0)^2+(1-0)^2}
             = {{\sqrt3}\over{2}}\eqno(1.106)$$

\noindent
Thus

$$\theta = tan^{-1}\left({{\sqrt3}\over{2}}
           \raise15pt\hbox{$\bigslash$}
           {{-1}\over{2}}\right)
         = 120^\circ\eqno(1.107)$$

\noindent
As $\theta > 90$, we determine the largest component of {\bf k}
corresponding to the largest element on the diagonal. As all diagonal
elements are equal in this example we may pick any one. We will pick
$k_x$ given by Equation 1.92

$$k_x = +\sqrt{(0 + {{1}\over{2}})
               \raise15pt\hbox{$\bigslash$}
               (1 + {{1}\over{2}})}
      = {{1}\over{\sqrt{3}}}\eqno(1.108)$$

\noindent
As we have determined $k_x$ we may now determine $k_y$ and $k_z$ from
Equations 1.98 and 1.99, respectively

$$k_y = {{1+0}\over{\sqrt{3}}} = {{1}\over{\sqrt{3}}}\eqno(1.109)$$

$$k_z = {{1+0}\over{\sqrt{3}}} = {{1}\over{\sqrt{3}}}\eqno(1.110)$$

\noindent
In summary, then

$${\bf Rot(y,90)}{\bf Rot(z,90)} = {\bf Rot(k,120)}\eqno(1.111)$$

\noindent
where

$${\bf k} = {{1}\over{\sqrt{3}}} {\bf i}
          + {{1}\over{\sqrt{3}}} {\bf j}
          + {{1}\over{\sqrt{3}}} {\bf k}\eqno(1.112)$$

Any combination of rotations is always equivalent to a single rotation
about some axis {\bf k} by an angle $\theta$, an important result
that we will make use of later.

\subsection{Stretching and Scaling}

A transform {\bf T} 

$${\bf T} = \left[\matrix{a & 0 & 0 & 0\cr
                          0 & b & 0 & 0\cr
                          0 & 0 & c & 0\cr
                          0 & 0 & 0 & 1}
            \right]\eqno(1.113)$$

\noindent
will stretch objects uniformly along the $x$ axis by a factor $a$,
along the $y$ axis by a factor $b$, and along the $z$ axis by a factor
$c$. Consider any point on an object $x{\bf i}+y{\bf j}+z{\bf k}$; its
tranform is

$$\left[\matrix{ax\cr
                by\cr
                cz\cr
                 1}
  \right]
  = \left[\matrix{a & 0 & 0 & 0\cr
                  0 & b & 0 & 0\cr
                  0 & 0 & c & 0\cr
                  0 & 0 & 0 & 1}
    \right]
    \left[\matrix{x\cr
                  y\cr
                  z\cr
                  1}
    \right]\eqno(1.114)$$

\noindent
indicating stretching as stated. Thus a cube could be transformed into
a rectangular parallelepiped by such a transform.

The Axiom code to perform this scale change is:

<<scale>>=
    scale(scalex, scaley, scalez) ==
     matrix(_
      [[scalex, 0      ,0     , 0], _
       [0     , scaley ,0     , 0], _
       [0     , 0,      scalez, 0], _
       [0     , 0,      0     , 1]])
@
\noindent
The transform {\bf S} where

$${\bf S} = \left[\matrix{s & 0 & 0 & 0\cr
                          0 & s & 0 & 0\cr
                          0 & 0 & s & 0\cr
                          0 & 0 & 0 & 1}
            \right]\eqno(1.115)$$

\noindent
will scale any object by the factor $s$.

\subsection{Perspective Transformations}

\noindent
Consider the image formed of an object by a simple lens.

The axis of the lens is along the $y$ axis for convenience. An object
point $x$,$y$,$z$ is imaged at $x^\prime$,$y^\prime$,$z^\prime$ if the
lens has a focal length $f$ ($f$ is considered positive). $y^\prime$
represents the image distance and varies with object distance $y$. If
we plot points on a plane perpendicular to the $y$ axis located at
$y^\prime$ (the film plane in a camera), then a perspective image is
formed. 

We will first obtain values of $x^\prime$, $y^\prime$, and $z^\prime$,
then introduce a perspective transformation and show that the same
values are obtained.

Based on the fact that a ray passing through the center of the lens is
undeviated we may write

$${\rm \ \ \ \ \ }{{z}\over{y}} = {{z^\prime}\over{y^\prime}}\eqno(1.116)$$

$${\rm and\ } {{x}\over{y}} = {{x^\prime}\over{y^\prime}}\eqno(1.117)$$

Based on the additional fact that a ray parallel to the lens axis
passes through the focal point $f$, we may write

$${\rm \ \ \ \ \ }{{z}\over{f}} 
    = {{z^\prime}\over{y^\prime + f}}\eqno(1.118)$$

$${\rm and\ } {{x}\over{f}} 
    = {{x^\prime}\over{y^\prime + f}}\eqno(1.119)$$

\noindent
Notice that $x^\prime$, $y^\prime$, and $z^\prime$ are negative and
that $f$ is positive. Eliminating $y^\prime$ between Equations 1.116
and 1.118 we obtain

$${{z}\over{f}} 
    = {{z^\prime}\over{({{z^\prime y}\over{z}} + f)}}\eqno(1.120)$$

\noindent
and solving for $z^\prime$ we obtain the result

$$z^\prime = {{z}\over{(1 - {{y}\over{f}})}}\eqno(1.121)$$

\noindent
Working with Equations 1.117 and 1.119 we can similarly obtain

$$x^\prime = {{x}\over{(1 - {{y}\over{f}})}}\eqno(1.122)$$

\noindent
In order to obtain the image distance $y^\prime$ we rewrite Equations
1.116 and 1.118 as

$${{z}\over{z^\prime}} = {{y}\over{y^\prime}}\eqno(1.123)$$

\noindent
and

$${{z}\over{z^\prime}} = {{f}\over{y^\prime + f}}\eqno(1.124)$$

\noindent
thus

$${{y}\over{y^\prime}} = {{f}\over{y^\prime + f}}\eqno(1.125)$$

\noindent
and solving for $y^\prime$ we obtain the result

$$y^\prime = {{y}\over{(1-{{y}\over{f}})}}\eqno(1.126)$$

The homogeneous transformation {\bf P} which produces the same result
is 

$${\bf P} = \left[\matrix{1 & 0 & 0 & 0\cr
                          0 & 1 & 0 & 0\cr
                          0 & 0 & 1 & 0\cr
                          0 & -{{1}\over{f}} & 0 & 1}
            \right]\eqno(1.127)$$

\noindent
as any point $x{\bf i}+y{\bf j}+z{\bf k}$ transforms as

$$\left[\matrix{x\cr
                y\cr
                z\cr
                {1 - {{{y}\over{f}}}}}
   \right]
 = \left[\matrix{1 & 0 & 0 & 0\cr
                 0 & 1 & 0 & 0\cr
                 0 & 0 & 1 & 0\cr
                 0 & -{{1}\over{f}} & 0 & 1}
    \right]
    \left[\matrix{x\cr
                  y\cr
                  z\cr
                  1}
    \right]\eqno(1.128)$$

\noindent
The image point $x^\prime$, $y^\prime$,, $z^\prime$, obtained by
dividing through by the weight factor $(1 - {{y}\over{f}})$, is

$${{x}\over{(1 - {{y}\over{f}})}}{\bf i} +
  {{y}\over{(1 - {{y}\over{f}})}}{\bf j} +
  {{z}\over{(1 - {{y}\over{f}})}}{\bf k} \eqno(1.129)$$

\noindent
This is the same result that we obtained above.

A transform similar to {\bf P} but with $-{{1}\over{f}}$ at the bottom
of the first column produces a perspective transformation along the
$x$ axis. If the $-{{1}\over{f}}$ term is in the third column then the
projection is along the $z$ axis.

\subsection{Transform Equations}

\noindent We will frequently be required to deal with transform
equations in which a coordinate frame is described in two or more
ways.  A manipulator is positioned with respect to base coordinates by
a transform {\bf Z}. The end of the manipulator is described by a
transform $^Z{\bf T}_6$, and the end effector is described by
$^{T_6}{\bf E}$. An object is positioned with respect to base
coordinates by a transform {\bf B}, and finally the manipulator end
effector is positioned with respect to the object by $^B{\bf G}$. We
have two descriptions of the position of the end effector, one with
respect to the object and one with respect to the manipulator. As both
positions are the same, we may equate the two descriptions

$${\bf Z}{^Z{\bf T}_6}{^{T_6}{\bf E}}
   = {\bf B}{^B{\bf G}}\eqno(1.130)$$

If we wish to solve Equation 1.130 for the manipulator transform 
${\bf T}_6$ we must premultiply Equation 1.130 by ${\bf Z}^{-1}$ and
postmultiply by ${\bf E}^{-1}$ to obtain

$${\bf T}_6 
 = {{\bf Z}^{-1}} {\bf B} {\bf G} {{\bf E}^{-1}}\eqno(1.131)$$

\noindent
As a further example, consider that the position of the object {\bf B}
is unknown, but that the manipulator is moved such that the end
effector is positioned over the object correctly. We may then solve
for {\bf B} from Equation 1.130 by postmultiplying by ${\bf G}^{-1}$.

$${\bf B} = {\bf Z}{{\bf T}_6}{\bf E}{{\bf G}^{-1}}\eqno(1.133)$$

\subsection{Summary}

\noindent
Homogeneous transformations may be readily used to describe the
positions and orientations of coordinate frames in space. If a
coordinate frame is embedded in an object then the position and
orientation of the object are also readily described.

The description of object A in terms of object B by means of a
homogeneous transformation may be inverted to obtain the description
of object B in terms of object A. This is not a property of a simple
vector description of the relative displacement of one object with
respect to another.

Transformations may be interpreted as a product of rotation and
translation transformations. If they are intrepreted from left to
right, then the rotations and translations are in terms of the
currently defined coordinate frame. If they are interpreted from right
to left, then the rotations and translations are described with
respect to the reference coordinate frame.

Homogeneous transformations describe coordinate frames in terms of
rectangular components, which are the sines and cosines of
angles. This description may be related to rotations in which case the
description is in terms of a vector and angle of rotation.

\pagehead{DenavitHartenbergMatrix}{DHMATRIX}
\pagepic{ps/v103denavithartenbergmatrix.ps}{DHMATRIX}{1.00}
<<domain DHMATRIX DenavitHartenbergMatrix>>=

++ 4x4 Matrices for coordinate transformations
++ Author: Timothy Daly
++ Date Created: June 26, 1991
++ Date Last Updated: 26 June 1991
++ Description:
++   This package contains functions to create 4x4 matrices
++   useful for rotating and transforming coordinate systems.
++   These matrices are useful for graphics and robotics.
++   (Reference: Robot Manipulators Richard Paul MIT Press 1981) 
 
 
)abbrev domain DHMATRIX DenavitHartenbergMatrix
 
--% DHMatrix

DenavitHartenbergMatrix(R): Exports == Implementation where
  ++ A Denavit-Hartenberg Matrix is a 4x4 Matrix of the form:
  ++  \spad{nx ox ax px}
  ++  \spad{ny oy ay py}
  ++  \spad{nz oz az pz}
  ++   \spad{0  0  0  1}
  ++ (n, o, and a are the direction cosines)
  R : Join(Field,  TranscendentalFunctionCategory)

-- for the implementation of dhmatrix
  minrow ==> 1
  mincolumn ==> 1
--
  nx ==> x(1,1)::R
  ny ==> x(2,1)::R
  nz ==> x(3,1)::R
  ox ==> x(1,2)::R
  oy ==> x(2,2)::R
  oz ==> x(3,2)::R
  ax ==> x(1,3)::R
  ay ==> x(2,3)::R
  az ==> x(3,3)::R
  px ==> x(1,4)::R
  py ==> x(2,4)::R
  pz ==> x(3,4)::R
  row ==> Vector(R)
  col ==> Vector(R)
  radians ==> pi()/180

  Exports ==> MatrixCategory(R,row,col) with
   "*": (%, Point R) -> Point R
     ++ t*p applies the dhmatrix t to point p
   identity: () -> %
     ++ identity() create the identity dhmatrix
   rotatex: R -> %
     ++ rotatex(r) returns a dhmatrix for rotation about axis X for r degrees
   rotatey: R -> %
     ++ rotatey(r) returns a dhmatrix for rotation about axis Y for r degrees
   rotatez: R -> %
     ++ rotatez(r) returns a dhmatrix for rotation about axis Z for r degrees
   scale: (R,R,R) -> %
     ++ scale(sx,sy,sz) returns a dhmatrix for scaling in the X, Y and Z
     ++ directions
   translate: (R,R,R) -> %
     ++ translate(X,Y,Z) returns a dhmatrix for translation by X, Y, and Z
 
  Implementation ==> Matrix(R) add

    identity() == matrix([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])

--    inverse(x) == (inverse(x pretend (Matrix R))$Matrix(R)) pretend %
--    dhinverse(x) == matrix( _
--        [[nx,ny,nz,-(px*nx+py*ny+pz*nz)],_
--         [ox,oy,oz,-(px*ox+py*oy+pz*oz)],_
--         [ax,ay,az,-(px*ax+py*ay+pz*az)],_
--         [ 0, 0, 0, 1]])

    d * p ==
       v := p pretend Vector R
       v := concat(v, 1$R)
       v := d * v
       point ([v.1, v.2, v.3]$List(R))

<<rotatex>>

<<rotatey>>

<<rotatez>>

<<scale>>

<<translate>>
 
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain DEQUEUE Dequeue}
<<dot>>=
"DEQUEUE" -> "DQAGG"
"Dequeue(a:SetCategory)" -> "DequeueAggregate(a:SetCategory)"
@
\pagehead{Dequeue}{DEQUEUE}
\pagepic{ps/v103dequeue.ps}{DEQUEUE}{1.00}
<<domain DEQUEUE Dequeue>>=
)abbrev domain DEQUEUE Dequeue
++ Author: Michael Monagan and Stephen Watt
++ Date Created:June 86 and July 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
 
++ Linked list implementation of a Dequeue
--% Dequeue and Heap data types
 
Dequeue(S:SetCategory): DequeueAggregate S with
     dequeue: List S -> %
       ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
       ++ element x, second element y,...,and last (bottom or back) element z.
       ++
       ++E g:Dequeue INT:= dequeue [1,2,3,4,5]

  == Queue S add
    Rep := Reference List S
    bottom_! d ==
         if empty? d then error "empty dequeue" else last deref d
    dequeue d == ref copy d
    extractBottom_! d ==
        if empty? d then error "empty dequeue"
        p := deref d
        n := maxIndex p
        n = 1 =>
           r := first p
           setref(d,[])
           r
        q := rest(p,(n-2)::NonNegativeInteger)
        r := first rest q
        q.rest := []
        r
    extractTop_! d ==
        e := top d
        setref(d,rest deref d)
        e
    height d == # deref d
    insertTop_!(e,d) == (setref(d,cons(e,deref d)); e)
    lastTail==> LAST$Lisp
    insertBottom_!(e,d) ==
        if empty? d then setref(d, list e)
        else lastTail.(deref d).rest := list e
        e
    top d == if empty? d then error "empty dequeue" else first deref d
    reverse_! d == (setref(d,reverse deref d); d)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter F}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain FARRAY FlexibleArray}
<<FlexibleArray.input>>=
-- array1.spad.pamphlet FlexibleArray.input
)spool FlexibleArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 16
flexibleArray [i for i in 1..6]
--R 
--R
--R   (1)  [1,2,3,4,5,6]
--R                                          Type: FlexibleArray PositiveInteger
--E 1

--S 2 of 16
f : FARRAY INT := new(6,0)
--R 
--R
--R   (2)  [0,0,0,0,0,0]
--R                                                  Type: FlexibleArray Integer
--E 2

--S 3 of 16
for i in 1..6 repeat f.i := i; f
--R 
--R
--R   (3)  [1,2,3,4,5,6]
--R                                                  Type: FlexibleArray Integer
--E 3

--S 4 of 16
physicalLength f
--R 
--R
--R   (4)  6
--R                                                        Type: PositiveInteger
--E 4

--S 5 of 16
concat!(f,11)
--R 
--R
--R   (5)  [1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 5

--S 6 of 16
physicalLength f
--R 
--R
--R   (6)  10
--R                                                        Type: PositiveInteger
--E 6

--S 7 of 16
physicalLength!(f,15)
--R 
--R
--R   (7)  [1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 7

--S 8 of 16
concat!(f,f)
--R 
--R
--R   (8)  [1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 8

--S 9 of 16
insert!(22,f,1)
--R 
--R
--R   (9)  [22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 9

--S 10 of 16
g := f(10..)
--R 
--R
--R   (10)  [2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 10

--S 11 of 16
insert!(g,f,1)
--R 
--R
--R   (11)  [2,3,4,5,6,11,22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
--R                                                  Type: FlexibleArray Integer
--E 11

--S 12 of 16
merge!(sort! f, sort! g)
--R 
--R
--R   (12)  [1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,11,11,11,11,22]
--R                                                  Type: FlexibleArray Integer
--E 12

--S 13 of 16
removeDuplicates! f
--R 
--R
--R   (13)  [1,2,3,4,5,6,11,22]
--R                                                  Type: FlexibleArray Integer
--E 13

--S 14 of 16
select!(i +-> even? i,f)
--R 
--R
--R   (14)  [2,4,6,22]
--R                                                  Type: FlexibleArray Integer
--E 14

--S 15 of 16
physicalLength f
--R 
--R
--R   (15)  8
--R                                                        Type: PositiveInteger
--E 15

--S 16 of 16
shrinkable(false)$FlexibleArray(Integer)
--R 
--R
--R   (16)  true
--R                                                                Type: Boolean
--E 16
)spool
)lisp (bye)
@
<<FlexibleArray.help>>=
====================================================================
FlexibleArray
====================================================================

The FlexibleArray domain constructor creates one-dimensional
arrays of elements of the same type.  Flexible arrays are an attempt
to provide a data type that has the best features of both
one-dimensional arrays (fast, random access to elements) and lists
(flexibility).  They are implemented by a fixed block of storage.
When necessary for expansion, a new, larger block of storage is
allocated and the elements from the old storage area are copied into
the new block.

Flexible arrays have available most of the operations provided by
OneDimensionalArray Vector.  Since flexible arrays are also of
category ExtensibleLinearAggregate they have operations concat!,
delete!, insert!, merge!, remove!, removeDuplicates!, and select!.  In
addition, the operations physicalLength and physicalLength! provide
user-control over expansion and contraction.

A convenient way to create a flexible array is to apply the operation
flexibleArray to a list of values.

  flexibleArray [i for i in 1..6]
    [1,2,3,4,5,6]
                     Type: FlexibleArray PositiveInteger

Create a flexible array of six zeroes.

  f : FARRAY INT := new(6,0)
    [0,0,0,0,0,0]
                     Type: FlexibleArray Integer

For i=1..6 set the i-th element to i.  Display f.

  for i in 1..6 repeat f.i := i; f
    [1,2,3,4,5,6]
                     Type: FlexibleArray Integer

Initially, the physical length is the same as the number of elements.

  physicalLength f
    6
                     Type: PositiveInteger

Add an element to the end of f.

  concat!(f,11)
    [1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

See that its physical length has grown.

  physicalLength f
    10
                     Type: PositiveInteger

Make f grow to have room for 15 elements.

  physicalLength!(f,15)
    [1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Concatenate the elements of f to itself.  The physical length
allows room for three more values at the end.

  concat!(f,f)
    [1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Use insert! to add an element to the front of a flexible array.

  insert!(22,f,1)
    [22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Create a second flexible array from f consisting of the elements from
index 10 forward.

  g := f(10..)
    [2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Insert this array at the front of f.

  insert!(g,f,1)
    [2,3,4,5,6,11,22,1,2,3,4,5,6,11,1,2,3,4,5,6,11]
                     Type: FlexibleArray Integer

Merge the flexible array f into g after sorting each in place.

  merge!(sort! f, sort! g)
    [1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,11,11,11,11,22]
                     Type: FlexibleArray Integer

Remove duplicates in place.

  removeDuplicates! f
    [1,2,3,4,5,6,11,22]
                     Type: FlexibleArray Integer

Remove all odd integers.

  select!(i +-> even? i,f)
    [2,4,6,22]
                     Type: FlexibleArray Integer

All these operations have shrunk the physical length of f.

  physicalLength f
    8
                     Type: PositiveInteger

To force Axiom not to shrink flexible arrays call the shrinkable
operation with the argument false.  You must package call this
operation.  The previous value is returned.

  shrinkable(false)$FlexibleArray(Integer)
    true
                     Type: Boolean

See Also:
o )help OneDimensionalArray
o )help Vector
o )help ExtensibleLinearAggregate
o )show FlexibleArray
o $AXIOM/doc/src/algebra/array1.spad.dvi

@
<<dot>>=
"FARRAY" -> "IFARRAY"
"FlexibleArray(a:Type)" -> "IndexedFlexibleArray(a:Type,1)"
@
\pagehead{FlexibleArray}{FARRAY}
\pagepic{ps/v103flexiblearray.ps}{FARRAY}{1.00}
<<domain FARRAY FlexibleArray>>=
)abbrev domain FARRAY FlexibleArray
++ A FlexibleArray is the notion of an array intended to allow for growth
++ at the end only.  Hence the following efficient operations
++   \spad{append(x,a)} meaning append item x at the end of the array \spad{a}
++   \spad{delete(a,n)} meaning delete the last item from the array \spad{a}
++ Flexible arrays support the other operations inherited from
++ \spadtype{ExtensibleLinearAggregate}. However, these are not efficient.
++ Flexible arrays combine the \spad{O(1)} access time property of arrays
++ with growing and shrinking at the end in \spad{O(1)} (average) time.
++ This is done by using an ordinary array which may have zero or more
++ empty slots at the end.  When the array becomes full it is copied
++ into a new larger (50% larger) array.  Conversely, when the array
++ becomes less than 1/2 full, it is copied into a smaller array.
++ Flexible arrays provide for an efficient implementation of many
++ data structures in particular heaps, stacks and sets.

FlexibleArray(S: Type) == Implementation where
  ARRAYMININDEX ==> 1       -- if you want to change this, be my guest
  Implementation ==> IndexedFlexibleArray(S, ARRAYMININDEX)
-- Join(OneDimensionalArrayAggregate S, ExtensibleLinearAggregate S)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter G}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter H}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain HEAP Heap}
<<Heap.input>>=
-- bags.spad.pamphlet Heap.input
)spool Heap.output
)set message test on
)set message auto off
)clear all
--S 1 of 8
h := heap [-4,9,11,2,7,-7]
--R 
--R
--R   (1)  [11,7,9,- 4,2,- 7]
--R                                                           Type: Heap Integer
--E 1

--S 2 of 8
insert!(3,h)
--R 
--R
--R   (2)  [11,7,9,- 4,2,- 7,3]
--R                                                           Type: Heap Integer
--E 2

--S 3 of 8
extract! h
--R 
--R
--R   (3)  11
--R                                                        Type: PositiveInteger
--E 3

--S 4 of 8
h
--R 
--R
--R   (4)  [9,7,3,- 4,2,- 7]
--R                                                           Type: Heap Integer
--E 4

--S 5 of 8
[extract!(h) while not empty?(h)]
--R 
--R
--R   (5)  [9,7,3,2,- 4,- 7]
--R                                                           Type: List Integer
--E 5

--S 6 of 8
heapsort(x) == (empty? x => []; cons(extract!(x),heapsort x))
--R 
--R                                                                   Type: Void
--E 6

--S 7 of 8
h1 := heap [17,-4,9,-11,2,7,-7]
--R 
--R
--R   (7)  [17,2,9,- 11,- 4,7,- 7]
--R                                                           Type: Heap Integer
--E 7

--S 8 of 8
heapsort h1
--R 
--R   Compiling function heapsort with type Heap Integer -> List Integer 
--R
--R   (8)  [17,9,7,2,- 4,- 7,- 11]
--R                                                           Type: List Integer
--E 8
)spool
)lisp (bye)
@
<<Heap.help>>=
====================================================================
Heap examples
====================================================================

The domain Heap(S) implements a priority queue of objects of type S
such that the operation extract! removes and returns the maximum
element.  The implementation represents heaps as flexible arrays The
representation and algorithms give complexity of O(log(n)) for
insertion and extractions, and O(n) for construction.

Create a heap of six elements.

  h := heap [-4,9,11,2,7,-7]
    [11,7,9,- 4,2,- 7]
                      Type: Heap Integer

Use insert! to add an element.

  insert!(3,h)
    [11,7,9,- 4,2,- 7,3]
                      Type: Heap Integer

The operation extract! removes and returns the maximum element.

  extract! h
    11
                      Type: PositiveInteger

The internal structure of h has been appropriately adjusted.

  h
    [9,7,3,- 4,2,- 7]
                      Type: Heap Integer

Now extract! elements repeatedly until none are left, collecting
the elements in a list.

  [extract!(h) while not empty?(h)]
    [9,7,3,2,- 4,- 7]
                      Type: List Integer

Another way to produce the same result is by defining a heapsort function.

  heapsort(x) == (empty? x => []; cons(extract!(x),heapsort x))
                      Type: Void

Create another sample heap.

  h1 := heap [17,-4,9,-11,2,7,-7]
    [17,2,9,- 11,- 4,7,- 7]
                      Type: Heap Integer

Apply heapsort to present elements in order.

  heapsort h1
    [17,9,7,2,- 4,- 7,- 11]
                      Type: List Integer

See Also:
o )help FlexibleArray
o )show Heap
o $AXIOM/doc/src/algebra/bags.spad.dvi

@
<<dot>>=
"HEAP" -> "PRQAGG"
"Heap(a:OrderedSet)" -> "PriorityQueueAggregate(a:OrderedSet)"
@
\pagehead{Heap}{HEAP}
\pagepic{ps/v103heap.ps}{HEAP}{1.00}
<<domain HEAP Heap>>=
)abbrev domain HEAP Heap
++ Author: Michael Monagan and Stephen Watt
++ Date Created:June 86 and July 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
 
++ Heap implemented in a flexible array to allow for insertions
++ Complexity: O(log n) insertion, extraction and O(n) construction
--% Dequeue and Heap data types
 
Heap(S:OrderedSet): Exports == Implementation where 
  Exports == PriorityQueueAggregate S with
    heap : List S -> %
      ++ heap(ls) creates a heap of elements consisting of the 
      ++ elements of ls.
      ++
      ++E i:Heap INT := heap [1,6,3,7,5,2,4]

  Implementation == IndexedFlexibleArray(S,0) add
    Rep := IndexedFlexibleArray( S,0)
    empty() == empty()$Rep
    heap l == 
      n := #l
      h := empty()
      n = 0 => h
      for x in l repeat insert_!(x,h)
      h
    siftUp: (%,Integer,Integer) -> Void
    siftUp(r,i,n) ==
       -- assertion 0 <= i < n
       t := r.i
       while (j := 2*i+1) < n repeat
          if (k := j+1) < n and r.j < r.k then j := k
          if t < r.j then (r.i := r.j; r.j := t; i := j) else leave
 
    extract_! r ==
       -- extract the maximum from the heap O(log n)
       n := #r :: Integer
       n = 0 => error "empty heap"
       t := r(0)
       r(0) := r(n-1)
       delete_!(r,n-1)
       n = 1 => t
       siftUp(r,0,n-1)
       t
 
    insert_!(x,r) ==
       -- Williams' insertion algorithm O(log n)
       j := (#r) :: Integer
       r:=concat_!(r,concat(x,empty()$Rep))
       while j > 0 repeat
          i := (j-1) quo 2
          if r(i) >= x then leave
          r(j) := r(i)
          j := i
       r(j):=x
       r
 
    max r == if #r = 0 then error "empty heap" else r.0
    inspect r == max r
 
    makeHeap(r:%):% ==
       -- Floyd's heap construction algorithm O(n)
       n := #r
       for k in n quo 2 -1 .. 0 by -1 repeat siftUp(r,k,n)
       r
    bag l == makeHeap construct(l)$Rep
    merge(a,b) == makeHeap concat(a,b)
    merge_!(a,b) == makeHeap concat_!(a,b)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter I}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ICARD IndexCard}
<<dot>>=
"ICARD" -> "ORDSET"
"IndexCard()" -> "OrderedSet()"
@
\pagehead{IndexCard}{ICARD}
\pagepic{ps/v103indexcard.ps}{ICARD}{1.00}
<<domain ICARD IndexCard>>=
)abbrev domain ICARD IndexCard
++ This domain implements a container of information
++ about the AXIOM library
IndexCard() : Exports == Implementation where
  Exports == OrderedSet with
    elt: (%,Symbol) -> String
      ++ elt(ic,s) selects a particular field from \axiom{ic}.  Valid fields
      ++ are \axiom{name, nargs, exposed, type, abbreviation, kind, origin,
      ++ params, condition, doc}.
    display: % -> Void
      ++ display(ic) prints a summary of information contained in \axiom{ic}.
    fullDisplay: % -> Void
      ++ fullDisplay(ic) prints all of the information contained in \axiom{ic}.
    coerce: String -> %
      ++ coerce(s) converts \axiom{s} into an \axiom{IndexCard}.  Warning: if
      ++ \axiom{s} is not of the right format then an error will occur 
  Implementation == add
    x<y==(x pretend String) < (y pretend String)
    x=y==(x pretend String) = (y pretend String)
    display(x) ==
      name : OutputForm := dbName(x)$Lisp
      type : OutputForm := dbPart(x,4,1$Lisp)$Lisp
      output(hconcat(name,hconcat(" : ",type)))$OutputPackage
    fullDisplay(x) ==
      name : OutputForm := dbName(x)$Lisp
      type : OutputForm := dbPart(x,4,1$Lisp)$Lisp
      origin:OutputForm := 
          hconcat(alqlGetOrigin(x$Lisp)$Lisp,alqlGetParams(x$Lisp)$Lisp)
      fromPart : OutputForm := hconcat(" from ",origin)
      condition : String := dbPart(x,6,1$Lisp)$Lisp
      ifPart : OutputForm :=
        condition = "" => empty()
        hconcat(" if ",condition::OutputForm)
      exposed? : String := SUBSTRING(dbPart(x,3,1)$Lisp,0,1)$Lisp 
      exposedPart : OutputForm := 
        exposed? = "n" => " (unexposed)"
        empty()       
      firstPart := hconcat(name,hconcat(" : ",type))
      secondPart := hconcat(fromPart,hconcat(ifPart,exposedPart))
      output(hconcat(firstPart,secondPart))$OutputPackage
    coerce(s:String): % == (s pretend %)
    coerce(x): OutputForm == (x pretend String)::OutputForm
    elt(x,sel) ==
      s := PNAME(sel)$Lisp pretend String
      s = "name" => dbName(x)$Lisp
      s = "nargs" => dbPart(x,2,1$Lisp)$Lisp
      s = "exposed" => SUBSTRING(dbPart(x,3,1)$Lisp,0,1)$Lisp 
      s = "type" => dbPart(x,4,1$Lisp)$Lisp
      s = "abbreviation" => dbPart(x,5,1$Lisp)$Lisp
      s = "kind" => alqlGetKindString(x)$Lisp
      s = "origin" => alqlGetOrigin(x)$Lisp
      s = "params" => alqlGetParams(x)$Lisp
      s = "condition" => dbPart(x,6,1$Lisp)$Lisp
      s = "doc" => dbComments(x)$Lisp
      error "unknown selector"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain IBITS IndexedBits}
<<dot>>=
"IBITS" -> "BTAGG"
"IndexedBits(a:Integer)" -> "BitAggregate()"
@
\pagehead{IndexedBits}{IBITS}
\pagepic{ps/v103indexedbits.ps}{IBITS}{1.00}
<<domain IBITS IndexedBits>>=
)abbrev domain IBITS IndexedBits
++ Author: Stephen Watt and Michael Monagan
++ Date Created:
++   July 86
++ Change History:
++   Oct 87
++ Basic Operations: range
++ Related Constructors:
++ Keywords: indexed bits
++ Description: \spadtype{IndexedBits} is a domain to compactly represent
++ large quantities of Boolean data.

IndexedBits(mn:Integer): BitAggregate() with
        -- temporaries until parser gets better
        Not: % -> %
            ++ Not(n) returns the bit-by-bit logical {\em Not} of n.
        Or : (%, %) -> %
            ++ Or(n,m)  returns the bit-by-bit logical {\em Or} of
            ++ n and m.
        And: (%, %) -> %
            ++ And(n,m)  returns the bit-by-bit logical {\em And} of
            ++ n and m.
    == add

        range: (%, Integer) -> Integer
          --++ range(j,i) returnes the range i of the boolean j.

        minIndex u  == mn

        range(v, i) ==
          i >= 0 and i < #v => i
          error "Index out of range"

        coerce(v):OutputForm ==
            t:Character := char "1"
            f:Character := char "0"
            s := new(#v, space()$Character)$String
            for i in minIndex(s)..maxIndex(s) for j in mn.. repeat
              s.i := if v.j then t else f
            s::OutputForm

        new(n, b)       == BVEC_-MAKE_-FULL(n,TRUTH_-TO_-BIT(b)$Lisp)$Lisp
        empty()         == BVEC_-MAKE_-FULL(0,0)$Lisp
        copy v          == BVEC_-COPY(v)$Lisp
        #v              == BVEC_-SIZE(v)$Lisp
        v = u           == BVEC_-EQUAL(v, u)$Lisp
        v < u           == BVEC_-GREATER(u, v)$Lisp
        _and(u, v)      == (#v=#u => BVEC_-AND(v,u)$Lisp; map("and",v,u))
        _or(u, v)       == (#v=#u => BVEC_-OR(v, u)$Lisp; map("or", v,u))
        xor(v,u)        == (#v=#u => BVEC_-XOR(v,u)$Lisp; map("xor",v,u))
        setelt(v:%, i:Integer, f:Boolean) ==
          BVEC_-SETELT(v, range(v, i-mn), TRUTH_-TO_-BIT(f)$Lisp)$Lisp
        elt(v:%, i:Integer) ==
          BIT_-TO_-TRUTH(BVEC_-ELT(v, range(v, i-mn))$Lisp)$Lisp

        Not v           == BVEC_-NOT(v)$Lisp
        And(u, v)       == (#v=#u => BVEC_-AND(v,u)$Lisp; map("and",v,u))
        Or(u, v)        == (#v=#u => BVEC_-OR(v, u)$Lisp; map("or", v,u))

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain IFARRAY IndexedFlexibleArray}
<<dot>>=
"IFARRAY" -> "A1AGG"
"IndexedFlexibleArray(a:Type,b:Integer)" ->
    "OneDimensionalArrayAggregate(a:Type)"
"IndexedFlexibleArray(a:Type,1)" -> 
    "IndexedFlexibleArray(a:Type,b:Integer)"
"IFARRAY" -> "ELAGG"
"IndexedFlexibleArray(a:Type,b:Integer)" ->
    "ExtensibleLinearAggregate(a:Type)"
@
\pagehead{IndexedFlexibleArray}{IFARRAY}
\pagepic{ps/v103indexedflexiblearray.ps}{IFARRAY}{1.00}
<<domain IFARRAY IndexedFlexibleArray>>=
)abbrev domain IFARRAY IndexedFlexibleArray
++ Author: Michael Monagan July/87, modified SMW June/91
++ A FlexibleArray is the notion of an array intended to allow for growth
++ at the end only.  Hence the following efficient operations
++   \spad{append(x,a)} meaning append item x at the end of the array \spad{a}
++   \spad{delete(a,n)} meaning delete the last item from the array \spad{a}
++ Flexible arrays support the other operations inherited from
++ \spadtype{ExtensibleLinearAggregate}. However, these are not efficient.
++ Flexible arrays combine the \spad{O(1)} access time property of arrays
++ with growing and shrinking at the end in \spad{O(1)} (average) time.
++ This is done by using an ordinary array which may have zero or more
++ empty slots at the end.  When the array becomes full it is copied
++ into a new larger (50% larger) array.  Conversely, when the array
++ becomes less than 1/2 full, it is copied into a smaller array.
++ Flexible arrays provide for an efficient implementation of many
++ data structures in particular heaps, stacks and sets.

IndexedFlexibleArray(S:Type, mn: Integer): Exports == Implementation where
  A ==> PrimitiveArray S
  I ==> Integer
  N ==> NonNegativeInteger
  U ==> UniversalSegment Integer
  Exports ==
   Join(OneDimensionalArrayAggregate S,ExtensibleLinearAggregate S) with
    flexibleArray : List S -> %
     ++ flexibleArray(l) creates a flexible array from the list of elements l
     ++
     ++X T1:=IndexedFlexibleArray(Integer,20)
     ++X flexibleArray([i for i in 1..10])$T1

    physicalLength : % -> NonNegativeInteger
     ++ physicalLength(x) returns the number of elements x can 
     ++ accomodate before growing
     ++
     ++X T1:=IndexedFlexibleArray(Integer,20)
     ++X t2:=flexibleArray([i for i in 1..10])$T1
     ++X physicalLength t2

    physicalLength_!: (%, I) -> %
     ++ physicalLength!(x,n) changes the physical length of x to be n and
     ++ returns the new array.
     ++
     ++X T1:=IndexedFlexibleArray(Integer,20)
     ++X t2:=flexibleArray([i for i in 1..10])$T1
     ++X physicalLength!(t2,15)

    shrinkable: Boolean -> Boolean
     ++ shrinkable(b) sets the shrinkable attribute of flexible arrays to b
     ++ and returns the previous value
     ++
     ++X T1:=IndexedFlexibleArray(Integer,20)
     ++X shrinkable(false)$T1

  Implementation == add
    Rep := Record(physLen:I, logLen:I, f:A)
    shrinkable? : Boolean := true
    growAndFill : (%, I, S) -> %
    growWith    : (%, I, S) -> %
    growAdding  : (%, I, %) -> %
    shrink: (%, I)    -> %
    newa  : (N, A) -> A

    physicalLength(r) == (r.physLen) pretend NonNegativeInteger
    physicalLength_!(r, n) ==
       r.physLen = 0  => error "flexible array must be non-empty"
       growWith(r, n, r.f.0)

    empty()      == [0, 0, empty()]
    #r           == (r.logLen)::N
    fill_!(r, x) == (fill_!(r.f, x); r)
    maxIndex r   == r.logLen - 1 + mn
    minIndex r   == mn
    new(n, a)    == [n, n, new(n, a)]

    shrinkable(b) ==
      oldval := shrinkable?
      shrinkable? := b
      oldval

    flexibleArray l ==
       n := #l
       n = 0 => empty()
       x := l.1
       a := new(n,x)
       for i in mn + 1..mn + n-1 for y in rest l repeat a.i := y
       a

    -- local utility operations
    newa(n, a) ==
       zero? n => empty()
       new(n, a.0)

    growAdding(r, b, s) ==
       b = 0 => r
       #r > 0 => growAndFill(r, b, (r.f).0)
       #s > 0 => growAndFill(r, b, (s.f).0)
       error "no default filler element"

    growAndFill(r, b, x) ==
       (r.logLen := r.logLen + b) <= r.physLen => r
       -- enlarge by 50% + b
       n := r.physLen + r.physLen quo 2 + 1
       if r.logLen > n then n := r.logLen
       growWith(r, n, x)

    growWith(r, n, x) ==
       y := new(n::N, x)$PrimitiveArray(S)
       a := r.f
       for k in 0 .. r.physLen-1 repeat y.k := a.k
       r.physLen := n
       r.f := y
       r

    shrink(r, i) ==
       r.logLen := r.logLen - i
       negative?(n := r.logLen) => error "internal bug in flexible array"
       2*n+2 > r.physLen => r
       not shrinkable? => r
       if n < r.logLen 
         then error "cannot shrink flexible array to indicated size"
       n = 0 => empty()
       r.physLen := n
       y := newa(n::N, a := r.f)
       for k in 0 .. n-1 repeat y.k := a.k
       r.f := y
       r

    copy r ==
       n := #r
       a := r.f
       v := newa(n, a := r.f)
       for k in 0..n-1 repeat v.k := a.k
       [n, n, v]


    elt(r:%, i:I) ==
       i < mn or i >= r.logLen + mn =>
           error "index out of range"
       r.f.(i-mn)

    setelt(r:%, i:I, x:S) ==
       i < mn or i >= r.logLen + mn =>
           error "index out of range"
       r.f.(i-mn) := x

    -- operations inherited from extensible aggregate
    merge(g, a, b)   == merge_!(g, copy a, b)
    concat(x:S, r:%) == insert_!(x, r, mn)

    concat_!(r:%, x:S) ==
       growAndFill(r, 1, x)
       r.f.(r.logLen-1) := x
       r

    concat_!(a:%, b:%) ==
       if eq?(a, b) then b := copy b
       n := #a
       growAdding(a, #b, b)
       copyInto_!(a, b, n + mn)

    remove_!(g:(S->Boolean), a:%) ==
       k:I := 0
       for i in 0..maxIndex a - mn repeat
          if not g(a.i) then (a.k := a.i; k := k+1)
       shrink(a, #a - k)

    delete_!(r:%, i1:I) ==
       i := i1 - mn
       i < 0 or i > r.logLen => error "index out of range"
       for k in i..r.logLen-2 repeat r.f.k := r.f.(k+1)
       shrink(r, 1)

    delete_!(r:%, i:U) ==
       l := lo i - mn; m := maxIndex r - mn
       h := (hasHi i => hi i - mn; m)
       l < 0 or h > m => error "index out of range"
       for j in l.. for k in h+1..m repeat r.f.j := r.f.k
       shrink(r, max(0,h-l+1))

    insert_!(x:S, r:%, i1:I):% ==
       i := i1 - mn
       n := r.logLen
       i < 0 or i > n => error "index out of range"
       growAndFill(r, 1, x)
       for k in n-1 .. i by -1 repeat r.f.(k+1) := r.f.k
       r.f.i := x
       r

    insert_!(a:%, b:%, i1:I):% ==
       i := i1 - mn
       if eq?(a, b) then b := copy b
       m := #a; n := #b
       i < 0 or i > n => error "index out of range"
       growAdding(b, m, a)
       for k in n-1 .. i by -1 repeat b.f.(m+k) := b.f.k
       for k in m-1 .. 0 by -1 repeat b.f.(i+k) := a.f.k
       b

    merge_!(g, a, b) ==
       m := #a; n := #b; growAdding(a, n, b)
       for i in m-1..0 by -1 for j in m+n-1.. by -1 repeat a.f.j := a.f.i
       i := n; j := 0
       for k in 0.. while i < n+m and j < n repeat
          if g(a.f.i,b.f.j) then (a.f.k := a.f.i; i := i+1)
          else (a.f.k := b.f.j; j := j+1)
       for k in k.. for j in j..n-1 repeat a.f.k := b.f.j
       a

    select_!(g:(S->Boolean), a:%) ==
       k:I := 0
       for i in 0..maxIndex a - mn repeat_
          if g(a.f.i) then (a.f.k := a.f.i;k := k+1)
       shrink(a, #a - k)

    if S has SetCategory then
      removeDuplicates_! a ==
         ct := #a
         ct < 2 => a

         i     := mn
         nlim  := mn + ct
         nlim0 := nlim
         while i < nlim repeat
            j := i+1
            for k in j..nlim-1 | a.k ^= a.i repeat
                a.j := a.k
                j := j+1
            nlim := j
            i := i+1
         nlim ^= nlim0 => delete_!(a, i..)
         a

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain IARRAY1 IndexedOneDimensionalArray}
<<dot>>=
"IARRAY1" -> "A1AGG"
"IndexedOneDimensionalArray(a:Type,b:Integer)" ->
    "OneDimensionalArrayAggregate(a:Type)"
@
\pagehead{IndexedOneDimensionalArray}{IARRAY1}
\pagepic{ps/v103indexedonedimensionalarray.ps}{IARRAY1}{1.00}
<<domain IARRAY1 IndexedOneDimensionalArray>>=
)abbrev domain IARRAY1 IndexedOneDimensionalArray
++ Author Micheal Monagan Aug/87
++ This is the basic one dimensional array data type.

IndexedOneDimensionalArray(S:Type, mn:Integer):
 OneDimensionalArrayAggregate S == add
   Qmax ==> QVMAXINDEX$Lisp
   Qsize ==> QVSIZE$Lisp
--   Qelt ==> QVELT$Lisp
--   Qsetelt ==> QSETVELT$Lisp
   Qelt ==> ELT$Lisp
   Qsetelt ==> SETELT$Lisp
--   Qelt1 ==> QVELT_-1$Lisp
--   Qsetelt1 ==> QSETVELT_-1$Lisp
   Qnew ==> GETREFV$Lisp
   I ==> Integer

   #x               == Qsize x
   fill_!(x, s)     == (for i in 0..Qmax x repeat Qsetelt(x, i, s); x)
   minIndex x       == mn

   empty()          == Qnew(0$Lisp)
   new(n, s)        == fill_!(Qnew n,s)

   map_!(f, s1)  ==
      n:Integer := Qmax(s1)
      n < 0 => s1
      for i in 0..n repeat Qsetelt(s1, i, f(Qelt(s1,i)))
      s1

   map(f, s1)       ==
      n:Integer := Qmax(s1)
      n < 0 => s1
      ss2:% := Qnew(n+1)
      for i in 0..n repeat Qsetelt(ss2, i, f(Qelt(s1,i)))
      ss2

   map(f, a, b)   ==
      maxind:Integer := min(Qmax a, Qmax b)
      maxind < 0 => empty()
      c:% := Qnew(maxind+1)
      for i in 0..maxind repeat
        Qsetelt(c, i, f(Qelt(a,i),Qelt(b,i)))
      c

   if zero? mn then
     qelt(x, i)       == Qelt(x, i)
     qsetelt_!(x, i, s) == Qsetelt(x, i, s)

     elt(x:%, i:I) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qelt(x, i)

     setelt(x:%, i:I, s:S) ==
       negative? i or i > maxIndex(x) => error "index out of range"
       qsetelt_!(x, i, s)

--   else if one? mn then
   else if (mn = 1) then
     maxIndex x       == Qsize x
     qelt(x, i)       == Qelt(x, i-1)
     qsetelt_!(x, i, s) == Qsetelt(x, i-1, s)

     elt(x:%, i:I) ==
       QSLESSP(i,1$Lisp)$Lisp or QSLESSP(Qsize x,i)$Lisp =>
         error "index out of range"
       Qelt(x, i-1)

     setelt(x:%, i:I, s:S) ==
       QSLESSP(i,1$Lisp)$Lisp or QSLESSP(Qsize x,i)$Lisp =>
         error "index out of range"
       Qsetelt(x, i-1, s)

    else
       qelt(x, i)       == Qelt(x, i - mn)
       qsetelt_!(x, i, s) == Qsetelt(x, i - mn, s)

       elt(x:%, i:I) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qelt(x, i)

       setelt(x:%, i:I, s:S) ==
         i < mn or i > maxIndex(x) => error "index out of range"
         qsetelt_!(x, i, s)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain IARRAY2 IndexedTwoDimensionalArray}
An IndexedTwoDimensionalArray is a 2-dimensional array where
the minimal row and column indices are parameters of the type.
Rows and columns are returned as IndexedOneDimensionalArray's with
minimal indices matching those of the IndexedTwoDimensionalArray.
The index of the 'first' row may be obtained by calling the
function 'minRowIndex'.  The index of the 'first' column may
be obtained by calling the function 'minColIndex'.  The index of
the first element of a 'Row' is the same as the index of the
first column in an array and vice versa.
<<dot>>=
"IARRAY2" -> "ARR2CAT"
"IndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer)" ->
"TwoDimensionalArrayCategory(a:Type,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
"IARRAY2" -> "IIARRAY2"
"IndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer)" ->
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
@
\pagehead{IndexedTwoDimensionalArray}{IARRAY2}
\pagepic{ps/v103indexedtwodimensionalarray.ps}{IARRAY2}{1.00}
<<domain IARRAY2 IndexedTwoDimensionalArray>>=
)abbrev domain IARRAY2 IndexedTwoDimensionalArray
IndexedTwoDimensionalArray(R,mnRow,mnCol):Exports == Implementation where
  R : Type
  mnRow, mnCol : Integer
  Row ==> IndexedOneDimensionalArray(R,mnCol)
  Col ==> IndexedOneDimensionalArray(R,mnRow)

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col)

  Implementation ==>
    InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain IIARRAY2 InnerIndexedTwoDimensionalArray}
This is an internal type which provides an implementation of
2-dimensional arrays as PrimitiveArray's of PrimitiveArray's.
<<dot>>=
"IIARRAY2" -> "ARR2CAT"
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
-> "TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
"InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
-> "InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
"InnerIndexedTwoDimensionalArray(a:Type,1,1,b:OneDimensionalArray(a),c:OneDimensionalArray(a))"
-> "InnerIndexedTwoDimensionalArray(a:Type,b:Integer,c:Integer,d:FiniteLinearAggregate(a),e:FiniteLinearAggregate(a))"
@
\pagehead{InnerIndexedTwoDimensionalArray}{IIARRAY2}
\pagepic{ps/v103innerindexedtwodimensionalarray.ps}{IIARRAY2}{1.00}
<<domain IIARRAY2 InnerIndexedTwoDimensionalArray>>=
)abbrev domain IIARRAY2 InnerIndexedTwoDimensionalArray
InnerIndexedTwoDimensionalArray(R,mnRow,mnCol,Row,Col):_
       Exports == Implementation where
  R : Type
  mnRow, mnCol : Integer
  Row : FiniteLinearAggregate R
  Col : FiniteLinearAggregate R

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col)

  Implementation ==> add

    Rep := PrimitiveArray PrimitiveArray R

--% Predicates

    empty? m == empty?(m)$Rep

--% Primitive array creation

    empty() == empty()$Rep

    new(rows,cols,a) ==
      rows = 0 =>
        error "new: arrays with zero rows are not supported"
--      cols = 0 =>
--        error "new: arrays with zero columns are not supported"
      arr : PrimitiveArray PrimitiveArray R := new(rows,empty())
      for i in minIndex(arr)..maxIndex(arr) repeat
        qsetelt_!(arr,i,new(cols,a))
      arr

--% Size inquiries

    minRowIndex m == mnRow
    minColIndex m == mnCol
    maxRowIndex m == nrows m + mnRow - 1
    maxColIndex m == ncols m + mnCol - 1

    nrows m == (# m)$Rep

    ncols m ==
      empty? m => 0
      # m(minIndex(m)$Rep)

--% Part selection/assignment

    qelt(m,i,j) ==
      qelt(qelt(m,i - minRowIndex m)$Rep,j - minColIndex m)

    elt(m:%,i:Integer,j:Integer) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "elt: index out of range"
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "elt: index out of range"
      qelt(m,i,j)

    qsetelt_!(m,i,j,r) ==
      setelt(qelt(m,i - minRowIndex m)$Rep,j - minColIndex m,r)

    setelt(m:%,i:Integer,j:Integer,r:R) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "setelt: index out of range"
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "setelt: index out of range"
      qsetelt_!(m,i,j,r)

    if R has SetCategory then
        latex(m : %) : String ==
          s : String := "\left[ \begin{array}{"
          j : Integer
          for j in minColIndex(m)..maxColIndex(m) repeat
            s := concat(s,"c")$String
          s := concat(s,"} ")$String
          i : Integer
          for i in minRowIndex(m)..maxRowIndex(m) repeat
            for j in minColIndex(m)..maxColIndex(m) repeat
              s := concat(s, latex(qelt(m,i,j))$R)$String
              if j < maxColIndex(m) then s := concat(s, " & ")$String
            if i < maxRowIndex(m) then s := concat(s, " \\ ")$String
          concat(s, "\end{array} \right]")$String

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter J}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter K}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter L}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter M}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter N}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain NONE None}
<<None.input>>=
-- any.spad.pamphlet None.input
)spool None.output
)set message test on
)set message auto off
)clear all
--S 1 of 3
[ ]
--R 
--R
--R   (1)  []
--R                                                              Type: List None
--E 1

--S 2 of 3
[ ] :: List Float
--R 
--R
--R   (2)  []
--R                                                             Type: List Float
--E 2

--S 3 of 3
[ ]$List(NonNegativeInteger)
--R 
--R
--R   (3)  []
--R                                                Type: List NonNegativeInteger
--E 3 
)spool
)lisp (bye)
@
<<None.help>>=
====================================================================
None examples
====================================================================

The None domain is not very useful for interactive work but it is
provided nevertheless for completeness of the Axiom type system.

Probably the only place you will ever see it is if you enter an
empty list with no type information.

  [ ]
    []
                         Type: List None

Such an empty list can be converted into an empty list of any other
type.

  [ ] :: List Float
    []
                         Type: List Float

If you wish to produce an empty list of a particular type directly,
such as List NonNegativeInteger, do it this way.

  [ ]$List(NonNegativeInteger)
    []
                         Type: List NonNegativeInteger

See Also:
o )show None
o $AXIOM/doc/src/algebra/any.spad.dvi

@
<<dot>>=
"NONE" -> "SETCAT"
"None()" -> "SetCategory()"
@
\pagehead{None}{NONE}
\pagepic{ps/v103none.ps}{NONE}{1.00}
<<domain NONE None>>=
)abbrev domain NONE None
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions: coerce
++ Related Constructors: NoneFunctions1
++ Also See: Any
++ AMS Classification:
++ Keywords: none, empty
++ Description:
++    \spadtype{None} implements a type with no objects. It is mainly
++    used in technical situations where such a thing is needed (e.g.
++    the interpreter and some of the internal \spadtype{Expression}
++    code).

None():SetCategory == add
    coerce(none:%):OutputForm == "NONE" :: OutputForm
    x:% = y:% == EQ(x,y)$Lisp

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain NIPROB NumericalIntegrationProblem}
\pagehead{NumericalIntegrationProblem}{NIPROB}
\pagepic{ps/v103numericalintegrationproblem.ps}{NIPROB}{1.00}
<<domain NIPROB NumericalIntegrationProblem>>=
)abbrev domain NIPROB NumericalIntegrationProblem
++ Author: Brian Dupee
++ Date Created: December 1997
++ Date Last Updated: December 1997
++ Basic Operations: coerce, retract
++ Related Constructors: Union
++ Description:
++ \axiomType{NumericalIntegrationProblem} is a \axiom{domain}
++ for the representation of Numerical Integration problems for use
++ by ANNA. 
++
++ The representation is a Union of two record types - one for integration of
++ a function of one variable:
++
++ \axiomType{Record}(var:\axiomType{Symbol},
++ fn:\axiomType{Expression DoubleFloat},
++ range:\axiomType{Segment OrderedCompletion DoubleFloat},
++ abserr:\axiomType{DoubleFloat},
++ relerr:\axiomType{DoubleFloat},)
++
++ and one for multivariate integration:
++
++ \axiomType{Record}(fn:\axiomType{Expression DoubleFloat},
++ range:\axiomType{List Segment OrderedCompletion DoubleFloat},
++ abserr:\axiomType{DoubleFloat},
++ relerr:\axiomType{DoubleFloat},).
++

EDFA   ==> Expression DoubleFloat
SOCDFA ==> Segment OrderedCompletion DoubleFloat
DFA    ==> DoubleFloat
NIAA   ==> Record(var:Symbol,fn:EDFA,range:SOCDFA,abserr:DFA,relerr:DFA)
MDNIAA ==> Record(fn:EDFA,range:List SOCDFA,abserr:DFA,relerr:DFA)
 
NumericalIntegrationProblem():SetCategory with
    coerce: NIAA -> %
      ++ coerce(x) \undocumented{}
    coerce: MDNIAA -> %
      ++ coerce(x) \undocumented{}
    coerce: Union(nia:NIAA,mdnia:MDNIAA) -> %
      ++ coerce(x) \undocumented{}
    coerce: % -> OutputForm
      ++ coerce(x) \undocumented{}
    retract: % -> Union(nia:NIAA,mdnia:MDNIAA)
      ++ retract(x) \undocumented{}

  ==
 
    add
      Rep := Union(nia:NIAA,mdnia:MDNIAA)
 
      coerce(s:NIAA) == [s]
      coerce(s:MDNIAA) == [s]
      coerce(s:Union(nia:NIAA,mdnia:MDNIAA)) == s
      coerce(x:%):OutputForm ==
        (x) case nia => (x.nia)::OutputForm
        (x.mdnia)::OutputForm
      retract(x:%):Union(nia:NIAA,mdnia:MDNIAA) ==
        (x) case nia => [x.nia]
        [x.mdnia]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ODEPROB NumericalODEProblem}
\pagehead{NumericalODEProblem}{ODEPROB}
\pagepic{ps/v103numericalodeproblem.ps}{ODEPROB}{1.00}
<<domain ODEPROB NumericalODEProblem>>=
)abbrev domain ODEPROB NumericalODEProblem
++ Author: Brian Dupee
++ Date Created: December 1997
++ Date Last Updated: December 1997
++ Basic Operations: coerce, retract
++ Related Constructors: Union
++ Description:
++ \axiomType{NumericalODEProblem} is a \axiom{domain}
++ for the representation of Numerical ODE problems for use
++ by ANNA. 
++
++ The representation is of type: 
++
++ \axiomType{Record}(xinit:\axiomType{DoubleFloat},
++ xend:\axiomType{DoubleFloat},
++ fn:\axiomType{Vector Expression DoubleFloat},
++ yinit:\axiomType{List DoubleFloat},intvals:\axiomType{List DoubleFloat},
++ g:\axiomType{Expression DoubleFloat},abserr:\axiomType{DoubleFloat},
++ relerr:\axiomType{DoubleFloat})
++

DFB   ==> DoubleFloat
VEDFB ==> Vector Expression DoubleFloat
LDFB  ==> List DoubleFloat
EDFB  ==> Expression DoubleFloat
ODEAB ==> Record(xinit:DFB,xend:DFB,fn:VEDFB,yinit:LDFB,intvals:LDFB,g:EDFB,abserr:DFB,relerr:DFB)
NumericalODEProblem():SetCategory with

    coerce: ODEAB -> %
      ++ coerce(x) \undocumented{}
    coerce: % -> OutputForm
      ++ coerce(x) \undocumented{}
    retract: % -> ODEAB
      ++ retract(x) \undocumented{}

  ==
 
    add
      Rep := ODEAB
 
      coerce(s:ODEAB) == s
      coerce(x:%):OutputForm ==
        (retract(x))::OutputForm
      retract(x:%):ODEAB == x :: Rep

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain OPTPROB NumericalOptimizationProblem}
\pagehead{NumericalOptimizationProblem}{OPTPROB}
\pagepic{ps/v103numericaloptimizationproblem.ps}{OPTPROB}{1.00}
<<domain OPTPROB NumericalOptimizationProblem>>=
)abbrev domain OPTPROB NumericalOptimizationProblem
++ Author: Brian Dupee
++ Date Created: December 1997
++ Date Last Updated: December 1997
++ Basic Operations: coerce, retract
++ Related Constructors: Union
++ Description:
++ \axiomType{NumericalOptimizationProblem} is a \axiom{domain}
++ for the representation of Numerical Optimization problems for use
++ by ANNA. 
++
++ The representation is a Union of two record types - one for otimization of
++ a single function of one or more variables:
++
++ \axiomType{Record}(
++ fn:\axiomType{Expression DoubleFloat},
++ init:\axiomType{List DoubleFloat},
++ lb:\axiomType{List OrderedCompletion DoubleFloat},
++ cf:\axiomType{List Expression DoubleFloat},
++ ub:\axiomType{List OrderedCompletion DoubleFloat})
++
++ and one for least-squares problems i.e. optimization of a set of
++ observations of a data set:
++
++ \axiomType{Record}(lfn:\axiomType{List Expression DoubleFloat},
++ init:\axiomType{List DoubleFloat}).
++

LDFD     ==> List DoubleFloat
LEDFD    ==> List Expression DoubleFloat
LSAD     ==> Record(lfn:LEDFD, init:LDFD)
UNOALSAD ==> Union(noa:NOAD,lsa:LSAD)
EDFD     ==> Expression DoubleFloat
LOCDFD   ==> List OrderedCompletion DoubleFloat
NOAD     ==> Record(fn:EDFD, init:LDFD, lb:LOCDFD, cf:LEDFD, ub:LOCDFD)
NumericalOptimizationProblem():SetCategory with

    coerce: NOAD -> %
      ++ coerce(x) \undocumented{}
    coerce: LSAD -> %
      ++ coerce(x) \undocumented{}
    coerce: UNOALSAD -> %
      ++ coerce(x) \undocumented{}
    coerce: % -> OutputForm
      ++ coerce(x) \undocumented{}
    retract: % -> UNOALSAD
      ++ retract(x) \undocumented{}

  ==
 
    add
      Rep := UNOALSAD
 
      coerce(s:NOAD) == [s]
      coerce(s:LSAD) == [s]
      coerce(x:UNOALSAD) == x
      coerce(x:%):OutputForm ==
        (x) case noa => (x.noa)::OutputForm
        (x.lsa)::OutputForm
      retract(x:%):UNOALSAD ==
        (x) case noa => [x.noa]
        [x.lsa]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain PDEPROB NumericalPDEProblem}
\pagehead{NumericalPDEProblem}{PDEPROB}
\pagepic{ps/v103numericalpdeproblem.ps}{PDEPROB}{1.00}
<<domain PDEPROB NumericalPDEProblem>>=
)abbrev domain PDEPROB NumericalPDEProblem
++ Author: Brian Dupee
++ Date Created: December 1997
++ Date Last Updated: December 1997
++ Basic Operations: coerce, retract
++ Related Constructors: Union
++ Description:
++ \axiomType{NumericalPDEProblem} is a \axiom{domain}
++ for the representation of Numerical PDE problems for use
++ by ANNA. 
++
++ The representation is of type: 
++
++ \axiomType{Record}(pde:\axiomType{List Expression DoubleFloat}, 
++ constraints:\axiomType{List PDEC}, 
++ f:\axiomType{List List Expression DoubleFloat},
++ st:\axiomType{String},
++ tol:\axiomType{DoubleFloat})
++
++ where \axiomType{PDEC} is of type:
++
++ \axiomType{Record}(start:\axiomType{DoubleFloat}, 
++ finish:\axiomType{DoubleFloat},
++ grid:\axiomType{NonNegativeInteger},
++ boundaryType:\axiomType{Integer},
++ dStart:\axiomType{Matrix DoubleFloat}, 
++ dFinish:\axiomType{Matrix DoubleFloat})
++

DFC   ==> DoubleFloat
NNIC  ==> NonNegativeInteger
INTC  ==> Integer
MDFC  ==> Matrix DoubleFloat
PDECC ==> Record(start:DFC, finish:DFC, grid:NNIC, boundaryType:INTC,
                dStart:MDFC, dFinish:MDFC)
LEDFC ==> List Expression DoubleFloat
PDEBC ==> Record(pde:LEDFC, constraints:List PDECC, f:List LEDFC, 
                    st:String, tol:DFC)
NumericalPDEProblem():SetCategory with

    coerce: PDEBC -> %
      ++ coerce(x) \undocumented{}
    coerce: % -> OutputForm
      ++ coerce(x) \undocumented{}
    retract: % -> PDEBC
      ++ retract(x) \undocumented{}

  ==
 
    add
      Rep := PDEBC
 
      coerce(s:PDEBC) == s
      coerce(x:%):OutputForm ==
        (retract(x))::OutputForm
      retract(x:%):PDEBC == x :: Rep

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter O}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ARRAY1 OneDimensionalArray}
<<OneDimensionalArray.input>>=
-- array1.spad.pamphlet OneDimensionalArray.input
)spool OneDimensionalArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
oneDimensionalArray [i**2 for i in 1..10]
--R 
--R
--R   (1)  [1,4,9,16,25,36,49,64,81,100]
--R                                    Type: OneDimensionalArray PositiveInteger
--E 1

--S 2 of 9
a : ARRAY1 INT := new(10,0)
--R 
--R
--R   (2)  [0,0,0,0,0,0,0,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 2

--S 3 of 9
for i in 1..10 repeat a.i := i; a
--R 
--R
--R   (3)  [1,2,3,4,5,6,7,8,9,10]
--R                                            Type: OneDimensionalArray Integer
--E 3

--S 4 of 9
map!(i +-> i ** 2,a); a
--R 
--R
--R   (4)  [1,4,9,16,25,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 4

--S 5 of 9
reverse! a
--R 
--R
--R   (5)  [100,81,64,49,36,25,16,9,4,1]
--R                                            Type: OneDimensionalArray Integer
--E 5

--S 6 of 9
swap!(a,4,5); a
--R 
--R
--R   (6)  [100,81,64,36,49,25,16,9,4,1]
--R                                            Type: OneDimensionalArray Integer
--E 6

--S 7 of 9
sort! a 
--R 
--R
--R   (7)  [1,4,9,16,25,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 7

--S 8 of 9
b := a(6..10)
--R 
--R
--R   (8)  [36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 8

--S 9 of 9
copyInto!(a,b,1)
--R 
--R
--R   (9)  [36,49,64,81,100,36,49,64,81,100]
--R                                            Type: OneDimensionalArray Integer
--E 9
)spool
)lisp (bye)
@
<<OneDimensionalArray.help>>=
====================================================================
OneDimensionalArray examples
====================================================================

The OneDimensionalArray domain is used for storing data in a
one-dimensional indexed data structure.  Such an array is a
homogeneous data structure in that all the entries of the array must
belong to the same Axiom domain.  Each array has a fixed length
specified by the user and arrays are not extensible.  The indexing of
one-dimensional arrays is one-based.  This means that the "first"
element of an array is given the index 1. 

To create a one-dimensional array, apply the operation 
oneDimensionalArray to a list.

  oneDimensionalArray [i**2 for i in 1..10]
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray PositiveInteger

Another approach is to first create a, a one-dimensional array of 10
0's.  OneDimensionalArray has the convenient abbreviation ARRAY1.

  a : ARRAY1 INT := new(10,0)
    [0,0,0,0,0,0,0,0,0,0]
                     Type: OneDimensionalArray Integer

Set each i-th element to i, then display the result.

  for i in 1..10 repeat a.i := i; a
    [1,2,3,4,5,6,7,8,9,10]
                     Type: OneDimensionalArray Integer

Square each element by mapping the function i +-> i^2 onto each element.

  map!(i +-> i ** 2,a); a
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Reverse the elements in place.

  reverse! a
    [100,81,64,49,36,25,16,9,4,1]
                     Type: OneDimensionalArray Integer

Swap the 4th and 5th element.

  swap!(a,4,5); a
    [100,81,64,36,49,25,16,9,4,1]
                     Type: OneDimensionalArray Integer

Sort the elements in place.

  sort! a 
    [1,4,9,16,25,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Create a new one-dimensional array b containing the last 5 elements of a.

  b := a(6..10)
    [36,49,64,81,100]
                     Type: OneDimensionalArray Integer

Replace the first 5 elements of a with those of b.

  copyInto!(a,b,1)
    [36,49,64,81,100,36,49,64,81,100]
                     Type: OneDimensionalArray Integer

See Also:
o )help Vector
o )help FlexibleArray
o )show OneDimensionalArray
o $AXIOM/doc/src/algebra/array1.spad.dvi

@
<<dot>>=
"ARRAY1" -> "A1AGG"
"OneDimensionalArray(a:Type)" -> "OneDimensionalArrayAggregate(a:Type)"
@
\pagehead{OneDimensionalArray}{ARRAY1}
\pagepic{ps/v103onedimensionalarray.ps}{ARRAY1}{1.00}
<<domain ARRAY1 OneDimensionalArray>>=
)abbrev domain ARRAY1 OneDimensionalArray
++ This is the domain of 1-based one dimensional arrays

OneDimensionalArray(S:Type): Exports == Implementation where
  ARRAYMININDEX ==> 1       -- if you want to change this, be my guest
  Exports == OneDimensionalArrayAggregate S with
   oneDimensionalArray: List S -> %
    ++ oneDimensionalArray(l) creates an array from a list of elements l
    ++
    ++X oneDimensionalArray [i**2 for i in 1..10]
  
   oneDimensionalArray: (NonNegativeInteger, S) -> %
    ++ oneDimensionalArray(n,s) creates an array from n copies of element s
    ++
    ++X oneDimensionalArray(10,0.0)

  Implementation == IndexedOneDimensionalArray(S, ARRAYMININDEX) add
    oneDimensionalArray(u) ==
      n := #u
      n = 0 => empty()
      a := new(n, first u)
      for i in 2..n for x in rest u repeat a.i := x
      a
    oneDimensionalArray(n,s) == new(n,s)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter P}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ACPLOT PlaneAlgebraicCurvePlot}
<<PlaneAlgebraicCurvePlot.input>>=
-- acplot.spad.pamphlet PlaneAlgebraicCurvePlot.input
)spool PlaneAlgebraicCurvePlot.output
)set message test on
)set message auto off
)clear all
--S 1 of 1
makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT
--R   (1)                    ACPLOT
--R                       1         1      1         1
--R        y + x = 0,   - - <= x <= -,   - - <= y <= -
--R                       2         2      2         2
--R                        [0.5,- 0.5]
--R                        [- 0.5,0.5]
--R                                                Type: PlaneAlgebraicCurvePlot
--E 1
)spool
)lisp (bye)
@
<<PlaneAlgebraicCurvePlot.help>>=
====================================================================
PlaneAlgebraicCurvePlot examples
====================================================================

  makeSketch(x+y,x,y,-1/2..1/2,-1/2..1/2)$ACPLOT

See Also:
o )show PlaneAlgebraicCurvePlot
o $AXIOM/doc/src/algebra/acplot.spad.dvi 

@
<<dot>>=
"ACPLOT" -> "PPCURVE"
"PlaneAlgebraicCurvePlot()" -> "PlottablePlaneCurveCategory()"
@
\pagehead{PlaneAlgebraicCurvePlot}{ACPLOT}
\pagepic{ps/v103planealgebraiccurveplot.ps}{ACPLOT}{1.00}
<<domain ACPLOT PlaneAlgebraicCurvePlot>>=
--% PlaneAlgebraicCurvePlot
++ Plot a NON-SINGULAR plane algebraic curve p(x,y) = 0.
++ Author: Clifton J. Williamson and Timothy Daly
++ Date Created: Fall 1988
++ Date Last Updated: 27 April 1990
++ Keywords: algebraic curve, non-singular, plot
++ Examples:
++ References:

)abbrev domain ACPLOT PlaneAlgebraicCurvePlot

PlaneAlgebraicCurvePlot(): PlottablePlaneCurveCategory _
 with

  makeSketch:(Polynomial Integer,Symbol,Symbol,Segment Fraction Integer,_
               Segment Fraction Integer) -> %
     ++ makeSketch(p,x,y,a..b,c..d) creates an ACPLOT of the
     ++ curve \spad{p = 0} in the region {\em a <= x <= b, c <= y <= d}.
     ++ More specifically, 'makeSketch' plots a non-singular algebraic curve
     ++ \spad{p = 0} in an rectangular region {\em xMin <= x <= xMax},
     ++ {\em yMin <= y <= yMax}. The user inputs
     ++ \spad{makeSketch(p,x,y,xMin..xMax,yMin..yMax)}.
     ++ Here p is a polynomial in the variables x and y with
     ++ integer coefficients (p belongs to the domain
     ++ \spad{Polynomial Integer}). The case
     ++ where p is a polynomial in only one of the variables is
     ++ allowed.  The variables x and y are input to specify the
     ++ the coordinate axes.  The horizontal axis is the x-axis and
     ++ the vertical axis is the y-axis.  The rational numbers
     ++ xMin,...,yMax specify the boundaries of the region in
     ++ which the curve is to be plotted.
  refine:(%,DoubleFloat) -> %
     ++ refine(p,x) \undocumented{}

 == add

  import PointPackage DoubleFloat
  import Plot
  import RealSolvePackage

  BoundaryPts ==> Record(left:   List Point DoubleFloat,_
                         right:  List Point DoubleFloat,_
                         bottom: List Point DoubleFloat,_
                         top:    List Point DoubleFloat)

  NewPtInfo   ==> Record(newPt: Point DoubleFloat,_
                         type:  String)

  Corners     ==> Record(minXVal: DoubleFloat,_
                         maxXVal: DoubleFloat,_
                         minYVal: DoubleFloat,_
                         maxYVal: DoubleFloat)

  kinte       ==> solve$RealSolvePackage()

  rsolve      ==> realSolve$RealSolvePackage()

  singValBetween?:(DoubleFloat,DoubleFloat,List DoubleFloat) -> Boolean

  segmentInfo:(DoubleFloat -> DoubleFloat,DoubleFloat,DoubleFloat,_
               List DoubleFloat,List DoubleFloat,List DoubleFloat,_
               DoubleFloat,DoubleFloat) -> _
    Record(seg:Segment DoubleFloat,_
           left: DoubleFloat,_
           lowerVals: List DoubleFloat,_
           upperVals:List DoubleFloat)

  swapCoords:Point DoubleFloat -> Point DoubleFloat

  samePlottedPt?:(Point DoubleFloat,Point DoubleFloat) -> Boolean

  findPtOnList:(Point DoubleFloat,List Point DoubleFloat) -> _
    Union(Point DoubleFloat,"failed")

  makeCorners:(DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat) -> Corners

  getXMin: Corners -> DoubleFloat

  getXMax: Corners -> DoubleFloat

  getYMin: Corners -> DoubleFloat

  getYMax: Corners -> DoubleFloat

  SFPolyToUPoly:Polynomial DoubleFloat -> _
    SparseUnivariatePolynomial DoubleFloat

  RNPolyToUPoly:Polynomial Fraction Integer -> _
    SparseUnivariatePolynomial Fraction Integer

  coerceCoefsToSFs:Polynomial Integer -> Polynomial DoubleFloat

  coerceCoefsToRNs:Polynomial Integer -> Polynomial Fraction Integer

  RNtoSF:Fraction Integer -> DoubleFloat

  RNtoNF:Fraction Integer -> Float

  SFtoNF:DoubleFloat -> Float

  listPtsOnHorizBdry:(Polynomial Fraction Integer,Symbol,Fraction Integer,_
                      Float,Float) -> _
    List Point DoubleFloat

  listPtsOnVertBdry:(Polynomial Fraction Integer,Symbol,Fraction Integer,_
                     Float,Float) -> _
    List Point DoubleFloat

  listPtsInRect:(List List Float,Float,Float,Float,Float) -> _
    List Point DoubleFloat

  ptsSuchThat?:(List List Float,List Float -> Boolean) -> Boolean

  inRect?:(List Float,Float,Float,Float,Float) -> Boolean

  onHorzSeg?:(List Float,Float,Float,Float) -> Boolean

  onVertSeg?:(List Float,Float,Float,Float) -> Boolean

  newX:(List List Float,List List Float,Float,Float,Float,Fraction Integer,_
        Fraction Integer) -> Fraction Integer

  newY:(List List Float,List List Float,Float,Float,Float,_
        Fraction Integer,Fraction Integer) -> Fraction Integer

  makeOneVarSketch:(Polynomial Integer,Symbol,Symbol,Fraction Integer,_
                    Fraction Integer,Fraction Integer,Fraction Integer,_
                    Symbol) -> %

  makeLineSketch:(Polynomial Integer,Symbol,Symbol,Fraction Integer,_
                  Fraction Integer,Fraction Integer,Fraction Integer) -> %

  makeRatFcnSketch:(Polynomial Integer,Symbol,Symbol,Fraction Integer,_
                    Fraction Integer,Fraction Integer,Fraction Integer,_
                    Symbol) -> %

  makeGeneralSketch:(Polynomial Integer,Symbol,Symbol,Fraction Integer,_
                     Fraction Integer,Fraction Integer,Fraction Integer) -> %

  traceBranches:(Polynomial DoubleFloat,Polynomial DoubleFloat,_
                 Polynomial DoubleFloat,Symbol,Symbol,Corners,DoubleFloat,_
                 DoubleFloat,PositiveInteger, List Point DoubleFloat,_
                 BoundaryPts) -> List List Point DoubleFloat

  dummyFirstPt:(Point DoubleFloat,Polynomial DoubleFloat,_
                Polynomial DoubleFloat,Symbol,Symbol,List Point DoubleFloat,_
                List Point DoubleFloat,List Point DoubleFloat,_
                List Point DoubleFloat) -> Point DoubleFloat

  listPtsOnSegment:(Polynomial DoubleFloat,Polynomial DoubleFloat,_
                    Polynomial DoubleFloat,Symbol,Symbol,Point DoubleFloat,_
                    Point DoubleFloat,Corners, DoubleFloat,DoubleFloat,_
                    PositiveInteger,List Point DoubleFloat,_
                    List Point DoubleFloat) -> List List Point DoubleFloat

  listPtsOnLoop:(Polynomial DoubleFloat,Polynomial DoubleFloat,_
                 Polynomial DoubleFloat,Symbol,Symbol,Point DoubleFloat,_
                 Corners, DoubleFloat,DoubleFloat,PositiveInteger,_
                 List Point DoubleFloat,List Point DoubleFloat) -> _
                 List List Point DoubleFloat

  computeNextPt:(Polynomial DoubleFloat,Polynomial DoubleFloat,_
                 Polynomial DoubleFloat,Symbol,Symbol,Point DoubleFloat,_
                 Point DoubleFloat,Corners, DoubleFloat,DoubleFloat,_
                 PositiveInteger,List Point DoubleFloat,_
                 List Point DoubleFloat) -> NewPtInfo

  newtonApprox:(SparseUnivariatePolynomial DoubleFloat, DoubleFloat, _
                DoubleFloat, PositiveInteger) -> Union(DoubleFloat, "failed")

--% representation

  Rep := Record(poly    : Polynomial Integer,_
                xVar    : Symbol,_
                yVar    : Symbol,_
                minXVal : Fraction Integer,_
                maxXVal : Fraction Integer,_
                minYVal : Fraction Integer,_
                maxYVal : Fraction Integer,_
                bdryPts : BoundaryPts,_
                hTanPts : List Point DoubleFloat,_
                vTanPts : List Point DoubleFloat,_
                branches: List List Point DoubleFloat)

--% global constants

  EPSILON : Float := .000001 -- precision to which realSolve finds roots
  PLOTERR : DoubleFloat := float(1,-3,10)
    -- maximum allowable difference in each coordinate when
    -- determining if 2 plotted points are equal

--% global flags

  NADA   : String := "nothing in particular"
  BDRY   : String := "boundary point"
  CRIT   : String := "critical point"
  BOTTOM : String := "bottom"
  TOP    : String := "top"

--% hacks

  NFtoSF: Float -> DoubleFloat
  NFtoSF x == 0 + convert(x)$Float

--% points
  makePt: (DoubleFloat,DoubleFloat) -> Point DoubleFloat
  makePt(xx,yy) == point(l : List DoubleFloat := [xx,yy])

  swapCoords(pt) == makePt(yCoord pt,xCoord pt)

  samePlottedPt?(p0,p1) ==
    -- determines if p1 lies in a square with side 2 PLOTERR
    -- centered at p0
    x0 := xCoord p0; y0 := yCoord p0
    x1 := xCoord p1; y1 := yCoord p1
    (abs(x1-x0) < PLOTERR) and (abs(y1-y0) < PLOTERR)

  findPtOnList(pt,pointList) ==
    for point in pointList repeat
      samePlottedPt?(pt,point) => return point
    "failed"

--% corners

  makeCorners(xMinSF,xMaxSF,yMinSF,yMaxSF) ==
    [xMinSF,xMaxSF,yMinSF,yMaxSF]

  getXMin(corners) == corners.minXVal
  getXMax(corners) == corners.maxXVal
  getYMin(corners) == corners.minYVal
  getYMax(corners) == corners.maxYVal

--% coercions

  SFPolyToUPoly(p) ==
  -- 'p' is of type Polynomial, but has only one variable
    zero? p => 0
    monomial(leadingCoefficient p,totalDegree p) +
       SFPolyToUPoly(reductum p)

  RNPolyToUPoly(p) ==
  -- 'p' is of type Polynomial, but has only one variable
    zero? p => 0
    monomial(leadingCoefficient p,totalDegree p) +
        RNPolyToUPoly(reductum p)

  coerceCoefsToSFs(p) ==
  -- coefficients of 'p' are coerced to be DoubleFloat's
    map(coerce,p)$PolynomialFunctions2(Integer,DoubleFloat)

  coerceCoefsToRNs(p) ==
  -- coefficients of 'p' are coerced to be DoubleFloat's
    map(coerce,p)$PolynomialFunctions2(Integer,Fraction Integer)

  RNtoSF(r) == coerce(r)@DoubleFloat
  RNtoNF(r) == coerce(r)@Float
  SFtoNF(x) == convert(x)@Float

--% computation of special points

  listPtsOnHorizBdry(pRN,y,y0,xMinNF,xMaxNF) ==
  -- strict inequality here: corners on vertical boundary
    pointList : List Point DoubleFloat := nil()
    ySF := RNtoSF(y0)
    f := eval(pRN,y,y0)
    roots : List Float := kinte(f,EPSILON)
    for root in roots repeat
      if (xMinNF < root) and (root < xMaxNF) then
        pointList := cons(makePt(NFtoSF root, ySF), pointList)
    pointList

  listPtsOnVertBdry(pRN,x,x0,yMinNF,yMaxNF) ==
    pointList : List Point DoubleFloat := nil()
    xSF := RNtoSF(x0)
    f := eval(pRN,x,x0)
    roots : List Float := kinte(f,EPSILON)
    for root in roots repeat
      if (yMinNF <= root) and (root <= yMaxNF) then
        pointList := cons(makePt(xSF, NFtoSF root), pointList)
    pointList

  listPtsInRect(points,xMin,xMax,yMin,yMax) ==
    pointList : List Point DoubleFloat := nil()
    for point in points repeat
      xx := first point; yy := second point
      if (xMin<=xx) and (xx<=xMax) and (yMin<=yy) and (yy<=yMax) then
        pointList := cons(makePt(NFtoSF xx,NFtoSF yy),pointList)
    pointList

  ptsSuchThat?(points,pred) ==
    for point in points repeat
      if pred point then return true
    false

  inRect?(point,xMinNF,xMaxNF,yMinNF,yMaxNF) ==
    xx := first point; yy := second point
    xMinNF <= xx and xx <= xMaxNF and yMinNF <= yy and yy <= yMaxNF

  onHorzSeg?(point,xMinNF,xMaxNF,yNF) ==
    xx := first point; yy := second point
    yy = yNF and xMinNF <= xx and xx <= xMaxNF

  onVertSeg?(point,yMinNF,yMaxNF,xNF) ==
    xx := first point; yy := second point
    xx = xNF and yMinNF <= yy and yy <= yMaxNF

  newX(vtanPts,singPts,yMinNF,yMaxNF,xNF,xRN,horizInc) ==
    xNewNF := xNF + RNtoNF horizInc
    xRtNF := max(xNF,xNewNF); xLftNF := min(xNF,xNewNF)
--  ptsSuchThat?(singPts,inRect?(#1,xLftNF,xRtNF,yMinNF,yMaxNF)) =>
    foo : List Float -> Boolean := inRect?(#1,xLftNF,xRtNF,yMinNF,yMaxNF)
    ptsSuchThat?(singPts,foo) =>
      newX(vtanPts,singPts,yMinNF,yMaxNF,xNF,xRN,_
        horizInc/2::(Fraction Integer))
--  ptsSuchThat?(vtanPts,onVertSeg?(#1,yMinNF,yMaxNF,xNewNF)) =>
    goo : List Float -> Boolean := onVertSeg?(#1,yMinNF,yMaxNF,xNewNF)
    ptsSuchThat?(vtanPts,goo) =>
      newX(vtanPts,singPts,yMinNF,yMaxNF,xNF,xRN,_
        horizInc/2::(Fraction Integer))
    xRN + horizInc

  newY(htanPts,singPts,xMinNF,xMaxNF,yNF,yRN,vertInc) ==
    yNewNF := yNF + RNtoNF vertInc
    yTopNF := max(yNF,yNewNF); yBotNF := min(yNF,yNewNF)
--  ptsSuchThat?(singPts,inRect?(#1,xMinNF,xMaxNF,yBotNF,yTopNF)) =>
    foo : List Float -> Boolean := inRect?(#1,xMinNF,xMaxNF,yBotNF,yTopNF)
    ptsSuchThat?(singPts,foo) =>
      newY(htanPts,singPts,xMinNF,xMaxNF,yNF,yRN,_
        vertInc/2::(Fraction Integer))
--  ptsSuchThat?(htanPts,onHorzSeg?(#1,xMinNF,xMaxNF,yNewNF)) =>
    goo : List Float -> Boolean := onHorzSeg?(#1,xMinNF,xMaxNF,yNewNF)
    ptsSuchThat?(htanPts,goo) =>
      newY(htanPts,singPts,xMinNF,xMaxNF,yNF,yRN,_
        vertInc/2::(Fraction Integer))
    yRN + vertInc

--% creation of sketches

  makeSketch(p,x,y,xRange,yRange) ==
    xMin := lo xRange; xMax := hi xRange
    yMin := lo yRange; yMax := hi yRange
    -- test input for consistency
    xMax <= xMin =>
      error "makeSketch: bad range for first variable"
    yMax <= yMin =>
      error "makeSketch: bad range for second variable"
    varList := variables p
    # varList > 2 =>
      error "makeSketch: polynomial in more than 2 variables"
    # varList = 0 =>
      error "makeSketch: constant polynomial"
    -- polynomial in 1 variable
    # varList = 1 =>
      (not member?(x,varList)) and (not member?(y,varList)) =>
        error "makeSketch: bad variables"
      makeOneVarSketch(p,x,y,xMin,xMax,yMin,yMax,first varList)
    -- polynomial in 2 variables
    (not member?(x,varList)) or (not member?(y,varList)) =>
      error "makeSketch: bad variables"
    totalDegree p = 1 =>
      makeLineSketch(p,x,y,xMin,xMax,yMin,yMax)
    -- polynomial is linear in one variable
    -- y is a rational function of x
    degree(p,y) = 1 =>
      makeRatFcnSketch(p,x,y,xMin,xMax,yMin,yMax,y)
    -- x is a rational function of y
    degree(p,x) = 1 =>
      makeRatFcnSketch(p,x,y,xMin,xMax,yMin,yMax,x)
    -- the general case
    makeGeneralSketch(p,x,y,xMin,xMax,yMin,yMax)

--% special cases

  makeOneVarSketch(p,x,y,xMin,xMax,yMin,yMax,var) ==
  -- the case where 'p' is a polynomial in only one variable
  -- the graph consists of horizontal or vertical lines
    if var = x then
      minVal := RNtoNF xMin
      maxVal := RNtoNF xMax
    else
      minVal := RNtoNF yMin
      maxVal := RNtoNF yMax
    lf : List Point DoubleFloat := nil()
    rt : List Point DoubleFloat := nil()
    bt : List Point DoubleFloat := nil() 
    tp : List Point DoubleFloat := nil()
    htans : List Point DoubleFloat := nil() 
    vtans : List Point DoubleFloat := nil()
    bran : List List Point DoubleFloat := nil()
    roots := kinte(p,EPSILON)
    sketchRoots : List DoubleFloat := nil()
    for root in roots repeat
      if (minVal <= root) and (root <= maxVal) then
          sketchRoots := cons(NFtoSF root,sketchRoots)
    null sketchRoots =>
      [p,x,y,xMin,xMax,yMin,yMax,[lf,rt,bt,tp],htans,vtans,bran]
    if var = x then
      yMinSF := RNtoSF yMin; yMaxSF := RNtoSF yMax
      for rootSF in sketchRoots repeat
          tp := cons(pt1 := makePt(rootSF,yMaxSF),tp)
          bt := cons(pt2 := makePt(rootSF,yMinSF),bt)
          branch : List Point DoubleFloat := [pt1,pt2]
          bran := cons(branch,bran)
    else
      xMinSF := RNtoSF xMin; xMaxSF := RNtoSF xMax
      for rootSF in sketchRoots repeat
          rt := cons(pt1 := makePt(xMaxSF,rootSF),rt)
          lf := cons(pt2 := makePt(xMinSF,rootSF),lf)
          branch : List Point DoubleFloat := [pt1,pt2]
          bran := cons(branch,bran)
    [p,x,y,xMin,xMax,yMin,yMax,[lf,rt,bt,tp],htans,vtans,bran]

  makeLineSketch(p,x,y,xMin,xMax,yMin,yMax) ==
  -- the case where p(x,y) = a x + b y + c with a ^= 0, b ^= 0
  -- this is a line which is neither vertical nor horizontal
    xMinSF := RNtoSF xMin; xMaxSF := RNtoSF xMax
    yMinSF := RNtoSF yMin; yMaxSF := RNtoSF yMax
    -- determine the coefficients a, b, and c
    a := ground(coefficient(p,x,1)) :: DoubleFloat
    b := ground(coefficient(p,y,1)) :: DoubleFloat
    c := ground(coefficient(coefficient(p,x,0),y,0)) :: DoubleFloat
    lf : List Point DoubleFloat := nil()
    rt : List Point DoubleFloat := nil()
    bt : List Point DoubleFloat := nil()
    tp : List Point DoubleFloat := nil()
    htans : List Point DoubleFloat := nil()
    vtans : List Point DoubleFloat := nil()
    branch : List Point DoubleFloat := nil()
    bran : List List Point DoubleFloat := nil()
    -- compute x coordinate of point on line with y = yMin
    xBottom := (- b*yMinSF - c)/a
    -- compute x coordinate of point on line with y = yMax
    xTop    := (- b*yMaxSF - c)/a
    -- compute y coordinate of point on line with x = xMin
    yLeft   := (- a*xMinSF - c)/b
    -- compute y coordinate of point on line with x = xMax
    yRight  := (- a*xMaxSF - c)/b
    -- determine which of the above 4 points are in the region
    -- to be plotted and list them as a branch
    if (xMinSF < xBottom) and (xBottom < xMaxSF) then
        bt := cons(pt := makePt(xBottom,yMinSF),bt)
        branch := cons(pt,branch)
    if (xMinSF < xTop) and (xTop < xMaxSF) then
        tp := cons(pt := makePt(xTop,yMaxSF),tp)
        branch := cons(pt,branch)
    if (yMinSF <= yLeft) and (yLeft <= yMaxSF) then
        lf := cons(pt := makePt(xMinSF,yLeft),lf)
        branch := cons(pt,branch)
    if (yMinSF <= yRight) and (yRight <= yMaxSF) then
        rt := cons(pt := makePt(xMaxSF,yRight),rt)
        branch := cons(pt,branch)
    bran := cons(branch,bran)
    [p,x,y,xMin,xMax,yMin,yMax,[lf,rt,bt,tp],htans,vtans,bran]

  singValBetween?(xCurrent,xNext,xSingList) ==
    for xVal in xSingList repeat
      (xCurrent < xVal) and (xVal < xNext) => return true
    false

  segmentInfo(f,lo,hi,botList,topList,singList,minSF,maxSF) ==
    repeat
      -- 'current' is the smallest element of 'topList' and 'botList'
      -- 'currentFrom' records the list from which it was taken
      if null topList then
        if null botList then
          return [segment(lo,hi),hi,nil(),nil()]
        else
          current := first botList
          botList := rest  botList
          currentFrom := BOTTOM
      else
        if null botList then
          current := first topList
          topList := rest  topList
          currentFrom := TOP
        else
          bot := first botList
          top := first topList
          if bot < top then
            current := bot
            botList := rest botList
            currentFrom := BOTTOM
          else
            current := top
            topList := rest topList
            currentFrom := TOP
      -- 'nxt' is the next smallest element of 'topList'
      --  and 'botList'
      -- 'nextFrom' records the list from which it was taken
      if null topList then
        if null botList then
          return [segment(lo,hi),hi,nil(),nil()]
        else
          nxt := first botList
          botList := rest botList
          nextFrom := BOTTOM
      else
        if null botList then
          nxt := first topList
          topList := rest topList
          nextFrom := TOP
        else
          bot := first botList
          top := first topList
          if bot < top then
            nxt := bot
            botList := rest botList
            nextFrom := BOTTOM
          else
            nxt := top
            topList := rest topList
            nextFrom := TOP
      if currentFrom = nextFrom then
        if singValBetween?(current,nxt,singList) then
          return [segment(lo,current),nxt,botList,topList]
        else
          val := f((nxt - current)/2::DoubleFloat)
          if (val <= minSF) or (val >= maxSF) then
            return [segment(lo,current),nxt,botList,topList]
      else
        if singValBetween?(current,nxt,singList) then
          return [segment(lo,current),nxt,botList,topList]

  makeRatFcnSketch(p,x,y,xMin,xMax,yMin,yMax,depVar) ==
  -- the case where p(x,y) is linear in x or y
  -- Thus, one variable is a rational function of the other.
  -- Therefore, we may use the 2-dimensional function plotting
  -- package.  The only problem is determining the intervals on
  -- on which the function is to be plotted.
  --!! corners: e.g. upper left corner is on graph with y' > 0
    factoredP := p ::(Factored Polynomial Integer)
    numberOfFactors(factoredP) > 1 =>
        error "reducible polynomial"  --!! sketch each factor
    dpdx := differentiate(p,x)
    dpdy := differentiate(p,y)
    pRN := coerceCoefsToRNs p
    xMinSF := RNtoSF xMin; xMaxSF := RNtoSF xMax
    yMinSF := RNtoSF yMin; yMaxSF := RNtoSF yMax
    xMinNF := RNtoNF xMin; xMaxNF := RNtoNF xMax
    yMinNF := RNtoNF yMin; yMaxNF := RNtoNF yMax
    -- 'p' is of degree 1 in the variable 'depVar'.
    -- Thus, 'depVar' is a rational function of the other variable.
    num := -coefficient(p,depVar,0)
    den :=  coefficient(p,depVar,1)
    numUPolySF := SFPolyToUPoly(coerceCoefsToSFs(num))
    denUPolySF := SFPolyToUPoly(coerceCoefsToSFs(den))
    -- this is the rational function
    f : DoubleFloat -> DoubleFloat := elt(numUPolySF,#1)/elt(denUPolySF,#1)
    -- values of the dependent and independent variables
    if depVar = x then
      indVarMin   := yMin;   indVarMax   := yMax
      indVarMinNF := yMinNF; indVarMaxNF := yMaxNF
      indVarMinSF := yMinSF; indVarMaxSF := yMaxSF
      depVarMin   := xMin;   depVarMax   := xMax
      depVarMinSF := xMinSF; depVarMaxSF := xMaxSF
    else
      indVarMin   := xMin;   indVarMax   := xMax
      indVarMinNF := xMinNF; indVarMaxNF := xMaxNF
      indVarMinSF := xMinSF; indVarMaxSF := xMaxSF
      depVarMin   := yMin;   depVarMax   := yMax
      depVarMinSF := yMinSF; depVarMaxSF := yMaxSF
    -- Create lists of critical points.
    htanPts := rsolve([p,dpdx],[x,y],EPSILON)
    vtanPts := rsolve([p,dpdy],[x,y],EPSILON)
    htans := listPtsInRect(htanPts,xMinNF,xMaxNF,yMinNF,yMaxNF)
    vtans := listPtsInRect(vtanPts,xMinNF,xMaxNF,yMinNF,yMaxNF)
    -- Create lists which will contain boundary points.
    lf : List Point DoubleFloat := nil()
    rt : List Point DoubleFloat := nil()
    bt : List Point DoubleFloat := nil()
    tp : List Point DoubleFloat := nil()
    -- Determine values of the independent variable at the which
    -- the rational function has a pole as well as the values of
    -- the independent variable for which there is a point on the
    -- upper or lower boundary.
    singList : List DoubleFloat :=
      roots : List Float := kinte(den,EPSILON)
      outList : List DoubleFloat := nil()
      for root in roots repeat
        if (indVarMinNF < root) and (root < indVarMaxNF) then
          outList := cons(NFtoSF root,outList)
      sort(#1 < #2,outList)
    topList : List DoubleFloat :=
      roots : List Float := kinte(eval(pRN,depVar,depVarMax),EPSILON)
      outList : List DoubleFloat := nil()
      for root in roots repeat
        if (indVarMinNF < root) and (root < indVarMaxNF) then
          outList := cons(NFtoSF root,outList)
      sort(#1 < #2,outList)
    botList : List DoubleFloat :=
      roots : List Float := kinte(eval(pRN,depVar,depVarMin),EPSILON)
      outList : List DoubleFloat := nil()
      for root in roots repeat
        if (indVarMinNF < root) and (root < indVarMaxNF) then
          outList := cons(NFtoSF root,outList)
      sort(#1 < #2,outList)
    -- We wish to determine if the graph has points on the 'left'
    -- and 'right' boundaries, so we compute the value of the
    -- rational function at the lefthand and righthand values of
    -- the dependent variable.  If the function has a singularity
    -- on the left or right boundary, then 'leftVal' or 'rightVal'
    -- is given a dummy valuewhich will convince the program that
    -- there is no point on the left or right boundary.
    denUPolyRN := RNPolyToUPoly(coerceCoefsToRNs(den))
    if elt(denUPolyRN,indVarMin) = 0$(Fraction Integer) then
      leftVal  := depVarMinSF - (abs(depVarMinSF) + 1$DoubleFloat)
    else
      leftVal  := f(indVarMinSF)
    if elt(denUPolyRN,indVarMax) = 0$(Fraction Integer) then
      rightVal := depVarMinSF - (abs(depVarMinSF) + 1$DoubleFloat)
    else
      rightVal := f(indVarMaxSF)
    -- Now put boundary points on the appropriate lists.
    if depVar = x then
      if (xMinSF < leftVal) and (leftVal < xMaxSF) then
        bt := cons(makePt(leftVal,yMinSF),bt)
      if (xMinSF < rightVal) and (rightVal < xMaxSF) then
        tp := cons(makePt(rightVal,yMaxSF),tp)
      for val in botList repeat
        lf := cons(makePt(xMinSF,val),lf)
      for val in topList repeat
        rt := cons(makePt(xMaxSF,val),rt)
    else
      if (yMinSF < leftVal) and (leftVal < yMaxSF) then
        lf := cons(makePt(xMinSF,leftVal),lf)
      if (yMinSF < rightVal) and (rightVal < yMaxSF) then
        rt := cons(makePt(xMaxSF,rightVal),rt)
      for val in botList repeat
        bt := cons(makePt(val,yMinSF),bt)
      for val in topList repeat
        tp := cons(makePt(val,yMaxSF),tp)
    bran : List List Point DoubleFloat := nil()
    -- Determine segments on which the rational function is to
    -- be plotted.
    if (depVarMinSF < leftVal) and (leftVal < depVarMaxSF) then
      lo := indVarMinSF
    else
      if null topList then
        if null botList then
          return [p,x,y,xMin,xMax,yMin,yMax,[lf,rt,bt,tp],_
                                          htans,vtans,bran]
        else
          lo := first botList
          botList := rest botList
      else
        if null botList then
          lo := first topList
          topList := rest topList
        else
          bot := first botList
          top := first topList
          if bot < top then
            lo := bot
            botList := rest botList
          else
            lo := top
            topList := rest topList
    hi := 0$DoubleFloat  -- @#$%^&* compiler
    if (depVarMinSF < rightVal) and (rightVal < depVarMaxSF) then
      hi := indVarMaxSF
    else
      if null topList then
        if null botList then
          error "makeRatFcnSketch: plot domain"
        else
          hi := last botList
          botList := remove(hi,botList)
      else
        if null botList then
          hi := last topList
          topList := remove(hi,topList)
        else
          bot := last botList
          top := last topList
          if bot > top then
            hi := bot
            botList := remove(hi,botList)
          else
            hi := top
            topList := remove(hi,topList)
    if (depVar = x) then
      (minSF := xMinSF; maxSF := xMaxSF)
    else
      (minSF := yMinSF; maxSF := yMaxSF)
    segList : List Segment DoubleFloat := nil()
    repeat
      segInfo := segmentInfo(f,lo,hi,botList,topList,singList,_
                                  minSF,maxSF)
      segList := cons(segInfo.seg,segList)
      lo := segInfo.left
      botList := segInfo.lowerVals
      topList := segInfo.upperVals
      if lo = hi then break
    for segment in segList repeat
      RFPlot : Plot := plot(f,segment)
      curve := first(listBranches(RFPlot))
      if depVar = y then
        bran := cons(curve,bran)
      else
        bran := cons(map(swapCoords,curve),bran)
    [p,x,y,xMin,xMax,yMin,yMax,[lf,rt,bt,tp],htans,vtans,bran]

--% the general case

  makeGeneralSketch(pol,x,y,xMin,xMax,yMin,yMax) ==
    --!! corners of region should not be on curve
    --!! enlarge region if necessary
    factoredPol := pol :: (Factored Polynomial Integer)
    numberOfFactors(factoredPol) > 1 =>
        error "reducible polynomial"  --!! sketch each factor
    p := nthFactor(factoredPol,1)
    dpdx := differentiate(p,x); dpdy := differentiate(p,y)
    xMinNF := RNtoNF xMin; xMaxNF := RNtoNF xMax
    yMinNF := RNtoNF yMin; yMaxNF := RNtoNF yMax
    -- compute singular points; error if singularities in region
    singPts := rsolve([p,dpdx,dpdy],[x,y],EPSILON)
--  ptsSuchThat?(singPts,inRect?(#1,xMinNF,xMaxNF,yMinNF,yMaxNF)) =>
    foo : List Float -> Boolean := inRect?(#1,xMinNF,xMaxNF,yMinNF,yMaxNF)
    ptsSuchThat?(singPts,foo) =>
      error "singular pts in region of sketch"
    -- compute critical points
    htanPts := rsolve([p,dpdx],[x,y],EPSILON)
    vtanPts := rsolve([p,dpdy],[x,y],EPSILON)
    critPts := append(htanPts,vtanPts)
    -- if there are critical points on the boundary, then enlarge
    -- the region, but be sure that the new region does not contain
    -- any singular points
    hInc : Fraction Integer := (1/20) * (xMax - xMin)
    vInc : Fraction Integer := (1/20) * (yMax - yMin)
--  if ptsSuchThat?(critPts,onVertSeg?(#1,yMinNF,yMaxNF,xMinNF)) then
    foo : List Float -> Boolean := onVertSeg?(#1,yMinNF,yMaxNF,xMinNF)
    if ptsSuchThat?(critPts,foo) then
      xMin := newX(critPts,singPts,yMinNF,yMaxNF,xMinNF,xMin,-hInc)
      xMinNF := RNtoNF xMin
--  if ptsSuchThat?(critPts,onVertSeg?(#1,yMinNF,yMaxNF,xMaxNF)) then
    foo : List Float -> Boolean := onVertSeg?(#1,yMinNF,yMaxNF,xMaxNF)
    if ptsSuchThat?(critPts,foo) then
      xMax := newX(critPts,singPts,yMinNF,yMaxNF,xMaxNF,xMax,hInc)
      xMaxNF := RNtoNF xMax
--  if ptsSuchThat?(critPts,onHorzSeg?(#1,xMinNF,xMaxNF,yMinNF)) then
    foo : List Float -> Boolean := onHorzSeg?(#1,xMinNF,xMaxNF,yMinNF)
    if ptsSuchThat?(critPts,foo) then
      yMin := newY(critPts,singPts,xMinNF,xMaxNF,yMinNF,yMin,-vInc)
      yMinNF := RNtoNF yMin
--  if ptsSuchThat?(critPts,onHorzSeg?(#1,xMinNF,xMaxNF,yMaxNF)) then
    foo : List Float -> Boolean := onHorzSeg?(#1,xMinNF,xMaxNF,yMaxNF)
    if ptsSuchThat?(critPts,foo) then
      yMax := newY(critPts,singPts,xMinNF,xMaxNF,yMaxNF,yMax,vInc)
      yMaxNF := RNtoNF yMax
    htans := listPtsInRect(htanPts,xMinNF,xMaxNF,yMinNF,yMaxNF)
    vtans := listPtsInRect(vtanPts,xMinNF,xMaxNF,yMinNF,yMaxNF)
    crits := append(htans,vtans)
    -- conversions to DoubleFloats
    xMinSF := RNtoSF xMin; xMaxSF := RNtoSF xMax
    yMinSF := RNtoSF yMin; yMaxSF := RNtoSF yMax
    corners := makeCorners(xMinSF,xMaxSF,yMinSF,yMaxSF)
    pSF := coerceCoefsToSFs p
    dpdxSF := coerceCoefsToSFs dpdx
    dpdySF := coerceCoefsToSFs dpdy
    delta := min((xMaxSF - xMinSF)/25,(yMaxSF - yMinSF)/25)
    err := min(delta/100,PLOTERR/100)
    bound : PositiveInteger := 10
    -- compute points on the boundary
    pRN := coerceCoefsToRNs(p)
    lf : List Point DoubleFloat := 
      listPtsOnVertBdry(pRN,x,xMin,yMinNF,yMaxNF)
    rt : List Point DoubleFloat := 
      listPtsOnVertBdry(pRN,x,xMax,yMinNF,yMaxNF)
    bt : List Point DoubleFloat := 
      listPtsOnHorizBdry(pRN,y,yMin,xMinNF,xMaxNF)
    tp : List Point DoubleFloat := 
      listPtsOnHorizBdry(pRN,y,yMax,xMinNF,xMaxNF)
    bdPts : BoundaryPts := [lf,rt,bt,tp]
    bran := traceBranches(pSF,dpdxSF,dpdySF,x,y,corners,delta,err,_
                           bound,crits,bdPts)
    [p,x,y,xMin,xMax,yMin,yMax,bdPts,htans,vtans,bran]

  refine(plot,stepFraction) ==
    p := plot.poly; x := plot.xVar; y := plot.yVar
    dpdx := differentiate(p,x); dpdy := differentiate(p,y)
    pSF := coerceCoefsToSFs p
    dpdxSF := coerceCoefsToSFs dpdx
    dpdySF := coerceCoefsToSFs dpdy
    xMin := plot.minXVal; xMax := plot.maxXVal
    yMin := plot.minYVal; yMax := plot.maxYVal
    xMinSF := RNtoSF xMin; xMaxSF := RNtoSF xMax
    yMinSF := RNtoSF yMin; yMaxSF := RNtoSF yMax
    corners := makeCorners(xMinSF,xMaxSF,yMinSF,yMaxSF)
    pSF := coerceCoefsToSFs p
    dpdxSF := coerceCoefsToSFs dpdx
    dpdySF := coerceCoefsToSFs dpdy
    delta :=
      stepFraction * min((xMaxSF - xMinSF)/25,(yMaxSF - yMinSF)/25)
    err := min(delta/100,PLOTERR/100)
    bound : PositiveInteger := 10
    crits := append(plot.hTanPts,plot.vTanPts)
    bdPts := plot.bdryPts
    bran := traceBranches(pSF,dpdxSF,dpdySF,x,y,corners,delta,err,_
                           bound,crits,bdPts)
    htans := plot.hTanPts; vtans := plot.vTanPts
    [p,x,y,xMin,xMax,yMin,yMax,bdPts,htans,vtans,bran]

  traceBranches(pSF,dpdxSF,dpdySF,x,y,corners,delta,err,bound,_
                    crits,bdPts) ==
    -- for boundary points, trace curve from boundary to boundary
    -- add the branch to the list of branches
    -- update list of boundary points by deleting first and last
    -- points on this branch
    -- update list of critical points by deleting any critical
    -- points which were plotted
    lf := bdPts.left; rt := bdPts.right
    tp := bdPts.top ; bt := bdPts.bottom
    bdry := append(append(lf,rt),append(bt,tp))
    bran : List List Point DoubleFloat := nil()
    while not null bdry repeat
      pt := first bdry
      p0 := dummyFirstPt(pt,dpdxSF,dpdySF,x,y,lf,rt,bt,tp)
      segInfo := listPtsOnSegment(pSF,dpdxSF,dpdySF,x,y,p0,pt,_
                       corners,delta,err,bound,crits,bdry)
      bran  := cons(first segInfo,bran)
      crits := second segInfo
      bdry  := third segInfo
    -- trace loops beginning and ending with critical points
    -- add the branch to the list of branches
    -- update list of critical points by deleting any critical
    -- points which were plotted
    while not null crits repeat
      pt := first crits
      segInfo := listPtsOnLoop(pSF,dpdxSF,dpdySF,x,y,pt,_
                       corners,delta,err,bound,crits,bdry)
      bran  := cons(first segInfo,bran)
      crits := second segInfo
    bran

  dummyFirstPt(p1,dpdxSF,dpdySF,x,y,lf,rt,bt,tp) ==
  -- The function 'computeNextPt' requires 2 points, p0 and p1.
  -- When computing the second point on a branch which starts
  -- on the boundary, we use the boundary point as p1 and the
  -- 'dummy' point returned by this function as p0.
    x1 := xCoord p1; y1 := yCoord p1
    zero := 0$DoubleFloat; one := 1$DoubleFloat
    px := ground(eval(dpdxSF,[x,y],[x1,y1]))
    py := ground(eval(dpdySF,[x,y],[x1,y1]))
    if px * py < zero then       -- positive slope at p1
      member?(p1,lf) or member?(p1,bt) =>
        makePt(x1 - one,y1 - one)
      makePt(x1 + one,y1 + one)
    else
      member?(p1,lf) or member?(p1,tp) =>
        makePt(x1 - one,y1 + one)
      makePt(x1 + one,y1 - one)


  listPtsOnSegment(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                                 delta,err,bound,crits,bdry) ==
  -- p1 is a boundary point; p0 is a 'dummy' point
    bdry := remove(p1,bdry)
    pointList : List Point DoubleFloat := [p1]
    ptInfo := computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                                 delta,err,bound,crits,bdry)
    p2 := ptInfo.newPt
    ptInfo.type = BDRY =>
      bdry := remove(p2,bdry)
      pointList := cons(p2,pointList)
      [pointList,crits,bdry]
    if ptInfo.type = CRIT then crits := remove(p2,crits)
    pointList := cons(p2,pointList)
    repeat
      pt0 := second pointList; pt1 := first pointList
      ptInfo := computeNextPt(pSF,dpdxSF,dpdySF,x,y,pt0,pt1,corners,_
                                   delta,err,bound,crits,bdry)
      p2 := ptInfo.newPt
      ptInfo.type = BDRY =>
        bdry := remove(p2,bdry)
        pointList := cons(p2,pointList)
        return [pointList,crits,bdry]
      if ptInfo.type = CRIT then crits := remove(p2,crits)
      pointList := cons(p2,pointList)
    --!! delete next line (compiler bug)
    [pointList,crits,bdry]


  listPtsOnLoop(pSF,dpdxSF,dpdySF,x,y,p1,corners,_
                                 delta,err,bound,crits,bdry) ==
    x1 := xCoord p1; y1 := yCoord p1
    px := ground(eval(dpdxSF,[x,y],[x1,y1]))
    py := ground(eval(dpdySF,[x,y],[x1,y1]))
    p0 := makePt(x1 - 1$DoubleFloat,y1 - 1$DoubleFloat)
    pointList : List Point DoubleFloat := [p1]
    ptInfo := computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                                 delta,err,bound,crits,bdry)
    p2 := ptInfo.newPt
    ptInfo.type = BDRY =>
      error "boundary reached while on loop"
    if ptInfo.type = CRIT then
      p1 = p2 =>
        error "first and second points on loop are identical"
      crits := remove(p2,crits)
    pointList := cons(p2,pointList)
    repeat
      pt0 := second pointList; pt1 := first pointList
      ptInfo := computeNextPt(pSF,dpdxSF,dpdySF,x,y,pt0,pt1,corners,_
                                   delta,err,bound,crits,bdry)
      p2 := ptInfo.newPt
      ptInfo.type = BDRY =>
        error "boundary reached while on loop"
      if ptInfo.type = CRIT then
        crits := remove(p2,crits)
        p1 = p2 =>
          pointList := cons(p2,pointList)
          return [pointList,crits,bdry]
      pointList := cons(p2,pointList)
    --!! delete next line (compiler bug)
    [pointList,crits,bdry]

  computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                                 delta,err,bound,crits,bdry) ==
  -- p0=(x0,y0) and p1=(x1,y1) are the last two points on the curve.
  -- The function computes the next point on the curve.
  -- The function determines if the next point is a critical point
  -- or a boundary point.
  -- The function returns a record of the form
  -- Record(newPt:Point DoubleFloat,type:String).
  -- If the new point is a boundary point, then 'type' is
  -- "boundary point" and 'newPt' is a boundary point to be
  -- deleted from the list of boundary points yet to be plotted.
  -- Similarly, if the new point is a critical point, then 'type' is
  -- "critical point" and 'newPt' is a critical point to be
  -- deleted from the list of critical points yet to be plotted.
  -- If the new point is neither a critical point nor a boundary
  -- point, then 'type' is "nothing in particular".
    xMinSF := getXMin corners; xMaxSF := getXMax corners
    yMinSF := getYMin corners; yMaxSF := getYMax corners
    x0 := xCoord p0; y0 := yCoord p0
    x1 := xCoord p1; y1 := yCoord p1
    px := ground(eval(dpdxSF,[x,y],[x1,y1]))
    py := ground(eval(dpdySF,[x,y],[x1,y1]))
    -- let m be the slope of the tangent line at p1
    -- if |m| < 1, we will increment the x-coordinate by delta
    -- (indicated by 'incVar = x'), find an approximate
    -- y-coordinate using the tangent line, then find the actual
    -- y-coordinate using a Newton iteration
    if abs(py) > abs(px) then
      incVar0 := incVar := x
      deltaX := (if x1 > x0 then delta else -delta)
      x2Approx := x1 + deltaX
      y2Approx := y1 + (-px/py)*deltaX
    -- if |m| >= 1, we interchange the roles of the x- and y-
    -- coordinates
    else
      incVar0 := incVar := y
      deltaY := (if y1 > y0 then delta else -delta)
      x2Approx := x1 + (-py/px)*deltaY
      y2Approx := y1 + deltaY
    lookingFor := NADA
    -- See if (x2Approx,y2Approx) is out of bounds.
    -- If so, find where the line segment connecting (x1,y1) and
    -- (x2Approx,y2Approx) intersects the boundary and use this
    -- point as (x2Approx,y2Approx).
    -- If the resulting point is on the left or right boundary,
    -- we will now consider x as the 'incremented variable' and we
    -- will compute the y-coordinate using a Newton iteration.
    -- Similarly, if the point is on the top or bottom boundary,
    -- we will consider y as the 'incremented variable' and we
    -- will compute the x-coordinate using a Newton iteration.
    if x2Approx >= xMaxSF then
      incVar := x
      lookingFor := BDRY
      x2Approx := xMaxSF
      y2Approx := y1 + (-px/py)*(x2Approx - x1)
    else
      if x2Approx <= xMinSF then
        incVar := x
        lookingFor := BDRY
        x2Approx := xMinSF
        y2Approx := y1 + (-px/py)*(x2Approx - x1)
    if y2Approx >= yMaxSF then
      incVar := y
      lookingFor := BDRY
      y2Approx := yMaxSF
      x2Approx := x1 + (-py/px)*(y2Approx - y1)
    else
      if y2Approx <= yMinSF then
        incVar := y
        lookingFor := BDRY
        y2Approx := yMinSF
        x2Approx := x1 + (-py/px)*(y2Approx - y1)
    -- set xLo = min(x1,x2Approx), xHi = max(x1,x2Approx)
    -- set yLo = min(y1,y2Approx), yHi = max(y1,y2Approx)
    if x1 < x2Approx then
      xLo := x1
      xHi := x2Approx
    else
      xLo := x2Approx
      xHi := x1
    if y1 < y2Approx then
      yLo := y1
      yHi := y2Approx
    else
      yLo := y2Approx
      yHi := y1
    -- check for critical points (x*,y*) with x* between
    -- x1 and x2Approx or y* between y1 and y2Approx
    -- store values of x2Approx and y2Approx
    x2Approxx := x2Approx
    y2Approxx := y2Approx
    -- xPointList will contain all critical points (x*,y*)
    -- with x* between x1 and x2Approx
    xPointList : List Point DoubleFloat := nil()
    -- yPointList will contain all critical points (x*,y*)
    -- with y* between y1 and y2Approx
    yPointList : List Point DoubleFloat := nil()
    for pt in crits repeat
      xx := xCoord pt; yy := yCoord pt
      -- if x1 = x2Approx, then p1 is a point with horizontal
      -- tangent line
      -- in this case, we don't want critical points with
      -- x-coordinate x1
      if xx = x2Approx and not (xx = x1) then
        if min(abs(yy-yLo),abs(yy-yHi)) < delta then
          xPointList := cons(pt,xPointList)
      if ((xLo < xx) and (xx < xHi)) then
        if min(abs(yy-yLo),abs(yy-yHi)) < delta then
          xPointList := cons(pt,nil())
          x2Approx := xx
          if xx < x1 then xLo := xx else xHi := xx
      -- if y1 = y2Approx, then p1 is a point with vertical
      -- tangent line
      -- in this case, we don't want critical points with
      -- y-coordinate y1
      if yy = y2Approx and not (yy = y1) then
          yPointList := cons(pt,yPointList)
      if ((yLo < yy) and (yy < yHi)) then
        if min(abs(xx-xLo),abs(xx-xHi)) < delta then
          yPointList := cons(pt,nil())
          y2Approx := yy
          if yy < y1 then yLo := yy else yHi := yy
    -- points in both xPointList and yPointList
    if (not null xPointList) and (not null yPointList) then
      xPointList = yPointList =>
      -- this implies that the lists have only one point
        incVar := incVar0
        if incVar = x then
          y2Approx := y1 + (-px/py)*(x2Approx - x1)
        else
          x2Approx := x1 + (-py/px)*(y2Approx - y1)
        lookingFor := CRIT        -- proceed
      incVar0 = x =>
      -- first try Newton iteration with 'y' as incremented variable
        x2Temp := x1 + (-py/px)*(y2Approx - y1)
        f := SFPolyToUPoly(eval(pSF,y,y2Approx))
        x2New := newtonApprox(f,x2Temp,err,bound)
        x2New case "failed" =>
          y2Approx := y1 + (-px/py)*(x2Approx - x1)
          incVar := x
          lookingFor := CRIT      -- proceed
        y2Temp := y1 + (-px/py)*(x2Approx - x1)
        f := SFPolyToUPoly(eval(pSF,x,x2Approx))
        y2New := newtonApprox(f,y2Temp,err,bound)
        y2New case "failed" =>
          return computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                        abs((x2Approx-x1)/2),err,bound,crits,bdry)
        pt1 := makePt(x2Approx,y2New :: DoubleFloat)
        pt2 := makePt(x2New :: DoubleFloat,y2Approx)
        critPt1 := findPtOnList(pt1,crits)
        critPt2 := findPtOnList(pt2,crits)
        (critPt1 case "failed") and (critPt2 case "failed") =>
          abs(x2Approx - x1) > abs(x2Temp - x1) =>
            return [pt1,NADA]
          return [pt2,NADA]
        (critPt1 case "failed") =>
          return [critPt2::(Point DoubleFloat),CRIT]
        (critPt2 case "failed") =>
          return [critPt1::(Point DoubleFloat),CRIT]
        abs(x2Approx - x1) > abs(x2Temp - x1) =>
          return [critPt2::(Point DoubleFloat),CRIT]
        return [critPt1::(Point DoubleFloat),CRIT]
      y2Temp := y1 + (-px/py)*(x2Approx - x1)
      f := SFPolyToUPoly(eval(pSF,x,x2Approx))
      y2New := newtonApprox(f,y2Temp,err,bound)
      y2New case "failed" =>
        x2Approx := x1 + (-py/px)*(y2Approx - y1)
        incVar := y
        lookingFor := CRIT      -- proceed
      x2Temp := x1 + (-py/px)*(y2Approx - y1)
      f := SFPolyToUPoly(eval(pSF,y,y2Approx))
      x2New := newtonApprox(f,x2Temp,err,bound)
      x2New case "failed" =>
        return computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                      abs((y2Approx-y1)/2),err,bound,crits,bdry)
      pt1 := makePt(x2Approx,y2New :: DoubleFloat)
      pt2 := makePt(x2New :: DoubleFloat,y2Approx)
      critPt1 := findPtOnList(pt1,crits)
      critPt2 := findPtOnList(pt2,crits)
      (critPt1 case "failed") and (critPt2 case "failed") =>
        abs(y2Approx - y1) > abs(y2Temp - y1) =>
          return [pt2,NADA]
        return [pt1,NADA]
      (critPt1 case "failed") =>
        return [critPt2::(Point DoubleFloat),CRIT]
      (critPt2 case "failed") =>
        return [critPt1::(Point DoubleFloat),CRIT]
      abs(y2Approx - y1) > abs(y2Temp - y1) =>
        return [critPt1::(Point DoubleFloat),CRIT]
      return [critPt2::(Point DoubleFloat),CRIT]
    if (not null xPointList) and (null yPointList) then
      y2Approx := y1 + (-px/py)*(x2Approx - x1)
      incVar0 = x =>
        incVar := x
        lookingFor := CRIT        -- proceed
      f := SFPolyToUPoly(eval(pSF,x,x2Approx))
      y2New := newtonApprox(f,y2Approx,err,bound)
      y2New case "failed" =>
        x2Approx := x2Approxx
        y2Approx := y2Approxx     -- proceed
      pt := makePt(x2Approx,y2New::DoubleFloat)
      critPt := findPtOnList(pt,crits)
      critPt case "failed" =>
        return [pt,NADA]
      return [critPt :: (Point DoubleFloat),CRIT]
    if (null xPointList) and (not null yPointList) then
      x2Approx := x1 + (-py/px)*(y2Approx - y1)
      incVar0 = y =>
        incVar := y
        lookingFor := CRIT        -- proceed
      f := SFPolyToUPoly(eval(pSF,y,y2Approx))
      x2New := newtonApprox(f,x2Approx,err,bound)
      x2New case "failed" =>
        x2Approx := x2Approxx
        y2Approx := y2Approxx     -- proceed
      pt := makePt(x2New::DoubleFloat,y2Approx)
      critPt := findPtOnList(pt,crits)
      critPt case "failed" =>
        return [pt,NADA]
      return [critPt :: (Point DoubleFloat),CRIT]
    if incVar = x then
      x2 := x2Approx
      f := SFPolyToUPoly(eval(pSF,x,x2))
      y2New := newtonApprox(f,y2Approx,err,bound)
      y2New case "failed" =>
        return computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                               abs((x2-x1)/2),err,bound,crits,bdry)
      y2 := y2New :: DoubleFloat
    else
      y2 := y2Approx
      f := SFPolyToUPoly(eval(pSF,y,y2))
      x2New := newtonApprox(f,x2Approx,err,bound)
      x2New case "failed" =>
        return computeNextPt(pSF,dpdxSF,dpdySF,x,y,p0,p1,corners,_
                               abs((y2-y1)/2),err,bound,crits,bdry)
      x2 := x2New :: DoubleFloat
    pt := makePt(x2,y2)
    --!! check that 'pt' is not out of bounds
    -- check if you've gotten a critical or boundary point
    lookingFor = NADA =>
      [pt,lookingFor]
    lookingFor = BDRY =>
      bdryPt := findPtOnList(pt,bdry)
      bdryPt case "failed" =>
        error "couldn't find boundary point"
      [bdryPt :: (Point DoubleFloat),BDRY]
    critPt := findPtOnList(pt,crits)
    critPt case "failed" =>
      [pt,NADA]
    [critPt :: (Point DoubleFloat),CRIT]

--% Newton iterations

  newtonApprox(f,a0,err,bound) ==
  -- Newton iteration to approximate a root of the polynomial 'f'
  -- using an initial approximation of 'a0'
  -- Newton iteration terminates when consecutive approximations
  -- are within 'err' of each other
  -- returns "failed" if this has not been achieved after 'bound'
  -- iterations
    Df := differentiate f
    oldApprox := a0
    newApprox := a0 - elt(f,a0)/elt(Df,a0)
    i : PositiveInteger := 1
    while abs(newApprox - oldApprox) > err repeat
      i = bound => return "failed"
      oldApprox := newApprox
      newApprox := oldApprox - elt(f,oldApprox)/elt(Df,oldApprox)
      i := i+1
    newApprox

--% graphics output

  listBranches(acplot) == acplot.branches

--% terminal output

  coerce(acplot:%) ==
    pp := acplot.poly :: OutputForm
    xx := acplot.xVar :: OutputForm
    yy := acplot.yVar :: OutputForm
    xLo := acplot.minXVal :: OutputForm
    xHi := acplot.maxXVal :: OutputForm
    yLo := acplot.minYVal :: OutputForm
    yHi := acplot.maxYVal :: OutputForm
    zip := message(" = 0")
    com := message(",   ")
    les := message(" <= ")
    l : List OutputForm :=
      [pp,zip,com,xLo,les,xx,les,xHi,com,yLo,les,yy,les,yHi]
    f : List OutputForm := nil()
    for branch in acplot.branches repeat
      ll : List OutputForm := [p :: OutputForm for p in branch]
      f := cons(vconcat ll,f)
    ff := vconcat(hconcat l,vconcat f)
    vconcat(message "ACPLOT",ff)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain PRIMARR PrimitiveArray}
<<dot>>=
"PRIMARR" -> "A1AGG"
"PrimitiveArray(a:Type)" -> "OneDimensionalArrayAggregate(a:Type)"
@
\pagehead{PrimitiveArray}{PRIMARR}
\pagepic{ps/v103primitivearray.ps}{PRIMARR}{1.00}
<<domain PRIMARR PrimitiveArray>>=
)abbrev domain PRIMARR PrimitiveArray
++ This provides a fast array type with no bound checking on elt's.
++ Minimum index is 0 in this type, cannot be changed
PrimitiveArray(S:Type): OneDimensionalArrayAggregate S == add
   Qmax ==> QVMAXINDEX$Lisp
   Qsize ==> QVSIZE$Lisp
--   Qelt ==> QVELT$Lisp
--   Qsetelt ==> QSETVELT$Lisp
   Qelt ==> ELT$Lisp
   Qsetelt ==> SETELT$Lisp
   Qnew ==> GETREFV$Lisp

   #x                          == Qsize x
   minIndex x                  == 0
   empty()                     == Qnew(0$Lisp)
   new(n, x)                   == fill_!(Qnew n, x)
   qelt(x, i)                  == Qelt(x, i)
   elt(x:%, i:Integer)         == Qelt(x, i)
   qsetelt_!(x, i, s)          == Qsetelt(x, i, s)
   setelt(x:%, i:Integer, s:S) == Qsetelt(x, i, s)
   fill_!(x, s)       == (for i in 0..Qmax x repeat Qsetelt(x, i, s); x)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Q}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain QEQUAT QueryEquation}
<<dot>>=
"QEQUAT" -> "KOERCE"
"QueryEquation()" -> "CoercibleTo(OutputForm)"
@
\pagehead{QueryEquation}{QEQUAT}
\pagepic{ps/v103queryequation.ps}{QEQUAT}{1.00}
<<domain QEQUAT QueryEquation>>=
)abbrev domain QEQUAT QueryEquation
++ This domain implements simple database queries 
QueryEquation(): Exports == Implementation where
  Exports == CoercibleTo(OutputForm) with
    equation: (Symbol,String) -> %
      ++ equation(s,"a") creates a new equation.
    variable: % -> Symbol
      ++ variable(q) returns the variable (i.e. left hand side) of \axiom{q}.
    value: % -> String
      ++ value(q) returns the value (i.e. right hand side) of \axiom{q}.
  Implementation == add
    Rep := Record(var:Symbol, val:String)
    coerce(u) == coerce(u.var)$Symbol = coerce(u.val)$String
    equation(x,s) == [x,s]
    variable q == q.var
    value q == q.val

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain QUEUE Queue}
<<dot>>=
"QUEUE" -> "QUAGG"
"Queue(a:SetCategory)" -> "QueueAggregate(a:SetCategory)"
@
\pagehead{Queue}{QUEUE}
\pagepic{ps/v103queue.ps}{QUEUE}{1.00}
<<domain QUEUE Queue>>=
)abbrev domain QUEUE Queue
++ Author: Michael Monagan and Stephen Watt
++ Date Created:June 86 and July 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
 
++ Linked List implementation of a Queue
--% Dequeue and Heap data types
 
Queue(S:SetCategory): QueueAggregate S with
    queue: List S -> %
      ++ queue([x,y,...,z]) creates a queue with first (top)
      ++ element x, second element y,...,and last (bottom) element z.
      ++
      ++E e:Queue INT:= queue [1,2,3,4,5]

  == Stack S add
    Rep := Reference List S
    lastTail==> LAST$Lisp
    enqueue_!(e,q) ==
        if null deref q then setref(q, list e)
        else lastTail.(deref q).rest := list e
        e
    insert_!(e,q) == (enqueue_!(e,q);q)
    dequeue_! q ==
        empty? q => error "empty queue"
        e := first deref q
        setref(q,rest deref q)
        e
    extract_! q == dequeue_! q
    rotate_! q == if empty? q then q else (enqueue_!(dequeue_! q,q); q)
    length q == # deref q
    front q == if empty? q then error "empty queue" else first deref q
    inspect q == front q
    back q == if empty? q then error "empty queue" else last deref q
    queue q == ref copy q

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter R}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain REF Reference}
<<dot>>=
"REF" -> "TYPE"
"Reference(a:Type)" -> "Type()"
@
\pagehead{Reference}{REF}
\pagepic{ps/v103reference.ps}{REF}{1.00}
<<domain REF Reference>>=
)abbrev domain REF Reference
++ Author: Stephen M. Watt
++ Date Created:
++ Change History:
++ Basic Operations: deref, elt, ref, setelt, setref, =
++ Related Constructors:
++ Keywords:  reference
++ Description:  \spadtype{Reference} is for making a changeable instance
++ of something.

Reference(S:Type): Type with
        ref   : S -> %
          ++  ref(n) creates a pointer (reference) to the object n.
        elt   : % -> S
          ++ elt(n) returns the object n.
        setelt: (%, S) -> S
          ++ setelt(n,m) changes the value of the object n to m.
        -- alternates for when bugs don't allow the above
        deref : % -> S
          ++ deref(n) is equivalent to \spad{elt(n)}.
        setref: (%, S) -> S
          ++ setref(n,m) same as \spad{setelt(n,m)}.
        _=   : (%, %) -> Boolean
          ++ a=b tests if \spad{a} and b are equal.
        if S has SetCategory then SetCategory

    == add
        Rep := Record(value: S)

        p = q        == EQ(p, q)$Lisp
        ref v        == [v]
        elt p        == p.value
        setelt(p, v) == p.value := v
        deref p      == p.value
        setref(p, v) == p.value := v

        if S has SetCategory then
          coerce p ==
            prefix(message("ref"@String), [p.value::OutputForm])

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter S}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain SAE SimpleAlgebraicExtension}
<<dot>>=
"SimpleAlgebraicExtension(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"
    [color=white,style=filled];
"SAE" -> "MONOGEN"
"SimpleAlgebraicExtension(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 -> "MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
"SimpleAlgebraicExtension(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"
-> 
"SimpleAlgebraicExtension(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
@
\pagehead{SimpleAlgebraicExtension}{SAE}
\pagepic{ps/v103simplealgebraicextension.ps}{SAE}{1.00}
<<domain SAE SimpleAlgebraicExtension>>=
)abbrev domain SAE SimpleAlgebraicExtension
++ Algebraic extension of a ring by a single polynomial
++ Author: Barry Trager, Manuel Bronstein, Clifton Williamson
++ Date Created: 1986
++ Date Last Updated: 9 May 1994
++ Description:
++ Domain which represents simple algebraic extensions of arbitrary
++ rings. The first argument to the domain, R, is the underlying ring,
++ the second argument is a domain of univariate polynomials over K,
++ while the last argument specifies the defining minimal polynomial.
++ The elements of the domain are canonically represented as polynomials
++ of degree less than that of the minimal polynomial with coefficients
++ in R. The second argument is both the type of the third argument and
++ the underlying representation used by \spadtype{SAE} itself.
++ Keywords: ring, algebraic, extension
++ Example: )r SAE INPUT

SimpleAlgebraicExtension(R:CommutativeRing,
 UP:UnivariatePolynomialCategory R, M:UP): MonogenicAlgebra(R, UP) == add
    --sqFr(pb): FactorS(Poly) from UnivPolySquareFree(Poly)

    --degree(M) > 0 and M must be monic if R is not a field.
    if (r := recip leadingCoefficient M) case "failed" then
                                    error "Modulus cannot be made monic"
    Rep := UP
    x,y :$
    c: R

    mkDisc   : Boolean -> Void
    mkDiscMat: Boolean -> Void

    M   := r::R * M
    d   := degree M
    d1  := subtractIfCan(d,1)::NonNegativeInteger
    discmat:Matrix(R) := zero(d, d)
    nodiscmat?:Reference(Boolean) := ref true
    disc:Reference(R) := ref 0
    nodisc?:Reference(Boolean) := ref true
    bsis := [monomial(1, i)$Rep for i in 0..d1]$Vector(Rep)

    if R has Finite then
         size == size$R ** d
         random == represents([random()$R for i in 0..d1])
    0 == 0$Rep
    1 == 1$Rep
    c * x == c *$Rep x
    n:Integer * x == n *$Rep x
    coerce(n:Integer):$   == coerce(n)$Rep
    coerce(c) == monomial(c,0)$Rep
    coerce(x):OutputForm == coerce(x)$Rep
    lift(x) == x pretend Rep
    reduce(p:UP):$ == (monicDivide(p,M)$Rep).remainder
    x = y == x =$Rep y
    x + y == x +$Rep y
    - x == -$Rep x
    x * y == reduce((x *$Rep y) pretend UP)
    coordinates(x) == [coefficient(lift(x),i) for i in 0..d1]
    represents(vect) == +/[monomial(vect.(i+1),i) for i in 0..d1]
    definingPolynomial()  == M
    characteristic()      == characteristic()$R
    rank()                == d::PositiveInteger
    basis()               == copy(bsis@Vector(Rep) pretend Vector($))
    --!! I inserted 'copy' in the definition of 'basis'  -- cjw 7/19/91

    if R has Field then
      minimalPolynomial x == squareFreePart characteristicPolynomial x

    if R has Field then
      coordinates(x:$,bas: Vector $) ==
        (m := inverse transpose coordinates bas) case "failed" =>
          error "coordinates: second argument must be a basis"
        (m :: Matrix R) * coordinates(x)

    else if R has IntegralDomain then
      coordinates(x:$,bas: Vector $) ==
        -- we work over the quotient field of R to invert a matrix
        qf := Fraction R
        imatqf := InnerMatrixQuotientFieldFunctions(R,Vector R,Vector R,_
                   Matrix R,qf,Vector qf,Vector qf,Matrix qf)
        mat := transpose coordinates bas
        (m := inverse(mat)$imatqf) case "failed" =>
          error "coordinates: second argument must be a basis"
        coordsQF := map(#1 :: qf,coordinates x)$VectorFunctions2(R,qf)
        -- here are the coordinates as elements of the quotient field:
        vecQF := (m :: Matrix qf) * coordsQF
        vec : Vector R := new(d,0)
        for i in 1..d repeat
          xi := qelt(vecQF,i)
          denom(xi) = 1 => qsetelt_!(vec,i,numer xi)
          error "coordinates: coordinates are not integral over ground ring"
        vec

    reducedSystem(m:Matrix $):Matrix(R) ==
      reducedSystem(map(lift, m)$MatrixCategoryFunctions2($, Vector $,
               Vector $, Matrix $, UP, Vector UP, Vector UP, Matrix UP))

    reducedSystem(m:Matrix $, v:Vector $):Record(mat:Matrix R,vec:Vector R) ==
      reducedSystem(map(lift, m)$MatrixCategoryFunctions2($, Vector $,
               Vector $, Matrix $, UP, Vector UP, Vector UP, Matrix UP),
                                    map(lift, v)$VectorFunctions2($, UP))

    discriminant() ==
      if nodisc?() then mkDisc false
      disc()

    mkDisc b ==
      nodisc?() := b
      disc() := discriminant M
      void

    traceMatrix() ==
      if nodiscmat?() then mkDiscMat false
      discmat

    mkDiscMat b ==
      nodiscmat?() := b
      mr := minRowIndex discmat; mc := minColIndex discmat
      for i in 0..d1 repeat
        for j in 0..d1 repeat
          qsetelt_!(discmat,mr + i,mc + j,trace reduce monomial(1,i + j))
      void

    trace x ==          --this could be coded perhaps more efficiently
      xn := x;  ans := coefficient(lift xn, 0)
      for n in 1..d1 repeat
        (xn := generator() * xn;  ans := coefficient(lift xn, n) + ans)
      ans

    if R has Finite then
       index k ==
         i:Integer := k rem size()
         p:Integer := size()$R
         ans:$ := 0
         for j in 0.. while i > 0 repeat
           h := i rem p
           -- index(p) = 0$R
           if h ^= 0 then
             -- here was a bug: "index" instead of
             -- "coerce", otherwise it wouldn't work for
             -- Rings R where "coerce: I-> R" is not surjective
             a := index(h :: PositiveInteger)$R
             ans := ans + reduce monomial(a, j)
           i := i quo p
         ans
       lookup(z : $) : PositiveInteger ==
         -- z = index lookup z, n = lookup index n
         -- the answer is merely the Horner evaluation of the
         -- representation with the size of R (as integers).
         zero?(z) => size()$$ pretend PositiveInteger
         p  :            Integer := size()$R
         co :            Integer := lookup(leadingCoefficient z)$R
         n  : NonNegativeInteger := degree(z)
         while not zero?(z := reductum z) repeat
          co := co * p ** ((n - (n := degree z)) pretend
            NonNegativeInteger) + lookup(leadingCoefficient z)$R
         n = 0 => co pretend PositiveInteger
         (co * p ** n) pretend PositiveInteger

--
--   KA:=BasicPolynomialFunctions(Poly)
--   minPoly(x) ==
--      ffe:= SqFr(resultant(M::KA, KA.var - lift(x)::KA)).fs.first
--      ffe.flag = "SQFR" => ffe.f
--      mdeg:= (degree(ffe.f) // K.characteristic)::Integer
--      mat:= Zero()::Matrix<mdeg+1,deg+mdeg+1>(K)
--      xi:=L.1;  setelt(mat,1,1,K.1);  setelt(mat,1,(deg+1),K.1)
--      for i in 1..mdeg repeat
--         xi:= x * xi;  xp:= lift(xi)
--         while xp ^= KA.0 repeat
--            setelt(mat,(mdeg+1),(degree(xp)+1),LeadingCoef(xp))
--            xp:=reductum(xp)
--         setelt(mat,(mdeg+1),(deg+i+1),K.1)
--         EchelonLastRow(mat)
--         if and/(elt(mat,(i+1),j) = K.0 for j in 1..deg)
--           then return unitNormal(+/(elt(mat,(i+1),(deg+j+1))*(B::KA)**j
--                                       for j in 0..i)).a
--      ffe.f

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain STACK Stack}
<<dot>>=
"STACK" -> "SKAGG"
"Stack(a:SetCategory)" -> "StackAggregate(a:SetCategory)"
@
\pagehead{Stack}{STACK}
\pagepic{ps/v103stack.ps}{STACK}{1.00}
<<domain STACK Stack>>=
)abbrev domain STACK Stack
++ Author: Michael Monagan and Stephen Watt
++ Date Created:June 86 and July 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:
 
++ Linked List implementation of a Stack
--% Dequeue and Heap data types
 
Stack(S:SetCategory): StackAggregate S with
    stack: List S -> %
      ++ stack([x,y,...,z]) creates a stack with first (top)
      ++ element x, second element y,...,and last element z.
      ++
      ++E a:Stack INT:= stack [1,2,3,4,5]

  == add
    Rep := Reference List S
    s = t == deref s = deref t
    coerce(d:%): OutputForm == bracket [e::OutputForm for e in deref d]
    copy s == ref copy deref s
    depth s == # deref s
    # s == depth s
    pop_! (s:%):S ==
        empty? s => error "empty stack"
        e := first deref s
        setref(s,rest deref s)
        e
    extract_! (s:%):S == pop_! s
    top (s:%):S ==
        empty? s => error "empty stack"
        first deref s
    inspect s == top s
    push_!(e,s) == (setref(s,cons(e,deref s));e)
    insert_!(e:S,s:%):% == (push_!(e,s);s)
    empty() == ref nil()$List(S)
    empty? s == null deref s
    stack s == ref copy s

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain TUPLE Tuple}
<<dot>>=
"TUPLE" -> "PRIMARR"
"Tuple(a:Type)" -> "PrimitiveArray(a:Type)"
@
\pagehead{Tuple}{TUPLE}
\pagepic{ps/v103tuple.ps}{TUPLE}{1.00}
<<domain TUPLE Tuple>>=
)abbrev domain TUPLE Tuple
++ This domain is used to interface with the interpreter's notion
++ of comma-delimited sequences of values.
Tuple(S:Type): CoercibleTo(PrimitiveArray S) with
  coerce: PrimitiveArray S -> %
   ++ coerce(a) makes a tuple from primitive array a
   ++
   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++X t2:=coerce(t1)$Tuple(Integer)

  select: (%, NonNegativeInteger) -> S
   ++ select(x,n) returns the n-th element of tuple x.
   ++ tuples are 0-based
   ++
   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++X t2:=coerce(t1)$Tuple(Integer)
   ++X select(t2,3)

  length: % -> NonNegativeInteger
   ++ length(x) returns the number of elements in tuple x
   ++
   ++X t1:PrimitiveArray(Integer):= [i for i in 1..10]
   ++X t2:=coerce(t1)$Tuple(Integer)
   ++X length(t2)

  if S has SetCategory then SetCategory
 == add
  Rep := Record(len : NonNegativeInteger, elts : PrimitiveArray S)

  coerce(x: PrimitiveArray S): %  == [#x, x]
  coerce(x:%): PrimitiveArray(S) == x.elts
  length x == x.len

  select(x, n) ==
    n >= x.len => error "Index out of bounds"
    x.elts.n

  if S has SetCategory then
    x = y == (x.len = y.len) and (x.elts =$PrimitiveArray(S) y.elts)
    coerce(x : %): OutputForm ==
      paren [(x.elts.i)::OutputForm
             for i in minIndex x.elts .. maxIndex x.elts]$List(OutputForm)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{domain ARRAY2 TwoDimensionalArray}
<<TwoDimensionalArray.input>>=
-- array2.spad.pamphlet TwoDimensionalArray.input
)spool TwoDimensionalArray.output
)set message test on
)set message auto off
)clear all
--S 1 of 20
arr : ARRAY2 INT := new(5,4,0)
--R 
--R
--R        +0  0  0  0+
--R        |          |
--R        |0  0  0  0|
--R        |          |
--R   (1)  |0  0  0  0|
--R        |          |
--R        |0  0  0  0|
--R        |          |
--R        +0  0  0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 1

--S 2 of 20
setelt(arr,1,1,17)
--R 
--R
--R   (2)  17
--R                                                        Type: PositiveInteger
--E 2

--S 3 of 20
arr
--R 
--R
--R        +17  0  0  0+
--R        |           |
--R        |0   0  0  0|
--R        |           |
--R   (3)  |0   0  0  0|
--R        |           |
--R        |0   0  0  0|
--R        |           |
--R        +0   0  0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 3

--S 4 of 20
elt(arr,1,1)
--R 
--R
--R   (4)  17
--R                                                        Type: PositiveInteger
--E 4

--S 5 of 20
arr(3,2) := 15
--R 
--R
--R   (5)  15
--R                                                        Type: PositiveInteger
--E 5

--S 6 of 20
arr(3,2)
--R 
--R
--R   (6)  15
--R                                                        Type: PositiveInteger
--E 6

--S 7 of 20
row(arr,1)
--R 
--R
--R   (7)  [17,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 7

--S 8 of 20
column(arr,1)
--R 
--R
--R   (8)  [17,0,0,0,0]
--R                                            Type: OneDimensionalArray Integer
--E 8

--S 9 of 20
nrows(arr)
--R 
--R
--R   (9)  5
--R                                                        Type: PositiveInteger
--E 9

--S 10 of 20
ncols(arr)
--R 
--R
--R   (10)  4
--R                                                        Type: PositiveInteger
--E 10

--S 11 of 20
map(-,arr)
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (11)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 11

--S 12 of 20
map((x +-> x + x),arr)
--R 
--R
--R         +34  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (12)  |0   30  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 12

--S 13 of 20
arrc := copy(arr)
--R 
--R
--R         +17  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (13)  |0   15  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 13

--S 14 of 20
map!(-,arrc)
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (14)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 14

--S 15 of 20
arrc
--R 
--R
--R         +- 17   0    0  0+
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R   (15)  | 0    - 15  0  0|
--R         |                |
--R         | 0     0    0  0|
--R         |                |
--R         + 0     0    0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 15

--S 16 of 20
arr
--R 
--R
--R         +17  0   0  0+
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R   (16)  |0   15  0  0|
--R         |            |
--R         |0   0   0  0|
--R         |            |
--R         +0   0   0  0+
--R                                            Type: TwoDimensionalArray Integer
--E 16

--S 17 of 20
member?(17,arr)
--R 
--R
--R   (17)  true
--R                                                                Type: Boolean
--E 17

--S 18 of 20
member?(10317,arr)
--R 
--R
--R   (18)  false
--R                                                                Type: Boolean
--E 18

--S 19 of 20
count(17,arr)
--R 
--R
--R   (19)  1
--R                                                        Type: PositiveInteger
--E 19

--S 20 of 20
count(0,arr)
--R 
--R
--R   (20)  18
--R                                                        Type: PositiveInteger
--E 20
)spool
)lisp (bye)
@
<<TwoDimensionalArray.help>>=
====================================================================
TwoDimensionalArray examples
====================================================================

The TwoDimensionalArray domain is used for storing data in a two
dimensional data structure indexed by row and by column.  Such an
array is a homogeneous data structure in that all the entries of the
array must belong to the same Axiom domain..  Each array has a fixed
number of rows and columns specified by the user and arrays are not
extensible.  In Axiom, the indexing of two-dimensional arrays is
one-based.  This means that both the "first" row of an array and the
"first" column of an array are given the index 1.  Thus, the entry
in the upper left corner of an array is in position (1,1).

The operation new creates an array with a specified number of rows and
columns and fills the components of that array with a specified entry.
The arguments of this operation specify the number of rows, the number
of columns, and the entry.

This creates a five-by-four array of integers, all of whose entries are
zero.

  arr : ARRAY2 INT := new(5,4,0)
        +0  0  0  0+
        |          |
        |0  0  0  0|
        |          |
        |0  0  0  0|
        |          |
        |0  0  0  0|
        |          |
        +0  0  0  0+
                         Type: TwoDimensionalArray Integer

The entries of this array can be set to other integers using setelt.

Issue this to set the element in the upper left corner of this array to 17.

  setelt(arr,1,1,17)
    17
                         Type: PositiveInteger

Now the first element of the array is 17.

  arr
        +17  0  0  0+
        |           |
        |0   0  0  0|
        |           |
        |0   0  0  0|
        |           |
        |0   0  0  0|
        |           |
        +0   0  0  0+
                         Type: TwoDimensionalArray Integer

Likewise, elements of an array are extracted using the operation elt.

  elt(arr,1,1)
    17
                         Type: PositiveInteger

Another way to use these two operations is as follows.  This sets the
element in position (3,2) of the array to 15.

  arr(3,2) := 15
    15
                         Type: PositiveInteger

This extracts the element in position (3,2) of the array.

  arr(3,2)
    15
                         Type: PositiveInteger

The operations elt and setelt come equipped with an error check which
verifies that the indices are in the proper ranges.  For example, the
above array has five rows and four columns, so if you ask for the
entry in position (6,2) with arr(6,2) Axiom displays an error message.
If there is no need for an error check, you can call the operations qelt 
and qsetelt which provide the same functionality but without the error 
check. Typically, these operations are called in well-tested programs.

The operations row and column extract rows and columns, respectively,
and return objects of OneDimensionalArray with the same underlying
element type.

  row(arr,1)
    [17,0,0,0]
                         Type: OneDimensionalArray Integer

  column(arr,1)
    [17,0,0,0,0]
                         Type: OneDimensionalArray Integer

You can determine the dimensions of an array by calling the operations
nrows and ncols, which return the number of rows and columns, respectively.

  nrows(arr)
    5
                         Type: PositiveInteger

  ncols(arr)
    4
                         Type: PositiveInteger

To apply an operation to every element of an array, use map.  This
creates a new array.  This expression negates every element.

  map(-,arr)
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

This creates an array where all the elements are doubled.

  map((x +-> x + x),arr)
         +34  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   30  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

To change the array destructively, use map instead of map.  If you
need to make a copy of any array, use copy.

  arrc := copy(arr)
         +17  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   15  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

  map!(-,arrc)
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

  arrc
         +- 17   0    0  0+
         |                |
         | 0     0    0  0|
         |                |
         | 0    - 15  0  0|
         |                |
         | 0     0    0  0|
         |                |
         + 0     0    0  0+
                         Type: TwoDimensionalArray Integer

  arr
         +17  0   0  0+
         |            |
         |0   0   0  0|
         |            |
         |0   15  0  0|
         |            |
         |0   0   0  0|
         |            |
         +0   0   0  0+
                         Type: TwoDimensionalArray Integer

Use member? to see if a given element is in an array.

  member?(17,arr)
    true
                         Type: Boolean

  member?(10317,arr)
    false
                         Type: Boolean

To see how many times an element appears in an array, use count.

  count(17,arr)
    1
                         Type: PositiveInteger

  count(0,arr)
    18
                         Type: PositiveInteger

See Also:
o )help Matrix
o )help OneDimensionalArray
o )show TwoDimensionalArray
o $AXIOM/doc/src/algebra/array2.spad.dvi

@
<<dot>>=
"ARRAY2" -> "ARR2CAT"
"TwoDimensionalArray(a:Type)" ->
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
"ARRAY2" -> "IIARRAY2"
"TwoDimensionalArray(a:Type)" ->
"InnerIndexedTwoDimensionalArray(a:Type,1,1,b:OneDimensionalArray(a),c:OneDimensionalArray(a))"
@
\pagehead{TwoDimensionalArray}{ARRAY2}
\pagepic{ps/v103twodimensionalarray.ps}{ARRAY2}{1.00}
<<domain ARRAY2 TwoDimensionalArray>>=
)abbrev domain ARRAY2 TwoDimensionalArray
TwoDimensionalArray(R):Exports == Implementation where
  ++ A TwoDimensionalArray is a two dimensional array with
  ++ 1-based indexing for both rows and columns.
  R : Type
  Row ==> OneDimensionalArray R
  Col ==> OneDimensionalArray R

  Exports ==> TwoDimensionalArrayCategory(R,Row,Col) with
    shallowlyMutable
      ++ One may destructively alter TwoDimensionalArray's.

  Implementation ==> InnerIndexedTwoDimensionalArray(R,1,1,Row,Col)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter U}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter V}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter W}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter X}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Y}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Z}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The bootstrap code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{BOOLEAN.lsp}
{\bf BOOLEAN} depends on 
{\bf ORDSET} which depends on 
{\bf SETCAT} which depends on
{\bf BASTYPE} which depends on 
{\bf BOOLEAN}. We need to break this cycle to build the algebra.
So we keep a cached copy of the translated BOOLEAN domain which
we can write into the {\bf MID} directory. We compile the lisp
code and copy the {\bf BOOLEAN.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 
<<BOOLEAN.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(PUT 
  (QUOTE |BOOLEAN;test;2$;1|) 
  (QUOTE |SPADreplace|) 
  (QUOTE (XLAM (|a|) |a|))) 

(DEFUN |BOOLEAN;test;2$;1| (|a| |$|) |a|) 

(DEFUN |BOOLEAN;nt| (|b| |$|) 
  (COND (|b| (QUOTE NIL)) 
  ((QUOTE T) (QUOTE T)))) 

(PUT 
  (QUOTE |BOOLEAN;true;$;3|) 
  (QUOTE |SPADreplace|) 
  (QUOTE (XLAM NIL (QUOTE T)))) 

(DEFUN |BOOLEAN;true;$;3| (|$|) 
  (QUOTE T)) 

(PUT 
  (QUOTE |BOOLEAN;false;$;4|) 
  (QUOTE |SPADreplace|) 
  (QUOTE (XLAM NIL NIL))) 

(DEFUN |BOOLEAN;false;$;4| (|$|) NIL) 

(DEFUN |BOOLEAN;not;2$;5| (|b| |$|) 
  (COND 
    (|b| (QUOTE NIL)) 
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;^;2$;6| (|b| |$|) 
  (COND 
    (|b| (QUOTE NIL)) 
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;~;2$;7| (|b| |$|) 
  (COND 
    (|b| (QUOTE NIL)) 
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;and;3$;8| (|a| |b| |$|) 
  (COND 
    (|a| |b|) 
    ((QUOTE T) (QUOTE NIL)))) 

(DEFUN |BOOLEAN;/\\;3$;9| (|a| |b| |$|) 
  (COND 
    (|a| |b|) 
    ((QUOTE T) (QUOTE NIL)))) 

(DEFUN |BOOLEAN;or;3$;10| (|a| |b| |$|) 
  (COND 
    (|a| (QUOTE T)) 
    ((QUOTE T) |b|))) 

(DEFUN |BOOLEAN;\\/;3$;11| (|a| |b| |$|) 
  (COND 
    (|a| (QUOTE T)) 
    ((QUOTE T) |b|))) 

(DEFUN |BOOLEAN;xor;3$;12| (|a| |b| |$|) 
  (COND 
    (|a| (|BOOLEAN;nt| |b| |$|)) 
    ((QUOTE T) |b|))) 

(DEFUN |BOOLEAN;nor;3$;13| (|a| |b| |$|) 
  (COND 
    (|a| (QUOTE NIL)) 
    ((QUOTE T) (|BOOLEAN;nt| |b| |$|)))) 

(DEFUN |BOOLEAN;nand;3$;14| (|a| |b| |$|) 
  (COND 
    (|a| (|BOOLEAN;nt| |b| |$|)) 
    ((QUOTE T) (QUOTE T)))) 

(PUT 
  (QUOTE |BOOLEAN;=;3$;15|) 
  (QUOTE |SPADreplace|) 
  (QUOTE |BooleanEquality|)) 

(DEFUN |BOOLEAN;=;3$;15| (|a| |b| |$|) 
  (|BooleanEquality| |a| |b|)) 

(DEFUN |BOOLEAN;implies;3$;16| (|a| |b| |$|) 
  (COND 
    (|a| |b|) 
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;<;3$;17| (|a| |b| |$|) 
  (COND 
    (|b| 
      (COND 
        (|a| (QUOTE NIL))
        ((QUOTE T) (QUOTE T)))) 
    ((QUOTE T) (QUOTE NIL)))) 

(PUT 
  (QUOTE |BOOLEAN;size;Nni;18|) 
  (QUOTE |SPADreplace|) 
  (QUOTE (XLAM NIL 2))) 

(DEFUN |BOOLEAN;size;Nni;18| (|$|) 2) 

(DEFUN |BOOLEAN;index;Pi$;19| (|i| |$|) 
  (COND 
    ((SPADCALL |i| (QREFELT |$| 26)) (QUOTE NIL))
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;lookup;$Pi;20| (|a| |$|) 
  (COND 
    (|a| 1) 
    ((QUOTE T) 2))) 

(DEFUN |BOOLEAN;random;$;21| (|$|) 
  (COND 
    ((SPADCALL (|random|) (QREFELT |$| 26)) (QUOTE NIL)) 
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |BOOLEAN;convert;$If;22| (|x| |$|) 
  (COND 
    (|x| (SPADCALL (SPADCALL "true" (QREFELT |$| 33)) (QREFELT |$| 35)))
    ((QUOTE T) 
      (SPADCALL (SPADCALL "false" (QREFELT |$| 33)) (QREFELT |$| 35))))) 

(DEFUN |BOOLEAN;coerce;$Of;23| (|x| |$|) 
  (COND 
    (|x| (SPADCALL "true" (QREFELT |$| 38)))
    ((QUOTE T) (SPADCALL "false" (QREFELT |$| 38))))) 

(DEFUN |Boolean| NIL 
  (PROG NIL 
    (RETURN 
      (PROG (#1=#:G82461) 
        (RETURN 
          (COND 
            ((LETT #1# 
                (HGET |$ConstructorCache| (QUOTE |Boolean|))
                |Boolean|)
              (|CDRwithIncrement| (CDAR #1#)))
             ((QUOTE T) 
               (|UNWIND-PROTECT| 
                 (PROG1 
                   (CDDAR 
                     (HPUT 
                       |$ConstructorCache| 
                       (QUOTE |Boolean|) 
                       (LIST (CONS NIL (CONS 1 (|Boolean;|))))))
                   (LETT #1# T |Boolean|))
                 (COND 
                   ((NOT #1#) 
                     (HREM |$ConstructorCache| (QUOTE |Boolean|)))))))))))) 

(DEFUN |Boolean;| NIL 
  (PROG (|dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |dv$| (QUOTE (|Boolean|)) . #1=(|Boolean|))
        (LETT |$| (GETREFV 41) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|haddProp| |$ConstructorCache| (QUOTE |Boolean|) NIL (CONS 1 |$|))
        (|stuffDomainSlots| |$|) |$|)))) 

(MAKEPROP 
  (QUOTE |Boolean|) 
  (QUOTE |infovec|) 
    (LIST 
      (QUOTE 
        #(NIL NIL NIL NIL NIL NIL 
          (|Boolean|)
          |BOOLEAN;test;2$;1| 
          (CONS IDENTITY 
            (FUNCALL (|dispatchFunction| |BOOLEAN;true;$;3|) |$|))
          (CONS IDENTITY 
            (FUNCALL (|dispatchFunction| |BOOLEAN;false;$;4|) |$|))
          |BOOLEAN;not;2$;5| 
          |BOOLEAN;^;2$;6| 
          |BOOLEAN;~;2$;7| 
          |BOOLEAN;and;3$;8| 
          |BOOLEAN;/\\;3$;9| 
          |BOOLEAN;or;3$;10| 
          |BOOLEAN;\\/;3$;11| 
          |BOOLEAN;xor;3$;12| 
          |BOOLEAN;nor;3$;13| 
          |BOOLEAN;nand;3$;14| 
          |BOOLEAN;=;3$;15| 
          |BOOLEAN;implies;3$;16| 
          |BOOLEAN;<;3$;17| 
          (|NonNegativeInteger|) 
          |BOOLEAN;size;Nni;18| 
          (|Integer|) 
          (0 . |even?|) 
          (|PositiveInteger|) 
          |BOOLEAN;index;Pi$;19| 
          |BOOLEAN;lookup;$Pi;20| 
          |BOOLEAN;random;$;21| 
          (|String|) 
          (|Symbol|)
          (5 . |coerce|)
          (|InputForm|)
          (10 . |convert|)
          |BOOLEAN;convert;$If;22| 
          (|OutputForm|) 
          (15 . |message|) 
          |BOOLEAN;coerce;$Of;23| 
          (|SingleInteger|)))
      (QUOTE 
         #(|~=| 20 |~| 26 |xor| 31 |true| 37 |test| 41 |size| 46 |random| 50 
           |or| 54 |not| 60 |nor| 65 |nand| 71 |min| 77 |max| 83 |lookup| 89 
           |latex| 94 |index| 99 |implies| 104 |hash| 110 |false| 115 
           |convert| 119 |coerce| 124 |and| 129 |^| 135 |\\/| 140 |>=| 146 
           |>| 152 |=| 158 |<=| 164 |<| 170 |/\\| 176))
      (QUOTE NIL)
      (CONS 
        (|makeByteWordVec2| 1 (QUOTE (0 0 0 0 0 0 0)))
        (CONS 
          (QUOTE 
            #(|OrderedSet&| NIL |Logic&| |SetCategory&| NIL |BasicType&| NIL))
          (CONS 
            (QUOTE 
              #((|OrderedSet|) 
                (|Finite|)
                (|Logic|)
                (|SetCategory|)
                (|ConvertibleTo| 34)
                (|BasicType|)
                (|CoercibleTo| 37)))
            (|makeByteWordVec2| 
              40 
              (QUOTE 
                (1 25 6 0 26 1 32 0 31 33 1 34 0 32 35 1 37 0 31 38 2 0 6 0 0 
                 1 1 0 0 0 12 2 0 0 0 0 17 0 0 0 8 1 0 6 0 7 0 0 23 24 0 0 0 
                 30 2 0 0 0 0 15 1 0 0 0 10 2 0 0 0 0 18 2 0 0 0 0 19 2 0 0 0 
                 0 1 2 0 0 0 0 1 1 0 27 0 29 1 0 31 0 1 1 0 0 27 28 2 0 0 0 0
                 21 1 0 40 0 1 0 0 0 9 1 0 34 0 36 1 0 37 0 39 2 0 0 0 0 13 1
                 0 0 0 11 2 0 0 0 0 16 2 0 6 0 0 1 2 0 6 0 0 1 2 0 6 0 0 20 2
                 0 6 0 0 1 2 0 6 0 0 22 2 0 0 0 0 14))))))
      (QUOTE |lookupComplete|))) 

(MAKEPROP (QUOTE |Boolean|) (QUOTE NILADIC) T) 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PRIMARR.lsp BOOTSTRAP} 
{\bf PRIMARR} depends on itself.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf PRIMARR} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf PRIMARR.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<PRIMARR.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(PUT (QUOTE |PRIMARR;#;$Nni;1|) (QUOTE |SPADreplace|) (QUOTE QVSIZE)) 

(DEFUN |PRIMARR;#;$Nni;1| (|x| |$|) (QVSIZE |x|)) 

(PUT (QUOTE |PRIMARR;minIndex;$I;2|)
 (QUOTE |SPADreplace|) (QUOTE (XLAM (|x|) 0))) 

(DEFUN |PRIMARR;minIndex;$I;2| (|x| |$|) 0) 

(PUT (QUOTE |PRIMARR;empty;$;3|)
 (QUOTE |SPADreplace|) (QUOTE (XLAM NIL (GETREFV 0)))) 

(DEFUN |PRIMARR;empty;$;3| (|$|) (GETREFV 0)) 

(DEFUN |PRIMARR;new;NniS$;4| (|n| |x| |$|)
 (SPADCALL (GETREFV |n|) |x| (QREFELT |$| 12))) 

(PUT (QUOTE |PRIMARR;qelt;$IS;5|) (QUOTE |SPADreplace|) (QUOTE ELT)) 

(DEFUN |PRIMARR;qelt;$IS;5| (|x| |i| |$|) (ELT |x| |i|)) 

(PUT (QUOTE |PRIMARR;elt;$IS;6|) (QUOTE |SPADreplace|) (QUOTE ELT)) 

(DEFUN |PRIMARR;elt;$IS;6| (|x| |i| |$|) (ELT |x| |i|)) 

(PUT (QUOTE |PRIMARR;qsetelt!;$I2S;7|) (QUOTE |SPADreplace|) (QUOTE SETELT)) 

(DEFUN |PRIMARR;qsetelt!;$I2S;7| (|x| |i| |s| |$|) (SETELT |x| |i| |s|)) 

(PUT (QUOTE |PRIMARR;setelt;$I2S;8|) (QUOTE |SPADreplace|) (QUOTE SETELT)) 

(DEFUN |PRIMARR;setelt;$I2S;8| (|x| |i| |s| |$|) (SETELT |x| |i| |s|)) 

(DEFUN |PRIMARR;fill!;$S$;9| (|x| |s| |$|)
 (PROG (|i| #1=#:G82338)
  (RETURN
   (SEQ
    (SEQ
     (LETT |i| 0 |PRIMARR;fill!;$S$;9|)
     (LETT #1# (QVMAXINDEX |x|) |PRIMARR;fill!;$S$;9|)
     G190
     (COND ((QSGREATERP |i| #1#) (GO G191)))
     (SEQ (EXIT (SETELT |x| |i| |s|)))
     (LETT |i| (QSADD1 |i|) |PRIMARR;fill!;$S$;9|)
     (GO G190)
     G191
    (EXIT NIL))
   (EXIT |x|)))))

(DEFUN |PrimitiveArray| (#1=#:G82348)
 (PROG NIL
  (RETURN 
   (PROG (#2=#:G82349)
    (RETURN
     (COND
      ((LETT #2# 
        (|lassocShiftWithFunction|
          (LIST (|devaluate| #1#))
          (HGET |$ConstructorCache| (QUOTE |PrimitiveArray|))
          (QUOTE |domainEqualList|))
         |PrimitiveArray|)
        (|CDRwithIncrement| #2#))
      ((QUOTE T)
        (|UNWIND-PROTECT|
         (PROG1
          (|PrimitiveArray;| #1#)
          (LETT #2# T |PrimitiveArray|))
         (COND
          ((NOT #2#)
            (HREM |$ConstructorCache| (QUOTE |PrimitiveArray|)))))))))))) 

(DEFUN |PrimitiveArray;| (|#1|)
 (PROG (|DV$1| |dv$| |$| #1=#:G82347 |pv$|)
  (RETURN
   (PROGN 
    (LETT |DV$1| (|devaluate| |#1|) . #2=(|PrimitiveArray|))
    (LETT |dv$| (LIST (QUOTE |PrimitiveArray|) |DV$1|) . #2#)
    (LETT |$| (GETREFV 35) . #2#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0
       (LIST 
        (|HasCategory| |#1| (QUOTE (|SetCategory|)))
        (|HasCategory| |#1| (QUOTE (|ConvertibleTo| (|InputForm|))))
        (LETT #1# (|HasCategory| |#1| (QUOTE (|OrderedSet|))) . #2#)
        (OR #1# (|HasCategory| |#1| (QUOTE (|SetCategory|))))
        (|HasCategory| (|Integer|) (QUOTE (|OrderedSet|)))
        (AND (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
             (|HasCategory| |#1| (QUOTE (|SetCategory|))))
        (OR 
         (AND 
          (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
          #1#)
         (AND
          (|HasCategory| |#1| (LIST (QUOTE |Evalable|) (|devaluate| |#1|)))
          (|HasCategory| |#1| (QUOTE (|SetCategory|)))))))
      . #2#))
    (|haddProp| |$ConstructorCache|
     (QUOTE |PrimitiveArray|) (LIST |DV$1|) (CONS 1 |$|))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    |$|)))) 

(MAKEPROP (QUOTE |PrimitiveArray|) (QUOTE |infovec|)
 (LIST 
  (QUOTE
   #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|NonNegativeInteger|)
     |PRIMARR;#;$Nni;1| (|Integer|) |PRIMARR;minIndex;$I;2|
     |PRIMARR;empty;$;3| |PRIMARR;fill!;$S$;9| |PRIMARR;new;NniS$;4|
     |PRIMARR;qelt;$IS;5| |PRIMARR;elt;$IS;6| |PRIMARR;qsetelt!;$I2S;7|
     |PRIMARR;setelt;$I2S;8| (|Mapping| 6 6 6) (|Boolean|) (|List| 6)
     (|Equation| 6) (|List| 21) (|Mapping| 19 6) (|Mapping| 19 6 6)
     (|UniversalSegment| 9) (|Void|) (|Mapping| 6 6) (|InputForm|)
     (|OutputForm|) (|String|) (|SingleInteger|) (|List| |$|)
     (|Union| 6 (QUOTE "failed")) (|List| 9)))
  (QUOTE
   #(|~=| 0 |swap!| 6 |sorted?| 13 |sort!| 24 |sort| 35 |size?| 46 |setelt|
     52 |select| 66 |sample| 72 |reverse!| 76 |reverse| 81 |removeDuplicates|
     86 |remove| 91 |reduce| 103 |qsetelt!| 124 |qelt| 131 |position| 137
     |parts| 156 |new| 161 |more?| 167 |minIndex| 173 |min| 178 |merge| 184
     |members| 197 |member?| 202 |maxIndex| 208 |max| 213 |map!| 219 |map|
     225 |less?| 238 |latex| 244 |insert| 249 |indices| 263 |index?| 268
     |hash| 274 |first| 279 |find| 284 |fill!| 290 |every?| 296 |eval| 302
     |eq?| 328 |entry?| 334 |entries| 340 |empty?| 345 |empty| 350 |elt| 354
     |delete| 373 |count| 385 |copyInto!| 397 |copy| 404 |convert| 409
     |construct| 414 |concat| 419 |coerce| 442 |any?| 447 |>=| 453 |>| 459
     |=| 465 |<=| 471 |<| 477 |#| 483))
 (QUOTE ((|shallowlyMutable| . 0) (|finiteAggregate| . 0)))
 (CONS 
   (|makeByteWordVec2| 7 (QUOTE (0 0 0 0 0 0 3 0 0 7 4 0 0 7 1 2 4)))
   (CONS
    (QUOTE #(|OneDimensionalArrayAggregate&| |FiniteLinearAggregate&|
     |LinearAggregate&| |IndexedAggregate&| |Collection&|
     |HomogeneousAggregate&| |OrderedSet&| |Aggregate&| |EltableAggregate&|
     |Evalable&| |SetCategory&| NIL NIL |InnerEvalable&| NIL NIL |BasicType&|))
    (CONS
     (QUOTE
      #((|OneDimensionalArrayAggregate| 6) (|FiniteLinearAggregate| 6)
        (|LinearAggregate| 6) (|IndexedAggregate| 9 6) (|Collection| 6)
        (|HomogeneousAggregate| 6) (|OrderedSet|) (|Aggregate|)
        (|EltableAggregate| 9 6) (|Evalable| 6) (|SetCategory|) (|Type|)
        (|Eltable| 9 6) (|InnerEvalable| 6 6) (|CoercibleTo| 29)
        (|ConvertibleTo| 28) (|BasicType|)))
     (|makeByteWordVec2| 34 
      (QUOTE
       (2 1 19 0 0 1 3 0 26 0 9 9 1 1 3 19 0 1 2 0 19 24 0 1 1 3 0 0 1 2 0 0
        24 0 1 1 3 0 0 1 2 0 0 24 0 1 2 0 19 0 7 1 3 0 6 0 25 6 1 3 0 6 0 9
        6 17 2 0 0 23 0 1 0 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 1 2 1 0 6 0 1
        2 0 0 23 0 1 4 1 6 18 0 6 6 1 3 0 6 18 0 6 1 2 0 6 18 0 1 3 0 6 0 9
        6 16 2 0 6 0 9 14 2 1 9 6 0 1 3 1 9 6 0 9 1 2 0 9 23 0 1 1 0 20 0 1
        2 0 0 7 6 13 2 0 19 0 7 1 1 5 9 0 10 2 3 0 0 0 1 2 3 0 0 0 1 3 0 0
        24 0 0 1 1 0 20 0 1 2 1 19 6 0 1 1 5 9 0 1 2 3 0 0 0 1 2 0 0 27 0 1
        3 0 0 18 0 0 1 2 0 0 27 0 1 2 0 19 0 7 1 1 1 30 0 1 3 0 0 0 0 9 1 3
        0 0 6 0 9 1 1 0 34 0 1 2 0 19 9 0 1 1 1 31 0 1 1 5 6 0 1 2 0 33 23
        0 1 2 0 0 0 6 12 2 0 19 23 0 1 3 6 0 0 20 20 1 2 6 0 0 21 1 3 6 0 0
        6 6 1 2 6 0 0 22 1 2 0 19 0 0 1 2 1 19 6 0 1 1 0 20 0 1 1 0 19 0 1
        0 0 0 11 2 0 0 0 25 1 2 0 6 0 9 15 3 0 6 0 9 6 1 2 0 0 0 9 1 2 0 0
        0 25 1 2 1 7 6 0 1 2 0 7 23 0 1 3 0 0 0 0 9 1 1 0 0 0 1 1 2 28 0 1
        1 0 0 20 1 1 0 0 32 1 2 0 0 6 0 1 2 0 0 0 0 1 2 0 0 0 6 1 1 1 29 0
        1 2 0 19 23 0 1 2 3 19 0 0 1 2 3 19 0 0 1 2 1 19 0 0 1 2 3 19 0 0 1
        2 3 19 0 0 1 1 0 7 0 8))))))
 (QUOTE |lookupComplete|))) 
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{REF.lsp BOOTSTRAP} 
{\bf REF} depends on a chain of
files. We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf REF} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf REF.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<REF.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(PUT (QUOTE |REF;=;2$B;1|) (QUOTE |SPADreplace|) (QUOTE EQ)) 

(DEFUN |REF;=;2$B;1| (|p| |q| |$|) (EQ |p| |q|)) 

(PUT (QUOTE |REF;ref;S$;2|) (QUOTE |SPADreplace|) (QUOTE LIST)) 

(DEFUN |REF;ref;S$;2| (|v| |$|) (LIST |v|)) 

(PUT (QUOTE |REF;elt;$S;3|) (QUOTE |SPADreplace|) (QUOTE QCAR)) 

(DEFUN |REF;elt;$S;3| (|p| |$|) (QCAR |p|)) 

(DEFUN |REF;setelt;$2S;4| (|p| |v| |$|) (PROGN (RPLACA |p| |v|) (QCAR |p|))) 

(PUT (QUOTE |REF;deref;$S;5|) (QUOTE |SPADreplace|) (QUOTE QCAR)) 

(DEFUN |REF;deref;$S;5| (|p| |$|) (QCAR |p|)) 

(DEFUN |REF;setref;$2S;6| (|p| |v| |$|) (PROGN (RPLACA |p| |v|) (QCAR |p|))) 

(DEFUN |REF;coerce;$Of;7| (|p| |$|)
 (SPADCALL 
  (SPADCALL "ref" (QREFELT |$| 17))
  (LIST (SPADCALL (QCAR |p|) (QREFELT |$| 18)))
  (QREFELT |$| 20))) 

(DEFUN |Reference| (#1=#:G82336)
 (PROG NIL
  (RETURN
   (PROG (#2=#:G82337)
    (RETURN
     (COND
      ((LETT #2# 
        (|lassocShiftWithFunction| 
         (LIST (|devaluate| #1#))
         (HGET |$ConstructorCache| (QUOTE |Reference|))
         (QUOTE |domainEqualList|)) |Reference|)
        (|CDRwithIncrement| #2#))
      ((QUOTE T)
       (|UNWIND-PROTECT|
        (PROG1 (|Reference;| #1#) (LETT #2# T |Reference|))
        (COND
         ((NOT #2#) (HREM |$ConstructorCache| (QUOTE |Reference|)))))))))))) 

(DEFUN |Reference;| (|#1|)
 (PROG (|DV$1| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|Reference|))
    (LETT |dv$| (LIST (QUOTE |Reference|) |DV$1|) . #1#)
    (LETT |$| (GETREFV 23) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$| 
      (|buildPredVector| 0 0 
        (LIST (|HasCategory| |#1| (QUOTE (|SetCategory|)))))
      . #1#))
    (|haddProp| 
      |$ConstructorCache| 
      (QUOTE |Reference|) 
      (LIST |DV$1|) 
      (CONS 1 |$|))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 (|Record| (|:| |value| |#1|)))
    (COND 
     ((|testBitVector| |pv$| 1)
      (QSETREFV |$| 21 (CONS (|dispatchFunction| |REF;coerce;$Of;7|) |$|))))
    |$|)))) 

(MAKEPROP
 (QUOTE |Reference|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE 
  #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (QUOTE |Rep|) (|Boolean|)
    |REF;=;2$B;1| |REF;ref;S$;2| |REF;elt;$S;3| |REF;setelt;$2S;4| 
    |REF;deref;$S;5| |REF;setref;$2S;6| (|String|) (|OutputForm|) 
    (0 . |message|) (5 . |coerce|) (|List| |$|) (10 . |prefix|) 
    (16 . |coerce|) (|SingleInteger|)))
  (QUOTE #(|~=| 21 |setref| 27 |setelt| 33 |ref| 39 |latex| 44 |hash| 49 
           |elt| 54 |deref| 59 |coerce| 64 |=| 69))
   (QUOTE NIL)
   (CONS 
    (|makeByteWordVec2| 1 (QUOTE (1 0 1 1))) 
    (CONS 
     (QUOTE #(|SetCategory&| NIL |BasicType&| NIL))
     (CONS
      (QUOTE #((|SetCategory|) (|Type|) (|BasicType|) (|CoercibleTo| 16)))
      (|makeByteWordVec2| 22 
       (QUOTE (1 16 0 15 17 1 6 16 0 18 2 16 0 0 19 20 1 0 16 0 21 2 1 8 0 
               0 1 2 0 6 0 6 14 2 0 6 0 6 12 1 0 0 6 10 1 1 15 0 1 1 1 22 
               0 1 1 0 6 0 11 1 0 6 0 13 1 1 16 0 21 2 0 8 0 0 9))))))
   (QUOTE |lookupComplete|))) 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chunk collections}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<algebra>>=
<<domain ANY Any>>
<<domain ASTACK ArrayStack>>
<<domain ASP1 Asp1>>
<<domain ASP10 Asp10>>
<<domain ASP12 Asp12>>
<<domain ASP19 Asp19>>
<<domain ASP20 Asp20>>
<<domain ASP24 Asp24>>
<<domain ASP27 Asp27>>
<<domain ASP28 Asp28>>
<<domain ASP29 Asp29>>
<<domain ASP30 Asp30>>
<<domain ASP31 Asp31>>
<<domain ASP33 Asp33>>
<<domain ASP34 Asp34>>
<<domain ASP35 Asp35>>
<<domain ASP4 Asp4>>
<<domain ASP41 Asp41>>
<<domain ASP42 Asp42>>
<<domain ASP49 Asp49>>
<<domain ASP50 Asp50>>
<<domain ASP55 Asp55>>
<<domain ASP6 Asp6>>
<<domain ASP7 Asp7>>
<<domain ASP73 Asp73>>
<<domain ASP74 Asp74>>
<<domain ASP77 Asp77>>
<<domain ASP78 Asp78>>
<<domain ASP8 Asp8>>
<<domain ASP80 Asp80>>
<<domain ASP9 Asp9>>

<<domain BITS Bits>>
<<domain BOOLEAN Boolean>>

<<domain DHMATRIX DenavitHartenbergMatrix>>
<<domain DBASE Database>>
<<domain DLIST DataList>>
<<domain DEQUEUE Dequeue>>

<<domain FARRAY FlexibleArray>>

<<domain HEAP Heap>>

<<domain ICARD IndexCard>>
<<domain IBITS IndexedBits>>
<<domain IFARRAY IndexedFlexibleArray>>
<<domain IARRAY1 IndexedOneDimensionalArray>>
<<domain IARRAY2 IndexedTwoDimensionalArray>>
<<domain IIARRAY2 InnerIndexedTwoDimensionalArray>>

<<domain NONE None>>
<<domain NIPROB NumericalIntegrationProblem>>

<<domain ODEPROB NumericalODEProblem>>
<<domain OPTPROB NumericalOptimizationProblem>>
<<domain PDEPROB NumericalPDEProblem>>

<<domain ARRAY1 OneDimensionalArray>>

<<domain ACPLOT PlaneAlgebraicCurvePlot>>
<<domain PRIMARR PrimitiveArray>>

<<domain QEQUAT QueryEquation>>
<<domain QUEUE Queue>>

<<domain REF Reference>>

<<domain SAE SimpleAlgebraicExtension>>
<<domain STACK Stack>>

<<domain TUPLE Tuple>>
<<domain ARRAY2 TwoDimensionalArray>>
@
\begin{thebibliography}{99}
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex
\end{document}
