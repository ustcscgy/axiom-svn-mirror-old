\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% Note that this file will eventually generate a dvi file
%% which will eventually be processed by dvipdfm to create a pdf.
%% The categories/domains/packages will be placed in a graphviz graph.
%% The graphviz dot syntax allows an href parameter.
%% The href parameter will reference this file. 
%% pdf href syntax allows named destinations.
%% This macro creates a named destination using \special
%% Thus, you reference http://thispdf#nameddest=ABBREV 
%% and you end up at the right page.
%% This macro is called implicitly by \pagehead so every 
%% category/domain/package can be referenced by fullname or abbrev.
%%
%% dest will give the ability to use nameddest= in html pdfs
%%
\newcommand{\dest}[1]{% e.g. \dest{abb}
\special{pdf:dest (#1) [ @thispage /FitH @ypos ]}}
%%
%%
%% pagehead consolidates standard page indexing
%%
\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
\dest{#1}%
\dest{#2}%
\section{#1 (#2)}
\label{#1}%
\label{#2}%
\index{{#1}}%
\index{{#2}}}%
%%
%% pagepic adds an image and an index entry
%%
\newcommand{\pagepic}[3]{% e.g. \pagepic{pathandfile}{abb}{scale}
\includegraphics[scale=#3]{#1}%
\index{images!#2}}
%%
%% pageto is a forward link to a referenced page
%%
\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% pagefrom is a backward link to a referencing page
%%
\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% cross will put the category and function in the index
%% cross will leave the funcname so it can be put inline.
%%
\newcommand{\cross}[2]{% e.g. \pagefrom{cat}{funcname}
\index{#1!#2}%
\index{#2!#1}%
#2}


% special meanings for math characters
\providecommand{\N}{\mbox{\bbold N}}
\providecommand{\Natural}{\mbox{\bbold N}}
\providecommand{\Z}{\mbox{\bbold Z}}
\providecommand{\Integer}{\mbox{\bbold Z}}
\providecommand{\Rational}{\mbox{\bbold Q}}
\providecommand{\Q}{\mbox{\bbold Q}}
\providecommand{\Complex}{\mbox{\bbold C}}
\providecommand{\C}{{\mathcal C}}
\providecommand{\Real}{\mbox{\bbold R}}
\providecommand{\F}{{\mathcal F}}
\providecommand{\R}{{\mathcal R}}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 10: Axiom Algebra: Categories}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\chapter{Category Layer 1}
In general, we use several colors in the graph images.
The ``lightblue'' color indicates a category that is in the
direct inheritance path. The ``green'' (\#00EE00) color indicates
a category or domain used in the exports. The ``seagreen'' (a dark
green, indicates a category or domain which is used but does not
correspond to the signature of an existing category. The system
can infer that this ``subsumption node'' matches the category.
A ``yellow'' color indicates a domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Category}{CATEGORY}
\pagepic{ps/v102category.ps}{CATEGORY}{1.00}

This is the root of the category hierarchy and is not represented by code.

{\bf See:}\\
\pageto{ArcHyperbolicFunctionCategory}{AHYP}
\pageto{ArcTrigonometricFunctionCategory}{ATRIG}
\pageto{BasicType}{BASTYPE}
\pageto{CoercibleTo}{KOERCE}
\pageto{CombinatorialFunctionCategory}{CFCAT}
\pageto{ConvertibleTo}{KONVERT}
\pageto{ElementaryFunctionCategory}{ELEMFUN}
\pageto{Eltable}{ELTAB}
\pageto{HyperbolicFunctionCategory}{HYPCAT}
\pageto{InnerEvalable}{IEVALAB}
\pageto{Logic}{LOGIC}
\pageto{PrimitiveFunctionCategory}{PRIMCAT}
\pageto{RetractableTo}{RETRACT}
\pageto{SpecialFunctionCategory}{SPFCAT}
\pageto{TrigonometricFunctionCategory}{TRIGCAT}
\pageto{Type}{TYPE}

<<CATEGORY.dotabb>>=
"CATEGORY"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CATEGORY"];

@
<<CATEGORY.dotfull>>=
"Category"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CATEGORY"];

@
<<CATEGORY.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ArcHyperbolicFunctionCategory}{AHYP}
\pagepic{ps/v102archyperbolicfunctioncategory.ps}{AHYP}{1.00}

{\bf See:}\\
\pageto{TranscendentalFunctionCategory}{TRANFUN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{llllll}
\cross{AHYP}{acosh} &
\cross{AHYP}{acoth} &
\cross{AHYP}{acsch} &
\cross{AHYP}{asech} &
\cross{AHYP}{asinh} &
\cross{AHYP}{atanh} 
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 acosh : % -> %                       
 acoth : % -> %
 acsch : % -> %                       
 asech : % -> %
 asinh : % -> %                       
 atanh : % -> %
\end{verbatim}

<<category AHYP ArcHyperbolicFunctionCategory>>=
)abbrev category AHYP ArcHyperbolicFunctionCategory
++ Category for the inverse hyperbolic trigonometric functions
++ Author: ???
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description:
++ Category for the inverse hyperbolic trigonometric functions;
ArcHyperbolicFunctionCategory(): Category == with
    acosh: $ -> $ ++ acosh(x) returns the hyperbolic arc-cosine of x.
    acoth: $ -> $ ++ acoth(x) returns the hyperbolic arc-cotangent of x.
    acsch: $ -> $ ++ acsch(x) returns the hyperbolic arc-cosecant of x.
    asech: $ -> $ ++ asech(x) returns the hyperbolic arc-secant of x.
    asinh: $ -> $ ++ asinh(x) returns the hyperbolic arc-sine of x.
    atanh: $ -> $ ++ atanh(x) returns the hyperbolic arc-tangent of x.

@
<<AHYP.dotabb>>=
"AHYP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=AHYP"];
"AHYP" -> "CATEGORY"

@
<<AHYP.dotfull>>=
"ArcHyperbolicFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=AHYP"];
"ArcHyperbolicFunctionCategory()" -> "Category"

@
<<AHYP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ArcHyperbolicFunctionCategory()" [color=lightblue];
"ArcHyperbolicFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ArcTrigonometricFunctionCategory}{ATRIG}
\pagepic{ps/v102arctrigonometricfunctioncategory.ps}{ATRIG}{1.00}

The {\tt asec} and {\tt acsc} functions were modified to include an
intermediate test to check that the argument has a reciprocal values.

{\bf See:}\\
\pageto{TranscendentalFunctionCategory}{TRANFUN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{llllll}
\cross{ATRIG}{acos} &
\cross{ATRIG}{acot} &
\cross{ATRIG}{acsc} &
\cross{ATRIG}{asec} &
\cross{ATRIG}{asin} &
\cross{ATRIG}{atan} 
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 acos : % -> %                        
 acot : % -> %
 asin : % -> %                        
 atan : % -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 acsc : % -> %                        
 asec : % -> %
\end{verbatim}

<<category ATRIG ArcTrigonometricFunctionCategory>>=
)abbrev category ATRIG ArcTrigonometricFunctionCategory
++ Category for the inverse trigonometric functions
++ Author: ???
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the inverse trigonometric functions;
ArcTrigonometricFunctionCategory(): Category == with
    acos: $ -> $       ++ acos(x) returns the arc-cosine of x.
    acot: $ -> $       ++ acot(x) returns the arc-cotangent of x.
    acsc: $ -> $       ++ acsc(x) returns the arc-cosecant of x.
    asec: $ -> $       ++ asec(x) returns the arc-secant of x.
    asin: $ -> $       ++ asin(x) returns the arc-sine of x.
    atan: $ -> $       ++ atan(x) returns the arc-tangent of x.
 add
    if $ has Ring then
       asec(x) ==
         (a := recip x) case "failed" => error "asec: no reciprocal"
         acos(a::$)
       acsc(x) == 
         (a := recip x) case "failed" => error "acsc: no reciprocal"
         asin(a::$)

@
<<ATRIG.dotabb>>=
"ATRIG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ATRIG"];
"ATRIG" -> "CATEGORY"

@
<<ATRIG.dotfull>>=
"ArcTrigonometricFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ATRIG"];
"ArcTrigonometricFunctionCategory()" -> "Category"

@
<<ATRIG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ArcTrigonometricFunctionCategory()" [color=lightblue];
"ArcTrigonometricFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{AttributeRegistry}{ATTREG}
\pagepic{ps/v102attributeregistry.ps}{ATTREG}{1.00}

{\bf See:}\\
\pagefrom{Category}{CATEGORY}

{\bf Exports:} Nothing

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{ATTREG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{ATTREG}{commutative("*")}}
is true if it has an operation $"*": (D,D) -> D$
which is commutative.
\item {\bf \cross{ATTREG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\item {\bf \cross{ATTREG}{unitsKnown}}
is true if a monoid (a multiplicative semigroup with a 1) has 
unitsKnown means that  the operation {\tt recip} can only return 
``failed'' if its argument is not a unit.
\item {\bf \cross{ATTREG}{leftUnitary}}
is true if $1 * x = x$ for all x.
\item {\bf \cross{ATTREG}{rightUnitary}}
is true if $x * 1 = x$ for all x.
\item {\bf \cross{ATTREG}{noZeroDivisors}}
is true if $x * y ~= 0$ implies both x and y are non-zero.
\item {\bf \cross{ATTREG}{canonicalUnitNormal}}
is true if we can choose a canonical representative for each class 
of associate elements, that is {\tt associates?(a,b)} returns true 
if and only if {\tt unitCanonical(a) = unitCanonical(b)}.
\item {\bf \cross{ATTREG}{canonicalsClosed}}
is true if\\
{\tt unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.
\item {\bf \cross{ATTREG}{arbitraryPrecision}}
means the user can set the precision for subsequent calculations.
\item {\bf \cross{ATTREG}{partiallyOrderedSet}}
is true if a set with $<$ which is transitive, but 
not($a < b$ or $a = b$) does not necessarily imply $b<a$.
\item {\bf \cross{ATTREG}{central}}
is true if, given an algebra over a ring R, the image of R is the center
of the algebra, i.e. the set of members of the algebra which commute
with all others is precisely the image of R in the algebra.
\item {\bf \cross{ATTREG}{noetherian}}
is true if all of its ideals are finitely generated.
\item {\bf \cross{ATTREG}{additiveValuation}}
implies\\
{\tt euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}.
\item {\bf \cross{ATTREG}{multiplicativeValuation}}
implies\\
{\tt euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}.
\item {\bf \cross{ATTREG}{NullSquare}}
means that $[x,x] = 0$ holds. See {\tt LieAlgebra}.
\item {\bf \cross{ATTREG}{JacobiIdentity}}
means that $[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0$ holds.
See {\tt LieAlgebra}.
\item {\bf \cross{ATTREG}{canonical}}
is true if and only if distinct elements have distinct data structures. 
For example, a domain of mathematical objects which has the 
{\tt canonical} attribute means that two objects are mathematically 
equal if and only if their data structures are equal.
\end{itemize}

<<category ATTREG AttributeRegistry>>=
)abbrev category ATTREG AttributeRegistry

++ This category exports the attributes in the AXIOM Library
AttributeRegistry(): Category == with
  finiteAggregate
    ++ \spad{finiteAggregate} is true if it is an aggregate with a 
    ++ finite number of elements.
  commutative("*")
    ++ \spad{commutative("*")} is true if it has an operation
    ++ \spad{"*": (D,D) -> D} which is commutative.
  shallowlyMutable
    ++ \spad{shallowlyMutable} is true if its values
    ++ have immediate components that are updateable (mutable).
    ++ Note: the properties of any component domain are irrevelant to the
    ++ \spad{shallowlyMutable} proper.
  unitsKnown
    ++ \spad{unitsKnown} is true if a monoid (a multiplicative semigroup 
    ++ with a 1) has \spad{unitsKnown} means that
    ++ the operation \spadfun{recip} can only return "failed" 
    ++ if its argument is not a unit.
  leftUnitary
    ++ \spad{leftUnitary} is true if \spad{1 * x = x} for all x.
  rightUnitary
    ++ \spad{rightUnitary} is true if \spad{x * 1 = x} for all x.
  noZeroDivisors
    ++ \spad{noZeroDivisors} is true if \spad{x * y \~~= 0} implies 
    ++ both x and y are non-zero.
  canonicalUnitNormal
    ++ \spad{canonicalUnitNormal} is true if we can choose a canonical
    ++ representative for each class of associate elements, that is
    ++ \spad{associates?(a,b)} returns true if and only if 
    ++ \spad{unitCanonical(a) = unitCanonical(b)}.
  canonicalsClosed
    ++ \spad{canonicalsClosed} is true if 
    ++ \spad{unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.
  arbitraryPrecision
    ++ \spad{arbitraryPrecision} means the user can set the 
    ++ precision for subsequent calculations.
  partiallyOrderedSet
    ++ \spad{partiallyOrderedSet} is true if
    ++ a set with \spadop{<} which is transitive, 
    ++ but \spad{not(a < b or a = b)}
    ++ does not necessarily imply \spad{b<a}.
  central
    ++ \spad{central} is true if, given an algebra over a ring R,
    ++ the image of R is the center
    ++ of the algebra, i.e. the set of members of the algebra which commute
    ++ with all others is precisely the image of R in the algebra.
  noetherian
    ++ \spad{noetherian} is true if all of its ideals are finitely generated.
  additiveValuation
    ++ \spad{additiveValuation} implies
    ++ \spad{euclideanSize(a*b)=euclideanSize(a)+euclideanSize(b)}.
  multiplicativeValuation
    ++ \spad{multiplicativeValuation} implies
    ++ \spad{euclideanSize(a*b)=euclideanSize(a)*euclideanSize(b)}.
  NullSquare
    ++ \axiom{NullSquare} means that \axiom{[x,x] = 0} holds.
    ++ See \axiomType{LieAlgebra}.
  JacobiIdentity
    ++ \axiom{JacobiIdentity} means that 
    ++ \axiom{[x,[y,z]]+[y,[z,x]]+[z,[x,y]] = 0} holds.
    ++ See \axiomType{LieAlgebra}.
  canonical
    ++ \spad{canonical} is true if and only if distinct elements have 
    ++ distinct data structures. For example, a domain of mathematical 
    ++ objects  which has the \spad{canonical} attribute means that two 
    ++ objects are mathematically equal if and only if their data 
    ++ structures are equal.

@
<<ATTREG.dotabb>>=
"ATTREG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ATTREG"];
"ATTREG" -> "CATEGORY"

@
<<ATTREG.dotabb>>=
"AttributeRegistry()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ATTREG"];
"AttributeRegistry()" -> "Category"

@
<<ATTREG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"AttributeRegistry()" [color=lightblue];
"AttributeRegistry()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{BasicType}{BASTYPE}
\pagepic{ps/v102basictype.ps}{BASTYPE}{1.00}

{\bf See:}\\
\pageto{SetCategory}{SETCAT}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{ll}
\cross{BASTYPE}{?=?} &
\cross{BASTYPE}{?\~{}=?}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?=? : (%,%) -> Boolean                
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?~=? : (%,%) -> Boolean
\end{verbatim}

<<category BASTYPE BasicType>>=
)abbrev category BASTYPE BasicType
--% BasicType
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype{BasicType} is the basic category for describing a collection
++ of elements with \spadop{=} (equality).
BasicType(): Category == with
      "=": (%,%) -> Boolean    ++ x=y tests if x and y are equal.
      "~=": (%,%) -> Boolean   ++ x~=y tests if x and y are not equal.
   add
      _~_=(x:%,y:%) : Boolean == not(x=y)

@
<<BASTYPE.dotabb>>=
"BASTYPE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BASTYPE"];
"BASTYPE" -> "CATEGORY"

@
<<BASTYPE.dotfull>>=
"BasicType()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BASTYPE"];
"BasicType()" -> "Category"

@
<<BASTYPE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CoercibleTo}{KOERCE}
\pagepic{ps/v102koerce.ps}{KOERCE}{1.00}

{\bf See:}\\
\pageto{SetCategory}{SETCAT}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\cross{KOERCE}{coerce}

This is directly exported but not implemented:
\begin{verbatim}
 coerce : % -> S
\end{verbatim}

<<category KOERCE CoercibleTo>>=
)abbrev category KOERCE CoercibleTo
++ Category for coerce
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description:
++ A is coercible to B means any element of A can automatically be
++ converted into an element of B by the interpreter.
CoercibleTo(S:Type): Category == with
    coerce: % -> S
      ++ coerce(a) transforms a into an element of S.

@
<<KOERCE.dotabb>>=
"KOERCE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=KOERCE"];
"KOERCE" -> "CATEGORY"

@
<<KOERCE.dotfull>>=
"CoercibleTo(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=KOERCE"];
"CoercibleTo(a:Type)" -> "Category"

"CoercibleTo(OutputForm)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KOERCE"];
"CoercibleTo(OutputForm)" ->
    "CoercibleTo(a:Type)"

@
<<KOERCE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CombinatorialFunctionCategory}{CFCAT}
\pagepic{ps/v102combinatorialfunctioncategory.ps}{CFCAT}{1.00}

{\bf See:}\\
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{CFCAT}{binomial} &
\cross{CFCAT}{factorial} &
\cross{CFCAT}{permutation} 
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 binomial : (%,%) -> %                 
 factorial : % -> %
 permutation : (%,%) -> %             
\end{verbatim}

<<category CFCAT CombinatorialFunctionCategory>>=
)abbrev category CFCAT CombinatorialFunctionCategory
++ Category for the usual combinatorial functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the usual combinatorial functions;
CombinatorialFunctionCategory(): Category == with
    binomial   : ($, $) -> $
      ++ binomial(n,r) returns the \spad{(n,r)} binomial coefficient
      ++ (often denoted in the literature by \spad{C(n,r)}).
      ++ Note: \spad{C(n,r) = n!/(r!(n-r)!)} where \spad{n >= r >= 0}.
    factorial  : $ -> $
      ++ factorial(n) computes the factorial of n
      ++ (denoted in the literature by \spad{n!})
      ++ Note: \spad{n! = n (n-1)! when n > 0}; also, \spad{0! = 1}.
    permutation: ($, $) -> $
      ++ permutation(n, m) returns the number of
      ++ permutations of n objects taken m at a time.
      ++ Note: \spad{permutation(n,m) = n!/(n-m)!}.

@
<<CFCAT.dotabb>>=
"CFCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CFCAT"];
"CFCAT" -> "CATEGORY" 

@
<<CFCAT.dotfull>>=
"CombinatorialFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CFCAT"];
"CombinatorialFunctionCategory()" -> "Category"

@
<<CFCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CombinatorialFunctionCategory()" [color=lightblue];
"CombinatorialFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ConvertibleTo}{KONVERT}
\pagepic{ps/v102konvert.ps}{KONVERT}{1.00}

{\bf See:}\\
\pageto{Collection}{CLAGG}
\pageto{MonogenicAlgebra}{MONOGEN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\cross{KONVERT}{convert}

This is directly exported but not implemented:
\begin{verbatim}
 convert : % -> S
\end{verbatim}

<<category KONVERT ConvertibleTo>>=
)abbrev category KONVERT ConvertibleTo
++ Category for convert
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description:
++ A is convertible to B means any element of A
++ can be converted into an element of B,
++ but not automatically by the interpreter.
ConvertibleTo(S:Type): Category == with
    convert: % -> S
      ++ convert(a) transforms a into an element of S.

@
<<KONVERT.dotabb>>=
"KONVERT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=KONVERT"];
"KONVERT" -> "CATEGORY"

@
<<KONVERT.dotfull>>=
"ConvertibleTo(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(a:Type)" -> "Category"

"ConvertibleTo(DoubleFloat)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(DoubleFloat)" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(Float)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Float)" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(InputForm)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(InputForm)" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(Integer)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Integer)" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(Pattern(Integer))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Pattern(Integer))" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(Pattern(Float))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Pattern(Float))" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(Complex(Float))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Complex(Float))" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(Complex(DoubleFloat))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Complex(DoubleFloat))" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(String)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(String)" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(Symbol)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Symbol)" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(SExpression)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(SExpression)" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(Pattern(Base))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(Pattern(Base))" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(List(Integer))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(List(Integer))" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(List(Character))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(List(Character))" ->  "ConvertibleTo(a:Type)"

"ConvertibleTo(UnivariatePolynomialCategory(CommutativeRing))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=KONVERT"];
"ConvertibleTo(UnivariatePolynomialCategory(CommutativeRing))" ->
    "ConvertibleTo(a:Type)"

@
<<KONVERT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ConvertibleTo(a:Type)" [color=lightblue];
"ConvertibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ElementaryFunctionCategory}{ELEMFUN}
\pagepic{ps/v102elementaryfunctioncategory.ps}{ELEMFUN}{1.00}

{\bf See:}\\
\pageto{TranscendentalFunctionCategory}{TRANFUN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{ELEMFUN}{?**?} &
\cross{ELEMFUN}{exp} &
\cross{ELEMFUN}{log}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 exp : % -> %
 log : % -> %                         
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?**? : (%,%) -> %                    
\end{verbatim}

<<category ELEMFUN ElementaryFunctionCategory>>=
)abbrev category ELEMFUN ElementaryFunctionCategory
++ Category for the elementary functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the elementary functions;
ElementaryFunctionCategory(): Category == with
    log : $ -> $       ++ log(x) returns the natural logarithm of x.
    exp : $ -> $       ++ exp(x) returns %e to the power x.
    "**": ($, $) -> $  ++ x**y returns x to the power y.
 add
   if $ has Monoid then
     x ** y == exp(y * log x)

@
<<ELEMFUN.dotabb>>=
"ELEMFUN"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELEMFUN"];
"ELEMFUN" -> "CATEGORY"

@
<<ELEMFUN.dotfull>>=
"ElementaryFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELEMFUN"];
"ElementaryFunctionCategory()" -> "Category"

@
<<ELEMFUN.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ElementaryFunctionCategory()" [color=lightblue];
"ElementaryFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Eltable}{ELTAB}
\pagepic{ps/v102eltab.ps}{ELTAB}{1.00}

{\bf See:}\\
\pageto{EltableAggregate}{ELTAGG}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\cross{ELTAB}{?.?}

This syntax for elt is supported by the interpreter and compiler.

This is directly exported but not implemented:
\begin{verbatim}
 ?.? : (%,S) -> Index
\end{verbatim}

<<category ELTAB Eltable>>=
)abbrev category ELTAB Eltable
++ Author: Michael Monagan; revised by Manuel Bronstein and Manuel Bronstein
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An eltable over domains D and I is a structure which can be viewed
++ as a function from D to I.
++ Examples of eltable structures range from data structures, e.g. those
++ of type \spadtype{List}, to algebraic structures like 
++ \spadtype{Polynomial}.
Eltable(S:SetCategory, Index:Type): Category == with
  elt : (%, S) -> Index
     ++ elt(u,i) (also written: u . i) returns the element of u indexed by i.
     ++ Error: if i is not an index of u.

@
<<ELTAB.dotabb>>=
"ELTAB" [color=lightblue,href="bookvol10.2.pdf#nameddest=ELTAB"];
"ELTAB" -> "CATEGORY"

@
<<ELTAB.dotfull>>=
"Eltable(a:SetCategory,b:Type)" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELTAB"];
"Eltable(a:SetCategory,b:Type)" -> "Category"

@
<<ELTAB.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Eltable(a:SetCategory,b:Type)" [color=lightblue];
"Eltable(a:SetCategory,b:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{HyperbolicFunctionCategory}{HYPCAT}
\pagepic{ps/v102hyperbolicfunctioncategory.ps}{HYPCAT}{1.00}

The {\tt csch} and {\tt sech} functions were modified to include an
intermediate test to check that the argument has a reciprocal values.

{\bf See:}\\
\pageto{TranscendentalFunctionCategory}{TRANFUN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{llllll}
\cross{HYPCAT}{cosh} &
\cross{HYPCAT}{coth} &
\cross{HYPCAT}{csch} &
\cross{HYPCAT}{sech} &
\cross{HYPCAT}{sinh} &
\cross{HYPCAT}{tanh} 
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 cosh : % -> %                        
 coth : % -> %
 csch : % -> %                        
 sech : % -> %
 sinh : % -> %                        
 tanh : % -> %
\end{verbatim}

<<category HYPCAT HyperbolicFunctionCategory>>=
)abbrev category HYPCAT HyperbolicFunctionCategory
++ Category for the hyperbolic trigonometric functions
++ Author: ???
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the hyperbolic trigonometric functions;
HyperbolicFunctionCategory(): Category == with
    cosh: $ -> $       ++ cosh(x) returns the hyperbolic cosine of x.
    coth: $ -> $       ++ coth(x) returns the hyperbolic cotangent of x.
    csch: $ -> $       ++ csch(x) returns the hyperbolic cosecant of x.
    sech: $ -> $       ++ sech(x) returns the hyperbolic secant of x.
    sinh: $ -> $       ++ sinh(x) returns the hyperbolic sine of x.
    tanh: $ -> $       ++ tanh(x) returns the hyperbolic tangent of x.
 add
    if $ has Ring then
       csch x == 
         (a := recip(sinh x)) case "failed" => error "csch: no reciprocal"
         a::$
       sech x == 
         (a := recip(cosh x)) case "failed" => error "sech: no reciprocal"
         a::$
       tanh x == sinh x * sech x
       coth x == cosh x * csch x
       if $ has ElementaryFunctionCategory then
         cosh x ==
           e := exp x
           (e + recip(e)::$) * recip(2::$)::$
         sinh(x):$ ==
           e := exp x
           (e - recip(e)::$) * recip(2::$)::$

@
<<HYPCAT.dotabb>>=
"HYPCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=HYPCAT"];
"HYPCAT" -> "CATEGORY"

@
<<HYPCAT.dotfull>>=
"HyperbolicFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=HYPCAT"];
"HyperbolicFunctionCategory()" -> "Category"

@
<<HYPCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"HyperbolicFunctionCategory()" [color=lightblue];
"HyperbolicFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{InnerEvalable}{IEVALAB}
\pagepic{ps/v102innerevalable.ps}{IEVALAB}{1.00}

{\bf See:}\\
\pageto{Evalable}{EVALAB}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{l}
\cross{IEVALAB}{eval}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 eval : (%,A,B) -> %                  
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 eval : (%,List A,List B) -> %
\end{verbatim}

<<category IEVALAB InnerEvalable>>=
)abbrev category IEVALAB InnerEvalable
-- FOR THE BENEFIT OF LIBAX0 GENERATION
++ Author:
++ Date Created:
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains:
++ Also See: Evalable
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This category provides \spadfun{eval} operations.
++   A domain may belong to this category if it is possible to make
++   ``evaluation'' substitutions.  The difference between this
++   and \spadtype{Evalable} is that the operations in this category
++   specify the substitution as a pair of arguments rather than as
++   an equation.
InnerEvalable(A:SetCategory, B:Type): Category == with
    eval: ($, A, B) -> $
       ++ eval(f, x, v) replaces x by v in f.
    eval: ($, List A, List B) -> $
       ++ eval(f, [x1,...,xn], [v1,...,vn]) replaces xi by vi in f.
 add
    eval(f:$, x:A, v:B) == eval(f, [x], [v])

@
<<IEVALAB.dotabb>>=
"IEVALAB"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=IEVALAB"];
"IEVALAB" -> "CATEGORY"

@
<<IEVALAB.dotfull>>=
"InnerEvalable(a:SetCategory,b:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=IEVALAB"];
"InnerEvalable(a:SetCategory,b:Type)" -> "Category"

"InnerEvalable(a:SetCategory,b:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
"InnerEvalable(a:SetCategory,b:SetCategory)" ->
    "InnerEvalable(a:SetCategory,b:Type)"

"InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
"InnerEvalable(a:Ring,MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
     -> "InnerEvalable(a:SetCategory,b:Type)"

"InnerEvalable(Kernal(ExpressionSpace),ExpressionSpace)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=IEVALAB"];
"InnerEvalable(Kernal(ExpressionSpace),ExpressionSpace)" ->
    "InnerEvalable(a:SetCategory,b:Type)"
@
<<IEVALAB.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"InnerEvalable(a:SetCategory,b:Type)" [color=lightblue];
"InnerEvalable(a:SetCategory,b:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{PrimitiveFunctionCategory}{PRIMCAT}
\pagepic{ps/v102primitivefunctioncategory.ps}{PRIMCAT}{1.00}

{\bf See:}\\
\pageto{LiouvillianFunctionCategory}{LFCAT}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{l}
\cross{PRIMCAT}{integral} 
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 integral : (%,Symbol) -> %           
 integral : (%,SegmentBinding %) -> %
\end{verbatim}

<<category PRIMCAT PrimitiveFunctionCategory>>=
)abbrev category PRIMCAT PrimitiveFunctionCategory
++ Category for the integral functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the functions defined by integrals;
PrimitiveFunctionCategory(): Category == with
    integral: ($, Symbol) -> $
      ++ integral(f, x) returns the formal integral of f dx.
    integral: ($, SegmentBinding $) -> $
      ++ integral(f, x = a..b) returns the formal definite integral
      ++ of f dx for x between \spad{a} and b.

@
<<PRIMCAT.dotabb>>=
"PRIMCAT" -> "CATEGORY"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PRIMCAT"];
"PRIMCAT" -> "CATEGORY"

@
<<PRIMCAT.dotfull>>=
"PrimitiveFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PRIMCAT"];
"PrimitiveFunctionCategory()" -> "Category"

@
<<PRIMCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"PrimitiveFunctionCategory()" [color=lightblue];
"PrimitiveFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{RetractableTo}{RETRACT}
\pagepic{ps/v102retractableto.ps}{RETRACT}{1.00}

{\bf See:}\\
\pageto{FullyRetractableTo}{FRETRCT}
\pageto{GradedAlgebra}{GRALG}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{RETRACT}{coerce} &
\cross{RETRACT}{retract} &
\cross{RETRACT}{retractIfCan}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 coerce : S -> %
 retractIfCan : % -> Union(S,"failed")
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 retract : % -> S
\end{verbatim}

<<category RETRACT RetractableTo>>=
)abbrev category RETRACT RetractableTo
++ Category for retract
++ Author: ???
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description:
++ A is retractable to B means that some elementsif A can be converted
++ into elements of B and any element of B can be converted into an
++ element of A.
RetractableTo(S: Type): Category == with
    coerce:       S -> %
      ++ coerce(a) transforms a into an element of %.
    retractIfCan: % -> Union(S,"failed")
      ++ retractIfCan(a) transforms a into an element of S if possible.
      ++ Returns "failed" if a cannot be made into an element of S.
    retract:      % -> S
      ++ retract(a) transforms a into an element of S if possible.
      ++ Error: if a cannot be made into an element of S.
  add
    retract(s) ==
      (u:=retractIfCan s) case "failed" => error "not retractable"
      u

@
<<RETRACT.dotabb>>=
"RETRACT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RETRACT" -> "CATEGORY"

@
<<RETRACT.dotfull>>=
"RetractableTo(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(a:Type)" -> "Category"

"RetractableTo(SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(SetCategory)" -> "RetractableTo(a:Type)"

"RetractableTo(Symbol)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(Symbol)" -> "RetractableTo(a:Type)"

"RetractableTo(Integer)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(Integer)" -> "RetractableTo(a:Type)"

"RetractableTo(NonNegativeInteger)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(NonNegativeInteger)" -> "RetractableTo(a:Type)"

"RetractableTo(Fraction(Integer))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(Fraction(Integer))" -> "RetractableTo(a:Type)"

"RetractableTo(Float)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(Float)" -> "RetractableTo(a:Type)"

"RetractableTo(Kernel(ExpressionSpace))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(Kernel(ExpressionSpace))" -> "RetractableTo(a:Type)"

"RetractableTo(CommutativeRing)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RETRACT"];
"RetractableTo(CommutativeRing)" -> "RetractableTo(a:Type)"

@
<<RETRACT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"RetractableTo(a:Type)" [color=lightblue];
"RetractableTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{SpecialFunctionCategory}{SPFCAT}
\pagepic{ps/v102specialfunctioncategory.ps}{SPFCAT}{1.00}

{\bf See:}\\
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SPFCAT}{abs} &
\cross{SPFCAT}{airyAi} &
\cross{SPFCAT}{airyBi} &
\cross{SPFCAT}{besselI} &
\cross{SPFCAT}{besselJ} \\
\cross{SPFCAT}{besselK} &
\cross{SPFCAT}{besselY} &
\cross{SPFCAT}{Beta} &
\cross{SPFCAT}{digamma} &
\cross{SPFCAT}{Gamma} \\
\cross{SPFCAT}{polygamma} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 abs : % -> %
 airyAi : % -> %                      
 airyBi : % -> %
 besselI : (%,%) -> %                 
 besselJ : (%,%) -> %
 besselK : (%,%) -> %                 
 besselY : (%,%) -> %
 Beta : (%,%) -> %                    
 digamma : % -> %                     
 Gamma : % -> %
 Gamma : (%,%) -> %                   
 polygamma : (%,%) -> %
\end{verbatim}

<<category SPFCAT SpecialFunctionCategory>>=
)abbrev category SPFCAT SpecialFunctionCategory
++ Category for the other special functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 11 May 1993
++ Description: Category for the other special functions;
SpecialFunctionCategory(): Category == with
    abs :      $ -> $
        ++ abs(x) returns the absolute value of x.
    Gamma:     $ -> $
        ++ Gamma(x) is the Euler Gamma function.
    Beta:      ($,$)->$
        ++ Beta(x,y) is \spad{Gamma(x) * Gamma(y)/Gamma(x+y)}.
    digamma:   $ -> $
        ++ digamma(x) is the logarithmic derivative of \spad{Gamma(x)}
        ++ (often written \spad{psi(x)} in the literature).
    polygamma: ($, $) -> $
        ++ polygamma(k,x) is the \spad{k-th} derivative of \spad{digamma(x)},
        ++ (often written \spad{psi(k,x)} in the literature).
    Gamma:     ($, $) -> $
        ++ Gamma(a,x) is the incomplete Gamma function.
    besselJ:   ($,$) -> $
        ++ besselJ(v,z) is the Bessel function of the first kind.
    besselY:   ($,$) -> $
        ++ besselY(v,z) is the Bessel function of the second kind.
    besselI:   ($,$) -> $
        ++ besselI(v,z) is the modified Bessel function of the first kind.
    besselK:   ($,$) -> $
        ++ besselK(v,z) is the modified Bessel function of the second kind.
    airyAi:    $ -> $
        ++ airyAi(x) is the Airy function \spad{Ai(x)}.
    airyBi:    $ -> $
        ++ airyBi(x) is the Airy function \spad{Bi(x)}.

@
<<SPFCAT.dotabb>>=
"SPFCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SPFCAT"];
"SPFCAT" -> "CATEGORY"

@
<<SPFCAT.dotfull>>=
"SpecialFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SPFCAT"];
"SpecialFunctionCategory()" -> "Category"

@
<<SPFCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"SpecialFunctionCategory()" [color=lightblue];
"SpecialFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{TrigonometricFunctionCategory}{TRIGCAT}
\pagepic{ps/v102trigonometricfunctioncategory.ps}{TRIGCAT}{1.00}

The {\tt csc} and {\tt sec} functions were modified to include an
intermediate test to check that the argument has a reciprocal values.

{\bf See:}\\
\pageto{TranscendentalFunctionCategory}{TRANFUN}
\pagefrom{Category}{CATEGORY}

{\bf Exports:}\\
\begin{tabular}{llllll}
\cross{TRIGCAT}{cos} &
\cross{TRIGCAT}{cot} &
\cross{TRIGCAT}{csc} &
\cross{TRIGCAT}{sec} &
\cross{TRIGCAT}{sin} &
\cross{TRIGCAT}{tan} 
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 cos : % -> %                         
 sin : % -> %                         
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 cot : % -> %
 csc : % -> %                         
 sec : % -> %
 tan : % -> %
\end{verbatim}

<<category TRIGCAT TrigonometricFunctionCategory>>=
)abbrev category TRIGCAT TrigonometricFunctionCategory
++ Category for the trigonometric functions
++ Author: ???
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the trigonometric functions;
TrigonometricFunctionCategory(): Category == with
    cos: $ -> $        ++ cos(x) returns the cosine of x.
    cot: $ -> $        ++ cot(x) returns the cotangent of x.
    csc: $ -> $        ++ csc(x) returns the cosecant of x.
    sec: $ -> $        ++ sec(x) returns the secant of x.
    sin: $ -> $        ++ sin(x) returns the sine of x.
    tan: $ -> $        ++ tan(x) returns the tangent of x.
 add
    if $ has Ring then
       csc x == 
         (a := recip(sin x)) case "failed" => error "csc: no reciprocal"
         a::$
       sec x == 
         (a := recip(cos x)) case "failed" => error "sec: no reciprocal"
         a::$
       tan x == sin x * sec x
       cot x == cos x * csc x

@
<<TRIGCAT.dotabb>>=
"TRIGCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=TRIGCAT"];
"TRIGCAT" -> "CATEGORY"

@
<<TRIGCAT.dotfull>>=
"TrigonometricFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=TRIGCAT"];
"TrigonometricFunctionCategory()" -> "Category"

@
<<TRIGCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"TrigonometricFunctionCategory()" [color=lightblue];
"TrigonometricFunctionCategory()" -> "Category"

"Category" [color=lightblue];
}





@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Type}{TYPE}
\pagepic{ps/v102type.ps}{TYPE}{1.00}

{\bf See:}\\
\pageto{Aggregate}{AGG}
\pagefrom{Category}{CATEGORY}
<<category TYPE Type>>=
)abbrev category TYPE Type
++ The new fundamental Type (keeping Object for 1.5 as well)
++ Author: Richard Jenks
++ Date Created: 14 May 1992
++ Date Last Updated: 14 May 1992
++ Description: The fundamental Type;
Type(): Category == with nil

@
<<TYPE.dotabb>>=
"TYPE" [color=lightblue,href="bookvol10.2.pdf#nameddest=TYPE"];
"TYPE" -> "CATEGORY"

@
<<TYPE.dotfull>>=
"Type()" [color=lightblue,href="bookvol10.2.pdf#nameddest=TYPE"];
"Type()" -> "Category"

@
<<TYPE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
\chapter{Category Layer 2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Aggregate}{AGG}
\pagepic{ps/v102agg.ps}{AGG}{1.00}

{\bf See:}\\
\pageto{HomogeneousAggregate}{HOAGG}
\pagefrom{Type}{TYPE}

{\bf Exports:}\\
\begin{tabular}{llllll}
\cross{AGG}{empty?} &
\cross{AGG}{eq?} &
\cross{AGG}{less?} &
\cross{AGG}{more?} &
\cross{AGG}{sample} &
\cross{AGG}{size?}
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{AGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 less? : (%,NonNegativeInteger) -> Boolean
 more? : (%,NonNegativeInteger) -> Boolean
 sample : () -> %                     
 size? : (%,NonNegativeInteger) -> Boolean
\end{verbatim}

<<category AGG Aggregate>>=
)abbrev category AGG Aggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The notion of aggregate serves to model any data structure aggregate,
++ designating any collection of objects,
++ with heterogenous or homogeneous members,
++ with a finite or infinite number
++ of members, explicitly or implicitly represented.
++ An aggregate can in principle
++ represent everything from a string of characters to abstract sets such
++ as "the set of x satisfying relation {\em r(x)}"
++ An attribute \spadatt{finiteAggregate} is used to assert that a domain
++ has a finite number of elements.
Aggregate: Category == Type with
   eq?: (%,%) -> Boolean
     ++ eq?(u,v) tests if u and v are same objects.
   copy: % -> %
     ++ copy(u) returns a top-level (non-recursive) copy of u.
     ++ Note: for collections, \axiom{copy(u) == [x for x in u]}.
   empty: () -> %
     ++ empty()$D creates an aggregate of type D with 0 elements.
     ++ Note: The {\em $D} can be dropped if understood by context,
     ++ e.g. \axiom{u: D := empty()}.
   empty?: % -> Boolean
     ++ empty?(u) tests if u has 0 elements.
   less?: (%,NonNegativeInteger) -> Boolean
     ++ less?(u,n) tests if u has less than n elements.
   more?: (%,NonNegativeInteger) -> Boolean
     ++ more?(u,n) tests if u has greater than n elements.
   size?: (%,NonNegativeInteger) -> Boolean
     ++ size?(u,n) tests if u has exactly n elements.
   sample: constant -> %
     ++ sample yields a value of type %
   if % has finiteAggregate then
     "#": % -> NonNegativeInteger
       ++ # u returns the number of items in u.
 add
  eq?(a,b) == EQ(a,b)$Lisp
  sample() == empty()
  if % has finiteAggregate then
    empty? a   == #a = 0
    less?(a,n) == #a < n
    more?(a,n) == #a > n
    size?(a,n) == #a = n

@
<<AGG.dotabb>>=
"AGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=AGG"];
"AGG" -> "TYPE"

@
<<AGG.dotfull>>=
"Aggregate()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=AGG"];
"Aggregate()" -> "Type()"

@
<<AGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{EltableAggregate}{ELTAGG}
\pagepic{ps/v102eltableaggregate.ps}{ELTAGG}{0.75}

{\bf See:}\\
\pageto{IndexedAggregate}{IXAGG}
\pagefrom{Eltable}{ELTAB}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ELTAGG}{elt} &
\cross{ELTAGG}{qelt} &
\cross{ELTAGG}{qsetelt!} &
\cross{ELTAGG}{setelt} &
\cross{ELTAGG}{?.?}
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{ELTAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are part of this category's direct exports:
\begin{verbatim}
 elt : (%,Dom,Im) -> Im                
 setelt : (%,Dom,Im) -> Im if $ has shallowlyMutable
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 qelt : (%,Dom) -> Im                 
 qsetelt! : (%,Dom,Im) -> Im if $ has shallowlyMutable
\end{verbatim}

This export comes from Eltable:
\begin{verbatim}
 ?.? : (%,Dom) -> Im
\end{verbatim}

<<category ELTAGG EltableAggregate>>=
)abbrev category ELTAGG EltableAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An eltable aggregate is one which can be viewed as a function.
++ For example, the list \axiom{[1,7,4]} can applied to 0,1, and 2 
++ respectively will return the integers 1,7, and 4; thus this list may 
++ be viewed as mapping 0 to 1, 1 to 7 and 2 to 4. In general, an aggregate
++ can map members of a domain {\em Dom} to an image domain {\em Im}.
EltableAggregate(Dom:SetCategory, Im:Type): Category ==
-- This is separated from Eltable
-- and series won't have to support qelt's and setelt's.
  Eltable(Dom, Im) with
    elt : (%, Dom, Im) -> Im
       ++ elt(u, x, y) applies u to x if x is in the domain of u,
       ++ and returns y otherwise.
       ++ For example, if u is a polynomial in \axiom{x} over the rationals,
       ++ \axiom{elt(u,n,0)} may define the coefficient of \axiom{x}
       ++ to the power n, returning 0 when n is out of range.
    qelt: (%, Dom) -> Im
       ++ qelt(u, x) applies \axiom{u} to \axiom{x} without checking whether
       ++ \axiom{x} is in the domain of \axiom{u}.  If \axiom{x} is not 
       ++ in the domain of \axiom{u} a memory-access violation may occur. 
       ++ If a check on whether \axiom{x} is in the domain of \axiom{u} 
       ++ is required, use the function \axiom{elt}.
    if % has shallowlyMutable then
       setelt : (%, Dom, Im) -> Im
	   ++ setelt(u,x,y) sets the image of x to be y under u,
	   ++ assuming x is in the domain of u.
	   ++ Error: if x is not in the domain of u.
	   -- this function will soon be renamed as setelt!.
       qsetelt_!: (%, Dom, Im) -> Im
	   ++ qsetelt!(u,x,y) sets the image of \axiom{x} to be \axiom{y} 
           ++ under \axiom{u}, without checking that \axiom{x} is in 
           ++ the domain of \axiom{u}.
           ++ If such a check is required use the function \axiom{setelt}.
 add
  qelt(a, x) == elt(a, x)
  if % has shallowlyMutable then
    qsetelt_!(a, x, y) == (a.x := y)

@
<<ELTAGG.dotabb>>=
"ELTAGG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELTAGG"];
"ELTAGG" -> "ELTAB"

@
<<ELTAGG.dotfull>>=
"EltableAggregate(a:SetCategory,b:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELTAGG"];
"EltableAggregate(a:SetCategory,b:Type)" -> "Eltable(a:SetCategory,b:Type)"

@
<<ELTAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"EltableAggregate(a:SetCategory,b:Type)" [color=lightblue];
"EltableAggregate(a:SetCategory,b:Type)" -> "Eltable(a:SetCategory,b:Type)"

"Eltable(a:SetCategory,b:Type)" [color=lightblue];
"Eltable(a:SetCategory,b:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Evalable}{EVALAB}
\pagepic{ps/v102evalable.ps}{EVALAB}{1.00}

{\bf See:}\\
\pagefrom{InnerEvalable}{IEVALAB}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 eval : (%,List Equation R) -> %       
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
eval : (%,Equation R) -> %
eval : (%,List R,List R) -> %
\end{verbatim}

These exports come from InnerEvalable(R:SetCategory,R:SetCategory):
\begin{verbatim}
 eval : (%,R,R) -> %                   
\end{verbatim}

<<category EVALAB Evalable>>=
)abbrev category EVALAB Evalable
++ Author:
++ Date Created:
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains:
++ Also See: FullyEvalable
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This category provides \spadfun{eval} operations.
++   A domain may belong to this category if it is possible to make
++   ``evaluation'' substitutions.
Evalable(R:SetCategory): Category == InnerEvalable(R,R) with
    eval: ($, Equation R) -> $
       ++ eval(f,x = v) replaces x by v in f.
    eval: ($, List Equation R) -> $
       ++ eval(f, [x1 = v1,...,xn = vn]) replaces xi by vi in f.
 add
    eval(f:$, eq:Equation R) == eval(f, [eq])
    eval(f:$, xs:List R,vs:List R) == eval(f,[x=v for x in xs for v in vs])

@
<<EVALAB.dotabb>>=
"EVALAB"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=EVALAB"];
"EVALAB" -> "IEVALAB"

@
<<EVALAB.dotfull>>=
"Evalable(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=EVALAB"];
"Evalable(a:SetCategory)" -> "InnerEvalable(a:SetCategory,b:SetCategory)"

"Evalable(MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=EVALAB"];
"Evalable(MultivariateTaylorSeriesCategory(a:Ring,b:OrderedSet))" ->
    "Evalable(a:SetCategory)"

"Evalable(ExpressionSpace)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=EVALAB"];
"Evalable(ExpressionSpace)" -> "Evalable(a:SetCategory)"

@
<<EVALAB.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Evalable(a:SetCategory)" [color=lightblue];
"Evalable(a:SetCategory)" -> "InnerEvalable(a:SetCategory,b:SetCategory)"

"InnerEvalable(a:SetCategory,b:SetCategory)" [color=seagreen];
"InnerEvalable(a:SetCategory,b:SetCategory)" ->
    "InnerEvalable(a:SetCategory,b:Type)"

"InnerEvalable(a:SetCategory,b:Type)" [color=lightblue];
"InnerEvalable(a:SetCategory,b:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FullyRetractableTo}{FRETRCT}
\pagepic{ps/v102fullyretractableto.ps}{FRETRCT}{1.00}

{\bf See:}\\
\pageto{MonogenicAlgebra}{MONOGEN}
\pagefrom{RetractableTo}{RETRACT}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{FRETRCT}{coerce} &
\cross{FRETRCT}{retract} &
\cross{FRETRCT}{retractIfCan} 
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 coerce : Integer -> % 
     if S has RETRACT INT
 coerce : Fraction Integer -> % 
     if S has RETRACT FRAC INT
 retract : % -> Integer 
     if S has RETRACT INT
 retract : % -> Fraction Integer 
     if S has RETRACT FRAC INT
 retractIfCan : % -> Union(Integer,"failed") 
     if S has RETRACT INT
 retractIfCan : % -> Union(Fraction Integer,"failed") 
     if S has RETRACT FRAC INT
\end{verbatim}

These exports come from RetractableTo(S:Type):
\begin{verbatim}
 coerce : S -> %                       
 retract : % -> S
 retractIfCan : % -> Union(S,"failed")
\end{verbatim}

<<category FRETRCT FullyRetractableTo>>=
)abbrev category FRETRCT FullyRetractableTo
++ Author: Manuel Bronstein
++ Description:
++   A is fully retractable to B means that A is retractable to B, and,
++   in addition, if B is retractable to the integers or rational
++   numbers then so is A.
++   In particular, what we are asserting is that there are no integers
++   (rationals) in A which don't retract into B.
++ Date Created: March 1990
++ Date Last Updated: 9 April 1991
FullyRetractableTo(S: Type): Category == RetractableTo(S) with
    if (S has RetractableTo Integer) then RetractableTo Integer
    if (S has RetractableTo Fraction Integer) then
              RetractableTo Fraction Integer
  add
    if not(S is Integer) then
      if (S has RetractableTo Integer) then    -- induction
        coerce(n:Integer):%  == n::S::%
        retract(r:%):Integer == retract(retract(r)@S)
 
        retractIfCan(r:%):Union(Integer, "failed") ==
          (u:= retractIfCan(r)@Union(S,"failed")) case "failed"=> "failed"
          retractIfCan(u::S)
 
    if not(S is Fraction Integer) then
      if (S has RetractableTo Fraction Integer) then   -- induction
        coerce(n:Fraction Integer):%  == n::S::%
        retract(r:%):Fraction(Integer) == retract(retract(r)@S)
 
        retractIfCan(r:%):Union(Fraction Integer, "failed") ==
          (u:=retractIfCan(r)@Union(S,"failed")) case "failed"=>"failed"
          retractIfCan(u::S)

@
<<FRETRCT.dotabb>>=
"FRETRCT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRETRCT"];
"FRETRCT" -> "RETRACT"

@
<<FRETRCT.dotfull>>=
"FullyRetractableTo(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRETRCT"];
"FullyRetractableTo(a:Type)" -> "RetractableTo(a:Type)"

 [color=seagreen,href="bookvol10.2.pdf#nameddest=FRETRCT"];
"FullyRetractableTo(a:Ring)" -> "FullyRetractableTo(a:Type)"

 [color=seagreen,href="bookvol10.2.pdf#nameddest=FRETRCT"];
"FullyRetractableTo(a:CommutativeRing)" -> "FullyRetractableTo(a:Type)"

 [color=seagreen,href="bookvol10.2.pdf#nameddest=FRETRCT"];
"FullyRetractableTo(a:SetCategory)" -> "FullyRetractableTo(a:Type)"

@
<<FRETRCT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FullyRetractableTo(a:Type)" [color=lightblue];
"FullyRetractableTo(a:Type)" -> "RetractableTo(a:Type)"

"RetractableTo(a:Type)" [color=lightblue];
"RetractableTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Logic}{LOGIC}
\pagepic{ps/v102logic.ps}{LOGIC}{1.00}

{\bf See:}\\
\pageto{BitAggregate}{BTAGG}
\pagefrom{BasicType}{BASTYPE}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{LOGIC}{?$/\backslash{}$?}
\cross{LOGIC}{?=?}
\cross{LOGIC}{?$\backslash{}/$?}
\cross{LOGIC}{\~{}?}
\cross{LOGIC}{?\~{}=?}
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ~? : % -> %
 ?/\? : (%,%) -> %                    
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?\/? : (%,%) -> %                    
\end{verbatim}

These exports come from BasicType():
\begin{verbatim}
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

<<category LOGIC Logic>>=
)abbrev category LOGIC Logic
++ Author: 
++ Date Created:
++ Change History:
++ Basic Operations: ~, /\, \/
++ Related Constructors:
++ Keywords: boolean
++ Description:  
++ `Logic' provides the basic operations for lattices,
++ e.g., boolean algebra.
Logic: Category == BasicType with
       _~:        % -> %
	++ ~(x) returns the logical complement of x.
       _/_\:       (%, %) -> %
	++ \spadignore { /\ }returns the logical `meet', e.g. `and'.
       _\_/:       (%, %) -> %
	++ \spadignore{ \/ } returns the logical `join', e.g. `or'.
  add
    _\_/(x: %,y: %) == _~( _/_\(_~(x), _~(y)))

@
<<LOGIC.dotabb>>=
"LOGIC"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LOGIC"];
"LOGIC" -> "BASTYPE"

@
<<LOGIC.dotfull>>=
"Logic()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LOGIC"];
"Logic()" -> "BasicType()"

@
<<LOGIC.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Logic()" [color=lightblue];
"Logic()" -> "BasicType()"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{SetCategory}{SETCAT}
\pagepic{ps/v102setcategory.ps}{SETCAT}{1.00}

{\bf See:}\\
\pageto{AbelianSemiGroup}{ABELSG}
\pageto{Finite}{FINITE}
\pageto{GradedModule}{GRMOD}
\pageto{HomogeneousAggregate}{HOAGG}
\pageto{OrderedSet}{ORDSET}
\pageto{SemiGroup}{SGROUP}
\pageto{SetAggregate}{SETAGG}
\pageto{StepThrough}{STEP}
\pagefrom{BasicType}{BASTYPE}
\pagefrom{CoercibleTo}{KOERCE}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SETCAT}{coerce} &
\cross{SETCAT}{hash} &
\cross{SETCAT}{latex} &
\cross{SETCAT}{?=?} &
\cross{SETCAT}{?\~{}=?}
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 hash : % -> SingleInteger            
 latex : % -> String
\end{verbatim}

These exports come from BasicType():
\begin{verbatim}
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

These exports come from CoercibleTo(OutputForm):
\begin{verbatim}
 coerce : % -> OutputForm
\end{verbatim}

<<category SETCAT SetCategory>>=
)abbrev category SETCAT SetCategory
++ Author:
++ Date Created:
++ Date Last Updated:
++   09/09/92   RSS   added latex and hash
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype{SetCategory} is the basic category for describing a collection
++ of elements with \spadop{=} (equality) and \spadfun{coerce} to 
++ output form.
++
++ Conditional Attributes:
++    canonical\tab{15}data structure equality is the same as \spadop{=}
SetCategory(): Category == Join(BasicType,CoercibleTo OutputForm) with
      hash: % -> SingleInteger  ++ hash(s) calculates a hash code for s.
      latex: % -> String       ++ latex(s) returns a LaTeX-printable output
                               ++ representation of s.
  add
      hash(s : %):  SingleInteger == 0$SingleInteger
      latex(s : %): String       == "\mbox{\bf Unimplemented}"

@
<<SETCAT.dotabb>>=
"SETCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SETCAT"];
"SETCAT" -> "BASTYPE"
"SETCAT" -> "KOERCE"

@
<<SETCAT.dotfull>>=
"SetCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SETCAT"];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

@
<<SETCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{TranscendentalFunctionCategory}{TRANFUN}
\pagepic{ps/v102transcendentalfunctioncategory.ps}{TRANFUN}{0.75}

The {\tt acsch}, {\tt asech}, and {\tt acoth} functions were modified to
include an intermediate test to check that the argument has a
reciprocal values.

{\bf See:}\\
\pageto{LiouvillianFunctionCategory}{LFCAT}
\pagefrom{ArcHyperbolicFunctionCategory}{AHYP}
\pagefrom{ArcTrigonometricFunctionCategory}{ATRIG}
\pagefrom{ElementaryFunctionCategory}{ELEMFUN}
\pagefrom{HyperbolicFunctionCategory}{HYPCAT}
\pagefrom{TrigonometricFunctionCategory}{TRIGCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{TRANFUN}{?**?} &
\cross{TRANFUN}{acos} &
\cross{TRANFUN}{acosh} &
\cross{TRANFUN}{acot} &
\cross{TRANFUN}{acoth} \\
\cross{TRANFUN}{acsc} &
\cross{TRANFUN}{acsch} &
\cross{TRANFUN}{asec} &
\cross{TRANFUN}{asech} &
\cross{TRANFUN}{asin} \\
\cross{TRANFUN}{asinh} &
\cross{TRANFUN}{atan} &
\cross{TRANFUN}{atanh} &
\cross{TRANFUN}{cos} &
\cross{TRANFUN}{cosh} \\
\cross{TRANFUN}{cot} &
\cross{TRANFUN}{coth} &
\cross{TRANFUN}{csc} &
\cross{TRANFUN}{csch} &
\cross{TRANFUN}{exp} \\
\cross{TRANFUN}{log} &
\cross{TRANFUN}{pi} &
\cross{TRANFUN}{sec} &
\cross{TRANFUN}{sech} &
\cross{TRANFUN}{sin} \\
\cross{TRANFUN}{sinh} &
\cross{TRANFUN}{tan} &
\cross{TRANFUN}{tanh} &&
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 pi : () -> %
\end{verbatim}

These exports come from TrigonometricFunctionCategory():
\begin{verbatim}
 cos : % -> %
 cot : % -> %
 csc : % -> %
 sec : % -> %                         
 sin : % -> %                         
 tan : % -> %                         
\end{verbatim}

These exports come from ArcTrigonometricFunctionCategory():
\begin{verbatim}
 acos : % -> %
 acot : % -> %
 acsc : % -> %
 asec : % -> %
 asin : % -> %
 atan : % -> %
\end{verbatim}

These exports come from HyperbolicFunctionCategory():
\begin{verbatim}
 cosh : % -> %                        
 coth : % -> %                        
 csch : % -> %                        
 sech : % -> %
 sinh : % -> %
 tanh : % -> %
\end{verbatim}

These exports come from ArcHyperbolicFunctionCategory():
\begin{verbatim}
 acosh : % -> %                       
 acoth : % -> %                       
 acsch : % -> %                       
 asech : % -> %                       
 asinh : % -> %                       
 atanh : % -> %                       
\end{verbatim}

These exports come from ElementaryFunctionCategory():
\begin{verbatim}
 ?**? : (%,%) -> %                    
 exp : % -> %
 log : % -> %                         
\end{verbatim}

<<category TRANFUN TranscendentalFunctionCategory>>=
)abbrev category TRANFUN TranscendentalFunctionCategory
++ Category for the transcendental elementary functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the transcendental elementary functions;
TranscendentalFunctionCategory(): Category ==
    Join(TrigonometricFunctionCategory,ArcTrigonometricFunctionCategory,
         HyperbolicFunctionCategory,ArcHyperbolicFunctionCategory,
         ElementaryFunctionCategory) with
           pi : () -> $        ++ pi() returns the constant pi.
   add
     if $ has Ring then
       pi()   == 2*asin(1)
       acsch x == 
         (a := recip x) case "failed" => error "acsch: no reciprocal"
         asinh(a::$)
       asech x == 
         (a := recip x) case "failed" => error "asech: no reciprocal"
         acosh(a::$)
       acoth x == 
         (a := recip x) case "failed" => error "acoth: no reciprocal"
         atanh(a::$)
     if $ has Field and $ has sqrt: $ -> $ then
       asin x == atan(x/sqrt(1-x**2))
       acos x == pi()/2::$ - asin x
       acot x == pi()/2::$ - atan x
       asinh x == log(x + sqrt(x**2 + 1))
       acosh x == 2*log(sqrt((x+1)/2::$) + sqrt((x-1)/2::$))
       atanh x == (log(1+x)-log(1-x))/2::$

@
<<TRANFUN.dotabb>>=
"TRANFUN" -> "TRIGCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=TRANFUN"];
"TRANFUN" -> "TRIGCAT"
"TRANFUN" -> "ATRIG"
"TRANFUN" -> "HYPCAT"
"TRANFUN" -> "AHYP"
"TRANFUN" -> "ELEMFUN"

@
<<TRANFUN.dotfull>>=
"TranscendentalFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=TRANFUN"];
"TranscendentalFunctionCategory()" ->
    "TrigonometricFunctionCategory()"
"TranscendentalFunctionCategory()" ->
    "ArcTrigonometricFunctionCategory()"
"TranscendentalFunctionCategory()" ->
    "HyperbolicFunctionCategory()"
"TranscendentalFunctionCategory()" ->
    "ArcHyperbolicFunctionCategory()"
"TranscendentalFunctionCategory()" ->
    "ElementaryFunctionCategory()"

@
<<TRANFUN.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"TranscendentalFunctionCategory()" [color=lightblue];
"TranscendentalFunctionCategory()" ->
    "TRIGCAT"
"TranscendentalFunctionCategory()" ->
    "ATRIG"
"TranscendentalFunctionCategory()" ->
    "HYPCAT"
"TranscendentalFunctionCategory()" ->
    "AHYP"
"TranscendentalFunctionCategory()" ->
    "ELEMFUN"

"TRIGCAT" [color=lightblue];
"TRIGCAT" -> "Category"

"ATRIG" [color=lightblue];
"ATRIG" -> "Category"

"HYPCAT" [color=lightblue];
"HYPCAT" -> "Category"

"AHYP" [color=lightblue];
"AHYP" -> "Category"

"ELEMFUN" [color=lightblue];
"ELEMFUN" -> "Category"

"Category" [color=lightblue];
}

@
\chapter{Category Layer 3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{AbelianSemiGroup}{ABELSG}
\pagepic{ps/v102abeliansemigroup.ps}{ABELSG}{0.75}

{\bf See:}\\
\pageto{AbelianMonoid}{ABELMON}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ABELSG}{coerce} &
\cross{ABELSG}{hash} &
\cross{ABELSG}{latex} &
\cross{ABELSG}{?*?} &
\cross{ABELSG}{?+?} \\
\cross{ABELSG}{?=?} &
\cross{ABELSG}{?\~{}=?} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?+? : (%,%) -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?*? : (PositiveInteger,%) -> %       
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

<<category ABELSG AbelianSemiGroup>>=
)abbrev category ABELSG AbelianSemiGroup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ the class of all additive (commutative) semigroups, i.e.
++ a set with a commutative and associative operation \spadop{+}.
++
++ Axioms:
++   \spad{associative("+":(%,%)->%)}\tab{30}\spad{ (x+y)+z = x+(y+z) }
++   \spad{commutative("+":(%,%)->%)}\tab{30}\spad{ x+y = y+x }
AbelianSemiGroup(): Category == SetCategory with
      "+": (%,%) -> %                  ++ x+y computes the sum of x and y.
      "*": (PositiveInteger,%) -> %
        ++ n*x computes the left-multiplication of x by the positive 
        ++ integer n. This is equivalent to adding x to itself n times.
    add
      import RepeatedDoubling(%)
      if not (% has Ring) then
        n:PositiveInteger * x:% == double(n,x)

@
<<ABELSG.dotabb>>=
"ABELSG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELSG"];
"ABELSG" -> "SETCAT"
"ABELSG" -> "REPDB"

@
<<ABELSG.dotfull>>=
"AbelianSemiGroup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELSG"];
"AbelianSemiGroup()" -> "SetCategory()"
"AbelianSemiGroup()" -> "RepeatedDoubling(a:SetCategory)"

<<ABELSG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SetCategory()"
"AbelianSemiGroup()" -> "RepeatedDoubling(AbelianSemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" ->
    "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedDoubling(AbelianSemiGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianSemiGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Finite}{FINITE}
\pagepic{ps/v102finite.ps}{FINITE}{1.00}

{\bf See:}\\
\pageto{OrderedFinite}{ORDFIN}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FINITE}{coerce}
\cross{FINITE}{hash} &
\cross{FINITE}{index} &
\cross{FINITE}{latex} &
\cross{FINITE}{lookup} &
\cross{FINITE}{random} \\
\cross{FINITE}{size} &
\cross{FINITE}{?=?} &
\cross{FINITE}{?\~{}=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 index : PositiveInteger -> %
 lookup : % -> PositiveInteger
 random : () -> %                     
 size : () -> NonNegativeInteger
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String                  
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

<<category FINITE Finite>>=
)abbrev category FINITE Finite
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of domains composed of a finite set of elements.
++ We include the functions \spadfun{lookup} and \spadfun{index} 
++ to give a bijection between the finite set and an initial 
++ segment of positive integers.
++
++ Axioms:
++   \spad{lookup(index(n)) = n}
++   \spad{index(lookup(s)) = s}

Finite(): Category == SetCategory with
      size: () ->  NonNegativeInteger
        ++ size() returns the number of elements in the set.
      index: PositiveInteger -> %
        ++ index(i) takes a positive integer i less than or equal
        ++ to \spad{size()} and
        ++ returns the \spad{i}-th element of the set. 
        ++ This operation establishs a bijection
        ++ between the elements of the finite set and \spad{1..size()}.
      lookup: % -> PositiveInteger
        ++ lookup(x) returns a positive integer such that
        ++ \spad{x = index lookup x}.
      random: () -> %
        ++ random() returns a random element from the set.

@
<<FINITE.dotabb>>=
"FINITE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINITE"];
"FINITE" -> "SETCAT"

@
<<FINITE.dotfull>>=
"Finite()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINITE"];
"Finite()" -> "SetCategory()"

@
<<FINITE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Finite()" [color=lightblue];
"Finite()" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{GradedModule}{GRMOD}
\pagepic{ps/v102gradedmodule.ps}{GRMOD}{1.00}

{\bf See:}\\
\pageto{GradedAlgebra}{GRALG}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{GRMOD}{0} &
\cross{GRMOD}{coerce} &
\cross{GRMOD}{degree} &
\cross{GRMOD}{hash} &
\cross{GRMOD}{latex} \\
\cross{GRMOD}{?\~{}=?} &
\cross{GRMOD}{?*?} &
\cross{GRMOD}{?+?} &
\cross{GRMOD}{?-?} &
\cross{GRMOD}{-?} \\
\cross{GRMOD}{?=?} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 0 : () -> %                          
 degree : % -> E                      
 ?*? : (%,R) -> %                     
 ?*? : (R,%) -> %
 -? : % -> %                          
 ?+? : (%,%) -> %                     
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?-? : (%,%) -> %
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger
 latex : % -> String                  
 ?~=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category GRMOD GradedModule>>=
)abbrev category GRMOD GradedModule
++ Author: Stephen M. Watt
++ Date Created: May 20, 1991
++ Date Last Updated: May 20, 1991
++ Basic Operations: +, *, degree
++ Related Domains: CartesianTensor(n,dim,R)
++ Also See:
++ AMS Classifications:
++ Keywords: graded module, tensor, multi-linear algebra
++ Examples:
++ References: Algebra 2d Edition, MacLane and Birkhoff, MacMillan 1979
++ Description:
++  GradedModule(R,E) denotes ``E-graded R-module'', i.e. collection of
++  R-modules indexed by an abelian monoid E.
++  An element \spad{g} of \spad{G[s]} for some specific \spad{s} in \spad{E}
++  is said to be an element of \spad{G} with {\em degree} \spad{s}.
++  Sums are defined in each module \spad{G[s]} so two elements of \spad{G}
++  have a sum if they have the same degree.
++
++  Morphisms can be defined and composed by degree to give the
++  mathematical category of graded modules.

GradedModule(R: CommutativeRing, E: AbelianMonoid): Category ==
    SetCategory with
        degree: % -> E
            ++ degree(g) names the degree of g.  The set of all elements
            ++ of a given degree form an R-module.
        0: constant -> %
            ++ 0 denotes the zero of degree 0.
        _*: (R, %) -> %
            ++ r*g is left module multiplication.
        _*: (%, R) -> %
            ++ g*r is right module multiplication.

        _-: % -> %
            ++ -g is the additive inverse of g in the module of elements
            ++ of the same grade as g.
        _+: (%, %) -> %
            ++ g+h is the sum of g and h in the module of elements of
            ++ the same degree as g and h.  Error: if g and h
            ++ have different degrees.
        _-: (%, %) -> %
            ++ g-h is the difference of g and h in the module of elements of
            ++ the same degree as g and h.  Error: if g and h
            ++ have different degrees.
  add
        (x: %) - (y: %) == x+(-y)

@
<<GRMOD.dotabb>>=
"GRMOD"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GRMOD"];
"GRMOD" -> "SETCAT"

@
<<GRMOD.dotfull>>=
"GradedModule(a:CommutativeRing,b:AbelianMonoid)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GRMOD"];
"GradedModule(a:CommutativeRing,b:AbelianMonoid)" -> "SetCategory()"

@
<<GRMOD.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"GradedModule(a:CommutativeRing,b:AbelianMonoid)" [color=lightblue];
"GradedModule(a:CommutativeRing,b:AbelianMonoid)" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{HomogeneousAggregate}{HOAGG}
\pagepic{ps/v102homogeneousaggregate.ps}{HOAGG}{1.00}

{\bf See:}\\
\pageto{BagAggregate}{BGAGG}
\pageto{Collection}{CLAGG}
\pageto{IndexedAggregate}{IXAGG}
\pageto{RecursiveAggregate}{RCAGG}
\pageto{TwoDimensionalArrayCategory}{ARR2CAT}
\pagefrom{Aggregate}{AGG}
\pagefrom{Evalable}{EVALAB}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{HOAGG}{any?} &
\cross{HOAGG}{coerce} &
\cross{HOAGG}{copy} &
\cross{HOAGG}{count} &
\cross{HOAGG}{empty} \\
\cross{HOAGG}{empty?} &
\cross{HOAGG}{eq?} &
\cross{HOAGG}{eval} &
\cross{HOAGG}{every?} &
\cross{HOAGG}{hash} \\
\cross{HOAGG}{latex} &
\cross{HOAGG}{less?} &
\cross{HOAGG}{map} &
\cross{HOAGG}{map!} &
\cross{HOAGG}{members} \\
\cross{HOAGG}{member?} &
\cross{HOAGG}{more?} &
\cross{HOAGG}{parts} &
\cross{HOAGG}{sample} &
\cross{HOAGG}{size?} \\
\cross{HOAGG}{\#?} &
\cross{HOAGG}{?=?} &
\cross{HOAGG}{?\~{}=?} &&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{HOAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{HOAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 parts : % -> List S if $ has finiteAggregate
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from Aggregate:
\begin{verbatim}
 copy : % -> %
 empty : () -> %
 empty? : % -> Boolean                
 eq? : (%,%) -> Boolean
 less? : (%,NonNegativeInteger) -> Boolean
 more? : (%,NonNegativeInteger) -> Boolean
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
\end{verbatim}

These exports come from Evalable(a:Type):
\begin{verbatim}
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 hash : % -> SingleInteger if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
 latex : % -> String if S has SETCAT
\end{verbatim}

<<category HOAGG HomogeneousAggregate>>=
)abbrev category HOAGG HomogeneousAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991, May 1995
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A homogeneous aggregate is an aggregate of elements all of the
++ same type.
++ In the current system, all aggregates are homogeneous.
++ Two attributes characterize classes of aggregates.
++ Aggregates from domains with attribute \spadatt{finiteAggregate}
++ have a finite number of members.
++ Those with attribute \spadatt{shallowlyMutable} allow an element
++ to be modified or updated without changing its overall value.
HomogeneousAggregate(S:Type): Category == Aggregate with
   if S has SetCategory then SetCategory
   if S has SetCategory then
      if S has Evalable S then Evalable S
   map	   : (S->S,%) -> %
     ++ map(f,u) returns a copy of u with each element x replaced by f(x).
     ++ For collections, \axiom{map(f,u) = [f(x) for x in u]}.
   if % has shallowlyMutable then
     map_!: (S->S,%) -> %
	++ map!(f,u) destructively replaces each element x of u 
        ++ by \axiom{f(x)}.
   if % has finiteAggregate then
      any?: (S->Boolean,%) -> Boolean
	++ any?(p,u) tests if \axiom{p(x)} is true for any element x of u.
	++ Note: for collections,
	++ \axiom{any?(p,u) = reduce(or,map(f,u),false,true)}.
      every?: (S->Boolean,%) -> Boolean
	++ every?(f,u) tests if p(x) is true for all elements x of u.
	++ Note: for collections,
	++ \axiom{every?(p,u) = reduce(and,map(f,u),true,false)}.
      count: (S->Boolean,%) -> NonNegativeInteger
	++ count(p,u) returns the number of elements x in u
	++ such that \axiom{p(x)} is true. For collections,
	++ \axiom{count(p,u) = reduce(+,[1 for x in u | p(x)],0)}.
      parts: % -> List S
	++ parts(u) returns a list of the consecutive elements of u.
	++ For collections, \axiom{parts([x,y,...,z]) = (x,y,...,z)}.
      members: % -> List S
	++ members(u) returns a list of the consecutive elements of u.
	++ For collections, \axiom{parts([x,y,...,z]) = (x,y,...,z)}.
      if S has SetCategory then
	count: (S,%) -> NonNegativeInteger
	  ++ count(x,u) returns the number of occurrences of x in u. For
	  ++ collections, \axiom{count(x,u) = reduce(+,[x=y for y in u],0)}.
	member?: (S,%) -> Boolean
	  ++ member?(x,u) tests if x is a member of u.
	  ++ For collections,
	  ++ \axiom{member?(x,u) = reduce(or,[x=y for y in u],false)}.
  add
   if S has Evalable S then
     eval(u:%,l:List Equation S):% == map(eval(#1,l),u)
   if % has finiteAggregate then
     #c			  == # parts c
     any?(f, c)		  == _or/[f x for x in parts c]
     every?(f, c)	  == _and/[f x for x in parts c]
     count(f:S -> Boolean, c:%) == _+/[1 for x in parts c | f x]
     members x		  == parts x
     if S has SetCategory then
       count(s:S, x:%) == count(s = #1, x)
       member?(e, c)   == any?(e = #1,c)
       x = y ==
	  size?(x, #y) and _and/[a = b for a in parts x for b in parts y]
       coerce(x:%):OutputForm ==
	 bracket
	    commaSeparate [a::OutputForm for a in parts x]$List(OutputForm)

@
<<HOAGG.dotabb>>=
"HOAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=HOAGG"];
"HOAGG" -> "AGG"

@
<<HOAGG.dotfull>>=
"HomogeneousAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=HOAGG"];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

@
<<HOAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"
"HomogeneousAggregate(a:Type)" -> "Evalable(a:Type)"
"HomogeneousAggregate(a:Type)" -> "SetCategory()"

"Evalable(a:Type)" [color="#00EE00"];

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{LiouvillianFunctionCategory}{LFCAT}
\pagepic{ps/v102liouvillianfunctioncategory.ps}{LFCAT}{0.60}

{\bf See:}\\
\pagefrom{PrimitiveFunctionCategory}{PRIMCAT}
\pagefrom{TranscendentalFunctionCategory}{TRANFUN}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{LFCAT}{?**?} &
\cross{LFCAT}{Ci} &
\cross{LFCAT}{Ei} &
\cross{LFCAT}{Si} &
\cross{LFCAT}{acos} \\
\cross{LFCAT}{acosh} &
\cross{LFCAT}{acot} &
\cross{LFCAT}{acoth} &
\cross{LFCAT}{acsc} &
\cross{LFCAT}{acsch} \\
\cross{LFCAT}{asec} &
\cross{LFCAT}{asech} &
\cross{LFCAT}{asin} &
\cross{LFCAT}{asinh} &
\cross{LFCAT}{atan} \\
\cross{LFCAT}{atanh} &
\cross{LFCAT}{cos} &
\cross{LFCAT}{cosh} &
\cross{LFCAT}{cot} &
\cross{LFCAT}{coth} \\
\cross{LFCAT}{csc} &
\cross{LFCAT}{csch} &
\cross{LFCAT}{dilog} &
\cross{LFCAT}{erf} &
\cross{LFCAT}{exp} \\
\cross{LFCAT}{integral} &
\cross{LFCAT}{integral} &
\cross{LFCAT}{li} &
\cross{LFCAT}{log} &
\cross{LFCAT}{pi} \\
\cross{LFCAT}{sec} &
\cross{LFCAT}{sech} &
\cross{LFCAT}{sin} &
\cross{LFCAT}{sinh} &
\cross{LFCAT}{tan} \\
\cross{LFCAT}{tanh} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 Ci : % -> %
 dilog : % -> %                       
 Ei : % -> %                          
 erf : % -> %
 li : % -> %                          
 Si : % -> %
\end{verbatim}

These exports come from PrimitiveFunctionCategory()
\begin{verbatim}
 integral : (%,Symbol) -> %
 integral : (%,SegmentBinding %) -> %
\end{verbatim}

These exports come from TranscendentalFunctionCategory():
\begin{verbatim}
 ?**? : (%,%) -> %                    
 acos : % -> %                        
 acosh : % -> %
 acot : % -> %                        
 acoth : % -> %
 acsc : % -> %                        
 acsch : % -> %
 asec : % -> %                        
 asech : % -> %
 asin : % -> %                        
 asinh : % -> %
 atan : % -> %                        
 atanh : % -> %
 cos : % -> %                         
 cosh : % -> %
 cot : % -> %                         
 coth : % -> %
 csc : % -> %                         
 csch : % -> %
 exp : % -> %                         
 log : % -> %
 pi : () -> %                         
 sec : % -> %
 sech : % -> %                        
 sin : % -> %
 sinh : % -> %                        
 tan : % -> %
 tanh : % -> %                        
\end{verbatim}

<<category LFCAT LiouvillianFunctionCategory>>=
)abbrev category LFCAT LiouvillianFunctionCategory
++ Category for the transcendental Liouvillian functions
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Category for the transcendental Liouvillian functions;
LiouvillianFunctionCategory(): Category ==
  Join(PrimitiveFunctionCategory, TranscendentalFunctionCategory) with
    Ei      : $  -> $
      ++ Ei(x) returns the exponential integral of x, i.e.
      ++ the integral of \spad{exp(x)/x dx}.
    Si      : $  -> $
      ++ Si(x) returns the sine integral of x, i.e.
      ++ the integral of \spad{sin(x) / x dx}.
    Ci      : $  -> $
      ++ Ci(x) returns the cosine integral of x, i.e.
      ++ the integral of \spad{cos(x) / x dx}.
    li      : $  -> $
      ++ li(x) returns the logarithmic integral of x, i.e.
      ++ the integral of \spad{dx / log(x)}.
    dilog   : $  -> $
      ++ dilog(x) returns the dilogarithm of x, i.e.
      ++ the integral of \spad{log(x) / (1 - x) dx}.
    erf     : $  -> $
      ++ erf(x) returns the error function of x, i.e.
      ++ \spad{2 / sqrt(%pi)} times the integral of \spad{exp(-x**2) dx}.

@
<<LFCAT.dotabb>>=
"LFCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LFCAT"];
"LFCAT" -> "PRIMCAT"
"LFCAT" -> "TRANFUN"

@
<<LFCAT.dotfull>>=
"LiouvillianFunctionCategory()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LFCAT"];
"LiouvillianFunctionCategory()" -> "PrimitiveFunctionCategory()"
"LiouvillianFunctionCategory()" -> "TranscendentalFunctionCategory()"

@
<<LFCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"LiouvillianFunctionCategory()" [color=lightblue];
"LiouvillianFunctionCategory()" -> "PrimitiveFunctionCategory()"
"LiouvillianFunctionCategory()" -> "TranscendentalFunctionCategory()"

"PrimitiveFunctionCategory()" [color=lightblue];
"PrimitiveFunctionCategory()" -> "Category"

"TranscendentalFunctionCategory()" [color=lightblue];
"TranscendentalFunctionCategory()" ->
    "TRIGCAT"
"TranscendentalFunctionCategory()" ->
    "ATRIG"
"TranscendentalFunctionCategory()" ->
    "HYPCAT"
"TranscendentalFunctionCategory()" ->
    "AHYP"
"TranscendentalFunctionCategory()" ->
    "ELEMFUN"

"TRIGCAT" [color=lightblue];
"TRIGCAT" -> "Category"

"ATRIG" [color=lightblue];
"ATRIG" -> "Category"

"HYPCAT" [color=lightblue];
"HYPCAT" -> "Category"

"AHYP" [color=lightblue];
"AHYP" -> "Category"

"ELEMFUN" [color=lightblue];
"ELEMFUN" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Monad}{MONAD}
\pagepic{ps/v102monad.ps}{MONAD}{0.70}

{\bf See:}\\
\pageto{MonadWithUnit}{MONADWU}
\pageto{NonAssociativeRng}{NARNG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{MONAD}{coerce} &
\cross{MONAD}{hash} &
\cross{MONAD}{latex} &
\cross{MONAD}{leftPower} &
\cross{MONAD}{rightPower} \\
\cross{MONAD}{?**?} &
\cross{MONAD}{?*?} &
\cross{MONAD}{?=?} &
\cross{MONAD}{?\~{}=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?*? : (%,%) -> %                     
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 leftPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

<<category MONAD Monad>>=
)abbrev category MONAD Monad
++ Authors: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 11 June 1991
++ Basic Operations: *, **
++ Related Constructors: SemiGroup, Monoid, MonadWithUnit
++ Also See:
++ AMS Classifications:
++ Keywords: Monad,  binary operation
++ Reference:
++  N. Jacobson: Structure and Representations of Jordan Algebras
++  AMS, Providence, 1968
++ Description:
++  Monad is the class of all multiplicative monads, i.e. sets
++  with a binary operation.
Monad(): Category == SetCategory with
      "*": (%,%) -> %
        ++ a*b is the product of \spad{a} and b in a set with
        ++ a binary operation.
      rightPower: (%,PositiveInteger) -> %
        ++ rightPower(a,n) returns the \spad{n}-th right power of \spad{a},
        ++ i.e. \spad{rightPower(a,n) := rightPower(a,n-1) * a} and
        ++ \spad{rightPower(a,1) := a}.
      leftPower: (%,PositiveInteger) -> %
        ++ leftPower(a,n) returns the \spad{n}-th left power of \spad{a},
        ++ i.e. \spad{leftPower(a,n) := a * leftPower(a,n-1)} and
        ++ \spad{leftPower(a,1) := a}.
      "**": (%,PositiveInteger) -> %
        ++ a**n returns the \spad{n}-th power of \spad{a},
        ++ defined by repeated squaring.
    add
      import RepeatedSquaring(%)
      x:% ** n:PositiveInteger == expt(x,n)
      rightPower(a,n) ==
--        one? n => a
        (n = 1) => a
        res := a
        for i in 1..(n-1) repeat res := res * a
        res
      leftPower(a,n) ==
--        one? n => a
        (n = 1) => a
        res := a
        for i in 1..(n-1) repeat res := a * res
        res

@
<<MONAD.dotabb>>=
"MONAD"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONAD"];
"MONAD" -> "SETCAT"

@
<<MONAD.dotfull>>=
"Monad()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONAD"];
"Monad()" -> "SetCategory()"
"Monad()" -> "RepeatedSquaring(Monad)"

@
<<MONAD.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Monad()" [color=lightblue];
"Monad()" -> "SetCategory()"
"Monad()" -> "RepeatedSquaring(Monad)"

"RepeatedSquaring(Monad)" [color="#00EE00"];
"RepeatedSquaring(Monad)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedSet}{ORDSET}
\pagepic{ps/v102orderedset.ps}{ORDSET}{1.00}

{\bf See:}\\
\pageto{BitAggregate}{BTAGG}
\pageto{OrderedAbelianSemiGroup}{OASGP}
\pageto{OrderedFinite}{ORDFIN}
\pageto{OrderedMonoid}{ORDMON}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ORDSET}{coerce} &
\cross{ORDSET}{hash} &
\cross{ORDSET}{latex} &
\cross{ORDSET}{max} &
\cross{ORDSET}{min} \\
\cross{ORDSET}{?$<$?} &
\cross{ORDSET}{?$<=$?} &
\cross{ORDSET}{?=?} &
\cross{ORDSET}{?$>$?} &
\cross{ORDSET}{?$>=$?} \\
\cross{ORDSET}{?\~{}=?} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?<? : (%,%) -> Boolean               
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 max : (%,%) -> %                     
 min : (%,%) -> %
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
 ?<=? : (%,%) -> Boolean
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
\end{verbatim}

<<category ORDSET OrderedSet>>=
)abbrev category ORDSET OrderedSet
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The class of totally ordered sets, that is, sets such that for each 
++ pair of elements \spad{(a,b)}
++ exactly one of the following relations holds \spad{a<b or a=b or b<a}
++ and the relation is transitive, i.e.  \spad{a<b and b<c => a<c}.
OrderedSet(): Category == SetCategory with
    "<": (%,%) -> Boolean
      ++ x < y is a strict total ordering on the elements of the set.
    ">":         (%, %) -> Boolean
      ++ x > y is a greater than test.
    ">=":        (%, %) -> Boolean
      ++ x >= y is a greater than or equal test.
    "<=":        (%, %) -> Boolean
      ++ x <= y is a less than or equal test.
    max: (%,%) -> %
      ++ max(x,y) returns the maximum of x and y relative to "<".
    min: (%,%) -> %
      ++ min(x,y) returns the minimum of x and y relative to "<".
  add
    x,y: %
  -- These really ought to become some sort of macro
    max(x,y) ==
      x > y => x
      y
    min(x,y) ==
      x > y => y
      x
    ((x: %) >  (y: %)) : Boolean == y < x
    ((x: %) >= (y: %)) : Boolean == not (x < y)
    ((x: %) <= (y: %)) : Boolean == not (y < x)

@
<<ORDSET.dotabb>>=
"ORDSET" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDSET"];
"ORDSET" -> "SETCAT"

@
<<ORDSET.dotfull>>=
"OrderedSet()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDSET"];
"OrderedSet()" -> "SetCategory()"

@
<<ORDSET.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{SemiGroup}{SGROUP}
\pagepic{ps/v102semigroup.ps}{SGROUP}{0.75}

A Semigroup is defined as a set $S$ with a binary multiplicative
operator ``*''. A Semigroup $G(S,*)$ is:
\begin{itemize}
\item a set $S$ which can be null
\item a binary multiplicative operator ``*''
\item associative. $\forall a,b,c \in S, a*(b*c) = (a*b)*c$
\end{itemize}

{\bf See:}\\
\pageto{Monoid}{MONOID}
\pageto{Rng}{RNG}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SGROUP}{coerce} &
\cross{SGROUP}{hash} &
\cross{SGROUP}{latex} &
\cross{SGROUP}{?*?} &
\cross{SGROUP}{?**?} \\
\cross{SGROUP}{?=?} &
\cross{SGROUP}{?\^{}?} &
\cross{SGROUP}{?~=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?*? : (%,%) -> %                     
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,PositiveInteger) -> %
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
\end{verbatim}

<<category SGROUP SemiGroup>>=
)abbrev category SGROUP SemiGroup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ the class of all multiplicative semigroups, i.e. a set
++ with an associative operation \spadop{*}.
++
++ Axioms:
++    \spad{associative("*":(%,%)->%)}\tab{30}\spad{ (x*y)*z = x*(y*z)}
++
++ Conditional attributes:
++    \spad{commutative("*":(%,%)->%)}\tab{30}\spad{ x*y = y*x }
SemiGroup(): Category == SetCategory with
      "*": (%,%) -> %                  ++ x*y returns the product of x and y.
      "**": (%,PositiveInteger) -> %   ++ x**n returns the repeated product
                                       ++ of x n times, i.e. exponentiation.
      "^": (%,PositiveInteger) -> %    ++ x^n returns the repeated product
                                       ++ of x n times, i.e. exponentiation.
    add
      import RepeatedSquaring(%)
      x:% ** n:PositiveInteger == expt(x,n)
      _^(x:%, n:PositiveInteger):% == x ** n

@
<<SGROUP.dotabb>>=
"SGROUP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SGROUP"];
"SGROUP" -> "SETCAT"

@
<<SGROUP.dotfull>>=
"SemiGroup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SGROUP"];
"SemiGroup()" -> "SetCategory()"
"SemiGroup()" -> "RepeatedSquaring(a:SemiGroup)"

@
<<SGROUP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SetCategory()"
"SemiGroup()" -> "RepeatedSquaring(a:SemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedSquaring(a:SemiGroup)" [color="#00EE00"];
"RepeatedSquaring(a:SemiGroup)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{StepThrough}{STEP}
\pagepic{ps/v102stepthrough.ps}{STEP}{1.00}

{\bf See:}\\
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{STEP}{coerce} &
\cross{STEP}{hash} &
\cross{STEP}{init} &
\cross{STEP}{latex} &
\cross{STEP}{?=?} \\
\cross{STEP}{?~=?} &
\cross{STEP}{nextItem} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 init : () -> %
 nextItem : % -> Union(%,"failed")
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String                  
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
\end{verbatim}

<<category STEP StepThrough>>=
)abbrev category STEP StepThrough
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A class of objects which can be 'stepped through'.
++ Repeated applications of \spadfun{nextItem} is guaranteed never to
++ return duplicate items and only return "failed" after exhausting
++ all elements of the domain.
++ This assumes that the sequence starts with \spad{init()}.
++ For infinite domains, repeated application
++ of \spadfun{nextItem} is not required to reach all possible domain elements
++ starting from any initial element.
++
++ Conditional attributes:
++   infinite\tab{15}repeated \spad{nextItem}'s are never "failed".
StepThrough(): Category == SetCategory with
      init: constant -> %
        ++ init() chooses an initial object for stepping.
      nextItem: % -> Union(%,"failed")
        ++ nextItem(x) returns the next item, or "failed" 
        ++ if domain is exhausted.

@
<<STEP.dotabb>>=
"STEP" [color=lightblue,href="bookvol10.2.pdf#nameddest=STEP"];
"STEP" -> "SETCAT"

@
<<STEP.dotfull>>=
"StepThrough()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=STEP"];
"StepThrough()" -> "SetCategory()"

@
<<STEP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"StepThrough()" [color=lightblue];
"StepThrough()" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
\chapter{Category Layer 4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{AbelianMonoid}{ABELMON}
\pagepic{ps/v102abelianmonoid.ps}{ABELMON}{0.75}

{\bf See:}\\
\pageto{CancellationAbelianMonoid}{CABMON}
\pageto{OrderedAbelianMonoid}{OAMON}
\pageto{OrderedAbelianSemiGroup}{OASGP}
\pagefrom{AbelianSemiGroup}{ABELSG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ABELMON}{0} &
\cross{ABELMON}{coerce} &
\cross{ABELMON}{hash} &
\cross{ABELMON}{latex} &
\cross{ABELMON}{sample} \\
\cross{ABELMON}{zero?} &
\cross{ABELMON}{?*?} &
\cross{ABELMON}{?+?} &
\cross{ABELMON}{?=?} &
\cross{ABELMON}{?\~{}=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 0 : () -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 sample : () -> %
 zero? : % -> Boolean                 
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
\end{verbatim}

These exports come from AbelianSemiGroup():
\begin{verbatim}
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
 ?+? : (%,%) -> %
\end{verbatim}

<<category ABELMON AbelianMonoid>>=
)abbrev category ABELMON AbelianMonoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The class of multiplicative monoids, i.e. semigroups with an
++ additive identity element.
++
++ Axioms:
++   \spad{leftIdentity("+":(%,%)->%,0)}\tab{30}\spad{ 0+x=x }
++   \spad{rightIdentity("+":(%,%)->%,0)}\tab{30}\spad{ x+0=x }
-- following domain must be compiled with subsumption disabled
-- define SourceLevelSubset to be EQUAL
AbelianMonoid(): Category == AbelianSemiGroup with
      0: constant -> % 
	++ 0 is the additive identity element.
      sample: constant -> %
	++ sample yields a value of type %
      zero?: % -> Boolean
	++ zero?(x) tests if x is equal to 0.
      "*": (NonNegativeInteger,%) -> %
        ++ n * x is left-multiplication by a non negative integer
    add
      import RepeatedDoubling(%)
      zero? x == x = 0
      n:PositiveInteger * x:% == (n::NonNegativeInteger) * x
      sample() == 0
      if not (% has Ring) then
        n:NonNegativeInteger * x:% ==
          zero? n => 0
          double(n pretend PositiveInteger,x)

@
<<ABELMON.dotabb>>=
"ABELMON"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELMON"];
"ABELMON" -> "ABELSG"

@
<<ABELMON.dotfull>>=
"AbelianMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELMON"];
"AbelianMonoid()" -> "AbelianSemiGroup()"

@
<<ABELMON.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SetCategory()"
"AbelianSemiGroup()" -> "RepeatedDoubling(AbelianSemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" ->
    "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedDoubling(AbelianSemiGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianSemiGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{BagAggregate}{BGAGG}
\pagepic{ps/v102bagaggregate.ps}{BGAGG}{1.00}

{\bf See:}\\
\pageto{DictionaryOperations}{DIOPS}
\pageto{PriorityQueueAggregate}{PRQAGG}
\pageto{QueueAggregate}{QUAGG}
\pageto{StackAggregate}{SKAGG}
\pagefrom{HomogeneousAggregate}{HOAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{BGAGG}{any?} &
\cross{BGAGG}{bag} &
\cross{BGAGG}{coerce} &
\cross{BGAGG}{copy} &
\cross{BGAGG}{count} \\
\cross{BGAGG}{empty} &
\cross{BGAGG}{empty?} &
\cross{BGAGG}{eq?} &
\cross{BGAGG}{eval} &
\cross{BGAGG}{every?} \\
\cross{BGAGG}{extract!} &
\cross{BGAGG}{hash} &
\cross{BGAGG}{insert!} &
\cross{BGAGG}{inspect} &
\cross{BGAGG}{latex} \\
\cross{BGAGG}{less?} &
\cross{BGAGG}{map} &
\cross{BGAGG}{map!} &
\cross{BGAGG}{member?} &
\cross{BGAGG}{members} \\
\cross{BGAGG}{more?} &
\cross{BGAGG}{parts} &
\cross{BGAGG}{sample} &
\cross{BGAGG}{size?} &
\cross{BGAGG}{\#?} \\
\cross{BGAGG}{?=?} &
\cross{BGAGG}{?\~{}=?} &&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{BGAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 extract! : % -> S
 insert! : (S,%) -> %
 inspect : % -> S
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 bag : List S -> %
\end{verbatim}

These exports come from HomogeneousAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 members : % -> List S if $ has finiteAggregate
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
 \#? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category BGAGG BagAggregate>>=
)abbrev category BGAGG BagAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A bag aggregate is an aggregate for which one can insert and extract 
++ objects, and where the order in which objects are inserted determines 
++ the order of extraction.
++ Examples of bags are stacks, queues, and dequeues.
BagAggregate(S:Type): Category == HomogeneousAggregate S with
   shallowlyMutable
     ++ shallowlyMutable means that elements of bags may be 
     ++ destructively changed.
   bag: List S -> %
     ++ bag([x,y,...,z]) creates a bag with elements x,y,...,z.
   extract_!: % -> S
     ++ extract!(u) destructively removes a (random) item from bag u.
   insert_!: (S,%) -> %
     ++ insert!(x,u) inserts item x into bag u.
   inspect: % -> S
     ++ inspect(u) returns an (random) element from a bag.
 add
   bag(l) ==
     x:=empty()
     for s in l repeat x:=insert_!(s,x)
     x

@
<<BGAGG.dotabb>>=
"BGAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=BGAGG"];
"BGAGG" -> "HOAGG"

@
<<BGAGG.dotfull>>=
"BagAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BGAGG"];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"BagAggregate(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=BGAGG"];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

@
<<BGAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Collection}{CLAGG}
\pagepic{ps/v102collection.ps}{CLAGG}{1.00}

{\bf See:}\\
\pageto{DictionaryOperations}{DIOPS}
\pageto{LinearAggregate}{LNAGG}
\pageto{SetAggregate}{SETAGG}
\pagefrom{ConvertibleTo}{KONVERT}
\pagefrom{HomogeneousAggregate}{HOAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{CLAGG}{any?} &
\cross{CLAGG}{coerce} &
\cross{CLAGG}{construct} &
\cross{CLAGG}{copy} &
\cross{CLAGG}{convert} \\
\cross{CLAGG}{count} &
\cross{CLAGG}{empty} &
\cross{CLAGG}{empty?} &
\cross{CLAGG}{eq?} &
\cross{CLAGG}{eval} \\
\cross{CLAGG}{every?} &
\cross{CLAGG}{find} &
\cross{CLAGG}{hash} &
\cross{CLAGG}{latex} &
\cross{CLAGG}{less?} \\
\cross{CLAGG}{map} &
\cross{CLAGG}{map!} &
\cross{CLAGG}{member?} &
\cross{CLAGG}{members} &
\cross{CLAGG}{more?} \\
\cross{CLAGG}{parts} &
\cross{CLAGG}{reduce} &
\cross{CLAGG}{remove} &
\cross{CLAGG}{removeDuplicates} &
\cross{CLAGG}{sample} \\
\cross{CLAGG}{select} &
\cross{CLAGG}{size?} &
\cross{CLAGG}{\#?} &
\cross{CLAGG}{?=?} &
\cross{CLAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{CLAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 construct: List S -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 find : ((S -> Boolean),%) -> Union(S,"failed")
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT and $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S if $ has finiteAggregate
 remove : (S,%) -> % if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
 #? : % -> NonNegativeInteger if $ has finiteAggregate
\end{verbatim}

These exports come from HomogeneousAggregate(S:Type):
\begin{verbatim}
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
             if S has SETCAT and $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                     
 size? : (%,NonNegativeInteger) -> Boolean
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from ConvertibleTo(S:Type):
\begin{verbatim}
 convert : % -> InputForm if S has KONVERT INFORM
\end{verbatim}

<<category CLAGG Collection>>=
)abbrev category CLAGG Collection
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A collection is a homogeneous aggregate which can built from
++ list of members. The operation used to build the aggregate is
++ generically named \spadfun{construct}. However, each collection
++ provides its own special function with the same name as the
++ data type, except with an initial lower case letter, e.g.
++ \spadfun{list} for \spadtype{List},
++ \spadfun{flexibleArray} for \spadtype{FlexibleArray}, and so on.
Collection(S:Type): Category == HomogeneousAggregate(S) with
   construct: List S -> %
     ++ \axiom{construct(x,y,...,z)} returns the collection of elements 
     ++ \axiom{x,y,...,z} ordered as given. Equivalently written as 
     ++ \axiom{[x,y,...,z]$D}, where
     ++ D is the domain. D may be omitted for those of type List.
   find: (S->Boolean, %) -> Union(S, "failed")
     ++ find(p,u) returns the first x in u such that \axiom{p(x)} is true, 
     ++ and "failed" otherwise.
   if % has finiteAggregate then
      reduce: ((S,S)->S,%) -> S
	++ reduce(f,u) reduces the binary operation f across u. For example,
	++ if u is \axiom{[x,y,...,z]} then \axiom{reduce(f,u)} 
        ++ returns \axiom{f(..f(f(x,y),...),z)}.
	++ Note: if u has one element x, \axiom{reduce(f,u)} returns x.
	++ Error: if u is empty.
        ++
        ++C )clear all
        ++X reduce(+,[C[i]*x**i for i in 1..5])

      reduce: ((S,S)->S,%,S) -> S
	++ reduce(f,u,x) reduces the binary operation f across u, where x is
	++ the identity operation of f.
	++ Same as \axiom{reduce(f,u)} if u has 2 or more elements.
	++ Returns \axiom{f(x,y)} if u has one element y,
	++ x if u is empty.
	++ For example, \axiom{reduce(+,u,0)} returns the
	++ sum of the elements of u.
      remove: (S->Boolean,%) -> %
	++ remove(p,u) returns a copy of u removing all elements x such that
	++ \axiom{p(x)} is true.
	++ Note: \axiom{remove(p,u) == [x for x in u | not p(x)]}.
      select: (S->Boolean,%) -> %
	++ select(p,u) returns a copy of u containing only those elements 
	++ such \axiom{p(x)} is true.
	++ Note: \axiom{select(p,u) == [x for x in u | p(x)]}.
      if S has SetCategory then
	reduce: ((S,S)->S,%,S,S) -> S
	  ++ reduce(f,u,x,z) reduces the binary operation f across u, 
	  ++ stopping when an "absorbing element" z is encountered.
	  ++ As for \axiom{reduce(f,u,x)}, x is the identity operation of f.
	  ++ Same as \axiom{reduce(f,u,x)} when u contains no element z.
	  ++ Thus the third argument x is returned when u is empty.
	remove: (S,%) -> %
	  ++ remove(x,u) returns a copy of u with all
	  ++ elements \axiom{y = x} removed.
	  ++ Note: \axiom{remove(y,c) == [x for x in c | x ^= y]}.
	removeDuplicates: % -> %
	  ++ removeDuplicates(u) returns a copy of u with all duplicates 
          ++ removed.
   if S has ConvertibleTo InputForm then ConvertibleTo InputForm
 add
   if % has finiteAggregate then
     #c			  == # parts c
     count(f:S -> Boolean, c:%) == _+/[1 for x in parts c | f x]
     any?(f, c)		  == _or/[f x for x in parts c]
     every?(f, c)	  == _and/[f x for x in parts c]
     find(f:S -> Boolean, c:%) == find(f, parts c)
     reduce(f:(S,S)->S, x:%) == reduce(f, parts x)
     reduce(f:(S,S)->S, x:%, s:S) == reduce(f, parts x, s)
     remove(f:S->Boolean, x:%) ==
       construct remove(f, parts x)
     select(f:S->Boolean, x:%) ==
       construct select(f, parts x)

     if S has SetCategory then
       remove(s:S, x:%) == remove(#1 = s, x)
       reduce(f:(S,S)->S, x:%, s1:S, s2:S) == reduce(f, parts x, s1, s2)
       removeDuplicates(x) == construct removeDuplicates parts x

@
<<CLAGG.dotabb>>=
"CLAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=CLAGG"];
"CLAGG" -> "HOAGG"

@
<<CLAGG.dotfull>>=
"Collection(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CLAGG"];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"Collection(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=CLAGG"];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

@
<<CLAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"
"Collection(a:Type)" -> "ConvertibleTo(InputForm)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"ConvertibleTo(InputForm)" [color="#00EE00"];
"ConvertibleTo(InputForm)" -> "ConvertibleTo(a:Type)"

"ConvertibleTo(a:Type)" [color="#00EE00"];
"ConvertibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{GradedAlgebra}{GRALG}
\pagepic{ps/v102gradedalgebra.ps}{GRALG}{0.75}

{\bf See:}\\
\pagefrom{GradedModule}{GRMOD}
\pagefrom{RetractableTo}{RETRACT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{GRALG}{0} &
\cross{GRALG}{1} &
\cross{GRALG}{coerce} &
\cross{GRALG}{degree} &
\cross{GRALG}{hash} \\
\cross{GRALG}{latex} &
\cross{GRALG}{product} &
\cross{GRALG}{retract} &
\cross{GRALG}{retractIfCan} &
\cross{GRALG}{?\~{}=?} \\
\cross{GRALG}{?*?} &
\cross{GRALG}{?+?} &
\cross{GRALG}{?-?} &
\cross{GRALG}{-?} &
\cross{GRALG}{?=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 product : (%,%) -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 ?*? : (%,R) -> %                     
 ?*? : (R,%) -> %
\end{verbatim}

These exports come from GradedModule(R, E)\\
where R:CommutativeRing and E:AbelianMonoid:
\begin{verbatim}
 coerce : % -> OutputForm
 degree : % -> E                      
 hash : % -> SingleInteger
 latex : % -> String                  
 ?~=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?+? : (%,%) -> %                     
\end{verbatim}

These exports come from ,RetractableTo(R:CommutativeRing):
\begin{verbatim}
 coerce : R -> %                      
 retract : % -> R                     
 retractIfCan : % -> Union(R,"failed")
\end{verbatim}

<<category GRALG GradedAlgebra>>=
)abbrev category GRALG GradedAlgebra
++ Author: Stephen M. Watt
++ Date Created: May 20, 1991
++ Date Last Updated: May 20, 1991
++ Basic Operations: +, *, degree
++ Related Domains: CartesianTensor(n,dim,R)
++ Also See:
++ AMS Classifications:
++ Keywords: graded module, tensor, multi-linear algebra
++ Examples:
++ References: Encyclopedic Dictionary of Mathematics, MIT Press, 1977
++ Description:
++  GradedAlgebra(R,E) denotes ``E-graded R-algebra''.
++  A graded algebra is a graded module together with a degree preserving
++  R-linear map, called the {\em product}.
++
++  The name ``product'' is written out in full so inner and outer products
++  with the same mapping type can be distinguished by name.

GradedAlgebra(R: CommutativeRing, E: AbelianMonoid): Category ==
    Join(GradedModule(R, E),RetractableTo(R)) with
        1: constant -> %
            ++ 1 is the identity for \spad{product}.
        product: (%, %) -> %
            ++ product(a,b) is the degree-preserving R-linear product:
            ++
            ++   \spad{degree product(a,b) = degree a + degree b}
            ++   \spad{product(a1+a2,b) = product(a1,b) + product(a2,b)}
            ++   \spad{product(a,b1+b2) = product(a,b1) + product(a,b2)}
            ++   \spad{product(r*a,b) = product(a,r*b) = r*product(a,b)}
            ++   \spad{product(a,product(b,c)) = product(product(a,b),c)}
  add
        if not (R is %) then
            0: % == (0$R)::%
            1: % == 1$R::%
            (r: R)*(x: %) == product(r::%, x)
            (x: %)*(r: R) == product(x, r::%)

@
<<GRALG.dotabb>>=
"GRALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GRALG"];
"GRALG" -> "GRMOD"
"GRALG" -> "RETRACT"

@
<<GRALG.dotfull>>=
"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GRALG"];
"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)" ->
    "GradedModule(a:CommutativeRing,b:AbelianMonoid)"
"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)" ->
    "RetractableTo(CommutativeRing)"
@
<<GRALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)" [color=lightblue];
"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)" ->
    "GradedModule(a:CommutativeRing,b:AbelianMonoid)"
"GradedAlgebra(a:CommutativeRing,b:AbelianMonoid)" ->
    "RetractableTo(CommutativeRing)"

"RetractableTo(CommutativeRing)" [color=seagreen];
"RetractableTo(CommutativeRing)" -> "RetractableTo(a:Type)"

"RetractableTo(a:Type)" [color=lightblue];
"RetractableTo(a:Type)" -> "Category"

"GradedModule(a:CommutativeRing,b:AbelianMonoid)" [color=lightblue];
"GradedModule(a:CommutativeRing,b:AbelianMonoid)" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{IndexedAggregate}{IXAGG}
\pagepic{ps/v102indexedaggregate.ps}{IXAGG}{1.00}

{\bf See:}\\
\pageto{LinearAggregate}{LNAGG}
\pageto{TableAggregate}{TBAGG}
\pagefrom{EltableAggregate}{ELTAGG}
\pagefrom{HomogeneousAggregate}{HOAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{IXAGG}{any?} &
\cross{IXAGG}{coerce} &
\cross{IXAGG}{copy} &
\cross{IXAGG}{count} &
\cross{IXAGG}{elt} \\
\cross{IXAGG}{empty} &
\cross{IXAGG}{empty?} &
\cross{IXAGG}{entries} &
\cross{IXAGG}{entry?} &
\cross{IXAGG}{eq?} \\
\cross{IXAGG}{eval} &
\cross{IXAGG}{every?} &
\cross{IXAGG}{fill!} &
\cross{IXAGG}{first} &
\cross{IXAGG}{hash} \\
\cross{IXAGG}{index?} &
\cross{IXAGG}{indices} &
\cross{IXAGG}{latex} &
\cross{IXAGG}{less?} &
\cross{IXAGG}{map} \\
\cross{IXAGG}{map!} &
\cross{IXAGG}{maxIndex} &
\cross{IXAGG}{member?} &
\cross{IXAGG}{members} &
\cross{IXAGG}{minIndex} \\
\cross{IXAGG}{more?} &
\cross{IXAGG}{parts} &
\cross{IXAGG}{qelt} &
\cross{IXAGG}{qsetelt!} &
\cross{IXAGG}{sample} \\
\cross{IXAGG}{setelt} &
\cross{IXAGG}{size?} &
\cross{IXAGG}{swap!} &
\cross{IXAGG}{?.?} &
\cross{IXAGG}{?\~{}=?} \\
\cross{IXAGG}{\#?} &
\cross{IXAGG}{?=?} &&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{IXAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{IXAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 index? : (Index,%) -> Boolean
 indices : % -> List Index
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 elt : (%,Index,Entry) -> Entry
 entries : % -> List Entry
 entry? : (Entry,%) -> Boolean 
            if $ has finiteAggregate and Entry has SETCAT
 fill! : (%,Entry) -> % if $ has shallowlyMutable
 first : % -> Entry if Index has ORDSET
 map : ((Entry -> Entry),%) -> %
 map! : ((Entry -> Entry),%) -> % if $ has shallowlyMutable
 maxIndex : % -> Index if Index has ORDSET
 minIndex : % -> Index if Index has ORDSET
 swap! : (%,Index,Index) -> Void if $ has shallowlyMutable
\end{verbatim}

These exports come from HomogeneousAggregate(Entry:Type):
\begin{verbatim}
 any? : ((Entry -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if Entry has SETCAT
 copy : % -> %
 count : (Entry,%) -> NonNegativeInteger 
          if Entry has SETCAT and $ has finiteAggregate
 count : ((Entry -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List Entry,List Entry) -> % 
       if Entry has EVALAB Entry and Entry has SETCAT
 eval : (%,Entry,Entry) -> % 
       if Entry has EVALAB Entry and Entry has SETCAT
 eval : (%,Equation Entry) -> % 
       if Entry has EVALAB Entry and Entry has SETCAT
 eval : (%,List Equation Entry) -> % 
       if Entry has EVALAB Entry and Entry has SETCAT
 every? : ((Entry -> Boolean),%) -> Boolean 
       if $ has finiteAggregate
 hash : % -> SingleInteger if Entry has SETCAT
 latex : % -> String if Entry has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 member? : (Entry,%) -> Boolean 
           if Entry has SETCAT and $ has finiteAggregate
 members : % -> List Entry if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List Entry if $ has finiteAggregate
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
 ?~=? : (%,%) -> Boolean if Entry has SETCAT
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if Entry has SETCAT
\end{verbatim}

These exports come from EltableAggregate(Index:SetCategory,Entry:Type):
\begin{verbatim}
 qelt : (%,Index) -> Entry
 qsetelt! : (%,Index,Entry) -> Entry if $ has shallowlyMutable
 setelt : (%,Index,Entry) -> Entry if $ has shallowlyMutable
 ?.? : (%,Index) -> Entry
\end{verbatim}

<<category IXAGG IndexedAggregate>>=
)abbrev category IXAGG IndexedAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An indexed aggregate is a many-to-one mapping of indices to entries.
++ For example, a one-dimensional-array is an indexed aggregate where
++ the index is an integer.  Also, a table is an indexed aggregate
++ where the indices and entries may have any type.
IndexedAggregate(Index: SetCategory, Entry: Type): Category ==
  Join(HomogeneousAggregate(Entry), EltableAggregate(Index, Entry)) with
   entries: % -> List Entry
      ++ entries(u) returns a list of all the entries of aggregate u
      ++ in no assumed order.
      -- to become entries: % -> Entry* and 
      -- entries: % -> Iterator(Entry,Entry)
   index?: (Index,%) -> Boolean
      ++ index?(i,u) tests if i is an index of aggregate u.
   indices: % -> List Index
      ++ indices(u) returns a list of indices of aggregate u in no
      ++ particular order. to become indices:
      --  % -> Index* and indices: % -> Iterator(Index,Index).
-- map: ((Entry,Entry)->Entry,%,%,Entry) -> %
--    ++ exists c = map(f,a,b,x), i:Index where
--    ++    c.i = f(a(i,x),b(i,x)) | index?(i,a) or index?(i,b)
   if Entry has SetCategory and % has finiteAggregate then
      entry?: (Entry,%) -> Boolean
	++ entry?(x,u) tests if x equals \axiom{u . i} for some index i.
   if Index has OrderedSet then
      maxIndex: % -> Index
	++ maxIndex(u) returns the maximum index i of aggregate u.
	++ Note: in general,
	++ \axiom{maxIndex(u) = reduce(max,[i for i in indices u])};
	++ if u is a list, \axiom{maxIndex(u) = #u}.
      minIndex: % -> Index
	++ minIndex(u) returns the minimum index i of aggregate u.
	++ Note: in general,
	++ \axiom{minIndex(a) = reduce(min,[i for i in indices a])};
	++ for lists, \axiom{minIndex(a) = 1}.
      first   : % -> Entry
	++ first(u) returns the first element x of u.
	++ Note: for collections, \axiom{first([x,y,...,z]) = x}.
	++ Error: if u is empty.

   if % has shallowlyMutable then
      fill_!: (%,Entry) -> %
	++ fill!(u,x) replaces each entry in aggregate u by x.
	++ The modified u is returned as value.
      swap_!: (%,Index,Index) -> Void
	++ swap!(u,i,j) interchanges elements i and j of aggregate u.
	++ No meaningful value is returned.
 add
  elt(a, i, x) == (index?(i, a) => qelt(a, i); x)

  if % has finiteAggregate then
    entries x == parts x
    if Entry has SetCategory then
      entry?(x, a) == member?(x, a)

  if Index has OrderedSet then
    maxIndex a == "max"/indices(a)
    minIndex a == "min"/indices(a)
    first a    == a minIndex a

  if % has shallowlyMutable then
    map(f, a) == map_!(f, copy a)

    map_!(f, a) ==
      for i in indices a repeat qsetelt_!(a, i, f qelt(a, i))
      a

    fill_!(a, x) ==
      for i in indices a repeat qsetelt_!(a, i, x)
      a

    swap_!(a, i, j) ==
      t := a.i
      qsetelt_!(a, i, a.j)
      qsetelt_!(a, j, t)
      void

@
<<IXAGG.dotabb>>=
"IXAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=IXAGG"];
"IXAGG" -> "HOAGG"
"IXAGG" -> "ELTAGG"

@
<<IXAGG.dotfull>>=
"IndexedAggregate(a:SetCategory,b:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=IXAGG"];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "EltableAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=IXAGG"];
"IndexedAggregate(a:SetCategory,b:SetCategory)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(b:Integer,a:Type)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=IXAGG"];
"IndexedAggregate(b:Integer,a:Type)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

@
<<IXAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "EltableAggregate(a:SetCategory,b:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"EltableAggregate(a:SetCategory,b:Type)" [color=lightblue];
"EltableAggregate(a:SetCategory,b:Type)" -> "Eltable(a:SetCategory,b:Type)"

"Eltable(a:SetCategory,b:Type)" [color=lightblue];
"Eltable(a:SetCategory,b:Type)" -> "Category"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{MonadWithUnit}{MONADWU}
\pagepic{ps/v102monadwithunit.ps}{MONADWU}{0.75}

{\bf See:}\\
\pageto{NonAssociativeRing}{NASRING}
\pagefrom{Monad}{MONAD}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{MONADWU}{1} &
\cross{MONADWU}{coerce} &
\cross{MONADWU}{hash} &
\cross{MONADWU}{latex} &
\cross{MONADWU}{one?} \\
\cross{MONADWU}{recip} &
\cross{MONADWU}{leftPower} &
\cross{MONADWU}{leftRecip} &
\cross{MONADWU}{rightPower} &
\cross{MONADWU}{rightRecip} \\
\cross{MONADWU}{?*?} &
\cross{MONADWU}{?\~{}=?} &
\cross{MONADWU}{?**?} &
\cross{MONADWU}{?=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 1 : () -> %
 leftRecip : % -> Union(%,"failed")
 recip : % -> Union(%,"failed")       
 rightRecip : % -> Union(%,"failed")
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 leftPower : (%,NonNegativeInteger) -> %
 one? : % -> Boolean
 rightPower : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
\end{verbatim}

These exports come from Monad():
\begin{verbatim}
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 leftPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?*? : (%,%) -> %                     
 ?~=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
\end{verbatim}

<<category MONADWU MonadWithUnit>>=
)abbrev category MONADWU MonadWithUnit
++ Authors: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 11 June 1991
++ Basic Operations: *, **, 1
++ Related Constructors: SemiGroup, Monoid, Monad
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Keywords: Monad with unit, binary operation
++ Reference:
++  N. Jacobson: Structure and Representations of Jordan Algebras
++  AMS, Providence, 1968
++ Description:
++  MonadWithUnit is the class of multiplicative monads with unit,
++  i.e. sets with a binary operation and a unit element.
++ Axioms
++    leftIdentity("*":(%,%)->%,1)   \tab{30} 1*x=x
++    rightIdentity("*":(%,%)->%,1)  \tab{30} x*1=x
++ Common Additional Axioms
++    unitsKnown---if "recip" says "failed", that PROVES input wasn't a unit
MonadWithUnit(): Category == Monad with
      1: constant ->  %
        ++ 1 returns the unit element, denoted by 1.
      one?: % -> Boolean
        ++ one?(a) tests whether \spad{a} is the unit 1.
      rightPower: (%,NonNegativeInteger) -> %
        ++ rightPower(a,n) returns the \spad{n}-th right power of \spad{a},
        ++ i.e. \spad{rightPower(a,n) := rightPower(a,n-1) * a} and
        ++ \spad{rightPower(a,0) := 1}.
      leftPower: (%,NonNegativeInteger) -> %
        ++ leftPower(a,n) returns the \spad{n}-th left power of \spad{a},
        ++ i.e. \spad{leftPower(a,n) := a * leftPower(a,n-1)} and
        ++ \spad{leftPower(a,0) := 1}.
      "**": (%,NonNegativeInteger) -> %
        ++ \spad{a**n} returns the \spad{n}-th power of \spad{a},
        ++ defined by repeated squaring.
      recip: % -> Union(%,"failed")
        ++ recip(a) returns an element, which is both a left and a right
        ++ inverse of \spad{a},
        ++ or \spad{"failed"} if such an element doesn't exist or cannot
        ++ be determined (see unitsKnown).
      leftRecip: % -> Union(%,"failed")
        ++ leftRecip(a) returns an element, which is a left inverse of 
        ++ \spad{a}, or \spad{"failed"} if such an element doesn't exist 
        ++ or cannot be determined (see unitsKnown).
      rightRecip: % -> Union(%,"failed")
        ++ rightRecip(a) returns an element, which is a right inverse of
        ++ \spad{a}, or \spad{"failed"} if such an element doesn't exist
        ++ or cannot be determined (see unitsKnown).
    add
      import RepeatedSquaring(%)
      one? x == x = 1
      x:% ** n:NonNegativeInteger ==
         zero? n => 1
         expt(x,n pretend PositiveInteger)
      rightPower(a,n) ==
        zero? n => 1
        res := 1
        for i in 1..n repeat res := res * a
        res
      leftPower(a,n) ==
        zero? n => 1
        res := 1
        for i in 1..n repeat res := a * res
        res

@
<<MONADWU.dotabb>>=
"MONADWU"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONADWU"];
"MONADWU" -> "MONAD"

@
<<MONADWU.dotfull>>=
"MonadWithUnit()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONADWU"];
"MonadWithUnit()" -> "Monad()"

@
<<MONADWU.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"MonadWithUnit()" [color=lightblue];
"MonadWithUnit()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SetCategory()"
"Monad()" -> "RepeatedSquaring(Monad)"

"RepeatedSquaring(Monad)" [color="#00EE00"];
"RepeatedSquaring(Monad)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Monoid}{MONOID}
\pagepic{ps/v102monoid.ps}{MONOID}{0.75}

{\bf See:}\\
\pageto{Group}{GROUP}
\pageto{OrderedMonoid}{ORDMON}
\pageto{OrderedRing}{ORDRING}
\pageto{Ring}{RING}
\pagefrom{SemiGroup}{SGROUP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{MONOID}{1} &
\cross{MONOID}{coerce} &
\cross{MONOID}{hash} &
\cross{MONOID}{latex} &
\cross{MONOID}{one?} \\
\cross{MONOID}{recip} &
\cross{MONOID}{sample} &
\cross{MONOID}{?*?} &
\cross{MONOID}{?=?} &
\cross{MONOID}{?\~{}=?} \\
\cross{MONOID}{?**?} &
\cross{MONOID}{?\^{}?} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 1 : () -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")
 sample : () -> %                     
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
\end{verbatim}

These exports come from SemiGroup():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 ?*? : (%,%) -> %                     
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
\end{verbatim}

<<category MONOID Monoid>>=
)abbrev category MONOID Monoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The class of multiplicative monoids, i.e. semigroups with a
++ multiplicative identity element.
++
++ Axioms:
++    \spad{leftIdentity("*":(%,%)->%,1)}\tab{30}\spad{1*x=x}
++    \spad{rightIdentity("*":(%,%)->%,1)}\tab{30}\spad{x*1=x}
++
++ Conditional attributes:
++    unitsKnown\tab{15}\spadfun{recip} only returns "failed" on non-units
Monoid(): Category == SemiGroup with
      1: constant ->  %
        ++ 1 is the multiplicative identity.
      sample: constant -> %
        ++ sample yields a value of type %
      one?: % -> Boolean
        ++ one?(x) tests if x is equal to 1.
      "**": (%,NonNegativeInteger) -> %
        ++ x**n returns the repeated product
        ++ of x n times, i.e. exponentiation.
      "^" : (%,NonNegativeInteger) -> %   
        ++ x^n returns the repeated product
        ++ of x n times, i.e. exponentiation.
      recip: % -> Union(%,"failed")
        ++ recip(x) tries to compute the multiplicative inverse for x
        ++ or "failed" if it cannot find the inverse (see unitsKnown).
    add
      import RepeatedSquaring(%)
      _^(x:%, n:NonNegativeInteger):% == x ** n
      one? x == x = 1
      sample() == 1
      recip x ==
        (x = 1) => x
        "failed"
      x:% ** n:NonNegativeInteger ==
         zero? n => 1
         expt(x,n pretend PositiveInteger)

@
<<MONOID.dotabb>>=
"MONOID"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONOID"];
"MONOID" -> "SGROUP"

@
<<MONOID.dotfull>>=
"Monoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONOID"];
"Monoid()" -> "SemiGroup()"

@
<<MONOID.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SetCategory()"
"SemiGroup()" -> "RepeatedSquaring(a:SemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedSquaring(a:SemiGroup)" [color="#00EE00"];
"RepeatedSquaring(a:SemiGroup)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedFinite}{ORDFIN}
\pagepic{ps/v102orderedfinite.ps}{ORDFIN}{1.00}

{\bf See:}\\
\pagefrom{Finite}{FINITE}
\pagefrom{OrderedSet}{ORDSET}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ORDFIN}{coerce} &
\cross{ORDFIN}{hash} &
\cross{ORDFIN}{index} &
\cross{ORDFIN}{latex} &
\cross{ORDFIN}{lookup} \\
\cross{ORDFIN}{max} &
\cross{ORDFIN}{min} &
\cross{ORDFIN}{random} &
\cross{ORDFIN}{size} &
\cross{ORDFIN}{?\~{}=?} \\
\cross{ORDFIN}{?$<$?} &
\cross{ORDFIN}{?$<=$?} &
\cross{ORDFIN}{?=?} &
\cross{ORDFIN}{?$>$?} &
\cross{ORDFIN}{?$>=$?} \\
\end{tabular}

These exports come from OrderedSet():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String                  
 max : (%,%) -> %                     
 min : (%,%) -> %
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean              
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
\end{verbatim}

These exports come from Finite():
\begin{verbatim}
 index : PositiveInteger -> %
 lookup : % -> PositiveInteger
 random : () -> %                     
 size : () -> NonNegativeInteger
\end{verbatim}

<<category ORDFIN OrderedFinite>>=
)abbrev category ORDFIN OrderedFinite
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered finite sets.

OrderedFinite(): Category == Join(OrderedSet, Finite)

@
<<ORDFIN.dotabb>>=
"ORDFIN"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDFIN"];
"ORDFIN" -> "ORDSET"
"ORDFIN" -> "FINITE"

@
<<ORDFIN.dotfull>>=
"OrderedFinite()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDFIN"];
"OrderedFinite()" -> "OrderedSet()"
"OrderedFinite()" -> "Finite()"

@
<<ORDFIN.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedFinite()" [color=lightblue];
"OrderedFinite()" -> "OrderedSet()"
"OrderedFinite()" -> "Finite()"

"Finite()" [color=lightblue];
"Finite()" -> "SetCategory()"

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Category" [color=lightblue];

}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{RecursiveAggregate}{RCAGG}
\pagepic{ps/v102recursiveaggregate.ps}{RCAGG}{1.00}

{\bf See:}\\
\pageto{BinaryRecursiveAggregate}{BRAGG}
\pageto{DoublyLinkedAggregate}{DLAGG}
\pageto{UnaryRecursiveAggregate}{URAGG}
\pagefrom{HomogeneousAggregate}{HOAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{RCAGG}{any?} &
\cross{RCAGG}{child?} &
\cross{RCAGG}{children} &
\cross{RCAGG}{coerce} &
\cross{RCAGG}{copy} \\
\cross{RCAGG}{count} &
\cross{RCAGG}{cyclic?} &
\cross{RCAGG}{distance} &
\cross{RCAGG}{empty} &
\cross{RCAGG}{empty?} \\
\cross{RCAGG}{eq?} &
\cross{RCAGG}{eval} &
\cross{RCAGG}{every?} &
\cross{RCAGG}{hash} &
\cross{RCAGG}{latex} \\
\cross{RCAGG}{leaf?} &
\cross{RCAGG}{leaves} &
\cross{RCAGG}{less?} &
\cross{RCAGG}{map} &
\cross{RCAGG}{map!} \\
\cross{RCAGG}{member?} &
\cross{RCAGG}{members} &
\cross{RCAGG}{more?} &
\cross{RCAGG}{nodes} &
\cross{RCAGG}{node?} \\
\cross{RCAGG}{parts} &
\cross{RCAGG}{sample} &
\cross{RCAGG}{setchildren!} &
\cross{RCAGG}{setelt} &
\cross{RCAGG}{setvalue!} \\
\cross{RCAGG}{size?} &
\cross{RCAGG}{value} &
\cross{RCAGG}{?.value} &
\cross{RCAGG}{?\~{}=?} &
\cross{RCAGG}{\#?} \\
\cross{RCAGG}{?=?} &&&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{RCAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 children : % -> List %
 cyclic? : % -> Boolean
 distance : (%,%) -> Integer
 nodes : % -> List %
 leaf? : % -> Boolean
 leaves : % -> List S
 node? : (%,%) -> Boolean if S has SETCAT
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 value : % -> S
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 child? : (%,%) -> Boolean if S has SETCAT
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 ?.value : (%,value) -> S
\end{verbatim}

These exports come from HomogeneousAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
       if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
       if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
       if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
       if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
           if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
 ?~=? : (%,%) -> Boolean if S has SETCAT
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category RCAGG RecursiveAggregate>>=
)abbrev category RCAGG RecursiveAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A recursive aggregate over a type S is a model for a
++ a directed graph containing values of type S.
++ Recursively, a recursive aggregate is a {\em node}
++ consisting of a \spadfun{value} from S and 0 or more \spadfun{children}
++ which are recursive aggregates.
++ A node with no children is called a \spadfun{leaf} node.
++ A recursive aggregate may be cyclic for which some operations as noted
++ may go into an infinite loop.
RecursiveAggregate(S:Type): Category == HomogeneousAggregate(S) with
   children: % -> List %
     ++ children(u) returns a list of the children of aggregate u.
   -- should be % -> %* and also needs children: % -> Iterator(S,S)
   nodes: % -> List %
     ++ nodes(u) returns a list of all of the nodes of aggregate u.
   -- to become % -> %* and also nodes: % -> Iterator(S,S)
   leaf?: % -> Boolean
     ++ leaf?(u) tests if u is a terminal node.
   value: % -> S
     ++ value(u) returns the value of the node u.
   elt: (%,"value") -> S
     ++ elt(u,"value") (also written: \axiom{a. value}) is
     ++ equivalent to \axiom{value(a)}.
   cyclic?: % -> Boolean
     ++ cyclic?(u) tests if u has a cycle.
   leaves: % -> List S
     ++ leaves(t) returns the list of values in obtained by visiting the
     ++ nodes of tree \axiom{t} in left-to-right order.
   distance: (%,%) -> Integer
     ++ distance(u,v) returns the path length (an integer) from node u to v.
   if S has SetCategory then
      child?: (%,%) -> Boolean
	++ child?(u,v) tests if node u is a child of node v.
      node?: (%,%) -> Boolean
	++ node?(u,v) tests if node u is contained in node v
	++ (either as a child, a child of a child, etc.).
   if % has shallowlyMutable then
      setchildren_!: (%,List %)->%
	++ setchildren!(u,v) replaces the current children of node u
	++ with the members of v in left-to-right order.
      setelt: (%,"value",S) -> S
	++ setelt(a,"value",x) (also written \axiom{a . value := x})
	++ is equivalent to \axiom{setvalue!(a,x)}
      setvalue_!: (%,S) -> S
	++ setvalue!(u,x) sets the value of node u to x.
 add
   elt(x,"value") == value x
   if % has shallowlyMutable then
     setelt(x,"value",y) == setvalue_!(x,y)
   if S has SetCategory then
     child?(x,l) == member?(x,children(l))

@
<<RCAGG.dotabb>>=
"RCAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=RCAGG"];
"RCAGG" -> "HOAGG"

@
<<RCAGG.dotfull>>=
"RecursiveAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RCAGG"];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

@
<<RCAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"RecursiveAggregate(a:Type)" [color=lightblue];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{TwoDimensionalArrayCategory}{ARR2CAT}
\pagepic{ps/v102twodimensionalarraycategory.ps}{ARR2CAT}{0.60}

TwoDimensionalArrayCategory is a general array category which
allows different representations and indexing schemes.
Rows and columns may be extracted with rows returned as objects
of type Row and columns returned as objects of type Col.
The index of the 'first' row may be obtained by calling the
function 'minRowIndex'.  The index of the 'first' column may
be obtained by calling the function 'minColIndex'.  The index of
the first element of a 'Row' is the same as the index of the
first column in an array and vice versa.

{\bf See:}\\
\pagefrom{HomogeneousAggregate}{HOAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ARR2CAT}{any?} &
\cross{ARR2CAT}{column} &
\cross{ARR2CAT}{coerce} &
\cross{ARR2CAT}{copy} &
\cross{ARR2CAT}{count} \\
\cross{ARR2CAT}{elt} &
\cross{ARR2CAT}{empty} &
\cross{ARR2CAT}{empty?} &
\cross{ARR2CAT}{eq?} &
\cross{ARR2CAT}{eval} \\
\cross{ARR2CAT}{every?} &
\cross{ARR2CAT}{fill!} &
\cross{ARR2CAT}{hash} &
\cross{ARR2CAT}{latex} &
\cross{ARR2CAT}{less?} \\
\cross{ARR2CAT}{map} &
\cross{ARR2CAT}{map!} &
\cross{ARR2CAT}{maxColIndex} &
\cross{ARR2CAT}{maxRowIndex} &
\cross{ARR2CAT}{member?} \\
\cross{ARR2CAT}{members} &
\cross{ARR2CAT}{minColIndex} &
\cross{ARR2CAT}{minRowIndex} &
\cross{ARR2CAT}{more?} &
\cross{ARR2CAT}{ncols} \\
\cross{ARR2CAT}{new} &
\cross{ARR2CAT}{nrows} &
\cross{ARR2CAT}{parts} &
\cross{ARR2CAT}{qelt} &
\cross{ARR2CAT}{qsetelt!} \\
\cross{ARR2CAT}{row} &
\cross{ARR2CAT}{sample} &
\cross{ARR2CAT}{setColumn!} &
\cross{ARR2CAT}{setRow!} &
\cross{ARR2CAT}{setelt} \\
\cross{ARR2CAT}{size?} &
\cross{ARR2CAT}{\#?} &
\cross{ARR2CAT}{?=?} &
\cross{ARR2CAT}{?\~{}=?} &
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{ARR2CAT}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{ARR2CAT}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{ARR2CAT}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 elt : (%,Integer,Integer) -> R
 maxColIndex : % -> Integer           
 maxRowIndex : % -> Integer
 minColIndex : % -> Integer           
 minRowIndex : % -> Integer
 new : (NonNegativeInteger,NonNegativeInteger,R) -> %
 ncols : % -> NonNegativeInteger      
 nrows : % -> NonNegativeInteger
 qelt : (%,Integer,Integer) -> R
 qsetelt! : (%,Integer,Integer,R) -> R
 setelt : (%,Integer,Integer,R) -> R
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 any? : ((R -> Boolean),%) -> Boolean if $ has finiteAggregate
 copy : % -> %
 coerce : % -> OutputForm if R has SETCAT
 column : (%,Integer) -> Col          
 count : ((R -> Boolean),%) -> NonNegativeInteger if $ has finiteAggregate
 count : (R,%) -> NonNegativeInteger if R has SETCAT and $ has finiteAggregate
 elt : (%,Integer,Integer,R) -> R     
 every? : ((R -> Boolean),%) -> Boolean if $ has finiteAggregate
 fill! : (%,R) -> %
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((R -> R),%) -> %              
 map : (((R,R) -> R),%,%) -> %
 map : (((R,R) -> R),%,%,R) -> %      
 map! : ((R -> R),%) -> %
 member? : (R,%) -> Boolean if R has SETCAT and $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List R                  
 row : (%,Integer) -> Row             
 setColumn! : (%,Integer,Col) -> %
 setRow! : (%,Integer,Row) -> %       
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if R has SETCAT
\end{verbatim}

These exports come from HomogeneousAggregate(R:Type)
\begin{verbatim}
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List R,List R) -> % if R has EVALAB R and R has SETCAT
 eval : (%,R,R) -> % if R has EVALAB R and R has SETCAT
 eval : (%,Equation R) -> % if R has EVALAB R and R has SETCAT
 eval : (%,List Equation R) -> % if R has EVALAB R and R has SETCAT
 hash : % -> SingleInteger if R has SETCAT
 latex : % -> String if R has SETCAT
 members : % -> List R if $ has finiteAggregate
 sample : () -> %
 ?~=? : (%,%) -> Boolean if R has SETCAT
\end{verbatim}

<<category ARR2CAT TwoDimensionalArrayCategory>>=
)abbrev category ARR2CAT TwoDimensionalArrayCategory
++ Two dimensional array categories and domains
++ Author:
++ Date Created: 27 October 1989
++ Date Last Updated: 27 June 1990
++ Keywords: array, data structure
++ Examples:
++ References:
TwoDimensionalArrayCategory(R,Row,Col): Category == Definition where
 R   : Type
 Row : FiniteLinearAggregate R
 Col : FiniteLinearAggregate R

 Definition == HomogeneousAggregate(R) with

   shallowlyMutable
    ++ one may destructively alter arrays

   finiteAggregate
    ++ two-dimensional arrays are finite

--% Array creation

   new: (NonNegativeInteger,NonNegativeInteger,R) -> %
    ++ new(m,n,r) is an m-by-n array all of whose entries are r
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    
   fill_!: (%,R) -> %
    ++ fill!(m,r) fills m with r's
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X fill!(arr,10)

--% Size inquiries

   minRowIndex : % -> Integer
    ++ minRowIndex(m) returns the index of the 'first' row of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X minRowIndex(arr)

   maxRowIndex : % -> Integer
    ++ maxRowIndex(m) returns the index of the 'last' row of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X maxRowIndex(arr)

   minColIndex : % -> Integer
    ++ minColIndex(m) returns the index of the 'first' column of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X minColIndex(arr)

   maxColIndex : % -> Integer
    ++ maxColIndex(m) returns the index of the 'last' column of the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X maxColIndex(arr)

   nrows : % -> NonNegativeInteger
    ++ nrows(m) returns the number of rows in the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X nrows(arr)

   ncols : % -> NonNegativeInteger
    ++ ncols(m) returns the number of columns in the array m
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X ncols(arr)

--% Part extractions

   elt: (%,Integer,Integer) -> R
    ++ elt(m,i,j) returns the element in the ith row and jth
    ++ column of the array m
    ++ error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X elt(arr,1,1)

   qelt: (%,Integer,Integer) -> R
    ++ qelt(m,i,j) returns the element in the ith row and jth
    ++ column of the array m
    ++ NO error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X qelt(arr,1,1)

   elt: (%,Integer,Integer,R) -> R
    ++ elt(m,i,j,r) returns the element in the ith row and jth
    ++ column of the array m, if m has an ith row and a jth column,
    ++ and returns r otherwise
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X elt(arr,1,1,6)
    ++X elt(arr,1,10,6)

   row: (%,Integer) -> Row
    ++ row(m,i) returns the ith row of m
    ++ error check to determine if index is in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X row(arr,1)

   column: (%,Integer) -> Col
    ++ column(m,j) returns the jth column of m
    ++ error check to determine if index is in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X column(arr,1)

   parts: % -> List R
    ++ parts(m) returns a list of the elements of m in row major order
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X parts(arr)

--% Part assignments

   setelt: (%,Integer,Integer,R) -> R
    -- will become setelt_!
    ++ setelt(m,i,j,r) sets the element in the ith row and jth
    ++ column of m to r
    ++ error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X setelt(arr,1,1,17)

   qsetelt_!: (%,Integer,Integer,R) -> R
    ++ qsetelt!(m,i,j,r) sets the element in the ith row and jth
    ++ column of m to r
    ++ NO error check to determine if indices are in proper ranges
    ++
    ++X arr : ARRAY2 INT := new(5,4,0)
    ++X qsetelt!(arr,1,1,17)

   setRow_!: (%,Integer,Row) -> %
    ++ setRow!(m,i,v) sets to ith row of m to v
    ++
    ++X T1:=TwoDimensionalArray Integer
    ++X arr:T1:= new(5,4,0)
    ++X T2:=OneDimensionalArray Integer
    ++X arow:=construct([1,2,3,4]::List(INT))$T2
    ++X setRow!(arr,1,arow)$T1

   setColumn_!: (%,Integer,Col) -> %
    ++ setColumn!(m,j,v) sets to jth column of m to v
    ++
    ++X T1:=TwoDimensionalArray Integer
    ++X arr:T1:= new(5,4,0)
    ++X T2:=OneDimensionalArray Integer
    ++X acol:=construct([1,2,3,4,5]::List(INT))$T2
    ++X setColumn!(arr,1,acol)$T1

--% Map and Zip

   map: (R -> R,%) -> %
    ++ map(f,a) returns \spad{b}, where \spad{b(i,j) = f(a(i,j))} 
    ++ for all \spad{i, j}
    ++
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map(-,arr)
    ++X map((x +-> x + x),arr)

   map_!: (R -> R,%) -> %
    ++ map!(f,a)  assign \spad{a(i,j)} to \spad{f(a(i,j))} 
    ++ for all \spad{i, j}
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map!(-,arr)

   map:((R,R) -> R,%,%) -> %
    ++ map(f,a,b) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
    ++ for all \spad{i, j}
    ++
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X arr : ARRAY2 INT := new(5,4,10)
    ++X map(adder,arr,arr)

   map:((R,R) -> R,%,%,R) -> %
    ++ map(f,a,b,r) returns \spad{c}, where \spad{c(i,j) = f(a(i,j),b(i,j))}
    ++ when both \spad{a(i,j)} and \spad{b(i,j)} exist;
    ++ else \spad{c(i,j) = f(r, b(i,j))} when \spad{a(i,j)} does not exist;
    ++ else \spad{c(i,j) = f(a(i,j),r)} when \spad{b(i,j)} does not exist;
    ++ otherwise \spad{c(i,j) = f(r,r)}.
    ++
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X arr1 : ARRAY2 INT := new(5,4,10)
    ++X arr2 : ARRAY2 INT := new(3,3,10)
    ++X map(adder,arr1,arr2,17)

  add

--% Predicates

    any?(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          f(qelt(m,i,j)) => return true
      false

    every?(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          not f(qelt(m,i,j)) => return false
      true

    size?(m,n) == nrows(m) * ncols(m) = n
    less?(m,n) == nrows(m) * ncols(m) < n
    more?(m,n) == nrows(m) * ncols(m) > n

--% Size inquiries

    # m == nrows(m) * ncols(m)

--% Part extractions

    elt(m,i,j,r) ==
      i < minRowIndex(m) or i > maxRowIndex(m) => r
      j < minColIndex(m) or j > maxColIndex(m) => r
      qelt(m,i,j)

    count(f:R -> Boolean,m:%) ==
      num : NonNegativeInteger := 0
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          if f(qelt(m,i,j)) then num := num + 1
      num

    parts m ==
      entryList : List R := nil()
      for i in maxRowIndex(m)..minRowIndex(m) by -1 repeat
        for j in maxColIndex(m)..minColIndex(m) by -1 repeat
          entryList := concat(qelt(m,i,j),entryList)
      entryList

--% Creation

    copy m ==
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,qelt(m,i,j))
      ans

    fill_!(m,r) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(m,i,j,r)
      m

    map(f,m) ==
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,f(qelt(m,i,j)))
      ans

    map_!(f,m) ==
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(m,i,j,f(qelt(m,i,j)))
      m

    map(f,m,n) ==
      (nrows(m) ^= nrows(n)) or (ncols(m) ^= ncols(n)) =>
        error "map: arguments must have same dimensions"
      ans := new(nrows m,ncols m,NIL$Lisp)
      for i in minRowIndex(m)..maxRowIndex(m) repeat
        for j in minColIndex(m)..maxColIndex(m) repeat
          qsetelt_!(ans,i,j,f(qelt(m,i,j),qelt(n,i,j)))
      ans

    map(f,m,n,r) ==
      maxRow := max(maxRowIndex m,maxRowIndex n)
      maxCol := max(maxColIndex m,maxColIndex n)
      ans := new(max(nrows m,nrows n),max(ncols m,ncols n),NIL$Lisp)
      for i in minRowIndex(m)..maxRow repeat
        for j in minColIndex(m)..maxCol repeat
          qsetelt_!(ans,i,j,f(elt(m,i,j,r),elt(n,i,j,r)))
      ans

    setRow_!(m,i,v) ==
      i < minRowIndex(m) or i > maxRowIndex(m) =>
        error "setRow!: index out of range"
      for j in minColIndex(m)..maxColIndex(m) _
        for k in minIndex(v)..maxIndex(v) repeat
          qsetelt_!(m,i,j,v.k)
      m

    setColumn_!(m,j,v) ==
      j < minColIndex(m) or j > maxColIndex(m) =>
        error "setColumn!: index out of range"
      for i in minRowIndex(m)..maxRowIndex(m) _
        for k in minIndex(v)..maxIndex(v) repeat
          qsetelt_!(m,i,j,v.k)
      m

    if R has _= : (R,R) -> Boolean then

      m = n ==
        eq?(m,n) => true
        (nrows(m) ^= nrows(n)) or (ncols(m) ^= ncols(n)) => false
        for i in minRowIndex(m)..maxRowIndex(m) repeat
          for j in minColIndex(m)..maxColIndex(m) repeat
            not (qelt(m,i,j) = qelt(n,i,j)) => return false
        true

      member?(r,m) ==
        for i in minRowIndex(m)..maxRowIndex(m) repeat
          for j in minColIndex(m)..maxColIndex(m) repeat
            qelt(m,i,j) = r => return true
        false

      count(r:R,m:%) == count(#1 = r,m)

    if Row has shallowlyMutable then

      row(m,i) ==
        i < minRowIndex(m) or i > maxRowIndex(m) =>
          error "row: index out of range"
        v : Row := new(ncols m,NIL$Lisp)
        for j in minColIndex(m)..maxColIndex(m) _
          for k in minIndex(v)..maxIndex(v) repeat
            qsetelt_!(v,k,qelt(m,i,j))
        v

    if Col has shallowlyMutable then

      column(m,j) ==
        j < minColIndex(m) or j > maxColIndex(m) =>
          error "column: index out of range"
        v : Col := new(nrows m,NIL$Lisp)
        for i in minRowIndex(m)..maxRowIndex(m) _
          for k in minIndex(v)..maxIndex(v) repeat
            qsetelt_!(v,k,qelt(m,i,j))
        v

    if R has CoercibleTo(OutputForm) then

      coerce(m:%) ==
        l : List List OutputForm
        l := [[qelt(m,i,j) :: OutputForm _
                  for j in minColIndex(m)..maxColIndex(m)] _
                  for i in minRowIndex(m)..maxRowIndex(m)]
        matrix l

@
<<ARR2CAT.dotabb>>=
"ARR2CAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ARR2CAT"];
"ARR2CAT" -> "HOAGG"

@
<<ARR2CAT.dotfull>>=
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ARR2CAT"];
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
    -> "HomogeneousAggregate(a:Type)"

"TwoDimensionalArrayCategory(a:Type,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=ARR2CAT"];
"TwoDimensionalArrayCategory(a:Type,d:IndexedOneDimensionalArray(a,b),e:IndexedOneDimensionalArray(a,c))"
-> "TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"

@
<<ARR2CAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
 [color=lightblue];
"TwoDimensionalArrayCategory(a:Type,b:FiniteLinearAggregate(a),c:FiniteLinearAggregate(a))"
    -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"
"HomogeneousAggregate(a:Type)" -> "Evalable(a:Type)"
"HomogeneousAggregate(a:Type)" -> "SetCategory()"

"Evalable(a:Type)" [color="#00EE00"];

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];

}

@
\chapter{Category Layer 5}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{BinaryRecursiveAggregate}{BRAGG}
\pagepic{ps/v102binaryrecursiveaggregate.ps}{BRAGG}{1.00}

{\bf See:}\\
\pagefrom{RecursiveAggregate}{RCAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{BRAGG}{any?} &
\cross{BRAGG}{children} &
\cross{BRAGG}{child?} &
\cross{BRAGG}{coerce} &
\cross{BRAGG}{copy} \\
\cross{BRAGG}{count} &
\cross{BRAGG}{cyclic?} &
\cross{BRAGG}{distance} &
\cross{BRAGG}{empty} &
\cross{BRAGG}{empty?} \\
\cross{BRAGG}{eq?} &
\cross{BRAGG}{eval} &
\cross{BRAGG}{every?} &
\cross{BRAGG}{hash} &
\cross{BRAGG}{latex} \\
\cross{BRAGG}{leaf?} &
\cross{BRAGG}{leaves} &
\cross{BRAGG}{left} &
\cross{BRAGG}{less?} &
\cross{BRAGG}{map} \\
\cross{BRAGG}{map!} &
\cross{BRAGG}{member?} &
\cross{BRAGG}{members} &
\cross{BRAGG}{more?} &
\cross{BRAGG}{nodes} \\
\cross{BRAGG}{node?} &
\cross{BRAGG}{parts} &
\cross{BRAGG}{right} &
\cross{BRAGG}{sample} &
\cross{BRAGG}{setchildren!} \\
\cross{BRAGG}{setelt} &
\cross{BRAGG}{setleft!} &
\cross{BRAGG}{setright!} &
\cross{BRAGG}{setvalue!} &
\cross{BRAGG}{size?} \\
\cross{BRAGG}{value} &
\cross{BRAGG}{\#?} &
\cross{BRAGG}{?=?} &
\cross{BRAGG}{?\~{}=?} &
\cross{BRAGG}{?.right} \\
\cross{BRAGG}{?.left} &
\cross{BRAGG}{?.value} &&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{BRAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{BRAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 left : % -> %             
 right : % -> %
 setelt : (%,right,%) -> % if $ has shallowlyMutable
 setelt : (%,left,%) -> % if $ has shallowlyMutable
 setleft! : (%,%) -> % if $ has shallowlyMutable
 setright! : (%,%) -> % if $ has shallowlyMutable
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 children : % -> List %    
 coerce : % -> OutputForm if S has SETCAT
 cyclic? : % -> Boolean    
 leaf? : % -> Boolean      
 leaves : % -> List S
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 nodes : % -> List %       
 node? : (%,%) -> Boolean if S has SETCAT
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?.right : (%,right) -> %  
 ?.left : (%,left) -> %
\end{verbatim}

These exports come from RecursiveAggregate(S:Type)
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 child? : (%,%) -> Boolean if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 distance : (%,%) -> Integer
 empty : () -> %
 empty? : % -> Boolean     
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %          
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 value : % -> S
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?.value : (%,value) -> S  
\end{verbatim}

<<category BRAGG BinaryRecursiveAggregate>>=
)abbrev category BRAGG BinaryRecursiveAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A binary-recursive aggregate has 0, 1 or 2 children and serves
++ as a model for a binary tree or a doubly-linked aggregate structure
BinaryRecursiveAggregate(S:Type):Category == RecursiveAggregate S with
   -- needs preorder, inorder and postorder iterators
   left: % -> %
     ++ left(u) returns the left child.
   elt: (%,"left") -> %
     ++ elt(u,"left") (also written: \axiom{a . left}) is
     ++ equivalent to \axiom{left(a)}.
   right: % -> %
     ++ right(a) returns the right child.
   elt: (%,"right") -> %
     ++ elt(a,"right") (also written: \axiom{a . right})
     ++ is equivalent to \axiom{right(a)}.
   if % has shallowlyMutable then
      setelt: (%,"left",%) -> %
	++ setelt(a,"left",b) (also written \axiom{a . left := b}) is 
	++ equivalent to \axiom{setleft!(a,b)}.
      setleft_!: (%,%) -> %
	 ++ setleft!(a,b) sets the left child of \axiom{a} to be b.
      setelt: (%,"right",%) -> %
	 ++ setelt(a,"right",b) (also written \axiom{b . right := b})
	 ++ is equivalent to \axiom{setright!(a,b)}.
      setright_!: (%,%) -> %
	 ++ setright!(a,x) sets the right child of t to be x.
 add
   cycleMax ==> 1000

   elt(x,"left")  == left x
   elt(x,"right") == right x
   leaf? x == empty? x or empty? left x and empty? right x
   leaves t ==
     empty? t => empty()$List(S)
     leaf? t => [value t]
     concat(leaves left t,leaves right t)
   nodes x ==
     l := empty()$List(%)
     empty? x => l
     concat(nodes left x,concat([x],nodes right x))
   children x ==
     l := empty()$List(%)
     empty? x => l
     empty? left x  => [right x]
     empty? right x => [left x]
     [left x, right x]
   if % has SetAggregate(S) and S has SetCategory then
     node?(u,v) ==
       empty? v => false
       u = v => true
       for y in children v repeat node?(u,y) => return true
       false
     x = y ==
       empty?(x) => empty?(y)
       empty?(y) => false
       value x = value y and left x = left y and right x = right y
     if % has finiteAggregate then
       member?(x,u) ==
	 empty? u => false
	 x = value u => true
	 member?(x,left u) or member?(x,right u)

   if S has SetCategory then
     coerce(t:%): OutputForm ==
       empty? t =>  "[]"::OutputForm
       v := value(t):: OutputForm
       empty? left t =>
	 empty? right t => v
	 r := coerce(right t)@OutputForm
	 bracket ["."::OutputForm, v, r]
       l := coerce(left t)@OutputForm
       r :=
	 empty? right t => "."::OutputForm
	 coerce(right t)@OutputForm
       bracket [l, v, r]

   if % has finiteAggregate then
     aggCount: (%,NonNegativeInteger) -> NonNegativeInteger
     #x == aggCount(x,0)
     aggCount(x,k) ==
       empty? x => 0
       k := k + 1
       k = cycleMax and cyclic? x => error "cyclic tree"
       for y in children x repeat k := aggCount(y,k)
       k

   isCycle?:  (%, List %) -> Boolean
   eqMember?: (%, List %) -> Boolean
   cyclic? x	 == not empty? x and isCycle?(x,empty()$(List %))
   isCycle?(x,acc) ==
     empty? x => false
     eqMember?(x,acc) => true
     for y in children x | not empty? y repeat
       isCycle?(y,acc) => return true
     false
   eqMember?(y,l) ==
     for x in l repeat eq?(x,y) => return true
     false
   if % has shallowlyMutable then
     setelt(x,"left",b)  == setleft_!(x,b)
     setelt(x,"right",b) == setright_!(x,b)

@
<<BRAGG.dotabb>>=
"BRAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=BRAGG"];
"BRAGG" -> "RCAGG"

@
<<BRAGG.dotfull>>=
"BinaryRecursiveAggregate(a:Type)" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BRAGG"];
"BinaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

@
<<BRAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"BinaryRecursiveAggregate(a:Type)" [color=lightblue];
"BinaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

"RecursiveAggregate(a:Type)" [color=lightblue];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CancellationAbelianMonoid}{CABMON}
\pagepic{ps/v102cancellationabelianmonoid.ps}{CABMON}{0.75}

{\bf See:}\\
\pageto{AbelianGroup}{ABELGRP}
\pageto{OrderedCancellationAbelianMonoid}{OCAMON}
\pagefrom{AbelianMonoid}{ABELMON}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{CABMON}{0} &
\cross{CABMON}{coerce} &
\cross{CABMON}{hash} &
\cross{CABMON}{latex} &
\cross{CABMON}{sample} \\
\cross{CABMON}{subtractIfCan} &
\cross{CABMON}{zero?} &
\cross{CABMON}{?\~{}=?} &
\cross{CABMON}{?*?} &
\cross{CABMON}{?+?} \\
\cross{CABMON}{?=?} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 subtractIfCan : (%,%) -> Union(%,"failed")
\end{verbatim}

These exports come from AbelianMonoid():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 zero? : % -> Boolean                 
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?~=? : (%,%) -> Boolean
 ?+? : (%,%) -> %
 ?=? : (%,%) -> Boolean               
\end{verbatim}

<<category CABMON CancellationAbelianMonoid>>=
)abbrev category CABMON CancellationAbelianMonoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References: Davenport & Trager I
++ Description:
++ This is an \spadtype{AbelianMonoid} with the cancellation property, i.e.
++ \spad{ a+b = a+c => b=c }.
++ This is formalised by the partial subtraction operator,
++ which satisfies the axioms listed below:
++
++ Axioms:
++   \spad{c = a+b <=> c-b = a}
CancellationAbelianMonoid(): Category == AbelianMonoid with
      subtractIfCan: (%,%) -> Union(%,"failed")
         ++ subtractIfCan(x, y) returns an element z such that \spad{z+y=x}
         ++ or "failed" if no such element exists.

@
<<CABMON.dotabb>>=
"CABMON"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CABMON"];
"CABMON" -> "ABELMON"

@
<<CABMON.dotfull>>=
"CancellationAbelianMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CABMON"];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

@
<<CABMON.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SetCategory()"
"AbelianSemiGroup()" -> "RepeatedDoubling(AbelianSemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" ->
    "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedDoubling(AbelianSemiGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianSemiGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DictionaryOperations}{DIOPS}
\pagepic{ps/v102dictionaryoperations.ps}{DIOPS}{1.00}

{\bf See:}\\
\pageto{Dictionary}{DIAGG}
\pageto{MultiDictionary}{MDAGG}
\pagefrom{BagAggregate}{BGAGG}
\pagefrom{Collection}{CLAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DIOPS}{any?} &
\cross{DIOPS}{bag} &
\cross{DIOPS}{coerce} &
\cross{DIOPS}{construct} &
\cross{DIOPS}{convert} \\
\cross{DIOPS}{copy} &
\cross{DIOPS}{count} &
\cross{DIOPS}{dictionary} &
\cross{DIOPS}{empty} &
\cross{DIOPS}{empty?} \\
\cross{DIOPS}{eq?} &
\cross{DIOPS}{eval} &
\cross{DIOPS}{every?} &
\cross{DIOPS}{extract!} &
\cross{DIOPS}{find} \\
\cross{DIOPS}{hash} &
\cross{DIOPS}{insert!} &
\cross{DIOPS}{inspect} &
\cross{DIOPS}{latex} &
\cross{DIOPS}{less?} \\
\cross{DIOPS}{map} &
\cross{DIOPS}{map!} &
\cross{DIOPS}{member?} &
\cross{DIOPS}{members} &
\cross{DIOPS}{more?} \\
\cross{DIOPS}{parts} &
\cross{DIOPS}{reduce} &
\cross{DIOPS}{remove} &
\cross{DIOPS}{remove!} &
\cross{DIOPS}{removeDuplicates} \\
\cross{DIOPS}{sample} &
\cross{DIOPS}{select} &
\cross{DIOPS}{select!} &
\cross{DIOPS}{size?} &
\cross{DIOPS}{\#?} \\
\cross{DIOPS}{?=?} &
\cross{DIOPS}{?\~{}=?} &&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{DIOPS}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 dictionary : List S -> %
 remove! : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 select! : ((S -> Boolean),%) -> % if $ has finiteAggregate
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 coerce : % -> OutputForm if S has SETCAT
 construct : List S -> %
 copy : % -> %
 dictionary : () -> %
\end{verbatim}

These exports come from BagAggregate(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                     
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from Collection(S:SetCategory)
\begin{verbatim}
 convert : % -> InputForm if S has KONVERT INFORM
 find : ((S -> Boolean),%) -> Union(S,"failed")
 reduce : (((S,S) -> S),%) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
                 if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove : (S,%) -> % if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
\end{verbatim}

<<category DIOPS DictionaryOperations>>=
)abbrev category DIOPS DictionaryOperations
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This category is a collection of operations common to both
++ categories \spadtype{Dictionary} and \spadtype{MultiDictionary}
DictionaryOperations(S:SetCategory): Category ==
  Join(BagAggregate S, Collection(S)) with
   dictionary: () -> %
     ++ dictionary()$D creates an empty dictionary of type D.
   dictionary: List S -> %
     ++ dictionary([x,y,...,z]) creates a dictionary consisting of
     ++ entries \axiom{x,y,...,z}.
-- insert: (S,%) -> S		      ++ insert an entry
-- member?: (S,%) -> Boolean		      ++ search for an entry
-- remove_!: (S,%,NonNegativeInteger) -> %
--   ++ remove!(x,d,n) destructively changes dictionary d by removing
--   ++ up to n entries y such that \axiom{y = x}.
-- remove_!: (S->Boolean,%,NonNegativeInteger) -> %
--   ++ remove!(p,d,n) destructively changes dictionary d by removing
--   ++ up to n entries x such that \axiom{p(x)} is true.
   if % has finiteAggregate then
     remove_!: (S,%) -> %
       ++ remove!(x,d) destructively changes dictionary d by removing
       ++ all entries y such that \axiom{y = x}.
     remove_!: (S->Boolean,%) -> %
       ++ remove!(p,d) destructively changes dictionary d by removeing
       ++ all entries x such that \axiom{p(x)} is true.
     select_!: (S->Boolean,%) -> %
       ++ select!(p,d) destructively changes dictionary d by removing
       ++ all entries x such that \axiom{p(x)} is not true.
 add
   construct l == dictionary l
   dictionary() == empty()
   if % has finiteAggregate then
     copy d == dictionary parts d
     coerce(s:%):OutputForm ==
       prefix("dictionary"@String :: OutputForm,
				      [x::OutputForm for x in parts s])

@
<<DIOPS.dotabb>>=
"DIOPS" [color=lightblue,href="bookvol10.2.pdf#nameddest=DIOPS"];
"DIOPS" -> "BGAGG"
"DIOPS" -> "CLAGG"

@
<<DIOPS.dotfull>>=
"DictionaryOperations(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIOPS"];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

@
<<DIOPS.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

"BagAggregate(a:SetCategory)" [color=seagreen];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"Collection(a:SetCategory)" [color=seagreen];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DoublyLinkedAggregate}{DLAGG}
\pagepic{ps/v102doublylinkedaggregate.ps}{DLAGG}{1.00}

{\bf See:}\\
\pagefrom{RecursiveAggregate}{RCAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DLAGG}{any?} &
\cross{DLAGG}{children} &
\cross{DLAGG}{child?} &
\cross{DLAGG}{coerce} &
\cross{DLAGG}{concat!} \\
\cross{DLAGG}{copy} &
\cross{DLAGG}{count} &
\cross{DLAGG}{count} &
\cross{DLAGG}{cyclic?} &
\cross{DLAGG}{distance} \\
\cross{DLAGG}{empty} &
\cross{DLAGG}{empty?} &
\cross{DLAGG}{eq?} &
\cross{DLAGG}{eval} &
\cross{DLAGG}{eval} \\
\cross{DLAGG}{eval} &
\cross{DLAGG}{eval} &
\cross{DLAGG}{every?} &
\cross{DLAGG}{hash} &
\cross{DLAGG}{head} \\
\cross{DLAGG}{last} &
\cross{DLAGG}{latex} &
\cross{DLAGG}{leaf?} &
\cross{DLAGG}{leaves} &
\cross{DLAGG}{less?} \\
\cross{DLAGG}{map} &
\cross{DLAGG}{map!} &
\cross{DLAGG}{member?} &
\cross{DLAGG}{members} &
\cross{DLAGG}{more?} \\
\cross{DLAGG}{next} &
\cross{DLAGG}{nodes} &
\cross{DLAGG}{node?} &
\cross{DLAGG}{parts} &
\cross{DLAGG}{previous} \\
\cross{DLAGG}{sample} &
\cross{DLAGG}{setchildren!} &
\cross{DLAGG}{setelt} &
\cross{DLAGG}{setnext!} &
\cross{DLAGG}{setprevious!} \\
\cross{DLAGG}{setvalue!} &
\cross{DLAGG}{size?} &
\cross{DLAGG}{tail} &
\cross{DLAGG}{value} &
\cross{DLAGG}{\#?} \\
\cross{DLAGG}{?=?} &
\cross{DLAGG}{?\~{}=?} &
\cross{DLAGG}{?.value} &&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{DLAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 concat! : (%,%) -> % if $ has shallowlyMutable
 head : % -> %
 last : % -> S
 next : % -> %
 previous : % -> %
 setnext! : (%,%) -> % if $ has shallowlyMutable
 setprevious! : (%,%) -> % if $ has shallowlyMutable
 tail : % -> %
\end{verbatim}

These exports come from RecursiveAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 children : % -> List %
 child? : (%,%) -> Boolean if S has SETCAT
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 cyclic? : % -> Boolean
 distance : (%,%) -> Integer
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 leaf? : % -> Boolean
 leaves : % -> List S
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 nodes : % -> List %
 node? : (%,%) -> Boolean if S has SETCAT
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                      
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 value : % -> S                       
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?.value : (%,value) -> S             
\end{verbatim}

<<category DLAGG DoublyLinkedAggregate>>=
)abbrev category DLAGG DoublyLinkedAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A doubly-linked aggregate serves as a model for a doubly-linked
++ list, that is, a list which can has links to both next and previous
++ nodes and thus can be efficiently traversed in both directions.
DoublyLinkedAggregate(S:Type): Category == RecursiveAggregate S with
   last: % -> S
     ++ last(l) returns the last element of a doubly-linked aggregate l.
     ++ Error: if l is empty.
   head: % -> %
     ++ head(l) returns the first element of a doubly-linked aggregate l.
     ++ Error: if l is empty.
   tail: % -> %
     ++ tail(l) returns the doubly-linked aggregate l starting at
     ++ its second element.
     ++ Error: if l is empty.
   previous: % -> %
     ++ previous(l) returns the doubly-link list beginning with its previous
     ++ element.
     ++ Error: if l has no previous element.
     ++ Note: \axiom{next(previous(l)) = l}.
   next: % -> %
     ++ next(l) returns the doubly-linked aggregate beginning with its next
     ++ element.
     ++ Error: if l has no next element.
     ++ Note: \axiom{next(l) = rest(l)} and \axiom{previous(next(l)) = l}.
   if % has shallowlyMutable then
      concat_!: (%,%) -> %
	++ concat!(u,v) destructively concatenates doubly-linked aggregate v 
        ++ to the end of doubly-linked aggregate u.
      setprevious_!: (%,%) -> %
	++ setprevious!(u,v) destructively sets the previous node of 
        ++ doubly-linked aggregate u to v, returning v.
      setnext_!: (%,%) -> %
	++ setnext!(u,v) destructively sets the next node of doubly-linked 
        ++ aggregate u to v, returning v.

@
<<DLAGG.dotabb>>=
"DLAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=DLAGG"];
"DLAGG" -> "RCAGG"

@
<<DLAGG.dotfull>>=
"DoublyLinkedAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DLAGG"];
"DoublyLinkedAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

@
<<DLAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DoublyLinkedAggregate(a:Type)" [color=lightblue];
"DoublyLinkedAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

"RecursiveAggregate(a:Type)" [color=lightblue];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Group}{GROUP}
\pagepic{ps/v102group.ps}{GROUP}{0.65}

{\bf See:}\\
\pagefrom{Monoid}{MONOID}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{GROUP}{1} &
\cross{GROUP}{coerce} &
\cross{GROUP}{commutator} &
\cross{GROUP}{conjugate} &
\cross{GROUP}{hash} \\
\cross{GROUP}{inv} &
\cross{GROUP}{latex} &
\cross{GROUP}{one?} &
\cross{GROUP}{recip} &
\cross{GROUP}{sample} \\
\cross{GROUP}{?\~{}=?} &
\cross{GROUP}{?*?} &
\cross{GROUP}{?**?} &
\cross{GROUP}{?/?} &
\cross{GROUP}{?=?} \\
\cross{GROUP}{?\^{}?} &&&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{GROUP}{unitsKnown}}
is true if a monoid (a multiplicative semigroup with a 1) has 
unitsKnown means that  the operation {\tt recip} can only return 
``failed'' if its argument is not a unit.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 inv : % -> %                         
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 commutator : (%,%) -> %
 conjugate : (%,%) -> %               
 recip : % -> Union(%,"failed")
 ?/? : (%,%) -> %
 ?^? : (%,Integer) -> %               
 ?**? : (%,Integer) -> %
\end{verbatim}

These exports come from Aggregate:
\begin{verbatim}
\end{verbatim}

These exports come from Monoid():
\begin{verbatim}
 1 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String
 one? : % -> Boolean                  
 sample : () -> %                     
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %      
 ?*? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
\end{verbatim}

<<category GROUP Group>>=
)abbrev category GROUP Group
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The class of multiplicative groups, i.e. monoids with
++ multiplicative inverses.
++
++ Axioms:
++   \spad{leftInverse("*":(%,%)->%,inv)}\tab{30}\spad{ inv(x)*x = 1 }
++   \spad{rightInverse("*":(%,%)->%,inv)}\tab{30}\spad{ x*inv(x) = 1 }
Group(): Category == Monoid with
      inv: % -> %               
        ++ inv(x) returns the inverse of x.
      "/": (%,%) -> %           
        ++ x/y is the same as x times the inverse of y.
      "**": (%,Integer) -> %    
        ++ x**n returns x raised to the integer power n.
      "^": (%,Integer) -> %     
        ++ x^n returns x raised to the integer power n.
      unitsKnown                
        ++ unitsKnown asserts that recip only returns
        ++ "failed" for non-units.
      conjugate: (%,%) -> %
        ++ conjugate(p,q) computes \spad{inv(q) * p * q}; this is 
        ++ 'right action by conjugation'.
      commutator: (%,%) -> %
        ++ commutator(p,q) computes \spad{inv(p) * inv(q) * p * q}.
    add
      import RepeatedSquaring(%)
      x:% / y:% == x*inv(y)
      recip(x:%) == inv(x)
      _^(x:%, n:Integer):% == x ** n
      x:% ** n:Integer ==
         zero? n => 1
         n<0 => expt(inv(x),(-n) pretend PositiveInteger)
         expt(x,n pretend PositiveInteger)
      conjugate(p,q) == inv(q) * p * q
      commutator(p,q) == inv(p) * inv(q) * p * q

@
<<GROUP.dotabb>>=
"GROUP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GROUP"];
"GROUP" -> "MONOID"

@
<<GROUP.dotfull>>=
"Group()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GROUP"];
"Group()" -> "Monoid()"

@
<<GROUP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Group()" [color=lightblue];
"Group()" -> "Monoid()"
"Group()" -> "RepeatedSquaring(Group)"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SetCategory()"
"SemiGroup()" -> "RepeatedSquaring(SemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedSquaring(Group)" [color="#00EE00"];
"RepeatedSquaring(Group)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(SemiGroup)" [color="#00EE00"];
"RepeatedSquaring(SemiGroup)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];

}
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{LinearAggregate}{LNAGG}
\pagepic{ps/v102linearaggregate.ps}{LNAGG}{1.00}

{\bf See:}\\
\pageto{ExtensibleLinearAggregate}{ELAGG}
\pageto{FiniteLinearAggregate}{FLAGG}
\pageto{StreamAggregate}{STAGG}
\pagefrom{Collection}{CLAGG}
\pagefrom{IndexedAggregate}{IXAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{LNAGG}{any?} &
\cross{LNAGG}{coerce} &
\cross{LNAGG}{concat} &
\cross{LNAGG}{construct} &
\cross{LNAGG}{convert} \\
\cross{LNAGG}{copy} &
\cross{LNAGG}{count} &
\cross{LNAGG}{delete} &
\cross{LNAGG}{elt} &
\cross{LNAGG}{empty} \\
\cross{LNAGG}{empty?} &
\cross{LNAGG}{entries} &
\cross{LNAGG}{entry?} &
\cross{LNAGG}{eq?} &
\cross{LNAGG}{eval} \\
\cross{LNAGG}{every?} &
\cross{LNAGG}{fill!} &
\cross{LNAGG}{find} &
\cross{LNAGG}{first} &
\cross{LNAGG}{hash} \\
\cross{LNAGG}{index?} &
\cross{LNAGG}{indices} &
\cross{LNAGG}{insert} &
\cross{LNAGG}{latex} &
\cross{LNAGG}{less?} \\
\cross{LNAGG}{map} &
\cross{LNAGG}{map!} &
\cross{LNAGG}{maxIndex} &
\cross{LNAGG}{member?} &
\cross{LNAGG}{members} \\
\cross{LNAGG}{minIndex} &
\cross{LNAGG}{more?} &
\cross{LNAGG}{new} &
\cross{LNAGG}{parts} &
\cross{LNAGG}{qelt} \\
\cross{LNAGG}{qsetelt!} &
\cross{LNAGG}{reduce} &
\cross{LNAGG}{reduce} &
\cross{LNAGG}{reduce} &
\cross{LNAGG}{remove} \\
\cross{LNAGG}{remove} &
\cross{LNAGG}{removeDuplicates} &
\cross{LNAGG}{sample} &
\cross{LNAGG}{select} &
\cross{LNAGG}{setelt} \\
\cross{LNAGG}{setelt} &
\cross{LNAGG}{size?} &
\cross{LNAGG}{swap!} &
\cross{LNAGG}{?\~{}=?} &
\cross{LNAGG}{\#?} \\
\cross{LNAGG}{?=?} &
\cross{LNAGG}{?.?} &&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{LNAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{LNAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 concat : (%,%) -> %
 concat : List % -> %                 
 delete : (%,Integer) -> %            
 delete : (%,UniversalSegment Integer) -> %
 insert : (%,%,Integer) -> %
 map : (((S,S) -> S),%,%) -> %
 new : (NonNegativeInteger,S) -> %
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 ?.? : (%,UniversalSegment Integer) -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 concat : (%,S) -> %
 concat : (S,%) -> %                  
 index? : (Integer,%) -> Boolean
 indices : % -> List Integer          
 insert : (S,%,Integer) -> %          
 maxIndex : % -> Integer if Integer has ORDSET
\end{verbatim}

These exports come from IndexedAggregate(Integer,S:Type)
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 elt : (%,Integer,S) -> S             
 empty : () -> %
 empty? : % -> Boolean                
 entries : % -> List S
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate and S has SETCAT
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 fill! : (%,S) -> % if $ has shallowlyMutable
 first : % -> S if Integer has ORDSET
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 qelt : (%,Integer) -> S              
 qsetelt! : (%,Integer,S) -> S if $ has shallowlyMutable
 sample : () -> %
 setelt : (%,Integer,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 swap! : (%,Integer,Integer) -> Void if $ has shallowlyMutable
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?.? : (%,Integer) -> S
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from Collection(S:Type):
\begin{verbatim}
 construct : List S -> %              
 convert : % -> InputForm if S has KONVERT INFORM
 find : ((S -> Boolean),%) -> Union(S,"failed")
 reduce : (((S,S) -> S),%) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
                 if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove : (S,%) -> % if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
\end{verbatim}

<<category LNAGG LinearAggregate>>=
)abbrev category LNAGG LinearAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A linear aggregate is an aggregate whose elements are indexed by integers.
++ Examples of linear aggregates are strings, lists, and
++ arrays.
++ Most of the exported operations for linear aggregates are non-destructive
++ but are not always efficient for a particular aggregate.
++ For example, \spadfun{concat} of two lists needs only to copy its first
++ argument, whereas \spadfun{concat} of two arrays needs to copy both 
++ arguments. Most of the operations exported here apply to infinite 
++ objects (e.g. streams) as well to finite ones.
++ For finite linear aggregates, see \spadtype{FiniteLinearAggregate}.
LinearAggregate(S:Type): Category ==
  Join(IndexedAggregate(Integer, S), Collection(S)) with
   new	 : (NonNegativeInteger,S) -> %
     ++ new(n,x) returns \axiom{fill!(new n,x)}.
   concat: (%,S) -> %
     ++ concat(u,x) returns aggregate u with additional element x at the end.
     ++ Note: for lists, \axiom{concat(u,x) == concat(u,[x])}
   concat: (S,%) -> %
     ++ concat(x,u) returns aggregate u with additional element at the front.
     ++ Note: for lists: \axiom{concat(x,u) == concat([x],u)}.
   concat: (%,%) -> %
      ++ concat(u,v) returns an aggregate consisting of the elements of u
      ++ followed by the elements of v.
      ++ Note: if \axiom{w = concat(u,v)} then 
      ++ \axiom{w.i = u.i for i in indices u}
      ++ and \axiom{w.(j + maxIndex u) = v.j for j in indices v}.
   concat: List % -> %
      ++ concat(u), where u is a lists of aggregates \axiom{[a,b,...,c]}, 
      ++ returns a single aggregate consisting of the elements of \axiom{a}
      ++ followed by those
      ++ of b followed ... by the elements of c.
      ++ Note: \axiom{concat(a,b,...,c) = concat(a,concat(b,...,c))}.
   map: ((S,S)->S,%,%) -> %
     ++ map(f,u,v) returns a new collection w with elements 
     ++ \axiom{z = f(x,y)} for corresponding elements x and y from u and v.
     ++ Note: for linear aggregates, \axiom{w.i = f(u.i,v.i)}.
   elt: (%,UniversalSegment(Integer)) -> %
      ++ elt(u,i..j) (also written: \axiom{a(i..j)}) returns the aggregate of
      ++ elements \axiom{u} for k from i to j in that order.
      ++ Note: in general, \axiom{a.s = [a.k for i in s]}.
   delete: (%,Integer) -> %
      ++ delete(u,i) returns a copy of u with the \axiom{i}th 
      ++ element deleted. Note: for lists, 
      ++ \axiom{delete(a,i) == concat(a(0..i - 1),a(i + 1,..))}.
   delete: (%,UniversalSegment(Integer)) -> %
      ++ delete(u,i..j) returns a copy of u with the \axiom{i}th through
      ++ \axiom{j}th element deleted.
      ++ Note: \axiom{delete(a,i..j) = concat(a(0..i-1),a(j+1..))}.
   insert: (S,%,Integer) -> %
      ++ insert(x,u,i) returns a copy of u having x as its 
      ++ \axiom{i}th element.
      ++ Note: \axiom{insert(x,a,k) = concat(concat(a(0..k-1),x),a(k..))}.
   insert: (%,%,Integer) -> %
      ++ insert(v,u,k) returns a copy of u having v inserted beginning at the
      ++ \axiom{i}th element.
      ++ Note: \axiom{insert(v,u,k) = concat( u(0..k-1), v, u(k..) )}.
   if % has shallowlyMutable then 
    setelt: (%,UniversalSegment(Integer),S) -> S
      ++ setelt(u,i..j,x) (also written: \axiom{u(i..j) := x}) destructively
      ++ replaces each element in the segment \axiom{u(i..j)} by x.
      ++ The value x is returned.
      ++ Note: u is destructively change so
      ++ that \axiom{u.k := x for k in i..j};
      ++ its length remains unchanged.
 add
  indices a	 == [i for i in minIndex a .. maxIndex a]
  index?(i, a)	 == i >= minIndex a and i <= maxIndex a
  concat(a:%, x:S)	== concat(a, new(1, x))
  concat(x:S, y:%)	== concat(new(1, x), y)
  insert(x:S, a:%, i:Integer) == insert(new(1, x), a, i)
  if % has finiteAggregate then
    maxIndex l == #l - 1 + minIndex l

--if % has shallowlyMutable then new(n, s)  == fill_!(new n, s)

@
<<LNAGG.dotabb>>=
"LNAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=LNAGG"];
"LNAGG" -> "IXAGG"
"LNAGG" -> "CLAGG"

@
<<LNAGG.dotfull>>=
"LinearAggregate(a:Type)" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LNAGG"];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "Collection(a:Type)"

@
<<LNAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "Collection(a:Type)"

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];

}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedAbelianSemiGroup}{OASGP}
\pagepic{ps/v102orderedabeliansemigroup.ps}{OASGP}{0.75}

{\bf See:}\\
\pageto{OrderedAbelianMonoid}{OAMON}
\pagefrom{AbelianMonoid}{ABELMON}
\pagefrom{OrderedSet}{ORDSET}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OASGP}{0} &
\cross{OASGP}{coerce} &
\cross{OASGP}{hash} &
\cross{OASGP}{latex} &
\cross{OASGP}{max} \\
\cross{OASGP}{min} &
\cross{OASGP}{sample} &
\cross{OASGP}{zero?} &
\cross{OASGP}{?\~{}=?} &
\cross{OASGP}{?*?} \\
\cross{OASGP}{?+?} &
\cross{OASGP}{?$<$?} &
\cross{OASGP}{?$<=$?} &
\cross{OASGP}{?=?} &
\cross{OASGP}{?$>$?} \\
\cross{OASGP}{?$>=$?} &&&&
\end{tabular}

These exports come from OrderedSet():
\begin{verbatim}
 coerce : % -> OutputForm              
 hash : % -> SingleInteger
 latex : % -> String                   
 max : (%,%) -> %
 min : (%,%) -> %                      
 ?<? : (%,%) -> Boolean                
 ?>? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean               
 ?=? : (%,%) -> Boolean                
 ?~=? : (%,%) -> Boolean
\end{verbatim}

These exports come from AbelianMonoid():
\begin{verbatim}
 0 : () -> %
 sample : () -> %
 zero? : % -> Boolean                  
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %        
 ?+? : (%,%) -> %
\end{verbatim}

<<category OASGP OrderedAbelianSemiGroup>>=
)abbrev category OASGP OrderedAbelianSemiGroup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also abelian semigroups, such that the addition
++ preserves the ordering.
++   \spad{ x < y => x+z < y+z}
OrderedAbelianSemiGroup(): Category == Join(OrderedSet, AbelianMonoid)

@
<<OASGP.dotabb>>=
"OASGP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OASGP"];
"OASGP" -> "ORDSET"
"OASGP" -> "ABELMON"

@
<<OASGP.dotfull>>=
"OrderedAbelianSemiGroup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OASGP"];
"OrderedAbelianSemiGroup()" -> "OrderedSet()"
"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"

@
<<OASGP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedAbelianSemiGroup()" [color=lightblue];
"OrderedAbelianSemiGroup()" -> "OrderedSet()"
"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SetCategory()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SetCategory()"
"AbelianSemiGroup()" -> "RepeatedDoubling(AbelianSemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" ->
    "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedDoubling(AbelianSemiGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianSemiGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedMonoid}{ORDMON}
\pagepic{ps/v102orderedmonoid.ps}{ORDMON}{0.75}

{\bf See:}\\
\pagefrom{Monoid}{MONOID}
\pagefrom{OrderedSet}{ORDSET}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ORDMON}{1} &
\cross{ORDMON}{coerce} &
\cross{ORDMON}{hash} &
\cross{ORDMON}{latex} &
\cross{ORDMON}{max} \\
\cross{ORDMON}{min} &
\cross{ORDMON}{one?} &
\cross{ORDMON}{recip} &
\cross{ORDMON}{sample} &
\cross{ORDMON}{?*?} \\
\cross{ORDMON}{?**?} &
\cross{ORDMON}{?$<$?} &
\cross{ORDMON}{?$<=$?} &
\cross{ORDMON}{?=?} &
\cross{ORDMON}{?$>$?} \\
\cross{ORDMON}{?$>=$?} &
\cross{ORDMON}{?\~{}=?} &
\cross{ORDMON}{?\^{}?} &&
\end{tabular}

These exports come from Monoid():
\begin{verbatim}
 1 : () -> %
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")
 sample : () -> %                     
 ?*? : (%,%) -> %                     
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
\end{verbatim}

These exports come from OrderedSet():
\begin{verbatim}
 max : (%,%) -> %                     
 min : (%,%) -> %
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
\end{verbatim}

<<category ORDMON OrderedMonoid>>=
)abbrev category ORDMON OrderedMonoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also monoids, such that multiplication
++ preserves the ordering.
++
++ Axioms:
++   \spad{x < y => x*z < y*z}
++   \spad{x < y => z*x < z*y}

OrderedMonoid(): Category == Join(OrderedSet, Monoid)

@
<<ORDMON.dotabb>>=
"ORDMON"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDMON"];
"ORDMON" -> "ORDSET"
"ORDMON" -> "MONOID"

@
<<ORDMON.dotfull>>=
"OrderedMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDMON"];
"OrderedMonoid()" -> "OrderedSet()"
"OrderedMonoid()" -> "Monoid()"

@
<<ORDMON.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDMON"];
"OrderedMonoid()" -> "OrderedSet()"
"OrderedMonoid()" -> "Monoid()"

"OrderedSet()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDSET"];
"OrderedSet()" -> "SetCategory()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SetCategory()"
"SemiGroup()" -> "RepeatedSquaring(SemiGroup)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"RepeatedSquaring(SemiGroup)" [color="#00EE00"];
"RepeatedSquaring(SemiGroup)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"Category" [color=lightblue];

}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{PriorityQueueAggregate}{PRQAGG}
\pagepic{ps/v102priorityqueueaggregate.ps}{PRQAGG}{1.00}

{\bf See:}\\
\pageto{OrderedMultisetAggregate}{OMSAGG}
\pagefrom{BagAggregate}{BGAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{PRQAGG}{any?} &
\cross{PRQAGG}{bag} &
\cross{PRQAGG}{copy} &
\cross{PRQAGG}{coerce} &
\cross{PRQAGG}{count} \\
\cross{PRQAGG}{empty} &
\cross{PRQAGG}{empty?} &
\cross{PRQAGG}{eq?} &
\cross{PRQAGG}{eval} &
\cross{PRQAGG}{every?} \\
\cross{PRQAGG}{extract!} &
\cross{PRQAGG}{hash} &
\cross{PRQAGG}{insert!} &
\cross{PRQAGG}{inspect} &
\cross{PRQAGG}{latex} \\
\cross{PRQAGG}{less?} &
\cross{PRQAGG}{map} &
\cross{PRQAGG}{map!} &
\cross{PRQAGG}{max} &
\cross{PRQAGG}{member?} \\
\cross{PRQAGG}{members} &
\cross{PRQAGG}{merge} &
\cross{PRQAGG}{merge!} &
\cross{PRQAGG}{more?} &
\cross{PRQAGG}{parts} \\
\cross{PRQAGG}{sample} &
\cross{PRQAGG}{size?} &
\cross{PRQAGG}{\#?} &
\cross{PRQAGG}{?=?} &
\cross{PRQAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{PRQAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 max : % -> S
 merge : (%,%) -> %                   
 merge! : (%,%) -> %
\end{verbatim}

These exports come from BagAggregate(S:OrderedSet):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %                    
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %                 
 inspect : % -> S
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                     
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category PRQAGG PriorityQueueAggregate>>=
)abbrev category PRQAGG PriorityQueueAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A priority queue is a bag of items from an ordered set where the item
++ extracted is always the maximum element.
PriorityQueueAggregate(S:OrderedSet): Category == BagAggregate S with
   finiteAggregate
   max: % -> S
     ++ max(q) returns the maximum element of priority queue q.
   merge: (%,%) -> %
     ++ merge(q1,q2) returns combines priority queues q1 and q2 to return
     ++ a single priority queue q.
   merge_!: (%,%) -> %
     ++ merge!(q,q1) destructively changes priority queue q to include the
     ++ values from priority queue q1.

@
<<PRQAGG.dotabb>>=
"PRQAGG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PRQAGG"];
"PRQAGG" -> "BGAGG"

@
<<PRQAGG.dotfull>>=
"PriorityQueueAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PRQAGG"];
"PriorityQueueAggregate(a:Type)" -> "BagAggregate(a:Type)"

"PriorityQueueAggregate(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=PRQAGG"];
"PriorityQueueAggregate(a:SetCategory)" -> "PriorityQueueAggregate(a:Type)"

"PriorityQueueAggregate(a:OrderedSet)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=PRQAGG"];
"PriorityQueueAggregate(a:OrderedSet)" ->
   "PriorityQueueAggregate(a:SetCategory)"

@
<<PRQAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"PriorityQueueAggregate(a:Type)" [color=lightblue];
"PriorityQueueAggregate(a:Type)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{QueueAggregate}{QUAGG}
\pagepic{ps/v102queueaggregate.ps}{QUAGG}{1.00}

{\bf See:}\\
\pageto{DequeueAggregate}{DQAGG}
\pagefrom{BagAggregate}{BGAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{QUAGG}{any?} &
\cross{QUAGG}{bag} &
\cross{QUAGG}{back} &
\cross{QUAGG}{coerce} &
\cross{QUAGG}{copy} \\
\cross{QUAGG}{count} &
\cross{QUAGG}{dequeue!} &
\cross{QUAGG}{empty} &
\cross{QUAGG}{empty?} &
\cross{QUAGG}{enqueue!} \\
\cross{QUAGG}{eq?} &
\cross{QUAGG}{eval} &
\cross{QUAGG}{every?} &
\cross{QUAGG}{extract!} &
\cross{QUAGG}{front} \\
\cross{QUAGG}{hash} &
\cross{QUAGG}{insert!} &
\cross{QUAGG}{inspect} &
\cross{QUAGG}{latex} &
\cross{QUAGG}{length} \\
\cross{QUAGG}{less?} &
\cross{QUAGG}{map} &
\cross{QUAGG}{map!} &
\cross{QUAGG}{member?} &
\cross{QUAGG}{members} \\
\cross{QUAGG}{more?} &
\cross{QUAGG}{parts} &
\cross{QUAGG}{rotate!} &
\cross{QUAGG}{sample} &
\cross{QUAGG}{size?} \\
\cross{QUAGG}{\#?} &
\cross{QUAGG}{?=?} &
\cross{QUAGG}{?\~{}=?} &&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{QUAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 back : % -> S                        
 dequeue! : % -> S
 enqueue! : (S,%) -> S                
 front : % -> S
 length : % -> NonNegativeInteger     
 rotate! : % -> %                     
\end{verbatim}

These exports come from BagAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %                        
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S                    
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %                 
 inspect : % -> S
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category QUAGG QueueAggregate>>=
)abbrev category QUAGG QueueAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A queue is a bag where the first item inserted is the first 
++ item extracted.
QueueAggregate(S:Type): Category == BagAggregate S with
   finiteAggregate
   enqueue_!: (S, %) -> S
     ++ enqueue!(x,q) inserts x into the queue q at the back end.
   dequeue_!: % -> S
     ++ dequeue! s destructively extracts the first (top) element 
     ++ from queue q. The element previously second in the queue becomes 
     ++ the first element. Error: if q is empty.
   rotate_!: % -> %
     ++ rotate! q rotates queue q so that the element at the front of
     ++ the queue goes to the back of the queue.
     ++ Note: rotate! q is equivalent to enqueue!(dequeue!(q)).
   length: % -> NonNegativeInteger
     ++ length(q) returns the number of elements in the queue.
     ++ Note: \axiom{length(q) = #q}.
   front: % -> S
     ++ front(q) returns the element at the front of the queue.
     ++ The queue q is unchanged by this operation.
     ++ Error: if q is empty.
   back: % -> S
     ++ back(q) returns the element at the back of the queue.
     ++ The queue q is unchanged by this operation.
     ++ Error: if q is empty.

@
<<QUAGG.dotabb>>=
"QUAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=QUAGG"];
"QUAGG" -> "BGAGG"

@
<<QUAGG.dotfull>>=
"QueueAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=QUAGG"];
"QueueAggregate(a:Type)" -> "BagAggregate(a:Type)"

"QueueAggregate(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=QUAGG"];
"QueueAggregate(a:SetCategory)" -> "QueueAggregate(a:Type)"

@
<<QUAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"QueueAggregate(a:Type)" [color=lightblue];
"QueueAggregate(a:Type)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{SetAggregate}{SETAGG}
\pagepic{ps/v102setaggregate.ps}{SETAGG}{1.00}

{\bf See:}\\
\pageto{FiniteSetAggregate}{FSAGG}
\pageto{MultisetAggregate}{MSETAGG}
\pagefrom{Collection}{CLAGG}
\pagefrom{SetCategory}{SETCAT}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SETAGG}{any?} &
\cross{SETAGG}{brace} &
\cross{SETAGG}{coerce} &
\cross{SETAGG}{construct} &
\cross{SETAGG}{convert} \\
\cross{SETAGG}{copy} &
\cross{SETAGG}{count} &
\cross{SETAGG}{difference} &
\cross{SETAGG}{empty} &
\cross{SETAGG}{empty?} \\
\cross{SETAGG}{eq?} &
\cross{SETAGG}{eval} &
\cross{SETAGG}{every?} &
\cross{SETAGG}{find} &
\cross{SETAGG}{hash} \\
\cross{SETAGG}{intersect} &
\cross{SETAGG}{latex} &
\cross{SETAGG}{less?} &
\cross{SETAGG}{map} &
\cross{SETAGG}{map!} \\
\cross{SETAGG}{member?} &
\cross{SETAGG}{members} &
\cross{SETAGG}{more?} &
\cross{SETAGG}{parts} &
\cross{SETAGG}{reduce} \\
\cross{SETAGG}{remove} &
\cross{SETAGG}{removeDuplicates} &
\cross{SETAGG}{sample} &
\cross{SETAGG}{select} &
\cross{SETAGG}{set} \\
\cross{SETAGG}{size?} &
\cross{SETAGG}{subset?} &
\cross{SETAGG}{symmetricDifference} &
\cross{SETAGG}{union} &
\cross{SETAGG}{\#?} \\
\cross{SETAGG}{?$<$?} &
\cross{SETAGG}{?=?} &
\cross{SETAGG}{?\~{}=?} &&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{SETAGG}{partiallyOrderedSet}}
is true if a set with $<$ which is transitive, but 
not($a < b$ or $a = b$) does not necessarily imply $b<a$.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 brace : List S -> %
 brace : () -> %
 difference : (%,%) -> %      
 intersect : (%,%) -> %
 set : List S -> %
 set : () -> %                        
 subset? : (%,%) -> Boolean
 union : (%,%) -> %
 ?<? : (%,%) -> Boolean
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 difference : (%,S) -> %
 symmetricDifference : (%,%) -> %
 union : (S,%) -> %
 union : (%,S) -> %
\end{verbatim}

These exports come from SetCategory():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger
 latex : % -> String
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
\end{verbatim}

These exports come from Collection(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 construct : List S -> %
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %                        
 count : ((S -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 count : (S,%) -> NonNegativeInteger 
     if S has SETCAT 
     and $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List Equation S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,Equation S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,S,S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,List S,List S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 find : ((S -> Boolean),%) -> Union(S,"failed")
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 members : % -> List S if $ has finiteAggregate
 member? : (S,%) -> Boolean 
     if S has SETCAT and $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
     if S has SETCAT 
     and $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
     if $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove : (S,%) -> % 
     if S has SETCAT 
     and $ has finiteAggregate
 removeDuplicates : % -> % 
     if S has SETCAT 
     and $ has finiteAggregate
 sample : () -> %                     
 select : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger 
     if $ has finiteAggregate
\end{verbatim}

<<category SETAGG SetAggregate>>=
)abbrev category SETAGG SetAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: 14 Oct, 1993 by RSS
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A set category lists a collection of set-theoretic operations
++ useful for both finite sets and multisets.
++ Note however that finite sets are distinct from multisets.
++ Although the operations defined for set categories are
++ common to both, the relationship between the two cannot
++ be described by inclusion or inheritance.
SetAggregate(S:SetCategory):
  Category == Join(SetCategory, Collection(S)) with
   partiallyOrderedSet
   "<"         : (%, %) -> Boolean
     ++ s < t returns true if all elements of set aggregate s are also
     ++ elements of set aggregate t.
   brace       : () -> %
     ++ brace()$D (otherwise written {}$D)
     ++ creates an empty set aggregate of type D.
     ++ This form is considered obsolete. Use \axiomFun{set} instead.
   brace       : List S -> %
     ++ brace([x,y,...,z]) 
     ++ creates a set aggregate containing items x,y,...,z.
     ++ This form is considered obsolete. Use \axiomFun{set} instead.
   set	       : () -> %
     ++ set()$D creates an empty set aggregate of type D.
   set	       : List S -> %
     ++ set([x,y,...,z]) creates a set aggregate containing items x,y,...,z.
   intersect: (%, %) -> %
     ++ intersect(u,v) returns the set aggregate w consisting of
     ++ elements common to both set aggregates u and v.
     ++ Note: equivalent to the notation (not currently supported)
     ++ {x for x in u | member?(x,v)}.
   difference  : (%, %) -> %
     ++ difference(u,v) returns the set aggregate w consisting of
     ++ elements in set aggregate u but not in set aggregate v.
     ++ If u and v have no elements in common, \axiom{difference(u,v)}
     ++ returns a copy of u.
     ++ Note: equivalent to the notation (not currently supported)
     ++ \axiom{{x for x in u | not member?(x,v)}}.
   difference  : (%, S) -> %
     ++ difference(u,x) returns the set aggregate u with element x removed.
     ++ If u does not contain x, a copy of u is returned.
     ++ Note: \axiom{difference(s, x) = difference(s, {x})}.
   symmetricDifference : (%, %) -> %
     ++ symmetricDifference(u,v) returns the set aggregate of elements x 
     ++ which are members of set aggregate u or set aggregate v but 
     ++ not both. If u and v have no elements in common, 
     ++ \axiom{symmetricDifference(u,v)} returns a copy of u.
     ++ Note: \axiom{symmetricDifference(u,v) = 
     ++  union(difference(u,v),difference(v,u))}
   subset?     : (%, %) -> Boolean
     ++ subset?(u,v) tests if u is a subset of v.
     ++ Note: equivalent to
     ++ \axiom{reduce(and,{member?(x,v) for x in u},true,false)}.
   union       : (%, %) -> %
     ++ union(u,v) returns the set aggregate of elements which are members
     ++ of either set aggregate u or v.
   union       : (%, S) -> %
     ++ union(u,x) returns the set aggregate u with the element x added.
     ++ If u already contains x, \axiom{union(u,x)} returns a copy of u.
   union       : (S, %) -> %
     ++ union(x,u) returns the set aggregate u with the element x added.
     ++ If u already contains x, \axiom{union(x,u)} returns a copy of u.
 add
  symmetricDifference(x, y)    == union(difference(x, y), difference(y, x))
  union(s:%, x:S) == union(s, {x})
  union(x:S, s:%) == union(s, {x})
  difference(s:%, x:S) == difference(s, {x})

@
<<SETAGG.dotabb>>=
"SETAGG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SETAGG"];
"SETAGG" -> "SETCAT"
"SETAGG" -> "CLAGG"

@
<<SETAGG.dotfull>>=
"SetAggregate(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SETAGG"];
"SetAggregate(a:SetCategory)" -> "SetCategory()"
"SetAggregate(a:SetCategory)" -> "Collection(a:SetCategory)"

@
<<SETAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"SetAggregate(a:SetCategory)" [color=lightblue];
"SetAggregate(a:SetCategory)" -> "SetCategory()"
"SetAggregate(a:SetCategory)" -> "Collection(a:SetCategory)"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Collection(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=CLAGG"];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];

}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{StackAggregate}{SKAGG}
\pagepic{ps/v102stackaggregate.ps}{SKAGG}{1.00}

{\bf See:}\\
\pageto{DequeueAggregate}{DQAGG}
\pagefrom{BagAggregate}{BGAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SKAGG}{any?} &
\cross{SKAGG}{bag} &
\cross{SKAGG}{coerce} &
\cross{SKAGG}{copy} &
\cross{SKAGG}{count} \\
\cross{SKAGG}{depth} &
\cross{SKAGG}{empty} &
\cross{SKAGG}{empty?} &
\cross{SKAGG}{eq?} &
\cross{SKAGG}{eval} \\
\cross{SKAGG}{every?} &
\cross{SKAGG}{extract!} &
\cross{SKAGG}{hash} &
\cross{SKAGG}{insert!} &
\cross{SKAGG}{inspect} \\
\cross{SKAGG}{latex} &
\cross{SKAGG}{less?} &
\cross{SKAGG}{map} &
\cross{SKAGG}{map!} &
\cross{SKAGG}{member?} \\
\cross{SKAGG}{members} &
\cross{SKAGG}{more?} &
\cross{SKAGG}{parts} &
\cross{SKAGG}{pop!} &
\cross{SKAGG}{push!} \\
\cross{SKAGG}{sample} &
\cross{SKAGG}{size?} &
\cross{SKAGG}{top} &
\cross{SKAGG}{\#?} &
\cross{SKAGG}{?=?} \\
\cross{SKAGG}{?\~{}=?} &&&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{SKAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 depth : % -> NonNegativeInteger       
 pop! : % -> S                         
 push! : (S,%) -> S
 top : % -> S
\end{verbatim}

These exports come from BagAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %                     
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 empty : () -> %
 empty? : % -> Boolean                 
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S                     
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S                      
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                      
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category SKAGG StackAggregate>>=
)abbrev category SKAGG StackAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A stack is a bag where the last item inserted is the first item extracted.
StackAggregate(S:Type): Category == BagAggregate S with
   finiteAggregate
   push_!: (S,%) -> S
     ++ push!(x,s) pushes x onto stack s, i.e. destructively changing s
     ++ so as to have a new first (top) element x.
     ++ Afterwards, pop!(s) produces x and pop!(s) produces the original s.
   pop_!: % -> S
     ++ pop!(s) returns the top element x, destructively removing x from s.
     ++ Note: Use \axiom{top(s)} to obtain x without removing it from s.
     ++ Error: if s is empty.
   top: % -> S
     ++ top(s) returns the top element x from s; s remains unchanged.
     ++ Note: Use \axiom{pop!(s)} to obtain x and remove it from s.
   depth: % -> NonNegativeInteger
     ++ depth(s) returns the number of elements of stack s.
     ++ Note: \axiom{depth(s) = #s}.


@
<<SKAGG.dotabb>>=
"SKAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=SKAGG"];
"SKAGG" -> "BGAGG"

@
<<SKAGG.dotfull>>=
"StackAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SKAGG"];
"StackAggregate(a:Type)" -> "BagAggregate(a:Type)"

"StackAggregate(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=SKAGG"];
"StackAggregate(a:SetCategory)" -> "StackAggregate(a:Type)"

@
<<SKAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"StackAggregate(a:Type)" [color=lightblue];
"StackAggregate(a:Type)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{UnaryRecursiveAggregate}{URAGG}
\pagepic{ps/v102unaryrecursiveaggregate.ps}{URAGG}{1.00}

{\bf See:}\\
\pageto{StreamAggregate}{STAGG}
\pagefrom{RecursiveAggregate}{RCAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{URAGG}{any?} &
\cross{URAGG}{children} &
\cross{URAGG}{child?} &
\cross{URAGG}{coerce} &
\cross{URAGG}{concat} \\
\cross{URAGG}{concat!} &
\cross{URAGG}{copy} &
\cross{URAGG}{count} &
\cross{URAGG}{cycleEntry} &
\cross{URAGG}{cycleLength} \\
\cross{URAGG}{cycleSplit!} &
\cross{URAGG}{cycleTail} &
\cross{URAGG}{cyclic?} &
\cross{URAGG}{distance} &
\cross{URAGG}{empty} \\
\cross{URAGG}{empty?} &
\cross{URAGG}{eq?} &
\cross{URAGG}{eval} &
\cross{URAGG}{every?} &
\cross{URAGG}{first} \\
\cross{URAGG}{hash} &
\cross{URAGG}{last} &
\cross{URAGG}{latex} &
\cross{URAGG}{leaf?} &
\cross{URAGG}{leaves} \\
\cross{URAGG}{less?} &
\cross{URAGG}{map} &
\cross{URAGG}{map!} &
\cross{URAGG}{member?} &
\cross{URAGG}{members} \\
\cross{URAGG}{more?} &
\cross{URAGG}{nodes} &
\cross{URAGG}{node?} &
\cross{URAGG}{parts} &
\cross{URAGG}{rest} \\
\cross{URAGG}{sample} &
\cross{URAGG}{second} &
\cross{URAGG}{setchildren!} &
\cross{URAGG}{setelt} &
\cross{URAGG}{setfirst!} \\
\cross{URAGG}{setlast!} &
\cross{URAGG}{setrest!} &
\cross{URAGG}{setvalue!} &
\cross{URAGG}{size?} &
\cross{URAGG}{split!} \\
\cross{URAGG}{tail} &
\cross{URAGG}{third} &
\cross{URAGG}{value} &
\cross{URAGG}{\#?} &
\cross{URAGG}{?.last} \\
\cross{URAGG}{?.rest} &
\cross{URAGG}{?.first} &
\cross{URAGG}{?.value} &
\cross{URAGG}{?=?} &
\cross{URAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{URAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\item {\bf \cross{URAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 concat : (S,%) -> %
 concat! : (%,S) -> % if $ has shallowlyMutable
 concat! : (%,%) -> % if $ has shallowlyMutable
 first : % -> S
 first : (%,NonNegativeInteger) -> %
 rest : % -> %
 setfirst! : (%,S) -> S if $ has shallowlyMutable
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 children : % -> List %               
 concat : (%,%) -> %                  
 cycleEntry : % -> %                  
 cycleLength : % -> NonNegativeInteger
 cycleSplit! : % -> % if $ has shallowlyMutable
 cycleTail : % -> %
 cyclic? : % -> Boolean               
 last : % -> S                        
 last : (%,NonNegativeInteger) -> %
 leaf? : % -> Boolean
 less? : (%,NonNegativeInteger) -> Boolean
 more? : (%,NonNegativeInteger) -> Boolean
 nodes : % -> List %                  
 node? : (%,%) -> Boolean if S has SETCAT
 rest : (%,NonNegativeInteger) -> %
 second : % -> S
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,first,S) -> S if $ has shallowlyMutable
 setelt : (%,last,S) -> S if $ has shallowlyMutable
 setelt : (%,rest,%) -> % if $ has shallowlyMutable
 setlast! : (%,S) -> S if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 split! : (%,Integer) -> % if $ has shallowlyMutable
 tail : % -> %                        
 third : % -> S
 value : % -> S                       
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?.first : (%,first) -> S             
 ?.last : (%,last) -> S               
 ?.rest : (%,rest) -> %
\end{verbatim}

These exports come from RecursiveAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 child? : (%,%) -> Boolean if S has SETCAT
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 distance : (%,%) -> Integer
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 leaves : % -> List S                 
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 parts : % -> List S if $ has finiteAggregate
 sample : () -> %                     
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 setrest! : (%,%) -> % if $ has shallowlyMutable
 ?.value : (%,value) -> S
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category URAGG UnaryRecursiveAggregate>>=
)abbrev category URAGG UnaryRecursiveAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A unary-recursive aggregate is a one where nodes may have either
++ 0 or 1 children.
++ This aggregate models, though not precisely, a linked
++ list possibly with a single cycle.
++ A node with one children models a non-empty list, with the
++ \spadfun{value} of the list designating the head, or \spadfun{first}, 
++ of the list, and the child designating the tail, or \spadfun{rest}, 
++ of the list. A node with no child then designates the empty list.
++ Since these aggregates are recursive aggregates, they may be cyclic.
UnaryRecursiveAggregate(S:Type): Category == RecursiveAggregate S with
   concat: (%,%) -> %
      ++ concat(u,v) returns an aggregate w consisting of the elements of u
      ++ followed by the elements of v.
      ++ Note: \axiom{v = rest(w,#a)}.
   concat: (S,%) -> %
      ++ concat(x,u) returns aggregate consisting of x followed by
      ++ the elements of u.
      ++ Note: if \axiom{v = concat(x,u)} then \axiom{x = first v}
      ++ and \axiom{u = rest v}.
   first: % -> S
      ++ first(u) returns the first element of u
      ++ (equivalently, the value at the current node).
   elt: (%,"first") -> S
      ++ elt(u,"first") (also written: \axiom{u . first}) 
      ++ is equivalent to first u.
   first: (%,NonNegativeInteger) -> %
      ++ first(u,n) returns a copy of the first n (\axiom{n >= 0}) 
      ++ elements of u.
   rest: % -> %
      ++ rest(u) returns an aggregate consisting of all but the first
      ++ element of u
      ++ (equivalently, the next node of u).
   elt: (%,"rest") -> %
      ++ elt(%,"rest") (also written: \axiom{u.rest}) is
      ++ equivalent to \axiom{rest u}.
   rest: (%,NonNegativeInteger) -> %
      ++ rest(u,n) returns the \axiom{n}th (n >= 0) node of u.
      ++ Note: \axiom{rest(u,0) = u}.
   last: % -> S
      ++ last(u) resturn the last element of u.
      ++ Note: for lists, \axiom{last(u) = u . (maxIndex u) = u . (# u - 1)}.
   elt: (%,"last") -> S
      ++ elt(u,"last") (also written: \axiom{u . last}) is equivalent 
      ++ to last u.
   last: (%,NonNegativeInteger) -> %
      ++ last(u,n) returns a copy of the last n (\axiom{n >= 0}) nodes of u.
      ++ Note: \axiom{last(u,n)} is a list of n elements.
   tail: % -> %
      ++ tail(u) returns the last node of u.
      ++ Note: if u is \axiom{shallowlyMutable},
      ++ \axiom{setrest(tail(u),v) = concat(u,v)}.
   second: % -> S
      ++ second(u) returns the second element of u.
      ++ Note: \axiom{second(u) = first(rest(u))}.
   third: % -> S
      ++ third(u) returns the third element of u.
      ++ Note: \axiom{third(u) = first(rest(rest(u)))}.
   cycleEntry: % -> %
      ++ cycleEntry(u) returns the head of a top-level cycle contained in
      ++ aggregate u, or \axiom{empty()} if none exists.
   cycleLength: % -> NonNegativeInteger
      ++ cycleLength(u) returns the length of a top-level cycle
      ++ contained  in aggregate u, or 0 is u has no such cycle.
   cycleTail: % -> %
      ++ cycleTail(u) returns the last node in the cycle, or
      ++ empty if none exists.
   if % has shallowlyMutable then
      concat_!: (%,%) -> %
	++ concat!(u,v) destructively concatenates v to the end of u.
	++ Note: \axiom{concat!(u,v) = setlast_!(u,v)}.
      concat_!: (%,S) -> %
	++ concat!(u,x) destructively adds element x to the end of u.
	++ Note: \axiom{concat!(a,x) = setlast!(a,[x])}.
      cycleSplit_!: % -> %
	++ cycleSplit!(u) splits the aggregate by dropping off the cycle.
	++ The value returned is the cycle entry, or nil if none exists.
	++ For example, if \axiom{w = concat(u,v)} is the cyclic list where 
	++ v is the head of the cycle, \axiom{cycleSplit!(w)} will drop v 
	++ off w thus destructively changing w to u, and returning v.
      setfirst_!: (%,S) -> S
	++ setfirst!(u,x) destructively changes the first element of a to x.
      setelt: (%,"first",S) -> S
	++ setelt(u,"first",x) (also written: \axiom{u.first := x}) is
	++ equivalent to \axiom{setfirst!(u,x)}.
      setrest_!: (%,%) -> %
	++ setrest!(u,v) destructively changes the rest of u to v.
      setelt: (%,"rest",%) -> %
	++ setelt(u,"rest",v) (also written: \axiom{u.rest := v}) is 
	++ equivalent to \axiom{setrest!(u,v)}.
      setlast_!: (%,S) -> S
	++ setlast!(u,x) destructively changes the last element of u to x.
      setelt: (%,"last",S) -> S
	++ setelt(u,"last",x) (also written: \axiom{u.last := b})
	++ is equivalent to \axiom{setlast!(u,v)}.
      split_!: (%,Integer) -> %
	 ++ split!(u,n) splits u into two aggregates: \axiom{v = rest(u,n)}
	 ++ and \axiom{w = first(u,n)}, returning \axiom{v}.
	 ++ Note: afterwards \axiom{rest(u,n)} returns \axiom{empty()}.
 add
  cycleMax ==> 1000

  findCycle: % -> %

  elt(x, "first") == first x
  elt(x,  "last") == last x
  elt(x,  "rest") == rest x
  second x	  == first rest x
  third x	  == first rest rest x
  cyclic? x	  == not empty? x and not empty? findCycle x
  last x	  == first tail x

  nodes x ==
    l := empty()$List(%)
    while not empty? x repeat
      l := concat(x, l)
      x := rest x
    reverse_! l

  children x ==
    l := empty()$List(%)
    empty? x => l
    concat(rest x,l)

  leaf? x == empty? x

  value x ==
    empty? x => error "value of empty object"
    first x

  less?(l, n) ==
    i := n::Integer
    while i > 0 and not empty? l repeat (l := rest l; i := i - 1)
    i > 0

  more?(l, n) ==
    i := n::Integer
    while i > 0 and not empty? l repeat (l := rest l; i := i - 1)
    zero?(i) and not empty? l

  size?(l, n) ==
    i := n::Integer
    while not empty? l and i > 0 repeat (l := rest l; i := i - 1)
    empty? l and zero? i

  #x ==
    for k in 0.. while not empty? x repeat
      k = cycleMax and cyclic? x => error "cyclic list"
      x := rest x
    k

  tail x ==
    empty? x => error "empty list"
    y := rest x
    for k in 0.. while not empty? y repeat
      k = cycleMax and cyclic? x => error "cyclic list"
      y := rest(x := y)
    x

  findCycle x ==
    y := rest x
    while not empty? y repeat
      if eq?(x, y) then return x
      x := rest x
      y := rest y
      if empty? y then return y
      if eq?(x, y) then return y
      y := rest y
    y

  cycleTail x ==
    empty?(y := x := cycleEntry x) => x
    z := rest x
    while not eq?(x,z) repeat (y := z; z := rest z)
    y

  cycleEntry x ==
    empty? x => x
    empty?(y := findCycle x) => y
    z := rest y
    for l in 1.. while not eq?(y,z) repeat z := rest z
    y := x
    for k in 1..l repeat y := rest y
    while not eq?(x,y) repeat (x := rest x; y := rest y)
    x

  cycleLength x ==
    empty? x => 0
    empty?(x := findCycle x) => 0
    y := rest x
    for k in 1.. while not eq?(x,y) repeat y := rest y
    k

  rest(x, n) ==
    for i in 1..n repeat
      empty? x => error "Index out of range"
      x := rest x
    x

  if % has finiteAggregate then
    last(x, n) ==
      n > (m := #x) => error "index out of range"
      copy rest(x, (m - n)::NonNegativeInteger)

  if S has SetCategory then
    x = y ==
      eq?(x, y) => true
      for k in 0.. while not empty? x and not empty? y repeat
	k = cycleMax and cyclic? x => error "cyclic list"
	first x ^= first y => return false
	x := rest x
	y := rest y
      empty? x and empty? y

    node?(u, v) ==
      for k in 0.. while not empty? v repeat
	u = v => return true
	k = cycleMax and cyclic? v => error "cyclic list"
	v := rest v
      u=v

  if % has shallowlyMutable then
    setelt(x, "first", a) == setfirst_!(x, a)
    setelt(x,  "last", a) == setlast_!(x, a)
    setelt(x,  "rest", a) == setrest_!(x, a)
    concat(x:%, y:%)	  == concat_!(copy x, y)

    setlast_!(x, s) ==
      empty? x => error "setlast: empty list"
      setfirst_!(tail x, s)
      s

    setchildren_!(u,lv) ==
      #lv=1 => setrest_!(u, first lv)
      error "wrong number of children specified"

    setvalue_!(u,s) == setfirst_!(u,s)

    split_!(p, n) ==
      n < 1 => error "index out of range"
      p := rest(p, (n - 1)::NonNegativeInteger)
      q := rest p
      setrest_!(p, empty())
      q

    cycleSplit_! x ==
      empty?(y := cycleEntry x) or eq?(x, y) => y
      z := rest x
      while not eq?(z, y) repeat (x := z; z := rest z)
      setrest_!(x, empty())
      y

@
<<URAGG.dotabb>>=
"URAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=URAGG"];
"URAGG" -> "RCAGG"

@
<<URAGG.dotfull>>=
"UnaryRecursiveAggregate(a:Type)" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=URAGG"];
"UnaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

@
<<URAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"UnaryRecursiveAggregate(a:Type)" [color=lightblue];
"UnaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

"RecursiveAggregate(a:Type)" [color=lightblue];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
\chapter{Category Layer 6}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{AbelianGroup}{ABELGRP}
\pagepic{ps/v102abeliangroup.ps}{ABELGRP}{0.75}

{\bf See:}\\
\pageto{LeftModule}{LMODULE}
\pageto{NonAssociativeRng}{NARNG}
\pageto{OrderedAbelianGroup}{OAGROUP}
\pageto{RightModule}{RMODULE}
\pageto{Rng}{RNG}
\pagefrom{CancellationAbelianMonoid}{CABMON}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ABELGRP}{0} &
\cross{ABELGRP}{coerce} &
\cross{ABELGRP}{hash} &
\cross{ABELGRP}{latex} &
\cross{ABELGRP}{sample} \\
\cross{ABELGRP}{subtractIfCan} &
\cross{ABELGRP}{zero?} &
\cross{ABELGRP}{?\~{}=?} &
\cross{ABELGRP}{?*?} &
\cross{ABELGRP}{?+?} \\
\cross{ABELGRP}{?-?} &
\cross{ABELGRP}{-?} &
\cross{ABELGRP}{?=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 -? : % -> %                          
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 subtractIfCan : (%,%) -> Union(%,"failed")
 ?*? : (Integer,%) -> %               
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
\end{verbatim}

These exports come from CancellationAbelianMonoid():
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 sample : () -> %                     
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category ABELGRP AbelianGroup>>=
)abbrev category ABELGRP AbelianGroup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The class of abelian groups, i.e. additive monoids where
++ each element has an additive inverse.
++
++ Axioms:
++   \spad{-(-x) = x}
++   \spad{x+(-x) = 0}
-- following domain must be compiled with subsumption disabled
AbelianGroup(): Category == CancellationAbelianMonoid with
      "-": % -> %                      
        ++ -x is the additive inverse of x.
      "-": (%,%) -> %                  
        ++ x-y is the difference of x and y
        ++ i.e. \spad{x + (-y)}.
        -- subsumes the partial subtraction from previous
      "*": (Integer,%) -> %            
        ++ n*x is the product of x by the integer n.
    add
      (x:% - y:%):% == x+(-y)
      subtractIfCan(x:%, y:%):Union(%, "failed") == (x-y)::Union(%,"failed")
      n:NonNegativeInteger * x:% == (n::Integer) * x
      import RepeatedDoubling(%)
      if not (% has Ring) then
        n:Integer * x:% ==
          zero? n => 0
          n>0 => double(n pretend PositiveInteger,x)
          double((-n) pretend PositiveInteger,-x)

@
<<ABELGRP.dotabb>>=
"ABELGRP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELGRP"];
"ABELGRP" -> "CABMON"

@
<<ABELGRP.dotfull>>=
"AbelianGroup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ABELGRP"];
"AbelianGroup()" -> "CancellationAbelianMonoid()"

@
<<ABELGRP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "AbelianGroup()"
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "RepeatedSquaring(Monad)"

"RepeatedSquaring(Monad)" [color="#00EE00"];
"RepeatedSquaring(Monad)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "RepeatedDoubling(AbelianGroup)"

"RepeatedDoubling(AbelianGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(AbelianSemiGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianSemiGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SETCAT..."
"AbelianSemiGroup()" -> "RepeatedDoubling(AbelianSemiGroup)"

"SETCAT..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Dictionary}{DIAGG}
\pagepic{ps/v102dictionary.ps}{DIAGG}{1.00}

{\bf See:}\\
\pageto{FiniteSetAggregate}{FSAGG}
\pageto{KeyedDictionary}{KDAGG}
\pagefrom{DictionaryOperations}{DIOPS}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DIAGG}{any?} &
\cross{DIAGG}{bag} &
\cross{DIAGG}{coerce} &
\cross{DIAGG}{construct} &
\cross{DIAGG}{convert} \\
\cross{DIAGG}{copy} &
\cross{DIAGG}{count} &
\cross{DIAGG}{dictionary} &
\cross{DIAGG}{empty} &
\cross{DIAGG}{empty?} \\
\cross{DIAGG}{eq?} &
\cross{DIAGG}{eval} &
\cross{DIAGG}{every?} &
\cross{DIAGG}{extract!} &
\cross{DIAGG}{find} \\
\cross{DIAGG}{hash} &
\cross{DIAGG}{insert!} &
\cross{DIAGG}{inspect} &
\cross{DIAGG}{latex} &
\cross{DIAGG}{less?} \\
\cross{DIAGG}{map} &
\cross{DIAGG}{map!} &
\cross{DIAGG}{member?} &
\cross{DIAGG}{members} &
\cross{DIAGG}{more?} \\
\cross{DIAGG}{parts} &
\cross{DIAGG}{reduce} &
\cross{DIAGG}{remove} &
\cross{DIAGG}{remove!} &
\cross{DIAGG}{removeDuplicates} \\
\cross{DIAGG}{sample} &
\cross{DIAGG}{select} &
\cross{DIAGG}{select!} &
\cross{DIAGG}{size?} &
\cross{DIAGG}{\#?} \\
\cross{DIAGG}{?\~{}=?} &
\cross{DIAGG}{?=?} &&&
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{DIAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 dictionary : List S -> %
 select! : ((S -> Boolean),%) -> % if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 remove! : ((S -> Boolean),%) -> % if $ has finiteAggregate
\end{verbatim}

These exports come from DictionaryOperations(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %                    
 coerce : % -> OutputForm if S has SETCAT
 construct : List S -> %
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %                        
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 dictionary : () -> %                 
 empty : () -> %
 empty? : % -> Boolean                
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S                    
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S                     
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
       if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove : (S,%) -> % if S has SETCAT and $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 sample : () -> %                     
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category DIAGG Dictionary>>=
)abbrev category DIAGG Dictionary
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A dictionary is an aggregate in which entries can be inserted,
++ searched for and removed. Duplicates are thrown away on insertion.
++ This category models the usual notion of dictionary which involves
++ large amounts of data where copying is impractical.
++ Principal operations are thus destructive (non-copying) ones.
Dictionary(S:SetCategory): Category ==
 DictionaryOperations S add
   dictionary l ==
     d := dictionary()
     for x in l repeat insert_!(x, d)
     d

   if % has finiteAggregate then
    -- remove(f:S->Boolean,t:%)  == remove_!(f, copy t)
    -- select(f, t)	   == select_!(f, copy t)
     select_!(f, t)	 == remove_!(not f #1, t)

     --extract_! d ==
     --	 empty? d => error "empty dictionary"
     --	 remove_!(x := first parts d, d, 1)
     --	 x

     s = t ==
       eq?(s,t) => true
       #s ^= #t => false
       _and/[member?(x, t) for x in parts s]

     remove_!(f:S->Boolean, t:%) ==
       for m in parts t repeat if f m then remove_!(m, t)
       t

@
<<DIAGG.dotabb>>=
"DIAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=DIAGG"];
"DIAGG" -> "DIOPS"

@
<<DIAGG.dotfull>>=
"Dictionary(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIAGG"];
"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"Dictionary(Record(a:SetCategory,b:SetCategory))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=DIAGG"];
"Dictionary(Record(a:SetCategory,b:SetCategory))" ->
    "Dictionary(a:SetCategory)"

@
<<DIAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Dictionary(a:SetCategory)" [color=lightblue];
"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

"BagAggregate(a:SetCategory)" [color=seagreen];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"Collection(a:SetCategory)" [color=seagreen];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "Aggregate()"

"Aggregate()" [color=lightblue];
"Aggregate()" -> "Type()"

"Type()" [color=lightblue];
"Type()" -> "Category"

"Category" [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DequeueAggregate}{DQAGG}
\pagepic{ps/v102dequeueaggregate.ps}{DQAGG}{1.00}

{\bf See:}\\
\pagefrom{QueueAggregate}{QUAGG}
\pagefrom{StackAggregate}{SKAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DQAGG}{any?} &
\cross{DQAGG}{back} &
\cross{DQAGG}{bag} &
\cross{DQAGG}{bottom!} &
\cross{DQAGG}{coerce} \\
\cross{DQAGG}{copy} &
\cross{DQAGG}{count} &
\cross{DQAGG}{depth} &
\cross{DQAGG}{dequeue} &
\cross{DQAGG}{dequeue!} \\
\cross{DQAGG}{empty} &
\cross{DQAGG}{empty?} &
\cross{DQAGG}{enqueue!} &
\cross{DQAGG}{eq?} &
\cross{DQAGG}{eval} \\
\cross{DQAGG}{every?} &
\cross{DQAGG}{extract!} &
\cross{DQAGG}{extractBottom!} &
\cross{DQAGG}{extractTop!} &
\cross{DQAGG}{front} \\
\cross{DQAGG}{hash} &
\cross{DQAGG}{height} &
\cross{DQAGG}{insert!} &
\cross{DQAGG}{insertBottom!} &
\cross{DQAGG}{insertTop!} \\
\cross{DQAGG}{inspect} &
\cross{DQAGG}{latex} &
\cross{DQAGG}{length} &
\cross{DQAGG}{less?} &
\cross{DQAGG}{map} \\
\cross{DQAGG}{map!} &
\cross{DQAGG}{members} &
\cross{DQAGG}{member?} &
\cross{DQAGG}{more?} &
\cross{DQAGG}{parts} \\
\cross{DQAGG}{pop!} &
\cross{DQAGG}{push!} &
\cross{DQAGG}{reverse!} &
\cross{DQAGG}{rotate!} &
\cross{DQAGG}{sample} \\
\cross{DQAGG}{size?} &
\cross{DQAGG}{top} &
\cross{DQAGG}{top!} &
\cross{DQAGG}{\#?} &
\cross{DQAGG}{?=?} \\
\cross{DQAGG}{?\~{}=?} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 bottom! : % -> S                     
 dequeue : () -> %                    
 dequeue : List S -> %
 extractBottom! : % -> S
 extractTop! : % -> S                 
 height : % -> NonNegativeInteger     
 insertBottom! : (S,%) -> S           
 insertTop! : (S,%) -> S
 reverse! : % -> %
 top! : % -> S
\end{verbatim}

These exports come from StackAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %
 coerce : % -> OutputForm if S has SETCAT
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 depth : % -> NonNegativeInteger      
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S                    
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S                     
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 members : % -> List S if $ has finiteAggregate
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 pop! : % -> S
 push! : (S,%) -> S                   
 sample : () -> %
 size? : (%,NonNegativeInteger) -> Boolean
 top : % -> S                         
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from QueueAggregate(S:Type):
\begin{verbatim}
 back : % -> S                        
 dequeue! : % -> S
 enqueue! : (S,%) -> S                
 front : % -> S
 length : % -> NonNegativeInteger
 rotate! : % -> %                     
\end{verbatim}

<<category DQAGG DequeueAggregate>>=
)abbrev category DQAGG DequeueAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A dequeue is a doubly ended stack, that is, a bag where first items
++ inserted are the first items extracted, at either the front or 
++ the back end of the data structure.
DequeueAggregate(S:Type):
 Category == Join(StackAggregate S,QueueAggregate S) with
   dequeue: () -> %
     ++ dequeue()$D creates an empty dequeue of type D.
   dequeue: List S -> %
     ++ dequeue([x,y,...,z]) creates a dequeue with first (top or front)
     ++ element x, second element y,...,and last (bottom or back) element z.
   height: % -> NonNegativeInteger
     ++ height(d) returns the number of elements in dequeue d.
     ++ Note: \axiom{height(d) = # d}.
   top_!: % -> S
     ++ top!(d) returns the element at the top (front) of the dequeue.
   bottom_!: % -> S
     ++ bottom!(d) returns the element at the bottom (back) of the dequeue.
   insertTop_!: (S,%) -> S
     ++ insertTop!(x,d) destructively inserts x into the dequeue d, that is,
     ++ at the top (front) of the dequeue.
     ++ The element previously at the top of the dequeue becomes the
     ++ second in the dequeue, and so on.
   insertBottom_!: (S,%) -> S
     ++ insertBottom!(x,d) destructively inserts x into the dequeue d
     ++ at the bottom (back) of the dequeue.
   extractTop_!: % -> S
     ++ extractTop!(d) destructively extracts the top (front) element
     ++ from the dequeue d.
     ++ Error: if d is empty.
   extractBottom_!: % -> S
     ++ extractBottom!(d) destructively extracts the bottom (back) element
     ++ from the dequeue d.
     ++ Error: if d is empty.
   reverse_!: % -> %
     ++ reverse!(d) destructively replaces d by its reverse dequeue, i.e.
     ++ the top (front) element is now the bottom (back) element, and so on.

@
<<DQAGG.dotabb>>=
"DQAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=DQAGG"];
"DQAGG" -> "SKAGG"
"DQAGG" -> "QUAGG"

@
<<DQAGG.dotfull>>=
"DequeueAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DQAGG"];
"DequeueAggregate(a:Type)" -> "StackAggregate(a:Type)"
"DequeueAggregate(a:Type)" -> "QueueAggregate(a:Type)"

"DequeueAggregate(a:SetCategory)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=DQAGG"];
"DequeueAggregate(a:SetCategory)" -> "DequeueAggregate(a:Type)"

@
<<DQAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DequeueAggregate(a:Type)" [color=lightblue];
"DequeueAggregate(a:Type)" -> "StackAggregate(a:Type)"
"DequeueAggregate(a:Type)" -> "QueueAggregate(a:Type)"

"StackAggregate(a:Type)" [color=lightblue];
"StackAggregate(a:Type)" -> "BagAggregate(a:Type)"

"QueueAggregate(a:Type)" [color=lightblue];
"QueueAggregate(a:Type)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "..."

"..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ExtensibleLinearAggregate}{ELAGG}
\pagepic{ps/v102extensiblelinearaggregate.ps}{ELAGG}{1.00}

{\bf See:}\\
\pageto{ListAggregate}{LSAGG}
\pagefrom{LinearAggregate}{LNAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ELAGG}{any?} &
\cross{ELAGG}{coerce} &
\cross{ELAGG}{concat} &
\cross{ELAGG}{concat!} &
\cross{ELAGG}{construct} \\
\cross{ELAGG}{copy} &
\cross{ELAGG}{convert} &
\cross{ELAGG}{count} &
\cross{ELAGG}{delete} &
\cross{ELAGG}{delete!} \\
\cross{ELAGG}{elt} &
\cross{ELAGG}{empty} &
\cross{ELAGG}{empty?} &
\cross{ELAGG}{entries} &
\cross{ELAGG}{entry?} \\
\cross{ELAGG}{eval} &
\cross{ELAGG}{every?} &
\cross{ELAGG}{eq?} &
\cross{ELAGG}{fill!} &
\cross{ELAGG}{find} \\
\cross{ELAGG}{first} &
\cross{ELAGG}{hash} &
\cross{ELAGG}{index?} &
\cross{ELAGG}{indices} &
\cross{ELAGG}{insert} \\
\cross{ELAGG}{insert!} &
\cross{ELAGG}{latex} &
\cross{ELAGG}{less?} &
\cross{ELAGG}{map} &
\cross{ELAGG}{map!} \\
\cross{ELAGG}{maxIndex} &
\cross{ELAGG}{member?} &
\cross{ELAGG}{members} &
\cross{ELAGG}{merge!} &
\cross{ELAGG}{minIndex} \\
\cross{ELAGG}{more?} &
\cross{ELAGG}{new} &
\cross{ELAGG}{parts} &
\cross{ELAGG}{qelt} &
\cross{ELAGG}{qsetelt!} \\
\cross{ELAGG}{reduce} &
\cross{ELAGG}{remove} &
\cross{ELAGG}{remove!} &
\cross{ELAGG}{removeDuplicates} &
\cross{ELAGG}{removeDuplicates!} \\
\cross{ELAGG}{sample} &
\cross{ELAGG}{select} &
\cross{ELAGG}{select!} &
\cross{ELAGG}{setelt} &
\cross{ELAGG}{size?} \\
\cross{ELAGG}{swap!} &
\cross{ELAGG}{\#?} &
\cross{ELAGG}{?=?} &
\cross{ELAGG}{?.?} &
\cross{ELAGG}{?\~{}=? } \\
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{ELAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 concat! : (%,S) -> %
 delete! : (%,Integer) -> %
 delete! : (%,UniversalSegment Integer) -> %
 insert! : (%,%,Integer) -> %         
 insert! : (S,%,Integer) -> %
 merge! : (((S,S) -> Boolean),%,%) -> %
 remove! : ((S -> Boolean),%) -> %
 removeDuplicates! : % -> % if S has SETCAT
 select! : ((S -> Boolean),%) -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 concat : (%,%) -> %
 concat : (%,S) -> %
 concat! : (%,%) -> %                 
 delete : (%,Integer) -> %            
 delete : (%,UniversalSegment Integer) -> %
 insert : (%,%,Integer) -> %          
 insert : (S,%,Integer) -> %
 merge! : (%,%) -> % if S has ORDSET
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove : (S,%) -> % if S has SETCAT and $ has finiteAggregate
 remove! : (S,%) -> % if S has SETCAT
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
\end{verbatim}

These exports come from LinearAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 concat : List % -> %                 
 concat : (S,%) -> %                  
 construct : List S -> %              
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 convert : % -> InputForm if S has KONVERT INFORM
 elt : (%,Integer,S) -> S
 empty : () -> %                      
 empty? : % -> Boolean
 entries : % -> List S                
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate and S has SETCAT
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 index? : (Integer,%) -> Boolean      
 indices : % -> List Integer
 fill! : (%,S) -> % if $ has shallowlyMutable
 find : ((S -> Boolean),%) -> Union(S,"failed")
 first : % -> S if Integer has ORDSET
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : (((S,S) -> S),%,%) -> %        
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 maxIndex : % -> Integer if Integer has ORDSET
 new : (NonNegativeInteger,S) -> %    
 members : % -> List S if $ has finiteAggregate
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 qelt : (%,Integer) -> S
 qsetelt! : (%,Integer,S) -> S 
          if $ has shallowlyMutable
 reduce : (((S,S) -> S),%) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT and $ has finiteAggregate
 sample : () -> %                     
 setelt : (%,Integer,S) -> S if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?.? : (%,Integer) -> S               
 ?.? : (%,UniversalSegment Integer) -> %
\end{verbatim}

<<category ELAGG ExtensibleLinearAggregate>>=
)abbrev category ELAGG ExtensibleLinearAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An extensible aggregate is one which allows insertion and deletion of 
++ entries. These aggregates are models of lists and streams which are 
++ represented by linked structures so as to make insertion, deletion, and
++ concatenation efficient. However, access to elements of these
++ extensible aggregates is generally slow since access is made from the end.
++ See \spadtype{FlexibleArray} for an exception.
ExtensibleLinearAggregate(S:Type):Category == LinearAggregate S with
   shallowlyMutable
   concat_!: (%,S) -> %
     ++ concat!(u,x) destructively adds element x to the end of u.
   concat_!: (%,%) -> %
     ++ concat!(u,v) destructively appends v to the end of u.
     ++ v is unchanged
   delete_!: (%,Integer) -> %
     ++ delete!(u,i) destructively deletes the \axiom{i}th element of u.
     ++
     ++E Data:=Record(age:Integer,gender:String)
     ++E a1:AssociationList(String,Data):=table()
     ++E a1."tim":=[55,"male"]$Data
     ++E delete!(a1,1)

   delete_!: (%,UniversalSegment(Integer)) -> %
     ++ delete!(u,i..j) destructively deletes elements u.i through u.j.
   remove_!: (S->Boolean,%) -> %
     ++ remove!(p,u) destructively removes all elements x of
     ++ u such that \axiom{p(x)} is true.
   insert_!: (S,%,Integer) -> %
     ++ insert!(x,u,i) destructively inserts x into u at position i.
   insert_!: (%,%,Integer) -> %
     ++ insert!(v,u,i) destructively inserts aggregate v into u 
     ++ at position i.
   merge_!: ((S,S)->Boolean,%,%) -> %
     ++ merge!(p,u,v) destructively merges u and v using predicate p.
   select_!: (S->Boolean,%) -> %
     ++ select!(p,u) destructively changes u by keeping only values 
     ++ x such that \axiom{p(x)}.
   if S has SetCategory then
     remove_!: (S,%) -> %
       ++ remove!(x,u) destructively removes all values x from u.
     removeDuplicates_!: % -> %
       ++ removeDuplicates!(u) destructively removes duplicates from u.
   if S has OrderedSet then merge_!: (%,%) -> %
       ++ merge!(u,v) destructively merges u and v in ascending order.
 add
   delete(x:%, i:Integer)	   == delete_!(copy x, i)
   delete(x:%, i:UniversalSegment(Integer))	   == delete_!(copy x, i)
   remove(f:S -> Boolean, x:%)   == remove_!(f, copy x)
   insert(s:S, x:%, i:Integer)   == insert_!(s, copy x, i)
   insert(w:%, x:%, i:Integer)   == insert_!(copy w, copy x, i)
   select(f, x)		   == select_!(f, copy x)
   concat(x:%, y:%)	   == concat_!(copy x, y)
   concat(x:%, y:S)	   == concat_!(copy x, new(1, y))
   concat_!(x:%, y:S)	   == concat_!(x, new(1, y))
   if S has SetCategory then
     remove(s:S, x:%)	     == remove_!(s, copy x)
     remove_!(s:S, x:%)	     == remove_!(#1 = s, x)
     removeDuplicates(x:%)   == removeDuplicates_!(copy x)

   if S has OrderedSet then
     merge_!(x, y) == merge_!(_<$S, x, y)

@
<<ELAGG.dotabb>>=
"ELAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=ELAGG"];
"ELAGG" -> "LNAGG"

@
<<ELAGG.dotfull>>=
"ExtensibleLinearAggregate(a:Type)" 
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ELAGG"];
"ExtensibleLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

@
<<ELAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ExtensibleLinearAggregate(a:Type)" [color=lightblue];
"ExtensibleLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "Collection(a:Type)"

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "..."

"..." [color=lightblue];
}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FiniteLinearAggregate}{FLAGG}
\pagepic{ps/v102finitelinearaggregate.ps}{FLAGG}{1.00}

{\bf See:}\\
\pageto{OneDimensionalArrayAggregate}{A1AGG}
\pageto{ListAggregate}{LSAGG}
\pagefrom{LinearAggregate}{LNAGG}
\pagefrom{OrderedSet}{ORDSET}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FLAGG}{any?} &
\cross{FLAGG}{coerce} &
\cross{FLAGG}{concat} &
\cross{FLAGG}{construct} &
\cross{FLAGG}{convert} \\
\cross{FLAGG}{copy} &
\cross{FLAGG}{copyInto!} &
\cross{FLAGG}{count} &
\cross{FLAGG}{delete} &
\cross{FLAGG}{elt} \\
\cross{FLAGG}{empty} &
\cross{FLAGG}{empty?} &
\cross{FLAGG}{entries} &
\cross{FLAGG}{entry?} &
\cross{FLAGG}{eq?} \\
\cross{FLAGG}{eval} &
\cross{FLAGG}{every?} &
\cross{FLAGG}{fill!} &
\cross{FLAGG}{find} &
\cross{FLAGG}{first} \\
\cross{FLAGG}{hash} &
\cross{FLAGG}{index?} &
\cross{FLAGG}{indices} &
\cross{FLAGG}{insert} &
\cross{FLAGG}{latex} \\
\cross{FLAGG}{less?} &
\cross{FLAGG}{map} &
\cross{FLAGG}{map!} &
\cross{FLAGG}{max} &
\cross{FLAGG}{maxIndex} \\
\cross{FLAGG}{member?} &
\cross{FLAGG}{members} &
\cross{FLAGG}{merge} &
\cross{FLAGG}{min} &
\cross{FLAGG}{minIndex} \\
\cross{FLAGG}{more?} &
\cross{FLAGG}{new} &
\cross{FLAGG}{parts} &
\cross{FLAGG}{position} &
\cross{FLAGG}{qelt} \\
\cross{FLAGG}{qsetelt!} &
\cross{FLAGG}{reduce} &
\cross{FLAGG}{remove} &
\cross{FLAGG}{removeDuplicates} &
\cross{FLAGG}{reverse} \\
\cross{FLAGG}{reverse!} &
\cross{FLAGG}{sample} &
\cross{FLAGG}{select} &
\cross{FLAGG}{setelt} &
\cross{FLAGG}{size?} \\
\cross{FLAGG}{sort} &
\cross{FLAGG}{sort!} &
\cross{FLAGG}{sorted?} &
\cross{FLAGG}{swap!} &
\cross{FLAGG}{\#?} \\
\cross{FLAGG}{?.?} &
\cross{FLAGG}{?.?} &
\cross{FLAGG}{?$<$?} &
\cross{FLAGG}{?$<=$?} &
\cross{FLAGG}{?=?} \\
\cross{FLAGG}{?$>$?} &
\cross{FLAGG}{?$>=$?} &
\cross{FLAGG}{?\~{}=?} &&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{FLAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{FLAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 copyInto! : (%,%,Integer) -> % 
          if $ has shallowlyMutable
 merge : (((S,S) -> Boolean),%,%) -> %
 sorted? : (((S,S) -> Boolean),%) -> Boolean
 position : (S,%,Integer) -> Integer if S has SETCAT
 position : ((S -> Boolean),%) -> Integer
 reverse! : % -> % if $ has shallowlyMutable
 sort! : (((S,S) -> Boolean),%) -> % 
          if $ has shallowlyMutable
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 merge : (%,%) -> % if S has ORDSET
 position : (S,%) -> Integer if S has SETCAT
 reverse : % -> %
 sort : % -> % if S has ORDSET
 sort : (((S,S) -> Boolean),%) -> %
 sorted? : % -> Boolean if S has ORDSET
 sort! : % -> % 
          if S has ORDSET and $ has shallowlyMutable
\end{verbatim}

These exports come from LinearAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 concat : List % -> %                 
 concat : (%,%) -> %
 concat : (S,%) -> %                  
 concat : (%,S) -> %
 construct : List S -> %              
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 delete : (%,UniversalSegment Integer) -> %
 delete : (%,Integer) -> %            
 elt : (%,Integer,S) -> S             
 empty : () -> %
 empty? : % -> Boolean                
 entries : % -> List S
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate and S has SETCAT
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 fill! : (%,S) -> % if $ has shallowlyMutable
 find : ((S -> Boolean),%) -> Union(S,"failed")
 first : % -> S if Integer has ORDSET
 hash : % -> SingleInteger if S has SETCAT
 index? : (Integer,%) -> Boolean
 indices : % -> List Integer          
 insert : (S,%,Integer) -> %          
 insert : (%,%,Integer) -> %
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : (((S,S) -> S),%,%) -> %
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 maxIndex : % -> Integer if Integer has ORDSET
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 new : (NonNegativeInteger,S) -> %
 parts : % -> List S if $ has finiteAggregate
 qelt : (%,Integer) -> S              
 qsetelt! : (%,Integer,S) -> S 
          if $ has shallowlyMutable
 reduce : (((S,S) -> S),%) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 remove : (S,%) -> % 
          if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 sample : () -> %                     
 select : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 setelt : (%,Integer,S) -> S 
          if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
 #? : % -> NonNegativeInteger 
          if $ has finiteAggregate
 ?.? : (%,Integer) -> S
 ?.? : (%,UniversalSegment Integer) -> %
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from OrderedSet:
\begin{verbatim}
 max : (%,%) -> % if S has ORDSET
 min : (%,%) -> % if S has ORDSET
 ?<? : (%,%) -> Boolean if S has ORDSET
 ?<=? : (%,%) -> Boolean if S has ORDSET
 ?>? : (%,%) -> Boolean if S has ORDSET
 ?>=? : (%,%) -> Boolean if S has ORDSET
\end{verbatim}

<<category FLAGG FiniteLinearAggregate>>=
)abbrev category FLAGG FiniteLinearAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A finite linear aggregate is a linear aggregate of finite length.
++ The finite property of the aggregate adds several exports to the
++ list of exports from \spadtype{LinearAggregate} such as
++ \spadfun{reverse}, \spadfun{sort}, and so on.
FiniteLinearAggregate(S:Type): Category == LinearAggregate S with
   finiteAggregate
   merge: ((S,S)->Boolean,%,%) -> %
      ++ merge(p,a,b) returns an aggregate c which merges \axiom{a} and b.
      ++ The result is produced by examining each element x of \axiom{a} 
      ++ and y of b successively. If \axiom{p(x,y)} is true, then x is 
      ++ inserted into the result; otherwise y is inserted. If x is 
      ++ chosen, the next element of \axiom{a} is examined, and so on. 
      ++ When all the elements of one aggregate are examined, the 
      ++ remaining elements of the other are appended.
      ++ For example, \axiom{merge(<,[1,3],[2,7,5])} returns 
      ++ \axiom{[1,2,3,7,5]}.
   reverse: % -> %
      ++ reverse(a) returns a copy of \axiom{a} with elements 
      ++ in reverse order.
   sort: ((S,S)->Boolean,%) -> %
      ++ sort(p,a) returns a copy of \axiom{a} sorted using total ordering 
      ++ predicate p.
   sorted?: ((S,S)->Boolean,%) -> Boolean
      ++ sorted?(p,a) tests if \axiom{a} is sorted according to predicate p.
   position: (S->Boolean, %) -> Integer
      ++ position(p,a) returns the index i of the first x in \axiom{a} 
      ++ such that \axiom{p(x)} is true, and \axiom{minIndex(a) - 1} 
      ++ if there is no such x.
   if S has SetCategory then
      position: (S, %)	-> Integer
	++ position(x,a) returns the index i of the first occurrence of 
	++ x in a, and \axiom{minIndex(a) - 1} if there is no such x.
      position: (S,%,Integer) -> Integer
	++ position(x,a,n) returns the index i of the first occurrence of 
	++ x in \axiom{a} where \axiom{i >= n}, and \axiom{minIndex(a) - 1} 
        ++ if no such x is found.
   if S has OrderedSet then
      OrderedSet
      merge: (%,%) -> %
	++ merge(u,v) merges u and v in ascending order.
	++ Note: \axiom{merge(u,v) = merge(<=,u,v)}.
      sort: % -> %
	++ sort(u) returns an u with elements in ascending order.
	++ Note: \axiom{sort(u) = sort(<=,u)}.
      sorted?: % -> Boolean
	++ sorted?(u) tests if the elements of u are in ascending order.
   if % has shallowlyMutable then
      copyInto_!: (%,%,Integer) -> %
	++ copyInto!(u,v,i) returns aggregate u containing a copy of
	++ v inserted at element i.
      reverse_!: % -> %
	++ reverse!(u) returns u with its elements in reverse order.
      sort_!: ((S,S)->Boolean,%) -> %
	++ sort!(p,u) returns u with its elements ordered by p.
      if S has OrderedSet then sort_!: % -> %
	++ sort!(u) returns u with its elements in ascending order.
 add
    if S has SetCategory then
      position(x:S, t:%) == position(x, t, minIndex t)

    if S has OrderedSet then
--    sorted? l	  == sorted?(_<$S, l)
      sorted? l	  == sorted?(#1 < #2 or #1 = #2, l)
      merge(x, y) == merge(_<$S, x, y)
      sort l	  == sort(_<$S, l)

    if % has shallowlyMutable then
      reverse x	 == reverse_! copy x
      sort(f, l) == sort_!(f, copy l)

      if S has OrderedSet then
	sort_! l == sort_!(_<$S, l)

@
<<FLAGG.dotabb>>=
"FLAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=FLAGG"];
"FLAGG" -> "LNAGG"

@
<<FLAGG.dotfull>>=
"FiniteLinearAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FLAGG"];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

@
<<FLAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"
"FiniteLinearAggregate(a:Type)" -> "OrderedSet"

"OrderedSet" [color="#00EE00"];

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "Collection(a:Type)"

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "..."

"..." [color=lightblue];
}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{MultiDictionary}{MDAGG}
\pagepic{ps/v102multidictionary.ps}{MDAGG}{1.00}

{\bf See:}\\
\pageto{MultisetAggregate}{MSETAGG}
\pagefrom{DictionaryOperations}{DIOPS}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{MDAGG}{any?} &
\cross{MDAGG}{bag} &
\cross{MDAGG}{coerce} &
\cross{MDAGG}{construct} &
\cross{MDAGG}{convert} \\
\cross{MDAGG}{copy} &
\cross{MDAGG}{count} &
\cross{MDAGG}{dictionary} &
\cross{MDAGG}{duplicates} &
\cross{MDAGG}{empty} \\
\cross{MDAGG}{empty?} &
\cross{MDAGG}{eq?} &
\cross{MDAGG}{eval} &
\cross{MDAGG}{every?} &
\cross{MDAGG}{extract!} \\
\cross{MDAGG}{find} &
\cross{MDAGG}{hash} &
\cross{MDAGG}{insert!} &
\cross{MDAGG}{inspect} &
\cross{MDAGG}{latex} \\
\cross{MDAGG}{less?} &
\cross{MDAGG}{map} &
\cross{MDAGG}{map!} &
\cross{MDAGG}{member?} &
\cross{MDAGG}{members} \\
\cross{MDAGG}{more?} &
\cross{MDAGG}{parts} &
\cross{MDAGG}{reduce} &
\cross{MDAGG}{remove} &
\cross{MDAGG}{remove!} \\
\cross{MDAGG}{removeDuplicates} &
\cross{MDAGG}{removeDuplicates!} &
\cross{MDAGG}{sample} &
\cross{MDAGG}{select} &
\cross{MDAGG}{select!} \\
\cross{MDAGG}{size?} &
\cross{MDAGG}{\#?} &
\cross{MDAGG}{?=?} &
\cross{MDAGG}{?\~{}=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 insert! : (S,%,NonNegativeInteger) -> %
 removeDuplicates! : % -> %           
 duplicates : % -> List Record(entry:S,count:NonNegativeInteger)
\end{verbatim}

These exports come from DictionaryOperations(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List S -> %                    
 coerce : % -> OutputForm if S has SETCAT
 construct : List S -> %
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %                        
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 dictionary : () -> %                 
 dictionary : List S -> %
 empty : () -> %
 empty? : % -> Boolean                
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 extract! : % -> S                    
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S                     
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove : (S,%) -> % 
          if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 remove! : ((S -> Boolean),%) -> % if $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
 sample : () -> %
 select! : ((S -> Boolean),%) -> % if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger 
          if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category MDAGG MultiDictionary>>=
)abbrev category MDAGG MultiDictionary
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A multi-dictionary is a dictionary which may contain duplicates.
++ As for any dictionary, its size is assumed large so that
++ copying (non-destructive) operations are generally to be avoided.
MultiDictionary(S:SetCategory): Category == DictionaryOperations S with
-- count: (S,%) -> NonNegativeInteger		       ++ multiplicity count
   insert_!: (S,%,NonNegativeInteger) -> %
     ++ insert!(x,d,n) destructively inserts n copies of x into dictionary d.
-- remove_!: (S,%,NonNegativeInteger) -> %
--   ++ remove!(x,d,n) destructively removes (up to) n copies of x from
--   ++ dictionary d.
   removeDuplicates_!: % -> %
     ++ removeDuplicates!(d) destructively removes any duplicate values
     ++ in dictionary d.
   duplicates: % -> List Record(entry:S,count:NonNegativeInteger)
     ++ duplicates(d) returns a list of values which have duplicates in d
--   ++ duplicates(d) returns a list of		     ++ duplicates iterator
-- to become duplicates: % -> Iterator(D,D)

@
<<MDAGG.dotabb>>=
"MDAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=MDAGG"];
"MDAGG" -> "DIOPS"

@
<<MDAGG.dotfull>>=
"MultiDictionary(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MDAGG"];
"MultiDictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

@
<<MDAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"MultiDictionary(a:SetCategory)" [color=lightblue];
"MultiDictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

"BagAggregate(a:SetCategory)" [color=seagreen];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"Collection(a:SetCategory)" [color=seagreen];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "..."

"..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedAbelianMonoid}{OAMON}
\pagepic{ps/v102orderedabelianmonoid.ps}{OAMON}{1.00}

{\bf See:}\\
\pageto{OrderedCancellationAbelianMonoid}{OCAMON}
\pagefrom{AbelianMonoid}{ABELMON}
\pagefrom{OrderedAbelianSemiGroup}{OASGP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OAMON}{0} &
\cross{OAMON}{coerce} &
\cross{OAMON}{hash} &
\cross{OAMON}{latex} &
\cross{OAMON}{max} \\
\cross{OAMON}{min} &
\cross{OAMON}{sample} &
\cross{OAMON}{zero?} &
\cross{OAMON}{?*?} &
\cross{OAMON}{?+?} \\
\cross{OAMON}{?$<$?} &
\cross{OAMON}{?$<=$?} &
\cross{OAMON}{?=?} &
\cross{OAMON}{?$>$?} &
\cross{OAMON}{?$>=$?} \\
\cross{OAMON}{?\~{}=?} &
\cross{OAMON}{?*?} &&&
\end{tabular}

These exports come from OrderedAbelianSemiGroup():
\begin{verbatim}
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 max : (%,%) -> %
 min : (%,%) -> %                     
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
 ?~=? : (%,%) -> Boolean
\end{verbatim}

These exports come from AbelianMonoid():
\begin{verbatim}
 0 : () -> %
 sample : () -> %
 zero? : % -> Boolean                 
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
\end{verbatim}

<<category OAMON OrderedAbelianMonoid>>=
)abbrev category OAMON OrderedAbelianMonoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also abelian monoids, such that the addition
++ preserves the ordering.
OrderedAbelianMonoid(): Category ==
        Join(OrderedAbelianSemiGroup, AbelianMonoid)

@
<<OAMON.dotabb>>=
"OAMON" [color=lightblue,href="bookvol10.2.pdf#nameddest=OAMON"];
"OAMON" -> "OASGP"
"OAMON" -> "ABELMON"

@
<<OAMON.dotfull>>=
"OrderedAbelianMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OAMON"];
"OrderedAbelianMonoid()" -> "OrderedAbelianSemiGroup()"
"OrderedAbelianMonoid()" -> "AbelianMonoid()"

@
<<OAMON.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedAbelianMonoid()" [color=lightblue];
"OrderedAbelianMonoid()" -> "OrderedAbelianSemiGroup()"
"OrderedAbelianMonoid()" -> "AbelianMonoid()"

"OrderedAbelianSemiGroup()" [color=lightblue];
"OrderedAbelianSemiGroup()" -> "OrderedSet()"
"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SETCAT..."

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "ABELSG..."

"SETCAT..." [color=lightblue];
"ABELSG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{StreamAggregate}{STAGG}
\pagepic{ps/v102streamaggregate.ps}{STAGG}{0.50}

{\bf See:}\\
\pagefrom{LinearAggregate}{LNAGG}
\pagefrom{UnaryRecursiveAggregate}{URAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{STAGG}{any?} &
\cross{STAGG}{children} &
\cross{STAGG}{child?} &
\cross{STAGG}{coerce} &
\cross{STAGG}{concat} \\
\cross{STAGG}{concat!} &
\cross{STAGG}{construct} &
\cross{STAGG}{convert} &
\cross{STAGG}{copy} &
\cross{STAGG}{count} \\
\cross{STAGG}{cycleEntry} &
\cross{STAGG}{cycleLength} &
\cross{STAGG}{cycleSplit!} &
\cross{STAGG}{cycleTail} &
\cross{STAGG}{cyclic?} \\
\cross{STAGG}{delete} &
\cross{STAGG}{distance} &
\cross{STAGG}{elt} &
\cross{STAGG}{empty} &
\cross{STAGG}{empty?} \\
\cross{STAGG}{entries} &
\cross{STAGG}{entry?} &
\cross{STAGG}{eq?} &
\cross{STAGG}{eval} &
\cross{STAGG}{every?} \\
\cross{STAGG}{explicitlyFinite?} &
\cross{STAGG}{fill!} &
\cross{STAGG}{find} &
\cross{STAGG}{first} &
\cross{STAGG}{hash} \\
\cross{STAGG}{index?} &
\cross{STAGG}{indices} &
\cross{STAGG}{insert} &
\cross{STAGG}{last} &
\cross{STAGG}{latex} \\
\cross{STAGG}{leaf?} &
\cross{STAGG}{leaves} &
\cross{STAGG}{less?} &
\cross{STAGG}{map} &
\cross{STAGG}{map!} \\
\cross{STAGG}{maxIndex} &
\cross{STAGG}{member?} &
\cross{STAGG}{members} &
\cross{STAGG}{minIndex} &
\cross{STAGG}{more?} \\
\cross{STAGG}{new} &
\cross{STAGG}{nodes} &
\cross{STAGG}{node?} &
\cross{STAGG}{parts} &
\cross{STAGG}{possiblyInfinite?} \\
\cross{STAGG}{qelt} &
\cross{STAGG}{qsetelt!} &
\cross{STAGG}{reduce} &
\cross{STAGG}{remove} &
\cross{STAGG}{removeDuplicates} \\
\cross{STAGG}{rest} &
\cross{STAGG}{sample} &
\cross{STAGG}{second} &
\cross{STAGG}{select} &
\cross{STAGG}{setchildren!} \\
\cross{STAGG}{setelt} &
\cross{STAGG}{setfirst!} &
\cross{STAGG}{setlast!} &
\cross{STAGG}{setrest!} &
\cross{STAGG}{setvalue!} \\
\cross{STAGG}{size?} &
\cross{STAGG}{split!} &
\cross{STAGG}{swap!} &
\cross{STAGG}{tail} &
\cross{STAGG}{third} \\
\cross{STAGG}{value} &
\cross{STAGG}{\#?} &
\cross{STAGG}{?=?} &
\cross{STAGG}{?.?} &
\cross{STAGG}{?.first} \\
\cross{STAGG}{?.last} &
\cross{STAGG}{?.rest} &
\cross{STAGG}{?.value} &
\cross{STAGG}{?\~{}=?} &
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{STAGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 concat : (%,%) -> %                  
 concat : List % -> %                 
 concat! : (%,%) -> % if $ has shallowlyMutable
 fill! : (%,S) -> % if $ has shallowlyMutable
 first : (%,NonNegativeInteger) -> %
 explicitlyFinite? : % -> Boolean     
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 possiblyInfinite? : % -> Boolean
 setelt : (%,Integer,S) -> S if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 ?.? : (%,Integer) -> S
 ?.? : (%,UniversalSegment Integer) -> %
\end{verbatim}

These exports come from UnaryRecursiveAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 children : % -> List %               
 child? : (%,%) -> Boolean if S has SETCAT
 coerce : % -> OutputForm if S has SETCAT
 concat : (S,%) -> %
 concat : (%,S) -> %
 concat! : (%,S) -> % if $ has shallowlyMutable
 copy : % -> %                        
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT 
          and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 cycleEntry : % -> %
 cycleLength : % -> NonNegativeInteger
 cycleSplit! : % -> % if $ has shallowlyMutable
 cycleTail : % -> %                   
 cyclic? : % -> Boolean
 distance : (%,%) -> Integer
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List S,List S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 first : % -> S
 hash : % -> SingleInteger if S has SETCAT
 latex : % -> String if S has SETCAT
 last : % -> S                        
 last : (%,NonNegativeInteger) -> %
 leaf? : % -> Boolean
 leaves : % -> List S                 
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %              
 member? : (S,%) -> Boolean 
          if S has SETCAT 
          and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 nodes : % -> List %                  
 node? : (%,%) -> Boolean if S has SETCAT
 parts : % -> List S if $ has finiteAggregate
 rest : % -> %
 rest : (%,NonNegativeInteger) -> %
 sample : () -> %                     
 second : % -> S
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,first,S) -> S if $ has shallowlyMutable
 setelt : (%,last,S) -> S if $ has shallowlyMutable
 setelt : (%,rest,%) -> % if $ has shallowlyMutable
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 setfirst! : (%,S) -> S if $ has shallowlyMutable
 setlast! : (%,S) -> S if $ has shallowlyMutable
 setrest! : (%,%) -> % if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 split! : (%,Integer) -> % if $ has shallowlyMutable
 tail : % -> %                        
 third : % -> S
 value : % -> S                       
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?.last : (%,last) -> S               
 ?.rest : (%,rest) -> %
 ?.first : (%,first) -> S             
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?.value : (%,value) -> S
\end{verbatim}

These exports come from LinearAggregate(S:Type):
\begin{verbatim}
 construct : List S -> %
 delete : (%,Integer) -> %            
 elt : (%,Integer,S) -> S             
 entries : % -> List S                
 index? : (Integer,%) -> Boolean      
 indices : % -> List Integer
 insert : (S,%,Integer) -> %          
 insert : (%,%,Integer) -> %
 map : (((S,S) -> S),%,%) -> %
 new : (NonNegativeInteger,S) -> %
 qelt : (%,Integer) -> S              
 convert : % -> InputForm if S has KONVERT INFORM
 delete : (%,UniversalSegment Integer) -> %
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate 
          and S has SETCAT
 find : ((S -> Boolean),%) -> Union(S,"failed")
 maxIndex : % -> Integer if Integer has ORDSET
 minIndex : % -> Integer if Integer has ORDSET
 qsetelt! : (%,Integer,S) -> S 
          if $ has shallowlyMutable
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT 
          and $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
          if $ has finiteAggregate
 remove : (S,%) -> % 
          if S has SETCAT 
          and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT 
          and $ has finiteAggregate
 select : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
\end{verbatim}

<<category STAGG StreamAggregate>>=
)abbrev category STAGG StreamAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A stream aggregate is a linear aggregate which possibly has an infinite
++ number of elements. A basic domain constructor which builds stream
++ aggregates is \spadtype{Stream}. From streams, a number of infinite
++ structures such power series can be built. A stream aggregate may
++ also be infinite since it may be cyclic.
++ For example, see \spadtype{DecimalExpansion}.
StreamAggregate(S:Type): Category ==
   Join(UnaryRecursiveAggregate S, LinearAggregate S) with
      explicitlyFinite?: % -> Boolean
	++ explicitlyFinite?(s) tests if the stream has a finite
	++ number of elements, and false otherwise.
	++ Note: for many datatypes, 
        ++ \axiom{explicitlyFinite?(s) = not possiblyInfinite?(s)}.
      possiblyInfinite?: % -> Boolean
	++ possiblyInfinite?(s) tests if the stream s could possibly
	++ have an infinite number of elements.
	++ Note: for many datatypes, 
        ++ \axiom{possiblyInfinite?(s) = not explictlyFinite?(s)}.
 add
   c2: (%, %) -> S

   explicitlyFinite? x == not cyclic? x
   possiblyInfinite? x == cyclic? x
   first(x, n)	       == construct [c2(x, x := rest x) for i in 1..n]

   c2(x, r) ==
     empty? x => error "Index out of range"
     first x

   elt(x:%, i:Integer) ==
     i := i - minIndex x
     (i < 0) or empty?(x := rest(x, i::NonNegativeInteger)) => _
         error "index out of range"
     first x

   elt(x:%, i:UniversalSegment(Integer)) ==
     l := lo(i) - minIndex x
     l < 0 => error "index out of range"
     not hasHi i => copy(rest(x, l::NonNegativeInteger))
     (h := hi(i) - minIndex x) < l => empty()
     first(rest(x, l::NonNegativeInteger), (h - l + 1)::NonNegativeInteger)

   if % has shallowlyMutable then
     concat(x:%, y:%) == concat_!(copy x, y)

     concat l ==
       empty? l => empty()
       concat_!(copy first l, concat rest l)

     map_!(f, l) ==
       y := l
       while not empty? l repeat
	 setfirst_!(l, f first l)
	 l := rest l
       y

     fill_!(x, s) ==
       y := x
       while not empty? y repeat (setfirst_!(y, s); y := rest y)
       x

     setelt(x:%, i:Integer, s:S) ==
       i := i - minIndex x
       (i < 0) or empty?(x := rest(x,i::NonNegativeInteger)) => _
           error "index out of range"
       setfirst_!(x, s)

     setelt(x:%, i:UniversalSegment(Integer), s:S) ==
       (l := lo(i) - minIndex x) < 0 => error "index out of range"
       h := if hasHi i then hi(i) - minIndex x else maxIndex x
       h < l => s
       y := rest(x, l::NonNegativeInteger)
       z := rest(y, (h - l + 1)::NonNegativeInteger)
       while not eq?(y, z) repeat (setfirst_!(y, s); y := rest y)
       s

     concat_!(x:%, y:%) ==
       empty? x => y
       setrest_!(tail x, y)
       x

@
<<STAGG.dotabb>>=
"STAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=STAGG"];
"STAGG" -> "RCAGG"
"STAGG" -> "LNAGG"

@
<<STAGG.dotfull>>=
"StreamAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=STAGG"];
"StreamAggregate(a:Type)" -> "UnaryRecursiveAggregate(a:Type)"
"StreamAggregate(a:Type)" -> "LinearAggregate(a:Type)"

@
<<STAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"StreamAggregate(a:Type)" [color=lightblue];
"StreamAggregate(a:Type)" -> "UnaryRecursiveAggregate(a:Type)"
"StreamAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"UnaryRecursiveAggregate(a:Type)" [color=lightblue];
"UnaryRecursiveAggregate(a:Type)" -> "RecursiveAggregate(a:Type)"

"RecursiveAggregate(a:Type)" [color=lightblue];
"RecursiveAggregate(a:Type)" -> "HomogeneousAggregate(a:Type)"

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "Collection(a:Type)"

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> 
    "HomogeneousAggregate(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HomogeneousAggregate(a:Type)"

"HomogeneousAggregate(a:Type)" [color=lightblue];
"HomogeneousAggregate(a:Type)" -> "..."

"..." [color=lightblue];

}
@
\chapter{Category Layer 7}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{NonAssociativeRng}{NARNG}
\pagepic{ps/v102nonassociativerng.ps}{NARNG}{1.00}

{\bf See:}\\
\pageto{NonAssociativeAlgebra}{NAALG}
\pageto{NonAssociativeRing}{NASRING}
\pagefrom{AbelianGroup}{ABELGRP}
\pagefrom{Monad}{MONAD}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{NARNG}{0} &
\cross{NARNG}{antiCommutator} &
\cross{NARNG}{associator} &
\cross{NARNG}{coerce} &
\cross{NARNG}{commutator} \\
\cross{NARNG}{hash} &
\cross{NARNG}{latex} &
\cross{NARNG}{leftPower} &
\cross{NARNG}{rightPower} &
\cross{NARNG}{sample} \\
\cross{NARNG}{subtractIfCan} &
\cross{NARNG}{zero?} &
\cross{NARNG}{?*?} &
\cross{NARNG}{?**?} &
\cross{NARNG}{?+?} \\
\cross{NARNG}{?-?} &
\cross{NARNG}{-?} &
\cross{NARNG}{?=?} &
\cross{NARNG}{?~=?} &
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 antiCommutator : (%,%) -> %
 associator : (%,%,%) -> %            
 commutator : (%,%) -> %              
\end{verbatim}

These exports come from AbelianGroup():
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
\end{verbatim}

These exports come from Monad():
\begin{verbatim}
 leftPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 ?*? : (%,%) -> %                     
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

<<category NARNG NonAssociativeRng>>=
)abbrev category NARNG NonAssociativeRng
++ Author: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 03 July 1991
++ Basic Operations: +, *, -, **
++ Related Constructors: Rng, Ring, NonAssociativeRing
++ Also See:
++ AMS Classifications:
++ Keywords: not associative ring
++ Reference:
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++ Description:
++  NonAssociativeRng is a basic ring-type structure, not necessarily
++  commutative or associative, and not necessarily with unit.
++  Axioms
++    x*(y+z) = x*y + x*z
++    (x+y)*z = x*z + y*z
++  Common Additional Axioms
++    noZeroDivisors  ab = 0 => a=0 or b=0
NonAssociativeRng(): Category == Join(AbelianGroup,Monad)  with
    associator: (%,%,%) -> %
      ++ associator(a,b,c) returns \spad{(a*b)*c-a*(b*c)}.
    commutator: (%,%) -> %
      ++ commutator(a,b) returns \spad{a*b-b*a}.
    antiCommutator: (%,%) -> %
      ++ antiCommutator(a,b) returns \spad{a*b+b*a}.
  add
    associator(x,y,z) == (x*y)*z - x*(y*z)
    commutator(x,y) == x*y - y*x
    antiCommutator(x,y) == x*y + y*x

@
<<NARNG.dotabb>>=
"NARNG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NARNG"];
"NARNG" -> "ABELGRP"
"NARNG" -> "MONAD"

@
<<NARNG.dotfull>>=
"NonAssociativeRng()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NARNG"];
"NonAssociativeRng()" -> "AbelianGroup()"
"NonAssociativeRng()" -> "Monad()"

@
<<NARNG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "AbelianGroup()"
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "REPSQ..."

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "REPDB..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SETCAT..."
"AbelianSemiGroup()" -> "REPDB..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OneDimensionalArrayAggregate}{A1AGG}
\pagepic{ps/v102onedimensionalarrayaggregate.ps}{A1AGG}{1.00}

{\bf See:}\\
\pageto{BitAggregate}{BTAGG}
\pageto{StringAggregate}{SRAGG}
\pagefrom{FiniteLinearAggregate}{FLAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{A1AGG}{any?} &
\cross{A1AGG}{coerce} &
\cross{A1AGG}{concat} &
\cross{A1AGG}{construct} &
\cross{A1AGG}{convert} \\
\cross{A1AGG}{copy} &
\cross{A1AGG}{copyInto!} &
\cross{A1AGG}{count} &
\cross{A1AGG}{delete} &
\cross{A1AGG}{elt} \\
\cross{A1AGG}{empty} &
\cross{A1AGG}{empty?} &
\cross{A1AGG}{entries} &
\cross{A1AGG}{entry?} &
\cross{A1AGG}{eq?} \\
\cross{A1AGG}{eval} &
\cross{A1AGG}{every?} &
\cross{A1AGG}{fill!} &
\cross{A1AGG}{find} &
\cross{A1AGG}{first} \\
\cross{A1AGG}{hash} &
\cross{A1AGG}{index?} &
\cross{A1AGG}{indices} &
\cross{A1AGG}{insert} &
\cross{A1AGG}{latex} \\
\cross{A1AGG}{less?} &
\cross{A1AGG}{map} &
\cross{A1AGG}{map!} &
\cross{A1AGG}{max} &
\cross{A1AGG}{maxIndex} \\
\cross{A1AGG}{member?} &
\cross{A1AGG}{members} &
\cross{A1AGG}{merge} &
\cross{A1AGG}{min} &
\cross{A1AGG}{minIndex} \\
\cross{A1AGG}{more?} &
\cross{A1AGG}{new} &
\cross{A1AGG}{parts} &
\cross{A1AGG}{position} &
\cross{A1AGG}{qelt} \\
\cross{A1AGG}{qsetelt!} &
\cross{A1AGG}{reduce} &
\cross{A1AGG}{remove} &
\cross{A1AGG}{removeDuplicates} &
\cross{A1AGG}{reverse} \\
\cross{A1AGG}{reverse!} &
\cross{A1AGG}{sample} &
\cross{A1AGG}{select} &
\cross{A1AGG}{setelt} &
\cross{A1AGG}{size?} \\
\cross{A1AGG}{sort} &
\cross{A1AGG}{sort!} &
\cross{A1AGG}{sorted?} &
\cross{A1AGG}{swap!} &
\cross{A1AGG}{\#?} \\
\cross{A1AGG}{?.?} &
\cross{A1AGG}{?$<$?} &
\cross{A1AGG}{?$<=$?} &
\cross{A1AGG}{?\~{}=?} &
\cross{A1AGG}{?=?} \\
\cross{A1AGG}{?$>$?} &
\cross{A1AGG}{?$>=$?} &&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{A1AGG}{shallowlyMutable}}
is true if its values have immediate components that are 
updateable (mutable). Note: the properties of any component 
domain are irrevelant to the shallowlyMutable proper.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if S has SETCAT
 concat : (%,%) -> %
 concat : List % -> %                  
 construct : List S -> %               
 copy : % -> %
 copyInto! : (%,%,Integer) -> % if $ has shallowlyMutable
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 delete : (%,UniversalSegment Integer) -> %
 delete : (%,Integer) -> %             
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 find : ((S -> Boolean),%) -> Union(S,"failed")
 insert : (%,%,Integer) -> %
 map : (((S,S) -> S),%,%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 merge : (((S,S) -> Boolean),%,%) -> %
 parts : % -> List S if $ has finiteAggregate
 position : ((S -> Boolean),%) -> Integer
 position : (S,%,Integer) -> Integer 
          if S has SETCAT
 reduce : (((S,S) -> S),%) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT and $ has finiteAggregate
 reverse! : % -> % if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 sort! : (((S,S) -> Boolean),%) -> % 
          if $ has shallowlyMutable
 sorted? : (((S,S) -> Boolean),%) -> Boolean
 ?.? : (%,UniversalSegment Integer) -> %
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?<? : (%,%) -> Boolean if S has ORDSET
\end{verbatim}

These exports come from FiniteLinearAggregate(S:Type):
\begin{verbatim}
 concat : (S,%) -> %                   
 concat : (%,S) -> %
 convert : % -> InputForm if S has KONVERT INFORM
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT and $ has finiteAggregate
 elt : (%,Integer,S) -> S              
 empty : () -> %
 empty? : % -> Boolean                 
 entries : % -> List S
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate and S has SETCAT
 eq? : (%,%) -> Boolean                
 eval : (%,List S,List S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S and S has SETCAT
 fill! : (%,S) -> % if $ has shallowlyMutable
 first : % -> S if Integer has ORDSET
 hash : % -> SingleInteger if S has SETCAT
 index? : (Integer,%) -> Boolean
 indices : % -> List Integer           
 insert : (S,%,Integer) -> %           
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %               
 max : (%,%) -> % if S has ORDSET
 maxIndex : % -> Integer if Integer has ORDSET
 member? : (S,%) -> Boolean 
          if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 merge : (%,%) -> % if S has ORDSET
 min : (%,%) -> % if S has ORDSET
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 new : (NonNegativeInteger,S) -> %
 position : (S,%) -> Integer if S has SETCAT
 qelt : (%,Integer) -> S               
 qsetelt! : (%,Integer,S) -> S 
          if $ has shallowlyMutable
 remove : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 remove : (S,%) -> % 
          if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT and $ has finiteAggregate
 reverse : % -> %
 sample : () -> %                     
 select : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 setelt : (%,Integer,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 sort : % -> % if S has ORDSET
 sort : (((S,S) -> Boolean),%) -> %
 sort! : % -> % 
          if S has ORDSET and $ has shallowlyMutable
 sorted? : % -> Boolean if S has ORDSET
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?.? : (%,Integer) -> S
 ?~=? : (%,%) -> Boolean if S has SETCAT
 ?>? : (%,%) -> Boolean if S has ORDSET
 ?>=? : (%,%) -> Boolean if S has ORDSET
 ?<=? : (%,%) -> Boolean if S has ORDSET
\end{verbatim}

<<category A1AGG OneDimensionalArrayAggregate>>=
)abbrev category A1AGG OneDimensionalArrayAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ One-dimensional-array aggregates serves as models for one-dimensional 
++ arrays. Categorically, these aggregates are finite linear aggregates
++ with the \spadatt{shallowlyMutable} property, that is, any component of
++ the array may be changed without affecting the
++ identity of the overall array.
++ Array data structures are typically represented by a fixed area in 
++ storage and cannot efficiently grow or shrink on demand as can list 
++ structures (see however \spadtype{FlexibleArray} for a data structure 
++ which is a cross between a list and an array).
++ Iteration over, and access to, elements of arrays is extremely fast
++ (and often can be optimized to open-code).
++ Insertion and deletion however is generally slow since an entirely new
++ data structure must be created for the result.
OneDimensionalArrayAggregate(S:Type): Category ==
    FiniteLinearAggregate S with shallowlyMutable
  add
    parts x	    == [qelt(x, i) for i in minIndex x .. maxIndex x]
    sort_!(f, a) == quickSort(f, a)$FiniteLinearAggregateSort(S, %)

    any?(f, a) ==
      for i in minIndex a .. maxIndex a repeat
	f qelt(a, i) => return true
      false

    every?(f, a) ==
      for i in minIndex a .. maxIndex a repeat
	not(f qelt(a, i)) => return false
      true

    position(f:S -> Boolean, a:%) ==
      for i in minIndex a .. maxIndex a repeat
	f qelt(a, i) => return i
      minIndex(a) - 1

    find(f, a) ==
      for i in minIndex a .. maxIndex a repeat
	f qelt(a, i) => return qelt(a, i)
      "failed"

    count(f:S->Boolean, a:%) ==
      n:NonNegativeInteger := 0
      for i in minIndex a .. maxIndex a repeat
	if f(qelt(a, i)) then n := n+1
      n

    map_!(f, a) ==
      for i in minIndex a .. maxIndex a repeat
	qsetelt_!(a, i, f qelt(a, i))
      a

    setelt(a:%, s:UniversalSegment(Integer), x:S) ==
      l := lo s; h := if hasHi s then hi s else maxIndex a
      l < minIndex a or h > maxIndex a => error "index out of range"
      for k in l..h repeat qsetelt_!(a, k, x)
      x

    reduce(f, a) ==
      empty? a => error "cannot reduce an empty aggregate"
      r := qelt(a, m := minIndex a)
      for k in m+1 .. maxIndex a repeat r := f(r, qelt(a, k))
      r

    reduce(f, a, identity) ==
      for k in minIndex a .. maxIndex a repeat
	identity := f(identity, qelt(a, k))
      identity

    if S has SetCategory then
       reduce(f, a, identity,absorber) ==
	 for k in minIndex a .. maxIndex a while identity ^= absorber
		repeat identity := f(identity, qelt(a, k))
	 identity

-- this is necessary since new has disappeared.
    stupidnew: (NonNegativeInteger, %, %) -> %
    stupidget: List % -> S
-- a and b are not both empty if n > 0
    stupidnew(n, a, b) ==
      zero? n => empty()
      new(n, (empty? a => qelt(b, minIndex b); qelt(a, minIndex a)))
-- at least one element of l must be non-empty
    stupidget l ==
      for a in l repeat
	not empty? a => return first a
      error "Should not happen"

    map(f, a, b) ==
      m := max(minIndex a, minIndex b)
      n := min(maxIndex a, maxIndex b)
      l := max(0, n - m + 1)::NonNegativeInteger
      c := stupidnew(l, a, b)
      for i in minIndex(c).. for j in m..n repeat
	qsetelt_!(c, i, f(qelt(a, j), qelt(b, j)))
      c

--  map(f, a, b, x) ==
--    m := min(minIndex a, minIndex b)
--    n := max(maxIndex a, maxIndex b)
--    l := (n - m + 1)::NonNegativeInteger
--    c := new l
--    for i in minIndex(c).. for j in m..n repeat
--	qsetelt_!(c, i, f(a(j, x), b(j, x)))
--    c

    merge(f, a, b) ==
      r := stupidnew(#a + #b, a, b)
      i := minIndex a
      m := maxIndex a
      j := minIndex b
      n := maxIndex b
      for k in minIndex(r).. while i <= m and j <= n repeat
	if f(qelt(a, i), qelt(b, j)) then
	  qsetelt_!(r, k, qelt(a, i))
	  i := i+1
	else
	  qsetelt_!(r, k, qelt(b, j))
	  j := j+1
      for k in k.. for i in i..m repeat qsetelt_!(r, k, elt(a, i))
      for k in k.. for j in j..n repeat qsetelt_!(r, k, elt(b, j))
      r

    elt(a:%, s:UniversalSegment(Integer)) ==
      l := lo s
      h := if hasHi s then hi s else maxIndex a
      l < minIndex a or h > maxIndex a => error "index out of range"
      r := stupidnew(max(0, h - l + 1)::NonNegativeInteger, a, a)
      for k in minIndex r.. for i in l..h repeat
	qsetelt_!(r, k, qelt(a, i))
      r

    insert(a:%, b:%, i:Integer) ==
      m := minIndex b
      n := maxIndex b
      i < m or i > n => error "index out of range"
      y := stupidnew(#a + #b, a, b)
      for k in minIndex y.. for j in m..i-1 repeat
	qsetelt_!(y, k, qelt(b, j))
      for k in k.. for j in minIndex a .. maxIndex a repeat
	qsetelt_!(y, k, qelt(a, j))
      for k in k.. for j in i..n repeat qsetelt_!(y, k, qelt(b, j))
      y

    copy x ==
      y := stupidnew(#x, x, x)
      for i in minIndex x .. maxIndex x for j in minIndex y .. repeat
	qsetelt_!(y, j, qelt(x, i))
      y

    copyInto_!(y, x, s) ==
      s < minIndex y or s + #x > maxIndex y + 1 =>
					      error "index out of range"
      for i in minIndex x .. maxIndex x for j in s.. repeat
	qsetelt_!(y, j, qelt(x, i))
      y

    construct l ==
--    a := new(#l)
      empty? l => empty()
      a := new(#l, first l)
      for i in minIndex(a).. for x in l repeat qsetelt_!(a, i, x)
      a

    delete(a:%, s:UniversalSegment(Integer)) ==
      l := lo s; h := if hasHi s then hi s else maxIndex a
      l < minIndex a or h > maxIndex a => error "index out of range"
      h < l => copy a
      r := stupidnew((#a - h + l - 1)::NonNegativeInteger, a, a)
      for k in minIndex(r).. for i in minIndex a..l-1 repeat
	qsetelt_!(r, k, qelt(a, i))
      for k in k.. for i in h+1 .. maxIndex a repeat
	qsetelt_!(r, k, qelt(a, i))
      r

    delete(x:%, i:Integer) ==
      i < minIndex x or i > maxIndex x => error "index out of range"
      y := stupidnew((#x - 1)::NonNegativeInteger, x, x)
      for i in minIndex(y).. for j in minIndex x..i-1 repeat
	qsetelt_!(y, i, qelt(x, j))
      for i in i .. for j in i+1 .. maxIndex x repeat
	qsetelt_!(y, i, qelt(x, j))
      y

    reverse_! x ==
      m := minIndex x
      n := maxIndex x
      for i in 0..((n-m) quo 2) repeat swap_!(x, m+i, n-i)
      x

    concat l ==
      empty? l => empty()
      n := _+/[#a for a in l]
      i := minIndex(r := new(n, stupidget l))
      for a in l repeat
	copyInto_!(r, a, i)
	i := i + #a
      r

    sorted?(f, a) ==
      for i in minIndex(a)..maxIndex(a)-1 repeat
	not f(qelt(a, i), qelt(a, i + 1)) => return false
      true

    concat(x:%, y:%) ==
      z := stupidnew(#x + #y, x, y)
      copyInto_!(z, x, i := minIndex z)
      copyInto_!(z, y, i + #x)
      z

    if S has SetCategory then
      x = y ==
	#x ^= #y => false
	for i in minIndex x .. maxIndex x repeat
	  not(qelt(x, i) = qelt(y, i)) => return false
	true

      coerce(r:%):OutputForm ==
	bracket commaSeparate
	      [qelt(r, k)::OutputForm for k in minIndex r .. maxIndex r]

      position(x:S, t:%, s:Integer) ==
	n := maxIndex t
	s < minIndex t or s > n => error "index out of range"
	for k in s..n repeat
	  qelt(t, k) = x => return k
	minIndex(t) - 1

    if S has OrderedSet then
      a < b ==
	for i in minIndex a .. maxIndex a
	  for j in minIndex b .. maxIndex b repeat
	    qelt(a, i) ^= qelt(b, j) => return a.i < b.j
	#a < #b


@
<<A1AGG.dotabb>>=
"A1AGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=A1AGG"];
"A1AGG" -> "FLAGG"

@
<<A1AGG.dotfull>>=
"OneDimensionalArrayAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=A1AGG"];
"OneDimensionalArrayAggregate(a:Type)" -> 
    "FiniteLinearAggregate(a:Type)"

"OneDimensionalArrayAggregate(Character)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=A1AGG"];
"OneDimensionalArrayAggregate(Character)" ->
    "OneDimensionalArrayAggregate(a:Type)"

"OneDimensionalArrayAggregate(Boolean)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=A1AGG"];
"OneDimensionalArrayAggregate(Boolean)" ->    
    "OneDimensionalArrayAggregate(a:Type)"

@
<<A1AGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OneDimensionalArrayAggregate(a:Type)" [color=lightblue];
"OneDimensionalArrayAggregate(a:Type)" -> 
    "FiniteLinearAggregate(a:Type)"

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "CLAGG..."

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" -> "IXAGG..."

"CLAGG..." [color=lightblue];
"IXAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FiniteSetAggregate}{FSAGG}
\pagepic{ps/v102finitesetaggregate.ps}{FSAGG}{0.75}

{\bf See:}\\
\pagefrom{Dictionary}{DIAGG}
\pagefrom{SetAggregate}{SETAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FSAGG}{any?} &
\cross{FSAGG}{bag} &
\cross{FSAGG}{brace} &
\cross{FSAGG}{cardinality} &
\cross{FSAGG}{coerce} \\
\cross{FSAGG}{complement} &
\cross{FSAGG}{construct} &
\cross{FSAGG}{convert} &
\cross{FSAGG}{copy} &
\cross{FSAGG}{count} \\
\cross{FSAGG}{count} &
\cross{FSAGG}{dictionary} &
\cross{FSAGG}{difference} &
\cross{FSAGG}{empty} &
\cross{FSAGG}{empty?} \\
\cross{FSAGG}{eq?} &
\cross{FSAGG}{eval} &
\cross{FSAGG}{every?} &
\cross{FSAGG}{extract!} &
\cross{FSAGG}{find} \\
\cross{FSAGG}{hash} &
\cross{FSAGG}{index} &
\cross{FSAGG}{insert!} &
\cross{FSAGG}{inspect} &
\cross{FSAGG}{intersect} \\
\cross{FSAGG}{latex} &
\cross{FSAGG}{less?} &
\cross{FSAGG}{lookup} &
\cross{FSAGG}{map} &
\cross{FSAGG}{map!} \\
\cross{FSAGG}{max} &
\cross{FSAGG}{member?} &
\cross{FSAGG}{members} &
\cross{FSAGG}{min} &
\cross{FSAGG}{more?} \\
\cross{FSAGG}{parts} &
\cross{FSAGG}{random} &
\cross{FSAGG}{reduce} &
\cross{FSAGG}{remove} &
\cross{FSAGG}{remove!} \\
\cross{FSAGG}{removeDuplicates} &
\cross{FSAGG}{sample} &
\cross{FSAGG}{select} &
\cross{FSAGG}{select!} &
\cross{FSAGG}{set} \\
\cross{FSAGG}{size} &
\cross{FSAGG}{size?} &
\cross{FSAGG}{subset?} &
\cross{FSAGG}{symmetricDifference} &
\cross{FSAGG}{union} \\
\cross{FSAGG}{universe} &
\cross{FSAGG}{\#?} &
\cross{FSAGG}{?$<$?} &
\cross{FSAGG}{?=?} &
\cross{FSAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{FSAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 brace : List S -> %                  
 cardinality : % -> NonNegativeInteger
 coerce : % -> OutputForm
 complement : % -> % if S has FINITE
 construct : List S -> %              
 count : (S,%) -> NonNegativeInteger 
     if S has SETCAT and $ has finiteAggregate
 difference : (%,%) -> %              
 index : PositiveInteger -> % if S has FINITE
 intersect : (%,%) -> %
 lookup : % -> PositiveInteger if S has FINITE
 max : % -> S if S has ORDSET         
 min : % -> S if S has ORDSET
 random : () -> % if S has FINITE
 set : List S -> %                    
 size : () -> NonNegativeInteger if S has FINITE
 subset? : (%,%) -> Boolean
 symmetricDifference : (%,%) -> %
 union : (%,%) -> %                   
 universe : () -> % if S has FINITE
 ?<? : (%,%) -> Boolean               
 ?=? : (%,%) -> Boolean
\end{verbatim}

These exports come from Dictionary(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 bag : List S -> %                    
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %
 count : ((S -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 dictionary : () -> %
 dictionary : List S -> %             
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,S,S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,Equation S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 eval : (%,List Equation S) -> % 
     if S has EVALAB S 
     and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 extract! : % -> S
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger            
 insert! : (S,%) -> %
 inspect : % -> S                     
 latex : % -> String                  
 less? : (%,NonNegativeInteger) -> Boolean
 select! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % 
     if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
     if S has SETCAT 
     and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
     if S has SETCAT 
     and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove : (S,%) -> % 
     if S has SETCAT 
     and $ has finiteAggregate
 remove! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
     if S has SETCAT 
     and $ has finiteAggregate
 sample : () -> %                     
 select : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean
\end{verbatim}

These exports come from SetAggregate(S:SetCategory):
\begin{verbatim}
 brace : () -> %
 difference : (%,S) -> %
 set : () -> %
 union : (%,S) -> %
 union : (S,%) -> %                   
\end{verbatim}

<<category FSAGG FiniteSetAggregate>>=
)abbrev category FSAGG FiniteSetAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: 14 Oct, 1993 by RSS
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A finite-set aggregate models the notion of a finite set, that is,
++ a collection of elements characterized by membership, but not
++ by order or multiplicity.
++ See \spadtype{Set} for an example.
FiniteSetAggregate(S:SetCategory): Category ==
  Join(Dictionary S, SetAggregate S) with
    finiteAggregate
    cardinality: % -> NonNegativeInteger
      ++ cardinality(u) returns the number of elements of u.
      ++ Note: \axiom{cardinality(u) = #u}.
    if S has Finite then
      Finite
      complement: % -> %
	++ complement(u) returns the complement of the set u,
	++ i.e. the set of all values not in u.
      universe: () -> %
	++ universe()$D returns the universal set for finite set aggregate D.
    if S has OrderedSet then
      max: % -> S
	++ max(u) returns the largest element of aggregate u.
      min: % -> S
	++ min(u) returns the smallest element of aggregate u.

 add
   s < t	   == #s < #t and s = intersect(s,t)
   s = t	   == #s = #t and empty? difference(s,t)
   brace l	   == construct l
   set	 l	   == construct l
   cardinality s   == #s
   construct l	   == (s := set(); for x in l repeat insert_!(x,s); s)
   count(x:S, s:%) == (member?(x, s) => 1; 0)
   subset?(s, t)   == #s < #t and _and/[member?(x, t) for x in parts s]

   coerce(s:%):OutputForm ==
     brace [x::OutputForm for x in parts s]$List(OutputForm)

   intersect(s, t) ==
     i := {}
     for x in parts s | member?(x, t) repeat insert_!(x, i)
     i

   difference(s:%, t:%) ==
     m := copy s
     for x in parts t repeat remove_!(x, m)
     m

   symmetricDifference(s, t) ==
     d := copy s
     for x in parts t repeat
       if member?(x, s) then remove_!(x, d) else insert_!(x, d)
     d

   union(s:%, t:%) ==
      u := copy s
      for x in parts t repeat insert_!(x, u)
      u

   if S has Finite then
     universe()	  == {index(i::PositiveInteger) for i in 1..size()$S}
     complement s == difference(universe(), s )
     size()  == 2 ** size()$S
     index i ==
       {index(j::PositiveInteger)$S for j in 1..size()$S | bit?(i-1,j-1)}
     random()  == 
       index((random()$Integer rem (size()$% + 1))::PositiveInteger)

     lookup s ==
       n:PositiveInteger := 1
       for x in parts s repeat _
         n := n + 2 ** ((lookup(x) - 1)::NonNegativeInteger)
       n

   if S has OrderedSet then
     max s ==
       empty?(l := parts s) => error "Empty set"
       reduce("max", l)

     min s ==
       empty?(l := parts s) => error "Empty set"
       reduce("min", l)

@
<<FSAGG.dotabb>>=
"FSAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=FSAGG"];
"FSAGG" -> "DIAGG"
"FSAGG" -> "SETAGG"

@
<<FSAGG.dotfull>>=
"FiniteSetAggregate(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FSAGG"];
"FiniteSetAggregate(a:SetCategory)" -> "Dictionary(a:SetCategory)"
"FiniteSetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"

@
<<FSAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FiniteSetAggregate(a:SetCategory)" [color=lightblue];
"FiniteSetAggregate(a:SetCategory)" -> "Dictionary(a:SetCategory)"
"FiniteSetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"

"SetAggregate(a:SetCategory)" [color=lightblue];
"SetAggregate(a:SetCategory)" -> "SetCategory()"
"SetAggregate(a:SetCategory)" -> "CLAGG..."

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BASTYPE..."
"SetCategory()" -> "KOERCE..."

"Dictionary(a:SetCategory)" [color=lightblue];
"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BGAGG..."
"DictionaryOperations(a:SetCategory)" -> "CLAGG..."

"BGAGG..." [color=lightblue];
"CLAGG..." [color=lightblue];
"BASTYPE..." [color=lightblue];
"KOERCE..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{KeyedDictionary}{KDAGG}
\pagepic{ps/v102keyeddictionary.ps}{KDAGG}{1.00}

{\bf See:}\\
\pageto{TableAggregate}{TBAGG}
\pagefrom{Dictionary}{DIAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{KDAGG}{any?} &
\cross{KDAGG}{bag} &
\cross{KDAGG}{coerce} &
\cross{KDAGG}{construct} &
\cross{KDAGG}{convert} \\
\cross{KDAGG}{copy} &
\cross{KDAGG}{count} &
\cross{KDAGG}{dictionary} &
\cross{KDAGG}{empty} &
\cross{KDAGG}{empty?} \\
\cross{KDAGG}{eq?} &
\cross{KDAGG}{eval} &
\cross{KDAGG}{every?} &
\cross{KDAGG}{extract!} &
\cross{KDAGG}{find} \\
\cross{KDAGG}{hash} &
\cross{KDAGG}{insert!} &
\cross{KDAGG}{inspect} &
\cross{KDAGG}{key?} &
\cross{KDAGG}{keys} \\
\cross{KDAGG}{latex} &
\cross{KDAGG}{less?} &
\cross{KDAGG}{map} &
\cross{KDAGG}{map!} &
\cross{KDAGG}{member?} \\
\cross{KDAGG}{members} &
\cross{KDAGG}{more?} &
\cross{KDAGG}{parts} &
\cross{KDAGG}{reduce} &
\cross{KDAGG}{remove} \\
\cross{KDAGG}{remove!} &
\cross{KDAGG}{removeDuplicates} &
\cross{KDAGG}{sample} &
\cross{KDAGG}{search} &
\cross{KDAGG}{select} \\
\cross{KDAGG}{select!} &
\cross{KDAGG}{size?} &
\cross{KDAGG}{\#?} &
\cross{KDAGG}{?=?} &
\cross{KDAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{KDAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 remove! : (Key,%) -> Union(Entry,"failed")
 search : (Key,%) -> Union(Entry,"failed")
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 key? : (Key,%) -> Boolean
 member? : (Record(key: Key,entry: Entry),%) -> Boolean 
     if Record(key: Key,entry: Entry) has SETCAT 
     and $ has finiteAggregate
 keys : % -> List Key                  
\end{verbatim}

These exports come from Dictionary(R) \\
where R=Record(a:SetCategory,b:SetCategory))\\
and S=Record(key: Key,entry: Entry)
\begin{verbatim}
 any? : ((S) -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 bag : List S -> %
 coerce : % -> OutputForm if S has SETCAT
 construct : List S -> %
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %                         
 count : (S,%) -> NonNegativeInteger 
     if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 dictionary : () -> %
 dictionary : List S -> %
 empty : () -> %                       
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean                
 eval : (%,List S,List S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
     if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 extract! : % -> S
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger if S has SETCAT
 insert! : (S,%) -> %
 inspect : % -> S
 latex : % -> String if S has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % 
     if $ has shallowlyMutable
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
     if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove : (S,%) -> % 
     if S has SETCAT and $ has finiteAggregate
 remove! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
     if S has SETCAT and $ has finiteAggregate
 sample : () -> %
 select : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 select! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger 
     if $ has finiteAggregate
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

<<category KDAGG KeyedDictionary>>=
)abbrev category KDAGG KeyedDictionary
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A keyed dictionary is a dictionary of key-entry pairs for which there is
++ a unique entry for each key.
KeyedDictionary(Key:SetCategory, Entry:SetCategory): Category ==
  Dictionary Record(key:Key,entry:Entry) with
   key?: (Key, %) -> Boolean
     ++ key?(k,t) tests if k is a key in table t.
   keys: % -> List Key
     ++ keys(t) returns the list the keys in table t.
   -- to become keys: % -> Key* and keys: % -> Iterator(Entry,Entry)
   remove_!: (Key, %) -> Union(Entry,"failed")
     ++ remove!(k,t) searches the table t for the key k removing
     ++ (and return) the entry if there.
     ++ If t has no such key, \axiom{remove!(k,t)} returns "failed".
   search: (Key, %) -> Union(Entry,"failed")
     ++ search(k,t) searches the table t for the key k,
     ++ returning the entry stored in t for key k.
     ++ If t has no such key, \axiom{search(k,t)} returns "failed".
 add
   key?(k, t) == search(k, t) case Entry

   member?(p, t) ==
     r := search(p.key, t)
     r case Entry and r::Entry = p.entry

   if % has finiteAggregate then
     keys t == [x.key for x in parts t]

@
<<KDAGG.dotabb>>=
"KDAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=KDAGG"];
"KDAGG" -> "DIAGG"

@
<<KDAGG.dotfull>>=
"KeyedDictionary(a:SetCategory,b:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=KDAGG"];
"KeyedDictionary(a:SetCategory,b:SetCategory)" -> 
    "Dictionary(Record(a:SetCategory,b:SetCategory))"

@
<<KDAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"KeyedDictionary(a:SetCategory,b:SetCategory)" [color=lightblue];
"KeyedDictionary(a:SetCategory,b:SetCategory)" -> 
    "Dictionary(Record(a:SetCategory,b:SetCategory))"

"Dictionary(Record(a:SetCategory,b:SetCategory))" [color=seagreen];
"Dictionary(Record(a:SetCategory,b:SetCategory))" ->
    "Dictionary(a:SetCategory)"

"Dictionary(a:SetCategory)" [color=lightblue];
"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

"BagAggregate(a:SetCategory)" [color=seagreen];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HOAGG..."

"Collection(a:SetCategory)" [color=seagreen];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HOAGG..."

"HOAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{LeftModule}{LMODULE}
\pagepic{ps/v102leftmodule.ps}{LMODULE}{0.90}

{\bf See:}\\
\pageto{BiModule}{BMODULE}
\pageto{Ring}{RING}
\pagefrom{AbelianGroup}{ABELGRP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{LMODULE}{0} &
\cross{LMODULE}{coerce} &
\cross{LMODULE}{hash} &
\cross{LMODULE}{latex} &
\cross{LMODULE}{sample} \\
\cross{LMODULE}{subtractIfCan} &
\cross{LMODULE}{zero?} &
\cross{LMODULE}{?~=?} &
\cross{LMODULE}{?*?} &
\cross{LMODULE}{?+?} \\
\cross{LMODULE}{?-?} &
\cross{LMODULE}{-?} &
\cross{LMODULE}{?=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?*? : (R,%) -> %                     
\end{verbatim}

These exports come from AbelianGroup():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
 ?+? : (%,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?-? : (%,%) -> %                     
 -? : % -> %
\end{verbatim}

<<category LMODULE LeftModule>>=
)abbrev category LMODULE LeftModule
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of left modules over an rng (ring not necessarily with unit).
++ This is an abelian group which supports left multiplation by elements of
++ the rng.
++
++ Axioms:
++   \spad{ (a*b)*x = a*(b*x) }
++   \spad{ (a+b)*x = (a*x)+(b*x) }
++   \spad{ a*(x+y) = (a*x)+(a*y) }
LeftModule(R:Rng):Category == AbelianGroup with
   "*": (R,%) -> %     
     ++ r*x returns the left multiplication of the module element x
     ++ by the ring element r.

@
<<LMODULE.dotabb>>=
"LMODULE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LMODULE"];
"LMODULE" -> "ABELGRP"

@
<<LMODULE.dotfull>>=
"LeftModule(a:Rng)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LMODULE"];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"LeftModule(a:Ring)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=LMODULE"];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

@
<<LMODULE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "RepeatedDoubling(AbelianGroup)"

"RepeatedDoubling(AbelianGroup)" [color="#00EE00"];
"RepeatedDoubling(AbelianGroup)" -> "RepeatedDoubling(a:SetCategory)"

"RepeatedDoubling(a:SetCategory)" [color="#00EE00"];
"RepeatedDoubling(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "ABELMON..."

"ABELMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{ListAggregate}{LSAGG}
\pagepic{ps/v102listaggregate.ps}{LSAGG}{0.50}

{\bf See:}\\
\pageto{AssociationListAggregate}{ALAGG}
\pagefrom{ExtensibleLinearAggregate}{ELAGG}
\pagefrom{FiniteLinearAggregate}{FLAGG}

{\bf Exports:}\\
\begin{tabular}{llll}
\cross{LSAGG}{any?} &
\cross{LSAGG}{children} &
\cross{LSAGG}{child?} &
\cross{LSAGG}{coerce} \\
\cross{LSAGG}{concat} &
\cross{LSAGG}{concat!} &
\cross{LSAGG}{construct} &
\cross{LSAGG}{convert} \\
\cross{LSAGG}{copy} &
\cross{LSAGG}{copyInto!} &
\cross{LSAGG}{count} &
\cross{LSAGG}{cycleEntry} \\
\cross{LSAGG}{cycleLength} &
\cross{LSAGG}{cycleSplit!} &
\cross{LSAGG}{cycleTail} &
\cross{LSAGG}{cyclic?} \\
\cross{LSAGG}{delete} &
\cross{LSAGG}{delete!} &
\cross{LSAGG}{distance} &
\cross{LSAGG}{elt} \\
\cross{LSAGG}{empty} &
\cross{LSAGG}{empty?} &
\cross{LSAGG}{entries} &
\cross{LSAGG}{entry?} \\
\cross{LSAGG}{eq?} &
\cross{LSAGG}{eval} &
\cross{LSAGG}{every?} &
\cross{LSAGG}{explicitlyFinite?} \\
\cross{LSAGG}{fill!} &
\cross{LSAGG}{find} &
\cross{LSAGG}{first} &
\cross{LSAGG}{hash} \\
\cross{LSAGG}{index?} &
\cross{LSAGG}{indices} &
\cross{LSAGG}{insert} &
\cross{LSAGG}{insert!} \\
\cross{LSAGG}{last} &
\cross{LSAGG}{latex} &
\cross{LSAGG}{leaf?} &
\cross{LSAGG}{leaves} \\
\cross{LSAGG}{less?} &
\cross{LSAGG}{list} &
\cross{LSAGG}{map} &
\cross{LSAGG}{map!} \\
\cross{LSAGG}{max} &
\cross{LSAGG}{maxIndex} &
\cross{LSAGG}{member?} &
\cross{LSAGG}{members} \\
\cross{LSAGG}{merge} &
\cross{LSAGG}{merge!} &
\cross{LSAGG}{min} &
\cross{LSAGG}{minIndex} \\
\cross{LSAGG}{more?} &
\cross{LSAGG}{new} &
\cross{LSAGG}{nodes} &
\cross{LSAGG}{node?} \\
\cross{LSAGG}{parts} &
\cross{LSAGG}{position} &
\cross{LSAGG}{possiblyInfinite?} &
\cross{LSAGG}{qelt} \\
\cross{LSAGG}{qsetelt!} &
\cross{LSAGG}{reduce} &
\cross{LSAGG}{remove} &
\cross{LSAGG}{remove!} \\
\cross{LSAGG}{removeDuplicates} &
\cross{LSAGG}{removeDuplicates!} &
\cross{LSAGG}{rest} &
\cross{LSAGG}{reverse} \\
\cross{LSAGG}{reverse!} &
\cross{LSAGG}{sample} &
\cross{LSAGG}{second} &
\cross{LSAGG}{select} \\
\cross{LSAGG}{select!} &
\cross{LSAGG}{setchildren!} &
\cross{LSAGG}{setelt} &
\cross{LSAGG}{setfirst!} \\
\cross{LSAGG}{setlast!} &
\cross{LSAGG}{setrest!} &
\cross{LSAGG}{setvalue!} &
\cross{LSAGG}{size?} \\
\cross{LSAGG}{sort} &
\cross{LSAGG}{sort!} &
\cross{LSAGG}{sorted?} &
\cross{LSAGG}{split!} \\
\cross{LSAGG}{swap!} &
\cross{LSAGG}{tail} &
\cross{LSAGG}{third} &
\cross{LSAGG}{value} \\
\cross{LSAGG}{\#?} &
\cross{LSAGG}{?.?} &
\cross{LSAGG}{?.last} &
\cross{LSAGG}{?.rest} \\
\cross{LSAGG}{?.first} &
\cross{LSAGG}{?.value} &
\cross{LSAGG}{?$<$?} &
\cross{LSAGG}{?$<=$?} \\
\cross{LSAGG}{?=?} &
\cross{LSAGG}{?$>$?} &
\cross{LSAGG}{?$>=$?} &
\cross{LSAGG}{?\~{}=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 copy : % -> %                        
 copyInto! : (%,%,Integer) -> % if $ has shallowlyMutable
 delete! : (%,Integer) -> %
 delete! : (%,UniversalSegment Integer) -> %
 find : ((S -> Boolean),%) -> Union(S,"failed")
 insert! : (S,%,Integer) -> %
 insert! : (%,%,Integer) -> %         
 list : S -> %                        
 map : (((S,S) -> S),%,%) -> %
 merge : (((S,S) -> Boolean),%,%) -> %
 merge! : (((S,S) -> Boolean),%,%) -> %
 new : (NonNegativeInteger,S) -> %
 position : ((S -> Boolean),%) -> Integer
 position : (S,%,Integer) -> Integer if S has SETCAT
 reduce : (((S,S) -> S),%,S) -> S 
          if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
          if S has SETCAT 
          and $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
          if $ has finiteAggregate
 remove! : ((S -> Boolean),%) -> %
 removeDuplicates! : % -> % if S has SETCAT
 reverse! : % -> % if $ has shallowlyMutable
 select : ((S -> Boolean),%) -> % 
          if $ has finiteAggregate
 sort! : (((S,S) -> Boolean),%) -> % 
          if $ has shallowlyMutable
 sorted? : (((S,S) -> Boolean),%) -> Boolean
 ?<? : (%,%) -> Boolean if S has ORDSET
\end{verbatim}

These exports come from StreamAggregate(S:Type):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 children : % -> List %               
 child? : (%,%) -> Boolean if S has SETCAT
 coerce : % -> OutputForm if S has SETCAT
 concat : (%,S) -> %
 concat : List % -> %                 
 concat : (S,%) -> %
 concat : (%,%) -> %                  
 concat! : (%,S) -> %
 concat! : (%,%) -> %                 
 construct : List S -> %
 convert : % -> InputForm if S has KONVERT INFORM
 count : (S,%) -> NonNegativeInteger 
          if S has SETCAT 
          and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 cycleEntry : % -> %
 cycleLength : % -> NonNegativeInteger
 cycleSplit! : % -> % if $ has shallowlyMutable
 cycleTail : % -> %                   
 cyclic? : % -> Boolean
 delete : (%,UniversalSegment Integer) -> %
 delete : (%,Integer) -> %            
 distance : (%,%) -> Integer          
 elt : (%,Integer,S) -> S
 empty : () -> %
 empty? : % -> Boolean                
 entry? : (S,%) -> Boolean 
          if $ has finiteAggregate 
          and S has SETCAT
 entries : % -> List S
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,S,S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,Equation S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 eval : (%,List Equation S) -> % 
          if S has EVALAB S 
          and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 explicitlyFinite? : % -> Boolean
 fill! : (%,S) -> % if $ has shallowlyMutable
 first : % -> S                       
 first : (%,NonNegativeInteger) -> %
 hash : % -> SingleInteger if S has SETCAT
 index? : (Integer,%) -> Boolean
 indices : % -> List Integer          
 insert : (S,%,Integer) -> %
 insert : (%,%,Integer) -> %          
 last : % -> S
 last : (%,NonNegativeInteger) -> %
 latex : % -> String if S has SETCAT
 leaf? : % -> Boolean                 
 leaves : % -> List S
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %              
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 maxIndex : % -> Integer if Integer has ORDSET
 member? : (S,%) -> Boolean 
          if S has SETCAT 
          and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 nodes : % -> List %                  
 node? : (%,%) -> Boolean if S has SETCAT
 parts : % -> List S if $ has finiteAggregate
 possiblyInfinite? : % -> Boolean
 qelt : (%,Integer) -> S              
 qsetelt! : (%,Integer,S) -> S if $ has shallowlyMutable
 remove : (S,%) -> % 
          if S has SETCAT 
          and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
          if S has SETCAT 
          and $ has finiteAggregate
 rest : % -> %
 rest : (%,NonNegativeInteger) -> %
 sample : () -> %
 second : % -> S                      
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,Integer,S) -> S if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,S) -> S 
          if $ has shallowlyMutable
 setelt : (%,last,S) -> S if $ has shallowlyMutable
 setelt : (%,rest,%) -> % if $ has shallowlyMutable
 setelt : (%,first,S) -> S if $ has shallowlyMutable
 setelt : (%,value,S) -> S if $ has shallowlyMutable
 setfirst! : (%,S) -> S if $ has shallowlyMutable
 setlast! : (%,S) -> S if $ has shallowlyMutable
 setrest! : (%,%) -> % if $ has shallowlyMutable
 setvalue! : (%,S) -> S if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 split! : (%,Integer) -> % if $ has shallowlyMutable
 swap! : (%,Integer,Integer) -> Void if $ has shallowlyMutable
 tail : % -> %
 third : % -> S                       
 value : % -> S
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?.last : (%,last) -> S
 ?.rest : (%,rest) -> %               
 ?.first : (%,first) -> S
 ?.value : (%,value) -> S             
 ?.? : (%,Integer) -> S               
 ?.? : (%,UniversalSegment Integer) -> %
 ?=? : (%,%) -> Boolean if S has SETCAT
 ?~=? : (%,%) -> Boolean if S has SETCAT
\end{verbatim}

These exports come from FiniteLinearAggregate(S:Type)
\begin{verbatim}
 max : (%,%) -> % if S has ORDSET
 merge : (%,%) -> % if S has ORDSET
 min : (%,%) -> % if S has ORDSET
 position : (S,%) -> Integer if S has SETCAT
 reverse : % -> %                     
 sort : (((S,S) -> Boolean),%) -> %
 sort : % -> % if S has ORDSET
 sort! : % -> % if S has ORDSET and $ has shallowlyMutable
 sorted? : % -> Boolean if S has ORDSET
 ?<=? : (%,%) -> Boolean if S has ORDSET
 ?>? : (%,%) -> Boolean if S has ORDSET
 ?>=? : (%,%) -> Boolean if S has ORDSET
\end{verbatim}

These exports come from ExtensibleLinearAggregate(S:Type):
\begin{verbatim}
 merge! : (%,%) -> % if S has ORDSET
 remove! : (S,%) -> % if S has SETCAT
 select! : ((S -> Boolean),%) -> %
\end{verbatim}

<<category LSAGG ListAggregate>>=
)abbrev category LSAGG ListAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A list aggregate is a model for a linked list data structure.
++ A linked list is a versatile
++ data structure. Insertion and deletion are efficient and
++ searching is a linear operation.
ListAggregate(S:Type): Category == Join(StreamAggregate S,
   FiniteLinearAggregate S, ExtensibleLinearAggregate S) with
      list: S -> %
	++ list(x) returns the list of one element x.
 add
   cycleMax ==> 1000

   mergeSort: ((S, S) -> Boolean, %, Integer) -> %

   sort_!(f, l)	      == mergeSort(f, l, #l)
   list x		   == concat(x, empty())
   reduce(f, x)		   ==
     empty? x => _
       error "reducing over an empty list needs the 3 argument form"
     reduce(f, rest x, first x)
   merge(f, p, q)	   == merge_!(f, copy p, copy q)

   select_!(f, x) ==
     while not empty? x and not f first x repeat x := rest x
     empty? x => x
     y := x
     z := rest y
     while not empty? z repeat
       if f first z then (y := z; z := rest z)
		    else (z := rest z; setrest_!(y, z))
     x

   merge_!(f, p, q) ==
     empty? p => q
     empty? q => p
     eq?(p, q) => error "cannot merge a list into itself"
     if f(first p, first q)
       then (r := t := p; p := rest p)
       else (r := t := q; q := rest q)
     while not empty? p and not empty? q repeat
       if f(first p, first q)
	 then (setrest_!(t, p); t := p; p := rest p)
	 else (setrest_!(t, q); t := q; q := rest q)
     setrest_!(t, if empty? p then q else p)
     r

   insert_!(s:S, x:%, i:Integer) ==
     i < (m := minIndex x) => error "index out of range"
     i = m => concat(s, x)
     y := rest(x, (i - 1 - m)::NonNegativeInteger)
     z := rest y
     setrest_!(y, concat(s, z))
     x

   insert_!(w:%, x:%, i:Integer) ==
     i < (m := minIndex x) => error "index out of range"
     i = m => concat_!(w, x)
     y := rest(x, (i - 1 - m)::NonNegativeInteger)
     z := rest y
     setrest_!(y, w)
     concat_!(y, z)
     x

   remove_!(f:S -> Boolean, x:%) ==
     while not empty? x and f first x repeat x := rest x
     empty? x => x
     p := x
     q := rest x
     while not empty? q repeat
       if f first q then q := setrest_!(p, rest q)
		    else (p := q; q := rest q)
     x

   delete_!(x:%, i:Integer) ==
     i < (m := minIndex x) => error "index out of range"
     i = m => rest x
     y := rest(x, (i - 1 - m)::NonNegativeInteger)
     setrest_!(y, rest(y, 2))
     x

   delete_!(x:%, i:UniversalSegment(Integer)) ==
     (l := lo i) < (m := minIndex x) => error "index out of range"
     h := if hasHi i then hi i else maxIndex x
     h < l => x
     l = m => rest(x, (h + 1 - m)::NonNegativeInteger)
     t := rest(x, (l - 1 - m)::NonNegativeInteger)
     setrest_!(t, rest(t, (h - l + 2)::NonNegativeInteger))
     x

   find(f, x) ==
     while not empty? x and not f first x repeat x := rest x
     empty? x => "failed"
     first x

   position(f:S -> Boolean, x:%) ==
     for k in minIndex(x).. while not empty? x and not f first x repeat
       x := rest x
     empty? x => minIndex(x) - 1
     k

   mergeSort(f, p, n) ==
     if n = 2 and f(first rest p, first p) then p := reverse_! p
     n < 3 => p
     l := (n quo 2)::NonNegativeInteger
     q := split_!(p, l)
     p := mergeSort(f, p, l)
     q := mergeSort(f, q, n - l)
     merge_!(f, p, q)

   sorted?(f, l) ==
     empty? l => true
     p := rest l
     while not empty? p repeat
       not f(first l, first p) => return false
       p := rest(l := p)
     true

   reduce(f, x, i) ==
     r := i
     while not empty? x repeat (r := f(r, first x); x := rest x)
     r

   if S has SetCategory then
      reduce(f, x, i,a) ==
	r := i
	while not empty? x and r ^= a repeat
	  r := f(r, first x)
	  x := rest x
	r

   new(n, s) ==
     l := empty()
     for k in 1..n repeat l := concat(s, l)
     l

   map(f, x, y) ==
     z := empty()
     while not empty? x and not empty? y repeat
       z := concat(f(first x, first y), z)
       x := rest x
       y := rest y
     reverse_! z

-- map(f, x, y, d) ==
--   z := empty()
--   while not empty? x and not empty? y repeat
--     z := concat(f(first x, first y), z)
--     x := rest x
--     y := rest y
--   z := reverseInPlace z
--   if not empty? x then
--	z := concat_!(z, map(f(#1, d), x))
--   if not empty? y then
--	z := concat_!(z, map(f(d, #1), y))
--   z

   reverse_! x ==
     empty? x => x
     empty?(y := rest x) => x
     setrest_!(x, empty())
     while not empty? y repeat
       z := rest y
       setrest_!(y, x)
       x := y
       y := z
     x

   copy x ==
     y := empty()
     for k in 0.. while not empty? x repeat
       k = cycleMax and cyclic? x => error "cyclic list"
       y := concat(first x, y)
       x := rest x
     reverse_! y

   copyInto_!(y, x, s) ==
     s < (m := minIndex y) => error "index out of range"
     z := rest(y, (s - m)::NonNegativeInteger)
     while not empty? z and not empty? x repeat
       setfirst_!(z, first x)
       x := rest x
       z := rest z
     y

   if S has SetCategory then
     position(w, x, s) ==
       s < (m := minIndex x) => error "index out of range"
       x := rest(x, (s - m)::NonNegativeInteger)
       for k in s.. while not empty? x and w ^= first x repeat
	 x := rest x
       empty? x => minIndex x - 1
       k

     removeDuplicates_! l ==
       p := l
       while not empty? p repeat
	 p := setrest_!(p, remove_!(#1 = first p, rest p))
       l

   if S has OrderedSet then
     x < y ==
	while not empty? x and not empty? y repeat
	  first x ^= first y => return(first x < first y)
	  x := rest x
	  y := rest y
	empty? x => not empty? y
	false

@
<<LSAGG.dotabb>>=
"LSAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=LSAGG"];
"LSAGG" -> "FLAGG"
"LSAGG" -> "ELAGG"

@
<<LSAGG.dotfull>>=
"ListAggregate(a:Type)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LSAGG"];
"ListAggregate(a:Type)" -> "StreamAggregate(a:Type)"
"ListAggregate(a:Type)" -> "FiniteLinearAggregate(a:Type)"
"ListAggregate(a:Type)" -> "ExtensibleLinearAggregate(a:Type)"

"ListAggregate(Record(a:SetCategory,b:SetCategory))" 
 [color=seagreen,href="bookvol10.2.pdf#nameddest=LSAGG"];
"ListAggregate(Record(a:SetCategory,b:SetCategory))" ->
    "ListAggregate(a:Type)"

@
<<LSAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"ListAggregate(a:Type)" [color=lightblue];
"ListAggregate(a:Type)" -> "StreamAggregate(a:Type)"
"ListAggregate(a:Type)" -> "FiniteLinearAggregate(a:Type)"
"ListAggregate(a:Type)" -> "ExtensibleLinearAggregate(a:Type)"

"StreamAggregate(a:Type)" [color=lightblue];
"StreamAggregate(a:Type)" -> "UnaryRecursiveAggregate(a:Type)"
"StreamAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"ExtensibleLinearAggregate(a:Type)" [color=lightblue];
"ExtensibleLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"UnaryRecursiveAggregate(a:Type)" [color=lightblue];
"UnaryRecursiveAggregate(a:Type)" -> "RCAGG..."

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IXAGG..."
"LinearAggregate(a:Type)" -> "CLAGG..."

"CLAGG..." [color=lightblue];
"IXAGG..." [color=lightblue];
"RCAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{MultisetAggregate}{MSETAGG}
\pagepic{ps/v102multisetaggregate.ps}{MSETAGG}{0.75}

{\bf See:}\\
\pageto{OrderedMultisetAggregate}{OMSAGG}
\pagefrom{MultiDictionary}{MDAGG}
\pagefrom{SetAggregate}{SETAGG}

{\bf Exports:}\\
\begin{tabular}{llll}
\cross{MSETAGG}{any?} &
\cross{MSETAGG}{bag} &
\cross{MSETAGG}{brace} &
\cross{MSETAGG}{coerce} \\ 
\cross{MSETAGG}{construct} &
\cross{MSETAGG}{convert} &
\cross{MSETAGG}{copy} &
\cross{MSETAGG}{count} \\
\cross{MSETAGG}{dictionary} &
\cross{MSETAGG}{difference} &
\cross{MSETAGG}{duplicates} &
\cross{MSETAGG}{empty} \\
\cross{MSETAGG}{empty?} &
\cross{MSETAGG}{eq?} &
\cross{MSETAGG}{eval} &
\cross{MSETAGG}{every?} \\
\cross{MSETAGG}{extract!} &
\cross{MSETAGG}{find} &
\cross{MSETAGG}{hash} &
\cross{MSETAGG}{insert!} \\
\cross{MSETAGG}{inspect} &
\cross{MSETAGG}{intersect} &
\cross{MSETAGG}{latex} &
\cross{MSETAGG}{less?} \\
\cross{MSETAGG}{map} &
\cross{MSETAGG}{map!} &
\cross{MSETAGG}{member?} &
\cross{MSETAGG}{members} \\
\cross{MSETAGG}{more?} &
\cross{MSETAGG}{parts} &
\cross{MSETAGG}{reduce} &
\cross{MSETAGG}{remove} \\
\cross{MSETAGG}{remove!} &
\cross{MSETAGG}{removeDuplicates} &
\cross{MSETAGG}{removeDuplicates!} &
\cross{MSETAGG}{sample} \\
\cross{MSETAGG}{select} &
\cross{MSETAGG}{select!} &
\cross{MSETAGG}{set} &
\cross{MSETAGG}{size?} \\
\cross{MSETAGG}{subset?} &
\cross{MSETAGG}{symmetricDifference} &
\cross{MSETAGG}{union} &
\cross{MSETAGG}{\#?} \\
\cross{MSETAGG}{?\~{}=?} &
\cross{MSETAGG}{?$<$?} &
\cross{MSETAGG}{?=?} &
\end{tabular}

These exports come from MultiDictionary(S:SetCategory):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 bag : List S -> %                    
 coerce : % -> OutputForm
 construct : List S -> %              
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
     if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 dictionary : List S -> %             
 dictionary : () -> %
 duplicates : % -> 
     List Record(entry: S,count: NonNegativeInteger)
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 extract! : % -> S
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger            
 insert! : (S,%) -> %
 insert! : (S,%,NonNegativeInteger) -> %
 inspect : % -> S                     
 latex : % -> String                  
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
     if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
     if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove : (S,%) -> % 
     if S has SETCAT and $ has finiteAggregate
 removeDuplicates : % -> % 
     if S has SETCAT and $ has finiteAggregate
 removeDuplicates! : % -> %           
 remove! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove! : (S,%) -> % if $ has finiteAggregate
 select : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 select! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 size? : (%,NonNegativeInteger) -> Boolean
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean              
 ?=? : (%,%) -> Boolean
\end{verbatim}

These exports come from SetAggregate(S:SetCategory):
\begin{verbatim}
 brace : () -> %
 brace : List S -> %                  
 difference : (%,S) -> %
 intersect : (%,%) -> %
 sample : () -> %
 set : () -> %                        
 set : List S -> %
 subset? : (%,%) -> Boolean           
 symmetricDifference : (%,%) -> %
 union : (%,S) -> %                   
 union : (S,%) -> %
 union : (%,%) -> %
 ?<? : (%,%) -> Boolean               
\end{verbatim}

<<category MSETAGG MultisetAggregate>>=
)abbrev category MSETAGG MultisetAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A multi-set aggregate is a set which keeps track of the multiplicity
++ of its elements.
MultisetAggregate(S:SetCategory):
 Category == Join(MultiDictionary S, SetAggregate S)

@
<<MSETAGG.dotabb>>=
"MSETAGG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MSETAGG"];
"MSETAGG" -> "MDAGG"
"MSETAGG" -> "SETAGG"

@
<<MSETAGG.dotfull>>=
"MultisetAggregate(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MSETAGG"];
"MultisetAggregate(a:SetCategory)" -> "MultiDictionary(a:SetCategory)"
"MultisetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"

@
<<MSETAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"MultisetAggregate(a:SetCategory)" [color=lightblue];
"MultisetAggregate(a:SetCategory)" -> "MultiDictionary(a:SetCategory)"
"MultisetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"

"MultiDictionary(a:SetCategory)" [color=lightblue];
"MultiDictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"SetAggregate(a:SetCategory)" [color=lightblue];
"SetAggregate(a:SetCategory)" -> "SETAGG..."
"SetAggregate(a:SetCategory)" -> "CLAGG..."

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BGAGG..."
"DictionaryOperations(a:SetCategory)" -> "CLAGG..."

"BGAGG..." [color=lightblue];
"CLAGG..." [color=lightblue];
"SETAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedCancellationAbelianMonoid}{OCAMON}
\pagepic{ps/v102orderedcancellationabelianmonoid.ps}{OCAMON}{0.75}

{\bf See:}\\
\pageto{OrderedAbelianGroup}{OAGROUP}
\pageto{OrderedAbelianMonoidSup}{OAMONS}
\pagefrom{CancellationAbelianMonoid}{CABMON}
\pagefrom{OrderedAbelianMonoid}{OAMON}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OCAMON}{0} &
\cross{OCAMON}{coerce} &
\cross{OCAMON}{hash} &
\cross{OCAMON}{latex} &
\cross{OCAMON}{max} \\
\cross{OCAMON}{min} &
\cross{OCAMON}{sample} &
\cross{OCAMON}{subtractIfCan} &
\cross{OCAMON}{zero?} &
\cross{OCAMON}{?\~{}=?} \\
\cross{OCAMON}{?*?} &
\cross{OCAMON}{?+?} &
\cross{OCAMON}{?$<$?} &
\cross{OCAMON}{?$<=$?} &
\cross{OCAMON}{?=?} \\
\cross{OCAMON}{?$>$?} &
\cross{OCAMON}{?$>=$?} &&&
\end{tabular}

These exports come from OrderedAbelianMonoid():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 max : (%,%) -> %
 min : (%,%) -> %                     
 sample : () -> %
 zero? : % -> Boolean                 
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              
 ?~=? : (%,%) -> Boolean
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %
\end{verbatim}

These exports come from CancellationAbelianMonoid():
\begin{verbatim}
 subtractIfCan : (%,%) -> Union(%,"failed")
\end{verbatim}

<<category OCAMON OrderedCancellationAbelianMonoid>>=
)abbrev category OCAMON OrderedCancellationAbelianMonoid
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also abelian cancellation monoids, 
++ such that the addition preserves the ordering.
OrderedCancellationAbelianMonoid(): Category ==
        Join(OrderedAbelianMonoid, CancellationAbelianMonoid)

@
<<OCAMON.dotabb>>=
"OCAMON"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OCAMON"];
"OCAMON" -> "OAMON"
"OCAMON" -> "CABMON"

@
<<OCAMON.dotfull>>=
"OrderedCancellationAbelianMonoid()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OCAMON"];
"OrderedCancellationAbelianMonoid()" -> "OrderedAbelianMonoid()"
"OrderedCancellationAbelianMonoid()" -> "CancellationAbelianMonoid()"

@
<<OCAMON.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedCancellationAbelianMonoid()" [color=lightblue];
"OrderedCancellationAbelianMonoid()" -> "OrderedAbelianMonoid()"
"OrderedCancellationAbelianMonoid()" -> "CancellationAbelianMonoid()"

"OrderedAbelianMonoid()" [color=lightblue];
"OrderedAbelianMonoid()" -> "OrderedAbelianSemiGroup()"
"OrderedAbelianMonoid()" -> "AbelianMonoid()"

"OrderedAbelianSemiGroup()" [color=lightblue];
"OrderedAbelianSemiGroup()" -> "OrderedSet()"
"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SETCAT..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "ABELSG..."

"SETCAT..." [color=lightblue];
"ABELSG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{RightModule}{RMODULE}
\pagepic{ps/v102rightmodule.ps}{RMODULE}{1.00}

{\bf See:}\\
\pageto{BiModule}{BMODULE}
\pagefrom{AbelianGroup}{ABELGRP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{RMODULE}{0} &
\cross{RMODULE}{coerce} &
\cross{RMODULE}{hash} &
\cross{RMODULE}{latex} &
\cross{RMODULE}{sample} \\
\cross{RMODULE}{subtractIfCan} &
\cross{RMODULE}{zero?} &
\cross{RMODULE}{?\~{}=?} &
\cross{RMODULE}{?*?} &
\cross{RMODULE}{?+?} \\
\cross{RMODULE}{?-?} &
\cross{RMODULE}{-?} &
\cross{RMODULE}{?=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?*? : (%,R) -> %                     
\end{verbatim}

These exports come from AbelianGroup():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %
 ?=? : (%,%) -> Boolean               
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?-? : (%,%) -> %                     
 -? : % -> %
\end{verbatim}

<<category RMODULE RightModule>>=
)abbrev category RMODULE RightModule
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of right modules over an rng (ring not necessarily 
++ with unit). This is an abelian group which supports right 
++ multiplication by elements of the rng.
++
++ Axioms:
++   \spad{ x*(a*b) = (x*a)*b }
++   \spad{ x*(a+b) = (x*a)+(x*b) }
++   \spad{ (x+y)*x = (x*a)+(y*a) }
RightModule(R:Rng):Category == AbelianGroup with
   "*": (%,R) -> %  
     ++ x*r returns the right multiplication of the module element x
     ++ by the ring element r.

@
<<RMODULE.dotabb>>=
"RMODULE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RMODULE"];
"RMODULE" -> "ABELGRP"

@
<<RMODULE.dotfull>>=
"RightModule(a:Rng)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RMODULE"];
"RightModule(a:Rng)" -> "AbelianGroup()"

"RightModule(a:Ring)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=RMODULE"];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

@
<<RMODULE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "REPDB..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "ABELMON..."

"ABELMON..." [color=lightblue];
"REPDB..." [color="#00EE00"];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Rng}{RNG}
\pagepic{ps/v102rng.ps}{RNG}{1.00}

Rng is a Ring that does not necessarily have a unit.

{\bf See:}\\
\pageto{Ring}{RING}
\pagefrom{AbelianGroup}{ABELGRP}
\pagefrom{SemiGroup}{SGROUP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{RNG}{0} &
\cross{RNG}{coerce} &
\cross{RNG}{hash} &
\cross{RNG}{latex} &
\cross{RNG}{sample} \\
\cross{RNG}{zero?} &
\cross{RNG}{subtractIfCan} &
\cross{RNG}{?*?} &
\cross{RNG}{?**?} &
\cross{RNG}{?+?} \\
\cross{RNG}{?-?} &
\cross{RNG}{-?} &
\cross{RNG}{?=?} &
\cross{RNG}{?\~{}=?} &
\cross{RNG}{?\^{}?} \\
\end{tabular}

These exports come from AbelianGroup():
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (Integer,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
\end{verbatim}

These exports come from SemiGroup():
\begin{verbatim}
 ?*? : (%,%) -> %                     
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,PositiveInteger) -> %
\end{verbatim}

<<category RNG Rng>>=
)abbrev category RNG Rng
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of associative rings, not necessarily commutative, and not
++ necessarily with a 1. This is a combination of an abelian group
++ and a semigroup, with multiplication distributing over addition.
++
++ Axioms:
++   \spad{ x*(y+z) = x*y + x*z}
++   \spad{ (x+y)*z = x*z + y*z }
++
++ Conditional attributes:
++   \spadnoZeroDivisors\tab{25}\spad{  ab = 0 => a=0 or b=0}
Rng(): Category == Join(AbelianGroup,SemiGroup)

@ 
<<RNG.dotabb>>=
"RNG" [color=lightblue,href="bookvol10.2.pdf#nameddest=RNG"];
"RNG" -> "ABELGRP"
"RNG" -> "SGROUP"

@
<<RNG.dotfull>>=
"Rng()" [color=lightblue,href="bookvol10.2.pdf#nameddest=RNG"];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

@
<<RNG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "REPDB..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SETCAT..."
"AbelianSemiGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{StringAggregate}{SRAGG}
\pagepic{ps/v102stringaggregate.ps}{SRAGG}{1.00}

{\bf See:}\\
\pagefrom{OneDimensionalArrayAggregate}{A1AGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{SRAGG}{any?} &
\cross{SRAGG}{coerce} &
\cross{SRAGG}{concat} &
\cross{SRAGG}{construct} &
\cross{SRAGG}{copy} \\
\cross{SRAGG}{convert} &
\cross{SRAGG}{copyInto!} &
\cross{SRAGG}{count} &
\cross{SRAGG}{delete} &
\cross{SRAGG}{?.?} \\
\cross{SRAGG}{elt} &
\cross{SRAGG}{empty} &
\cross{SRAGG}{empty?} &
\cross{SRAGG}{entries} &
\cross{SRAGG}{entry?} \\
\cross{SRAGG}{eval} &
\cross{SRAGG}{every?} &
\cross{SRAGG}{eq?} &
\cross{SRAGG}{fill!} &
\cross{SRAGG}{find} \\
\cross{SRAGG}{first} &
\cross{SRAGG}{hash} &
\cross{SRAGG}{index?} &
\cross{SRAGG}{indices} &
\cross{SRAGG}{insert} \\
\cross{SRAGG}{latex} &
\cross{SRAGG}{leftTrim} &
\cross{SRAGG}{less?} &
\cross{SRAGG}{lowerCase} &
\cross{SRAGG}{lowerCase!} \\
\cross{SRAGG}{map} &
\cross{SRAGG}{map!} &
\cross{SRAGG}{match} &
\cross{SRAGG}{match?} &
\cross{SRAGG}{max} \\
\cross{SRAGG}{maxIndex} &
\cross{SRAGG}{member?} &
\cross{SRAGG}{members} &
\cross{SRAGG}{merge} &
\cross{SRAGG}{min} \\
\cross{SRAGG}{minIndex} &
\cross{SRAGG}{more?} &
\cross{SRAGG}{new} &
\cross{SRAGG}{parts} &
\cross{SRAGG}{position} \\
\cross{SRAGG}{prefix?} &
\cross{SRAGG}{qelt} &
\cross{SRAGG}{qsetelt!} &
\cross{SRAGG}{reduce} &
\cross{SRAGG}{remove} \\
\cross{SRAGG}{removeDuplicates} &
\cross{SRAGG}{replace} &
\cross{SRAGG}{reverse} &
\cross{SRAGG}{reverse!} &
\cross{SRAGG}{rightTrim} \\
\cross{SRAGG}{sample} &
\cross{SRAGG}{setelt} &
\cross{SRAGG}{size?} &
\cross{SRAGG}{sort} &
\cross{SRAGG}{sort!} \\
\cross{SRAGG}{sorted?} &
\cross{SRAGG}{split} &
\cross{SRAGG}{substring?} &
\cross{SRAGG}{suffix?} &
\cross{SRAGG}{swap!} \\
\cross{SRAGG}{trim} &
\cross{SRAGG}{trim} &
\cross{SRAGG}{upperCase} &
\cross{SRAGG}{upperCase!} &
\cross{SRAGG}{\#?} \\
\cross{SRAGG}{?\~{}=?} &
\cross{SRAGG}{?.?} &
\cross{SRAGG}{?$<$?} &
\cross{SRAGG}{?$<=$?} &
\cross{SRAGG}{?=?} \\
\cross{SRAGG}{?$>$?} &
\cross{SRAGG}{?$>=$?} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 leftTrim : (%,Character) -> %
 leftTrim : (%,CharacterClass) -> %
 lowerCase! : % -> %
 match : (%,%,Character) -> NonNegativeInteger
 match? : (%,%,Character) -> Boolean
 position : (CharacterClass,%,Integer) -> Integer
 position : (%,%,Integer) -> Integer
 replace : (%,UniversalSegment Integer,%) -> %
 rightTrim : (%,Character) -> %
 rightTrim : (%,CharacterClass) -> %
 split : (%,Character) -> List %
 split : (%,CharacterClass) -> List %
 substring? : (%,%,Integer) -> Boolean
 suffix? : (%,%) -> Boolean           
 upperCase! : % -> %                  
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 coerce : Character -> %              
 lowerCase : % -> %                   
 prefix? : (%,%) -> Boolean           
 trim : (%,CharacterClass) -> %
 trim : (%,Character) -> %            
 upperCase : % -> %
 ?.? : (%,%) -> %                     
\end{verbatim}

These exports come from OneDimensionalArrayAggregate(Character):
\begin{verbatim}
 any? : ((Character -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 coerce : % -> OutputForm if Character has SETCAT
 concat : List % -> %
 concat : (%,%) -> %                  
 concat : (Character,%) -> %
 concat : (%,Character) -> %          
 copy : % -> %                        
 copyInto! : (%,%,Integer) -> % 
          if $ has shallowlyMutable
 construct : List Character -> %
 convert : % -> InputForm 
          if Character has KONVERT INFORM
 count : (Character,%) -> NonNegativeInteger 
          if Character has SETCAT 
          and $ has finiteAggregate
 count : ((Character -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 delete : (%,Integer) -> %
 delete : (%,UniversalSegment Integer) -> %
 elt : (%,Integer,Character) -> Character
 empty : () -> %                      
 empty? : % -> Boolean
 entries : % -> List Character        
 entry? : (Character,%) -> Boolean 
          if $ has finiteAggregate 
          and Character has SETCAT
 eq? : (%,%) -> Boolean
 eval : (%,List Character,List Character) -> % 
          if Character has EVALAB CHAR 
          and Character has SETCAT
 eval : (%,Character,Character) -> % 
          if Character has EVALAB CHAR 
          and Character has SETCAT
 eval : (%,Equation Character) -> % 
          if Character has EVALAB CHAR 
          and Character has SETCAT
 eval : (%,List Equation Character) -> % 
          if Character has EVALAB CHAR 
          and Character has SETCAT
 every? : ((Character -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 fill! : (%,Character) -> % 
          if $ has shallowlyMutable
 find : ((Character -> Boolean),%) -> Union(Character,"failed")
 first : % -> Character 
          if Integer has ORDSET
 hash : % -> SingleInteger 
          if Character has SETCAT
 index? : (Integer,%) -> Boolean      
 indices : % -> List Integer
 insert : (Character,%,Integer) -> %
 insert : (%,%,Integer) -> %          
 latex : % -> String if Character has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((Character -> Character),%) -> %
 map : (((Character,Character) -> Character),%,%) -> %
 map! : ((Character -> Character),%) -> % 
          if $ has shallowlyMutable
 max : (%,%) -> % if Character has ORDSET
 maxIndex : % -> Integer if Integer has ORDSET
 member? : (Character,%) -> Boolean 
          if Character has SETCAT 
          and $ has finiteAggregate
 members : % -> List Character 
          if $ has finiteAggregate
 merge : (%,%) -> % if Character has ORDSET
 merge : (((Character,Character) -> Boolean),%,%) -> %
 min : (%,%) -> % if Character has ORDSET
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 new : (NonNegativeInteger,Character) -> %
 parts : % -> List Character if $ has finiteAggregate
 position : (Character,%) -> Integer 
          if Character has SETCAT
 position : ((Character -> Boolean),%) -> Integer
 position : (Character,%,Integer) -> Integer 
          if Character has SETCAT
 qelt : (%,Integer) -> Character
 qsetelt! : (%,Integer,Character) -> Character 
          if $ has shallowlyMutable
 reduce : (((Character,Character) -> Character),%) -> Character 
          if $ has finiteAggregate
 reduce : 
   (((Character,Character) -> Character),%,Character) -> Character 
          if $ has finiteAggregate
 reduce : 
   (((Character,Character) -> Character),%,Character,Character)
       -> Character 
          if Character has SETCAT and $ has finiteAggregate
 remove : ((Character -> Boolean),%) -> % 
          if $ has finiteAggregate
 remove : (Character,%) -> % 
          if Character has SETCAT 
          and $ has finiteAggregate
 removeDuplicates : % -> % 
          if Character has SETCAT 
          and $ has finiteAggregate
 reverse : % -> %                     
 reverse! : % -> % if $ has shallowlyMutable
 sample : () -> %                     
 select : ((Character -> Boolean),%) -> % 
          if $ has finiteAggregate
 setelt : (%,UniversalSegment Integer,Character) -> Character 
          if $ has shallowlyMutable
 sort! : (((Character,Character) -> Boolean),%) -> % 
          if $ has shallowlyMutable
 sorted? : (((Character,Character) -> Boolean),%) -> Boolean
 setelt : (%,Integer,Character) -> Character 
          if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 sort : % -> % if Character has ORDSET
 sort : (((Character,Character) -> Boolean),%) -> %
 sort! : % -> % 
          if Character has ORDSET 
          and $ has shallowlyMutable
 sorted? : % -> Boolean if Character has ORDSET
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean if Character has SETCAT
 ?.? : (%,UniversalSegment Integer) -> %
 ?.? : (%,Integer) -> Character
 ?<? : (%,%) -> Boolean if Character has ORDSET
 ?<=? : (%,%) -> Boolean if Character has ORDSET
 ?=? : (%,%) -> Boolean if Character has SETCAT
 ?>? : (%,%) -> Boolean if Character has ORDSET
 ?>=? : (%,%) -> Boolean if Character has ORDSET
\end{verbatim}

<<category SRAGG StringAggregate>>=
)abbrev category SRAGG StringAggregate
++ Author: Stephen Watt and Michael Monagan. 
++ revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A string aggregate is a category for strings, that is,
++ one dimensional arrays of characters.
StringAggregate: Category == OneDimensionalArrayAggregate Character with
    lowerCase	    : % -> %
      ++ lowerCase(s) returns the string with all characters in lower case.
    lowerCase_!: % -> %
      ++ lowerCase!(s) destructively replaces the alphabetic characters
      ++ in s by lower case.
    upperCase	    : % -> %
      ++ upperCase(s) returns the string with all characters in upper case.
    upperCase_!: % -> %
      ++ upperCase!(s) destructively replaces the alphabetic characters
      ++ in s by upper case characters.
    prefix?	    : (%, %) -> Boolean
      ++ prefix?(s,t) tests if the string s is the initial substring of t.
      ++ Note: \axiom{prefix?(s,t) == 
      ++   reduce(and,[s.i = t.i for i in 0..maxIndex s])}.
    suffix?	    : (%, %) -> Boolean
      ++ suffix?(s,t) tests if the string s is the final substring of t.
      ++ Note: \axiom{suffix?(s,t) == 
      ++  reduce(and,[s.i = t.(n - m + i) for i in 0..maxIndex s])}
      ++ where m and n denote the maxIndex of s and t respectively.
    substring?: (%, %, Integer) -> Boolean
      ++ substring?(s,t,i) tests if s is a substring of t beginning at
      ++ index i.
      ++ Note: \axiom{substring?(s,t,0) = prefix?(s,t)}.
    match: (%, %, Character) -> NonNegativeInteger
      ++ match(p,s,wc) tests if pattern \axiom{p} matches subject \axiom{s}
      ++ where \axiom{wc} is a wild card character. If no match occurs,
      ++ the index \axiom{0} is returned; otheriwse, the value returned
      ++ is the first index of the first character in the subject matching
      ++ the subject (excluding that matched by an initial wild-card).
      ++ For example, \axiom{match("*to*","yorktown","*")} returns \axiom{5}
      ++ indicating a successful match starting at index \axiom{5} of
      ++ \axiom{"yorktown"}.
    match?: (%, %, Character) -> Boolean
      ++ match?(s,t,c) tests if s matches t except perhaps for
      ++ multiple and consecutive occurrences of character c.
      ++ Typically c is the blank character.
    replace	    : (%, UniversalSegment(Integer), %) -> %
      ++ replace(s,i..j,t) replaces the substring \axiom{s(i..j)} 
      ++ of s by string t.
    position	    : (%, %, Integer) -> Integer
      ++ position(s,t,i) returns the position j of the substring s in 
      ++ string t, where \axiom{j >= i} is required.
    position	    : (CharacterClass, %, Integer) -> Integer
      ++ position(cc,t,i) returns the position \axiom{j >= i} in t of
      ++ the first character belonging to cc.
    coerce	    : Character -> %
      ++ coerce(c) returns c as a string s with the character c.
    split: (%, Character) -> List %
      ++ split(s,c) returns a list of substrings delimited by character c.
    split: (%, CharacterClass) -> List %
      ++ split(s,cc) returns a list of substrings delimited by 
      ++ characters in cc.
    trim: (%, Character) -> %
      ++ trim(s,c) returns s with all characters c deleted from right
      ++ and left ends.
      ++ For example, \axiom{trim(" abc ", char " ")} returns \axiom{"abc"}.
    trim: (%, CharacterClass) -> %
      ++ trim(s,cc) returns s with all characters in cc deleted from right
      ++ and left ends.
      ++ For example, \axiom{trim("(abc)", charClass "()")} 
      ++ returns \axiom{"abc"}.
    leftTrim: (%, Character) -> %
      ++ leftTrim(s,c) returns s with all leading characters c deleted.
      ++ For example, \axiom{leftTrim("  abc  ", char " ")} 
      ++ returns \axiom{"abc  "}.
    leftTrim: (%, CharacterClass) -> %
      ++ leftTrim(s,cc) returns s with all leading characters in cc deleted.
      ++ For example, \axiom{leftTrim("(abc)", charClass "()")} 
      ++ returns \axiom{"abc)"}.
    rightTrim: (%, Character) -> %
      ++ rightTrim(s,c) returns s with all trailing occurrences of c deleted.
      ++ For example, \axiom{rightTrim("  abc  ", char " ")} 
      ++ returns \axiom{"  abc"}.
    rightTrim: (%, CharacterClass) -> %
      ++ rightTrim(s,cc) returns s with all trailing occurences of
      ++ characters in cc deleted.
      ++ For example, \axiom{rightTrim("(abc)", charClass "()")} 
      ++ returns \axiom{"(abc"}.
    elt: (%, %) -> %
      ++ elt(s,t) returns the concatenation of s and t. It is provided to
      ++ allow juxtaposition of strings to work as concatenation.
      ++ For example, \axiom{"smoo" "shed"} returns \axiom{"smooshed"}.
 add
   trim(s: %, c:  Character)	  == leftTrim(rightTrim(s, c),	c)
   trim(s: %, cc: CharacterClass) == leftTrim(rightTrim(s, cc), cc)
   lowerCase s		 == lowerCase_! copy s
   upperCase s		 == upperCase_! copy s
   prefix?(s, t)	 == substring?(s, t, minIndex t)
   coerce(c:Character):% == new(1, c)
   elt(s:%, t:%): %	 == concat(s,t)$%

@
<<SRAGG.dotabb>>=
"SRAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=SRAGG"];
"SRAGG" -> "A1AGG"

@
<<SRAGG.dotfull>>=
"StringAggregate()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=SRAGG"];
"StringAggregate()" -> "OneDimensionalArrayAggregate(Character)"

@
<<SRAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"StringAggregate()" [color=lightblue];
"StringAggregate()" -> "OneDimensionalArrayAggregate(Character)"

"OneDimensionalArrayAggregate(Character)" [color=seagreen];
"OneDimensionalArrayAggregate(Character)" ->
    "OneDimensionalArrayAggregate(a:Type)"

"OneDimensionalArrayAggregate(a:Type)" [color=lightblue];
"OneDimensionalArrayAggregate(a:Type)" -> 
    "FiniteLinearAggregate(a:Type)"

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IndexedAggregate(b:Integer,a:Type)"
"LinearAggregate(a:Type)" -> "CLAGG..."

"IndexedAggregate(b:Integer,a:Type)" [color=seagreen];
"IndexedAggregate(b:Integer,a:Type)" -> "IXAGG..."

"CLAGG..." [color=lightblue];
"IXAGG..." [color=lightblue];
}
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{TableAggregate}{TBAGG}
\pagepic{ps/v102tableaggregate.ps}{TBAGG}{0.60}

{\bf See:}\\
\pageto{AssociationListAggregate}{ALAGG}
\pagefrom{IndexedAggregate}{IXAGG}
\pagefrom{KeyedDictionary}{KDAGG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{TBAGG}{any?} &
\cross{TBAGG}{bag} &
\cross{TBAGG}{coerce} &
\cross{TBAGG}{construct} &
\cross{TBAGG}{convert} \\
\cross{TBAGG}{copy} &
\cross{TBAGG}{count} &
\cross{TBAGG}{dictionary} &
\cross{TBAGG}{elt} &
\cross{TBAGG}{empty} \\
\cross{TBAGG}{empty?} &
\cross{TBAGG}{entries} &
\cross{TBAGG}{entry?} &
\cross{TBAGG}{eq?} &
\cross{TBAGG}{eval} \\
\cross{TBAGG}{every?} &
\cross{TBAGG}{extract!} &
\cross{TBAGG}{fill!} &
\cross{TBAGG}{find} &
\cross{TBAGG}{first} \\
\cross{TBAGG}{hash} &
\cross{TBAGG}{index?} &
\cross{TBAGG}{indices} &
\cross{TBAGG}{insert!} &
\cross{TBAGG}{inspect} \\
\cross{TBAGG}{key?} &
\cross{TBAGG}{keys} &
\cross{TBAGG}{latex} &
\cross{TBAGG}{less?} &
\cross{TBAGG}{map} \\
\cross{TBAGG}{map!} &
\cross{TBAGG}{maxIndex} &
\cross{TBAGG}{member?} &
\cross{TBAGG}{members} &
\cross{TBAGG}{minIndex} \\
\cross{TBAGG}{more?} &
\cross{TBAGG}{parts} &
\cross{TBAGG}{qelt} &
\cross{TBAGG}{qsetelt!} &
\cross{TBAGG}{reduce} \\
\cross{TBAGG}{remove} &
\cross{TBAGG}{remove!} &
\cross{TBAGG}{removeDuplicates} &
\cross{TBAGG}{sample} &
\cross{TBAGG}{search} \\
\cross{TBAGG}{select} &
\cross{TBAGG}{select!} &
\cross{TBAGG}{setelt} &
\cross{TBAGG}{size?} &
\cross{TBAGG}{swap!} \\
\cross{TBAGG}{table} &
\cross{TBAGG}{\#?} &
\cross{TBAGG}{?=?} &
\cross{TBAGG}{?.?} &
\cross{TBAGG}{?\~{}=?} \\
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{TBAGG}{finiteAggregate}}
is true if it is an aggregate with a finite number of elements.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 setelt : (%,Key,Entry) -> Entry
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 any? : ((Entry -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 coerce : % -> OutputForm 
          if Entry has SETCAT 
          or Record(key: Key,entry: Entry) has SETCAT
 count : ((Entry -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 elt : (%,Key,Entry) -> Entry         
 entries : % -> List Entry            
 every? : ((Entry -> Boolean),%) -> Boolean 
         if $ has finiteAggregate
 extract! : % -> Record(key: Key,entry: Entry)
 find : 
   ((Record(key: Key,entry: Entry) -> Boolean),%)
      -> Union(Record(key: Key,entry: Entry),"failed")
 index? : (Key,%) -> Boolean          
 indices : % -> List Key
 insert! : (Record(key: Key,entry: Entry),%) -> %
 inspect : % -> Record(key: Key,entry: Entry)
 map : (((Entry,Entry) -> Entry),%,%) -> %
 map : ((Record(key: Key,entry: Entry)
       -> Record(key: Key,entry: Entry)),%) -> %
 map! : ((Entry -> Entry),%) -> % if $ has shallowlyMutable
 map! : 
   ((Record(key: Key,entry: Entry)
       -> Record(key: Key,entry: Entry)),%)
        -> % if $ has shallowlyMutable
 parts : % -> List Entry if $ has finiteAggregate
 parts : % -> List Record(key: Key,entry: Entry) 
          if $ has finiteAggregate
 remove! : (Key,%) -> Union(Entry,"failed")
 table : () -> %                      
 table : List Record(key: Key,entry: Entry) -> %
 ?.? : (%,Key) -> Entry
 ?=? : (%,%) -> Boolean 
          if Entry has SETCAT 
          or Record(key: Key,entry: Entry) has SETCAT
\end{verbatim}

These exports come from KeyedDictionary(Key,Entry)\\
where Key:SetCategory and Entry:SetCategory\\
and RecKE=Record(key: Key,entry: Entry):
\begin{verbatim}
 any? : ((RecKE -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List RecKE -> %
 construct : List RecKE -> %
 convert : % -> InputForm if RecKE has KONVERT INFORM
 copy : % -> %                        
 count : (Entry,%) -> NonNegativeInteger 
          if Entry has SETCAT 
          and $ has finiteAggregate
 count : ((RecKE -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 dictionary : () -> %
 dictionary : List RecKE -> %
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean
 eval : (%,List RecKE,List RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,RecKE,RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,List Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 every? : ((RecKE -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 key? : (Key,%) -> Boolean            
 keys : % -> List Key
 hash : % -> SingleInteger 
          if Entry has SETCAT 
          or RecKE has SETCAT
 latex : % -> String 
          if Entry has SETCAT 
          or RecKE has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 member? : (RecKE,%) -> Boolean 
     if RecKE has SETCAT 
      and $ has finiteAggregate
 members : % -> List RecKE if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 reduce : 
  (((RecKE,RecKE) -> RecKE),%) -> RecKE 
          if $ has finiteAggregate
 reduce : 
  (((RecKE,RecKE)->RecKE),%,RecKE) -> RecKE 
          if $ has finiteAggregate
 reduce : 
  (((RecKE,RecKE)->RecKE),%,RecKE,RecKE)
    -> RecKE 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 remove : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 remove : (RecKE,%) -> % 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 remove! : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 remove! : (RecKE,%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 sample : () -> %                     
 search : (Key,%) -> Union(Entry,"failed")
 select : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 select! : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean 
          if Entry has SETCAT 
          or RecKE has SETCAT
\end{verbatim}

These exports come from IndexedAggregate(Key,Entry))\\
where Key:SetCategory and Entry:SetCategory\\
and RecKE=Record(key: Key,entry: Entry):
\begin{verbatim}
 count : (RecKE,%) -> NonNegativeInteger 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 entry? : (Entry,%) -> Boolean 
          if $ has finiteAggregate 
          and Entry has SETCAT
 eval : (%,List Equation Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,Equation Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,Entry,Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,List Entry,List Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 fill! : (%,Entry) -> % if $ has shallowlyMutable
 first : % -> Entry if Key has ORDSET
 map : ((Entry -> Entry),%) -> %      
 maxIndex : % -> Key if Key has ORDSET
 member? : (Entry,%) -> Boolean 
          if Entry has SETCAT 
          and $ has finiteAggregate
 members : % -> List Entry if $ has finiteAggregate
 minIndex : % -> Key if Key has ORDSET
 qelt : (%,Key) -> Entry
 qsetelt! : (%,Key,Entry) -> Entry if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 swap! : (%,Key,Key) -> Void if $ has shallowlyMutable
\end{verbatim}

<<category TBAGG TableAggregate>>=
)abbrev category TBAGG TableAggregate
++ Author: Michael Monagan, Stephen Watt; 
++ revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A table aggregate is a model of a table, i.e. a discrete many-to-one
++ mapping from keys to entries.
TableAggregate(Key:SetCategory, Entry:SetCategory): Category ==
  Join(KeyedDictionary(Key,Entry),IndexedAggregate(Key,Entry)) with
   setelt: (%,Key,Entry) -> Entry	   -- setelt_! later
     ++ setelt(t,k,e) (also written \axiom{t.k := e}) is equivalent
     ++ to \axiom{(insert([k,e],t); e)}.
   table: () -> %
     ++ table()$T creates an empty table of type T.
     ++
     ++E Data:=Record(age:Integer,gender:String)
     ++E a1:AssociationList(String,Data):=table()
     ++E a1."tim":=[55,"male"]$Data
   table: List Record(key:Key,entry:Entry) -> %
     ++ table([x,y,...,z]) creates a table consisting of entries
     ++ \axiom{x,y,...,z}.
   -- to become table: Record(key:Key,entry:Entry)* -> %
   map: ((Entry, Entry) -> Entry, %, %) -> %
     ++ map(fn,t1,t2) creates a new table t from given tables t1 and t2 with
     ++ elements fn(x,y) where x and y are corresponding elements from t1
     ++ and t2 respectively.
 add
   table()	       == empty()
   table l	       == dictionary l
-- empty()	       == dictionary()

   insert_!(p, t)      == (t(p.key) := p.entry; t)
   indices t	       == keys t

   coerce(t:%):OutputForm ==
     prefix("table"::OutputForm,
		    [k::OutputForm = (t.k)::OutputForm for k in keys t])

   elt(t, k) ==
      (r := search(k, t)) case Entry => r::Entry
      error "key not in table"

   elt(t, k, e) ==
      (r := search(k, t)) case Entry => r::Entry
      e

   map_!(f, t) ==
      for k in keys t repeat t.k := f t.k
      t

   map(f:(Entry, Entry) -> Entry, s:%, t:%) ==
      z := table()
      for k in keys s | key?(k, t) repeat z.k := f(s.k, t.k)
      z

-- map(f, s, t, x) ==
--    z := table()
--    for k in keys s repeat z.k := f(s.k, t(k, x))
--    for k in keys t | not key?(k, s) repeat z.k := f(t.k, x)
--    z

   if % has finiteAggregate then
     parts(t:%):List Record(key:Key,entry:Entry) ==
         [[k, t.k] for k in keys t]
     parts(t:%):List Entry   == [t.k for k in keys t]
     entries(t:%):List Entry == parts(t)

     s:% = t:% ==
       eq?(s,t) => true
       #s ^= #t => false
       for k in keys s repeat
	 (e := search(k, t)) _
           case "failed" or (e::Entry) ^= s.k => return false
       true

     map(f: Record(key:Key,entry:Entry)->Record(key:Key,entry:Entry),t:%):%==
       z := table()
       for k in keys t repeat
	 ke: Record(key:Key,entry:Entry) := f [k, t.k]
	 z ke.key := ke.entry
       z
     map_!(f:Record(key:Key,entry:Entry)->Record(key:Key,entry:Entry),t:%):%_
      ==
       lke: List Record(key:Key,entry:Entry) := nil()
       for k in keys t repeat
	 lke := cons(f [k, remove_!(k,t)::Entry], lke)
       for ke in lke repeat
	 t ke.key := ke.entry
       t

     inspect(t: %): Record(key:Key,entry:Entry) ==
       ks := keys t
       empty? ks => error "Cannot extract from an empty aggregate"
       [first ks, t first ks]

     find(f: Record(key:Key,entry:Entry)->Boolean, t:%):_
           Union(Record(key:Key,entry:Entry), "failed") ==
       for ke in parts(t)@List(Record(key:Key,entry:Entry)) _
          repeat if f ke then return ke
       "failed"

     index?(k: Key, t: %): Boolean ==
       search(k,t) case Entry

     remove_!(x:Record(key:Key,entry:Entry), t:%) ==
       if member?(x, t) then remove_!(x.key, t)
       t
     extract_!(t: %): Record(key:Key,entry:Entry) ==
       k: Record(key:Key,entry:Entry) := inspect t
       remove_!(k.key, t)
       k

     any?(f: Entry->Boolean, t: %): Boolean ==
       for k in keys t | f t k repeat return true
       false
     every?(f: Entry->Boolean, t: %): Boolean ==
       for k in keys t | not f t k repeat return false
       true
     count(f: Entry->Boolean, t: %): NonNegativeInteger ==
       tally: NonNegativeInteger := 0
       for k in keys t | f t k repeat tally := tally + 1
       tally

@
<<TBAGG.dotabb>>=
"TBAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=TBAGG"];
"TBAGG" -> "KDAGG"
"TBAGG" -> "IXAGG"

@
<<TBAGG.dotfull>>=
"TableAggregate(a:SetCategory,b:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=TBAGG"];
"TableAggregate(a:SetCategory,b:SetCategory)" -> 
    "KeyedDictionary(a:SetCategory,b:SetCategory)"
"TableAggregate(a:SetCategory,b:SetCategory)" -> 
    "IndexedAggregate(a:SetCategory,b:SetCategory)"

@
<<TBAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"TableAggregate(a:SetCategory,b:SetCategory)" [color=lightblue];
"TableAggregate(a:SetCategory,b:SetCategory)" -> 
    "KeyedDictionary(a:SetCategory,b:SetCategory)"
"TableAggregate(a:SetCategory,b:SetCategory)" -> 
    "IndexedAggregate(a:SetCategory,b:SetCategory)"

"IndexedAggregate(a:SetCategory,b:SetCategory)" [color=seagreen];
"IndexedAggregate(a:SetCategory,b:SetCategory)" ->
    "IndexedAggregate(a:SetCategory,b:Type)"

"IndexedAggregate(a:SetCategory,b:Type)" [color=lightblue];
"IndexedAggregate(a:SetCategory,b:Type)" -> "HOAGG..."
"IndexedAggregate(a:SetCategory,b:Type)" -> "ELTAGG..."

"KeyedDictionary(a:SetCategory,b:SetCategory)" [color=lightblue];
"KeyedDictionary(a:SetCategory,b:SetCategory)" -> 
    "Dictionary(Record(a:SetCategory,b:SetCategory))"

"Dictionary(Record(a:SetCategory,b:SetCategory))" [color=seagreen];
"Dictionary(Record(a:SetCategory,b:SetCategory))" ->
    "Dictionary(a:SetCategory)"

"Dictionary(a:SetCategory)" [color=lightblue];
"Dictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BagAggregate(a:SetCategory)"
"DictionaryOperations(a:SetCategory)" -> "Collection(a:SetCategory)"

"BagAggregate(a:SetCategory)" [color=seagreen];
"BagAggregate(a:SetCategory)" -> "BagAggregate(a:Type)"

"BagAggregate(a:Type)" [color=lightblue];
"BagAggregate(a:Type)" -> "HOAGG..."

"Collection(a:SetCategory)" [color=seagreen];
"Collection(a:SetCategory)" -> "Collection(a:Type)"

"Collection(a:Type)" [color=lightblue];
"Collection(a:Type)" -> "HOAGG..."

"ELTAGG..." [color=lightblue];
"HOAGG..." [color=lightblue];
}
@
\chapter{Category Layer 8}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{AssociationListAggregate}{ALAGG}
\pagepic{ps/v102associationlistaggregate.ps}{ALAGG}{0.45}

{\bf See:}\\
\pagefrom{ListAggregate}{LSAGG}
\pagefrom{TableAggregate}{TBAGG}

{\bf Exports:}\\
\begin{tabular}{llll}
\cross{ALAGG}{any?} &
\cross{ALAGG}{assoc} &
\cross{ALAGG}{bag} &
\cross{ALAGG}{children} \\
\cross{ALAGG}{child?} &
\cross{ALAGG}{coerce} &
\cross{ALAGG}{concat} &
\cross{ALAGG}{concat!} \\
\cross{ALAGG}{construct} &
\cross{ALAGG}{convert} &
\cross{ALAGG}{copy} &
\cross{ALAGG}{copyInto!} \\
\cross{ALAGG}{count} &
\cross{ALAGG}{cycleEntry} &
\cross{ALAGG}{cycleLength} &
\cross{ALAGG}{cycleSplit!} \\
\cross{ALAGG}{cycleTail} &
\cross{ALAGG}{cyclic?} &
\cross{ALAGG}{delete} &
\cross{ALAGG}{delete!} \\
\cross{ALAGG}{dictionary} &
\cross{ALAGG}{distance} &
\cross{ALAGG}{elt} &
\cross{ALAGG}{empty} \\
\cross{ALAGG}{empty?} &
\cross{ALAGG}{entries} &
\cross{ALAGG}{entry?} &
\cross{ALAGG}{eq?} \\
\cross{ALAGG}{eval} &
\cross{ALAGG}{every?} &
\cross{ALAGG}{explicitlyFinite?} &
\cross{ALAGG}{extract!} \\
\cross{ALAGG}{fill!} &
\cross{ALAGG}{find} &
\cross{ALAGG}{first} &
\cross{ALAGG}{hash} \\
\cross{ALAGG}{index?} &
\cross{ALAGG}{indices} &
\cross{ALAGG}{insert} &
\cross{ALAGG}{insert!} \\
\cross{ALAGG}{inspect} &
\cross{ALAGG}{key?} &
\cross{ALAGG}{keys} &
\cross{ALAGG}{last} \\
\cross{ALAGG}{latex} &
\cross{ALAGG}{leaf?} &
\cross{ALAGG}{leaves} &
\cross{ALAGG}{less?} \\
\cross{ALAGG}{list} &
\cross{ALAGG}{map} &
\cross{ALAGG}{map!} &
\cross{ALAGG}{max} \\
\cross{ALAGG}{maxIndex} &
\cross{ALAGG}{member?} &
\cross{ALAGG}{members} &
\cross{ALAGG}{merge} \\
\cross{ALAGG}{merge!} &
\cross{ALAGG}{min} &
\cross{ALAGG}{minIndex} &
\cross{ALAGG}{more?} \\
\cross{ALAGG}{new} &
\cross{ALAGG}{nodes} &
\cross{ALAGG}{node?} &
\cross{ALAGG}{parts} \\
\cross{ALAGG}{position} &
\cross{ALAGG}{possiblyInfinite?} &
\cross{ALAGG}{qelt} &
\cross{ALAGG}{qsetelt!} \\
\cross{ALAGG}{reduce} &
\cross{ALAGG}{remove} &
\cross{ALAGG}{remove!} &
\cross{ALAGG}{removeDuplicates} \\
\cross{ALAGG}{removeDuplicates!} &
\cross{ALAGG}{rest} &
\cross{ALAGG}{reverse} &
\cross{ALAGG}{reverse!} \\
\cross{ALAGG}{sample} &
\cross{ALAGG}{search} &
\cross{ALAGG}{second} &
\cross{ALAGG}{select} \\
\cross{ALAGG}{select!} &
\cross{ALAGG}{setchildren!} &
\cross{ALAGG}{setelt} &
\cross{ALAGG}{setfirst!} \\
\cross{ALAGG}{setlast!} &
\cross{ALAGG}{setrest!} &
\cross{ALAGG}{setvalue!} &
\cross{ALAGG}{size?} \\
\cross{ALAGG}{sort} &
\cross{ALAGG}{sort!} &
\cross{ALAGG}{sorted?} &
\cross{ALAGG}{split!} \\
\cross{ALAGG}{swap!} &
\cross{ALAGG}{table} &
\cross{ALAGG}{tail} &
\cross{ALAGG}{third} \\
\cross{ALAGG}{value} &
\cross{ALAGG}{\#?} &
\cross{ALAGG}{?$<$?} &
\cross{ALAGG}{?$<=$?} \\
\cross{ALAGG}{?=?} &
\cross{ALAGG}{?$>$?} &
\cross{ALAGG}{?$>=$?} &
\cross{ALAGG}{?\~{}=?} \\
\cross{ALAGG}{?.rest} &
\cross{ALAGG}{?.value} &
\cross{ALAGG}{?.first} &
\cross{ALAGG}{?.last} \\
\cross{ALAGG}{?.?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 assoc : (Key,%) -> Union(Record(key: Key,entry: Entry),"failed")
\end{verbatim}

These exports come from TableAggregate(Key, Entry)\\
where Key:SetCategory and Entry:SetCategory\\
and RecKE = Record(key: Key,entry: Entry)
\begin{verbatim}
 any? : ((RecKE -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 any? : ((Entry -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 any? : ((RecKE -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 bag : List RecKE -> %
 construct : List RecKE -> %
 convert : % -> InputForm 
          if RecKE has KONVERT INFORM 
          or RecKE has KONVERT INFORM
 copy : % -> %                        
 count : 
  ((RecKE -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 count : (RecKE,%) -> NonNegativeInteger 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 count : ((Entry -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 count : (Entry,%) -> NonNegativeInteger 
          if Entry has SETCAT 
          and $ has finiteAggregate
 count : (RecKE,%) -> NonNegativeInteger 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 count : 
  ((RecKE -> Boolean),%) -> NonNegativeInteger 
          if $ has finiteAggregate
 dictionary : () -> %                 
 dictionary : List RecKE -> %
 elt : (%,Key,Entry) -> Entry
 elt : (%,Integer,RecKE) -> RecKE
 empty : () -> %
 empty? : % -> Boolean                
 entries : % -> List Entry
 entry? : (Entry,%) -> Boolean 
          if $ has finiteAggregate 
          and Entry has SETCAT
 eq? : (%,%) -> Boolean               
 eval : (%,List Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,RecKE,RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,List RecKE,List RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,List Equation Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,Equation Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,Entry,Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,List Entry,List Entry) -> % 
          if Entry has EVALAB Entry 
          and Entry has SETCAT
 eval : (%,List RecKE,List RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,RecKE,RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 eval : (%,List Equation RecKE) -> % 
          if RecKE has EVALAB RecKE 
          and RecKE has SETCAT
 every? : ((RecKE -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 every? : ((Entry -> Boolean),%) -> Boolean 
          if $ has finiteAggregate
 extract! : % -> RecKE
 fill! : (%,Entry) -> % if $ has shallowlyMutable
 find : ((RecKE -> Boolean),%) -> Union(RecKE,"failed")
 first : % -> Entry if Key has ORDSET
 hash : % -> SingleInteger 
          if RecKE has SETCAT 
          or Entry has SETCAT 
          or RecKE has SETCAT
 index? : (Key,%) -> Boolean
 indices : % -> List Key
 insert! : (RecKE,%) -> %
 inspect : % -> RecKE
 key? : (Key,%) -> Boolean            
 keys : % -> List Key
 latex : % -> String 
          if RecKE has SETCAT 
          or Entry has SETCAT 
          or RecKE has SETCAT
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((Entry -> Entry),%) -> %
 map : ((RecKE -> RecKE),%) -> %
 map : (((Entry,Entry) -> Entry),%,%) -> %
 map! : ((RecKE -> RecKE),%) -> % 
          if $ has shallowlyMutable
 map! : ((Entry -> Entry),%) -> % if $ has shallowlyMutable
 map! : ((RecKE -> RecKE),%) -> % 
          if $ has shallowlyMutable
 maxIndex : % -> Key if Key has ORDSET
 member? : (RecKE,%) -> Boolean 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 member? : (Entry,%) -> Boolean 
          if Entry has SETCAT 
          and $ has finiteAggregate
 members : % -> List RecKE if $ has finiteAggregate
 members : % -> List Entry if $ has finiteAggregate
 members : % -> List RecKE if $ has finiteAggregate
 minIndex : % -> Key if Key has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List Entry if $ has finiteAggregate
 parts : % -> List RecKE if $ has finiteAggregate
 qelt : (%,Key) -> Entry              
 qsetelt! : (%,Key,Entry) -> Entry if $ has shallowlyMutable
 reduce : 
  (((RecKE,RecKE) -> RecKE),%)
    -> RecKE 
          if $ has finiteAggregate
 reduce : 
  (((RecKE,RecKE) -> RecKE),%,RecKE)
    -> RecKE 
          if $ has finiteAggregate
 reduce : 
  (((RecKE,RecKE) -> RecKE),%,RecKE,RecKE)
    -> RecKE 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 remove : ((RecKE -> Boolean),%) -> % if $ has finiteAggregate
 remove : (RecKE,%) -> % 
          if RecKE has SETCAT 
          and $ has finiteAggregate
 remove! : (Key,%) -> Union(Entry,"failed")
 remove! : (RecKE,%) -> % if RecKE has SETCAT
 remove! : (RecKE,%) -> % if $ has finiteAggregate
 removeDuplicates : % -> % 
          if RecKE has SETCAT 
          and $ has finiteAggregate 
          or RecKE has SETCAT 
          and $ has finiteAggregate
 sample : () -> %
 search : (Key,%) -> Union(Entry,"failed")
 select : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 select! : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 setelt : (%,Key,Entry) -> Entry      
 size? : (%,NonNegativeInteger) -> Boolean
 swap! : (%,Key,Key) -> Void if $ has shallowlyMutable
 table : () -> %
 table : List RecKE -> %
 ?~=? : (%,%) -> Boolean 
          if RecKE has SETCAT 
          or Entry has SETCAT 
          or RecKE has SETCAT
 ?.? : (%,Key) -> Entry               
\end{verbatim}

These exports come from ListAggregate(a)\\
where a is  Record(key:Key,entry:Entry)\\
and RecKE=Record(key: Key,entry: Entry)
\begin{verbatim}
 children : % -> List %               
 child? : (%,%) -> Boolean if RecKE has SETCAT
 coerce : % -> OutputForm 
          if RecKE has SETCAT 
          or Entry has SETCAT 
          or RecKE has SETCAT
 concat : (%,%) -> %
 concat : List % -> %                 
 concat : (RecKE,%) -> %
 concat : (%,RecKE) -> %
 concat! : (%,%) -> %
 concat! : (%,RecKE) -> %
 copyInto! : (%,%,Integer) -> % if $ has shallowlyMutable
 cycleEntry : % -> %
 cycleLength : % -> NonNegativeInteger
 cycleSplit! : % -> % if $ has shallowlyMutable
 cycleTail : % -> %                   
 cyclic? : % -> Boolean
 delete : (%,Integer) -> %            
 delete! : (%,Integer) -> %
 delete : (%,UniversalSegment Integer) -> %
 delete! : (%,UniversalSegment Integer) -> %
 distance : (%,%) -> Integer
 entries : % -> List RecKE
 entry? : (RecKE,%) -> Boolean 
          if $ has finiteAggregate 
          and RecKE has SETCAT
 explicitlyFinite? : % -> Boolean
 fill! : (%,RecKE) -> % if $ has shallowlyMutable
 first : % -> RecKE
 first : (%,NonNegativeInteger) -> %
 index? : (Integer,%) -> Boolean      
 indices : % -> List Integer          
 insert : (%,%,Integer) -> %          
 insert : (RecKE,%,Integer) -> %
 insert! : (%,%,Integer) -> %
 insert! : (RecKE,%,Integer) -> %
 last : % -> RecKE
 last : (%,NonNegativeInteger) -> %
 leaf? : % -> Boolean                 
 leaves : % -> List RecKE
 list : RecKE -> %
 map : (((RecKE,RecKE) -> RecKE),%,%) -> %
 max : (%,%) -> % if RecKE has ORDSET
 maxIndex : % -> Integer if Integer has ORDSET
 merge : (%,%) -> % if RecKE has ORDSET
 merge : (((RecKE,RecKE) -> Boolean),%,%) -> %
 merge! : (%,%) -> % if RecKE has ORDSET
 merge! : (((RecKE,RecKE) -> Boolean),%,%) -> %
 min : (%,%) -> % if RecKE has ORDSET
 minIndex : % -> Integer if Integer has ORDSET
 new : (NonNegativeInteger,RecKE) -> %
 nodes : % -> List %                  
 node? : (%,%) -> Boolean if RecKE has SETCAT
 position : (RecKE,%,Integer) -> Integer 
          if RecKE has SETCAT
 position : (RecKE,%) -> Integer 
          if RecKE has SETCAT
 position : ((RecKE -> Boolean),%) -> Integer
 possiblyInfinite? : % -> Boolean
 qelt : (%,Integer) -> RecKE
 qsetelt! : (%,Integer,RecKE) -> RecKE 
          if $ has shallowlyMutable
 remove! : ((RecKE -> Boolean),%) -> %
 remove! : ((RecKE -> Boolean),%) -> % 
          if $ has finiteAggregate
 removeDuplicates! : % -> % if RecKE has SETCAT
 rest : % -> %
 rest : (%,NonNegativeInteger) -> %
 reverse : % -> %                     
 reverse! : % -> % if $ has shallowlyMutable
 second : % -> RecKE
 select! : ((RecKE -> Boolean),%) -> %
 setchildren! : (%,List %) -> % if $ has shallowlyMutable
 setelt : (%,value,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setelt : (%,first,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setelt : (%,rest,%) -> % if $ has shallowlyMutable
 setelt : (%,last,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setelt : (%,UniversalSegment Integer,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setelt : (%,Integer,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setfirst! : (%,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setlast! : (%,RecKE) -> RecKE 
          if $ has shallowlyMutable
 setrest! : (%,%) -> % if $ has shallowlyMutable
 setvalue! : (%,RecKE) -> RecKE 
          if $ has shallowlyMutable
 sort : % -> % if RecKE has ORDSET
 sort : (((RecKE,RecKE) -> Boolean),%) -> %
 sort! : % -> % 
          if RecKE has ORDSET 
          and $ has shallowlyMutable
 sort! : (((RecKE,RecKE) -> Boolean),%) -> % 
          if $ has shallowlyMutable
 sorted? : % -> Boolean if RecKE has ORDSET
 sorted? : (((RecKE,RecKE) -> Boolean),%) -> Boolean
 split! : (%,Integer) -> % if $ has shallowlyMutable
 swap! : (%,Integer,Integer) -> Void 
          if $ has shallowlyMutable
 tail : % -> %                        
 third : % -> RecKE
 value : % -> RecKE
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?<? : (%,%) -> Boolean if RecKE has ORDSET
 ?<=? : (%,%) -> Boolean if RecKE has ORDSET
 ?=? : (%,%) -> Boolean 
          if RecKE has SETCAT 
          or Entry has SETCAT 
          or RecKE has SETCAT
 ?>? : (%,%) -> Boolean if RecKE has ORDSET
 ?>=? : (%,%) -> Boolean if RecKE has ORDSET
 ?.value : (%,value) -> RecKE
 ?.first : (%,first) -> RecKE
 ?.last : (%,last) -> RecKE
 ?.rest : (%,rest) -> %               
 ?.? : (%,UniversalSegment Integer) -> %
 ?.? : (%,Integer) -> RecKE
\end{verbatim}

<<category ALAGG AssociationListAggregate>>=
)abbrev category ALAGG AssociationListAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An association list is a list of key entry pairs which may be viewed
++ as a table.	It is a poor mans version of a table:
++ searching for a key is a linear operation.
AssociationListAggregate(Key:SetCategory,Entry:SetCategory): Category ==
   Join(TableAggregate(Key, Entry), _
         ListAggregate Record(key:Key,entry:Entry)) with
      assoc: (Key, %) -> Union(Record(key:Key,entry:Entry), "failed")
	++ assoc(k,u) returns the element x in association list u stored
	++ with key k, or "failed" if u has no key k.

@
<<ALAGG.dotabb>>=
"ALAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=ALAGG"];
"ALAGG" -> "TBAGG"
"ALAGG" -> "LSAGG"

@
<<ALAGG.dotfull>>=
"AssociationListAggregate(a:SetCategory,b:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ALAGG"];
"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
    "TableAggregate(a:SetCategory,b:SetCategory)"
"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
    "ListAggregate(Record(a:SetCategory,b:SetCategory))"

@
<<ALAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"AssociationListAggregate(a:SetCategory,b:SetCategory)" [color=lightblue];
"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
    "TableAggregate(a:SetCategory,b:SetCategory)"
"AssociationListAggregate(a:SetCategory,b:SetCategory)" ->
    "ListAggregate(Record(a:SetCategory,b:SetCategory))"

"TableAggregate(a:SetCategory,b:SetCategory)" [color=lightblue];
"TableAggregate(a:SetCategory,b:SetCategory)" -> "KDAGG..."
"TableAggregate(a:SetCategory,b:SetCategory)" -> 
    "IndexedAggregate(a:SetCategory,b:SetCategory)"

"IndexedAggregate(a:SetCategory,b:SetCategory)" [color=seagreen];
"IndexedAggregate(a:SetCategory,b:SetCategory)" -> "IXAGG..."

"ListAggregate(Record(a:SetCategory,b:SetCategory))" [color=seagreen];
"ListAggregate(Record(a:SetCategory,b:SetCategory))" -> 
    "ListAggregate(a:Type)"

"ListAggregate(a:Type)" [color=lightblue];
"ListAggregate(a:Type)" -> "FiniteLinearAggregate(a:Type)"
"ListAggregate(a:Type)" -> "ExtensibleLinearAggregate(a:Type)"

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LSAGG..."

"ExtensibleLinearAggregate(a:Type)" [color=lightblue];
"ExtensibleLinearAggregate(a:Type)" -> "LSAGG..."

"KDAGG..." [color=lightblue];
"IXAGG..." [color=lightblue];
"LSAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{BiModule}{BMODULE}
\pagepic{ps/v102bimodule.ps}{BMODULE}{1.00}

{\bf See:}\\
\pageto{CommutativeRing}{COMRING}
\pageto{EntireRing}{ENTIRER}
\pageto{Module}{MODULE}
\pagefrom{LeftModule}{LMODULE}
\pagefrom{RightModule}{RMODULE}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{BMODULE}{0} &
\cross{BMODULE}{coerce} &
\cross{BMODULE}{hash} &
\cross{BMODULE}{latex} &
\cross{BMODULE}{sample} \\
\cross{BMODULE}{subtractIfCan} &
\cross{BMODULE}{zero?} &
\cross{BMODULE}{?~=?} &
\cross{BMODULE}{?*?} &
\cross{BMODULE}{?+?} \\
\cross{BMODULE}{?-?} &
\cross{BMODULE}{-?} &
\cross{BMODULE}{?=?} &&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{BMODULE}{leftUnitary}}
is true if $1 * x = x$ for all x.
\item {\bf \cross{BMODULE}{rightUnitary}}
is true if $x * 1 = x$ for all x.
\end{itemize}

These exports come from LeftModule(R:Ring):
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (R,%) -> %
 ?=? : (%,%) -> Boolean
 ?+? : (%,%) -> %                     
 ?*? : (PositiveInteger,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %               
 ?-? : (%,%) -> %
 -? : % -> %                          
\end{verbatim}

These exports come from RightModule(S:Ring):
\begin{verbatim}
 ?*? : (%,S) -> %                     
\end{verbatim}

<<category BMODULE BiModule>>=
)abbrev category BMODULE BiModule
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A \spadtype{BiModule} is both a left and right module with respect
++ to potentially different rings.
++
++ Axiom:
++   \spad{ r*(x*s) = (r*x)*s }
BiModule(R:Ring,S:Ring):Category ==
  Join(LeftModule(R),RightModule(S)) with
     leftUnitary 
       ++ \spad{1 * x = x}
     rightUnitary 
       ++ \spad{x * 1 = x}

@
<<BMODULE.dotabb>>=
"BMODULE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BMODULE"];
"BMODULE" -> "LMODULE"
"BMODULE" -> "RMODULE"

@
<<BMODULE.dotfull>>=
"BiModule(a:Ring,b:Ring)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BMODULE"];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"BiModule(a:CommutativeRing,b:CommutativeRing)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=BMODULE"];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:OrderedAbelianMonoid)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=BMODULE"];
"BiModule(a:Ring,b:OrderedAbelianMonoid)" -> "BiModule(a:Ring,b:Ring)"

@
<<BMODULE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "AbelianGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "REPDB..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "ABELMON..."

"ABELMON..." [color=lightblue];
"REPDB..." [color="#00EE00"];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{BitAggregate}{BTAGG}
\pagepic{ps/v102bitaggregate.ps}{BTAGG}{0.65}

{\bf See:}\\
\pagefrom{Logic}{LOGIC}
\pagefrom{OneDimensionalArrayAggregate}{A1AGG}
\pagefrom{OrderedSet}{ORDSET}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{BTAGG}{any?} &
\cross{BTAGG}{coerce} &
\cross{BTAGG}{concat} &
\cross{BTAGG}{construct} &
\cross{BTAGG}{convert} \\
\cross{BTAGG}{copy} &
\cross{BTAGG}{copyInto!} &
\cross{BTAGG}{count} &
\cross{BTAGG}{delete} &
\cross{BTAGG}{elt} \\
\cross{BTAGG}{empty} &
\cross{BTAGG}{empty?} &
\cross{BTAGG}{entry?} &
\cross{BTAGG}{entries} &
\cross{BTAGG}{eq?} \\
\cross{BTAGG}{eval} &
\cross{BTAGG}{every?} &
\cross{BTAGG}{fill!} &
\cross{BTAGG}{find} &
\cross{BTAGG}{first} \\
\cross{BTAGG}{hash} &
\cross{BTAGG}{index?} &
\cross{BTAGG}{indices} &
\cross{BTAGG}{insert} &
\cross{BTAGG}{latex} \\
\cross{BTAGG}{less?} &
\cross{BTAGG}{map} &
\cross{BTAGG}{map!} &
\cross{BTAGG}{max} &
\cross{BTAGG}{maxIndex} \\
\cross{BTAGG}{member?} &
\cross{BTAGG}{members} &
\cross{BTAGG}{merge} &
\cross{BTAGG}{min} &
\cross{BTAGG}{minIndex} \\
\cross{BTAGG}{more?} &
\cross{BTAGG}{nand} &
\cross{BTAGG}{new} &
\cross{BTAGG}{nor} &
\cross{BTAGG}{not?} \\
\cross{BTAGG}{parts} &
\cross{BTAGG}{position} &
\cross{BTAGG}{qelt} &
\cross{BTAGG}{qsetelt!} &
\cross{BTAGG}{reduce} \\
\cross{BTAGG}{remove} &
\cross{BTAGG}{removeDuplicates} &
\cross{BTAGG}{reverse} &
\cross{BTAGG}{reverse!} &
\cross{BTAGG}{sample} \\
\cross{BTAGG}{select} &
\cross{BTAGG}{setelt} &
\cross{BTAGG}{size?} &
\cross{BTAGG}{sort} &
\cross{BTAGG}{sort!} \\
\cross{BTAGG}{sorted?} &
\cross{BTAGG}{swap!} &
\cross{BTAGG}{xor} &
\cross{BTAGG}{\#?} &
\cross{BTAGG}{?$/\backslash{}$?} \\
\cross{BTAGG}{?$<$?} &
\cross{BTAGG}{?$<=$?} &
\cross{BTAGG}{?=?} &
\cross{BTAGG}{?$>$?} &
\cross{BTAGG}{?$>=$?} \\
\cross{BTAGG}{?$\backslash{}/$?} &
\cross{BTAGG}{\^{}?} &
\cross{BTAGG}{?and?} &
\cross{BTAGG}{?.?} &
\cross{BTAGG}{?or?} \\
\cross{BTAGG}{\~{}?} &
\cross{BTAGG}{?\~{}=?} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 ?and? : (%,%) -> %                   
 ?or? : (%,%) -> %                    
 xor : (%,%) -> %                     
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 not? : % -> %
 ^? : % -> %
 ~? : % -> %
 ?/\? : (%,%) -> %                    
 ?\/? : (%,%) -> %                    
 nand : (%,%) -> %
 nor : (%,%) -> %                     
\end{verbatim}

These exports come from OrderedSet():
\begin{verbatim}
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String                  
 max : (%,%) -> %
 min : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?<? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean              
 ?>=? : (%,%) -> Boolean
\end{verbatim}

TPDHERE: Note that none of the exports of Logic are needed.
Perhaps this can be eliminated.

These exports come from OneDimensionalArrayAggregate(Boolean):
\begin{verbatim}
 any? : ((Boolean -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 concat : (%,%) -> %                  
 concat : List % -> %
 concat : (%,Boolean) -> %            
 concat : (Boolean,%) -> %
 construct : List Boolean -> %        
 convert : % -> InputForm 
     if Boolean has KONVERT INFORM
 copy : % -> %
 copyInto! : (%,%,Integer) -> % 
     if $ has shallowlyMutable
 count : (Boolean,%) -> NonNegativeInteger 
     if Boolean has SETCAT and $ has finiteAggregate
 count : ((Boolean -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 delete : (%,UniversalSegment Integer) -> %
 delete : (%,Integer) -> %            
 elt : (%,Integer,Boolean) -> Boolean
 empty : () -> %                      
 empty? : % -> Boolean
 entry? : (Boolean,%) -> Boolean 
     if $ has finiteAggregate and Boolean has SETCAT
 entries : % -> List Boolean          
 eq? : (%,%) -> Boolean
 eval : (%,List Equation Boolean) -> % 
     if Boolean has EVALAB BOOLEAN and Boolean has SETCAT
 eval : (%,Equation Boolean) -> % 
     if Boolean has EVALAB BOOLEAN and Boolean has SETCAT
 eval : (%,Boolean,Boolean) -> % 
     if Boolean has EVALAB BOOLEAN and Boolean has SETCAT
 eval : (%,List Boolean,List Boolean) -> % 
     if Boolean has EVALAB BOOLEAN and Boolean has SETCAT
 every? : ((Boolean -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 fill! : (%,Boolean) -> % 
     if $ has shallowlyMutable
 find : ((Boolean -> Boolean),%) -> Union(Boolean,"failed")
 first : % -> Boolean if Integer has ORDSET
 index? : (Integer,%) -> Boolean
 indices : % -> List Integer          
 insert : (Boolean,%,Integer) -> %
 insert : (%,%,Integer) -> %
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((Boolean -> Boolean),%) -> %
 map : (((Boolean,Boolean) -> Boolean),%,%) -> %
 map! : ((Boolean -> Boolean),%) -> % 
     if $ has shallowlyMutable
 maxIndex : % -> Integer if Integer has ORDSET
 member? : (Boolean,%) -> Boolean 
     if Boolean has SETCAT and $ has finiteAggregate
 members : % -> List Boolean if $ has finiteAggregate
 merge : (%,%) -> % if Boolean has ORDSET
 minIndex : % -> Integer if Integer has ORDSET
 more? : (%,NonNegativeInteger) -> Boolean
 new : (NonNegativeInteger,Boolean) -> %
 merge : (((Boolean,Boolean) -> Boolean),%,%) -> %
 parts : % -> List Boolean if $ has finiteAggregate
 position : ((Boolean -> Boolean),%) -> Integer
 position : (Boolean,%,Integer) -> Integer 
     if Boolean has SETCAT
 position : (Boolean,%) -> Integer 
     if Boolean has SETCAT
 qelt : (%,Integer) -> Boolean
 qsetelt! : (%,Integer,Boolean) -> Boolean 
     if $ has shallowlyMutable
 reverse : % -> %                     
 reduce : (((Boolean,Boolean) -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 reduce : (((Boolean,Boolean) -> Boolean),%,Boolean) -> Boolean 
     if $ has finiteAggregate
 reduce : 
  (((Boolean,Boolean) -> Boolean),%,Boolean,Boolean) -> Boolean 
     if Boolean has SETCAT and $ has finiteAggregate
 remove : (Boolean,%) -> % 
     if Boolean has SETCAT and $ has finiteAggregate
 remove : ((Boolean -> Boolean),%) -> % 
     if $ has finiteAggregate
 removeDuplicates : % -> % 
     if Boolean has SETCAT and $ has finiteAggregate
 reverse! : % -> % if $ has shallowlyMutable
 sample : () -> %
 setelt : (%,UniversalSegment Integer,Boolean) -> Boolean 
     if $ has shallowlyMutable
 select : ((Boolean -> Boolean),%) -> % 
     if $ has finiteAggregate
 setelt : (%,Integer,Boolean) -> Boolean 
     if $ has shallowlyMutable
 size? : (%,NonNegativeInteger) -> Boolean
 sort : (((Boolean,Boolean) -> Boolean),%) -> %
 sort : % -> % if Boolean has ORDSET
 sort! : % -> % 
     if Boolean has ORDSET and $ has shallowlyMutable
 sort! : (((Boolean,Boolean) -> Boolean),%) -> % 
     if $ has shallowlyMutable
 sorted? : % -> Boolean if Boolean has ORDSET
 sorted? : (((Boolean,Boolean) -> Boolean),%) -> Boolean
 swap! : (%,Integer,Integer) -> Void if $ has shallowlyMutable
 ?.? : (%,UniversalSegment Integer) -> %
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?.? : (%,Integer) -> Boolean
\end{verbatim}

<<category BTAGG BitAggregate>>=
)abbrev category BTAGG BitAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The bit aggregate category models aggregates representing large
++ quantities of Boolean data.
BitAggregate(): Category ==
  Join(OrderedSet, Logic, OneDimensionalArrayAggregate Boolean) with
    "not": % -> %
      ++ not(b) returns the logical {\em not} of bit aggregate 
      ++ \axiom{b}.
    "^"  : % -> %
      ++ ^ b returns the logical {\em not} of bit aggregate 
      ++ \axiom{b}.
    nand : (%, %) -> %
      ++ nand(a,b) returns the logical {\em nand} of bit aggregates 
      ++ \axiom{a} and \axiom{b}.
    nor	 : (%, %) -> %
      ++ nor(a,b) returns the logical {\em nor} of bit aggregates 
      ++ \axiom{a} and \axiom{b}.
    _and : (%, %) -> %
      ++ a and b returns the logical {\em and} of bit aggregates 
      ++ \axiom{a} and \axiom{b}.
    _or	 : (%, %) -> %
      ++ a or b returns the logical {\em or} of bit aggregates 
      ++ \axiom{a} and \axiom{b}.
    xor	 : (%, %) -> %
      ++ xor(a,b) returns the logical {\em exclusive-or} of bit aggregates
      ++ \axiom{a} and \axiom{b}.

 add
   not v      == map(_not, v)
   _^ v	      == map(_not, v)
   _~(v)      == map(_~, v)
   _/_\(v, u) == map(_/_\, v, u)
   _\_/(v, u) == map(_\_/, v, u)
   nand(v, u) == map(nand, v, u)
   nor(v, u)  == map(nor, v, u)

@
<<BTAGG.dotabb>>=
"BTAGG" [color=lightblue,href="bookvol10.2.pdf#nameddest=BTAGG"];
"BTAGG" -> "ORDSET"
"BTAGG" -> "LOGIC"
"BTAGG" -> "A1AGG"

@
<<BTAGG.dotfull>>=
"BitAggregate()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=BTAGG"];
"BitAggregate()" -> "OrderedSet()"
"BitAggregate()" -> "Logic()"
"BitAggregate()" -> "OneDimensionalArrayAggregate(Boolean)"

@
<<BTAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"BitAggregate()" [color=lightblue];
"BitAggregate()" -> "OrderedSet()"
"BitAggregate()" -> "Logic()"
"BitAggregate()" -> "OneDimensionalArrayAggregate(Boolean)"

"OneDimensionalArrayAggregate(Boolean)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=A1AGG"];
"OneDimensionalArrayAggregate(Boolean)" ->    
    "OneDimensionalArrayAggregate(a:Type)"

"OneDimensionalArrayAggregate(a:Type)" [color=lightblue];
"OneDimensionalArrayAggregate(a:Type)" -> 
    "FiniteLinearAggregate(a:Type)"

"FiniteLinearAggregate(a:Type)" [color=lightblue];
"FiniteLinearAggregate(a:Type)" -> "LinearAggregate(a:Type)"

"LinearAggregate(a:Type)" [color=lightblue];
"LinearAggregate(a:Type)" -> "IXAGG..."
"LinearAggregate(a:Type)" -> "CLAGG..."

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SetCategory()"

"SetCategory()" [color=lightblue];
"SetCategory()" -> "BasicType()"
"SetCategory()" -> "CoercibleTo(OutputForm)"

"CoercibleTo(OutputForm)" [color=seagreen];
"CoercibleTo(OutputForm)" -> "CoercibleTo(a:Type)"

"CoercibleTo(a:Type)" [color=lightblue];
"CoercibleTo(a:Type)" -> "Category"

"Logic()" [color=lightblue];
"Logic()" -> "BasicType()"

"BasicType()" [color=lightblue];
"BasicType()" -> "Category"

"Category" [color=lightblue];

"CLAGG..." [color=lightblue];
"IXAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{NonAssociativeRing}{NASRING}
\pagepic{ps/v102nonassociativering.ps}{NASRING}{1.00}

{\bf See:}\\
\pagefrom{MonadWithUnit}{MONADWU}
\pagefrom{NonAssociativeRng}{NARNG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{NASRING}{0} &
\cross{NASRING}{1} &
\cross{NASRING}{antiCommutator} &
\cross{NASRING}{associator} &
\cross{NASRING}{characteristic} \\
\cross{NASRING}{coerce} &
\cross{NASRING}{commutator} &
\cross{NASRING}{hash} &
\cross{NASRING}{latex} &
\cross{NASRING}{leftPower} \\
\cross{NASRING}{leftRecip} &
\cross{NASRING}{one?} &
\cross{NASRING}{recip} &
\cross{NASRING}{rightPower} &
\cross{NASRING}{rightRecip} \\
\cross{NASRING}{sample} &
\cross{NASRING}{subtractIfCan} &
\cross{NASRING}{zero?} &
\cross{NASRING}{?*?} &
\cross{NASRING}{?~=?} \\
\cross{NASRING}{?**?} &
\cross{NASRING}{?+?} &
\cross{NASRING}{?-?} &
\cross{NASRING}{-?} &
\cross{NASRING}{?=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 characteristic : () -> NonNegativeInteger
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 coerce : Integer -> %                
\end{verbatim}

These exports come from NonAssociativeRng():
\begin{verbatim}
 0 : () -> %
 antiCommutator : (%,%) -> %          
 associator : (%,%,%) -> %
 coerce : % -> OutputForm
 commutator : (%,%) -> %              
 hash : % -> SingleInteger
 latex : % -> String                  
 leftPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (%,%) -> %                     
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

These exports come from MonadWithUnit():
\begin{verbatim}
 1 : () -> %                          
 leftPower : (%,NonNegativeInteger) -> %
 leftRecip : % -> Union(%,"failed")
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 rightPower : (%,NonNegativeInteger) -> %
 rightRecip : % -> Union(%,"failed")
 ?**? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category NASRING NonAssociativeRing>>=
)abbrev category NASRING NonAssociativeRing
++ Author: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 11 June 1991
++ Basic Operations: +, *, -, **
++ Related Constructors: NonAssociativeRng, Rng, Ring
++ Also See:
++ AMS Classifications:
++ Keywords: non-associative ring with unit
++ Reference:
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++ Description:
++  A NonAssociativeRing is a non associative rng which has a unit,
++  the multiplication is not necessarily commutative or associative.
NonAssociativeRing(): Category == Join(NonAssociativeRng,MonadWithUnit) with
      characteristic: -> NonNegativeInteger
        ++ characteristic() returns the characteristic of the ring.
        --we can not make this a constant, since some domains are mutable
      coerce: Integer -> %
        ++ coerce(n) coerces the integer n to an element of the ring.
   add
      n:Integer
      coerce(n) == n * 1$%

@
<<NASRING.dotabb>>=
"NASRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NASRING"];
"NASRING" -> "MONADWU"
"NASRING" -> "NARNG"

@
<<NASRING.dotfull>>=
"NonAssociativeRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NASRING"];
"NonAssociativeRing()" -> "NonAssociativeRng()"
"NonAssociativeRing()" -> "MonadWithUnit()"

@
<<NASRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"NonAssociativeRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NASRING"];
"NonAssociativeRing()" -> "NonAssociativeRng()"
"NonAssociativeRing()" -> "MonadWithUnit()"

"MonadWithUnit()" [color=lightblue];
"MonadWithUnit()" -> "Monad()"

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "AbelianGroup()"
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "REPSQ..."

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CancellationAbelianMonoid()"
"AbelianGroup()" -> "REPDB..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "AbelianSemiGroup()"

"AbelianSemiGroup()" [color=lightblue];
"AbelianSemiGroup()" -> "SETCAT..."
"AbelianSemiGroup()" -> "REPDB..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedAbelianGroup}{OAGROUP}
\pagepic{ps/v102orderedabeliangroup.ps}{OAGROUP}{1.00}

{\bf See:}\\
\pageto{OrderedRing}{ORDRING}
\pagefrom{AbelianGroup}{ABELGRP}
\pagefrom{OrderedCancellationAbelianMonoid}{OCAMON}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OAGROUP}{0} &
\cross{OAGROUP}{coerce} &
\cross{OAGROUP}{hash} &
\cross{OAGROUP}{latex} &
\cross{OAGROUP}{max} \\
\cross{OAGROUP}{min} &
\cross{OAGROUP}{sample} &
\cross{OAGROUP}{subtractIfCan} &
\cross{OAGROUP}{zero?} &
\cross{OAGROUP}{?\~{}=?} \\
\cross{OAGROUP}{?*?} &
\cross{OAGROUP}{?+?} &
\cross{OAGROUP}{-?} &
\cross{OAGROUP}{?-?} &
\cross{OAGROUP}{?$<$?} \\
\cross{OAGROUP}{?$<=$?} &
\cross{OAGROUP}{?=?} &
\cross{OAGROUP}{?$>$?} &
\cross{OAGROUP}{?$>=$?} &
\end{tabular}

These exports come from OrderedCancellationAbelianMonoid():
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 max : (%,%) -> %                     
 min : (%,%) -> %
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?<? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean              
 ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean               
 ?>=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                     
\end{verbatim}

These exports come from AbelianGroup():
\begin{verbatim}
 -? : % -> %
 ?*? : (Integer,%) -> %               
 ?-? : (%,%) -> %                     
\end{verbatim}

<<category OAGROUP OrderedAbelianGroup>>=
)abbrev category OAGROUP OrderedAbelianGroup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also abelian groups, such that the 
++ addition preserves the ordering.
OrderedAbelianGroup(): Category ==
        Join(OrderedCancellationAbelianMonoid, AbelianGroup)

@
<<OAGROUP.dotabb>>=
"OAGROUP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OAGROUP"];
"OAGROUP" -> "OCAMON"
"OAGROUP" -> "ABELGRP"

@
<<OAGROUP.dotfull>>=
"OrderedAbelianGroup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OAGROUP"];
"OrderedAbelianGroup()" -> "OrderedCancellationAbelianMonoid()"
"OrderedAbelianGroup()" -> "AbelianGroup()"

@
<<OAGROUP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedAbelianGroup()" [color=lightblue];
"OrderedAbelianGroup()" -> "OrderedCancellationAbelianMonoid()"
"OrderedAbelianGroup()" -> "AbelianGroup()"

"OrderedCancellationAbelianMonoid()" [color=lightblue];
"OrderedCancellationAbelianMonoid()" -> "OAMON..."
"OrderedCancellationAbelianMonoid()" -> "CABMON..."

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"REPDB..." [color="#00EE00"];
"OAMON..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedAbelianMonoidSup}{OAMONS}
\pagepic{ps/v102orderedabelianmonoidsup.ps}{OAMONS}{0.75}

{\bf See:}\\
\pagefrom{OrderedCancellationAbelianMonoid}{OCAMON}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OAMONS}{0} &
\cross{OAMONS}{coerce} &
\cross{OAMONS}{hash} &
\cross{OAMONS}{latex} &
\cross{OAMONS}{max} \\
\cross{OAMONS}{min} &
\cross{OAMONS}{sample} &
\cross{OAMONS}{subtractIfCan} &
\cross{OAMONS}{sup} &
\cross{OAMONS}{zero?} \\
\cross{OAMONS}{?\~{}=?} &
\cross{OAMONS}{?*?} &
\cross{OAMONS}{?$<=$?} &
\cross{OAMONS}{?+?} &
\cross{OAMONS}{?$<$?} \\
\cross{OAMONS}{?=?} &
\cross{OAMONS}{?$>$?} &
\cross{OAMONS}{?$>=$?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 sup : (%,%) -> %                     
\end{verbatim}

These exports come from OrderedCancellationAbelianMonoid():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 max : (%,%) -> %
 min : (%,%) -> %                     
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %
 ?<? : (%,%) -> Boolean               
 ?<=? : (%,%) -> Boolean
 ?=? : (%,%) -> Boolean               
 ?>? : (%,%) -> Boolean
 ?>=? : (%,%) -> Boolean              

\end{verbatim}

<<category OAMONS OrderedAbelianMonoidSup>>=
)abbrev category OAMONS OrderedAbelianMonoidSup
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This domain is an OrderedAbelianMonoid with a \spadfun{sup} 
++ operation added. The purpose of the \spadfun{sup} operator 
++ in this domain is to act as a supremum with respect to the 
++ partial order imposed by \spadop{-}, rather than with respect to
++ the total \spad{>} order (since that is "max").
++
++ Axioms:
++   \spad{sup(a,b)-a \~~= "failed"}
++   \spad{sup(a,b)-b \~~= "failed"}
++   \spad{x-a \~~= "failed" and x-b \~~= "failed" => x >= sup(a,b)}

OrderedAbelianMonoidSup(): Category == OrderedCancellationAbelianMonoid with
  sup: (%,%) -> %
    ++ sup(x,y) returns the least element from which both
    ++ x and y can be subtracted.

@
<<OAMONS.dotabb>>=
"OAMONS"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OAMONS"];
"OAMONS" -> "OCAMON"

@
<<OAMONS.dotfull>>=
"OrderedAbelianMonoidSup()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OAMONS"];
"OrderedAbelianMonoidSup()" -> "OrderedCancellationAbelianMonoid()"

@
<<OAMONS.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedAbelianMonoidSup()" [color=lightblue];
"OrderedAbelianMonoidSup()" -> "OrderedCancellationAbelianMonoid()"

"OrderedCancellationAbelianMonoid()" [color=lightblue];
"OrderedCancellationAbelianMonoid()" -> "OrderedAbelianMonoid()"
"OrderedCancellationAbelianMonoid()" -> "CancellationAbelianMonoid()"

"OrderedAbelianMonoid()" [color=lightblue];
"OrderedAbelianMonoid()" -> "OrderedAbelianSemiGroup()"
"OrderedAbelianMonoid()" -> "AbelianMonoid()"

"OrderedAbelianSemiGroup()" [color=lightblue];
"OrderedAbelianSemiGroup()" -> "OrderedSet()"
"OrderedAbelianSemiGroup()" -> "AbelianMonoid()"

"OrderedSet()" [color=lightblue];
"OrderedSet()" -> "SETCAT..."

"CancellationAbelianMonoid()" [color=lightblue];
"CancellationAbelianMonoid()" -> "AbelianMonoid()"

"AbelianMonoid()" [color=lightblue];
"AbelianMonoid()" -> "ABELSG..."

"SETCAT..." [color=lightblue];
"ABELSG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedMultisetAggregate}{OMSAGG}
\pagepic{ps/v102orderedmultisetaggregate.ps}{OMSAGG}{0.50}

{\bf See:}\\
\pagefrom{MultisetAggregate}{MSETAGG}
\pagefrom{PriorityQueueAggregate}{PRQAGG}

{\bf Exports:}\\
\begin{tabular}{llll}
\cross{OMSAGG}{any?} &
\cross{OMSAGG}{bag} &
\cross{OMSAGG}{brace} &
\cross{OMSAGG}{coerce} \\
\cross{OMSAGG}{construct} &
\cross{OMSAGG}{convert} &
\cross{OMSAGG}{copy} &
\cross{OMSAGG}{count} \\
\cross{OMSAGG}{dictionary} &
\cross{OMSAGG}{difference} &
\cross{OMSAGG}{empty} &
\cross{OMSAGG}{empty?} \\
\cross{OMSAGG}{eq?} &
\cross{OMSAGG}{duplicates} &
\cross{OMSAGG}{eval} &
\cross{OMSAGG}{every?} \\
\cross{OMSAGG}{extract!} &
\cross{OMSAGG}{find} &
\cross{OMSAGG}{hash} &
\cross{OMSAGG}{insert!} \\
\cross{OMSAGG}{inspect} &
\cross{OMSAGG}{intersect} &
\cross{OMSAGG}{latex} &
\cross{OMSAGG}{less?} \\
\cross{OMSAGG}{map} &
\cross{OMSAGG}{map!} &
\cross{OMSAGG}{max} &
\cross{OMSAGG}{member?} \\
\cross{OMSAGG}{members} &
\cross{OMSAGG}{merge} &
\cross{OMSAGG}{merge!} &
\cross{OMSAGG}{min} \\
\cross{OMSAGG}{more?} &
\cross{OMSAGG}{parts} &
\cross{OMSAGG}{reduce} &
\cross{OMSAGG}{remove} \\
\cross{OMSAGG}{remove!} &
\cross{OMSAGG}{removeDuplicates} &
\cross{OMSAGG}{removeDuplicates!} &
\cross{OMSAGG}{sample} \\
\cross{OMSAGG}{select} &
\cross{OMSAGG}{select!} &
\cross{OMSAGG}{set} &
\cross{OMSAGG}{size?} \\
\cross{OMSAGG}{subset?} &
\cross{OMSAGG}{symmetricDifference} &
\cross{OMSAGG}{union} &
\cross{OMSAGG}{\#?} \\
\cross{OMSAGG}{?$<$?} &
\cross{OMSAGG}{?=?} &
\cross{OMSAGG}{?\~{}?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 min : % -> S
\end{verbatim}

These exports come from MultisetAggregate(S:OrderedSet):
\begin{verbatim}
 any? : ((S -> Boolean),%) -> Boolean if $ has finiteAggregate
 bag : List S -> %                    
 brace : () -> %
 brace : List S -> %                  
 coerce : % -> OutputForm
 construct : List S -> %              
 convert : % -> InputForm if S has KONVERT INFORM
 copy : % -> %
 count : (S,%) -> NonNegativeInteger 
     if S has SETCAT and $ has finiteAggregate
 count : ((S -> Boolean),%) -> NonNegativeInteger 
     if $ has finiteAggregate
 dictionary : List S -> %             
 dictionary : () -> %
 difference : (%,S) -> %
 difference : (%,%) -> %              
 duplicates : % -> 
     List Record(entry: S,count: NonNegativeInteger)
 empty : () -> %                      
 empty? : % -> Boolean
 eq? : (%,%) -> Boolean               
 eval : (%,List S,List S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,S,S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,Equation S) -> % 
     if S has EVALAB S and S has SETCAT
 eval : (%,List Equation S) -> % 
     if S has EVALAB S and S has SETCAT
 every? : ((S -> Boolean),%) -> Boolean 
     if $ has finiteAggregate
 extract! : % -> S
 find : ((S -> Boolean),%) -> Union(S,"failed")
 hash : % -> SingleInteger            
 insert! : (S,%) -> %
 insert! : (S,%,NonNegativeInteger) -> %
 inspect : % -> S                     
 intersect : (%,%) -> %
 latex : % -> String                  
 less? : (%,NonNegativeInteger) -> Boolean
 map : ((S -> S),%) -> %
 map! : ((S -> S),%) -> % if $ has shallowlyMutable
 member? : (S,%) -> Boolean 
     if S has SETCAT and $ has finiteAggregate
 members : % -> List S if $ has finiteAggregate
 more? : (%,NonNegativeInteger) -> Boolean
 parts : % -> List S if $ has finiteAggregate
 reduce : (((S,S) -> S),%) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S) -> S 
     if $ has finiteAggregate
 reduce : (((S,S) -> S),%,S,S) -> S 
     if S has SETCAT and $ has finiteAggregate
 remove : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove : (S,%) -> % 
     if S has SETCAT and $ has finiteAggregate
 remove! : ((S -> Boolean),%) -> % 
     if $ has finiteAggregate
 remove! : (S,%) -> % 
     if $ has finiteAggregate
 removeDuplicates : % -> % 
     if S has SETCAT and $ has finiteAggregate
 removeDuplicates! : % -> %           
 sample : () -> %
 select : ((S -> Boolean),%) -> % if $ has finiteAggregate
 select! : ((S -> Boolean),%) -> % if $ has finiteAggregate
 set : () -> %                        
 set : List S -> %
 size? : (%,NonNegativeInteger) -> Boolean
 subset? : (%,%) -> Boolean           
 symmetricDifference : (%,%) -> %
 union : (%,%) -> %
 union : (%,S) -> %                   
 union : (S,%) -> %
 #? : % -> NonNegativeInteger if $ has finiteAggregate
 ?~=? : (%,%) -> Boolean              
 ?=? : (%,%) -> Boolean
 ?<? : (%,%) -> Boolean               
\end{verbatim}

These exports come from PriorityQueueAggregate(S:OrderedSet):
\begin{verbatim}
 max : % -> S                         
 merge : (%,%) -> %
 merge! : (%,%) -> %                  
\end{verbatim}

<<category OMSAGG OrderedMultisetAggregate>>=
)abbrev category OMSAGG OrderedMultisetAggregate
++ Author: Michael Monagan; revised by Manuel Bronstein and Richard Jenks
++ Date Created: August 87 through August 88
++ Date Last Updated: April 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An ordered-multiset aggregate is a multiset built over an ordered set S
++ so that the relative sizes of its entries can be assessed.
++ These aggregates serve as models for priority queues.
OrderedMultisetAggregate(S:OrderedSet): Category ==
   Join(MultisetAggregate S,PriorityQueueAggregate S) with
   -- max: % -> S		      ++ smallest entry in the set
   -- duplicates: % -> List Record(entry:S,count:NonNegativeInteger)
        ++ to become an in order iterator
   -- parts: % -> List S	      ++ in order iterator
      min: % -> S
	++ min(u) returns the smallest entry in the multiset aggregate u.

@
<<OMSAGG.dotabb>>=
"OMSAGG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OMSAGG"];
"OMSAGG" -> "MSETAGG"
"OMSAGG" -> "PRQAGG"

@
<<OMSAGG.dotfull>>=
"OrderedMultisetAggregate(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OMSAGG"];
"OrderedMultisetAggregate(a:SetCategory)" ->
    "MultisetAggregate(a:SetCategory)"
"OrderedMultisetAggregate(a:SetCategory)" -> 
   "PriorityQueueAggregate(a:SetCategory)"

@
<<OMSAGG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedMultisetAggregate(a:SetCategory)" [color=lightblue];
"OrderedMultisetAggregate(a:SetCategory)" ->
    "MultisetAggregate(a:SetCategory)"
"OrderedMultisetAggregate(a:SetCategory)" -> 
   "PriorityQueueAggregate(a:SetCategory)"

"MultisetAggregate(a:SetCategory)" [color=lightblue];
"MultisetAggregate(a:SetCategory)" -> "MultiDictionary(a:SetCategory)"
"MultisetAggregate(a:SetCategory)" -> "SetAggregate(a:SetCategory)"

"MultiDictionary(a:SetCategory)" [color=lightblue];
"MultiDictionary(a:SetCategory)" -> "DictionaryOperations(a:SetCategory)"

"SetAggregate(a:SetCategory)" [color=lightblue];
"SetAggregate(a:SetCategory)" -> "SETAGG..."
"SetAggregate(a:SetCategory)" -> "CLAGG..."

"DictionaryOperations(a:SetCategory)" [color=lightblue];
"DictionaryOperations(a:SetCategory)" -> "BGAGG..."
"DictionaryOperations(a:SetCategory)" -> "CLAGG..."

"PriorityQueueAggregate(a:SetCategory)" [color=seagreen];
"PriorityQueueAggregate(a:SetCategory)" -> "PriorityQueueAggregate(a:Type)"

"PriorityQueueAggregate(a:Type)" [color=lightblue];
"PriorityQueueAggregate(a:Type)" -> "BGAGG..."

"BGAGG..." [color=lightblue];
"CLAGG..." [color=lightblue];
"SETAGG..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Ring}{RING}
\pagepic{ps/v102ring.ps}{RING}{1.00}

{\bf See:}\\
\pageto{Algebra}{ALGEBRA}
\pageto{CharacteristicNonZero}{CHARNZ}
\pageto{CharacteristicZero}{CHARZ}
\pageto{CommutativeRing}{COMRING}
\pageto{DifferentialExtension}{DIFEXT}
\pageto{DifferentialRing}{DIFRING}
\pageto{EntireRing}{ENTIRER}
\pageto{LinearlyExplicitRingOver}{LINEXP}
\pageto{OrderedRing}{ORDRING}
\pageto{PartialDifferentialRing}{PDRING}
\pagefrom{LeftModule}{LMODULE}
\pagefrom{Monoid}{MONOID}
\pagefrom{Rng}{RNG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{RING}{1} &
\cross{RING}{0} &
\cross{RING}{characteristic} &
\cross{RING}{coerce} &
\cross{RING}{hash} \\
\cross{RING}{latex} &
\cross{RING}{one?} &
\cross{RING}{recip} &
\cross{RING}{sample} &
\cross{RING}{subtractIfCan} \\
\cross{RING}{zero?} &
\cross{RING}{?\~{}=?} &
\cross{RING}{?*?} &
\cross{RING}{?**?} &
\cross{RING}{?\^{}?} \\
\cross{RING}{?*?} &
\cross{RING}{?**?} &
\cross{RING}{?+?} &
\cross{RING}{?-?} &
\cross{RING}{-?} \\
\cross{RING}{?=?} &&&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{RING}{unitsKnown}}
is true if a monoid (a multiplicative semigroup with a 1) has 
unitsKnown means that  the operation {\tt recip} can only return 
``failed'' if its argument is not a unit.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 characteristic : () -> NonNegativeInteger
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 coerce : Integer -> %
\end{verbatim}

These exports come from Rng():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (Integer,%) -> %
 ?*? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
\end{verbatim}

These exports come from Monoid():
\begin{verbatim}
 1 : () -> %                          
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

TPDHERE: Note that none of the exports of LeftModule are needed.
Perhaps this can be eliminated.

<<category RING Ring>>=
)abbrev category RING Ring
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of rings with unity, always associative, but
++ not necessarily commutative.
Ring(): Category == Join(Rng,Monoid,LeftModule(%)) with
      characteristic: () -> NonNegativeInteger
        ++ characteristic() returns the characteristic of the ring
        ++ this is the smallest positive integer n such that
        ++ \spad{n*x=0} for all x in the ring, or zero if no such n
        ++ exists.
        --We can not make this a constant, since some domains are mutable
      coerce: Integer -> %
        ++ coerce(i) converts the integer i to a member of the given domain.
--    recip: % -> Union(%,"failed") -- inherited from Monoid
      unitsKnown
        ++ recip truly yields
        ++ reciprocal or "failed" if not a unit.
        ++ Note: \spad{recip(0) = "failed"}.
   add
      n:Integer
      coerce(n) == n * 1$%

@
<<RING.dotabb>>=
"RING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RING"];
"RING" -> "RNG"
"RING" -> "MONOID"
"RING" -> "LMODULE"

@
<<RING.dotfull>>=
"Ring()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=RING"];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

@
<<RING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
\chapter{Category Layer 9}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CharacteristicNonZero}{CHARNZ}
\pagepic{ps/v102characteristicnonzero.ps}{CHARNZ}{0.90}

{\bf See:}\\
\pageto{FiniteRankAlgebra}{FINRALG}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{CHARNZ}{1} &
\cross{CHARNZ}{0} &
\cross{CHARNZ}{coerce} &
\cross{CHARNZ}{hash} &
\cross{CHARNZ}{latex} \\
\cross{CHARNZ}{one?} &
\cross{CHARNZ}{recip} &
\cross{CHARNZ}{sample} &
\cross{CHARNZ}{zero?} &
\cross{CHARNZ}{characteristic} \\
\cross{CHARNZ}{charthRoot} &
\cross{CHARNZ}{subtractIfCan} &
\cross{CHARNZ}{?\~{}=?} &
\cross{CHARNZ}{?\^{}?} &
\cross{CHARNZ}{?*?} \\
\cross{CHARNZ}{?**?} &
\cross{CHARNZ}{?+?} &
\cross{CHARNZ}{?-?} &
\cross{CHARNZ}{-?} &
\cross{CHARNZ}{?=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 charthRoot : % -> Union(%,"failed")
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 1 : () -> %                          
 0 : () -> %
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 zero? : % -> Boolean                 
 characteristic : () -> NonNegativeInteger
 subtractIfCan : (%,%) -> Union(%,"failed")
 ?~=? : (%,%) -> Boolean
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?*? : (%,%) -> %                     
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category CHARNZ CharacteristicNonZero>>=
)abbrev category CHARNZ CharacteristicNonZero
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Rings of Characteristic Non Zero
CharacteristicNonZero():Category == Ring with
    charthRoot: % -> Union(%,"failed")
       ++ charthRoot(x) returns the pth root of x
       ++ where p is the characteristic of the ring.

@
<<CHARNZ.dotabb>>=
"CHARNZ"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CHARNZ"];
"CHARNZ" -> "RING"

@
<<CHARNZ.dotfull>>=
"CharacteristicNonZero()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CHARNZ"];
"CharacteristicNonZero()" -> "Ring()"

@
<<CHARNZ.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CharacteristicNonZero()" [color=lightblue];
"CharacteristicNonZero()" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CharacteristicZero}{CHARZ}
\pagepic{ps/v102characteristiczero.ps}{CHARZ}{0.90}

{\bf See:}\\
\pageto{FiniteRankAlgebra}{FINRALG}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{CHARZ}{1} &
\cross{CHARZ}{0} &
\cross{CHARZ}{coerce} &
\cross{CHARZ}{hash} &
\cross{CHARZ}{latex} \\
\cross{CHARZ}{one?} &
\cross{CHARZ}{recip} &
\cross{CHARZ}{sample} &
\cross{CHARZ}{zero?} &
\cross{CHARZ}{characteristic} \\
\cross{CHARZ}{subtractIfCan} &
\cross{CHARZ}{?\~{}=?} &
\cross{CHARZ}{?\^{}?} &
\cross{CHARZ}{?*?} \\
\cross{CHARZ}{?**?} &
\cross{CHARZ}{?+?} &
\cross{CHARZ}{?-?} &
\cross{CHARZ}{-?} &
\cross{CHARZ}{?=?} \\
\end{tabular}

These exports come from Ring():
\begin{verbatim}
 1 : () -> %                          
 0 : () -> %
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 zero? : % -> Boolean                 
 characteristic : () -> NonNegativeInteger
 subtractIfCan : (%,%) -> Union(%,"failed")
 ?~=? : (%,%) -> Boolean
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?*? : (%,%) -> %                     
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category CHARZ CharacteristicZero>>=
)abbrev category CHARZ CharacteristicZero
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Rings of Characteristic Zero.
CharacteristicZero():Category == Ring

@
<<CHARZ.dotabb>>=
"CHARZ"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CHARZ"];
"CHARZ" -> "RING"

@
<<CHARZ.dotfull>>=
"CharacteristicZero()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=CHARZ"];
"CharacteristicZero()" -> "Ring()"

@
<<CHARZ.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CharacteristicZero()" [color=lightblue];
"CharacteristicZero()" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{CommutativeRing}{COMRING}
\pagepic{ps/v102commutativering.ps}{COMRING}{0.65}

{\bf See:}\\
\pageto{IntegralDomain}{INTDOM}
\pageto{MonogenicAlgebra}{MONOGEN}
\pagefrom{BiModule}{BMODULE}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{COMRING}{1} &
\cross{COMRING}{0} &
\cross{COMRING}{coerce} &
\cross{COMRING}{hash} &
\cross{COMRING}{latex} \\
\cross{COMRING}{one?} &
\cross{COMRING}{recip} &
\cross{COMRING}{sample} &
\cross{COMRING}{zero?} &
\cross{COMRING}{characteristic} \\
\cross{COMRING}{subtractIfCan} &
\cross{COMRING}{?\~{}=?} &
\cross{COMRING}{?\^{}?} &
\cross{COMRING}{?*?} &
\cross{COMRING}{?**?} \\
\cross{COMRING}{?+?} &
\cross{COMRING}{?-?} &
\cross{COMRING}{-?} &
\cross{COMRING}{?=?} &
\end{tabular}

{\bf Attributes:}
\begin{itemize}
\item {\bf \cross{COMRING}{commutative("*")}}
is true if it has an operation $"*": (D,D) -> D$
which is commutative.
\end{itemize}


These exports come from Ring():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

TPDHERE: Note that none of the exports of BiModule(a:Ring,b:Ring)
are needed. Perhaps this can be eliminated. 

<<category COMRING CommutativeRing>>=
)abbrev category COMRING CommutativeRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of commutative rings with unity, i.e. rings where
++ \spadop{*} is commutative, and which have a multiplicative identity.
++ element.
--CommutativeRing():Category == Join(Ring,BiModule(%:Ring,%:Ring)) with
CommutativeRing():Category == Join(Ring,BiModule(%,%)) with
    commutative("*")  ++ multiplication is commutative.

@
<<COMRING.dotabb>>=
"COMRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=COMRING"];
"COMRING" -> "RING"
"COMRING" -> "BMODULE"

@
<<COMRING.dotfull>>=
"CommutativeRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=COMRING"];
"CommutativeRing()" -> "Ring()"
"CommutativeRing()" -> "BiModule(a:Ring,b:Ring)"

@
<<COMRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "Ring()"
"CommutativeRing()" -> "BiModule(a:Ring,b:Ring)"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "AbelianGroup()"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DifferentialRing}{DIFRING}
\pagepic{ps/v102differentialring.ps}{DIFRING}{0.90}

{\bf See:}\\
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DIFRING}{1} &
\cross{DIFRING}{0} &
\cross{DIFRING}{characteristic} &
\cross{DIFRING}{coerce} &
\cross{DIFRING}{D} \\
\cross{DIFRING}{differentiate} &
\cross{DIFRING}{hash} &
\cross{DIFRING}{latex} &
\cross{DIFRING}{one?} &
\cross{DIFRING}{recip} \\
\cross{DIFRING}{sample} &
\cross{DIFRING}{subtractIfCan} &
\cross{DIFRING}{zero?} &
\cross{DIFRING}{?\~{}=?} &
\cross{DIFRING}{?**?} \\
\cross{DIFRING}{?\^{}?} &
\cross{DIFRING}{?*?} &
\cross{DIFRING}{?+?} &
\cross{DIFRING}{?-?} &
\cross{DIFRING}{-?} \\
\cross{DIFRING}{?=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 differentiate : % -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 D : % -> %
 D : (%,NonNegativeInteger) -> %      
 differentiate : (%,NonNegativeInteger) -> %
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 1 : () -> %                          
 0 : () -> %
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger            
 latex : % -> String
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?*? : (%,%) -> %                     
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category DIFRING DifferentialRing>>=
)abbrev category DIFRING DifferentialRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An ordinary differential ring, that is, a ring with an operation
++ \spadfun{differentiate}.
++
++ Axioms:
++   \spad{differentiate(x+y) = differentiate(x)+differentiate(y)}
++   \spad{differentiate(x*y) = x*differentiate(y) + differentiate(x)*y}

DifferentialRing(): Category == Ring with
    differentiate: % -> %
         ++ differentiate(x) returns the derivative of x.
         ++ This function is a simple differential operator
         ++ where no variable needs to be specified.
    D: % -> %
         ++ D(x) returns the derivative of x.
         ++ This function is a simple differential operator
         ++ where no variable needs to be specified.
    differentiate: (%, NonNegativeInteger) -> %
         ++ differentiate(x, n) returns the n-th derivative of x.
    D: (%, NonNegativeInteger) -> %
         ++ D(x, n) returns the n-th derivative of x.
  add
    D r == differentiate r
    differentiate(r, n) ==
      for i in 1..n repeat r := differentiate r
      r
    D(r,n) == differentiate(r,n)

@
<<DIFRING.dotabb>>=
"DIFRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIFRING"];
"DIFRING" -> "RING"

@
<<DIFRING.dotfull>>=
"DifferentialRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIFRING"];
"DifferentialRing()" -> "Ring()"

@
<<DIFRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DifferentialRing()" [color=lightblue];
"DifferentialRing()" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{EntireRing}{ENTIRER}
\pagepic{ps/v102EntireRing.ps}{ENTIRER}{0.65}

{\bf See:}\\
\pageto{DivisionRing}{DIVRING}
\pageto{IntegralDomain}{INTDOM}
\pagefrom{BiModule}{BMODULE}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ENTIRER}{1} &
\cross{ENTIRER}{0} &
\cross{ENTIRER}{characteristic} &
\cross{ENTIRER}{coerce} &
\cross{ENTIRER}{hash} \\
\cross{ENTIRER}{latex} &
\cross{ENTIRER}{one?} &
\cross{ENTIRER}{recip} &
\cross{ENTIRER}{sample} &
\cross{ENTIRER}{subtractIfCan} \\
\cross{ENTIRER}{zero?} &
\cross{ENTIRER}{?\^{}?} &
\cross{ENTIRER}{?\~{}=?} &
\cross{ENTIRER}{?*?} &
\cross{ENTIRER}{?**?} \\
\cross{ENTIRER}{?*?} &
\cross{ENTIRER}{?+?} &
\cross{ENTIRER}{?-?} &
\cross{ENTIRER}{-?} &
\cross{ENTIRER}{?=?} \\
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{ENTIRER}{noZeroDivisors}}
is true if $x * y ~= 0$ implies both x and y are non-zero.
\end{itemize}

These exports come from Ring():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

TPDHERE: Note that none of the exports of BiModule(a:Ring,b:Ring)
are needed. Perhaps this can be eliminated. 

<<category ENTIRER EntireRing>>=
)abbrev category ENTIRER EntireRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Entire Rings (non-commutative Integral Domains), i.e. a ring
++ not necessarily commutative which has no zero divisors.
++
++ Axioms:
++   \spad{ab=0 => a=0 or b=0}  -- known as noZeroDivisors
++   \spad{not(1=0)}
--EntireRing():Category == Join(Ring,BiModule(%:Ring,%:Ring)) with
EntireRing():Category == Join(Ring,BiModule(%,%)) with
      noZeroDivisors  ++ if a product is zero then one of the factors
                      ++ must be zero.

@
<<ENTIRER.dotabb>>=
"ENTIRER"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ENTIRER"];
"ENTIRER" -> "RING"
"ENTIRER" -> "BMODULE"

@
<<ENTIRER.dotfull>>=
"EntireRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ENTIRER"];
"EntireRing()" -> "Ring()"
"EntireRing()" -> "BiModule(a:Ring,b:Ring)"

@
<<ENTIRER.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"EntireRing()" [color=lightblue];
"EntireRing()" -> "Ring()"
"EntireRing()" -> "BiModule(a:Ring,b:Ring)"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "ABELGRP..."
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"ABELGRP..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{LinearlyExplicitRingOver}{LINEXP}
\pagepic{ps/v102linearlyexplicitringover.ps}{LINEXP}{0.90}

{\bf See:}\\
\pageto{FullyLinearlyExplicitRingOver}{FLINEXP}
\pageto{MonogenicAlgebra}{MONOGEN}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{LINEXP}{0} &
\cross{LINEXP}{1} &
\cross{LINEXP}{characteristic} &
\cross{LINEXP}{coerce} &
\cross{LINEXP}{hash} \\
\cross{LINEXP}{latex} &
\cross{LINEXP}{one?} &
\cross{LINEXP}{recip} &
\cross{LINEXP}{reducedSystem} &
\cross{LINEXP}{subtractIfCan} \\
\cross{LINEXP}{sample} &
\cross{LINEXP}{zero?} &
\cross{LINEXP}{?*?} &
\cross{LINEXP}{?**?} &
\cross{LINEXP}{?+?} \\
\cross{LINEXP}{?-?} &
\cross{LINEXP}{-?} &
\cross{LINEXP}{?=?} &
\cross{LINEXP}{?\^{}?} &
\cross{LINEXP}{?\~{}=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 reducedSystem : (Matrix %,Vector %) -> 
     Record(mat: Matrix R,vec: Vector R)
 reducedSystem : Matrix % -> Matrix R
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (Integer,%) -> %
 ?*? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category LINEXP LinearlyExplicitRingOver>>=
)abbrev category LINEXP LinearlyExplicitRingOver
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ An extension ring with an explicit linear dependence test.
LinearlyExplicitRingOver(R:Ring): Category == Ring with
  reducedSystem: Matrix % -> Matrix R
    ++ reducedSystem(A) returns a matrix B such that \spad{A x = 0} 
    ++ and \spad{B x = 0} have the same solutions in R.
  reducedSystem: (Matrix %,Vector %) -> Record(mat:Matrix R,vec:Vector R)
    ++ reducedSystem(A, v) returns a matrix B and a vector w such that
    ++ \spad{A x = v} and \spad{B x = w} have the same solutions in R.

@
<<LINEXP.dotabb>>=
"LINEXP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LINEXP"];
"LINEXP" -> "RING"

@
<<LINEXP.dotfull>>=
"LinearlyExplicitRingOver(a:Ring)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=LINEXP"];
"LinearlyExplicitRingOver(a:Ring)" -> "Ring()"

"LinearlyExplicitRingOver(Integer)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=LINEXP"];
"LinearlyExplicitRingOver(Integer)" -> "LinearlyExplicitRingOver(a:Ring)"

"LinearlyExplicitRingOver(Fraction(Integer))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=LINEXP"];
"LinearlyExplicitRingOver(Fraction(Integer))" -> 
    "LinearlyExplicitRingOver(a:Ring)"

@
<<LINEXP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"LinearlyExplicitRingOver(a:Ring)" [color=lightblue];
"LinearlyExplicitRingOver(a:Ring)" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedRing}{ORDRING}
\pagepic{ps/v102orderedring.ps}{ORDRING}{0.65}

{\bf See:}\\
\pageto{OrderedIntegralDomain}{OINTDOM}
\pagefrom{Monoid}{MONOID}
\pagefrom{OrderedAbelianGroup}{OAGROUP}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ORDRING}{1} &
\cross{ORDRING}{0} &
\cross{ORDRING}{abs} &
\cross{ORDRING}{characteristic} &
\cross{ORDRING}{coerce} \\
\cross{ORDRING}{hash} &
\cross{ORDRING}{latex} &
\cross{ORDRING}{max} &
\cross{ORDRING}{min} &
\cross{ORDRING}{negative?} \\
\cross{ORDRING}{one?} &
\cross{ORDRING}{positive?} &
\cross{ORDRING}{recip} &
\cross{ORDRING}{sample} &
\cross{ORDRING}{sign} \\
\cross{ORDRING}{subtractIfCan} &
\cross{ORDRING}{zero?} &
\cross{ORDRING}{?\^{}?} &
\cross{ORDRING}{?\~{}=?} &
\cross{ORDRING}{?*?} \\
\cross{ORDRING}{?**?} &
\cross{ORDRING}{?+?} &
\cross{ORDRING}{-?} &
\cross{ORDRING}{?-?} &
\cross{ORDRING}{?$<$?} \\
\cross{ORDRING}{?$<=$?} &
\cross{ORDRING}{?=?} &
\cross{ORDRING}{?$>$?} &
\cross{ORDRING}{?$>=$?} &
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 abs : % -> %
 negative? : % -> Boolean             
 positive? : % -> Boolean             
 sign : % -> Integer
\end{verbatim}

These exports come from OrderedAbelianGroup():
\begin{verbatim}
 0 : () -> %
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 max : (%,%) -> %                     
 min : (%,%) -> %
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?<? : (%,%) -> Boolean
 ?<=? : (%,%) -> Boolean              
 ?=? : (%,%) -> Boolean
 ?>? : (%,%) -> Boolean               
 ?>=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (Integer,%) -> %
 ?+? : (%,%) -> %                     
 -? : % -> %
 ?-? : (%,%) -> %                     
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %                
 one? : % -> Boolean
 recip : % -> Union(%,"failed")
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?*? : (%,%) -> %                     
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
\end{verbatim}

TPDHERE: Note that none of the exports of Monoid are needed.
Perhaps this can be eliminated.

These exports come from Monoid();
\begin{verbatim}
\end{verbatim}

<<category ORDRING OrderedRing>>=
)abbrev category ORDRING OrderedRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Ordered sets which are also rings, that is, domains where the ring
++ operations are compatible with the ordering.
++
++ Axiom:
++   \spad{0<a and b<c => ab< ac}
OrderedRing(): Category == Join(OrderedAbelianGroup,Ring,Monoid) with
     positive?: % -> Boolean
       ++ positive?(x) tests whether x is strictly greater than 0.
     negative?: % -> Boolean
       ++ negative?(x) tests whether x is strictly less than 0.
     sign     : % -> Integer
       ++ sign(x) is 1 if x is positive, -1 if x is negative, 
       ++ 0 if x equals 0.
     abs      : % -> %
       ++ abs(x) returns the absolute value of x.
  add
     positive? x == x>0
     negative? x == x<0
     sign x ==
       positive? x => 1
       negative? x => -1
       zero? x => 0
       error "x satisfies neither positive?, negative? or zero?"
     abs x ==
       positive? x => x
       negative? x => -x
       zero? x => 0
       error "x satisfies neither positive?, negative? or zero?"

@
<<ORDRING.dotabb>>=
"ORDRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDRING"];
"ORDRING" -> "OAGROUP"
"ORDRING" -> "RING"
"ORDRING" -> "MONOID"

@
<<ORDRING.dotfull>>=
"OrderedRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ORDRING"];
"OrderedRing()" -> "OrderedAbelianGroup()"
"OrderedRing()" -> "Ring()"
"OrderedRing()" -> "Monoid()"

@
<<ORDRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedRing()" [color=lightblue];
"OrderedRing()" -> "OrderedAbelianGroup()"
"OrderedRing()" -> "Ring()"
"OrderedRing()" -> "Monoid()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "ABELGRP..."
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"OrderedAbelianGroup()" [color=lightblue];
"OrderedAbelianGroup()" -> "OCAMON..."
"OrderedAbelianGroup()" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPSQ..." [color="#00EE00"];
"OCAMON..." [color=lightblue];
"SETCAT..." [color=lightblue];
"ABELGRP..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{PartialDifferentialRing}{PDRING}
\pagepic{ps/v102partialdifferentialring.ps}{PDRING}{1.00}

{\bf See:}\\
\pageto{DifferentialExtension}{DIFEXT}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{PDRING}{1} &
\cross{PDRING}{0} &
\cross{PDRING}{characteristic} &
\cross{PDRING}{coerce} &
\cross{PDRING}{D} \\
\cross{PDRING}{differentiate} &
\cross{PDRING}{hash} &
\cross{PDRING}{latex} &
\cross{PDRING}{one?} &
\cross{PDRING}{recip} \\
\cross{PDRING}{sample} &
\cross{PDRING}{subtractIfCan} &
\cross{PDRING}{zero?} &
\cross{PDRING}{?\^{}?} &
\cross{PDRING}{?*?} \\
\cross{PDRING}{?\~{}=?} &
\cross{PDRING}{?**?} &
\cross{PDRING}{?+?} &
\cross{PDRING}{?-?} &
\cross{PDRING}{-?} \\
\cross{PDRING}{?=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 differentiate : (%,S) -> %           
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 differentiate : (%,List S) -> %
 differentiate : (%,S,NonNegativeInteger) -> %
 differentiate : (%,List S,List NonNegativeInteger) -> %
 D : (%,S) -> %
 D : (%,List S) -> %                  
 D : (%,S,NonNegativeInteger) -> %
 D : (%,List S,List NonNegativeInteger) -> %
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 characteristic : () -> NonNegativeInteger
 0 : () -> %
 1 : () -> %                          
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

<<category PDRING PartialDifferentialRing>>=
)abbrev category PDRING PartialDifferentialRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A partial differential ring with differentiations indexed by a 
++ parameter type S.
++
++ Axioms:
++  \spad{differentiate(x+y,e) = differentiate(x,e)+differentiate(y,e)}
++  \spad{differentiate(x*y,e) = x*differentiate(y,e)+differentiate(x,e)*y}

PartialDifferentialRing(S:SetCategory): Category == Ring with
    differentiate: (%, S) -> %
        ++ differentiate(x,v) computes the partial derivative of x
        ++ with respect to v.
    differentiate: (%, List S) -> %
        ++ differentiate(x,[s1,...sn]) computes successive partial 
        ++ derivatives,
        ++ i.e. \spad{differentiate(...differentiate(x, s1)..., sn)}.
    differentiate: (%, S, NonNegativeInteger) -> %
        ++ differentiate(x, s, n) computes multiple partial derivatives, i.e.
        ++ n-th derivative of x with respect to s.
    differentiate: (%, List S, List NonNegativeInteger) -> %
        ++ differentiate(x, [s1,...,sn], [n1,...,nn]) computes
        ++ multiple partial derivatives, i.e.
    D: (%, S) -> %
        ++ D(x,v) computes the partial derivative of x
        ++ with respect to v.
    D: (%, List S) -> %
        ++ D(x,[s1,...sn]) computes successive partial derivatives,
        ++ i.e. \spad{D(...D(x, s1)..., sn)}.
    D: (%, S, NonNegativeInteger) -> %
        ++ D(x, s, n) computes multiple partial derivatives, i.e.
        ++ n-th derivative of x with respect to s.
    D: (%, List S, List NonNegativeInteger) -> %
        ++ D(x, [s1,...,sn], [n1,...,nn]) computes
        ++ multiple partial derivatives, i.e.
        ++ \spad{D(...D(x, s1, n1)..., sn, nn)}.
  add
    differentiate(r:%, l:List S) ==
      for s in l repeat r := differentiate(r, s)
      r

    differentiate(r:%, s:S, n:NonNegativeInteger) ==
      for i in 1..n repeat r := differentiate(r, s)
      r

    differentiate(r:%, ls:List S, ln:List NonNegativeInteger) ==
      for s in ls for n in ln repeat r := differentiate(r, s, n)
      r

    D(r:%, v:S) == differentiate(r,v)
    D(r:%, lv:List S) == differentiate(r,lv)
    D(r:%, v:S, n:NonNegativeInteger) == differentiate(r,v,n)
    D(r:%, lv:List S, ln:List NonNegativeInteger) == differentiate(r, lv, ln)

@
<<PDRING.dotabb>>=
"PDRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PDRING"];
"PDRING" -> "RING"

@
<<PDRING.dotfull>>=
"PartialDifferentialRing(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PDRING"];
"PartialDifferentialRing(a:SetCategory)" -> "Ring()"

"PartialDifferentialRing(a:OrderedSet)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=PDRING"];
"PartialDifferentialRing(a:OrderedSet)" ->
    "PartialDifferentialRing(a:SetCategory)"

"PartialDifferentialRing(Symbol)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=PDRING"];
"PartialDifferentialRing(Symbol)" ->
    "PartialDifferentialRing(a:SetCategory)"

@
<<PDRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"PartialDifferentialRing(a:SetCategory)" [color=lightblue];
"PartialDifferentialRing(a:SetCategory)" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
\chapter{Category Layer 10}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DifferentialExtension}{DIFEXT}
\pagepic{ps/v102differentialextension.ps}{DIFEXT}{0.65}

{\bf See:}\\
\pagefrom{PartialDifferentialRing}{PDRING}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DIFEXT}{1} &
\cross{DIFEXT}{0} &
\cross{DIFEXT}{characteristic} &
\cross{DIFEXT}{coerce} &
\cross{DIFEXT}{D} \\
\cross{DIFEXT}{differentiate} &
\cross{DIFEXT}{hash} &
\cross{DIFEXT}{latex} &
\cross{DIFEXT}{one?} &
\cross{DIFEXT}{recip} \\
\cross{DIFEXT}{sample} &
\cross{DIFEXT}{subtractIfCan} &
\cross{DIFEXT}{zero?} &
\cross{DIFEXT}{?*?} &
\cross{DIFEXT}{?\~{}=?} \\
\cross{DIFEXT}{?**?} &
\cross{DIFEXT}{?+?} &
\cross{DIFEXT}{?-?} &
\cross{DIFEXT}{-?} &
\cross{DIFEXT}{?=?} \\
\cross{DIFEXT}{?\^{}?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 differentiate : (%,(R -> R)) -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 D : (%,(R -> R)) -> %
 D : (%,(R -> R),NonNegativeInteger) -> %
 differentiate : % -> % if R has DIFRING
 differentiate : (%,(R -> R),NonNegativeInteger) -> %
 differentiate : (%,Symbol) -> % if R has PDRING SYMBOL
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
\end{verbatim}

These exports come from DifferentialRing():
\begin{verbatim}
 D : % -> % if R has DIFRING          
 D : (%,NonNegativeInteger) -> % if R has DIFRING
 differentiate : (%,NonNegativeInteger) -> % 
     if R has DIFRING
\end{verbatim}

These exports come from PartialDifferentialRing(Symbol):
\begin{verbatim}
 differentiate : (%,List Symbol) -> % 
     if R has PDRING SYMBOL
 differentiate : (%,Symbol,NonNegativeInteger) -> % 
     if R has PDRING SYMBOL
 differentiate : (%,List Symbol,List NonNegativeInteger) -> % 
     if R has PDRING SYMBOL
 D : (%,Symbol) -> % if R has PDRING SYMBOL
 D : (%,List Symbol) -> % if R has PDRING SYMBOL
 D : (%,Symbol,NonNegativeInteger) -> % 
     if R has PDRING SYMBOL
 D : (%,List Symbol,List NonNegativeInteger) -> % 
     if R has PDRING SYMBOL
\end{verbatim}

<<category DIFEXT DifferentialExtension>>=
)abbrev category DIFEXT DifferentialExtension
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Differential extensions of a ring R.
++ Given a differentiation on R, extend it to a differentiation on %.

DifferentialExtension(R:Ring): Category == Ring with
    differentiate: (%, R -> R) -> %
       ++ differentiate(x, deriv) differentiates x extending
       ++ the derivation deriv on R.
    differentiate: (%, R -> R, NonNegativeInteger) -> %
       ++ differentiate(x, deriv, n) differentiate x n times
       ++ using a derivation which extends deriv on R.
    D: (%, R -> R) -> %
       ++ D(x, deriv) differentiates x extending
       ++ the derivation deriv on R.
    D: (%, R -> R, NonNegativeInteger) -> %
       ++ D(x, deriv, n) differentiate x n times
       ++ using a derivation which extends deriv on R.
    if R has DifferentialRing then DifferentialRing
    if R has PartialDifferentialRing(Symbol) then
             PartialDifferentialRing(Symbol)
  add
    differentiate(x:%, derivation: R -> R, n:NonNegativeInteger):% ==
      for i in 1..n repeat x := differentiate(x, derivation)
      x
    D(x:%, derivation: R -> R) == differentiate(x, derivation)
    D(x:%, derivation: R -> R, n:NonNegativeInteger) ==
            differentiate(x, derivation, n)

    if R has DifferentialRing then
      differentiate x == differentiate(x, differentiate$R)

    if R has PartialDifferentialRing Symbol then
      differentiate(x:%, v:Symbol):% ==
        differentiate(x, differentiate(#1, v)$R)

@
<<DIFEXT.dotabb>>=
"DIFEXT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIFEXT"];
"DIFEXT" -> "RING"
"DIFEXT" -> "DIFRING"
"DIFEXT" -> "PDRING"

@
<<DIFEXT.dotfull>>=
"DifferentialExtension(a:Ring)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIFEXT"];
"DifferentialExtension(a:Ring)" -> "Ring()"
"DifferentialExtension(a:Ring)" -> "DifferentialRing()"
"DifferentialExtension(a:Ring)" -> "PartialDifferentialRing(Symbol)"

@
<<DIFEXT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DifferentialExtension(a:Ring)" [color=lightblue];
"DifferentialExtension(a:Ring)" -> "Ring()"
"DifferentialExtension(a:Ring)" -> "DifferentialRing()"
"DifferentialExtension(a:Ring)" -> "PartialDifferentialRing(Symbol)"

"PartialDifferentialRing(Symbol)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=PDRING"];
"PartialDifferentialRing(Symbol)" ->
    "PartialDifferentialRing(a:SetCategory)"

"PartialDifferentialRing(a:SetCategory)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PDRING"];
"PartialDifferentialRing(a:SetCategory)" -> "Ring()"

"DifferentialRing()" [color=lightblue];
"DifferentialRing()" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SGROUP..."

"Monoid()" [color=lightblue];
"Monoid()" -> "SGROUP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LMODULE..."

"SGROUP..." [color=lightblue];
"LMODULE..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FullyLinearlyExplicitRingOver}{FLINEXP}
\pagepic{ps/v102fullylinearlyexplicitringover.ps}{FLINEXP}{1.00}

{\bf See:}\\
\pagefrom{LinearlyExplicitRingOver}{LINEXP}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FLINEXP}{1} &
\cross{FLINEXP}{0} &
\cross{FLINEXP}{characteristic} &
\cross{FLINEXP}{coerce} &
\cross{FLINEXP}{hash} \\
\cross{FLINEXP}{latex} &
\cross{FLINEXP}{one?} &
\cross{FLINEXP}{recip} &
\cross{FLINEXP}{reducedSystem} &
\cross{FLINEXP}{sample} \\
\cross{FLINEXP}{subtractIfCan} &
\cross{FLINEXP}{zero?} &
\cross{FLINEXP}{?*?} &
\cross{FLINEXP}{?**?} &
\cross{FLINEXP}{?+?} \\
\cross{FLINEXP}{?-?} &
\cross{FLINEXP}{-?} &
\cross{FLINEXP}{?=?} &
\cross{FLINEXP}{?\^{}?} &
\cross{FLINEXP}{?\~{}=?} \\
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 reducedSystem : Matrix % -> 
     Matrix Integer if R has LINEXP INT
 reducedSystem : (Matrix %,Vector %) -> 
     Record(mat: Matrix Integer,vec: Vector Integer) 
          if R has LINEXP INT
\end{verbatim}

These exports come from LinearlyExplicitRingOver(a:Ring):
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 reducedSystem : (Matrix %,Vector %) -> 
     Record(mat: Matrix R,vec: Vector R)
 reducedSystem : Matrix % -> Matrix R
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category FLINEXP FullyLinearlyExplicitRingOver>>=
)abbrev category FLINEXP FullyLinearlyExplicitRingOver
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ S is \spadtype{FullyLinearlyExplicitRingOver R} means that S is a
++ \spadtype{LinearlyExplicitRingOver R} and, in addition, if R is a
++ \spadtype{LinearlyExplicitRingOver Integer}, then so is S
FullyLinearlyExplicitRingOver(R:Ring):Category ==
  LinearlyExplicitRingOver R with
    if (R has LinearlyExplicitRingOver Integer) then
            LinearlyExplicitRingOver Integer
 add
  if not(R is Integer) then
    if (R has LinearlyExplicitRingOver Integer) then
      reducedSystem(m:Matrix %):Matrix(Integer) ==
        reducedSystem(reducedSystem(m)@Matrix(R))

      reducedSystem(m:Matrix %, v:Vector %):
        Record(mat:Matrix(Integer), vec:Vector(Integer)) ==
          rec := reducedSystem(m, v)@Record(mat:Matrix R, vec:Vector R)
          reducedSystem(rec.mat, rec.vec)

@
<<FLINEXP.dotabb>>=
"FLINEXP"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FLINEXP"];
"FLINEXP" -> "LINEXP"

@
<<FLINEXP.dotfull>>=
"FullyLinearlyExplicitRingOver(a:Ring)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FLINEXP"];
"FullyLinearlyExplicitRingOver(a:Ring)" ->
     "LinearlyExplicitRingOver(a:Ring)"

"FullyLinearlyExplicitRingOver(a:CommutativeRing)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=FLINEXP"];
"FullyLinearlyExplicitRingOver(a:CommutativeRing)" ->
    "FullyLinearlyExplicitRingOver(a:Ring)"

@
<<FLINEXP.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FullyLinearlyExplicitRingOver(a:Ring)" [color=lightblue];
"FullyLinearlyExplicitRingOver(a:Ring)" ->
     "LinearlyExplicitRingOver(a:Ring)"

"LinearlyExplicitRingOver(a:Ring)" [color=lightblue];
"LinearlyExplicitRingOver(a:Ring)" -> "Ring()"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "AbelianGroup()"
"Rng()" -> "SemiGroup()"

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "AbelianGroup()"

"AbelianGroup()" [color=lightblue];
"AbelianGroup()" -> "CABMON..."
"AbelianGroup()" -> "REPDB..."

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"REPDB..." [color="#00EE00"];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"CABMON..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Module}{MODULE}
\pagepic{ps/v102module.ps}{MODULE}{1.00}

{\bf See:}\\
\pageto{Algebra}{ALGEBRA}
\pageto{NonAssociativeAlgebra}{NAALG}
\pageto{VectorSpace}{VSPACE}
\pagefrom{BiModule}{BMODULE}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{MODULE}{0} &
\cross{MODULE}{coerce} &
\cross{MODULE}{hash} &
\cross{MODULE}{latex} &
\cross{MODULE}{sample} \\
\cross{MODULE}{subtractIfCan} &
\cross{MODULE}{zero?} &
\cross{MODULE}{?~=?} &
\cross{MODULE}{?*?} &
\cross{MODULE}{?+?} \\
\cross{MODULE}{?-?} &
\cross{MODULE}{-?} &
\cross{MODULE}{?=?} &&
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 ?*? : (%,R) -> %                     
\end{verbatim}

These exports come from BiModule(a:Ring,b:Ring):
\begin{verbatim}
 0 : () -> %                          
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (R,%) -> %
 ?*? : (Integer,%) -> %               
 ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean
\end{verbatim}

<<category MODULE Module>>=
)abbrev category MODULE Module
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of modules over a commutative ring.
++
++ Axioms:
++   \spad{1*x = x}
++   \spad{(a*b)*x = a*(b*x)}
++   \spad{(a+b)*x = (a*x)+(b*x)}
++   \spad{a*(x+y) = (a*x)+(a*y)}
Module(R:CommutativeRing): Category == BiModule(R,R)
  add
    if not(R is %) then x:%*r:R == r*x

@
<<MODULE.dotabb>>=
"MODULE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MODULE"];
"MODULE" -> "BMODULE"

@
<<MODULE.dotfull>>=
"Module(a:CommutativeRing)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MODULE"];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"Module(Field)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=MODULE"];
"Module(Field)" -> "Module(a:CommutativeRing)"

@
<<MODULE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"ABELGRP..." [color=lightblue];
}

@
\chapter{Category Layer 11}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Algebra}{ALGEBRA}
\pagepic{ps/v102algebra.ps}{ALGEBRA}{0.65}

{\bf See:}\\
\pageto{DivisionRing}{DIVRING}
\pageto{FiniteRankAlgebra}{FINRALG}
\pageto{IntegralDomain}{INTDOM}
\pagefrom{Module}{MODULE}
\pagefrom{Ring}{RING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{ALGEBRA}{1} &
\cross{ALGEBRA}{0} &
\cross{ALGEBRA}{characteristic} &
\cross{ALGEBRA}{coerce} &
\cross{ALGEBRA}{hash} \\
\cross{ALGEBRA}{latex} &
\cross{ALGEBRA}{one?} &
\cross{ALGEBRA}{recip} &
\cross{ALGEBRA}{sample} &
\cross{ALGEBRA}{subtractIfCan} \\
\cross{ALGEBRA}{zero?} &
\cross{ALGEBRA}{?*?} &
\cross{ALGEBRA}{?+?} &
\cross{ALGEBRA}{?-?} &
\cross{ALGEBRA}{-?} \\
\cross{ALGEBRA}{?=?} &
\cross{ALGEBRA}{?\~{}=?} &
\cross{ALGEBRA}{?*?} &
\cross{ALGEBRA}{?**?} &
\cross{ALGEBRA}{?\^{}?} \\
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 coerce : R -> %
\end{verbatim}

These exports come from Ring():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %                
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (Integer,%) -> %
 ?*? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
\end{verbatim}

These exports come from Module(R:CommutativeRing):
\begin{verbatim}
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
\end{verbatim}

<<category ALGEBRA Algebra>>=
)abbrev category ALGEBRA Algebra
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of associative algebras (modules which are themselves rings).
++
++ Axioms:
++   \spad{(b+c)::% = (b::%) + (c::%)}
++   \spad{(b*c)::% = (b::%) * (c::%)}
++   \spad{(1::R)::% = 1::%}
++   \spad{b*x = (b::%)*x}
++   \spad{r*(a*b) = (r*a)*b = a*(r*b)}
Algebra(R:CommutativeRing): Category ==
  Join(Ring, Module R) with
      coerce: R -> %
          ++ coerce(r) maps the ring element r to a member of the algebra.
 add
  coerce(x:R):% == x * 1$%

@
<<ALGEBRA.dotabb>>=
"ALGEBRA"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ALGEBRA"];
"ALGEBRA" -> "RING"
"ALGEBRA" -> "MODULE"

@
<<ALGEBRA.dotfull>>=
"Algebra(a:CommutativeRing)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=ALGEBRA"];
"Algebra(a:CommutativeRing)" -> "Ring()"
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Algebra(a:Field)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=ALGEBRA"];
"Algebra(a:Field)" -> "Algebra(a:CommutativeRing)"

"Algebra(a:CommutativeRing)"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=ALGEBRA"];
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Algebra(Fraction(Integer))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=ALGEBRA"];
"Algebra(Fraction(Integer))" -> "Algebra(a:CommutativeRing)"

@
<<ALGEBRA.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "Ring()"
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Ring()" [color=lightblue];
"Ring()" -> "Rng()"
"Ring()" -> "Monoid()"
"Ring()" -> "LeftModule(a:Ring)"

"Rng()" [color=lightblue];
"Rng()" -> "ABELGRP..."
"Rng()" -> "SemiGroup()"

"SemiGroup()" [color=lightblue];
"SemiGroup()" -> "SETCAT..."
"SemiGroup()" -> "REPSQ..."

"Monoid()" [color=lightblue];
"Monoid()" -> "SemiGroup()"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"ABELGRP..." [color=lightblue];
"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{NonAssociativeAlgebra}{NAALG}
\pagepic{ps/v102nonassociativealgebra.ps}{NAALG}{0.75}

{\bf See:}\\
\pageto{FiniteRankNonAssociativeAlgebra}{FINAALG}
\pagefrom{Module}{MODULE}
\pagefrom{NonAssociativeRng}{NARNG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{NAALG}{0} &
\cross{NAALG}{antiCommutator} &
\cross{NAALG}{associator} &
\cross{NAALG}{coerce} &
\cross{NAALG}{commutator} \\
\cross{NAALG}{hash} &
\cross{NAALG}{latex} &
\cross{NAALG}{leftPower} &
\cross{NAALG}{plenaryPower} &
\cross{NAALG}{rightPower} \\
\cross{NAALG}{sample} &
\cross{NAALG}{subtractIfCan} &
\cross{NAALG}{zero?} &
\cross{NAALG}{?~=?} &
\cross{NAALG}{?*?} \\
\cross{NAALG}{?**?} &
\cross{NAALG}{?+?} &
\cross{NAALG}{?-?} &
\cross{NAALG}{-?} &
\cross{NAALG}{?=?} \\
\end{tabular}

These are implemented by this category:
\begin{verbatim}
 plenaryPower : (%,PositiveInteger) -> %
\end{verbatim}

These exports come from NonAssociativeRng():
\begin{verbatim}
 0 : () -> %                          
 antiCommutator : (%,%) -> %
 associator : (%,%,%) -> %            
 coerce : % -> OutputForm
 commutator : (%,%) -> %              
 hash : % -> SingleInteger
 latex : % -> String                  
 leftPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?*? : (PositiveInteger,%) -> %       
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?*? : (%,%) -> %                     
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

These exports come from Module(R:CommutativeRing):
\begin{verbatim}
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
\end{verbatim}

<<category NAALG NonAssociativeAlgebra>>=
)abbrev category NAALG NonAssociativeAlgebra
++ Author: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 11 June 1991
++ Basic Operations: +, -, *, **
++ Related Constructors: Algebra
++ Also See:
++ AMS Classifications:
++ Keywords: nonassociative algebra
++ Reference:
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++ Description:
++   NonAssociativeAlgebra is the category of non associative algebras
++   (modules which are themselves non associative rngs).
++   Axioms
++      r*(a*b) = (r*a)*b = a*(r*b)
NonAssociativeAlgebra(R:CommutativeRing): Category == _
  Join(NonAssociativeRng, Module R) with
    plenaryPower : (%,PositiveInteger) -> %
      ++ plenaryPower(a,n) is recursively defined to be
      ++ \spad{plenaryPower(a,n-1)*plenaryPower(a,n-1)} for \spad{n>1}
      ++ and \spad{a} for \spad{n=1}.
  add
    plenaryPower(a,n) ==
--      one? n => a
      ( n = 1 ) => a
      n1 : PositiveInteger := (n-1)::NonNegativeInteger::PositiveInteger
      plenaryPower(a,n1) * plenaryPower(a,n1)

@
<<NAALG.dotabb>>=
"NAALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NAALG"];
"NAALG" -> "NARNG"
"NAALG" -> "MODULE"

@
<<NAALG.dotfull>>=
"NonAssociativeAlgebra(a:CommutativeRing)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=NAALG"];
"NonAssociativeAlgebra(a:CommutativeRing)" -> "NonAssociativeRng()"
"NonAssociativeAlgebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

@
<<NAALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"NonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"NonAssociativeAlgebra(a:CommutativeRing)" -> "NonAssociativeRng()"
"NonAssociativeAlgebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "ABELGRP..."
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "REPSQ..."

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"ABELGRP..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{VectorSpace}{VSPACE}
\pagepic{ps/v102vectorspace.ps}{VSPACE}{1.00}

{\bf See:}\\
\pagefrom{Module}{MODULE}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{VSPACE}{0} &
\cross{VSPACE}{coerce} &
\cross{VSPACE}{dimension} &
\cross{VSPACE}{hash} &
\cross{VSPACE}{latex} \\
\cross{VSPACE}{sample} &
\cross{VSPACE}{subtractIfCan} &
\cross{VSPACE}{zero?} &
\cross{VSPACE}{?~=?} &
\cross{VSPACE}{?*?} \\
\cross{VSPACE}{?+?} &
\cross{VSPACE}{?-?} &
\cross{VSPACE}{-?} &
\cross{VSPACE}{?/?} &
\cross{VSPACE}{?=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 dimension : () -> CardinalNumber
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?/? : (%,S) -> %
\end{verbatim}

These exports come from Module():
\begin{verbatim}
 ?*? : (%,S) -> %                     
 0 : () -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger            
 latex : % -> String
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (S,%) -> %
 ?*? : (Integer,%) -> %               
 ?*? : (PositiveInteger,%) -> %
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean               
\end{verbatim}

<<category VSPACE VectorSpace>>=
)abbrev category VSPACE VectorSpace
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Vector Spaces (not necessarily finite dimensional) over a field.

VectorSpace(S:Field): Category ==  Module(S) with
    "/"      : (%, S) -> %
      ++ x/y divides the vector x by the scalar y.
    dimension: () -> CardinalNumber
      ++ dimension() returns the dimensionality of the vector space.
  add
    (v:% / s:S):% == inv(s) * v

@
<<VSPACE.dotabb>>=
"VSPACE"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=VSPACE"];
"VSPACE" -> "MODULE"

@
<<VSPACE.dotfull>>=
"VectorSpace(a:Field)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=VSPACE"];
"VectorSpace(a:Field)" -> "Module(Field)"

@
<<VSPACE.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"VectorSpace(a:Field)" [color=lightblue];
"VectorSpace(a:Field)" -> "Module(Field)"

"Module(Field)" [color=seagreen];
"Module(Field)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"ABELGRP..." [color=lightblue];
}

@
\chapter{Category Layer 12}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{DivisionRing}{DIVRING}
\pagepic{ps/v102divisionring.ps}{DIVRING}{0.65}

{\bf See:}\\
\pageto{Field}{FIELD}
\pagefrom{Algebra}{ALGEBRA}
\pagefrom{EntireRing}{ENTIRER}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{DIVRING}{1} &
\cross{DIVRING}{0} &
\cross{DIVRING}{characteristic} &
\cross{DIVRING}{coerce} &
\cross{DIVRING}{hash} \\
\cross{DIVRING}{inv} &
\cross{DIVRING}{latex} &
\cross{DIVRING}{one?} &
\cross{DIVRING}{recip} &
\cross{DIVRING}{sample} \\
\cross{DIVRING}{subtractIfCan} &
\cross{DIVRING}{zero?} &
\cross{DIVRING}{?\^{}?} &
\cross{DIVRING}{?\~{}=?} &
\cross{DIVRING}{?**?} \\
\cross{DIVRING}{?*?} &
\cross{DIVRING}{?+?} &
\cross{DIVRING}{?-?} &
\cross{DIVRING}{-?} &
\cross{DIVRING}{?=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 inv : % -> %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 ?^? : (%,Integer) -> %
 ?**? : (%,Integer) -> %
\end{verbatim}

These exports come from EntireRing():
\begin{verbatim}
 0 : () -> %                          
 1 : () -> %
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %                
 coerce : % -> OutputForm
 hash : % -> SingleInteger            
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %
 ?=? : (%,%) -> Boolean               
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %                     
 -? : % -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %      
\end{verbatim}

These exports come from Algebra(Fraction(Integer)):
\begin{verbatim}
 coerce : Fraction Integer -> %
 ?*? : (%,Fraction Integer) -> %      
 ?*? : (Fraction Integer,%) -> %
\end{verbatim}

<<category DIVRING DivisionRing>>=
)abbrev category DIVRING DivisionRing
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A division ring (sometimes called a skew field),
++ i.e. a not necessarily commutative ring where
++ all non-zero elements have multiplicative inverses.

DivisionRing(): Category ==
 Join(EntireRing, Algebra Fraction Integer) with
      "**": (%,Integer) -> %
          ++ x**n returns x raised to the integer power n.
      "^" : (%,Integer) -> %
          ++ x^n returns x raised to the integer power n.
      inv : % -> %
          ++ inv x returns the multiplicative inverse of x.
          ++ Error: if x is 0.
-- Q-algebra is a lie, should be conditional on characteristic 0,
-- but knownInfo cannot handle the following commented
--    if % has CharacteristicZero then Algebra Fraction Integer
    add
      n: Integer
      x: %
      _^(x:%, n:Integer):% == x ** n
      import RepeatedSquaring(%)
      x ** n: Integer ==
         zero? n => 1
         zero? x =>
            n<0 => error "division by zero"
            x
         n<0 =>
            expt(inv x,(-n) pretend PositiveInteger)
         expt(x,n pretend PositiveInteger)
--    if % has CharacteristicZero() then
      q:Fraction(Integer) * x:% == numer(q) * inv(denom(q)::%) * x

@
<<DIVRING.dotabb>>=
"DIVRING"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIVRING"];
"DIVRING" -> "ENTIRER"
"DIVRING" -> "ALGEBRA"

@
<<DIVRING.dotfull>>=
"DivisionRing()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=DIVRING"];
"DivisionRing()" -> "EntireRing()"
"DivisionRing()" -> "Algebra(Fraction(Integer))"
"DivisionRing()" -> "RepeatedSquaring(DivisionRing)"

@
<<DIVRING.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"DivisionRing()" [color=lightblue];
"DivisionRing()" -> "EntireRing()"
"DivisionRing()" -> "Algebra(Fraction(Integer))"
"DivisionRing()" -> "RepeatedSquaring(DivisionRing)"

"RepeatedSquaring(DivisionRing)" [color="#00EE00"];
"RepeatedSquaring(DivisionRing)" -> "RepeatedSquaring(a:SetCategory)"

"RepeatedSquaring(a:SetCategory)" [color="#00EE00"];
"RepeatedSquaring(a:SetCategory)" -> "Package"

"Package" [color="#00EE00"];

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(Fraction(Integer))" [color=seagreen];
"Algebra(Fraction(Integer))" -> "Algebra(a:CommutativeRing)"

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"RING..." [color=lightblue];
"BMODULE..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FiniteRankNonAssociativeAlgebra}{FINAALG}
\pagepic{ps/v102finiteranknonassociativealgebra.ps}{FINAALG}{0.75}

{\bf See:}\\
\pageto{FramedNonAssociativeAlgebra}{FRNAALG}
\pagefrom{NonAssociativeAlgebra}{NAALG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FINAALG}{0} &
\cross{FINAALG}{alternative?} \\
\cross{FINAALG}{antiAssociative?} &
\cross{FINAALG}{antiCommutative?} \\
\cross{FINAALG}{antiCommutator} &
\cross{FINAALG}{associative?} \\
\cross{FINAALG}{associator} &
\cross{FINAALG}{associatorDependence} \\
\cross{FINAALG}{coerce} &
\cross{FINAALG}{commutative?} \\
\cross{FINAALG}{commutator} &
\cross{FINAALG}{conditionsForIdempotents} \\
\cross{FINAALG}{coordinates} &
\cross{FINAALG}{flexible?} \\
\cross{FINAALG}{hash} &
\cross{FINAALG}{jacobiIdentity?} \\
\cross{FINAALG}{jordanAdmissible?} &
\cross{FINAALG}{jordanAlgebra?} \\
\cross{FINAALG}{latex} &
\cross{FINAALG}{leftAlternative?} \\
\cross{FINAALG}{leftCharacteristicPolynomial} &
\cross{FINAALG}{leftDiscriminant} \\
\cross{FINAALG}{leftMinimalPolynomial} &
\cross{FINAALG}{leftNorm} \\
\cross{FINAALG}{leftPower} &
\cross{FINAALG}{leftRecip} \\
\cross{FINAALG}{leftRegularRepresentation} &
\cross{FINAALG}{leftTrace} \\
\cross{FINAALG}{leftTraceMatrix} &
\cross{FINAALG}{leftUnit} \\
\cross{FINAALG}{leftUnits} &
\cross{FINAALG}{lieAdmissible?} \\
\cross{FINAALG}{lieAlgebra?} &
\cross{FINAALG}{noncommutativeJordanAlgebra?} \\
\cross{FINAALG}{plenaryPower} &
\cross{FINAALG}{powerAssociative?} \\
\cross{FINAALG}{rank} &
\cross{FINAALG}{recip} \\
\cross{FINAALG}{represents} &
\cross{FINAALG}{rightAlternative?} \\
\cross{FINAALG}{rightCharacteristicPolynomial} &
\cross{FINAALG}{rightDiscriminant} \\
\cross{FINAALG}{rightMinimalPolynomial} &
\cross{FINAALG}{rightNorm} \\
\cross{FINAALG}{rightPower} &
\cross{FINAALG}{rightRecip} \\
\cross{FINAALG}{rightRegularRepresentation} &
\cross{FINAALG}{rightTrace} \\
\cross{FINAALG}{rightTraceMatrix} &
\cross{FINAALG}{rightUnit} \\
\cross{FINAALG}{rightUnits} &
\cross{FINAALG}{sample} \\
\cross{FINAALG}{someBasis} &
\cross{FINAALG}{structuralConstants} \\
\cross{FINAALG}{subtractIfCan} &
\cross{FINAALG}{unit} \\
\cross{FINAALG}{zero?} &
\cross{FINAALG}{?*?} \\
\cross{FINAALG}{?**?} &
\cross{FINAALG}{?+?} \\
\cross{FINAALG}{?-?} &
\cross{FINAALG}{-?} \\
\cross{FINAALG}{?=?} &
\cross{FINAALG}{?\~{}=?} \\
\end{tabular}


{\bf Attributes Exported:}
\begin{itemize}
\item if R has IntegralDomain then {\bf \cross{ATTREG}{unitsKnown}}
is true if a monoid (a multiplicative semigroup with a 1) has 
unitsKnown means that  the operation {\tt recip} can only return 
``failed'' if its argument is not a unit.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 conditionsForIdempotents : Vector % -> List Polynomial R
 coordinates : (%,Vector %) -> Vector R
 leftUnit : () -> Union(%,"failed") if R has INTDOM
 leftUnits : () -> Union(Record(particular: %,basis: List %),"failed") if R has INTDOM
 powerAssociative? : () -> Boolean    
 rank : () -> PositiveInteger
 rightUnit : () -> Union(%,"failed") if R has INTDOM
 rightUnits : () -> Union(Record(particular: %,basis: List %),"failed") if R has INTDOM
 someBasis : () -> Vector %
 unit : () -> Union(%,"failed") if R has INTDOM
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 alternative? : () -> Boolean
 antiAssociative? : () -> Boolean     
 antiCommutative? : () -> Boolean
 associative? : () -> Boolean
 associatorDependence : () -> List Vector R if R has INTDOM
 commutative? : () -> Boolean         
 coordinates : (Vector %,Vector %) -> Matrix R
 flexible? : () -> Boolean            
 jacobiIdentity? : () -> Boolean      
 jordanAdmissible? : () -> Boolean
 jordanAlgebra? : () -> Boolean       
 leftAlternative? : () -> Boolean     
 leftCharacteristicPolynomial : % -> SparseUnivariatePolynomial R
 leftDiscriminant : Vector % -> R
 leftMinimalPolynomial : % -> SparseUnivariatePolynomial R if R has INTDOM
 leftNorm : % -> R                    
 leftRecip : % -> Union(%,"failed") if R has INTDOM
 leftRegularRepresentation : (%,Vector %) -> Matrix R
 leftTrace : % -> R
 leftTraceMatrix : Vector % -> Matrix R
 lieAdmissible? : () -> Boolean       
 lieAlgebra? : () -> Boolean
 noncommutativeJordanAlgebra? : () -> Boolean
 recip : % -> Union(%,"failed") if R has INTDOM
 represents : (Vector R,Vector %) -> %
 rightAlternative? : () -> Boolean    
 rightCharacteristicPolynomial : % -> SparseUnivariatePolynomial R
 rightDiscriminant : Vector % -> R
 rightMinimalPolynomial : % -> SparseUnivariatePolynomial R if R has INTDOM
 rightNorm : % -> R                   
 rightRecip : % -> Union(%,"failed") if R has INTDOM
 rightRegularRepresentation : (%,Vector %) -> Matrix R
 rightTrace : % -> R
 rightTraceMatrix : Vector % -> Matrix R
 structuralConstants : Vector % -> Vector Matrix R
\end{verbatim}

These exports come from NonAssociativeAlgebra(R:CommutativeRing):
\begin{verbatim}
 0 : () -> %                          
 antiCommutator : (%,%) -> %          
 associator : (%,%,%) -> %            
 coerce : % -> OutputForm
 commutator : (%,%) -> %
 hash : % -> SingleInteger
 latex : % -> String
 leftPower : (%,PositiveInteger) -> %
 plenaryPower : (%,PositiveInteger) -> %
 rightPower : (%,PositiveInteger) -> %
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?~=? : (%,%) -> Boolean
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

<<category FINAALG FiniteRankNonAssociativeAlgebra>>=
)abbrev category FINAALG FiniteRankNonAssociativeAlgebra
++ Author: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 12 June 1991
++ Basic Operations: +,-,*,**, someBasis
++ Related Constructors: FramedNonAssociativeAlgebra, FramedAlgebra,
++   FiniteRankAssociativeAlgebra
++ Also See:
++ AMS Classifications:
++ Keywords: nonassociative algebra, basis
++ References:
++   R.D. Schafer: An Introduction to Nonassociative Algebras
++   Academic Press, New York, 1966
++
++   R. Wisbauer: Bimodule Structure of Algebra
++   Lecture Notes Univ. Duesseldorf 1991
++ Description:
++   A FiniteRankNonAssociativeAlgebra is a non associative algebra over
++   a commutative ring R which is a free \spad{R}-module of finite rank.
FiniteRankNonAssociativeAlgebra(R:CommutativeRing):
 Category == NonAssociativeAlgebra R with
    someBasis : () -> Vector %
      ++ someBasis() returns some \spad{R}-module basis.
    rank : () -> PositiveInteger
      ++ rank() returns the rank of the algebra as \spad{R}-module.
    conditionsForIdempotents: Vector % -> List Polynomial R
      ++ conditionsForIdempotents([v1,...,vn]) determines a complete list
      ++ of polynomial equations for the coefficients of idempotents
      ++ with respect to the \spad{R}-module basis \spad{v1},...,\spad{vn}.
    structuralConstants: Vector % -> Vector Matrix R
      ++ structuralConstants([v1,v2,...,vm]) calculates the structural
      ++ constants \spad{[(gammaijk) for k in 1..m]} defined by
      ++ \spad{vi * vj = gammaij1 * v1 + ... + gammaijm * vm},
      ++ where \spad{[v1,...,vm]} is an \spad{R}-module basis
      ++ of a subalgebra.
    leftRegularRepresentation: (% , Vector %) -> Matrix R
      ++ leftRegularRepresentation(a,[v1,...,vn]) returns the matrix of
      ++ the linear map defined by left multiplication by \spad{a}
      ++ with respect to the \spad{R}-module basis \spad{[v1,...,vn]}.
    rightRegularRepresentation: (% , Vector %) -> Matrix R
      ++ rightRegularRepresentation(a,[v1,...,vn]) returns the matrix of
      ++ the linear map defined by right multiplication by \spad{a}
      ++ with respect to the \spad{R}-module basis \spad{[v1,...,vn]}.
    leftTrace: %  -> R
      ++ leftTrace(a) returns the trace of the left regular representation
      ++ of \spad{a}.
    rightTrace: %  -> R
      ++ rightTrace(a) returns the trace of the right regular representation
      ++ of \spad{a}.
    leftNorm: %  -> R
      ++ leftNorm(a) returns the determinant of the left regular 
      ++ representation of \spad{a}.
    rightNorm: %  -> R
      ++ rightNorm(a) returns the determinant of the right regular
      ++ representation of \spad{a}.
    coordinates: (%, Vector %) -> Vector R
      ++ coordinates(a,[v1,...,vn]) returns the coordinates of \spad{a}
      ++ with respect to the \spad{R}-module basis \spad{v1},...,\spad{vn}.
    coordinates: (Vector %, Vector %) -> Matrix R
      ++ coordinates([a1,...,am],[v1,...,vn]) returns a matrix whose
      ++ i-th row is formed by the coordinates of \spad{ai}
      ++ with respect to the \spad{R}-module basis \spad{v1},...,\spad{vn}.
    represents: (Vector R, Vector %) -> %
      ++ represents([a1,...,am],[v1,...,vm]) returns the linear
      ++ combination \spad{a1*vm + ... + an*vm}.
    leftDiscriminant: Vector % -> R
      ++ leftDiscriminant([v1,...,vn]) returns  the determinant of the
      ++ \spad{n}-by-\spad{n} matrix whose element at the \spad{i}-th row
      ++ and \spad{j}-th column is given by the left trace of the product
      ++ \spad{vi*vj}.
      ++ Note: the same as \spad{determinant(leftTraceMatrix([v1,...,vn]))}.
    rightDiscriminant: Vector % -> R
      ++ rightDiscriminant([v1,...,vn]) returns  the determinant of the
      ++ \spad{n}-by-\spad{n} matrix whose element at the \spad{i}-th row
      ++ and \spad{j}-th column is given by the right trace of the product
      ++ \spad{vi*vj}.
      ++ Note: the same as \spad{determinant(rightTraceMatrix([v1,...,vn]))}.
    leftTraceMatrix: Vector % -> Matrix R
      ++ leftTraceMatrix([v1,...,vn]) is the \spad{n}-by-\spad{n} matrix
      ++ whose element at the \spad{i}-th row and \spad{j}-th column is given
      ++ by the left trace of the product \spad{vi*vj}.
    rightTraceMatrix: Vector % -> Matrix R
      ++ rightTraceMatrix([v1,...,vn]) is the \spad{n}-by-\spad{n} matrix
      ++ whose element at the \spad{i}-th row and \spad{j}-th column is given
      ++ by the right trace of the product \spad{vi*vj}.
    leftCharacteristicPolynomial: % -> SparseUnivariatePolynomial R
      ++ leftCharacteristicPolynomial(a) returns the characteristic
      ++ polynomial of the left regular representation of \spad{a}
      ++ with respect to any basis.
    rightCharacteristicPolynomial: % -> SparseUnivariatePolynomial R
      ++ rightCharacteristicPolynomial(a) returns the characteristic
      ++ polynomial of the right regular representation of \spad{a}
      ++ with respect to any basis.

    --we not necessarily have a unit
    --if R has CharacteristicZero then CharacteristicZero
    --if R has CharacteristicNonZero then CharacteristicNonZero

    commutative?:()-> Boolean
      ++ commutative?() tests if multiplication in the algebra
      ++ is commutative.
    antiCommutative?:()-> Boolean
      ++ antiCommutative?() tests if \spad{a*a = 0}
      ++ for all \spad{a} in the algebra.
      ++ Note: this implies \spad{a*b + b*a = 0} for all 
      ++ \spad{a} and \spad{b}.
    associative?:()-> Boolean
      ++ associative?() tests if multiplication in algebra
      ++ is associative.
    antiAssociative?:()-> Boolean
      ++ antiAssociative?() tests if multiplication in algebra
      ++ is anti-associative, i.e. \spad{(a*b)*c + a*(b*c) = 0}
      ++ for all \spad{a},b,c in the algebra.
    leftAlternative?: ()-> Boolean
      ++ leftAlternative?() tests if \spad{2*associator(a,a,b) = 0}
      ++ for all \spad{a}, b in the algebra.
      ++ Note: we only can test this; in general we don't know
      ++ whether \spad{2*a=0} implies \spad{a=0}.
    rightAlternative?: ()-> Boolean
      ++ rightAlternative?() tests if \spad{2*associator(a,b,b) = 0}
      ++ for all \spad{a}, b in the algebra.
      ++ Note: we only can test this; in general we don't know
      ++ whether \spad{2*a=0} implies \spad{a=0}.
    flexible?: ()->  Boolean
      ++ flexible?() tests if \spad{2*associator(a,b,a) = 0}
      ++ for all \spad{a}, b in the algebra.
      ++ Note: we only can test this; in general we don't know
      ++ whether \spad{2*a=0} implies \spad{a=0}.
    alternative?: ()-> Boolean
      ++ alternative?() tests if
      ++ \spad{2*associator(a,a,b) = 0 = 2*associator(a,b,b)}
      ++ for all \spad{a}, b in the algebra.
      ++ Note: we only can test this; in general we don't know
      ++ whether \spad{2*a=0} implies \spad{a=0}.
    powerAssociative?:()-> Boolean
      ++ powerAssociative?() tests if all subalgebras
      ++ generated by a single element are associative.
    jacobiIdentity?:() -> Boolean
      ++ jacobiIdentity?() tests if \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0}
      ++ for all \spad{a},b,c in the algebra. For example, this holds
      ++ for crossed products of 3-dimensional vectors.
    lieAdmissible?: () -> Boolean
      ++ lieAdmissible?() tests if the algebra defined by the commutators
      ++ is a Lie algebra, i.e. satisfies the Jacobi identity.
      ++ The property of anticommutativity follows from definition.
    jordanAdmissible?: () -> Boolean
      ++ jordanAdmissible?() tests if 2 is invertible in the
      ++ coefficient domain and the multiplication defined by
      ++ \spad{(1/2)(a*b+b*a)} determines a
      ++ Jordan algebra, i.e. satisfies the Jordan identity.
      ++ The property of \spadatt{commutative("*")}
      ++ follows from by definition.
    noncommutativeJordanAlgebra?: () -> Boolean
      ++ noncommutativeJordanAlgebra?() tests if the algebra
      ++ is flexible and Jordan admissible.
    jordanAlgebra?:() -> Boolean
      ++ jordanAlgebra?() tests if the algebra is commutative,
      ++ characteristic is not 2, and \spad{(a*b)*a**2 - a*(b*a**2) = 0}
      ++ for all \spad{a},b,c in the algebra (Jordan identity).
      ++ Example:
      ++ for every associative algebra \spad{(A,+,@)} we can construct a
      ++ Jordan algebra \spad{(A,+,*)}, where \spad{a*b := (a@b+b@a)/2}.
    lieAlgebra?:() -> Boolean
      ++ lieAlgebra?() tests if the algebra is anticommutative
      ++ and \spad{(a*b)*c + (b*c)*a + (c*a)*b = 0}
      ++ for all \spad{a},b,c in the algebra (Jacobi identity).
      ++ Example:
      ++ for every associative algebra \spad{(A,+,@)} we can construct a
      ++ Lie algebra \spad{(A,+,*)}, where \spad{a*b := a@b-b@a}.

    if R has IntegralDomain then
      -- we not neccessarily have a unit, hence we don't inherit
      -- the next 3 functions anc hence copy them from MonadWithUnit:
      recip: % -> Union(%,"failed")
        ++ recip(a) returns an element, which is both a left and a right
        ++ inverse of \spad{a},
        ++ or \spad{"failed"} if there is no unit element, if such an
        ++ element doesn't exist or cannot be determined (see unitsKnown).
      leftRecip: % -> Union(%,"failed")
        ++ leftRecip(a) returns an element, which is a left inverse of 
        ++ \spad{a}, or \spad{"failed"} if there is no unit element, if such
        ++ an element doesn't exist or cannot be determined (see unitsKnown).
      rightRecip: % -> Union(%,"failed")
        ++ rightRecip(a) returns an element, which is a right inverse of
        ++ \spad{a},
        ++ or \spad{"failed"} if there is no unit element, if such an
        ++ element doesn't exist or cannot be determined (see unitsKnown).
      associatorDependence:() -> List Vector R
        ++ associatorDependence() looks for the associator identities, i.e.
        ++ finds a basis of the solutions of the linear combinations of the
        ++ six permutations of \spad{associator(a,b,c)} which yield 0,
        ++ for all \spad{a},b,c in the algebra.
        ++ The order of the permutations is \spad{123 231 312 132 321 213}.
      leftMinimalPolynomial : % -> SparseUnivariatePolynomial R
        ++ leftMinimalPolynomial(a) returns the polynomial determined by the
        ++ smallest non-trivial linear combination of left powers of 
        ++ \spad{a}. Note: the polynomial never has a constant term as in 
        ++ general the algebra has no unit.
      rightMinimalPolynomial : % -> SparseUnivariatePolynomial R
        ++ rightMinimalPolynomial(a) returns the polynomial determined by the
        ++ smallest non-trivial linear
        ++ combination of right powers of \spad{a}.
        ++ Note: the polynomial never has a constant term as in general
        ++ the algebra has no unit.
      leftUnits:() -> Union(Record(particular: %, basis: List %), "failed")
        ++ leftUnits() returns the affine space of all left units of the
        ++ algebra, or \spad{"failed"} if there is none.
      rightUnits:() -> Union(Record(particular: %, basis: List %), "failed")
        ++ rightUnits() returns the affine space of all right units of the
        ++ algebra, or \spad{"failed"} if there is none.
      leftUnit:() -> Union(%, "failed")
        ++ leftUnit() returns a left unit of the algebra
        ++ (not necessarily unique), or \spad{"failed"} if there is none.
      rightUnit:() -> Union(%, "failed")
        ++ rightUnit() returns a right unit of the algebra
        ++ (not necessarily unique), or \spad{"failed"} if there is none.
      unit:() -> Union(%, "failed")
        ++ unit() returns a unit of the algebra (necessarily unique),
        ++ or \spad{"failed"} if there is none.
      -- we not necessarily have a unit, hence we can't say anything
      -- about characteristic
      -- if R has CharacteristicZero then CharacteristicZero
      -- if R has CharacteristicNonZero then CharacteristicNonZero
      unitsKnown
        ++ unitsKnown means that \spadfun{recip} truly yields reciprocal
        ++ or \spad{"failed"} if not a unit,
        ++ similarly for \spadfun{leftRecip} and
        ++ \spadfun{rightRecip}. The reason is that we use left, respectively
        ++ right, minimal polynomials to decide this question.
  add
    --n := rank()
    --b := someBasis()
    --gamma : Vector Matrix R := structuralConstants b
    -- here is a problem: there seems to be a problem having local
    -- variables in the capsule of a category, furthermore
    -- see the commented code of conditionsForIdempotents, where
    -- we call structuralConstants, which also doesn't work
    -- at runtime, i.e. is not properly inherited, hence for
    -- the moment we put the code for
    -- conditionsForIdempotents, structuralConstants, unit, leftUnit,
    -- rightUnit into the domain constructor ALGSC
    V  ==> Vector
    M  ==> Matrix
    REC  ==> Record(particular: Union(V R,"failed"),basis: List V R)
    LSMP ==> LinearSystemMatrixPackage(R,V R,V R, M R)


    SUP ==>  SparseUnivariatePolynomial
    NNI ==>  NonNegativeInteger
    -- next 2 functions: use a general characteristicPolynomial
    leftCharacteristicPolynomial a ==
       n := rank()$%
       ma : Matrix R := leftRegularRepresentation(a,someBasis()$%)
       mb : Matrix SUP R := zero(n,n)
       for i in 1..n repeat
         for j in 1..n repeat
           mb(i,j):=
             i=j => monomial(ma(i,j),0)$SUP(R) - monomial(1,1)$SUP(R)
             monomial(ma(i,j),1)$SUP(R)
       determinant mb

    rightCharacteristicPolynomial a ==
       n := rank()$%
       ma : Matrix R := rightRegularRepresentation(a,someBasis()$%)
       mb : Matrix SUP R := zero(n,n)
       for i in 1..n repeat
         for j in 1..n repeat
           mb(i,j):=
             i=j => monomial(ma(i,j),0)$SUP(R) - monomial(1,1)$SUP(R)
             monomial(ma(i,j),1)$SUP(R)
       determinant mb

    leftTrace a ==
      t : R := 0
      ma : Matrix R := leftRegularRepresentation(a,someBasis()$%)
      for i in 1..rank()$% repeat
        t := t + elt(ma,i,i)
      t

    rightTrace a ==
      t : R := 0
      ma : Matrix R := rightRegularRepresentation(a,someBasis()$%)
      for i in 1..rank()$% repeat
        t := t + elt(ma,i,i)
      t

    leftNorm a == determinant leftRegularRepresentation(a,someBasis()$%)

    rightNorm a == determinant rightRegularRepresentation(a,someBasis()$%)

    antiAssociative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
        for j in 1..n repeat
          for k in 1..n repeat
            not zero? ( (b.i*b.j)*b.k + b.i*(b.j*b.k) )  =>
              messagePrint("algebra is not anti-associative")$OutputForm
              return false
      messagePrint("algebra is anti-associative")$OutputForm
      true

    jordanAdmissible?() ==
      b := someBasis()
      n := rank()
      recip(2 * 1$R) case "failed" =>
        messagePrint("this algebra is not Jordan admissible, " _
         "as 2 is not invertible in the ground ring")$OutputForm
        false
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for l in 1..n repeat
           not zero? ( _
             antiCommutator(antiCommutator(b.i,b.j),_
                            antiCommutator(b.l,b.k)) + _
             antiCommutator(antiCommutator(b.l,b.j),_
                            antiCommutator(b.k,b.i)) + _
             antiCommutator(antiCommutator(b.k,b.j),_
                            antiCommutator(b.i,b.l))   _
                      ) =>
               messagePrint(_
                         "this algebra is not Jordan admissible")$OutputForm
               return false
      messagePrint("this algebra is Jordan admissible")$OutputForm
      true

    lieAdmissible?() ==
      n := rank()
      b := someBasis()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
          not zero? (commutator(commutator(b.i,b.j),b.k) _
                  + commutator(commutator(b.j,b.k),b.i) _
                  + commutator(commutator(b.k,b.i),b.j))   =>
            messagePrint("this algebra is not Lie admissible")$OutputForm
            return false
      messagePrint("this algebra is Lie admissible")$OutputForm
      true

    -- conditionsForIdempotents b  ==
    --   n := rank()
    --   gamma : Vector Matrix R := structuralConstants b
    --   listOfNumbers : List String :=  [STRINGIMAGE(q)$Lisp for q in 1..n]
    --   symbolsForCoef : Vector Symbol :=
    --     [concat("%", concat("x", i))::Symbol  for i in listOfNumbers]
    --   conditions : List Polynomial R := []
    --  for k in 1..n repeat
    --    xk := symbolsForCoef.k
    --    p : Polynomial R :=  monomial( - 1$Polynomial(R), [xk], [1] )
    --    for i in 1..n repeat
    --      for j in 1..n repeat
    --        xi := symbolsForCoef.i
    --        xj := symbolsForCoef.j
    --        p := p + monomial(_
    --          elt((gamma.k),i,j) :: Polynomial(R), [xi,xj], [1,1])
    --    conditions := cons(p,conditions)
    --  conditions

    structuralConstants b ==
      --n := rank()
      -- be careful with the possibility that b is not a basis
      m : NonNegativeInteger := (maxIndex b) :: NonNegativeInteger
      sC : Vector Matrix R := [new(m,m,0$R) for k in 1..m]
      for i in 1..m repeat
        for j in 1..m repeat
          covec : Vector R := coordinates(b.i * b.j, b)
          for k in 1..m repeat
             setelt( sC.k, i, j, covec.k )
      sC

    if R has IntegralDomain then

      leftRecip x ==
        zero? x => "failed"
        lu := leftUnit()
        lu case "failed" => "failed"
        b := someBasis()
        xx : % := (lu :: %)
        k  : PositiveInteger := 1
        cond : Matrix R := coordinates(xx,b) :: Matrix(R)
        listOfPowers : List % := [xx]
        while rank(cond) = k repeat
          k := k+1
          xx := xx*x
          listOfPowers := cons(xx,listOfPowers)
          cond := horizConcat(cond, coordinates(xx,b) :: Matrix(R) )
        vectorOfCoef : Vector R := (nullSpace(cond)$Matrix(R)).first
        invC := recip vectorOfCoef.1
        invC case "failed" => "failed"
        invCR : R :=  - (invC :: R)
        reduce(_+,[(invCR*vectorOfCoef.i)*power for i in _
         2..maxIndex vectorOfCoef for power in reverse listOfPowers])

      rightRecip x ==
        zero? x => "failed"
        ru := rightUnit()
        ru case "failed" => "failed"
        b := someBasis()
        xx : % := (ru :: %)
        k  : PositiveInteger := 1
        cond : Matrix R := coordinates(xx,b) :: Matrix(R)
        listOfPowers : List % := [xx]
        while rank(cond) = k repeat
          k := k+1
          xx := x*xx
          listOfPowers := cons(xx,listOfPowers)
          cond := horizConcat(cond, coordinates(xx,b) :: Matrix(R) )
        vectorOfCoef : Vector R := (nullSpace(cond)$Matrix(R)).first
        invC := recip vectorOfCoef.1
        invC case "failed" => "failed"
        invCR : R :=  - (invC :: R)
        reduce(_+,[(invCR*vectorOfCoef.i)*power for i in _
         2..maxIndex vectorOfCoef for power in reverse listOfPowers])

      recip x ==
        lrx := leftRecip x
        lrx case "failed" => "failed"
        rrx := rightRecip x
        rrx case "failed" => "failed"
        (lrx :: %) ^= (rrx :: %)  => "failed"
        lrx :: %

      leftMinimalPolynomial x ==
        zero? x =>  monomial(1$R,1)$(SparseUnivariatePolynomial R)
        b := someBasis()
        xx : % := x
        k  : PositiveInteger := 1
        cond : Matrix R := coordinates(xx,b) :: Matrix(R)
        while rank(cond) = k repeat
          k := k+1
          xx := x*xx
          cond := horizConcat(cond, coordinates(xx,b) :: Matrix(R) )
        vectorOfCoef : Vector R := (nullSpace(cond)$Matrix(R)).first
        res : SparseUnivariatePolynomial R := 0
        for i in 1..k repeat
          res:=res+monomial(vectorOfCoef.i,i)$(SparseUnivariatePolynomial R)
        res

      rightMinimalPolynomial x ==
        zero? x =>  monomial(1$R,1)$(SparseUnivariatePolynomial R)
        b := someBasis()
        xx : % := x
        k  : PositiveInteger := 1
        cond : Matrix R := coordinates(xx,b) :: Matrix(R)
        while rank(cond) = k repeat
          k := k+1
          xx := xx*x
          cond := horizConcat(cond, coordinates(xx,b) :: Matrix(R) )
        vectorOfCoef : Vector R := (nullSpace(cond)$Matrix(R)).first
        res : SparseUnivariatePolynomial R := 0
        for i in 1..k repeat
          res:=res+monomial(vectorOfCoef.i,i)$(SparseUnivariatePolynomial R)
        res

      associatorDependence() ==
        n := rank()
        b := someBasis()
        cond : Matrix(R) := new(n**4,6,0$R)$Matrix(R)
        z : Integer := 0
        for i in 1..n repeat
         for j in 1..n repeat
          for k in 1..n repeat
           a123 : Vector R := coordinates(associator(b.i,b.j,b.k),b)
           a231 : Vector R := coordinates(associator(b.j,b.k,b.i),b)
           a312 : Vector R := coordinates(associator(b.k,b.i,b.j),b)
           a132 : Vector R := coordinates(associator(b.i,b.k,b.j),b)
           a321 : Vector R := coordinates(associator(b.k,b.j,b.i),b)
           a213 : Vector R := coordinates(associator(b.j,b.i,b.k),b)
           for r in 1..n repeat
            z:= z+1
            setelt(cond,z,1,elt(a123,r))
            setelt(cond,z,2,elt(a231,r))
            setelt(cond,z,3,elt(a312,r))
            setelt(cond,z,4,elt(a132,r))
            setelt(cond,z,5,elt(a321,r))
            setelt(cond,z,6,elt(a213,r))
        nullSpace(cond)

    jacobiIdentity?()  ==
      n := rank()
      b := someBasis()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
          not zero? ((b.i*b.j)*b.k + (b.j*b.k)*b.i + (b.k*b.i)*b.j) =>
            messagePrint("Jacobi identity does not hold")$OutputForm
            return false
      messagePrint("Jacobi identity holds")$OutputForm
      true

    lieAlgebra?()  ==
      not antiCommutative?() =>
        messagePrint("this is not a Lie algebra")$OutputForm
        false
      not jacobiIdentity?() =>
        messagePrint("this is not a Lie algebra")$OutputForm
        false
      messagePrint("this is a Lie algebra")$OutputForm
      true

    jordanAlgebra?()  ==
      b := someBasis()
      n := rank()
      recip(2 * 1$R) case "failed" =>
        messagePrint("this is not a Jordan algebra, as 2 is not " _
         "invertible in the ground ring")$OutputForm
        false
      not commutative?() =>
        messagePrint("this is not a Jordan algebra")$OutputForm
        false
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         for l in 1..n repeat
           not zero? (associator(b.i,b.j,b.l*b.k)+_
               associator(b.l,b.j,b.k*b.i)+associator(b.k,b.j,b.i*b.l)) =>
             messagePrint("not a Jordan algebra")$OutputForm
             return false
      messagePrint("this is a Jordan algebra")$OutputForm
      true

    noncommutativeJordanAlgebra?() ==
      b := someBasis()
      n := rank()
      recip(2 * 1$R) case "failed" =>                             
       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
       messagePrint(" as 2 is not invertible in the ground ring")$OutputForm
       false
      not flexible?()$% =>
       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
       messagePrint(" as it is not flexible")$OutputForm
       false
      not jordanAdmissible?()$% =>
       messagePrint("this is not a noncommutative Jordan algebra,")$OutputForm
       messagePrint(" as it is not Jordan admissible")$OutputForm
       false
      messagePrint("this is a noncommutative Jordan algebra")$OutputForm
      true

    antiCommutative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
        for j in i..n repeat
          not zero? (i=j => b.i*b.i; b.i*b.j + b.j*b.i) =>
            messagePrint("algebra is not anti-commutative")$OutputForm
            return false
      messagePrint("algebra is anti-commutative")$OutputForm
      true

    commutative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in i+1..n repeat
         not zero? commutator(b.i,b.j) =>
           messagePrint("algebra is not commutative")$OutputForm
           return false
      messagePrint("algebra is commutative")$OutputForm
      true

    associative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         not zero? associator(b.i,b.j,b.k) =>
           messagePrint("algebra is not associative")$OutputForm
           return false
      messagePrint("algebra is associative")$OutputForm
      true

    leftAlternative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         not zero? (associator(b.i,b.j,b.k) + associator(b.j,b.i,b.k)) =>
           messagePrint("algebra is not left alternative")$OutputForm
           return false
      messagePrint("algebra satisfies 2*associator(a,a,b) = 0")$OutputForm
      true

    rightAlternative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         not zero? (associator(b.i,b.j,b.k) + associator(b.i,b.k,b.j)) =>
           messagePrint("algebra is not right alternative")$OutputForm
           return false
      messagePrint("algebra satisfies 2*associator(a,b,b) = 0")$OutputForm
      true

    flexible?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         not zero? (associator(b.i,b.j,b.k) + associator(b.k,b.j,b.i)) =>
           messagePrint("algebra is not flexible")$OutputForm
           return false
      messagePrint("algebra satisfies 2*associator(a,b,a) = 0")$OutputForm
      true

    alternative?() ==
      b := someBasis()
      n := rank()
      for i in 1..n repeat
       for j in 1..n repeat
        for k in 1..n repeat
         not zero? (associator(b.i,b.j,b.k) + associator(b.j,b.i,b.k)) =>
           messagePrint("algebra is not alternative")$OutputForm
           return false
         not zero? (associator(b.i,b.j,b.k) + associator(b.i,b.k,b.j)) =>
           messagePrint("algebra is not alternative")$OutputForm
           return false
      messagePrint("algebra satisfies 2*associator(a,b,b) = 0 " _
                   "=  2*associator(a,a,b) = 0")$OutputForm
      true

    leftDiscriminant v == determinant leftTraceMatrix v
    rightDiscriminant v == determinant rightTraceMatrix v

    coordinates(v:Vector %, b:Vector %) ==
      m := new(#v, #b, 0)$Matrix(R)
      for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
        setRow_!(m, j, coordinates(qelt(v, i), b))
      m

    represents(v, b) ==
      m := minIndex v - 1
      reduce(_+,[v(i+m) * b(i+m) for i in 1..maxIndex b])

    leftTraceMatrix v ==
      matrix [[leftTrace(v.i*v.j) for j in minIndex v..maxIndex v]$List(R)
               for i in minIndex v .. maxIndex v]$List(List R)

    rightTraceMatrix v ==
      matrix [[rightTrace(v.i*v.j) for j in minIndex v..maxIndex v]$List(R)
               for i in minIndex v .. maxIndex v]$List(List R)

    leftRegularRepresentation(x, b) ==
      m := minIndex b - 1
      matrix
       [parts coordinates(x*b(i+m),b) for i in 1..rank()]$List(List R)

    rightRegularRepresentation(x, b) ==
      m := minIndex b - 1
      matrix
       [parts coordinates(b(i+m)*x,b) for i in 1..rank()]$List(List R)

@
<<FINAALG.dotabb>>=
"FINAALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINAALG"];
"FINAALG" -> "NAALG"

@
<<FINAALG.dotfull>>=
"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINAALG"];
"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)" ->
    "NonAssociativeAlgebra(a:CommutativeRing)"

@
<<FINAALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)" ->
    "NonAssociativeAlgebra(a:CommutativeRing)"

"NonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"NonAssociativeAlgebra(a:CommutativeRing)" -> "NonAssociativeRng()"
"NonAssociativeAlgebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "ABELGRP..."
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "REPSQ..."

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"ABELGRP..." [color=lightblue];
}

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{IntegralDomain}{INTDOM}
\pagepic{ps/v102integraldomain.ps}{INTDOM}{0.65}

{\bf See:}\\
\pageto{GcdDomain}{GCDDOM}
\pageto{OrderedIntegralDomain}{OINTDOM}
\pagefrom{Algebra}{ALGEBRA}
\pagefrom{CommutativeRing}{COMRING}
\pagefrom{EntireRing}{ENTIRER}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{INTDOM}{0} &
\cross{INTDOM}{1} &
\cross{INTDOM}{associates?} &
\cross{INTDOM}{characteristic} &
\cross{INTDOM}{coerce} \\
\cross{INTDOM}{exquo} &
\cross{INTDOM}{hash} &
\cross{INTDOM}{latex} &
\cross{INTDOM}{one?} &
\cross{INTDOM}{recip} \\
\cross{INTDOM}{sample} &
\cross{INTDOM}{subtractIfCan} &
\cross{INTDOM}{unit?} &
\cross{INTDOM}{unitCanonical} &
\cross{INTDOM}{unitNormal} \\
\cross{INTDOM}{zero?} &
\cross{INTDOM}{?\~{}=?} &
\cross{INTDOM}{?*?} &
\cross{INTDOM}{?**?} &
\cross{INTDOM}{?\^{}?} \\
\cross{INTDOM}{?+?} &
\cross{INTDOM}{?-?} &
\cross{INTDOM}{-?} &
\cross{INTDOM}{?=?} &
\end{tabular}

{\bf Attributes Used:}
\begin{itemize}
\item {\bf \cross{INTDOM}{canonicalUnitNormal}}
is true if we can choose a canonical representative for each class 
of associate elements, that is {\tt associates?(a,b)} returns true 
if and only if {\tt unitCanonical(a) = unitCanonical(b)}.
\end{itemize}

These are directly exported but not implemented:
\begin{verbatim}
 exquo : (%,%) -> Union(%,"failed")
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 associates? : (%,%) -> Boolean
 unit? : % -> Boolean                 
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
\end{verbatim}

These exports come from CommutativeRing():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

TPDHERE: Should we construct this coercion?

These exports come from Algebra(a:IntegralDomain):
\begin{verbatim}
 coerce : % -> %                      
\end{verbatim}

TPDHERE: Note that none of the exports of EntireRing are needed.
Perhaps this can be eliminated.

<<category INTDOM IntegralDomain>>=
)abbrev category INTDOM IntegralDomain
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References: Davenport & Trager I
++ Description:
++ The category of commutative integral domains, i.e. commutative
++ rings with no zero divisors.
++
++ Conditional attributes:
++   canonicalUnitNormal\tab{20}the canonical field is the same for 
++   all associates canonicalsClosed\tab{20}the product of two 
++   canonicals is itself canonical

IntegralDomain(): Category ==
  Join(CommutativeRing, Algebra(%), EntireRing) with
    "exquo": (%,%) -> Union(%,"failed")
        ++ exquo(a,b) either returns an element c such that
        ++ \spad{c*b=a} or "failed" if no such element can be found.
    unitNormal: % -> Record(unit:%,canonical:%,associate:%)
        ++ unitNormal(x) tries to choose a canonical element
        ++ from the associate class of x.
        ++ The attribute canonicalUnitNormal, if asserted, means that
        ++ the "canonical" element is the same across all associates of x
        ++ if \spad{unitNormal(x) = [u,c,a]} then
        ++ \spad{u*c = x}, \spad{a*u = 1}.
    unitCanonical: % -> %
        ++ \spad{unitCanonical(x)} returns \spad{unitNormal(x).canonical}.
    associates?: (%,%) -> Boolean
        ++ associates?(x,y) tests whether x and y are associates, i.e.
        ++ differ by a unit factor.
    unit?: % -> Boolean
        ++ unit?(x) tests whether x is a unit, i.e. is invertible.
 add
      x,y: %

      UCA ==> Record(unit:%,canonical:%,associate:%)
      if not (% has Field) then
        unitNormal(x) == [1$%,x,1$%]$UCA -- the non-canonical definition
      unitCanonical(x) == unitNormal(x).canonical -- always true
      recip(x) == if zero? x then "failed" else _exquo(1$%,x)
      unit?(x) == (recip x case "failed" => false; true)
      if % has canonicalUnitNormal then
         associates?(x,y) ==
           (unitNormal x).canonical = (unitNormal y).canonical
       else
         associates?(x,y) ==
           zero? x => zero? y
           zero? y => false
           x exquo y case "failed" => false
           y exquo x case "failed" => false
           true

@
<<INTDOM.dotabb>>=
"INTDOM"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=INTDOM"];
"INTDOM" -> "COMRING"
"INTDOM" -> "ALGEBRA"
"INTDOM" -> "ENTIRER"

@
<<INTDOM.dotfull>>=
"IntegralDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=INTDOM"];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

@
<<INTDOM.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
\chapter{Category Layer 13}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FramedNonAssociativeAlgebra}{FRNAALG}
\pagepic{ps/v102framednonassociativealgebra.ps}{FRNAALG}{0.65}

{\bf See:}\\
\pagefrom{FiniteRankNonAssociativeAlgebra}{FINAALG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FRNAALG}{0} &
\cross{FRNAALG}{alternative?} \\
\cross{FRNAALG}{antiAssociative?} &
\cross{FRNAALG}{antiCommutative?} \\
\cross{FRNAALG}{antiCommutator} &
\cross{FRNAALG}{apply} \\
\cross{FRNAALG}{associative?} &
\cross{FRNAALG}{associator} \\
\cross{FRNAALG}{associatorDependence} &
\cross{FRNAALG}{basis} \\
\cross{FRNAALG}{coerce} &
\cross{FRNAALG}{commutative?} \\
\cross{FRNAALG}{commutator} &
\cross{FRNAALG}{conditionsForIdempotents} \\
\cross{FRNAALG}{convert} &
\cross{FRNAALG}{coordinates} \\
\cross{FRNAALG}{flexible?} &
\cross{FRNAALG}{hash} \\
\cross{FRNAALG}{jacobiIdentity?} &
\cross{FRNAALG}{jordanAdmissible?} \\
\cross{FRNAALG}{jordanAlgebra?} &
\cross{FRNAALG}{latex} \\
\cross{FRNAALG}{leftAlternative?} &
\cross{FRNAALG}{leftCharacteristicPolynomial} \\
\cross{FRNAALG}{leftDiscriminant} &
\cross{FRNAALG}{leftMinimalPolynomial} \\
\cross{FRNAALG}{leftNorm} &
\cross{FRNAALG}{leftPower} \\
\cross{FRNAALG}{leftRankPolynomial} &
\cross{FRNAALG}{leftRecip} \\
\cross{FRNAALG}{leftRegularRepresentation} &
\cross{FRNAALG}{leftTrace} \\
\cross{FRNAALG}{leftTraceMatrix} &
\cross{FRNAALG}{leftUnit} \\
\cross{FRNAALG}{leftUnits} &
\cross{FRNAALG}{lieAdmissible?} \\
\cross{FRNAALG}{lieAlgebra?} &
\cross{FRNAALG}{noncommutativeJordanAlgebra?} \\
\cross{FRNAALG}{plenaryPower} &
\cross{FRNAALG}{powerAssociative?} \\
\cross{FRNAALG}{rank} &
\cross{FRNAALG}{recip} \\
\cross{FRNAALG}{represents} &
\cross{FRNAALG}{rightAlternative?} \\
\cross{FRNAALG}{rightCharacteristicPolynomial} &
\cross{FRNAALG}{rightDiscriminant} \\
\cross{FRNAALG}{rightMinimalPolynomial} &
\cross{FRNAALG}{rightNorm} \\
\cross{FRNAALG}{rightPower} &
\cross{FRNAALG}{rightRankPolynomial} \\
\cross{FRNAALG}{rightRecip} &
\cross{FRNAALG}{rightRegularRepresentation} \\
\cross{FRNAALG}{rightTrace} &
\cross{FRNAALG}{rightTraceMatrix} \\
\cross{FRNAALG}{rightUnit} &
\cross{FRNAALG}{rightUnits} \\
\cross{FRNAALG}{sample} &
\cross{FRNAALG}{someBasis} \\
\cross{FRNAALG}{structuralConstants} &
\cross{FRNAALG}{subtractIfCan} \\
\cross{FRNAALG}{unit} &
\cross{FRNAALG}{zero?} \\
\cross{FRNAALG}{?*?} &
\cross{FRNAALG}{?**?} \\
\cross{FRNAALG}{?+?} &
\cross{FRNAALG}{?-?} \\
\cross{FRNAALG}{-?} &
\cross{FRNAALG}{?=?} \\
\cross{FRNAALG}{?.?} &
\cross{FRNAALG}{?~=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 apply : (Matrix R,%) -> %
 basis : () -> Vector %               
 convert : Vector R -> %              
 ?.? : (%,Integer) -> R
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 conditionsForIdempotents : () -> List Polynomial R
 convert : % -> Vector R
 coordinates : % -> Vector R          
 coordinates : Vector % -> Matrix R
 leftDiscriminant : () -> R
 leftRankPolynomial : () -> 
   SparseUnivariatePolynomial Polynomial R 
     if R has FIELD
 leftRegularRepresentation : % -> Matrix R
 leftTraceMatrix : () -> Matrix R
 leftUnit : () -> Union(%,"failed") if R has INTDOM
 leftUnits : () -> 
   Union(Record(particular: %,basis: List %),"failed") 
     if R has INTDOM
 represents : Vector R -> %           
 rightDiscriminant : () -> R          
 rightRankPolynomial : () -> 
   SparseUnivariatePolynomial Polynomial R 
     if R has FIELD
 rightRegularRepresentation : % -> Matrix R
 rightTraceMatrix : () -> Matrix R    
 rightUnit : () -> Union(%,"failed") if R has INTDOM
 rightUnits : () -> 
   Union(Record(particular: %,basis: List %),"failed") 
     if R has INTDOM
 structuralConstants : () -> Vector Matrix R
 unit : () -> Union(%,"failed") if R has INTDOM
\end{verbatim}

These exports come from FiniteRankNonAssociativeAlgebra(R)\\
where R:CommutativeRing:
\begin{verbatim}
 0 : () -> %                          
 alternative? : () -> Boolean
 antiAssociative? : () -> Boolean     
 antiCommutative? : () -> Boolean
 antiCommutator : (%,%) -> %          
 associative? : () -> Boolean         
 associator : (%,%,%) -> %
 associatorDependence : () -> List Vector R 
     if R has INTDOM
 coerce : % -> OutputForm
 commutative? : () -> Boolean         
 commutator : (%,%) -> %
 conditionsForIdempotents : Vector % -> List Polynomial R
 coordinates : (Vector %,Vector %) -> Matrix R
 coordinates : (%,Vector %) -> Vector R
 flexible? : () -> Boolean            
 hash : % -> SingleInteger
 jacobiIdentity? : () -> Boolean      
 jordanAdmissible? : () -> Boolean
 jordanAlgebra? : () -> Boolean       
 latex : % -> String
 leftAlternative? : () -> Boolean     
 leftCharacteristicPolynomial : % -> 
   SparseUnivariatePolynomial R
 leftDiscriminant : Vector % -> R     
 leftMinimalPolynomial : % -> 
   SparseUnivariatePolynomial R 
     if R has INTDOM
 leftNorm : % -> R
 leftPower : (%,PositiveInteger) -> %
 leftRecip : % -> Union(%,"failed") if R has INTDOM
 leftRegularRepresentation : (%,Vector %) -> Matrix R
 leftTrace : % -> R                   
 leftTraceMatrix : Vector % -> Matrix R
 lieAdmissible? : () -> Boolean       
 lieAlgebra? : () -> Boolean
 noncommutativeJordanAlgebra? : () -> Boolean
 plenaryPower : (%,PositiveInteger) -> %
 powerAssociative? : () -> Boolean    
 rank : () -> PositiveInteger
 recip : % -> Union(%,"failed") if R has INTDOM
 represents : (Vector R,Vector %) -> %
 rightAlternative? : () -> Boolean
 rightCharacteristicPolynomial : % -> 
   SparseUnivariatePolynomial R
 rightDiscriminant : Vector % -> R
 rightMinimalPolynomial : % -> 
   SparseUnivariatePolynomial R 
     if R has INTDOM
 rightNorm : % -> R                   
 rightPower : (%,PositiveInteger) -> %
 rightRecip : % -> Union(%,"failed") if R has INTDOM
 rightRegularRepresentation : (%,Vector %) -> Matrix R
 rightTrace : % -> R
 rightTraceMatrix : Vector % -> Matrix R
 sample : () -> %
 someBasis : () -> Vector %           
 structuralConstants : Vector % -> Vector Matrix R
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
\end{verbatim}

<<category FRNAALG FramedNonAssociativeAlgebra>>=
)abbrev category FRNAALG FramedNonAssociativeAlgebra
++ Author: J. Grabmeier, R. Wisbauer
++ Date Created: 01 March 1991
++ Date Last Updated: 11 June 1991
++ Basic Operations: +,-,*,**,basis
++ Related Constructors: FiniteRankNonAssociativeAlgebra, FramedAlgebra,
++   FiniteRankAssociativeAlgebra
++ Also See:
++ AMS Classifications:
++ Keywords: nonassociative algebra, basis
++ Reference:
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++ Description:
++   FramedNonAssociativeAlgebra(R) is a
++   \spadtype{FiniteRankNonAssociativeAlgebra} (i.e. a non associative
++   algebra over R which is a free \spad{R}-module of finite rank)
++   over a commutative ring R together with a fixed \spad{R}-module basis.
FramedNonAssociativeAlgebra(R:CommutativeRing):
        Category == FiniteRankNonAssociativeAlgebra(R) with
    basis: () -> Vector %
      ++ basis() returns the fixed \spad{R}-module basis.
    coordinates: % -> Vector R
      ++ coordinates(a) returns the coordinates of \spad{a}
      ++ with respect to the
      ++ fixed \spad{R}-module basis.
    coordinates: Vector % -> Matrix R
      ++ coordinates([a1,...,am]) returns a matrix whose i-th row
      ++ is formed by the coordinates of \spad{ai} with respect to the
      ++ fixed \spad{R}-module basis.
    elt : (%,Integer) -> R
      ++ elt(a,i) returns the i-th coefficient of \spad{a} with respect 
      ++ to the fixed \spad{R}-module basis.
    structuralConstants:() -> Vector Matrix R
      ++ structuralConstants() calculates the structural constants
      ++ \spad{[(gammaijk) for k in 1..rank()]} defined by
      ++ \spad{vi * vj = gammaij1 * v1 + ... + gammaijn * vn},
      ++ where \spad{v1},...,\spad{vn} is the fixed \spad{R}-module basis.
    conditionsForIdempotents: () -> List Polynomial R
      ++ conditionsForIdempotents() determines a complete list
      ++ of polynomial equations for the coefficients of idempotents
      ++ with respect to the fixed \spad{R}-module basis.
    represents: Vector R -> %
      ++ represents([a1,...,an]) returns \spad{a1*v1 + ... + an*vn},
      ++ where \spad{v1}, ..., \spad{vn} are the elements of the
      ++ fixed \spad{R}-module basis.
    convert: % -> Vector R
      ++ convert(a) returns the coordinates of \spad{a} with respect to the
      ++ fixed \spad{R}-module basis.
    convert: Vector R -> %
      ++ convert([a1,...,an]) returns \spad{a1*v1 + ... + an*vn},
      ++ where \spad{v1}, ..., \spad{vn} are the elements of the
      ++ fixed \spad{R}-module basis.
    leftDiscriminant : () -> R
      ++ leftDiscriminant() returns the
      ++ determinant of the \spad{n}-by-\spad{n}
      ++ matrix whose element at the \spad{i}-th row and \spad{j}-th column
      ++ is given by the left trace of the product \spad{vi*vj}, where
      ++ \spad{v1},...,\spad{vn} are the
      ++ elements of the fixed \spad{R}-module basis.
      ++ Note: the same as \spad{determinant(leftTraceMatrix())}.
    rightDiscriminant : () -> R
      ++ rightDiscriminant() returns the determinant of the 
      ++ \spad{n}-by-\spad{n} matrix whose element at the \spad{i}-th row 
      ++ and \spad{j}-th column is 
      ++ given by the right trace of the product \spad{vi*vj}, where
      ++ \spad{v1},...,\spad{vn} are the elements of
      ++ the fixed \spad{R}-module basis.
      ++ Note: the same as \spad{determinant(rightTraceMatrix())}.
    leftTraceMatrix : () -> Matrix R
      ++ leftTraceMatrix() is the \spad{n}-by-\spad{n}
      ++ matrix whose element at the \spad{i}-th row and \spad{j}-th column
      ++ is given by left trace of the product \spad{vi*vj},
      ++ where \spad{v1},...,\spad{vn} are the
      ++ elements of the fixed \spad{R}-module basis.
    rightTraceMatrix : () -> Matrix R
      ++ rightTraceMatrix() is the \spad{n}-by-\spad{n}
      ++ matrix whose element at the \spad{i}-th row and \spad{j}-th column
      ++ is given by the right trace of the product \spad{vi*vj}, where
      ++ \spad{v1},...,\spad{vn} are the elements
      ++ of the fixed \spad{R}-module basis.
    leftRegularRepresentation : % -> Matrix R
      ++ leftRegularRepresentation(a) returns the matrix of the linear
      ++ map defined by left multiplication by \spad{a} with respect
      ++ to the fixed \spad{R}-module basis.
    rightRegularRepresentation : % -> Matrix R
      ++ rightRegularRepresentation(a) returns the matrix of the linear
      ++ map defined by right multiplication by \spad{a} with respect
      ++ to the fixed \spad{R}-module basis.
    if R has Field then
      leftRankPolynomial : () -> SparseUnivariatePolynomial Polynomial R
        ++ leftRankPolynomial() calculates the left minimal polynomial
        ++ of the generic element in the algebra,
        ++ defined by the same structural
        ++ constants over the polynomial ring in symbolic coefficients with
        ++ respect to the fixed basis.
      rightRankPolynomial : () -> SparseUnivariatePolynomial Polynomial R
        ++ rightRankPolynomial() calculates the right minimal polynomial
        ++ of the generic element in the algebra,
        ++ defined by the same structural
        ++ constants over the polynomial ring in symbolic coefficients with
        ++ respect to the fixed basis.
    apply: (Matrix R, %) -> %
      ++ apply(m,a) defines a left operation of n by n matrices
      ++ where n is the rank of the algebra in terms of matrix-vector
      ++ multiplication, this is a substitute for a left module structure.
      ++ Error: if shape of matrix doesn't fit.
    --attributes
      --separable <=> discriminant() ^= 0
  add

    V  ==> Vector
    M  ==> Matrix
    P  ==> Polynomial
    F  ==> Fraction
    REC  ==> Record(particular: Union(V R,"failed"),basis: List V R)
    LSMP ==> LinearSystemMatrixPackage(R,V R,V R, M R)
    CVMP ==> CoerceVectorMatrixPackage(R)

    --GA ==> GenericNonAssociativeAlgebra(R,rank()$%,_
    -- [random()$Character :: String :: Symbol for i in 1..rank()$%], _
    -- structuralConstants()$%)
    --y : GA := generic()
    if R has Field then
      leftRankPolynomial() ==
        n := rank()
        b := basis()
        gamma : Vector Matrix R := structuralConstants b
        listOfNumbers : List String :=  [STRINGIMAGE(q)$Lisp for q in 1..n]
        symbolsForCoef : Vector Symbol :=
          [concat("%", concat("x", i))::Symbol  for i in listOfNumbers]
        xx : M P R
        mo : P R
        x : M P R := new(1,n,0)
        for i in 1..n repeat
          mo := monomial(1, [symbolsForCoef.i], [1])$(P R)
          qsetelt_!(x,1,i,mo)
        y : M P R := copy x
        k  : PositiveInteger := 1
        cond : M P R := copy x
        -- multiplication in the generic algebra means using
        -- the structural matrices as bilinear forms.
        -- left multiplication by x, we prepare for that:
        genGamma : V M P R :=  coerceP$CVMP gamma
        x := reduce(horizConcat,[x*genGamma(i) for i in 1..#genGamma])
        while rank(cond) = k repeat
          k := k+1
          for i in 1..n repeat
            setelt(xx,[1],[i],x*transpose y)
          y := copy xx
          cond := horizConcat(cond, xx)
        vectorOfCoef : Vector P R := (nullSpace(cond)$Matrix(P R)).first
        res : SparseUnivariatePolynomial P R := 0
        for i in 1..k repeat
         res:=res+monomial(vectorOfCoef.i,i)$(SparseUnivariatePolynomial P R)
        res

      rightRankPolynomial() ==
        n := rank()
        b := basis()
        gamma : Vector Matrix R := structuralConstants b
        listOfNumbers : List String :=  [STRINGIMAGE(q)$Lisp for q in 1..n]
        symbolsForCoef : Vector Symbol :=
          [concat("%", concat("x", i))::Symbol  for i in listOfNumbers]
        xx : M P R
        mo : P R
        x : M P R := new(1,n,0)
        for i in 1..n repeat
          mo := monomial(1, [symbolsForCoef.i], [1])$(P R)
          qsetelt_!(x,1,i,mo)
        y : M P R := copy x
        k  : PositiveInteger := 1
        cond : M P R := copy x
        -- multiplication in the generic algebra means using
        -- the structural matrices as bilinear forms.
        -- left multiplication by x, we prepare for that:
        genGamma : V M P R :=  coerceP$CVMP gamma
        x := _
         reduce(horizConcat,[genGamma(i)*transpose x for i in 1..#genGamma])
        while rank(cond) = k repeat
          k := k+1
          for i in 1..n repeat
            setelt(xx,[1],[i],y * transpose x)
          y := copy xx
          cond := horizConcat(cond, xx)
        vectorOfCoef : Vector P R := (nullSpace(cond)$Matrix(P R)).first
        res : SparseUnivariatePolynomial P R := 0
        for i in 1..k repeat
         res := _
          res+monomial(vectorOfCoef.i,i)$(SparseUnivariatePolynomial  P R)
        res

      leftUnitsInternal : () -> REC
      leftUnitsInternal() ==
        n := rank()
        b := basis()
        gamma : Vector Matrix R := structuralConstants b
        cond : Matrix(R) := new(n**2,n,0$R)$Matrix(R)
        rhs : Vector(R) := new(n**2,0$R)$Vector(R)
        z : Integer := 0
        addOn : R := 0
        for k in 1..n repeat
         for i in 1..n repeat
           z := z+1   -- index for the rows
           addOn :=
             k=i => 1
             0
           setelt(rhs,z,addOn)$Vector(R)
           for j in 1..n repeat  -- index for the columns
             setelt(cond,z,j,elt(gamma.k,j,i))$Matrix(R)
        solve(cond,rhs)$LSMP


      leftUnit() ==
        res : REC := leftUnitsInternal()
        res.particular case "failed" =>
          messagePrint("this algebra has no left unit")$OutputForm
          "failed"
        represents (res.particular :: V R)

      leftUnits() ==
        res : REC := leftUnitsInternal()
        res.particular case "failed" =>
          messagePrint("this algebra has no left unit")$OutputForm
          "failed"
        [represents(res.particular :: V R)$%, _
          map(represents, res.basis)$ListFunctions2(Vector R, %) ]

      rightUnitsInternal : () -> REC
      rightUnitsInternal() ==
        n := rank()
        b := basis()
        gamma : Vector Matrix R := structuralConstants b
        condo : Matrix(R) := new(n**2,n,0$R)$Matrix(R)
        rhs : Vector(R) := new(n**2,0$R)$Vector(R)
        z : Integer := 0
        addOn : R := 0
        for k in 1..n repeat
         for i in 1..n repeat
           z := z+1   -- index for the rows
           addOn :=
             k=i => 1
             0
           setelt(rhs,z,addOn)$Vector(R)
           for j in 1..n repeat  -- index for the columns
             setelt(condo,z,j,elt(gamma.k,i,j))$Matrix(R)
        solve(condo,rhs)$LSMP

      rightUnit() ==
        res : REC := rightUnitsInternal()
        res.particular case "failed" =>
          messagePrint("this algebra has no right unit")$OutputForm
          "failed"
        represents (res.particular :: V R)

      rightUnits() ==
        res : REC := rightUnitsInternal()
        res.particular case "failed" =>
          messagePrint("this algebra has no right unit")$OutputForm
          "failed"
        [represents(res.particular :: V R)$%, _
          map(represents, res.basis)$ListFunctions2(Vector R, %) ]

      unit() ==
        n := rank()
        b := basis()
        gamma : Vector Matrix R := structuralConstants b
        cond : Matrix(R) := new(2*n**2,n,0$R)$Matrix(R)
        rhs : Vector(R) := new(2*n**2,0$R)$Vector(R)
        z : Integer := 0
        u : Integer := n*n
        addOn : R := 0
        for k in 1..n repeat
         for i in 1..n repeat
           z := z+1   -- index for the rows
           addOn :=
             k=i => 1
             0
           setelt(rhs,z,addOn)$Vector(R)
           setelt(rhs,u,addOn)$Vector(R)
           for j in 1..n repeat  -- index for the columns
             setelt(cond,z,j,elt(gamma.k,j,i))$Matrix(R)
             setelt(cond,u,j,elt(gamma.k,i,j))$Matrix(R)
        res : REC := solve(cond,rhs)$LSMP
        res.particular case "failed" =>
          messagePrint("this algebra has no unit")$OutputForm
          "failed"
        represents (res.particular :: V R)
    apply(m:Matrix(R),a:%) ==
      v : Vector R := coordinates(a)
      v := m *$Matrix(R) v
      convert v


    structuralConstants()   == structuralConstants basis()
    conditionsForIdempotents() == conditionsForIdempotents basis()
    convert(x:%):Vector(R)  == coordinates(x, basis())
    convert(v:Vector R):%   == represents(v, basis())
    leftTraceMatrix()       == leftTraceMatrix basis()
    rightTraceMatrix()      == rightTraceMatrix basis()
    leftDiscriminant()      == leftDiscriminant basis()
    rightDiscriminant()     == rightDiscriminant basis()
    leftRegularRepresentation x == leftRegularRepresentation(x, basis())
    rightRegularRepresentation x == rightRegularRepresentation(x, basis())
    coordinates x           == coordinates(x, basis())
    represents(v:Vector R):%== represents(v, basis())

    coordinates(v:Vector %) ==
      m := new(#v, rank(), 0)$Matrix(R)
      for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
        setRow_!(m, j, coordinates qelt(v, i))
      m

@
<<FRNAALG.dotabb>>=
"FRNAALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRNAALG"];
"FRNAALG" -> "FINAALG"

@
<<FRNAALG.dotfull>>=
"FramedNonAssociativeAlgebra(a:CommutativeRing)"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRNAALG"];
"FramedNonAssociativeAlgebra(a:CommutativeRing)" ->
    "FiniteRankNonAssociativeAlgebra(a:CommutativeRing)"

@
<<FRNAALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FramedNonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"FramedNonAssociativeAlgebra(a:CommutativeRing)" ->
    "FiniteRankNonAssociativeAlgebra(a:CommutativeRing)"

"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"FiniteRankNonAssociativeAlgebra(a:CommutativeRing)" ->
    "NonAssociativeAlgebra(a:CommutativeRing)"

"NonAssociativeAlgebra(a:CommutativeRing)" [color=lightblue];
"NonAssociativeAlgebra(a:CommutativeRing)" -> "NonAssociativeRng()"
"NonAssociativeAlgebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"NonAssociativeRng()" [color=lightblue];
"NonAssociativeRng()" -> "ABELGRP..."
"NonAssociativeRng()" -> "Monad()"

"Monad()" [color=lightblue];
"Monad()" -> "SETCAT..."
"Monad()" -> "REPSQ..."

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BiModule(a:Ring,b:Ring)"

"BiModule(a:Ring,b:Ring)" [color=lightblue];
"BiModule(a:Ring,b:Ring)" -> "LeftModule(a:Ring)"
"BiModule(a:Ring,b:Ring)" -> "RightModule(a:Ring)"

"RightModule(a:Ring)" [color=seagreen];
"RightModule(a:Ring)" -> "RightModule(a:Rng)"

"RightModule(a:Rng)" [color=lightblue];
"RightModule(a:Rng)" -> "ABELGRP..."

"LeftModule(a:Ring)" [color=seagreen];
"LeftModule(a:Ring)" -> "LeftModule(a:Rng)"

"LeftModule(a:Rng)" [color=lightblue];
"LeftModule(a:Rng)" -> "ABELGRP..."

"REPSQ..." [color="#00EE00"];
"SETCAT..." [color=lightblue];
"ABELGRP..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{GcdDomain}{GCDDOM}
\pagepic{ps/v102gcddomain.ps}{GCDDOM}{0.65}

{\bf See:}\\
\pageto{PrincipalIdealDomain}{PID}
\pageto{UniqueFactorizationDomain}{UFD}
\pagefrom{IntegralDomain}{INTDOM}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{GCDDOM}{0} &
\cross{GCDDOM}{1} &
\cross{GCDDOM}{associates?} &
\cross{GCDDOM}{characteristic} &
\cross{GCDDOM}{coerce} \\
\cross{GCDDOM}{exquo} &
\cross{GCDDOM}{gcd} &
\cross{GCDDOM}{gcdPolynomial} &
\cross{GCDDOM}{hash} &
\cross{GCDDOM}{latex} \\
\cross{GCDDOM}{lcm} &
\cross{GCDDOM}{one?} &
\cross{GCDDOM}{recip} &
\cross{GCDDOM}{sample} &
\cross{GCDDOM}{subtractIfCan} \\
\cross{GCDDOM}{unit?} &
\cross{GCDDOM}{unitCanonical} &
\cross{GCDDOM}{unitNormal} &
\cross{GCDDOM}{zero?} &
\cross{GCDDOM}{?*?} \\
\cross{GCDDOM}{?**?} &
\cross{GCDDOM}{?+?} &
\cross{GCDDOM}{?-?} &
\cross{GCDDOM}{-?} &
\cross{GCDDOM}{?=?} \\
\cross{GCDDOM}{?\^{}?} &
\cross{GCDDOM}{?\~{}=?} &&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 gcd : (%,%) -> %                     
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 gcd : List % -> %
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) -> 
                     SparseUnivariatePolynomial %
 lcm : (%,%) -> %                     
 lcm : List % -> %
\end{verbatim}

These exports come from IntegralDomain():
\begin{verbatim}
 associates? : (%,%) -> Boolean
 exquo : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean                 
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category GCDDOM GcdDomain>>=
)abbrev category GCDDOM GcdDomain
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References: Davenport & Trager 1
++ Description:
++ This category describes domains where
++ \spadfun{gcd} can be computed but where there is no guarantee
++ of the existence of \spadfun{factor} operation for factorisation 
++ into irreducibles. However, if such a \spadfun{factor} operation exist, 
++ factorization will be unique up to order and units.

GcdDomain(): Category == IntegralDomain with
    gcd: (%,%) -> %
      ++ gcd(x,y) returns the greatest common divisor of x and y.
      -- gcd(x,y) = gcd(y,x) in the presence of canonicalUnitNormal,
      -- but not necessarily elsewhere
    gcd: List(%) -> %
      ++ gcd(l) returns the common gcd of the elements in the list l.
    lcm: (%,%) -> %
      ++ lcm(x,y) returns the least common multiple of x and y.
      -- lcm(x,y) = lcm(y,x) in the presence of canonicalUnitNormal,
      -- but not necessarily elsewhere
    lcm: List(%) -> %
      ++ lcm(l) returns the least common multiple of the elements of 
      ++ the list l.
    gcdPolynomial: (SparseUnivariatePolynomial %, _
                    SparseUnivariatePolynomial %) -> _
                       SparseUnivariatePolynomial %
      ++ gcdPolynomial(p,q) returns the greatest common divisor (gcd) of 
      ++ univariate polynomials over the domain
  add
   lcm(x: %,y: %) ==
     y = 0 => 0
     x = 0 => 0
     LCM : Union(%,"failed") := y exquo gcd(x,y)
     LCM case % =>  x * LCM
     error "bad gcd in lcm computation"
   lcm(l:List %) == reduce(lcm,l,1,0)
   gcd(l:List %) == reduce(gcd,l,0,1)
   SUP ==> SparseUnivariatePolynomial
   gcdPolynomial(p1,p2) ==
     zero? p1 => unitCanonical p2
     zero? p2 => unitCanonical p1
     c1:= content(p1); c2:= content(p2)
     p1:= (p1 exquo c1)::SUP %
     p2:= (p2 exquo c2)::SUP %
     if (e1:=minimumDegree p1) > 0 then p1:=(p1 exquo monomial(1,e1))::SUP %
     if (e2:=minimumDegree p2) > 0 then p2:=(p2 exquo monomial(1,e2))::SUP %
     e1:=min(e1,e2); c1:=gcd(c1,c2)
     p1:=
        degree p1 = 0 or degree p2 = 0 => monomial(c1,0)
        p:= subResultantGcd(p1,p2)
        degree p = 0 => monomial(c1,0)
        c2:= gcd(leadingCoefficient p1,leadingCoefficient p2)
        unitCanonical(_
          c1 * primitivePart(((c2*p) exquo leadingCoefficient p)::SUP %))
     zero? e1 => p1
     monomial(1,e1)*p1

@
<<GCDDOM.dotabb>>=
"GCDDOM"
"GCDDOM" -> "INTDOM"

@
<<GCDDOM.dotfull>>=
"GcdDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=GCDDOM"];
"GcdDomain()" -> "IntegralDomain()"

@
<<GCDDOM.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"GcdDomain()" [color=lightblue];
"GcdDomain()" -> "IntegralDomain()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{OrderedIntegralDomain}{OINTDOM}
\pagepic{ps/v102orderedintegraldomain.ps}{OINTDOM}{0.45}

{\bf See:}\\
\pagefrom{IntegralDomain}{INTDOM}
\pagefrom{OrderedRing}{ORDRING}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{OINTDOM}{1} &
\cross{OINTDOM}{0} &
\cross{OINTDOM}{abs} &
\cross{OINTDOM}{associates?} &
\cross{OINTDOM}{characteristic} \\
\cross{OINTDOM}{coerce} &
\cross{OINTDOM}{exquo} &
\cross{OINTDOM}{hash} &
\cross{OINTDOM}{latex} &
\cross{OINTDOM}{max} \\
\cross{OINTDOM}{min} &
\cross{OINTDOM}{negative?} &
\cross{OINTDOM}{one?} &
\cross{OINTDOM}{positive?} &
\cross{OINTDOM}{recip} \\
\cross{OINTDOM}{sample} &
\cross{OINTDOM}{sign} &
\cross{OINTDOM}{subtractIfCan} &
\cross{OINTDOM}{unit?} &
\cross{OINTDOM}{unitCanonical} \\
\cross{OINTDOM}{unitNormal} &
\cross{OINTDOM}{zero?} &
\cross{OINTDOM}{?*?} &
\cross{OINTDOM}{?**?} &
\cross{OINTDOM}{?+?} \\
\cross{OINTDOM}{?-?} &
\cross{OINTDOM}{-?} &
\cross{OINTDOM}{?$<$?} &
\cross{OINTDOM}{?$<=$?} &
\cross{OINTDOM}{?=?} \\
\cross{OINTDOM}{?$>$?} &
\cross{OINTDOM}{?$>=$?} &
\cross{OINTDOM}{?\^{}?} &
\cross{OINTDOM}{?\~{}=?} &
\end{tabular}

These exports come from IntegralDomain():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 associates? : (%,%) -> Boolean       
 characteristic : () -> NonNegativeInteger
 coerce : % -> %
 coerce : Integer -> %                
 coerce : % -> OutputForm
 exquo : (%,%) -> Union(%,"failed")
 hash : % -> SingleInteger            
 latex : % -> String
 one? : % -> Boolean
 recip : % -> Union(%,"failed")
 sample : () -> %                     
 subtractIfCan : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean                 
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,NonNegativeInteger) -> %
 ?**? : (%,PositiveInteger) -> %
 ?<? : (%,%) -> Boolean
 ?^? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
\end{verbatim}

These exports come from OrderedRing():
\begin{verbatim}
 abs : % -> %
 max : (%,%) -> %                     
 min : (%,%) -> %
 negative? : % -> Boolean             
 positive? : % -> Boolean             
 sign : % -> Integer
 ?<=? : (%,%) -> Boolean              
 ?>? : (%,%) -> Boolean               
 ?>=? : (%,%) -> Boolean
\end{verbatim}

<<category OINTDOM OrderedIntegralDomain>>=
)abbrev category OINTDOM OrderedIntegralDomain
++ Author: JH Davenport (after L Gonzalez-Vega)
++ Date Created: 30.1.96
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Description:
++ The category of ordered commutative integral domains, where ordering
++ and the arithmetic operations are compatible
++

OrderedIntegralDomain(): Category ==
  Join(IntegralDomain, OrderedRing) 

@
<<OINTDOM.dotabb>>=
"OINTDOM"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OINTDOM"];
"OINTDOM" -> "INTDOM"
"OINTDOM" -> "ORDRING"

@
<<OINTDOM.dotfull>>=
"OrderedIntegralDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OINTDOM"];
"OrderedIntegralDomain()" -> "IntegralDomain()"
"OrderedIntegralDomain()" -> "OrderedRing()"

@
<<OINTDOM.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"OrderedIntegralDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=OINTDOM"];
"OrderedIntegralDomain()" -> "IntegralDomain()"
"OrderedIntegralDomain()" -> "OrderedRing()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"OrderedRing()" [color=lightblue];
"OrderedRing()" -> "OAGROUP..."
"OrderedRing()" -> "RING..."
"OrderedRing()" -> "MONOID..."

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"OAGROUP..." [color=lightblue];
"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
"MONOID..." [color=lightblue];
}

@
\chapter{Category Layer 14}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{PrincipalIdealDomain}{PID}
\pagepic{ps/v102principalidealdomain.ps}{PID}{0.65}

{\bf See:}\\
\pageto{EuclideanDomain}{EUCDOM}
\pagefrom{GcdDomain}{GCDDOM}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{PID}{0} &
\cross{PID}{1} &
\cross{PID}{associates?} &
\cross{PID}{characteristic} &
\cross{PID}{coerce} \\
\cross{PID}{expressIdealMember} &
\cross{PID}{exquo} &
\cross{PID}{gcd} &
\cross{PID}{gcdPolynomial} &
\cross{PID}{hash} \\
\cross{PID}{latex} &
\cross{PID}{lcm} &
\cross{PID}{one?} &
\cross{PID}{principalIdeal} &
\cross{PID}{recip} \\
\cross{PID}{sample} &
\cross{PID}{subtractIfCan} &
\cross{PID}{unit?} &
\cross{PID}{unitCanonical} &
\cross{PID}{unitNormal} \\
\cross{PID}{zero?} &
\cross{PID}{?+?} &
\cross{PID}{?-?} &
\cross{PID}{-?} &
\cross{PID}{?=?} \\
\cross{PID}{?\~{}=?} &
\cross{PID}{?*?} &
\cross{PID}{?**?} &
\cross{PID}{?\^{}?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 expressIdealMember : (List %,%) -> Union(List %,"failed")
 principalIdeal : List % -> Record(coef: List %,generator: %)
\end{verbatim}

These exports come from GcdDomain():
\begin{verbatim}
 associates? : (%,%) -> Boolean
 exquo : (%,%) -> Union(%,"failed")
 gcd : (%,%) -> %                     
 gcd : List % -> %
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) ->
                     SparseUnivariatePolynomial %
 lcm : List % -> %
 lcm : (%,%) -> %                     
 unit? : % -> Boolean                 
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category PID PrincipalIdealDomain>>=
)abbrev category PID PrincipalIdealDomain
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of constructive principal ideal domains, i.e.
++ where a single generator can be constructively found for
++ any ideal given by a finite set of generators.
++ Note that this constructive definition only implies that
++ finitely generated ideals are principal. It is not clear
++ what we would mean by an infinitely generated ideal.

PrincipalIdealDomain(): Category == GcdDomain with
      principalIdeal: List % -> Record(coef:List %,generator:%)
         ++ principalIdeal([f1,...,fn]) returns a record whose
         ++ generator component is a generator of the ideal
         ++ generated by \spad{[f1,...,fn]} whose coef component satisfies
         ++ \spad{generator = sum (input.i * coef.i)}
      expressIdealMember: (List %,%) -> Union(List %,"failed")
         ++ expressIdealMember([f1,...,fn],h) returns a representation
         ++ of h as a linear combination of the fi or "failed" if h
         ++ is not in the ideal generated by the fi.

@
<<PID.dotabb>>=
"PID"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PID"];
"PID" -> "GCDDOM"

@
<<PID.dotfull>>=
"PrincipalIdealDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PID"];
"PrincipalIdealDomain()" -> "GcdDomain()"

@
<<PID.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"PrincipalIdealDomain()" [color=lightblue];
"PrincipalIdealDomain()" -> "GcdDomain()"

"GcdDomain()" [color=lightblue];
"GcdDomain()" -> "IntegralDomain()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{UniqueFactorizationDomain}{UFD}
\pagepic{ps/v102uniquefactorizationdomain.ps}{UFD}{0.65}

{\bf See:}\\
\pageto{Field}{FIELD}
\pageto{PolynomialFactorizationExplicit}{PFECAT}
\pagefrom{GcdDomain}{GCDDOM}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{UFD}{0} &
\cross{UFD}{1} &
\cross{UFD}{associates?} &
\cross{UFD}{characteristic} &
\cross{UFD}{coerce} \\
\cross{UFD}{exquo} &
\cross{UFD}{factor} &
\cross{UFD}{gcd} &
\cross{UFD}{gcdPolynomial} &
\cross{UFD}{hash} \\
\cross{UFD}{latex} &
\cross{UFD}{lcm} &
\cross{UFD}{one?} &
\cross{UFD}{prime?} &
\cross{UFD}{recip} \\
\cross{UFD}{sample} &
\cross{UFD}{squareFree} &
\cross{UFD}{squareFreePart} &
\cross{UFD}{subtractIfCan} &
\cross{UFD}{unit?} \\
\cross{UFD}{unitCanonical} &
\cross{UFD}{unitNormal} &
\cross{UFD}{zero?} &
\cross{UFD}{?*?} &
\cross{UFD}{?**?} \\
\cross{UFD}{?+?} &
\cross{UFD}{?-?} &
\cross{UFD}{-?} &
\cross{UFD}{?=?} &
\cross{UFD}{?\~{}=?} \\
\cross{UFD}{?\^{}?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 factor : % -> Factored %
 squareFree : % -> Factored %         
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 prime? : % -> Boolean
 squareFreePart : % -> %
\end{verbatim}

These exports come from GcdDomain():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 associates? : (%,%) -> Boolean
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 exquo : (%,%) -> Union(%,"failed")
 gcd : (%,%) -> %
 gcd : List % -> %                    
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) -> 
                     SparseUnivariatePolynomial %
 hash : % -> SingleInteger            
 latex : % -> String
 lcm : List % -> %                    
 lcm : (%,%) -> %
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean                 
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category UFD UniqueFactorizationDomain>>=
)abbrev category UFD UniqueFactorizationDomain
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A constructive unique factorization domain, i.e. where
++ we can constructively factor members into a product of
++ a finite number of irreducible elements.

UniqueFactorizationDomain(): Category == GcdDomain with
   prime?: % -> Boolean
     ++ prime?(x) tests if x can never be written as the product of two
     ++ non-units of the ring,
     ++ i.e., x is an irreducible element.
   squareFree    : % -> Factored(%)
     ++ squareFree(x) returns the square-free factorization of x
     ++ i.e. such that the factors are pairwise relatively prime
     ++ and each has multiple prime factors.
   squareFreePart: % -> %
     ++ squareFreePart(x) returns a product of prime factors of
     ++ x each taken with multiplicity one.
   factor: % -> Factored(%)
     ++ factor(x) returns the factorization of x into irreducibles.
 add
  squareFreePart x ==
    unit(s := squareFree x) * _*/[f.factor for f in factors s]

  prime? x == # factorList factor x = 1

@
<<UFD.dotabb>>=
"UFD"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=UFD"];
"UFD" -> "GCDDOM"

@
<<UFD.dotfull>>=
"UniqueFactorizationDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=UFD"];
"UniqueFactorizationDomain()" -> "GcdDomain()"

@
<<UFD.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"UniqueFactorizationDomain()" [color=lightblue];
"UniqueFactorizationDomain()" -> "GcdDomain()"

"GcdDomain()" [color=lightblue];
"GcdDomain()" -> "IntegralDomain()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" ->
  "BiModule(a:CommutativeRing,b:CommutativeRing)"

"BiModule(a:CommutativeRing,b:CommutativeRing)" [color=seagreen];
"BiModule(a:CommutativeRing,b:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
\chapter{Category Layer 15}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{EuclideanDomain}{EUCDOM}
\pagepic{ps/v102euclideandomain.ps}{EUCDOM}{0.65}

{\bf See:}\\
\pageto{Field}{FIELD}
\pagefrom{PrincipalIdealDomain}{PID}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{EUCDOM}{1} &
\cross{EUCDOM}{0} &
\cross{EUCDOM}{associates?} &
\cross{EUCDOM}{characteristic} &
\cross{EUCDOM}{coerce} \\
\cross{EUCDOM}{divide} &
\cross{EUCDOM}{euclideanSize} &
\cross{EUCDOM}{expressIdealMember} &
\cross{EUCDOM}{exquo} &
\cross{EUCDOM}{extendedEuclidean} \\
\cross{EUCDOM}{gcd} &
\cross{EUCDOM}{gcdPolynomial} &
\cross{EUCDOM}{hash} &
\cross{EUCDOM}{latex} &
\cross{EUCDOM}{lcm} \\
\cross{EUCDOM}{multiEuclidean} &
\cross{EUCDOM}{one?} &
\cross{EUCDOM}{principalIdeal} &
\cross{EUCDOM}{recip} &
\cross{EUCDOM}{sample} \\
\cross{EUCDOM}{sizeLess?} &
\cross{EUCDOM}{subtractIfCan} &
\cross{EUCDOM}{unit?} &
\cross{EUCDOM}{unitCanonical} &
\cross{EUCDOM}{unitNormal} \\
\cross{EUCDOM}{zero?} &
\cross{EUCDOM}{?+?} &
\cross{EUCDOM}{?-?} &
\cross{EUCDOM}{-?} &
\cross{EUCDOM}{?=?} \\
\cross{EUCDOM}{?quo?} &
\cross{EUCDOM}{?rem?} &
\cross{EUCDOM}{?\~{}=?} &
\cross{EUCDOM}{?*?} &
\cross{EUCDOM}{?**?} \\
\cross{EUCDOM}{?\^{}?} &&&&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 divide : (%,%) -> Record(quotient: %,remainder: %)
 euclideanSize : % -> NonNegativeInteger
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 expressIdealMember : (List %,%) -> Union(List %,"failed")
 exquo : (%,%) -> Union(%,"failed")
 extendedEuclidean : (%,%) -> Record(coef1: %,coef2: %,generator: %)
 extendedEuclidean : (%,%,%) -> Union(Record(coef1: %,coef2: %),"failed")
 gcd : (%,%) -> %                     
 multiEuclidean : (List %,%) -> Union(List %,"failed")
 principalIdeal : List % -> Record(coef: List %,generator: %)
 sizeLess? : (%,%) -> Boolean         
 ?quo? : (%,%) -> %                   
 ?rem? : (%,%) -> %                   
\end{verbatim}

These exports come from PrincipalIdealDomain():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 associates? : (%,%) -> Boolean
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 gcd : List % -> %
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) -> 
                     SparseUnivariatePolynomial %
 hash : % -> SingleInteger
 latex : % -> String                  
 lcm : List % -> %
 lcm : (%,%) -> %                     
 one? : % -> Boolean
 recip : % -> Union(%,"failed")
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean
 unitCanonical : % -> %               
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 zero? : % -> Boolean
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category EUCDOM EuclideanDomain>>=
)abbrev category EUCDOM EuclideanDomain
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A constructive euclidean domain, i.e. one can divide producing
++ a quotient and a remainder where the remainder is either zero
++ or is smaller (\spadfun{euclideanSize}) than the divisor.
++
++ Conditional attributes:
++   multiplicativeValuation\tab{25}\spad{Size(a*b)=Size(a)*Size(b)}
++   additiveValuation\tab{25}\spad{Size(a*b)=Size(a)+Size(b)}

EuclideanDomain(): Category == PrincipalIdealDomain with
   sizeLess?: (%,%) -> Boolean
     ++ sizeLess?(x,y) tests whether x is strictly
     ++ smaller than y with respect to the 
     ++ \spadfunFrom{euclideanSize}{EuclideanDomain}.
   euclideanSize: % -> NonNegativeInteger
     ++ euclideanSize(x) returns the euclidean size of the element x.
     ++ Error: if x is zero.
   divide: (%,%) -> Record(quotient:%,remainder:%)
     ++ divide(x,y) divides x by y producing a record containing a
     ++ \spad{quotient} and \spad{remainder},
     ++ where the remainder is smaller (see 
     ++ \spadfunFrom{sizeLess?}{EuclideanDomain}) than the divisor y.
   "quo" : (%,%) -> %
     ++ x quo y is the same as \spad{divide(x,y).quotient}.
     ++ See \spadfunFrom{divide}{EuclideanDomain}.
   "rem": (%,%) -> %
     ++ x rem y is the same as \spad{divide(x,y).remainder}.
     ++ See \spadfunFrom{divide}{EuclideanDomain}.
   extendedEuclidean: (%,%) -> Record(coef1:%,coef2:%,generator:%)
     -- formerly called princIdeal
     ++ extendedEuclidean(x,y) returns a record rec where
     ++ \spad{rec.coef1*x+rec.coef2*y = rec.generator} and
     ++ rec.generator is a gcd of x and y.
     ++ The gcd is unique only
     ++ up to associates if \spadatt{canonicalUnitNormal} is not asserted.
     ++ \spadfun{principalIdeal} provides a version of this operation
     ++ which accepts an arbitrary length list of arguments.
   extendedEuclidean: (%,%,%) -> Union(Record(coef1:%,coef2:%),"failed")
     -- formerly called expressIdealElt
     ++ extendedEuclidean(x,y,z) either returns a record rec
     ++ where \spad{rec.coef1*x+rec.coef2*y=z} or returns "failed"
     ++ if z cannot be expressed as a linear combination of x and y.
   multiEuclidean: (List %,%) -> Union(List %,"failed")
     ++ multiEuclidean([f1,...,fn],z) returns a list of coefficients
     ++ \spad{[a1, ..., an]} such that
     ++ \spad{ z / prod fi = sum aj/fj}.
     ++ If no such list of coefficients exists, "failed" is returned.
  add
      x,y,z: %
      l: List %
      sizeLess?(x,y) ==
            zero? y => false
            zero? x => true
            euclideanSize(x)<euclideanSize(y)
      x quo y == divide(x,y).quotient --divide must be user-supplied
      x rem y == divide(x,y).remainder
      x exquo y ==
         zero? x => 0
         zero? y => "failed"
         qr:=divide(x,y)
         zero?(qr.remainder) => qr.quotient
         "failed"
      gcd(x,y) ==                --Euclidean Algorithm
         x:=unitCanonical x
         y:=unitCanonical y
         while not zero? y repeat
            (x,y):= (y,x rem y)
            y:=unitCanonical y   -- this doesn't affect the
                                 -- correctness of Euclid's algorithm,
                                 -- but
                                 -- a) may improve performance
                                 -- b) ensures gcd(x,y)=gcd(y,x)
                                 --    if canonicalUnitNormal
         x
      IdealElt ==> Record(coef1:%,coef2:%,generator:%)
      unitNormalizeIdealElt(s:IdealElt):IdealElt ==
         (u,c,a):=unitNormal(s.generator)
--         one? a => s
         (a = 1) => s
         [a*s.coef1,a*s.coef2,c]$IdealElt
      extendedEuclidean(x,y) ==         --Extended Euclidean Algorithm
         s1:=unitNormalizeIdealElt([1$%,0$%,x]$IdealElt)
         s2:=unitNormalizeIdealElt([0$%,1$%,y]$IdealElt)
         zero? y => s1
         zero? x => s2
         while not zero?(s2.generator) repeat
            qr:= divide(s1.generator, s2.generator)
            s3:=[s1.coef1 - qr.quotient * s2.coef1,
                 s1.coef2 - qr.quotient * s2.coef2, qr.remainder]$IdealElt
            s1:=s2
            s2:=unitNormalizeIdealElt s3
         if not(zero?(s1.coef1)) and not sizeLess?(s1.coef1,y)
           then
              qr:= divide(s1.coef1,y)
              s1.coef1:= qr.remainder
              s1.coef2:= s1.coef2 + qr.quotient * x
              s1 := unitNormalizeIdealElt s1
         s1

      TwoCoefs ==> Record(coef1:%,coef2:%)
      extendedEuclidean(x,y,z) ==
         zero? z => [0,0]$TwoCoefs
         s:= extendedEuclidean(x,y)
         (w:= z exquo s.generator) case "failed" => "failed"
         zero? y =>
            [s.coef1 * w, s.coef2 * w]$TwoCoefs
         qr:= divide((s.coef1 * w), y)
         [qr.remainder, s.coef2 * w + qr.quotient * x]$TwoCoefs
      principalIdeal l ==
         l = [] => error "empty list passed to principalIdeal"
         rest l = [] =>
              uca:=unitNormal(first l)
              [[uca.unit],uca.canonical]
         rest rest l = [] =>
             u:= extendedEuclidean(first l,second l)
             [[u.coef1, u.coef2], u.generator]
         v:=principalIdeal rest l
         u:= extendedEuclidean(first l,v.generator)
         [[u.coef1,:[u.coef2*vv for vv in v.coef]],u.generator]
      expressIdealMember(l,z) ==
         z = 0 => [0 for v in l]
         pid := principalIdeal l
         (q := z exquo (pid.generator)) case "failed" => "failed"
         [q*v for v in pid.coef]
      multiEuclidean(l,z) ==
         n := #l
         zero? n => error "empty list passed to multiEuclidean"
         n = 1 => [z]
         l1 := copy l
         l2 := split!(l1, n quo 2)
         u:= extendedEuclidean(*/l1, */l2, z)
         u case "failed" => "failed"
         v1 := multiEuclidean(l1,u.coef2)
         v1 case "failed" => "failed"
         v2 := multiEuclidean(l2,u.coef1)
         v2 case "failed" => "failed"
         concat(v1,v2)

@
<<EUCDOM.dotabb>>=
"EUCDOM"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=EUCDOM"];
"EUCDOM" -> "PID"

@
<<EUCDOM.dotfull>>=
"EuclideanDomain()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=EUCDOM"];
"EuclideanDomain()" -> "PrincipalIdealDomain()"

@
<<EUCDOM.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"EuclideanDomain()" [color=lightblue];
"EuclideanDomain()" -> "PrincipalIdealDomain()"

"PrincipalIdealDomain()" [color=lightblue];
"PrincipalIdealDomain()" -> "GcdDomain()"

"GcdDomain()" [color=lightblue];
"GcdDomain()" -> "IntegralDomain()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{PolynomialFactorizationExplicit}{PFECAT}
\pagepic{ps/v102polynomialfactorizationexplicit.ps}{PFECAT}{0.75}

{\bf See:}\\
\pagefrom{UniqueFactorizationDomain}{UFD}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{PFECAT}{0} &
\cross{PFECAT}{1} &
\cross{PFECAT}{associates?} \\
\cross{PFECAT}{characteristic} &
\cross{PFECAT}{charthRoot} &
\cross{PFECAT}{coerce} \\
\cross{PFECAT}{conditionP} &
\cross{PFECAT}{exquo} &
\cross{PFECAT}{factor} \\
\cross{PFECAT}{factorPolynomial} &
\cross{PFECAT}{factorSquareFreePolynomial} &
\cross{PFECAT}{gcd} \\
\cross{PFECAT}{gcdPolynomial} &
\cross{PFECAT}{hash} &
\cross{PFECAT}{latex} \\
\cross{PFECAT}{lcm} &
\cross{PFECAT}{one?} &
\cross{PFECAT}{prime?} \\
\cross{PFECAT}{recip} &
\cross{PFECAT}{sample} &
\cross{PFECAT}{solveLinearPolynomialEquation} \\
\cross{PFECAT}{squareFree} &
\cross{PFECAT}{squareFreePart} &
\cross{PFECAT}{squareFreePolynomial} \\
\cross{PFECAT}{subtractIfCan} &
\cross{PFECAT}{unit?} &
\cross{PFECAT}{unitNormal} \\
\cross{PFECAT}{unitCanonical} &
\cross{PFECAT}{zero?} &
\cross{PFECAT}{?*?} \\
\cross{PFECAT}{?**?} &
\cross{PFECAT}{?+?} &
\cross{PFECAT}{?-?} \\
\cross{PFECAT}{-?} &
\cross{PFECAT}{?=?} &
\cross{PFECAT}{?\^{}?} \\
\cross{PFECAT}{?\~{}=?} &&
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 conditionP : Matrix % -> Union(Vector %,"failed") 
     if $ has CHARNZ
 factorPolynomial :
   SparseUnivariatePolynomial % ->
      Factored SparseUnivariatePolynomial %
 factorSquareFreePolynomial : 
   SparseUnivariatePolynomial % -> 
      Factored SparseUnivariatePolynomial %
 squareFreePolynomial : 
   SparseUnivariatePolynomial % -> 
      Factored SparseUnivariatePolynomial %
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 charthRoot : % -> Union(%,"failed") if $ has CHARNZ
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) ->
                     SparseUnivariatePolynomial %
 solveLinearPolynomialEquation : 
   (List SparseUnivariatePolynomial %,
    SparseUnivariatePolynomial %) ->
      Union(List SparseUnivariatePolynomial %,"failed")
\end{verbatim}

These exports come from UniqueFactorizationDomain():
\begin{verbatim}
 factor : % -> Factored %
 squareFree : % -> Factored %         
 0 : () -> %
 1 : () -> %                          
 associates? : (%,%) -> Boolean
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 exquo : (%,%) -> Union(%,"failed")
 gcd : List % -> %                    
 gcd : (%,%) -> %
 hash : % -> SingleInteger            
 latex : % -> String
 lcm : List % -> %                    
 lcm : (%,%) -> %
 one? : % -> Boolean                  
 prime? : % -> Boolean
 recip : % -> Union(%,"failed")       
 sample : () -> %
 squareFreePart : % -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean                 
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 unitCanonical : % -> %
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category PFECAT PolynomialFactorizationExplicit>>=
)abbrev category PFECAT PolynomialFactorizationExplicit
++ Author: James Davenport
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This is the category of domains that know "enough" about
++ themselves in order to factor univariate polynomials over themselves.
++ This will be used in future releases for supporting factorization
++ over finitely generated coefficient fields, it is not yet available
++ in the current release of axiom.

PolynomialFactorizationExplicit(): Category == Definition where
  P ==> SparseUnivariatePolynomial %
  Definition ==>
   UniqueFactorizationDomain with
     squareFreePolynomial: P -> Factored(P)
       ++ squareFreePolynomial(p) returns the
       ++ square-free factorization of the
       ++ univariate polynomial p.
     factorPolynomial: P -> Factored(P)
       ++ factorPolynomial(p) returns the factorization
       ++ into irreducibles of the univariate polynomial p.
     factorSquareFreePolynomial: P -> Factored(P)
       ++ factorSquareFreePolynomial(p) factors the
       ++ univariate polynomial p into irreducibles
       ++ where p is known to be square free
       ++ and primitive with respect to its main variable.
     gcdPolynomial: (P, P) -> P
       ++ gcdPolynomial(p,q) returns the gcd of the univariate
       ++ polynomials p qnd q.
       -- defaults to Euclidean, but should be implemented via
       -- modular or p-adic methods.
     solveLinearPolynomialEquation: (List P, P) -> Union(List P,"failed")
       ++ solveLinearPolynomialEquation([f1, ..., fn], g)
       ++ (where the fi are relatively prime to each other)
       ++ returns a list of ai such that
       ++ \spad{g/prod fi = sum ai/fi}
       ++ or returns "failed" if no such list of ai's exists.
     if % has CharacteristicNonZero then
       conditionP: Matrix % -> Union(Vector %,"failed")
         ++ conditionP(m) returns a vector of elements, not all zero,
         ++ whose \spad{p}-th powers (p is the characteristic of the domain)
         ++ are a solution of the homogenous linear system represented
         ++ by m, or "failed" is there is no such vector.
       charthRoot: % -> Union(%,"failed")
         ++ charthRoot(r) returns the \spad{p}-th root of r, or "failed"
         ++ if none exists in the domain.
         -- this is a special case of conditionP, but often the one we want
    add
        gcdPolynomial(f,g) ==
           zero? f => g
           zero? g => f
           cf:=content f
           if not one? cf then f:=(f exquo cf)::P
           cg:=content g
           if not one? cg then g:=(g exquo cg)::P
           ans:=subResultantGcd(f,g)$P
           gcd(cf,cg)*(ans exquo content ans)::P
        if % has CharacteristicNonZero then
          charthRoot f ==
             -- to take p'th root of f, solve the system X-fY=0,
             -- so solution is [x,y]
             -- with x^p=X and y^p=Y, then (x/y)^p = f
             zero? f => 0
             m:Matrix % := matrix [[1,-f]]
             ans:= conditionP m
             ans case "failed" => "failed"
             (ans.1) exquo (ans.2)
        if % has Field then
          solveLinearPolynomialEquation(lf,g) ==
            multiEuclidean(lf,g)$P
        else solveLinearPolynomialEquation(lf,g) ==
               LPE ==> LinearPolynomialEquationByFractions %
               solveLinearPolynomialEquationByFractions(lf,g)$LPE

@
<<PFECAT.dotabb>>=
"PFECAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PFECAT"];
"PFECAT" -> "UFD"

@
<<PFECAT.dotfull>>=
"PolynomialFactorizationExplicit()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=PFECAT"];
"PolynomialFactorizationExplicit()" -> "UniqueFactorizationDomain()"

@
<<PFECAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"PolynomialFactorizationExplicit()" [color=lightblue];
"PolynomialFactorizationExplicit()" -> "UniqueFactorizationDomain()"

"UniqueFactorizationDomain()" [color=lightblue];
"UniqueFactorizationDomain()" -> "GcdDomain()"

"GcdDomain()" [color=lightblue];
"GcdDomain()" -> "IntegralDomain()"

"IntegralDomain()" [color=lightblue];
"IntegralDomain()" -> "CommutativeRing()"
"IntegralDomain()" -> "Algebra(a:CommutativeRing)"
"IntegralDomain()" -> "EntireRing()"

"CommutativeRing()" [color=lightblue];
"CommutativeRing()" -> "RING..."
"CommutativeRing()" -> "BMODULE..."

"EntireRing()" [color=lightblue];
"EntireRing()" -> "RING..."
"EntireRing()" -> "BMODULE..."

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "Module(a:CommutativeRing)"

"Module(a:CommutativeRing)" [color=lightblue];
"Module(a:CommutativeRing)" -> "BMODULE..."

"BMODULE..." [color=lightblue];
"RING..." [color=lightblue];
}

@
\chapter{Category Layer 16}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{Field}{FIELD}
\pagepic{ps/v102field.ps}{FIELD}{1.00}

{\bf See:}\\
\pageto{FiniteRankAlgebra}{FINRALG}
\pagefrom{DivisionRing}{DIVRING}
\pagefrom{EuclideanDomain}{EUCDOM}
\pagefrom{UniqueFactorizationDomain}{UFD}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FIELD}{0} &
\cross{FIELD}{1} &
\cross{FIELD}{associates?} &
\cross{FIELD}{characteristic} &
\cross{FIELD}{coerce} \\
\cross{FIELD}{divide} &
\cross{FIELD}{euclideanSize} &
\cross{FIELD}{expressIdealMember} &
\cross{FIELD}{exquo} &
\cross{FIELD}{extendedEuclidean} \\
\cross{FIELD}{factor} &
\cross{FIELD}{gcd} &
\cross{FIELD}{gcdPolynomial} &
\cross{FIELD}{hash} &
\cross{FIELD}{inv} \\
\cross{FIELD}{latex} &
\cross{FIELD}{lcm} &
\cross{FIELD}{multiEuclidean} &
\cross{FIELD}{one?} &
\cross{FIELD}{prime?} \\
\cross{FIELD}{principalIdeal} &
\cross{FIELD}{recip} &
\cross{FIELD}{sample} &
\cross{FIELD}{sizeLess?} &
\cross{FIELD}{squareFree} \\
\cross{FIELD}{squareFreePart} &
\cross{FIELD}{subtractIfCan} &
\cross{FIELD}{unit?} &
\cross{FIELD}{unitCanonical} &
\cross{FIELD}{unitNormal} \\
\cross{FIELD}{zero?} &
\cross{FIELD}{?*?} &
\cross{FIELD}{?**?} &
\cross{FIELD}{?+?} &
\cross{FIELD}{?-?} \\
\cross{FIELD}{-?} &
\cross{FIELD}{?/?} &
\cross{FIELD}{?=?} &
\cross{FIELD}{?\^{}?} &
\cross{FIELD}{?quo?} \\
\cross{FIELD}{?rem?} &
\cross{FIELD}{?\~{}=?} &&&
\end{tabular}

{\bf Attributes Exported:}
\begin{itemize}
\item {\bf \cross{FIELD}{canonicalUnitNormal}}
is true if we can choose a canonical representative for each class 
of associate elements, that is {\tt associates?(a,b)} returns true 
if and only if {\tt unitCanonical(a) = unitCanonical(b)}.
\item {\bf \cross{FIELD}{canonicalsClosed}}
is true if\\
{\tt unitCanonical(a)*unitCanonical(b) = unitCanonical(a*b)}.
\end{itemize}

These are implemented by this category:
\begin{verbatim}
 associates? : (%,%) -> Boolean       
 divide : (%,%) -> Record(quotient: %,remainder: %)
 euclideanSize : % -> NonNegativeInteger
 exquo : (%,%) -> Union(%,"failed")
 factor : % -> Factored %
 gcd : (%,%) -> %
 inv : % -> %
 prime? : % -> Boolean                
 squareFree : % -> Factored %         
 unitCanonical : % -> %
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
 ?/? : (%,%) -> %                     
\end{verbatim}

These exports come from EuclideanDomain():
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : % -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 expressIdealMember : (List %,%) -> Union(List %,"failed")
 extendedEuclidean : (%,%,%) -> Union(Record(coef1: %,coef2: %),"failed")
 extendedEuclidean : (%,%) -> Record(coef1: %,coef2: %,generator: %)
 gcd : List % -> %                    
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) ->
                      SparseUnivariatePolynomial %
 hash : % -> SingleInteger            
 latex : % -> String                  
 lcm : List % -> %
 lcm : (%,%) -> %                     
 multiEuclidean : (List %,%) -> Union(List %,"failed")
 one? : % -> Boolean
 principalIdeal : List % -> Record(coef: List %,generator: %)
 recip : % -> Union(%,"failed")       
 sample : () -> %                     
 sizeLess? : (%,%) -> Boolean
 subtractIfCan : (%,%) -> Union(%,"failed")
 unit? : % -> Boolean                 
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %                     
 -? : % -> %
 ?**? : (%,PositiveInteger) -> %      
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %
 ?^? : (%,NonNegativeInteger) -> %
 ?quo? : (%,%) -> %
 ?rem? : (%,%) -> %
\end{verbatim}

These exports come from UniqueFactorizationDomain():
\begin{verbatim}
 squareFreePart : % -> %
\end{verbatim}

These exports come from DivisionRing():
\begin{verbatim}
 coerce : Fraction Integer -> %
 ?*? : (Fraction Integer,%) -> %      
 ?*? : (%,Fraction Integer) -> %
 ?**? : (%,Integer) -> %
 ?^? : (%,Integer) -> %               
\end{verbatim}

<<category FIELD Field>>=
)abbrev category FIELD Field
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ The category of commutative fields, i.e. commutative rings
++ where all non-zero elements have multiplicative inverses.
++ The \spadfun{factor} operation while trivial is useful to have defined.
++
++ Axioms:
++   \spad{a*(b/a) = b}
++   \spad{inv(a) = 1/a}

Field(): Category == Join(EuclideanDomain,UniqueFactorizationDomain,
  DivisionRing) with
      "/": (%,%) -> %
        ++ x/y divides the element x by the element y.
        ++ Error: if y is 0.
      canonicalUnitNormal  ++ either 0 or 1.
      canonicalsClosed     ++ since \spad{0*0=0}, \spad{1*1=1}
    add
      x,y: %
      n: Integer
      UCA ==> Record(unit:%,canonical:%,associate:%)
      unitNormal(x) ==
          if zero? x then [1$%,0$%,1$%]$UCA else [x,1$%,inv(x)]$UCA
      unitCanonical(x) == if zero? x then x else 1
      associates?(x,y) == if zero? x then zero? y else not(zero? y)
      inv x ==((u:=recip x) case "failed" => error "not invertible"; u)
      x exquo y == (y=0 => "failed"; x / y)
      gcd(x,y) == 1
      euclideanSize(x) == 0
      prime? x == false
      squareFree x == x::Factored(%)
      factor x == x::Factored(%)
      x / y == (zero? y => error "catdef: division by zero"; x * inv(y))
      divide(x,y) == [x / y,0]

@
<<FIELD.dotabb>>=
"FIELD"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FIELD"];
"FIELD" -> "EUCDOM"
"FIELD" -> "UFD"
"FIELD" -> "DIVRING"

@
<<FIELD.dotfull>>=
"Field()"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FIELD"];
"Field()" -> "EuclideanDomain()"
"Field()" -> "UniqueFactorizationDomain()"
"Field()" -> "DivisionRing()"

@
<<FIELD.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"Field()" [color=lightblue];
"Field()" -> "EuclideanDomain()"
"Field()" -> "UniqueFactorizationDomain()"
"Field()" -> "DIVRING..."

"EuclideanDomain()" [color=lightblue];
"EuclideanDomain()" -> "PrincipalIdealDomain()"

"UniqueFactorizationDomain()" [color=lightblue];
"UniqueFactorizationDomain()" -> "GCDDOM..."

"PrincipalIdealDomain()" [color=lightblue];
"PrincipalIdealDomain()" -> "GCDDOM..."

"DIVRING..." [color=lightblue];
"GCDDOM..." [color=lightblue];
}

@
\chapter{Category Layer 17}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FiniteRankAlgebra}{FINRALG}
\pagepic{ps/v102finiterankalgebra.ps}{FINRALG}{0.45}

{\bf See:}\\
\pageto{FramedAlgebra}{FRAMALG}
\pagefrom{Algebra}{ALGEBRA}
\pagefrom{CharacteristicNonZero}{CHARNZ}
\pagefrom{CharacteristicZero}{CHARZ}
\pagefrom{Field}{FIELD}

{\bf Exports:}\\
\begin{tabular}{lll}
\cross{FINRALG}{0} &
\cross{FINRALG}{1} &
\cross{FINRALG}{characteristic} \\
\cross{FINRALG}{characteristicPolynomial} &
\cross{FINRALG}{charthRoot} &
\cross{FINRALG}{coerce} \\
\cross{FINRALG}{coordinates} &
\cross{FINRALG}{discriminant} &
\cross{FINRALG}{hash} \\
\cross{FINRALG}{latex} &
\cross{FINRALG}{minimalPolynomial} &
\cross{FINRALG}{norm} \\
\cross{FINRALG}{one?} &
\cross{FINRALG}{rank} &
\cross{FINRALG}{recip} \\
\cross{FINRALG}{regularRepresentation} &
\cross{FINRALG}{represents} &
\cross{FINRALG}{sample} \\
\cross{FINRALG}{subtractIfCan} &
\cross{FINRALG}{trace} &
\cross{FINRALG}{traceMatrix} \\
\cross{FINRALG}{zero?} &
\cross{FINRALG}{?*?} &
\cross{FINRALG}{?**?} \\
\cross{FINRALG}{?+?} &
\cross{FINRALG}{?-?} &
\cross{FINRALG}{-?} \\
\cross{FINRALG}{?=?} &
\cross{FINRALG}{?\^{}?} &
\cross{FINRALG}{?\~{}=?} \\
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 characteristicPolynomial : % -> UP
 coordinates : (%,Vector %) -> Vector R
 minimalPolynomial : % -> UP if R has FIELD
 norm : % -> R
 rank : () -> PositiveInteger
 trace : % -> R                       
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 coordinates : (Vector %,Vector %) -> Matrix R
 discriminant : Vector % -> R         
 regularRepresentation : (%,Vector %) -> Matrix R
 represents : (Vector R,Vector %) -> %
 traceMatrix : Vector % -> Matrix R
\end{verbatim}

These exports come from Algebra(R:CommutativeRing):
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 coerce : Integer -> %                
 coerce : % -> OutputForm
 hash : % -> SingleInteger
 latex : % -> String                  
 one? : % -> Boolean                  
 recip : % -> Union(%,"failed")       
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 zero? : % -> Boolean
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean              
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

These exports come from Field():
\begin{verbatim}
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
 coerce : R -> %
\end{verbatim}

These exports come from CharacteristicNonZero():
\begin{verbatim}
 charthRoot : % -> Union(%,"failed") if R has CHARNZ
\end{verbatim}

These exports come from CharacteristicZero():
\begin{verbatim}
\end{verbatim}

<<category FINRALG FiniteRankAlgebra>>=
)abbrev category FINRALG FiniteRankAlgebra
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A FiniteRankAlgebra is an algebra over a commutative ring R which
++ is a free R-module of finite rank.

FiniteRankAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 Category == Algebra R with
    rank                    : () -> PositiveInteger
      ++ rank() returns the rank of the algebra.
    regularRepresentation   : (% , Vector %) -> Matrix R
      ++ regularRepresentation(a,basis) returns the matrix of the
      ++ linear map defined by left multiplication by \spad{a} with respect
      ++ to the basis \spad{basis}.
    trace                   : %  -> R
      ++ trace(a) returns the trace of the regular representation
      ++ of \spad{a} with respect to any basis.
    norm                    : %  -> R
      ++ norm(a) returns the determinant of the regular representation
      ++ of \spad{a} with respect to any basis.
    coordinates             : (%, Vector %) -> Vector R
      ++ coordinates(a,basis) returns the coordinates of \spad{a} with
      ++ respect to the basis \spad{basis}.
    coordinates             : (Vector %, Vector %) -> Matrix R
      ++ coordinates([v1,...,vm], basis) returns the coordinates of the
      ++ vi's with to the basis \spad{basis}.  The coordinates of vi are
      ++ contained in the ith row of the matrix returned by this
      ++ function.
    represents              : (Vector R, Vector %) -> %
      ++ represents([a1,..,an],[v1,..,vn]) returns \spad{a1*v1+...+an*vn}.
    discriminant            : Vector % -> R
      ++ discriminant([v1,..,vn]) returns
      ++ \spad{determinant(traceMatrix([v1,..,vn]))}.
    traceMatrix             : Vector % -> Matrix R
      ++ traceMatrix([v1,..,vn]) is the n-by-n matrix ( Tr(vi * vj) )
    characteristicPolynomial: % -> UP
      ++ characteristicPolynomial(a) returns the characteristic
      ++ polynomial of the regular representation of \spad{a} with respect
      ++ to any basis.
    if R has Field then minimalPolynomial : % -> UP
      ++ minimalPolynomial(a) returns the minimal polynomial of \spad{a}.
    if R has CharacteristicZero then CharacteristicZero
    if R has CharacteristicNonZero then CharacteristicNonZero

  add

    discriminant v == determinant traceMatrix v

    coordinates(v:Vector %, b:Vector %) ==
      m := new(#v, #b, 0)$Matrix(R)
      for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
        setRow_!(m, j, coordinates(qelt(v, i), b))
      m

    represents(v, b) ==
      m := minIndex v - 1
      _+/[v(i+m) * b(i+m) for i in 1..rank()]

    traceMatrix v ==
      matrix [[trace(v.i*v.j) for j in minIndex v..maxIndex v]$List(R)
               for i in minIndex v .. maxIndex v]$List(List R)

    regularRepresentation(x, b) ==
      m := minIndex b - 1
      matrix
       [parts coordinates(x*b(i+m),b) for i in 1..rank()]$List(List R)

@
<<FINRALG.dotabb>>=
"FINRALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINRALG"];
"FINRALG" -> "ALGEBRA"
"FINRALG" -> "FIELD"
"FINRALG" -> "CHARNZ"
"FINRALG" -> "CHARZ"

@
<<FINRALG.dotfull>>=
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FINRALG"];
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Algebra(a:CommutativeRing)"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Field()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicNonZero()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicZero()"

@
<<FINRALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue];
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Algebra(a:CommutativeRing)"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Field()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicNonZero()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicZero()"

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "MODULE..."

"Field()" [color=lightblue];
"Field()" -> "EUCDOM..."
"Field()" -> "UFD..."
"Field()" -> "DIVRING..."

"CharacteristicNonZero()" [color=lightblue];
"CharacteristicNonZero()" -> "RING..."

"CharacteristicZero()" [color=lightblue];
"CharacteristicZero()" -> "RING..."

"EUCDOM..." [color=lightblue];
"UFD..." [color=lightblue];
"DIVRING..." [color=lightblue];
"RING..." [color=lightblue];
"MODULE..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{MonogenicAlgebra}{MONOGEN}
\pagepic{ps/v102monogenicalgebra.ps}{MONOGEN}{0.70}

{\bf See:}\\
\pageto{FunctionFieldCategory}{FFCAT}
\pagefrom{CommutativeRing}{COMRING}
\pagefrom{ConvertibleTo}{KONVERT}
\pagefrom{FramedAlgebra}{FRAMALG}
\pagefrom{FullyRetractableTo}{FRETRCT}
\pagefrom{LinearlyExplicitRingOver}{LINEXP}
<<category MONOGEN MonogenicAlgebra>>=
)abbrev category MONOGEN MonogenicAlgebra
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A \spadtype{MonogenicAlgebra} is an algebra of finite rank which
++ can be generated by a single element.

MonogenicAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 Category ==
    Join(FramedAlgebra(R, UP), CommutativeRing, ConvertibleTo UP,
              FullyRetractableTo R, FullyLinearlyExplicitRingOver R) with
      generator         : () -> %
        ++ generator() returns the generator for this domain.
      definingPolynomial: () -> UP
        ++ definingPolynomial() returns the minimal polynomial which
        ++ \spad{generator()} satisfies.
      reduce            : UP -> %
        ++ reduce(up) converts the univariate polynomial up to an algebra
        ++ element, reducing by the \spad{definingPolynomial()} if necessary.
      convert           : UP -> %
        ++ convert(up) converts the univariate polynomial up to an algebra
        ++ element, reducing by the \spad{definingPolynomial()} if necessary.
      lift              : % -> UP
        ++ lift(z) returns a minimal degree univariate polynomial up such that
        ++ \spad{z=reduce up}.
      if R has Finite then Finite
      if R has Field then
        Field
        DifferentialExtension R
        reduce               : Fraction UP -> Union(%, "failed")
          ++ reduce(frac) converts the fraction frac to an algebra element.
        derivationCoordinates: (Vector %, R -> R) -> Matrix R
          ++ derivationCoordinates(b, ') returns M such that \spad{b' = M b}.
      if R has FiniteFieldCategory then FiniteFieldCategory
  add
   convert(x:%):UP == lift x
   convert(p:UP):% == reduce p
   generator()     == reduce monomial(1, 1)$UP
   norm x          == resultant(definingPolynomial(), lift x)
   retract(x:%):R  == retract lift x
   retractIfCan(x:%):Union(R, "failed") == retractIfCan lift x

   basis() ==
     [reduce monomial(1,i)$UP for i in 0..(rank()-1)::NonNegativeInteger]

   characteristicPolynomial(x:%):UP ==
     characteristicPolynomial(x)$CharacteristicPolynomialInMonogenicalAlgebra(R,UP,%)

   if R has Finite then
     size()   == size()$R ** rank()
     random() == represents [random()$R for i in 1..rank()]$Vector(R)

   if R has Field then
     reduce(x:Fraction UP) == reduce(numer x) exquo reduce(denom x)

     differentiate(x:%, d:R -> R) ==
       p := definingPolynomial()
       yprime := - reduce(map(d, p)) / reduce(differentiate p)
       reduce(map(d, lift x)) + yprime * reduce differentiate lift x

     derivationCoordinates(b, d) ==
       coordinates(map(differentiate(#1, d), b), b)

     recip x ==
       (bc := extendedEuclidean(lift x, definingPolynomial(), 1))
                                                case "failed" => "failed"
       reduce(bc.coef1)

@
<<MONOGEN.dotabb>>=
"MONOGEN"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONOGEN"];
"MONOGEN" -> "FRAMALG"
"MONOGEN" -> "COMRING"
"MONOGEN" -> "KONVERT"
"MONOGEN" -> "FRETRCT"
"MONOGEN" -> "FLINEXP"

@
<<MONOGEN.dotfull>>=
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=MONOGEN"];
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CommutativeRing()"
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "ConvertibleTo(UnivariatePolynomialCategory(CommutativeRing))"
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FullyRetractableTo(a:CommutativeRing)"
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FullyLinearlyExplicitRingOver(a:CommutativeRing)"

"MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=MONOGEN"];
"MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))" ->
    "MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"

@
<<MONOGEN.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue];
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FRAMALG..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "COMRING..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "KONVERT..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FRETRCT..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FLINEXP..."

"FRAMALG..." [color=lightblue];
"COMRING..." [color=lightblue];
"KONVERT..." [color=lightblue];
"FRETRCT..." [color=lightblue];
"FLINEXP..." [color=lightblue];
}

@
\chapter{Category Layer 18}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FunctionFieldCategory}{FFCAT}
\pagepic{ps/v102functionfieldcategory.ps}{FFCAT}{0.70}

{\bf See:}\\
\pagefrom{MonogenicAlgebra}{MONOGEN}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FFCAT}{0} &
\cross{FFCAT}{1} \\
\cross{FFCAT}{absolutelyIrreducible?} &
\cross{FFCAT}{algSplitSimple} \\
\cross{FFCAT}{associates?} &
\cross{FFCAT}{basis} \\
\cross{FFCAT}{branchPoint?} &
\cross{FFCAT}{branchPointAtInfinity?} \\
\cross{FFCAT}{characteristic} &
\cross{FFCAT}{characteristicPolynomial} \\
\cross{FFCAT}{charthRoot} &
\cross{FFCAT}{coerce} \\
\cross{FFCAT}{complementaryBasis} &
\cross{FFCAT}{conditionP} \\
\cross{FFCAT}{convert} &
\cross{FFCAT}{coordinates} \\
\cross{FFCAT}{createPrimitiveElement} &
\cross{FFCAT}{D} \\
\cross{FFCAT}{definingPolynomial} &
\cross{FFCAT}{derivationCoordinates} \\
\cross{FFCAT}{differentiate} &
\cross{FFCAT}{discreteLog} \\
\cross{FFCAT}{discriminant} &
\cross{FFCAT}{divide} \\
\cross{FFCAT}{elliptic} &
\cross{FFCAT}{elt} \\
\cross{FFCAT}{euclideanSize} &
\cross{FFCAT}{expressIdealMember} \\
\cross{FFCAT}{exquo} &
\cross{FFCAT}{extendedEuclidean} \\
\cross{FFCAT}{factor} &
\cross{FFCAT}{factorsOfCyclicGroupSize} \\
\cross{FFCAT}{gcd} &
\cross{FFCAT}{gcdPolynomial} \\
\cross{FFCAT}{generator} &
\cross{FFCAT}{genus} \\
\cross{FFCAT}{hash} &
\cross{FFCAT}{hyperelliptic} \\
\cross{FFCAT}{index} &
\cross{FFCAT}{init} \\
\cross{FFCAT}{integral?} &
\cross{FFCAT}{integralAtInfinity?} \\
\cross{FFCAT}{integralBasis} &
\cross{FFCAT}{integralBasisAtInfinity} \\
\cross{FFCAT}{integralCoordinates} &
\cross{FFCAT}{integralDerivationMatrix} \\
\cross{FFCAT}{integralMatrix} &
\cross{FFCAT}{integralMatrixAtInfinity} \\
\cross{FFCAT}{integralRepresents} &
\cross{FFCAT}{inv} \\
\cross{FFCAT}{inverseIntegralMatrix} &
\cross{FFCAT}{inverseIntegralMatrixAtInfinity} \\
\cross{FFCAT}{latex} &
\cross{FFCAT}{lcm} \\
\cross{FFCAT}{lift} &
\cross{FFCAT}{lookup} \\
\cross{FFCAT}{minimalPolynomial} &
\cross{FFCAT}{multiEuclidean} \\
\cross{FFCAT}{nextItem} &
\cross{FFCAT}{nonSingularModel} \\
\cross{FFCAT}{norm} &
\cross{FFCAT}{normalizeAtInfinity} \\
\cross{FFCAT}{numberOfComponents} &
\cross{FFCAT}{one?} \\
\cross{FFCAT}{order} &
\cross{FFCAT}{prime?} \\
\cross{FFCAT}{primeFrobenius} &
\cross{FFCAT}{primitive?} \\
\cross{FFCAT}{primitiveElement} &
\cross{FFCAT}{primitivePart} \\
\cross{FFCAT}{principalIdeal} &
\cross{FFCAT}{ramified?} \\
\cross{FFCAT}{ramifiedAtInfinity?} &
\cross{FFCAT}{rank} \\
\cross{FFCAT}{random} &
\cross{FFCAT}{rationalPoints} \\
\cross{FFCAT}{rationalPoint?} &
\cross{FFCAT}{recip} \\
\cross{FFCAT}{reduce} &
\cross{FFCAT}{reduceBasisAtInfinity} \\
\cross{FFCAT}{reducedSystem} &
\cross{FFCAT}{regularRepresentation} \\
\cross{FFCAT}{representationType} &
\cross{FFCAT}{represents} \\
\cross{FFCAT}{retract} &
\cross{FFCAT}{retractIfCan} \\
\cross{FFCAT}{sample} &
\cross{FFCAT}{singular?} \\
\cross{FFCAT}{singularAtInfinity?} &
\cross{FFCAT}{size} \\
\cross{FFCAT}{sizeLess?} &
\cross{FFCAT}{squareFree} \\
\cross{FFCAT}{squareFreePart} &
\cross{FFCAT}{subtractIfCan} \\
\cross{FFCAT}{tableForDiscreteLogarithm} &
\cross{FFCAT}{trace} \\
\cross{FFCAT}{traceMatrix} &
\cross{FFCAT}{unit?} \\
\cross{FFCAT}{unitCanonical} &
\cross{FFCAT}{unitNormal} \\
\cross{FFCAT}{yCoordinates} &
\cross{FFCAT}{zero?} \\
\cross{FFCAT}{?*?} &
\cross{FFCAT}{?**?} \\
\cross{FFCAT}{?+?} &
\cross{FFCAT}{?-?} \\
\cross{FFCAT}{-?} &
\cross{FFCAT}{?=?} \\
\cross{FFCAT}{?\^{}?} &
\cross{FFCAT}{?\~{}=?} \\
\cross{FFCAT}{?/?} &
\cross{FFCAT}{?quo?} \\
\cross{FFCAT}{?rem?} &
\end{tabular}

TPDHERE:
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 associates? : (%,%) -> Boolean
     if Fraction UP has FIELD
 basis : () -> Vector %
 characteristic : () -> NonNegativeInteger
 characteristicPolynomial : % -> UPUP
 charthRoot : % -> Union(%,"failed")
     if Fraction UP has CHARNZ
 charthRoot : % -> %
     if Fraction UP has FFIELDC
 coerce : % -> %
     if Fraction UP has FIELD
 coerce : Fraction Integer -> %
     if Fraction UP has FIELD 
     or Fraction UP has RETRACT FRAC INT
 coerce : Fraction UP -> %            
 coerce : Integer -> %
 coerce : % -> OutputForm             
 conditionP : Matrix % -> Union(Vector %,"failed")
     if Fraction UP has FFIELDC
 convert : UPUP -> %
 convert : % -> UPUP                  
 convert : Vector Fraction UP -> %
 convert : % -> Vector Fraction UP    
 coordinates : Vector % -> Matrix Fraction UP
 coordinates : % -> Vector Fraction UP
 coordinates : (Vector %,Vector %) -> Matrix Fraction UP
 coordinates : (%,Vector %) -> Vector Fraction UP
 createPrimitiveElement : () -> %
     if Fraction UP has FFIELDC
 D : % -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,DifferentialRing)) 
      or 
        and(
          has(Fraction UP,DifferentialRing),
          has(Fraction UP,Field)) 
      or Fraction UP has FFIELDC
 D : (%,NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,DifferentialRing)) 
      or 
        and(
          has(Fraction UP,DifferentialRing),
          has(Fraction UP,Field)) 
      or Fraction UP has FFIELDC
 D : (%,Symbol) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol)) 
      or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 D : (%,List Symbol) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol)) 
      or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 D : (%,Symbol,NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol)) 
      or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 D : (%,List Symbol,List NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol)) 
      or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 D : (%,(Fraction UP -> Fraction UP)) -> %
     if Fraction UP has FIELD
 D : (%,(Fraction UP -> Fraction UP),NonNegativeInteger) -> %
     if Fraction UP has FIELD
 definingPolynomial : () -> UPUP
 derivationCoordinates : (Vector %,(Fraction UP -> Fraction UP))
   -> Matrix Fraction UP
     if Fraction UP has FIELD
 differentiate : % -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,DifferentialRing)) 
      or 
        and(
          has(Fraction UP,DifferentialRing),
          has(Fraction UP,Field)) 
      or Fraction UP has FFIELDC
 differentiate : (%,NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,DifferentialRing)) 
      or 
        and(
          has(Fraction UP,DifferentialRing),
          has(Fraction UP,Field))
      or Fraction UP has FFIELDC
 differentiate : (%,Symbol) -> %
     if 
       and(
         has(Fraction UP,Field),
         has(Fraction UP,PartialDifferentialRing Symbol)) 
     or 
      and(
        has(Fraction UP,PartialDifferentialRing Symbol),
        has(Fraction UP,Field))
 differentiate : (%,List Symbol) -> %
     if 
       and(
         has(Fraction UP,Field),
         has(Fraction UP,PartialDifferentialRing Symbol)) 
      or 
       and(
         has(Fraction UP,PartialDifferentialRing Symbol),
         has(Fraction UP,Field))
 differentiate : (%,Symbol,NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol))
      or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 differentiate : (%,List Symbol,List NonNegativeInteger) -> %
     if 
        and(
          has(Fraction UP,Field),
          has(Fraction UP,PartialDifferentialRing Symbol))
       or 
        and(
          has(Fraction UP,PartialDifferentialRing Symbol),
          has(Fraction UP,Field))
 differentiate : (%,(Fraction UP -> Fraction UP)) -> %
     if Fraction UP has FIELD
 differentiate :
   (%,(Fraction UP -> Fraction UP),NonNegativeInteger) -> %
     if Fraction UP has FIELD
 discreteLog : (%,%) -> Union(NonNegativeInteger,"failed")
     if Fraction UP has FFIELDC
 discreteLog : % -> NonNegativeInteger
     if Fraction UP has FFIELDC
 discriminant : Vector % -> Fraction UP
 discriminant : () -> Fraction UP     
 divide : (%,%) -> Record(quotient: %,remainder: %)
     if Fraction UP has FIELD
 euclideanSize : % -> NonNegativeInteger
     if Fraction UP has FIELD
 expressIdealMember : (List %,%) -> Union(List %,"failed")
     if Fraction UP has FIELD
 exquo : (%,%) -> Union(%,"failed")
     if Fraction UP has FIELD
 extendedEuclidean : (%,%) ->
    Record(coef1: %,coef2: %,generator: %)
     if Fraction UP has FIELD
 extendedEuclidean : (%,%,%) ->
    Union(Record(coef1: %,coef2: %),"failed")
     if Fraction UP has FIELD
 factor : % -> Factored %
     if Fraction UP has FIELD
 factorsOfCyclicGroupSize : () ->
    List Record(factor: Integer,exponent: Integer)
     if Fraction UP has FFIELDC
 gcd : (%,%) -> %
     if Fraction UP has FIELD
 gcd : List % -> %
     if Fraction UP has FIELD
 gcdPolynomial : (SparseUnivariatePolynomial %,
                  SparseUnivariatePolynomial %) ->
                     SparseUnivariatePolynomial %
     if Fraction UP has FIELD
 generator : () -> %                  
 hash : % -> SingleInteger            
 index : PositiveInteger -> %
     if Fraction UP has FINITE
 init : () -> %
     if Fraction UP has FFIELDC
 integralCoordinates : % ->
    Record(num: Vector UP,den: UP)
 integralDerivationMatrix : (UP -> UP) ->
    Record(num: Matrix UP,den: UP)
 integralMatrix : () -> Matrix Fraction UP
 integralMatrixAtInfinity : () -> Matrix Fraction UP
 integralRepresents : (Vector UP,UP) -> %
 inv : % -> %
     if Fraction UP has FIELD
 inverseIntegralMatrix : () -> Matrix Fraction UP
 inverseIntegralMatrixAtInfinity : () ->
    Matrix Fraction UP
 latex : % -> String
 lcm : (%,%) -> %
     if Fraction UP has FIELD
 lcm : List % -> %
     if Fraction UP has FIELD
 lift : % -> UPUP                     
 lookup : % -> PositiveInteger
     if Fraction UP has FINITE
 minimalPolynomial : % -> UPUP
     if Fraction UP has FIELD
 multiEuclidean : (List %,%) -> Union(List %,"failed")
     if Fraction UP has FIELD
 nextItem : % -> Union(%,"failed")
     if Fraction UP has FFIELDC
 nonSingularModel : Symbol -> List Polynomial F
     if F has FIELD
 norm : % -> Fraction UP
 one? : % -> Boolean                  
 order : % -> OnePointCompletion PositiveInteger
     if Fraction UP has FFIELDC
 order : % -> PositiveInteger
     if Fraction UP has FFIELDC
 prime? : % -> Boolean
     if Fraction UP has FIELD
 primeFrobenius : % -> %
     if Fraction UP has FFIELDC
 primeFrobenius : (%,NonNegativeInteger) -> %
     if Fraction UP has FFIELDC
 primitive? : % -> Boolean
     if Fraction UP has FFIELDC
 primitiveElement : () -> %
     if Fraction UP has FFIELDC
 principalIdeal : List % ->
   Record(coef: List %,generator: %)
     if Fraction UP has FIELD
 rank : () -> PositiveInteger         
 random : () -> %
     if Fraction UP has FINITE
 recip : % -> Union(%,"failed")       
 reduce : UPUP -> %
 reduce : Fraction UPUP -> Union(%,"failed")
     if Fraction UP has FIELD
 reducedSystem : Matrix % -> Matrix Fraction UP
 reducedSystem : (Matrix %,Vector %) ->
   Record(mat: Matrix Fraction UP,vec: Vector Fraction UP)
 reducedSystem : (Matrix %,Vector %) ->
   Record(mat: Matrix Integer,vec: Vector Integer)
     if Fraction UP has LINEXP INT
 reducedSystem : Matrix % -> Matrix Integer
     if Fraction UP has LINEXP INT
 regularRepresentation : % -> Matrix Fraction UP
 regularRepresentation : (%,Vector %) -> Matrix Fraction UP
 representationType : () ->
   Union("prime",polynomial,normal,cyclic)
     if Fraction UP has FFIELDC
 represents : Vector Fraction UP -> %
 represents : (Vector Fraction UP,Vector %) -> %
 retract : % -> Fraction Integer
     if Fraction UP has RETRACT FRAC INT
 retract : % -> Integer
     if Fraction UP has RETRACT INT
 retract : % -> Fraction UP
 retractIfCan : % -> Union(Fraction UP,"failed")
 retractIfCan : % -> Union(Fraction Integer,"failed")
     if Fraction UP has RETRACT FRAC INT
 retractIfCan : % -> Union(Integer,"failed")
     if Fraction UP has RETRACT INT
 sample : () -> %                     
 size : () -> NonNegativeInteger
     if Fraction UP has FINITE
 sizeLess? : (%,%) -> Boolean
     if Fraction UP has FIELD
 squareFree : % -> Factored %
     if Fraction UP has FIELD
 squareFreePart : % -> %
     if Fraction UP has FIELD
 subtractIfCan : (%,%) -> Union(%,"failed")
 tableForDiscreteLogarithm : Integer -> 
   Table(PositiveInteger,NonNegativeInteger)
     if Fraction UP has FFIELDC
 trace : % -> Fraction UP
 traceMatrix : () -> Matrix Fraction UP
 traceMatrix : Vector % -> Matrix Fraction UP
 unit? : % -> Boolean
     if Fraction UP has FIELD
 unitCanonical : % -> %
     if Fraction UP has FIELD
 unitNormal : % -> Record(unit: %,canonical: %,associate: %)
     if Fraction UP has FIELD
 zero? : % -> Boolean                 
 ?*? : (Fraction UP,%) -> %           
 ?*? : (%,Fraction UP) -> %
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?**? : (%,PositiveInteger) -> %
 ?+? : (%,%) -> %                     
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?=? : (%,%) -> Boolean
 ?^? : (%,PositiveInteger) -> %       
 ?~=? : (%,%) -> Boolean
 ?*? : (%,Fraction Integer) -> % if Fraction UP has FIELD
 ?*? : (Fraction Integer,%) -> % if Fraction UP has FIELD
 ?*? : (NonNegativeInteger,%) -> %
 ?**? : (%,Integer) -> % if Fraction UP has FIELD
 ?**? : (%,NonNegativeInteger) -> %
 ?/? : (%,%) -> % if Fraction UP has FIELD
 ?^? : (%,Integer) -> % if Fraction UP has FIELD
 ?^? : (%,NonNegativeInteger) -> %
 ?quo? : (%,%) -> % if Fraction UP has FIELD
 ?rem? : (%,%) -> % if Fraction UP has FIELD
\end{verbatim}

These are directly exported but not implemented:
\begin{verbatim}
 branchPointAtInfinity? : () -> Boolean
 branchPoint? : UP -> Boolean         
 branchPoint? : F -> Boolean
 integralBasis : () -> Vector %       
 integralBasisAtInfinity : () -> Vector %
 ramifiedAtInfinity? : () -> Boolean
 ramified? : UP -> Boolean            
 ramified? : F -> Boolean
 singularAtInfinity? : () -> Boolean
 singular? : F -> Boolean             
 singular? : UP -> Boolean
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 absolutelyIrreducible? : () -> Boolean
 algSplitSimple : (%,(UP -> UP)) ->
      Record(num: %,den: UP,derivden: UP,gd: UP)
 complementaryBasis : Vector % -> Vector %
 differentiate : (%,(UP -> UP)) -> %
 elliptic : () -> Union(UP,"failed")
 elt : (%,F,F) -> F
 genus : () -> NonNegativeInteger
 hyperelliptic : () -> Union(UP,"failed")
 integral? : % -> Boolean
 integral? : (%,F) -> Boolean         
 integral? : (%,UP) -> Boolean
 integralAtInfinity? : % -> Boolean
 normalizeAtInfinity : Vector % -> Vector %
 numberOfComponents : () -> NonNegativeInteger
 primitivePart : % -> %
 rationalPoint? : (F,F) -> Boolean
 rationalPoints : () -> List List F if F has FINITE
 reduceBasisAtInfinity : Vector % -> Vector %
 represents : (Vector UP,UP) -> %     
 yCoordinates : % -> Record(num: Vector UP,den: UP)
\end{verbatim}

These exports come from Aggregate:
\begin{verbatim}
\end{verbatim}

These exports come from Evalable(a:Type):
\begin{verbatim}
\end{verbatim}

These exports come from SetCategory:
\begin{verbatim}
\end{verbatim}

<<category FFCAT FunctionFieldCategory>>=
)abbrev category FFCAT FunctionFieldCategory
++ Function field of a curve
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 19 Mai 1993
++ Description: This category is a model for the function field of a
++ plane algebraic curve.
++ Keywords: algebraic, curve, function, field.
FunctionFieldCategory(F, UP, UPUP): Category == Definition where
  F   : UniqueFactorizationDomain
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP

  Z   ==> Integer
  Q   ==> Fraction F
  P   ==> Polynomial F
  RF  ==> Fraction UP
  QF  ==> Fraction UPUP
  SY  ==> Symbol
  REC ==> Record(num:$, den:UP, derivden:UP, gd:UP)

  Definition ==> MonogenicAlgebra(RF, UPUP) with
    numberOfComponents     : () -> NonNegativeInteger
      ++ numberOfComponents() returns the number of absolutely irreducible
      ++ components.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X numberOfComponents()$R
    genus                  : () -> NonNegativeInteger
      ++ genus() returns the genus of one absolutely irreducible component
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X genus()$R
    absolutelyIrreducible? : () -> Boolean
      ++ absolutelyIrreducible?() tests if the curve absolutely irreducible?
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
      ++X absolutelyIrreducible?()$R2
    rationalPoint?         : (F, F) -> Boolean
      ++ rationalPoint?(a, b) tests if \spad{(x=a,y=b)} is on the curve.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X rationalPoint?(0,0)$R
      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
      ++X rationalPoint?(0,0)$R2
    branchPointAtInfinity? : () -> Boolean
      ++ branchPointAtInfinity?() tests if there is a branch point 
      ++ at infinity.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X branchPointAtInfinity?()$R
      ++X R2 := RadicalFunctionField(INT, P0, P1, 2 * x**2, 4)
      ++X branchPointAtInfinity?()$R
    branchPoint?           : F -> Boolean
      ++ branchPoint?(a) tests whether \spad{x = a} is a branch point.
    branchPoint?           : UP -> Boolean
      ++ branchPoint?(p) tests whether \spad{p(x) = 0} is a branch point.
    singularAtInfinity?    : () -> Boolean
      ++ singularAtInfinity?() tests if there is a singularity at infinity.
    singular?              : F -> Boolean
      ++ singular?(a) tests whether \spad{x = a} is singular.
    singular?              : UP -> Boolean
      ++ singular?(p) tests whether \spad{p(x) = 0} is singular.
    ramifiedAtInfinity?    : () -> Boolean
      ++ ramifiedAtInfinity?() tests if infinity is ramified.
    ramified?              : F -> Boolean
      ++ ramified?(a) tests whether \spad{x = a} is ramified.
    ramified?              : UP -> Boolean
      ++ ramified?(p) tests whether \spad{p(x) = 0} is ramified.
    integralBasis          : () -> Vector $
      ++ integralBasis() returns the integral basis for the curve.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X integralBasis()$R
    integralBasisAtInfinity: () -> Vector $
      ++ integralBasisAtInfinity() returns the local integral basis 
      ++ at infinity
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X integralBasisAtInfinity()$R
    integralAtInfinity?    : $  -> Boolean
      ++ integralAtInfinity?() tests if f is locally integral at infinity.
    integral?              : $  -> Boolean
      ++ integral?() tests if f is integral over \spad{k[x]}.
    complementaryBasis     : Vector $ -> Vector $
      ++ complementaryBasis(b1,...,bn) returns the complementary basis
      ++ \spad{(b1',...,bn')} of \spad{(b1,...,bn)}.
    normalizeAtInfinity    : Vector $ -> Vector $
      ++ normalizeAtInfinity(v) makes v normal at infinity.
    reduceBasisAtInfinity  : Vector $ -> Vector $
      ++ reduceBasisAtInfinity(b1,...,bn) returns \spad{(x**i * bj)}
      ++ for all i,j such that \spad{x**i*bj} is locally integral 
      ++ at infinity.
    integralMatrix         : () -> Matrix RF
      ++ integralMatrix() returns M such that
      ++ \spad{(w1,...,wn) = M (1, y, ..., y**(n-1))},
      ++ where \spad{(w1,...,wn)} is the integral basis of
      ++ \spadfunFrom{integralBasis}{FunctionFieldCategory}.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X integralMatrix()$R
    inverseIntegralMatrix  : () -> Matrix RF
      ++ inverseIntegralMatrix() returns M such that
      ++ \spad{M (w1,...,wn) = (1, y, ..., y**(n-1))}
      ++ where \spad{(w1,...,wn)} is the integral basis of
      ++ \spadfunFrom{integralBasis}{FunctionFieldCategory}.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X inverseIntegralMatrix()$R
    integralMatrixAtInfinity       : () -> Matrix RF
      ++ integralMatrixAtInfinity() returns M such that
      ++ \spad{(v1,...,vn) = M (1, y, ..., y**(n-1))}
      ++ where \spad{(v1,...,vn)} is the local integral basis at infinity
      ++ returned by \spad{infIntBasis()}.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X integralMatrixAtInfinity()$R
    inverseIntegralMatrixAtInfinity: () -> Matrix RF
      ++ inverseIntegralMatrixAtInfinity() returns M such
      ++ that \spad{M (v1,...,vn) = (1, y, ..., y**(n-1))}
      ++ where \spad{(v1,...,vn)} is the local integral basis at infinity
      ++ returned by \spad{infIntBasis()}.
      ++
      ++X P0 := UnivariatePolynomial(x, Integer)
      ++X P1 := UnivariatePolynomial(y, Fraction P0)
      ++X R := RadicalFunctionField(INT, P0, P1, 1 - x**20, 20)
      ++X inverseIntegralMatrixAtInfinity()$R
    yCoordinates           : $ -> Record(num:Vector(UP), den:UP)
      ++ yCoordinates(f) returns \spad{[[A1,...,An], D]} such that
      ++ \spad{f = (A1 + A2 y +...+ An y**(n-1)) / D}.
    represents             : (Vector UP, UP) -> $
      ++ represents([A0,...,A(n-1)],D) returns
      ++ \spad{(A0 + A1 y +...+ A(n-1)*y**(n-1))/D}.
    integralCoordinates    : $ -> Record(num:Vector(UP), den:UP)
      ++ integralCoordinates(f) returns \spad{[[A1,...,An], D]} such that
      ++ \spad{f = (A1 w1 +...+ An wn) / D}  where \spad{(w1,...,wn)} is the
      ++ integral basis returned by \spad{integralBasis()}.
    integralRepresents     : (Vector UP, UP) -> $
      ++ integralRepresents([A1,...,An], D) returns
      ++ \spad{(A1 w1+...+An wn)/D}
      ++ where \spad{(w1,...,wn)} is the integral
      ++ basis of \spad{integralBasis()}.
    integralDerivationMatrix:(UP -> UP) -> Record(num:Matrix(UP),den:UP)
      ++ integralDerivationMatrix(d) extends the derivation d from UP to $
      ++ and returns (M, Q) such that the i^th row of M divided by Q form
      ++ the coordinates of \spad{d(wi)} with respect to \spad{(w1,...,wn)}
      ++ where \spad{(w1,...,wn)} is the integral basis returned
      ++ by integralBasis().
    integral?              : ($,  F) -> Boolean
      ++ integral?(f, a) tests whether f is locally integral at \spad{x = a}.
    integral?              : ($, UP) -> Boolean
      ++ integral?(f, p) tests whether f is locally integral at 
      ++ \spad{p(x) = 0}
    differentiate          : ($, UP -> UP) -> $
      ++ differentiate(x, d) extends the derivation d from UP to $ and
      ++ applies it to x.
    represents             : (Vector UP, UP) -> $
      ++ represents([A0,...,A(n-1)],D) returns
      ++ \spad{(A0 + A1 y +...+ A(n-1)*y**(n-1))/D}.
    primitivePart          : $ -> $
      ++ primitivePart(f) removes the content of the denominator and
      ++ the common content of the numerator of f.
    elt                    : ($, F, F) -> F
      ++ elt(f,a,b) or f(a, b) returns the value of f 
      ++ at the point \spad{(x = a, y = b)}
      ++ if it is not singular.
    elliptic               : () -> Union(UP, "failed")
      ++ elliptic() returns \spad{p(x)} if the curve is the elliptic
      ++ defined by \spad{y**2 = p(x)}, "failed" otherwise.
    hyperelliptic          : () -> Union(UP, "failed")
      ++ hyperelliptic() returns \spad{p(x)} if the curve is the 
      ++ hyperelliptic
      ++ defined by \spad{y**2 = p(x)}, "failed" otherwise.
    algSplitSimple         : ($, UP -> UP) -> REC
      ++ algSplitSimple(f, D) returns \spad{[h,d,d',g]} such that 
      ++ \spad{f=h/d},
      ++ \spad{h} is integral at all the normal places w.r.t. \spad{D},
      ++ \spad{d' = Dd}, \spad{g = gcd(d, discriminant())} and \spad{D}
      ++ is the derivation to use. \spad{f} must have at most simple finite
      ++ poles.
    if F has Field then
      nonSingularModel: SY -> List Polynomial F
        ++ nonSingularModel(u) returns the equations in u1,...,un of
        ++ an affine non-singular model for the curve.
    if F has Finite then
      rationalPoints: () -> List List F
        ++ rationalPoints() returns the list of all the affine 
        ++rational points.
   add
    import InnerCommonDenominator(UP, RF, Vector UP, Vector RF)
    import UnivariatePolynomialCommonDenominator(UP, RF, UPUP)

    repOrder: (Matrix RF, Z) -> Z
    Q2RF    : Q  -> RF
    infOrder: RF -> Z
    infValue: RF -> Fraction F
    intvalue: (Vector UP, F, F) -> F
    rfmonom : Z  -> RF
    kmin    : (Matrix RF,Vector Q) -> Union(Record(pos:Z,km:Z),"failed")

    Q2RF q                 == numer(q)::UP / denom(q)::UP
    infOrder f             == (degree denom f)::Z - (degree numer f)::Z
    integral? f            == ground?(integralCoordinates(f).den)
    integral?(f:$, a:F)    == (integralCoordinates(f).den)(a) ^= 0
--    absolutelyIrreducible? == one? numberOfComponents()
    absolutelyIrreducible? == numberOfComponents() = 1
    yCoordinates f         == splitDenominator coordinates f

    hyperelliptic() ==
      degree(f := definingPolynomial()) ^= 2 => "failed"
      (u:=retractIfCan(reductum f)@Union(RF,"failed"))
        case "failed" => "failed"
      (v:=retractIfCan(-(u::RF) / leadingCoefficient f)@Union(UP, "failed"))
        case "failed" => "failed"
      odd? degree(p := v::UP) => p
      "failed"

    algSplitSimple(f, derivation) ==
      cd := splitDenominator lift f
      dd := (cd.den exquo (g := gcd(cd.den, derivation(cd.den))))::UP
      [reduce(inv(g::RF) * cd.num), dd, derivation dd,
                                    gcd(dd, retract(discriminant())@UP)]

    elliptic() ==
      (u := hyperelliptic()) case "failed" => "failed"
      degree(p := u::UP) = 3 => p
      "failed"

    rationalPoint?(x, y)   ==
      zero?((definingPolynomial() (y::UP::RF)) (x::UP::RF))

    if F has Field then
      import PolyGroebner(F)
      import MatrixCommonDenominator(UP, RF)

      UP2P  : (UP,   P)    -> P
      UPUP2P: (UPUP, P, P) -> P

      UP2P(p, x) ==
        (map(#1::P, p)$UnivariatePolynomialCategoryFunctions2(F, UP,
                                     P, SparseUnivariatePolynomial P)) x

      UPUP2P(p, x, y) ==
        (map(UP2P(retract(#1)@UP, x),
             p)$UnivariatePolynomialCategoryFunctions2(RF, UPUP,
                                     P, SparseUnivariatePolynomial P)) y

      nonSingularModel u ==
        d    := commonDenominator(coordinates(w := integralBasis()))::RF
        vars := [concat(string u, string i)::SY for i in 1..(n := #w)]
        x    := "%%dummy1"::SY
        y    := "%%dummy2"::SY
        select_!(zero?(degree(#1, x)) and zero?(degree(#1, y)),
                 lexGroebner([v::P - UPUP2P(lift(d * w.i), x::P, y::P)
                    for v in vars for i in 1..n], concat([x, y], vars)))

    if F has Finite then
      ispoint: (UPUP, F, F) -> List F

-- must use the 'elt function explicitely or the compiler takes 45 mins
-- on that function    MB 5/90
-- still takes ages : I split the expression up. JHD 6/Aug/90
      ispoint(p, x, y) ==
        jhd:RF:=p(y::UP::RF)
        zero?(jhd (x::UP::RF)) => [x, y]
        empty()

      rationalPoints() ==
        p := definingPolynomial()
        concat [[pt for y in 1..size()$F | not empty?(pt :=
          ispoint(p, index(x::PositiveInteger)$F,
                     index(y::PositiveInteger)$F))]$List(List F)
                                for x in 1..size()$F]$List(List(List F))

    intvalue(v, x, y) ==
      singular? x => error "Point is singular"
      mini := minIndex(w := integralBasis())
      rec := yCoordinates(+/[qelt(v, i)::RF * qelt(w, i)
                           for i in mini .. maxIndex w])
      n   := +/[(qelt(rec.num, i) x) *
                (y ** ((i - mini)::NonNegativeInteger))
                           for i in mini .. maxIndex w]
      zero?(d := (rec.den) x) =>
        zero? n => error "0/0 -- cannot compute value yet"
        error "Shouldn't happen"
      (n exquo d)::F

    elt(f, x, y) ==
      rec := integralCoordinates f
      n   := intvalue(rec.num, x, y)
      zero?(d := (rec.den) x) =>
        zero? n => error "0/0 -- cannot compute value yet"
        error "Function has a pole at the given point"
      (n exquo d)::F

    primitivePart f ==
      cd := yCoordinates f
      d  := gcd([content qelt(cd.num, i)
                 for i in minIndex(cd.num) .. maxIndex(cd.num)]$List(F))
                   * primitivePart(cd.den)
      represents [qelt(cd.num, i) / d
               for i in minIndex(cd.num) .. maxIndex(cd.num)]$Vector(RF)

    reduceBasisAtInfinity b ==
      x := monomial(1, 1)$UP ::RF
      concat([[f for j in 0.. while
                integralAtInfinity?(f := x**j * qelt(b, i))]$Vector($)
                      for i in minIndex b .. maxIndex b]$List(Vector $))

    complementaryBasis b ==
      m := inverse(traceMatrix b)::Matrix(RF)
      [represents row(m, i) for i in minRowIndex m .. maxRowIndex m]

    integralAtInfinity? f ==
      not any?(infOrder(#1) < 0,
         coordinates(f) * inverseIntegralMatrixAtInfinity())$Vector(RF)

    numberOfComponents() ==
      count(integralAtInfinity?, integralBasis())$Vector($)

    represents(v:Vector UP, d:UP) ==
      represents
        [qelt(v, i) / d for i in minIndex v .. maxIndex v]$Vector(RF)

    genus() ==
      ds := discriminant()
      d  := degree(retract(ds)@UP) + infOrder(ds * determinant(
             integralMatrixAtInfinity() * inverseIntegralMatrix()) ** 2)
      dd := (((d exquo 2)::Z - rank()) exquo numberOfComponents())::Z
      (dd + 1)::NonNegativeInteger

    repOrder(m, i) ==
      nostart:Boolean := true
      ans:Z := 0
      r := row(m, i)
      for j in minIndex r .. maxIndex r | qelt(r, j) ^= 0 repeat
        ans :=
          nostart => (nostart := false; infOrder qelt(r, j))
          min(ans, infOrder qelt(r,j))
      nostart => error "Null row"
      ans

    infValue f ==
      zero? f => 0
      (n := infOrder f) > 0 => 0
      zero? n =>
        (leadingCoefficient numer f) / (leadingCoefficient denom f)
      error "f not locally integral at infinity"

    rfmonom n ==
      n < 0 => inv(monomial(1, (-n)::NonNegativeInteger)$UP :: RF)
      monomial(1, n::NonNegativeInteger)$UP :: RF

    kmin(m, v) ==
      nostart:Boolean := true
      k:Z := 0
      ii  := minRowIndex m - (i0  := minIndex v)
      for i in minIndex v .. maxIndex v | qelt(v, i) ^= 0 repeat
        nk := repOrder(m, i + ii)
        if nostart then (nostart := false; k := nk; i0 := i)
        else
          if nk < k then (k := nk; i0 := i)
      nostart => "failed"
      [i0, k]

    normalizeAtInfinity w ==
      ans   := copy w
      infm  := inverseIntegralMatrixAtInfinity()
      mhat  := zero(rank(), rank())$Matrix(RF)
      ii    := minIndex w - minRowIndex mhat
      repeat
        m := coordinates(ans) * infm
        r := [rfmonom repOrder(m, i)
                     for i in minRowIndex m .. maxRowIndex m]$Vector(RF)
        for i in minRowIndex m .. maxRowIndex m repeat
          for j in minColIndex m .. maxColIndex m repeat
            qsetelt_!(mhat, i, j, qelt(r, i + ii) * qelt(m, i, j))
        sol := first nullSpace transpose map(infValue,
                mhat)$MatrixCategoryFunctions2(RF, Vector RF, Vector RF,
                             Matrix RF, Q, Vector Q, Vector Q, Matrix Q)
        (pr := kmin(m, sol)) case "failed" => return ans
        qsetelt_!(ans, pr.pos,
         +/[Q2RF(qelt(sol, i)) * rfmonom(repOrder(m, i - ii) - pr.km)
                  * qelt(ans, i) for i in minIndex sol .. maxIndex sol])

    integral?(f:$, p:UP) ==
      (r:=retractIfCan(p)@Union(F,"failed")) case F => integral?(f,r::F)
      (integralCoordinates(f).den exquo p) case "failed"

    differentiate(f:$, d:UP -> UP) ==
      differentiate(f, differentiate(#1, d)$RF)

@
<<FFCAT.dotabb>>=
"FFCAT"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FFCAT"];
"FFCAT" -> "MONOGEN"

@
<<FFCAT.dotfull>>=
"FunctionFieldCategory(a:UFD,b:UPOLYC(a),c:UPOLYC(Fraction(b)))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FFCAT"];
"FunctionFieldCategory(a:UFD,b:UPOLYC(a),c:UPOLYC(Fraction(b)))"
   -> "MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"

@
<<FFCAT.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FunctionFieldCategory(a:UFD,b:UPOLYC(a),c:UPOLYC(Fraction(b)))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FFCAT"];
"FunctionFieldCategory(a:UFD,b:UPOLYC(a),c:UPOLYC(Fraction(b)))"
   -> "MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"

"MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))"
 [color=seagreen,href="bookvol10.2.pdf#nameddest=MONOGEN"];
"MonogenicAlgebra(a:FRAC(UPOLYC(UFD)),b:UPOLYC(FRAC(UPOLYC(UFD))))" ->
    "MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"

"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue];
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FRAMALG..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "COMRING..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "KONVERT..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FRETRCT..."
"MonogenicAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "FLINEXP..."

"FRAMALG..." [color=lightblue];
"COMRING..." [color=lightblue];
"KONVERT..." [color=lightblue];
"FRETRCT..." [color=lightblue];
"FLINEXP..." [color=lightblue];
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagehead{FramedAlgebra}{FRAMALG}
\pagepic{ps/v102framedalgebra.ps}{FRAMALG}{0.45}

{\bf See:}\\
\pageto{MonogenicAlgebra}{MONOGEN}
\pagefrom{FiniteRankAlgebra}{FINRALG}

{\bf Exports:}\\
\begin{tabular}{lllll}
\cross{FRAMALG}{0} &
\cross{FRAMALG}{1} &
\cross{FRAMALG}{basis} \\
\cross{FRAMALG}{characteristic} &
\cross{FRAMALG}{characteristicPolynomial} &
\cross{FRAMALG}{charthRoot} \\
\cross{FRAMALG}{coerce} &
\cross{FRAMALG}{convert} &
\cross{FRAMALG}{coordinates} \\
\cross{FRAMALG}{discriminant} &
\cross{FRAMALG}{hash} &
\cross{FRAMALG}{latex} \\
\cross{FRAMALG}{minimalPolynomial} &
\cross{FRAMALG}{norm} &
\cross{FRAMALG}{one?} \\
\cross{FRAMALG}{rank} &
\cross{FRAMALG}{recip} &
\cross{FRAMALG}{regularRepresentation} \\
\cross{FRAMALG}{represents} &
\cross{FRAMALG}{sample} &
\cross{FRAMALG}{subtractIfCan} \\
\cross{FRAMALG}{trace} &
\cross{FRAMALG}{traceMatrix} &
\cross{FRAMALG}{zero?} \\
\cross{FRAMALG}{?*?} &
\cross{FRAMALG}{?**?} &
\cross{FRAMALG}{?+?} \\
\cross{FRAMALG}{?-?} &
\cross{FRAMALG}{-?} &
\cross{FRAMALG}{?=?} \\
\cross{FRAMALG}{?\^{}?} &
\cross{FRAMALG}{?\~{}=?} &
\end{tabular}

These are directly exported but not implemented:
\begin{verbatim}
 basis : () -> Vector %
 represents : Vector R -> %           
\end{verbatim}

These are implemented by this category:
\begin{verbatim}
 convert : Vector R -> %
 convert : % -> Vector R              
 coordinates : Vector % -> Matrix R
 coordinates : % -> Vector R
 discriminant : () -> R               
 regularRepresentation : % -> Matrix R
 traceMatrix : () -> Matrix R
\end{verbatim}

These exports come from FiniteRankAlgebra(R, UP)\\
where R:CommutativeRing and UP:UnivariatePolynomialCategory R):
\begin{verbatim}
 0 : () -> %
 1 : () -> %                          
 characteristic : () -> NonNegativeInteger
 characteristicPolynomial : % -> UP
 charthRoot : % -> Union(%,"failed") if R has CHARNZ
 coerce : R -> %                      
 coerce : Integer -> %
 coerce : % -> OutputForm             
 coordinates : (%,Vector %) -> Vector R
 coordinates : (Vector %,Vector %) -> Matrix R
 discriminant : Vector % -> R
 hash : % -> SingleInteger            
 latex : % -> String
 minimalPolynomial : % -> UP if R has FIELD
 norm : % -> R                        
 one? : % -> Boolean
 rank : () -> PositiveInteger         
 recip : % -> Union(%,"failed")
 regularRepresentation : (%,Vector %) -> Matrix R
 represents : (Vector R,Vector %) -> %
 sample : () -> %
 subtractIfCan : (%,%) -> Union(%,"failed")
 trace : % -> R                       
 traceMatrix : Vector % -> Matrix R
 zero? : % -> Boolean                 
 ?+? : (%,%) -> %                     
 ?=? : (%,%) -> Boolean
 ?~=? : (%,%) -> Boolean
 ?*? : (%,%) -> %                     
 ?*? : (Integer,%) -> %
 ?*? : (PositiveInteger,%) -> %       
 ?*? : (NonNegativeInteger,%) -> %
 ?*? : (R,%) -> %                     
 ?*? : (%,R) -> %
 ?-? : (%,%) -> %
 -? : % -> %                          
 ?**? : (%,PositiveInteger) -> %
 ?**? : (%,NonNegativeInteger) -> %
 ?^? : (%,PositiveInteger) -> %       
 ?^? : (%,NonNegativeInteger) -> %
\end{verbatim}

<<category FRAMALG FramedAlgebra>>=
)abbrev category FRAMALG FramedAlgebra
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ A \spadtype{FramedAlgebra} is a \spadtype{FiniteRankAlgebra} together
++ with a fixed R-module basis.

FramedAlgebra(R:CommutativeRing, UP:UnivariatePolynomialCategory R):
 Category == FiniteRankAlgebra(R, UP) with
      basis                 : () -> Vector %
        ++ basis() returns the fixed R-module basis.
      coordinates           : % -> Vector R
        ++ coordinates(a) returns the coordinates of \spad{a} with 
        ++ respect to the fixed R-module basis.
      coordinates           : Vector % -> Matrix R
        ++ coordinates([v1,...,vm]) returns the coordinates of the
        ++ vi's with to the fixed basis.  The coordinates of vi are
        ++ contained in the ith row of the matrix returned by this
        ++ function.
      represents            : Vector R -> %
        ++ represents([a1,..,an]) returns \spad{a1*v1 + ... + an*vn}, where
        ++ v1, ..., vn are the elements of the fixed basis.
      convert               : % -> Vector R
        ++ convert(a) returns the coordinates of \spad{a} with respect to the
        ++ fixed R-module basis.
      convert               : Vector R -> %
        ++ convert([a1,..,an]) returns \spad{a1*v1 + ... + an*vn}, where
        ++ v1, ..., vn are the elements of the fixed basis.
      traceMatrix           : () -> Matrix R
        ++ traceMatrix() is the n-by-n matrix ( \spad{Tr(vi * vj)} ), where
        ++ v1, ..., vn are the elements of the fixed basis.
      discriminant          : () -> R
        ++ discriminant() = determinant(traceMatrix()).
      regularRepresentation : % -> Matrix R
        ++ regularRepresentation(a) returns the matrix of the linear
        ++ map defined by left multiplication by \spad{a} with respect
        ++ to the fixed basis.
    --attributes
      --separable <=> discriminant() ^= 0
  add
   convert(x:%):Vector(R)  == coordinates(x)
   convert(v:Vector R):%   == represents(v)
   traceMatrix()           == traceMatrix basis()
   discriminant()          == discriminant basis()
   regularRepresentation x == regularRepresentation(x, basis())
   coordinates x           == coordinates(x, basis())
   represents x            == represents(x, basis())

   coordinates(v:Vector %) ==
     m := new(#v, rank(), 0)$Matrix(R)
     for i in minIndex v .. maxIndex v for j in minRowIndex m .. repeat
       setRow_!(m, j, coordinates qelt(v, i))
     m

   regularRepresentation x ==
     m := new(n := rank(), n, 0)$Matrix(R)
     b := basis()
     for i in minIndex b .. maxIndex b for j in minRowIndex m .. repeat
       setRow_!(m, j, coordinates(x * qelt(b, i)))
     m

   characteristicPolynomial x ==
      mat00 := (regularRepresentation x)
      mat0 := map(#1 :: UP,mat00)$MatrixCategoryFunctions2(R, Vector R,
                  Vector R, Matrix R, UP, Vector UP,Vector UP, Matrix UP)
      mat1 : Matrix UP := scalarMatrix(rank(),monomial(1,1)$UP)
      determinant(mat1 - mat0)

   if R has Field then
    -- depends on the ordering of results from nullSpace, also see FFP
      minimalPolynomial(x:%):UP ==
        y:%:=1
        n:=rank()
        m:Matrix R:=zero(n,n+1)
        for i in 1..n+1 repeat
          setColumn_!(m,i,coordinates(y))
          y:=y*x
        v:=first nullSpace(m)
        +/[monomial(v.(i+1),i) for i in 0..#v-1]

@
<<FRAMALG.dotabb>>=
"FRAMALG"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRAMALG"];
"FRAMALG" -> "FINRALG"

@
<<FRAMALG.dotfull>>=
"FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue,href="bookvol10.2.pdf#nameddest=FRAMALG"];
"FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
   "FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"

@
<<FRAMALG.dotpic>>=
digraph pic {
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

"FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue];
"FramedAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
   "FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"

"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))"
 [color=lightblue];
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Algebra(a:CommutativeRing)"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "Field()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicNonZero()"
"FiniteRankAlgebra(a:CommutativeRing,b:UnivariatePolynomialCategory(a))" ->
    "CharacteristicZero()"

"Algebra(a:CommutativeRing)" [color=lightblue];
"Algebra(a:CommutativeRing)" -> "RING..."
"Algebra(a:CommutativeRing)" -> "MODULE..."

"Field()" [color=lightblue];
"Field()" -> "EUCDOM..."
"Field()" -> "UFD..."
"Field()" -> "DIVRING..."

"CharacteristicNonZero()" [color=lightblue];
"CharacteristicNonZero()" -> "RING..."

"CharacteristicZero()" [color=lightblue];
"CharacteristicZero()" -> "RING..."

"EUCDOM..." [color=lightblue];
"UFD..." [color=lightblue];
"DIVRING..." [color=lightblue];
"RING..." [color=lightblue];
"MODULE..." [color=lightblue];
}

@
\chapter{The bootstrap code}
\section{ABELGRP.lsp BOOTSTRAP} 
{\bf ABELGRP} depends on a chain of
files. We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf ABELGRP} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf ABELGRP.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<ABELGRP.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |AbelianGroup;AL| (QUOTE NIL)) 

(DEFUN |AbelianGroup| NIL 
  (LET (#:G82664) 
    (COND 
      (|AbelianGroup;AL|) 
      (T (SETQ |AbelianGroup;AL| (|AbelianGroup;|)))))) 

(DEFUN |AbelianGroup;| NIL 
  (PROG (#1=#:G82662) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|CancellationAbelianMonoid|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|-| (|$| |$|)) T)
                ((|-| (|$| |$| |$|)) T)
                ((|*| (|$| (|Integer|) |$|)) T)))
              NIL
              (QUOTE ((|Integer|)))
              NIL))
          |AbelianGroup|)
        (SETELT #1# 0 (QUOTE (|AbelianGroup|))))))) 

(MAKEPROP (QUOTE |AbelianGroup|) (QUOTE NILADIC) T) 

@
\section{ABELGRP-.lsp BOOTSTRAP}
{\bf ABELGRP-} depends on a chain of files. 
We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ABELGRP-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ABELGRP-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<ABELGRP-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |ABELGRP-;-;3S;1| (|x| |y| |$|) 
  (SPADCALL |x| (SPADCALL |y| (QREFELT |$| 7)) (QREFELT |$| 8))) 

(DEFUN |ABELGRP-;subtractIfCan;2SU;2| (|x| |y| |$|) 
  (CONS 0 (SPADCALL |x| |y| (QREFELT |$| 10)))) 

(DEFUN |ABELGRP-;*;Nni2S;3| (|n| |x| |$|) 
  (SPADCALL |n| |x| (QREFELT |$| 14))) 

(DEFUN |ABELGRP-;*;I2S;4| (|n| |x| |$|) 
  (COND 
    ((ZEROP |n|) (|spadConstant| |$| 17))
    ((|<| 0 |n|) (SPADCALL |n| |x| (QREFELT |$| 20)))
    ((QUOTE T) 
      (SPADCALL (|-| |n|) (SPADCALL |x| (QREFELT |$| 7)) (QREFELT |$| 20))))) 

(DEFUN |AbelianGroup&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|AbelianGroup&|))
        (LETT |dv$| (LIST (QUOTE |AbelianGroup&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 22) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        (COND 
          ((|HasCategory| |#1| (QUOTE (|Ring|))))
          ((QUOTE T) 
            (QSETREFV |$| 21 
              (CONS (|dispatchFunction| |ABELGRP-;*;I2S;4|) |$|))))
        |$|)))) 

(MAKEPROP 
  (QUOTE |AbelianGroup&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |-|)
        (5 . |+|)
        |ABELGRP-;-;3S;1|
        (11 . |-|)
        (|Union| |$| (QUOTE "failed"))
        |ABELGRP-;subtractIfCan;2SU;2|
        (|Integer|)
        (17 . |*|)
        (|NonNegativeInteger|)
        |ABELGRP-;*;Nni2S;3|
        (23 . |Zero|)
        (|PositiveInteger|)
        (|RepeatedDoubling| 6)
        (27 . |double|)
        (33 . |*|))) 
    (QUOTE #(|subtractIfCan| 39 |-| 45 |*| 51))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 21 
            (QUOTE (1 6 0 0 7 2 6 0 0 0 8 2 6 0 0 0 10 2 6 0 13 0 14 0 6 0 17
                    2 19 6 18 6 20 2 0 0 13 0 21 2 0 11 0 0 12 2 0 0 0 0 9 2
                    0 0 13 0 21 2 0 0 15 0 16))))))
    (QUOTE |lookupComplete|))) 

@
\section{ABELMON.lsp BOOTSTRAP}
{\bf ABELMON} which needs
{\bf ABELSG} which needs
{\bf SETCAT} which needs 
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON}. 
We break this chain with {\bf ABELMON.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ABELMON}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ABELMON.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<ABELMON.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |AbelianMonoid;AL| (QUOTE NIL)) 

(DEFUN |AbelianMonoid| NIL 
  (LET (#:G82597) 
    (COND 
      (|AbelianMonoid;AL|) 
      (T (SETQ |AbelianMonoid;AL| (|AbelianMonoid;|)))))) 

(DEFUN |AbelianMonoid;| NIL 
  (PROG (#1=#:G82595) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|AbelianSemiGroup|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|Zero| (|$|) |constant|) T)
                ((|sample| (|$|) |constant|) T)
                ((|zero?| ((|Boolean|) |$|)) T)
                ((|*| (|$| (|NonNegativeInteger|) |$|)) T)))
              NIL
              (QUOTE ((|NonNegativeInteger|) (|Boolean|)))
              NIL))
            |AbelianMonoid|)
        (SETELT #1# 0 (QUOTE (|AbelianMonoid|))))))) 

(MAKEPROP (QUOTE |AbelianMonoid|) (QUOTE NILADIC) T) 

@
\section{ABELMON-.lsp BOOTSTRAP}
{\bf ABELMON-} which needs
{\bf ABELSG} which needs
{\bf SETCAT} which needs 
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON-}. 
We break this chain with {\bf ABELMON-.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ABELMON-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ABELMON-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<ABELMON-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |ABELMON-;zero?;SB;1| (|x| |$|) 
  (SPADCALL |x| (|spadConstant| |$| 7) (QREFELT |$| 9))) 

(DEFUN |ABELMON-;*;Pi2S;2| (|n| |x| |$|) 
  (SPADCALL |n| |x| (QREFELT |$| 12))) 

(DEFUN |ABELMON-;sample;S;3| (|$|) 
  (|spadConstant| |$| 7)) 

(DEFUN |ABELMON-;*;Nni2S;4| (|n| |x| |$|) 
  (COND 
    ((ZEROP |n|) (|spadConstant| |$| 7))
    ((QUOTE T) (SPADCALL |n| |x| (QREFELT |$| 17))))) 

(DEFUN |AbelianMonoid&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|AbelianMonoid&|))
        (LETT |dv$| (LIST (QUOTE |AbelianMonoid&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 19) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        (COND 
          ((|HasCategory| |#1| (QUOTE (|Ring|))))
          ((QUOTE T) 
            (QSETREFV |$| 18 
              (CONS (|dispatchFunction| |ABELMON-;*;Nni2S;4|) |$|)))) |$|)))) 

(MAKEPROP 
  (QUOTE |AbelianMonoid&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |Zero|)
        (|Boolean|)
        (4 . |=|)
        |ABELMON-;zero?;SB;1|
        (|NonNegativeInteger|)
        (10 . |*|)
        (|PositiveInteger|)
        |ABELMON-;*;Pi2S;2|
        |ABELMON-;sample;S;3|
        (|RepeatedDoubling| 6)
        (16 . |double|)
        (22 . |*|))) 
    (QUOTE #(|zero?| 28 |sample| 33 |*| 37))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 18 
            (QUOTE (0 6 0 7 2 6 8 0 0 9 2 6 0 11 0 12 2 16 6 13 6 17 2 0 0 11
                    0 18 1 0 8 0 10 0 0 0 15 2 0 0 11 0 18 2 0 0 13 0 14))))))
   (QUOTE |lookupComplete|))) 

@
\section{ABELSG.lsp BOOTSTRAP}
{\bf ABELSG} needs
{\bf SETCAT} which needs
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG}. 
We break this chain with {\bf ABELSG.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ABELSG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ABELSG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<ABELSG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |AbelianSemiGroup;AL| (QUOTE NIL)) 

(DEFUN |AbelianSemiGroup| NIL 
  (LET (#:G82568) 
    (COND 
      (|AbelianSemiGroup;AL|)
      (T (SETQ |AbelianSemiGroup;AL| (|AbelianSemiGroup;|)))))) 

(DEFUN |AbelianSemiGroup;| NIL 
  (PROG (#1=#:G82566) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|SetCategory|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|+| (|$| |$| |$|)) T)
                ((|*| (|$| (|PositiveInteger|) |$|)) T)))
              NIL
              (QUOTE ((|PositiveInteger|)))
              NIL))
            |AbelianSemiGroup|)
        (SETELT #1# 0 (QUOTE (|AbelianSemiGroup|))))))) 

(MAKEPROP (QUOTE |AbelianSemiGroup|) (QUOTE NILADIC) T) 
@
\section{ABELSG-.lsp BOOTSTRAP}
{\bf ABELSG-} needs
{\bf SETCAT} which needs
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG-}. 
We break this chain with {\bf ABELSG-.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ABELSG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ABELSG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<ABELSG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |ABELSG-;*;Pi2S;1| (|n| |x| |$|) (SPADCALL |n| |x| (QREFELT |$| 9))) 

(DEFUN |AbelianSemiGroup&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|AbelianSemiGroup&|))
        (LETT |dv$| (LIST (QUOTE |AbelianSemiGroup&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 11) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        (COND 
          ((|HasCategory| |#1| (QUOTE (|Ring|))))
          ((QUOTE T) 
            (QSETREFV |$| 10 
              (CONS (|dispatchFunction| |ABELSG-;*;Pi2S;1|) |$|))))
        |$|)))) 

(MAKEPROP 
  (QUOTE |AbelianSemiGroup&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL
        (|local| |#1|)
        (|PositiveInteger|)
        (|RepeatedDoubling| 6)
        (0 . |double|)
        (6 . |*|)))
    (QUOTE #(|*| 12))
    (QUOTE NIL)
    (CONS
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #()) 
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 10 
            (QUOTE (2 8 6 7 6 9 2 0 0 7 0 10 2 0 0 7 0 10))))))
    (QUOTE |lookupComplete|))) 
@
\section{ALAGG.lsp BOOTSTRAP}
{\bf ALAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ALAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ALAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<ALAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |AssociationListAggregate;CAT| (QUOTE NIL)) 

(SETQ |AssociationListAggregate;AL| (QUOTE NIL)) 

(DEFUN |AssociationListAggregate|
 (|&REST| #1=#:G88404 |&AUX| #2=#:G88402)
  (DSETQ #2# #1#)
  (LET (#3=#:G88403)
   (COND
    ((SETQ #3# (|assoc| (|devaluateList| #2#) |AssociationListAggregate;AL|))
      (CDR #3#))
    (T
      (SETQ |AssociationListAggregate;AL|
       (|cons5|
        (CONS
         (|devaluateList| #2#)
         (SETQ #3# (APPLY (FUNCTION |AssociationListAggregate;|) #2#)))
        |AssociationListAggregate;AL|)) #3#)))) 

(DEFUN |AssociationListAggregate;| (|t#1| |t#2|)
 (PROG (#1=#:G88401)
  (RETURN 
   (PROG1 
    (LETT #1#
     (|sublisV|
      (PAIR 
       (QUOTE (|t#1| |t#2|)) (LIST (|devaluate| |t#1|) (|devaluate| |t#2|)))
      (|sublisV| 
       (PAIR
        (QUOTE (#2=#:G88400))
        (LIST (QUOTE (|Record| (|:| |key| |t#1|) (|:| |entry| |t#2|)))))
       (COND
        (|AssociationListAggregate;CAT|)
        ((QUOTE T)
         (LETT |AssociationListAggregate;CAT|
          (|Join|
           (|TableAggregate| (QUOTE |t#1|) (QUOTE |t#2|))
           (|ListAggregate| (QUOTE #2#))
           (|mkCategory|
            (QUOTE |domain|)
            (QUOTE
             (((|assoc|
                ((|Union|
                  (|Record| (|:| |key| |t#1|) (|:| |entry| |t#2|)) "failed")
                 |t#1| |$|))
                T)))
            NIL (QUOTE NIL) NIL))
          . #3=(|AssociationListAggregate|))))))
       . #3#)
    (SETELT #1# 0 
     (LIST 
      (QUOTE |AssociationListAggregate|)
      (|devaluate| |t#1|)
      (|devaluate| |t#2|))))))) 
@
\section{CABMON.lsp BOOTSTRAP}
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG} which needs
{\bf SETCAT} which needs 
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON}.
We break this chain with {\bf CABMON.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf CABMON}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf CABMON.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<CABMON.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |CancellationAbelianMonoid;AL| (QUOTE NIL)) 

(DEFUN |CancellationAbelianMonoid| NIL 
  (LET (#:G82646) 
    (COND 
      (|CancellationAbelianMonoid;AL|) 
      (T 
        (SETQ 
          |CancellationAbelianMonoid;AL| 
          (|CancellationAbelianMonoid;|)))))) 

(DEFUN |CancellationAbelianMonoid;| NIL 
  (PROG (#1=#:G82644) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|AbelianMonoid|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE 
               (((|subtractIfCan| ((|Union| |$| "failed") |$| |$|)) T)))
              NIL
             (QUOTE NIL)
             NIL))
           |CancellationAbelianMonoid|)
        (SETELT #1# 0 (QUOTE (|CancellationAbelianMonoid|))))))) 

(MAKEPROP (QUOTE |CancellationAbelianMonoid|) (QUOTE NILADIC) T) 

@
\section{CLAGG.lsp BOOTSTRAP}
{\bf CLAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf CLAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf CLAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<CLAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |Collection;CAT| (QUOTE NIL)) 

(SETQ |Collection;AL| (QUOTE NIL)) 

(DEFUN |Collection| (#1=#:G82618)
 (LET (#2=#:G82619)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |Collection;AL|)) (CDR #2#))
   (T
    (SETQ |Collection;AL|
     (|cons5|
      (CONS
       (|devaluate| #1#)
       (SETQ #2# (|Collection;| #1#)))
      |Collection;AL|))
     #2#)))) 

(DEFUN |Collection;| (|t#1|)
 (PROG (#1=#:G82617)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|Collection;CAT|)
       ((QUOTE T)
        (LETT |Collection;CAT|
         (|Join|
          (|HomogeneousAggregate| (QUOTE |t#1|))
          (|mkCategory|
           (QUOTE |domain|)
           (QUOTE (
            ((|construct| (|$| (|List| |t#1|))) T)
            ((|find| ((|Union| |t#1| "failed")
                      (|Mapping| (|Boolean|) |t#1|) |$|))
              T)
            ((|reduce| (|t#1| (|Mapping| |t#1| |t#1| |t#1|) |$|))
             (|has| |$| (ATTRIBUTE |finiteAggregate|)))
            ((|reduce| (|t#1| (|Mapping| |t#1| |t#1| |t#1|) |$| |t#1|))
             (|has| |$| (ATTRIBUTE |finiteAggregate|)))
            ((|remove| (|$| (|Mapping| (|Boolean|) |t#1|) |$|))
             (|has| |$| (ATTRIBUTE |finiteAggregate|)))
            ((|select| (|$| (|Mapping| (|Boolean|) |t#1|) |$|))
             (|has| |$| (ATTRIBUTE |finiteAggregate|)))
            ((|reduce| (|t#1| (|Mapping| |t#1| |t#1| |t#1|) |$| |t#1| |t#1|))
             (AND
              (|has| |t#1| (|SetCategory|))
              (|has| |$| (ATTRIBUTE |finiteAggregate|))))
            ((|remove| (|$| |t#1| |$|))
             (AND
              (|has| |t#1| (|SetCategory|))
              (|has| |$| (ATTRIBUTE |finiteAggregate|))))
            ((|removeDuplicates| (|$| |$|))
             (AND
              (|has| |t#1| (|SetCategory|))
              (|has| |$| (ATTRIBUTE |finiteAggregate|))))))
           (QUOTE (((|ConvertibleTo| (|InputForm|))
                    (|has| |t#1| (|ConvertibleTo| (|InputForm|))))))
           (QUOTE ((|List| |t#1|))) NIL))
         . #2=(|Collection|)))))
      . #2#)
    (SETELT #1# 0 (LIST (QUOTE |Collection|) (|devaluate| |t#1|))))))) 
@
\section{CLAGG-.lsp BOOTSTRAP}
{\bf CLAGG-} depends on {\bf CLAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf CLAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf CLAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<CLAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |CLAGG-;#;ANni;1| (|c| |$|) (LENGTH (SPADCALL |c| (QREFELT |$| 9)))) 

(DEFUN |CLAGG-;count;MANni;2| (|f| |c| |$|)
 (PROG (|x| #1=#:G82637 #2=#:G82634 #3=#:G82632 #4=#:G82633)
  (RETURN
   (SEQ
    (PROGN
     (LETT #4# NIL |CLAGG-;count;MANni;2|)
     (SEQ
      (LETT |x| NIL |CLAGG-;count;MANni;2|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 9)) |CLAGG-;count;MANni;2|)
      G190
      (COND
       ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |CLAGG-;count;MANni;2|) NIL))
        (GO G191)))
      (SEQ
       (EXIT
        (COND
         ((SPADCALL |x| |f|)
          (PROGN
           (LETT #2# 1 |CLAGG-;count;MANni;2|)
           (COND
            (#4# (LETT #3# (|+| #3# #2#) |CLAGG-;count;MANni;2|))
            ((QUOTE T)
             (PROGN
              (LETT #3# #2# |CLAGG-;count;MANni;2|)
              (LETT #4# (QUOTE T) |CLAGG-;count;MANni;2|)))))))))
      (LETT #1# (CDR #1#) |CLAGG-;count;MANni;2|)
      (GO G190)
      G191
      (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) 0))))))) 

(DEFUN |CLAGG-;any?;MAB;3| (|f| |c| |$|)
 (PROG (|x| #1=#:G82642 #2=#:G82640 #3=#:G82638 #4=#:G82639)
  (RETURN
   (SEQ
    (PROGN
     (LETT #4# NIL |CLAGG-;any?;MAB;3|)
     (SEQ
      (LETT |x| NIL |CLAGG-;any?;MAB;3|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 9)) |CLAGG-;any?;MAB;3|)
      G190
      (COND
       ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |CLAGG-;any?;MAB;3|) NIL))
        (GO G191)))
      (SEQ
       (EXIT
        (PROGN
         (LETT #2# (SPADCALL |x| |f|) |CLAGG-;any?;MAB;3|)
         (COND
          (#4#
           (LETT #3#
            (COND (#3# (QUOTE T)) ((QUOTE T) #2#))
            |CLAGG-;any?;MAB;3|))
          ((QUOTE T)
           (PROGN
            (LETT #3# #2# |CLAGG-;any?;MAB;3|)
            (LETT #4# (QUOTE T) |CLAGG-;any?;MAB;3|)))))))
      (LETT #1# (CDR #1#) |CLAGG-;any?;MAB;3|)
      (GO G190)
      G191
      (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) (QUOTE NIL)))))))) 

(DEFUN |CLAGG-;every?;MAB;4| (|f| |c| |$|)
 (PROG (|x| #1=#:G82647 #2=#:G82645 #3=#:G82643 #4=#:G82644)
  (RETURN
   (SEQ
    (PROGN
     (LETT #4# NIL |CLAGG-;every?;MAB;4|)
     (SEQ
      (LETT |x| NIL |CLAGG-;every?;MAB;4|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 9)) |CLAGG-;every?;MAB;4|)
      G190
      (COND
       ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |CLAGG-;every?;MAB;4|) NIL))
        (GO G191)))
      (SEQ
       (EXIT
        (PROGN
         (LETT #2# (SPADCALL |x| |f|) |CLAGG-;every?;MAB;4|)
         (COND
          (#4#
           (LETT #3#
            (COND (#3# #2#) ((QUOTE T) (QUOTE NIL)))
            |CLAGG-;every?;MAB;4|))
          ((QUOTE T)
           (PROGN
            (LETT #3# #2# |CLAGG-;every?;MAB;4|)
            (LETT #4# (QUOTE T) |CLAGG-;every?;MAB;4|)))))))
      (LETT #1# (CDR #1#) |CLAGG-;every?;MAB;4|)
      (GO G190)
      G191
      (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) (QUOTE T)))))))) 

(DEFUN |CLAGG-;find;MAU;5| (|f| |c| |$|)
 (SPADCALL |f| (SPADCALL |c| (QREFELT |$| 9)) (QREFELT |$| 18))) 

(DEFUN |CLAGG-;reduce;MAS;6| (|f| |x| |$|)
 (SPADCALL |f| (SPADCALL |x| (QREFELT |$| 9)) (QREFELT |$| 21))) 

(DEFUN |CLAGG-;reduce;MA2S;7| (|f| |x| |s| |$|)
 (SPADCALL |f| (SPADCALL |x| (QREFELT |$| 9)) |s| (QREFELT |$| 23))) 

(DEFUN |CLAGG-;remove;M2A;8| (|f| |x| |$|)
 (SPADCALL
  (SPADCALL |f| (SPADCALL |x| (QREFELT |$| 9)) (QREFELT |$| 25))
  (QREFELT |$| 26))) 

(DEFUN |CLAGG-;select;M2A;9| (|f| |x| |$|)
 (SPADCALL
  (SPADCALL |f| (SPADCALL |x| (QREFELT |$| 9)) (QREFELT |$| 28))
  (QREFELT |$| 26))) 

(DEFUN |CLAGG-;remove;S2A;10| (|s| |x| |$|)
 (SPADCALL
  (CONS (FUNCTION |CLAGG-;remove;S2A;10!0|) (VECTOR |$| |s|))
  |x|
  (QREFELT |$| 31))) 

(DEFUN |CLAGG-;remove;S2A;10!0| (|#1| |$$|)
 (SPADCALL |#1| (QREFELT |$$| 1) (QREFELT (QREFELT |$$| 0) 30))) 

(DEFUN |CLAGG-;reduce;MA3S;11| (|f| |x| |s1| |s2| |$|)
 (SPADCALL |f| (SPADCALL |x| (QREFELT |$| 9)) |s1| |s2| (QREFELT |$| 33))) 

(DEFUN |CLAGG-;removeDuplicates;2A;12| (|x| |$|) 
 (SPADCALL
  (SPADCALL (SPADCALL |x| (QREFELT |$| 9)) (QREFELT |$| 35))
  (QREFELT |$| 26))) 

(DEFUN |Collection&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|Collection&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |Collection&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 37) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3 
     (LETT |pv$| 
      (|buildPredVector| 0 0
       (LIST 
        (|HasCategory| |#2| (QUOTE (|ConvertibleTo| (|InputForm|))))
        (|HasCategory| |#2| (QUOTE (|SetCategory|)))
        (|HasAttribute| |#1| (QUOTE |finiteAggregate|))))
      . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
     ((|testBitVector| |pv$| 3)
      (PROGN
       (QSETREFV |$| 11 (CONS (|dispatchFunction| |CLAGG-;#;ANni;1|) |$|))
       (QSETREFV |$| 13 (CONS (|dispatchFunction| |CLAGG-;count;MANni;2|) |$|))
       (QSETREFV |$| 15 (CONS (|dispatchFunction| |CLAGG-;any?;MAB;3|) |$|))
       (QSETREFV |$| 16 (CONS (|dispatchFunction| |CLAGG-;every?;MAB;4|) |$|))
       (QSETREFV |$| 19 (CONS (|dispatchFunction| |CLAGG-;find;MAU;5|) |$|))
       (QSETREFV |$| 22 (CONS (|dispatchFunction| |CLAGG-;reduce;MAS;6|) |$|))
       (QSETREFV |$| 24 (CONS (|dispatchFunction| |CLAGG-;reduce;MA2S;7|) |$|))
       (QSETREFV |$| 27 (CONS (|dispatchFunction| |CLAGG-;remove;M2A;8|) |$|))
       (QSETREFV |$| 29 (CONS (|dispatchFunction| |CLAGG-;select;M2A;9|) |$|))
       (COND
        ((|testBitVector| |pv$| 2)
         (PROGN
          (QSETREFV |$| 32
           (CONS (|dispatchFunction| |CLAGG-;remove;S2A;10|) |$|))
          (QSETREFV |$| 34
           (CONS (|dispatchFunction| |CLAGG-;reduce;MA3S;11|) |$|))
          (QSETREFV |$| 36
           (CONS (|dispatchFunction| |CLAGG-;removeDuplicates;2A;12|)
                 |$|))))))))
    |$|)))) 

(MAKEPROP
 (QUOTE |Collection&|)
 (QUOTE |infovec|)
 (LIST (QUOTE 
  #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|List| 7) 
   (0 . |parts|) (|NonNegativeInteger|) (5 . |#|) (|Mapping| 14 7) 
   (10 . |count|) (|Boolean|) (16 . |any?|) (22 . |every?|) 
   (|Union| 7 (QUOTE "failed")) (28 . |find|) (34 . |find|) 
   (|Mapping| 7 7 7) (40 . |reduce|) (46 . |reduce|) (52 . |reduce|) 
   (59 . |reduce|) (66 . |remove|) (72 . |construct|) (77 . |remove|) 
   (83 . |select|) (89 . |select|) (95 . |=|) (101 . |remove|) 
   (107 . |remove|) (113 . |reduce|) (121 . |reduce|) 
   (129 . |removeDuplicates|) (134 . |removeDuplicates|))) 
   (QUOTE #(|select| 139 |removeDuplicates| 145 |remove| 150 |reduce| 
   162 |find| 183 |every?| 189 |count| 195 |any?| 201 |#| 207))
   (QUOTE NIL)
   (CONS 
    (|makeByteWordVec2| 1 (QUOTE NIL))
    (CONS 
     (QUOTE #())
     (CONS 
      (QUOTE #()) 
      (|makeByteWordVec2| 36 
       (QUOTE (1 6 8 0 9 1 0 10 0 11 2 0 10 12 0 13 2 0 14 12 0 15 2 0 14 
        12 0 16 2 8 17 12 0 18 2 0 17 12 0 19 2 8 7 20 0 21 2 0 7 20 0 22 
        3 8 7 20 0 7 23 3 0 7 20 0 7 24 2 8 0 12 0 25 1 6 0 8 26 2 0 0 12 
        0 27 2 8 0 12 0 28 2 0 0 12 0 29 2 7 14 0 0 30 2 6 0 12 0 31 2 0 0 
        7 0 32 4 8 7 20 0 7 7 33 4 0 7 20 0 7 7 34 1 8 0 0 35 1 0 0 0 36 2 
        0 0 12 0 29 1 0 0 0 36 2 0 0 7 0 32 2 0 0 12 0 27 4 0 7 20 0 7 7 34 
        3 0 7 20 0 7 24 2 0 7 20 0 22 2 0 17 12 0 19 2 0 14 12 0 16 2 0 10 
        12 0 13 2 0 14 12 0 15 1 0 10 0 11))))))
    (QUOTE |lookupComplete|))) 
@
\section{COMRING.lsp BOOTSTRAP}
{\bf COMRING} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf COMRING}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf COMRING.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<COMRING.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |CommutativeRing;AL| (QUOTE NIL)) 

(DEFUN |CommutativeRing| NIL 
  (LET (#:G82892) 
    (COND 
      (|CommutativeRing;AL|)
      (T (SETQ |CommutativeRing;AL| (|CommutativeRing;|)))))) 

(DEFUN |CommutativeRing;| NIL 
  (PROG (#1=#:G82890) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|Ring|)
            (|BiModule| (QUOTE |$|) (QUOTE |$|))
            (|mkCategory| 
              (QUOTE |package|)
              NIL
              (QUOTE (((|commutative| "*") T)))
              (QUOTE NIL)
              NIL)) 
           |CommutativeRing|)
        (SETELT #1# 0 (QUOTE (|CommutativeRing|))))))) 

(MAKEPROP (QUOTE |CommutativeRing|) (QUOTE NILADIC) T) 

@
\section{DIFRING.lsp BOOTSTRAP} 
{\bf DIFRING} needs {\bf INT} which needs {\bf DIFRING}.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf DIFRING} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf DIFRING.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<DIFRING.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |DifferentialRing;AL| (QUOTE NIL)) 

(DEFUN |DifferentialRing| NIL 
  (LET (#:G84565) 
    (COND 
      (|DifferentialRing;AL|) 
      (T (SETQ |DifferentialRing;AL| (|DifferentialRing;|)))))) 

(DEFUN |DifferentialRing;| NIL 
  (PROG (#1=#:G84563) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|Ring|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE 
                (((|differentiate| (|$| |$|)) T)
                 ((D (|$| |$|)) T)
                 ((|differentiate| (|$| |$| (|NonNegativeInteger|))) T)
                 ((D (|$| |$| (|NonNegativeInteger|))) T)))
              NIL
              (QUOTE ((|NonNegativeInteger|)))
              NIL))
          |DifferentialRing|)
        (SETELT #1# 0 (QUOTE (|DifferentialRing|))))))) 

(MAKEPROP (QUOTE |DifferentialRing|) (QUOTE NILADIC) T) 

@
\section{DIFRING-.lsp BOOTSTRAP} 
{\bf DIFRING-} needs {\bf DIFRING}.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf DIFRING-} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf DIFRING-.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<DIFRING-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |DIFRING-;D;2S;1| (|r| |$|) 
  (SPADCALL |r| (QREFELT |$| 7))) 

(DEFUN |DIFRING-;differentiate;SNniS;2| (|r| |n| |$|) 
  (PROG (|i|) 
    (RETURN 
      (SEQ 
        (SEQ 
          (LETT |i| 1 |DIFRING-;differentiate;SNniS;2|)
          G190
          (COND ((QSGREATERP |i| |n|) (GO G191)))
          (SEQ 
            (EXIT 
              (LETT |r| 
                (SPADCALL |r| (QREFELT |$| 7))
                |DIFRING-;differentiate;SNniS;2|)))
          (LETT |i| (QSADD1 |i|) |DIFRING-;differentiate;SNniS;2|)
          (GO G190)
          G191
          (EXIT NIL)) 
        (EXIT |r|))))) 

(DEFUN |DIFRING-;D;SNniS;3| (|r| |n| |$|) 
  (SPADCALL |r| |n| (QREFELT |$| 11))) 

(DEFUN |DifferentialRing&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|DifferentialRing&|))
        (LETT |dv$| (LIST (QUOTE |DifferentialRing&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 13) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |DifferentialRing&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |differentiate|)
        |DIFRING-;D;2S;1| 
        (|NonNegativeInteger|)
        |DIFRING-;differentiate;SNniS;2| 
        (5 . |differentiate|)
        |DIFRING-;D;SNniS;3|)) 
    (QUOTE #(|differentiate| 11 D 17))
    (QUOTE NIL) 
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 12 
            (QUOTE 
             (1 6 0 0 7 2 6 0 0 9 11 2 0 0 0 9 10 2 0 0 0 9 12 1 0 0 0 8))))))
    (QUOTE |lookupComplete|))) 

@
\section{DIVRING.lsp BOOTSTRAP}
{\bf DIVRING} depends on {\bf QFCAT} which eventually depends on 
{\bf DIVRING}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf DIVRING}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf DIVRING.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<DIVRING.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |DivisionRing;AL| (QUOTE NIL)) 

(DEFUN |DivisionRing| NIL 
  (LET (#:G84035) 
    (COND 
      (|DivisionRing;AL|)
      (T (SETQ |DivisionRing;AL| (|DivisionRing;|)))))) 

(DEFUN |DivisionRing;| NIL 
  (PROG (#1=#:G84033) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|sublisV| 
            (PAIR 
              (QUOTE (#2=#:G84032))
              (LIST (QUOTE (|Fraction| (|Integer|)))))
            (|Join| 
              (|EntireRing|)
              (|Algebra| (QUOTE #2#))
              (|mkCategory| 
                (QUOTE |domain|)
                (QUOTE (
                  ((|**| (|$| |$| (|Integer|))) T)
                  ((|^| (|$| |$| (|Integer|))) T)
                  ((|inv| (|$| |$|)) T)))
                NIL
                (QUOTE ((|Integer|)))
                NIL)))
          |DivisionRing|)
        (SETELT #1# 0 (QUOTE (|DivisionRing|))))))) 

(MAKEPROP (QUOTE |DivisionRing|) (QUOTE NILADIC) T) 

@
\section{DIVRING-.lsp BOOTSTRAP}
{\bf DIVRING-} depends on {\bf DIVRING}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf DIVRING-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf DIVRING-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<DIVRING-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |DIVRING-;^;SIS;1| (|x| |n| |$|) 
  (SPADCALL |x| |n| (QREFELT |$| 8))) 

(DEFUN |DIVRING-;**;SIS;2| (|x| |n| |$|) 
  (COND 
    ((ZEROP |n|) (|spadConstant| |$| 10))
    ((SPADCALL |x| (QREFELT |$| 12))
      (COND 
        ((|<| |n| 0) (|error| "division by zero"))
        ((QUOTE T) |x|)))
    ((|<| |n| 0) 
      (SPADCALL (SPADCALL |x| (QREFELT |$| 14)) (|-| |n|) (QREFELT |$| 17)))
    ((QUOTE T) (SPADCALL |x| |n| (QREFELT |$| 17))))) 

(DEFUN |DIVRING-;*;F2S;3| (|q| |x| |$|) 
  (SPADCALL 
    (SPADCALL 
      (SPADCALL |q| (QREFELT |$| 20))
      (SPADCALL 
        (SPADCALL (SPADCALL |q| (QREFELT |$| 21)) (QREFELT |$| 22))
        (QREFELT |$| 14))
      (QREFELT |$| 23))
    |x|
    (QREFELT |$| 24))) 

(DEFUN |DivisionRing&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|DivisionRing&|))
        (LETT |dv$| (LIST (QUOTE |DivisionRing&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 27) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |DivisionRing&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (|Integer|)
        (0 . |**|)
        |DIVRING-;^;SIS;1| 
        (6 . |One|)
        (|Boolean|)
        (10 . |zero?|)
        (15 . |Zero|)
        (19 . |inv|)
        (|PositiveInteger|)
        (|RepeatedSquaring| 6)
        (24 . |expt|)
        |DIVRING-;**;SIS;2| 
        (|Fraction| 7)
        (30 . |numer|)
        (35 . |denom|)
        (40 . |coerce|)
        (45 . |*|)
        (51 . |*|)
        |DIVRING-;*;F2S;3| 
        (|NonNegativeInteger|))) 
    (QUOTE #(|^| 57 |**| 63 |*| 69))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #()) 
        (CONS 
          (QUOTE #()) 
            (|makeByteWordVec2| 25 
              (QUOTE 
                (2 6 0 0 7 8 0 6 0 10 1 6 11 0 12 0 6 0 13 1 6 0 0 14 2 16 6
                 6 15 17 1 19 7 0 20 1 19 7 0 21 1 6 0 7 22 2 6 0 7 0 23 2 6
                 0 0 0 24 2 0 0 0 7 9 2 0 0 0 7 18 2 0 0 19 0 25)))))) 
    (QUOTE |lookupComplete|))) 

@
\section{EUCDOM.lsp BOOTSTRAP}
{\bf EUCDOM} depends on {\bf INT} which depends on {\bf EUCDOM}. 
We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf EUCDOM}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf EUCDOM.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

\subsection{The Lisp Implementation}
\subsubsection{EUCDOM;VersionCheck}
This implements the bootstrap code for {\bf EuclideanDomain}. 
The call to {\bf VERSIONCHECK} is a legacy check to ensure that
we did not load algebra code from a previous system version (which
would not run due to major surgical changes in the system) without
recompiling.
<<EUCDOM;VersionCheck>>=
(|/VERSIONCHECK| 2) 

@
\subsubsection{The Domain Cache Variable}
We create a variable which is formed by concatenating the string
``{\bf ;AL}'' to the domain name forming, in this case,
``{\bf EuclideanDomain;AL}''. The variable has the initial value
at load time of a list of one element, {\bf NIL}. This list is
a data structure that will be modified to hold an executable 
function. This function is created the first time the domain is
used which it replaces the {\bf NIL}.
<<EuclideanDomain;AL>>=
(SETQ |EuclideanDomain;AL| (QUOTE NIL)) 

@
\subsubsection{The Domain Function}
When you call a domain the code is pretty simple at the top
level. This code will check to see if this domain has ever been
used. It does this by checking the value of the cached domain
variable (which is the domain name {\bf EuclideanDomain} concatenated
with the string ``{\bf ;AL}'' to form the cache variable name which
is {\bf EuclideanDomain;AL}).

If this value is NIL we have never executed this function
before. If it is not NIL we have executed this function before and
we need only return the cached function which was stored in the
cache variable.

If this is the first time this function is called, the cache
variable is NIL and we execute the other branch of the conditional.
This calls a function which 
\begin{enumerate}
\item creates a procedure
\item returns the procedure as a value.
\end{enumerate}
This procedure replaces the cached variable {\bf EuclideanDomain;AL}
value so it will be non-NIL the second time this domain is used.
Thus the work of building the domain only happens once.

If this function has never been called before we call the 
<<EuclideanDomain>>=
(DEFUN |EuclideanDomain| NIL 
  (LET (#:G83585) 
    (COND 
      (|EuclideanDomain;AL|)
      (T (SETQ |EuclideanDomain;AL| (|EuclideanDomain;|)))))) 

@
\subsubsection{The First Call Domain Function}
<<EuclideanDomain;>>=
(DEFUN |EuclideanDomain;| NIL 
  (PROG (#1=#:G83583) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|PrincipalIdealDomain|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|sizeLess?| ((|Boolean|) |$| |$|)) T)
                ((|euclideanSize| ((|NonNegativeInteger|) |$|)) T)
                ((|divide| 
                  ((|Record| 
                    (|:| |quotient| |$|)
                    (|:| |remainder| |$|))
                  |$| |$|)) T)
                ((|quo| (|$| |$| |$|)) T)
                ((|rem| (|$| |$| |$|)) T)
                ((|extendedEuclidean| 
                  ((|Record| 
                    (|:| |coef1| |$|)
                    (|:| |coef2| |$|)
                    (|:| |generator| |$|))
                  |$| |$|)) T)
                ((|extendedEuclidean| 
                  ((|Union| 
                      (|Record| (|:| |coef1| |$|) (|:| |coef2| |$|))
                      "failed")
                    |$| |$| |$|)) T)
                ((|multiEuclidean| 
                  ((|Union| 
                      (|List| |$|)
                      "failed") 
                   (|List| |$|) |$|)) T)))
              NIL 
              (QUOTE ((|List| |$|) (|NonNegativeInteger|) (|Boolean|)))
              NIL)) 
            |EuclideanDomain|)
        (SETELT #1# 0 (QUOTE (|EuclideanDomain|))))))) 

@
\subsubsection{EUCDOM;MAKEPROP}
<<EUCDOM;MAKEPROP>>=
(MAKEPROP (QUOTE |EuclideanDomain|) (QUOTE NILADIC) T) 

@
<<EUCDOM.lsp BOOTSTRAP>>=
<<EUCDOM;VersionCheck>>
<<EuclideanDomain;AL>>
<<EuclideanDomain>>
<<EuclideanDomain;>>
<<EUCDOM;MAKEPROP>>
@
\section{EUCDOM-.lsp BOOTSTRAP}
{\bf EUCDOM-} depends on {\bf EUCDOM}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf EUCDOM-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf EUCDOM-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

\subsection{The Lisp Implementation}
\subsubsection{EUCDOM-;VersionCheck}
This implements the bootstrap code for {\bf EuclideanDomain}. 
The call to {\bf VERSIONCHECK} is a legacy check to ensure that
we did not load algebra code from a previous system version (which
would not run due to major surgical changes in the system) without
recompiling.
<<EUCDOM-;VersionCheck>>=
(|/VERSIONCHECK| 2) 

@
\subsubsection{EUCDOM-;sizeLess?;2SB;1}
<<EUCDOM-;sizeLess?;2SB;1>>=
(DEFUN |EUCDOM-;sizeLess?;2SB;1| (|x| |y| $)
 (COND
  ((SPADCALL |y| (QREFELT $ 8)) (QUOTE NIL))
  ((SPADCALL |x| (QREFELT $ 8)) (QUOTE T))
  ((QUOTE T)
   (< (SPADCALL |x| (QREFELT $ 10)) (SPADCALL |y| (QREFELT $ 10)))))) 

@

\subsubsection{EUCDOM-;quo;3S;2}
<<EUCDOM-;quo;3S;2>>=
(DEFUN |EUCDOM-;quo;3S;2| (|x| |y| $)
 (QCAR (SPADCALL |x| |y| (QREFELT $ 13)))) 

@
\subsubsection{EUCDOM-;rem;3S;3}
<<EUCDOM-;rem;3S;3>>=
(DEFUN |EUCDOM-;rem;3S;3| (|x| |y| $)
 (QCDR (SPADCALL |x| |y| (QREFELT $ 13)))) 

@
\subsubsection{EUCDOM-;exquo;2SU;4}
<<EUCDOM-;exquo;2SU;4>>=
(DEFUN |EUCDOM-;exquo;2SU;4| (|x| |y| $)
 (PROG (|qr|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |x| (QREFELT $ 8)) (CONS 0 (|spadConstant| $ 16)))
     ((SPADCALL |y| (QREFELT $ 8)) (CONS 1 "failed"))
     ((QUOTE T)
      (SEQ
       (LETT |qr|
        (SPADCALL |x| |y| (QREFELT $ 13))
        |EUCDOM-;exquo;2SU;4|)
       (EXIT
        (COND
         ((SPADCALL (QCDR |qr|) (QREFELT $ 8)) (CONS 0 (QCAR |qr|)))
         ((QUOTE T) (CONS 1 "failed"))))))))))) 

@
\subsubsection{EUCDOM-;gcd;3S;5}
<<EUCDOM-;gcd;3S;5>>=
(DEFUN |EUCDOM-;gcd;3S;5| (|x| |y| $)
 (PROG (|#G13| |#G14|)
  (RETURN
   (SEQ
    (LETT |x| (SPADCALL |x| (QREFELT $ 19)) |EUCDOM-;gcd;3S;5|)
    (LETT |y| (SPADCALL |y| (QREFELT $ 19)) |EUCDOM-;gcd;3S;5|)
    (SEQ G190
     (COND
      ((NULL
       (COND 
        ((SPADCALL |y| (QREFELT $ 8)) (QUOTE NIL))
        ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (PROGN
       (LETT |#G13| |y| |EUCDOM-;gcd;3S;5|)
       (LETT |#G14| (SPADCALL |x| |y| (QREFELT $ 20)) |EUCDOM-;gcd;3S;5|)
       (LETT |x| |#G13| |EUCDOM-;gcd;3S;5|)
       (LETT |y| |#G14| |EUCDOM-;gcd;3S;5|))
      (EXIT
       (LETT |y| (SPADCALL |y| (QREFELT $ 19)) |EUCDOM-;gcd;3S;5|)))
     NIL
     (GO G190)
    G191
   (EXIT NIL))
  (EXIT |x|))))) 

@
\subsubsection{EUCDOM-;unitNormalizeIdealElt}
<<EUCDOM-;unitNormalizeIdealElt>>=
(DEFUN |EUCDOM-;unitNormalizeIdealElt| (|s| $)
 (PROG (|#G16| |u| |c| |a|)
  (RETURN
   (SEQ
    (PROGN
     (LETT |#G16| 
       (SPADCALL (QVELT |s| 2) (QREFELT $ 23))
       |EUCDOM-;unitNormalizeIdealElt|)
     (LETT |u| (QVELT |#G16| 0) |EUCDOM-;unitNormalizeIdealElt|)
     (LETT |c| (QVELT |#G16| 1) |EUCDOM-;unitNormalizeIdealElt|)
     (LETT |a| (QVELT |#G16| 2) |EUCDOM-;unitNormalizeIdealElt|)
     |#G16|)
    (EXIT
     (COND
      ((SPADCALL |a| (|spadConstant| $ 24) (QREFELT $ 25)) |s|)
      ((QUOTE T)
       (VECTOR
        (SPADCALL |a| (QVELT |s| 0) (QREFELT $ 26))
        (SPADCALL |a| (QVELT |s| 1) (QREFELT $ 26))
        |c|)))))))) 

@
\subsubsection{EUCDOM-;extendedEuclidean;2SR;7}
<<EUCDOM-;extendedEuclidean;2SR;7>>=
(DEFUN |EUCDOM-;extendedEuclidean;2SR;7| (|x| |y| $)
 (PROG (|s3| |s2| |qr| |s1|)
  (RETURN
   (SEQ
    (LETT |s1|
     (|EUCDOM-;unitNormalizeIdealElt|
      (VECTOR (|spadConstant| $ 24) (|spadConstant| $ 16) |x|)
       $)
     |EUCDOM-;extendedEuclidean;2SR;7|)
    (LETT |s2|
     (|EUCDOM-;unitNormalizeIdealElt|
      (VECTOR (|spadConstant| $ 16) (|spadConstant| $ 24) |y|)
      $)
      |EUCDOM-;extendedEuclidean;2SR;7|)
    (EXIT
     (COND
      ((SPADCALL |y| (QREFELT $ 8)) |s1|)
      ((SPADCALL |x| (QREFELT $ 8)) |s2|)
      ((QUOTE T)
       (SEQ
        (SEQ
         G190
         (COND
          ((NULL 
            (COND 
             ((SPADCALL (QVELT |s2| 2) (QREFELT $ 8)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ
          (LETT |qr|
           (SPADCALL (QVELT |s1| 2) (QVELT |s2| 2) (QREFELT $ 13))
           |EUCDOM-;extendedEuclidean;2SR;7|)
          (LETT |s3|
           (VECTOR
            (SPADCALL (QVELT |s1| 0)
             (SPADCALL (QCAR |qr|) (QVELT |s2| 0) (QREFELT $ 26))
             (QREFELT $ 27))
            (SPADCALL (QVELT |s1| 1)
             (SPADCALL (QCAR |qr|) (QVELT |s2| 1) (QREFELT $ 26))
             (QREFELT $ 27))
            (QCDR |qr|))
           |EUCDOM-;extendedEuclidean;2SR;7|)
          (LETT |s1| |s2| |EUCDOM-;extendedEuclidean;2SR;7|)
          (EXIT
           (LETT |s2|
            (|EUCDOM-;unitNormalizeIdealElt| |s3| $)
            |EUCDOM-;extendedEuclidean;2SR;7|)))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
        (COND
         ((NULL (SPADCALL (QVELT |s1| 0) (QREFELT $ 8)))
           (COND
            ((NULL (SPADCALL (QVELT |s1| 0) |y| (QREFELT $ 28)))
             (SEQ
              (LETT |qr|
               (SPADCALL (QVELT |s1| 0) |y| (QREFELT $ 13))
               |EUCDOM-;extendedEuclidean;2SR;7|)
              (QSETVELT |s1| 0 (QCDR |qr|))
              (QSETVELT |s1| 1
               (SPADCALL (QVELT |s1| 1)
                (SPADCALL (QCAR |qr|) |x| (QREFELT $ 26)) (QREFELT $ 29)))
              (EXIT
               (LETT |s1|
                (|EUCDOM-;unitNormalizeIdealElt| |s1| $)
                |EUCDOM-;extendedEuclidean;2SR;7|)))))))
        (EXIT |s1|))))))))) 

@
\subsubsection{EUCDOM-;extendedEuclidean;3SU;8}
<<EUCDOM-;extendedEuclidean;3SU;8>>=
(DEFUN |EUCDOM-;extendedEuclidean;3SU;8| (|x| |y| |z| $)
 (PROG (|s| |w| |qr|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |z| (QREFELT $ 8))
       (CONS 0 (CONS (|spadConstant| $ 16) (|spadConstant| $ 16))))
     ((QUOTE T)
       (SEQ
        (LETT |s|
         (SPADCALL |x| |y| (QREFELT $ 32))
         |EUCDOM-;extendedEuclidean;3SU;8|)
        (LETT |w|
         (SPADCALL |z| (QVELT |s| 2) (QREFELT $ 33))
         |EUCDOM-;extendedEuclidean;3SU;8|)
        (EXIT
         (COND
          ((QEQCAR |w| 1) (CONS 1 "failed"))
          ((SPADCALL |y| (QREFELT $ 8))
            (CONS 0
             (CONS (SPADCALL (QVELT |s| 0) (QCDR |w|) (QREFELT $ 26))
              (SPADCALL (QVELT |s| 1) (QCDR |w|) (QREFELT $ 26)))))
          ((QUOTE T)
           (SEQ
            (LETT |qr|
             (SPADCALL
              (SPADCALL (QVELT |s| 0) (QCDR |w|) (QREFELT $ 26))
              |y|
              (QREFELT $ 13))
             |EUCDOM-;extendedEuclidean;3SU;8|)
            (EXIT
             (CONS 0
              (CONS (QCDR |qr|)
               (SPADCALL
                (SPADCALL (QVELT |s| 1) (QCDR |w|) (QREFELT $ 26))
                (SPADCALL (QCAR |qr|) |x| (QREFELT $ 26))
                (QREFELT $ 29)))))))))))))))) 

@
\subsubsection{EUCDOM-;principalIdeal;LR;9}
<<EUCDOM-;principalIdeal;LR;9>>=
(DEFUN |EUCDOM-;principalIdeal;LR;9| (|l| $)
 (PROG (|uca| |v| |u| #0=#:G1497 |vv| #1=#:G1498)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |l| NIL (QREFELT $ 38))
       (|error| "empty list passed to principalIdeal"))
     ((SPADCALL (CDR |l|) NIL (QREFELT $ 38))
       (SEQ
        (LETT |uca|
         (SPADCALL (|SPADfirst| |l|) (QREFELT $ 23))
         |EUCDOM-;principalIdeal;LR;9|)
        (EXIT (CONS (LIST (QVELT |uca| 0)) (QVELT |uca| 1)))))
     ((SPADCALL (CDR (CDR |l|)) NIL (QREFELT $ 38))
       (SEQ
        (LETT |u|
         (SPADCALL (|SPADfirst| |l|)
          (SPADCALL |l| (QREFELT $ 39)) (QREFELT $ 32))
         |EUCDOM-;principalIdeal;LR;9|)
        (EXIT (CONS (LIST (QVELT |u| 0) (QVELT |u| 1)) (QVELT |u| 2)))))
     ((QUOTE T)
       (SEQ
        (LETT |v|
         (SPADCALL (CDR |l|) (QREFELT $ 42))
         |EUCDOM-;principalIdeal;LR;9|)
        (LETT |u|
         (SPADCALL (|SPADfirst| |l|) (QCDR |v|) (QREFELT $ 32))
         |EUCDOM-;principalIdeal;LR;9|)
        (EXIT
         (CONS 
          (CONS (QVELT |u| 0)
           (PROGN
            (LETT #0# NIL |EUCDOM-;principalIdeal;LR;9|)
            (SEQ
             (LETT |vv| NIL |EUCDOM-;principalIdeal;LR;9|)
             (LETT #1# (QCAR |v|) |EUCDOM-;principalIdeal;LR;9|)
             G190
             (COND
              ((OR (ATOM #1#)
                   (PROGN
                    (LETT |vv| (CAR #1#) |EUCDOM-;principalIdeal;LR;9|) NIL))
               (GO G191)))
             (SEQ
              (EXIT
               (LETT #0#
                (CONS (SPADCALL (QVELT |u| 1) |vv| (QREFELT $ 26))
                   #0#)
                |EUCDOM-;principalIdeal;LR;9|)))
             (LETT #1# (CDR #1#)
              |EUCDOM-;principalIdeal;LR;9|)
             (GO G190)
             G191
             (EXIT (NREVERSE0 #0#)))))
          (QVELT |u| 2)))))))))) 

@
\subsubsection{EUCDOM-;expressIdealMember;LSU;10}
<<EUCDOM-;expressIdealMember;LSU;10>>=
(DEFUN |EUCDOM-;expressIdealMember;LSU;10| (|l| |z| $)
 (PROG (#0=#:G1513 #1=#:G1514 |pid| |q| #2=#:G1515 |v| #3=#:G1516)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |z| (|spadConstant| $ 16) (QREFELT $ 25))
      (CONS 0
       (PROGN
        (LETT #0# NIL |EUCDOM-;expressIdealMember;LSU;10|)
        (SEQ
         (LETT |v| NIL |EUCDOM-;expressIdealMember;LSU;10|)
         (LETT #1# |l| |EUCDOM-;expressIdealMember;LSU;10|)
         G190
         (COND
          ((OR (ATOM #1#)
               (PROGN
                (LETT |v| (CAR #1#) |EUCDOM-;expressIdealMember;LSU;10|) NIL))
           (GO G191)))
         (SEQ 
          (EXIT
           (LETT #0#
            (CONS (|spadConstant| $ 16) #0#)
            |EUCDOM-;expressIdealMember;LSU;10|)))
         (LETT #1# (CDR #1#) |EUCDOM-;expressIdealMember;LSU;10|)
         (GO G190)
         G191
        (EXIT (NREVERSE0 #0#))))))
     ((QUOTE T)
      (SEQ
       (LETT |pid|
        (SPADCALL |l| (QREFELT $ 42))
        |EUCDOM-;expressIdealMember;LSU;10|)
       (LETT |q|
        (SPADCALL |z| (QCDR |pid|) (QREFELT $ 33))
        |EUCDOM-;expressIdealMember;LSU;10|)
       (EXIT
        (COND
         ((QEQCAR |q| 1) (CONS 1 "failed"))
         ((QUOTE T)
          (CONS 0
           (PROGN
            (LETT #2# NIL |EUCDOM-;expressIdealMember;LSU;10|)
            (SEQ
             (LETT |v| NIL |EUCDOM-;expressIdealMember;LSU;10|)
             (LETT #3# (QCAR |pid|) |EUCDOM-;expressIdealMember;LSU;10|)
             G190
             (COND
              ((OR (ATOM #3#)
                   (PROGN
                    (LETT |v| (CAR #3#) |EUCDOM-;expressIdealMember;LSU;10|)
                    NIL))
               (GO G191)))
             (SEQ
              (EXIT
              (LETT #2#
               (CONS (SPADCALL (QCDR |q|) |v| (QREFELT $ 26))
                  #2#) 
               |EUCDOM-;expressIdealMember;LSU;10|)))
             (LETT #3# (CDR #3#) |EUCDOM-;expressIdealMember;LSU;10|)
             (GO G190)
             G191
             (EXIT (NREVERSE0 #2#))))))))))))))) 

@
\subsubsection{EUCDOM-;multiEuclidean;LSU;11}
<<EUCDOM-;multiEuclidean;LSU;11>>=
(DEFUN |EUCDOM-;multiEuclidean;LSU;11| (|l| |z| $)
 (PROG (|n| |l1| |l2| #0=#:G1405 #1=#:G1535 #2=#:G1522 #3=#:G1520 
        #4=#:G1521 #5=#:G1406 #6=#:G1536 #7=#:G1525 #8=#:G1523 #9=#:G1524 
        |u| |v1| |v2|)
  (RETURN
   (SEQ
    (LETT |n| (LENGTH |l|) |EUCDOM-;multiEuclidean;LSU;11|)
    (EXIT
     (COND
      ((ZEROP |n|) (|error| "empty list passed to multiEuclidean"))
      ((EQL |n| 1) (CONS 0 (LIST |z|)))
      ((QUOTE T)
       (SEQ
        (LETT |l1|
         (SPADCALL |l| (QREFELT $ 46)) |EUCDOM-;multiEuclidean;LSU;11|)
        (LETT |l2|
         (SPADCALL |l1| (QUOTIENT2 |n| 2) (QREFELT $ 48))
         |EUCDOM-;multiEuclidean;LSU;11|)
        (LETT |u|
         (SPADCALL
          (PROGN
           (LETT #4# NIL |EUCDOM-;multiEuclidean;LSU;11|)
           (SEQ
            (LETT #0# NIL |EUCDOM-;multiEuclidean;LSU;11|)
            (LETT #1# |l1| |EUCDOM-;multiEuclidean;LSU;11|)
            G190
            (COND
             ((OR (ATOM #1#)
                  (PROGN
                   (LETT #0# (CAR #1#) |EUCDOM-;multiEuclidean;LSU;11|)
                   NIL))
              (GO G191)))
            (SEQ 
             (EXIT
              (PROGN
               (LETT #2# #0# |EUCDOM-;multiEuclidean;LSU;11|)
               (COND
                (#4#
                 (LETT #3#
                  (SPADCALL #3# #2# (QREFELT $ 26))
                  |EUCDOM-;multiEuclidean;LSU;11|))
                ((QUOTE T)
                 (PROGN
                  (LETT #3# #2# |EUCDOM-;multiEuclidean;LSU;11|)
                  (LETT #4# (QUOTE T) |EUCDOM-;multiEuclidean;LSU;11|)))))))
            (LETT #1# (CDR #1#) |EUCDOM-;multiEuclidean;LSU;11|)
            (GO G190)
            G191
            (EXIT NIL))
           (COND (#4# #3#) ((QUOTE T) (|spadConstant| $ 24))))
          (PROGN
           (LETT #9# NIL |EUCDOM-;multiEuclidean;LSU;11|)
           (SEQ
            (LETT #5# NIL |EUCDOM-;multiEuclidean;LSU;11|)
            (LETT #6# |l2| |EUCDOM-;multiEuclidean;LSU;11|)
            G190
            (COND
             ((OR (ATOM #6#)
                  (PROGN
                   (LETT #5# (CAR #6#) |EUCDOM-;multiEuclidean;LSU;11|)
                   NIL))
              (GO G191)))
            (SEQ
             (EXIT
              (PROGN
               (LETT #7# #5# |EUCDOM-;multiEuclidean;LSU;11|)
               (COND
                (#9#
                 (LETT #8#
                  (SPADCALL #8# #7# (QREFELT $ 26))
                  |EUCDOM-;multiEuclidean;LSU;11|))
                ((QUOTE T)
                 (PROGN
                  (LETT #8# #7# |EUCDOM-;multiEuclidean;LSU;11|)
                  (LETT #9# (QUOTE T) |EUCDOM-;multiEuclidean;LSU;11|)))))))
            (LETT #6# (CDR #6#) |EUCDOM-;multiEuclidean;LSU;11|)
            (GO G190)
            G191
            (EXIT NIL))
           (COND (#9# #8#) ((QUOTE T) (|spadConstant| $ 24))))
          |z| (QREFELT $ 49))
         |EUCDOM-;multiEuclidean;LSU;11|)
        (EXIT
         (COND
          ((QEQCAR |u| 1) (CONS 1 "failed"))
          ((QUOTE T)
           (SEQ
            (LETT |v1|
             (SPADCALL |l1| (QCDR (QCDR |u|)) (QREFELT $ 50))
             |EUCDOM-;multiEuclidean;LSU;11|)
            (EXIT
             (COND
              ((QEQCAR |v1| 1) (CONS 1 "failed"))
              ((QUOTE T)
               (SEQ
                (LETT |v2|
                 (SPADCALL |l2| (QCAR (QCDR |u|)) (QREFELT $ 50))
                 |EUCDOM-;multiEuclidean;LSU;11|)
                (EXIT
                 (COND
                  ((QEQCAR |v2| 1) (CONS 1 "failed"))
                  ((QUOTE T)
                   (CONS 0
                    (SPADCALL
                     (QCDR |v1|)
                     (QCDR |v2|)
                     (QREFELT $ 51)))))))))))))))))))))) 

@
\subsubsection{EuclideanDomain\&}
<<EuclideanDomainAmp>>=
(DEFUN |EuclideanDomain&| (|#1|)
 (PROG (DV$1 |dv$| $ |pv$|)
  (RETURN
   (PROGN 
    (LETT DV$1 (|devaluate| |#1|) . #0=(|EuclideanDomain&|))
    (LETT |dv$| (LIST (QUOTE |EuclideanDomain&|) DV$1) . #0#)
    (LETT $ (GETREFV 53) . #0#)
    (QSETREFV $ 0 |dv$|)
    (QSETREFV $ 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #0#))
    (|stuffDomainSlots| $)
    (QSETREFV $ 6 |#1|)
    $)))) 

@
\subsubsection{EUCDOM-;MAKEPROP}
<<EUCDOM-;MAKEPROP>>=
(MAKEPROP
 (QUOTE |EuclideanDomain&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|Boolean|) (0 . |zero?|)
  (|NonNegativeInteger|) (5 . |euclideanSize|) |EUCDOM-;sizeLess?;2SB;1|
  (|Record| (|:| |quotient| $) (|:| |remainder| $)) (10 . |divide|)
  |EUCDOM-;quo;3S;2| |EUCDOM-;rem;3S;3| (16 . |Zero|)
  (|Union| $ (QUOTE "failed")) |EUCDOM-;exquo;2SU;4| (20 . |unitCanonical|)
  (25 . |rem|) |EUCDOM-;gcd;3S;5|
  (|Record| (|:| |unit| $) (|:| |canonical| $) (|:| |associate| $))
  (31 . |unitNormal|) (36 . |One|) (40 . =) (46 . *) (52 . -)
  (58 . |sizeLess?|) (64 . +) 
  (|Record| (|:| |coef1| $) (|:| |coef2| $) (|:| |generator| $))
  |EUCDOM-;extendedEuclidean;2SR;7|
  (70 . |extendedEuclidean|) (76 . |exquo|) 
  (|Record| (|:| |coef1| $) (|:| |coef2| $))
  (|Union| 34 (QUOTE "failed")) |EUCDOM-;extendedEuclidean;3SU;8|
  (|List| 6) (82 . =) (88 . |second|) 
  (|Record| (|:| |coef| 41) (|:| |generator| $))
  (|List| $) (93 . |principalIdeal|) |EUCDOM-;principalIdeal;LR;9| 
  (|Union| 41 (QUOTE "failed")) |EUCDOM-;expressIdealMember;LSU;10|
  (98 . |copy|) (|Integer|) (103 . |split!|) (109 . |extendedEuclidean|)
  (116 . |multiEuclidean|) (122 . |concat|) |EUCDOM-;multiEuclidean;LSU;11|))
  (QUOTE
   #(|sizeLess?| 128 |rem| 134 |quo| 140 |principalIdeal| 146 
     |multiEuclidean| 151 |gcd| 157 |extendedEuclidean| 163 
     |exquo| 176 |expressIdealMember| 182))
  (QUOTE NIL)
  (CONS (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS (QUOTE #())
    (CONS (QUOTE #())
     (|makeByteWordVec2| 52 (QUOTE (1 6 7 0 8 1 6 9 0 10 2 6 12 0 0 13 0 
       6 0 16 1 6 0 0 19 2 6 0 0 0 20 1 6 22 0 23 0 6 0 24 2 6 7 0 0 25 2 6 0 
       0 0 26 2 6 0 0 0 27 2 6 7 0 0 28 2 6 0 0 0 29 2 6 30 0 0 32 2 6 17 0 0 
       33 2 37 7 0 0 38 1 37 6 0 39 1 6 40 41 42 1 37 0 0 46 2 37 0 0 47 48 3 
       6 35 0 0 0 49 2 6 44 41 0 50 2 37 0 0 0 51 2 0 7 0 0 11 2 0 0 0 0 15 2 
       0 0 0 0 14 1 0 40 41 43 2 0 44 41 0 52 2 0 0 0 0 21 3 0 35 0 0 0 36 2 0 
       30 0 0 31 2 0 17 0 0 18 2 0 44 41 0 45))))))
  (QUOTE |lookupComplete|))) 

@
<<EUCDOM-.lsp BOOTSTRAP>>=

<<EUCDOM-;VersionCheck>>
<<EUCDOM-;sizeLess?;2SB;1>>
<<EUCDOM-;quo;3S;2>>
<<EUCDOM-;rem;3S;3>>
<<EUCDOM-;exquo;2SU;4>>
<<EUCDOM-;gcd;3S;5>>
<<EUCDOM-;unitNormalizeIdealElt>>
<<EUCDOM-;extendedEuclidean;2SR;7>>
<<EUCDOM-;extendedEuclidean;3SU;8>>
<<EUCDOM-;principalIdeal;LR;9>>
<<EUCDOM-;expressIdealMember;LSU;10>>
<<EUCDOM-;multiEuclidean;LSU;11>>
<<EuclideanDomainAmp>>
<<EUCDOM-;MAKEPROP>>
@
\section{ENTIRER.lsp BOOTSTRAP}
{\bf ENTIRER} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ENTIRER}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ENTIRER.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<ENTIRER.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |EntireRing;AL| (QUOTE NIL)) 

(DEFUN |EntireRing| NIL 
  (LET (#:G82841) 
    (COND 
      (|EntireRing;AL|) 
      (T (SETQ |EntireRing;AL| (|EntireRing;|)))))) 

(DEFUN |EntireRing;| NIL 
  (PROG (#1=#:G82839) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|Ring|) 
            (|BiModule| (QUOTE |$|) (QUOTE |$|))
            (|mkCategory| 
              (QUOTE |package|)
              NIL
              (QUOTE ((|noZeroDivisors| T)))
              (QUOTE NIL)
              NIL))
          |EntireRing|)
        (SETELT #1# 0 (QUOTE (|EntireRing|))))))) 

(MAKEPROP (QUOTE |EntireRing|) (QUOTE NILADIC) T) 

@
\section{GCDDOM.lsp BOOTSTRAP}
{\bf GCDDOM} needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG} which needs
{\bf SETCAT} which needs
{\bf SINT} which needs
{\bf UFD} which needs
{\bf GCDDOM}. 
We break this chain with {\bf GCDDOM.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf GCDDOM}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf GCDDOM.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<GCDDOM.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |GcdDomain;AL| (QUOTE NIL)) 

(DEFUN |GcdDomain| NIL 
  (LET (#:G83171) 
    (COND 
      (|GcdDomain;AL|) 
      (T (SETQ |GcdDomain;AL| (|GcdDomain;|)))))) 

(DEFUN |GcdDomain;| NIL 
  (PROG (#1=#:G83169) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|IntegralDomain|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|gcd| (|$| |$| |$|)) T)
                ((|gcd| (|$| (|List| |$|))) T)
                ((|lcm| (|$| |$| |$|)) T)
                ((|lcm| (|$| (|List| |$|))) T)
                ((|gcdPolynomial| 
                  ((|SparseUnivariatePolynomial| |$|)
                   (|SparseUnivariatePolynomial| |$|)
                   (|SparseUnivariatePolynomial| |$|)))
                  T)))
              NIL 
              (QUOTE ((|SparseUnivariatePolynomial| |$|) (|List| |$|)))
              NIL)) 
            |GcdDomain|)
        (SETELT #1# 0 (QUOTE (|GcdDomain|))))))) 

(MAKEPROP (QUOTE |GcdDomain|) (QUOTE NILADIC) T) 

@
\section{GCDDOM-.lsp BOOTSTRAP}
{\bf GCDDOM-} depends on {\bf GCDDOM}.
We break this chain with {\bf GCDDOM-.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf GCDDOM-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf GCDDOM-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<GCDDOM-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |GCDDOM-;lcm;3S;1| (|x| |y| |$|) 
  (PROG (LCM) 
    (RETURN 
      (SEQ 
        (COND 
          ((OR 
              (SPADCALL |y| (|spadConstant| |$| 7) (QREFELT |$| 9))
              (SPADCALL |x| (|spadConstant| |$| 7) (QREFELT |$| 9))) 
            (|spadConstant| |$| 7))
          ((QUOTE T) 
            (SEQ 
              (LETT LCM 
                (SPADCALL |y| 
                  (SPADCALL |x| |y| (QREFELT |$| 10))
                  (QREFELT |$| 12))
                |GCDDOM-;lcm;3S;1|)
              (EXIT 
                (COND 
                  ((QEQCAR LCM 0) (SPADCALL |x| (QCDR LCM) (QREFELT |$| 13)))
                  ((QUOTE T) (|error| "bad gcd in lcm computation"))))))))))) 

(DEFUN |GCDDOM-;lcm;LS;2| (|l| |$|) 
  (SPADCALL 
    (ELT |$| 15)
    |l|
    (|spadConstant| |$| 16)
    (|spadConstant| |$| 7)
    (QREFELT |$| 19))) 

(DEFUN |GCDDOM-;gcd;LS;3| (|l| |$|) 
  (SPADCALL 
    (ELT |$| 10)
    |l|
    (|spadConstant| |$| 7)
    (|spadConstant| |$| 16)
    (QREFELT |$| 19))) 

(DEFUN |GCDDOM-;gcdPolynomial;3Sup;4| (|p1| |p2| |$|) 
  (PROG (|e2| |e1| |c1| |p| |c2| #1=#:G83191) 
    (RETURN 
      (SEQ 
        (COND 
          ((SPADCALL |p1| (QREFELT |$| 24)) (SPADCALL |p2| (QREFELT |$| 25)))
          ((SPADCALL |p2| (QREFELT |$| 24)) (SPADCALL |p1| (QREFELT |$| 25)))
          ((QUOTE T) 
            (SEQ 
              (LETT |c1| 
                (SPADCALL |p1| (QREFELT |$| 26))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (LETT |c2| 
                (SPADCALL |p2| (QREFELT |$| 26))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (LETT |p1| 
                (PROG2 
                  (LETT #1# 
                    (SPADCALL |p1| |c1| (QREFELT |$| 27))
                    |GCDDOM-;gcdPolynomial;3Sup;4|)
                  (QCDR #1#)
                  (|check-union| 
                    (QEQCAR #1# 0)
                    (|SparseUnivariatePolynomial| (QREFELT |$| 6))
                    #1#))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (LETT |p2| 
                (PROG2 
                  (LETT #1# 
                    (SPADCALL |p2| |c2| (QREFELT |$| 27))
                    |GCDDOM-;gcdPolynomial;3Sup;4|)
                  (QCDR #1#)
                  (|check-union| 
                    (QEQCAR #1# 0)
                    (|SparseUnivariatePolynomial| (QREFELT |$| 6))
                    #1#))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (SEQ 
                (LETT |e1| 
                  (SPADCALL |p1| (QREFELT |$| 29))
                  |GCDDOM-;gcdPolynomial;3Sup;4|)
                (EXIT 
                  (COND 
                    ((|<| 0 |e1|)
                      (LETT |p1| 
                        (PROG2 
                          (LETT #1# 
                            (SPADCALL |p1| 
                              (SPADCALL 
                               (|spadConstant| |$| 16) |e1| (QREFELT |$| 32))
                              (QREFELT |$| 33))
                            |GCDDOM-;gcdPolynomial;3Sup;4|)
                          (QCDR #1#)
                          (|check-union| 
                            (QEQCAR #1# 0)
                            (|SparseUnivariatePolynomial| (QREFELT |$| 6))
                            #1#))
                        |GCDDOM-;gcdPolynomial;3Sup;4|)))))
              (SEQ 
                (LETT |e2| 
                  (SPADCALL |p2| (QREFELT |$| 29))
                  |GCDDOM-;gcdPolynomial;3Sup;4|)
                (EXIT 
                  (COND 
                    ((|<| 0 |e2|)
                      (LETT |p2| 
                        (PROG2 
                          (LETT #1# 
                            (SPADCALL |p2| 
                              (SPADCALL 
                                (|spadConstant| |$| 16)
                                |e2|
                                (QREFELT |$| 32)) 
                              (QREFELT |$| 33)) 
                            |GCDDOM-;gcdPolynomial;3Sup;4|)
                          (QCDR #1#)
                          (|check-union| 
                            (QEQCAR #1# 0)
                            (|SparseUnivariatePolynomial| (QREFELT |$| 6))
                            #1#))
                        |GCDDOM-;gcdPolynomial;3Sup;4|)))))
              (LETT |e1| 
                (MIN |e1| |e2|)
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (LETT |c1| 
                (SPADCALL |c1| |c2| (QREFELT |$| 10))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (LETT |p1| 
                (COND 
                  ((OR 
                       (EQL (SPADCALL |p1| (QREFELT |$| 34)) 0)
                       (EQL (SPADCALL |p2| (QREFELT |$| 34)) 0))
                     (SPADCALL |c1| 0 (QREFELT |$| 32))) 
                  ((QUOTE T) 
                    (SEQ 
                      (LETT |p| 
                        (SPADCALL |p1| |p2| (QREFELT |$| 35))
                        |GCDDOM-;gcdPolynomial;3Sup;4|)
                      (EXIT 
                        (COND 
                          ((EQL (SPADCALL |p| (QREFELT |$| 34)) 0)
                            (SPADCALL |c1| 0 (QREFELT |$| 32)))
                          ((QUOTE T) 
                            (SEQ 
                              (LETT |c2| 
                                (SPADCALL 
                                  (SPADCALL |p1| (QREFELT |$| 36))
                                  (SPADCALL |p2| (QREFELT |$| 36))
                                  (QREFELT |$| 10))
                                |GCDDOM-;gcdPolynomial;3Sup;4|)
                              (EXIT 
                                (SPADCALL 
                                  (SPADCALL |c1| 
                                    (SPADCALL 
                                      (PROG2 
                                        (LETT #1# 
                                          (SPADCALL 
                                            (SPADCALL 
                                              |c2| 
                                              |p| 
                                              (QREFELT |$| 37)) 
                                            (SPADCALL |p| (QREFELT |$| 36))
                                            (QREFELT |$| 27))
                                          |GCDDOM-;gcdPolynomial;3Sup;4|) 
                                       (QCDR #1#)
                                       (|check-union| 
                                         (QEQCAR #1# 0)
                                         (|SparseUnivariatePolynomial| 
                                           (QREFELT |$| 6))
                                         #1#)) 
                                      (QREFELT |$| 38))
                                    (QREFELT |$| 37))
                                  (QREFELT |$| 25))))))))))
                |GCDDOM-;gcdPolynomial;3Sup;4|)
              (EXIT
               (COND
                ((ZEROP |e1|) |p1|)
                ((QUOTE T)
                  (SPADCALL
                   (SPADCALL (|spadConstant| |$| 16) |e1| (QREFELT |$| 32))
                   |p1| (QREFELT |$| 39)))))))))))) 

(DEFUN |GcdDomain&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|GcdDomain&|))
        (LETT |dv$| (LIST (QUOTE |GcdDomain&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 42) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |GcdDomain&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |Zero|)
        (|Boolean|)
        (4 . |=|)
        (10 . |gcd|)
        (|Union| |$| (QUOTE "failed"))
        (16 . |exquo|)
        (22 . |*|)
        |GCDDOM-;lcm;3S;1| 
        (28 . |lcm|)
        (34 . |One|)
        (|Mapping| 6 6 6)
        (|List| 6)
        (38 . |reduce|)
        (|List| |$|)
        |GCDDOM-;lcm;LS;2| 
        |GCDDOM-;gcd;LS;3| 
        (|SparseUnivariatePolynomial| 6)
        (46 . |zero?|)
        (51 . |unitCanonical|)
        (56 . |content|)
        (61 . |exquo|)
        (|NonNegativeInteger|)
        (67 . |minimumDegree|)
        (72 . |Zero|)
        (76 . |One|)
        (80 . |monomial|)
        (86 . |exquo|)
        (92 . |degree|)
        (97 . |subResultantGcd|)
        (103 . |leadingCoefficient|)
        (108 . |*|)
        (114 . |primitivePart|)
        (119 . |*|)
        (|SparseUnivariatePolynomial| |$|)
        |GCDDOM-;gcdPolynomial;3Sup;4|)) 
    (QUOTE #(|lcm| 125 |gcdPolynomial| 136 |gcd| 142))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #()) 
            (|makeByteWordVec2| 41 
             (QUOTE (0 6 0 7 2 6 8 0 0 9 2 6 0 0 0 10 2 6 11 0 0 12 2 6 0 0 0
                     13 2 6 0 0 0 15 0 6 0 16 4 18 6 17 0 6 6 19 1 23 8 0 24
                     1 23 0 0 25 1 23 6 0 26 2 23 11 0 6 27 1 23 28 0 29 0 23
                     0 30 0 23 0 31 2 23 0 6 28 32 2 23 11 0 0 33 1 23 28 0
                     34 2 23 0 0 0 35 1 23 6 0 36 2 23 0 6 0 37 1 23 0 0 38 2
                     23 0 0 0 39 1 0 0 20 21 2 0 0 0 0 14 2 0 40 40 40 41 1 0
                     0 20 22)))))) 
   (QUOTE |lookupComplete|))) 

@
\section{HOAGG.lsp BOOTSTRAP}
{\bf HOAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf HOAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf HOAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<HOAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |HomogeneousAggregate;CAT| (QUOTE NIL)) 

(SETQ |HomogeneousAggregate;AL| (QUOTE NIL)) 

(DEFUN |HomogeneousAggregate| (#1=#:G82375) 
  (LET (#2=#:G82376) 
    (COND 
      ((SETQ #2# (|assoc| (|devaluate| #1#) |HomogeneousAggregate;AL|))
        (CDR #2#))
      (T 
        (SETQ |HomogeneousAggregate;AL| 
          (|cons5| 
            (CONS (|devaluate| #1#) (SETQ #2# (|HomogeneousAggregate;| #1#)))
            |HomogeneousAggregate;AL|))
        #2#)))) 

(DEFUN |HomogeneousAggregate;| (|t#1|) 
  (PROG (#1=#:G82374) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|sublisV| 
            (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
            (COND 
              (|HomogeneousAggregate;CAT|)
              ((QUOTE T) 
                (LETT |HomogeneousAggregate;CAT| 
                  (|Join| 
                    (|Aggregate|)
                    (|mkCategory| 
                      (QUOTE |domain|) 
                      (QUOTE (
                        ((|map| (|$| (|Mapping| |t#1| |t#1|) |$|)) T)
                        ((|map!| (|$| (|Mapping| |t#1| |t#1|) |$|)) 
                          (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
                        ((|any?| 
                           ((|Boolean|) (|Mapping| (|Boolean|) |t#1|) |$|))
                          (|has| |$| (ATTRIBUTE |finiteAggregate|)))
                        ((|every?| 
                           ((|Boolean|) (|Mapping| (|Boolean|) |t#1|) |$|))
                          (|has| |$| (ATTRIBUTE |finiteAggregate|)))
                        ((|count| 
                           ((|NonNegativeInteger|)
                            (|Mapping| (|Boolean|) |t#1|) |$|))
                          (|has| |$| (ATTRIBUTE |finiteAggregate|)))
                        ((|parts| ((|List| |t#1|) |$|))
                          (|has| |$| (ATTRIBUTE |finiteAggregate|)))
                        ((|members| ((|List| |t#1|) |$|))
                          (|has| |$| (ATTRIBUTE |finiteAggregate|)))
                        ((|count| ((|NonNegativeInteger|) |t#1| |$|))
                          (AND 
                            (|has| |t#1| (|SetCategory|))
                            (|has| |$| (ATTRIBUTE |finiteAggregate|))))
                        ((|member?| ((|Boolean|) |t#1| |$|))
                          (AND 
                            (|has| |t#1| (|SetCategory|))
                            (|has| |$| (ATTRIBUTE |finiteAggregate|)))))) 
                     (QUOTE (
                      ((|SetCategory|) (|has| |t#1| (|SetCategory|)))
                      ((|Evalable| |t#1|)
                        (AND 
                          (|has| |t#1| (|Evalable| |t#1|))
                          (|has| |t#1| (|SetCategory|)))))) 
                    (QUOTE (
                      (|Boolean|)
                      (|NonNegativeInteger|)
                      (|List| |t#1|)))
                    NIL))
                . #2=(|HomogeneousAggregate|))))) . #2#)
        (SETELT #1# 0 
          (LIST (QUOTE |HomogeneousAggregate|) (|devaluate| |t#1|))))))) 

@
\section{HOAGG-.lsp BOOTSTRAP}
{\bf HOAGG-} depends on {\bf HOAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf HOAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf HOAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<HOAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |HOAGG-;eval;ALA;1| (|u| |l| |$|) 
 (SPADCALL
  (CONS (FUNCTION |HOAGG-;eval;ALA;1!0|) (VECTOR |$| |l|))
  |u|
  (QREFELT |$| 11))) 

(DEFUN |HOAGG-;eval;ALA;1!0| (|#1| |$$|)
 (SPADCALL |#1| (QREFELT |$$| 1) (QREFELT (QREFELT |$$| 0) 9))) 

(DEFUN |HOAGG-;#;ANni;2| (|c| |$|)
 (LENGTH (SPADCALL |c| (QREFELT |$| 14)))) 

(DEFUN |HOAGG-;any?;MAB;3| (|f| |c| |$|)
 (PROG (|x| #1=#:G82396 #2=#:G82393 #3=#:G82391 #4=#:G82392)
  (RETURN 
   (SEQ
    (PROGN
     (LETT #4# NIL |HOAGG-;any?;MAB;3|)
     (SEQ
      (LETT |x| NIL |HOAGG-;any?;MAB;3|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 14)) |HOAGG-;any?;MAB;3|)
      G190
      (COND
       ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |HOAGG-;any?;MAB;3|) NIL))
        (GO G191)))
      (SEQ
       (EXIT
        (PROGN
         (LETT #2# (SPADCALL |x| |f|) |HOAGG-;any?;MAB;3|)
         (COND
          (#4#
           (LETT #3#
             (COND 
              (#3# (QUOTE T))
              ((QUOTE T) #2#))
             |HOAGG-;any?;MAB;3|))
          ((QUOTE T)
           (PROGN
            (LETT #3# #2# |HOAGG-;any?;MAB;3|)
            (LETT #4# (QUOTE T) |HOAGG-;any?;MAB;3|)))))))
      (LETT #1# (CDR #1#) |HOAGG-;any?;MAB;3|) (GO G190) G191 (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) (QUOTE NIL)))))))) 

(DEFUN |HOAGG-;every?;MAB;4| (|f| |c| |$|)
 (PROG (|x| #1=#:G82401 #2=#:G82399 #3=#:G82397 #4=#:G82398)
  (RETURN
   (SEQ
    (PROGN
     (LETT #4# NIL |HOAGG-;every?;MAB;4|)
     (SEQ
      (LETT |x| NIL |HOAGG-;every?;MAB;4|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 14)) |HOAGG-;every?;MAB;4|)
      G190
      (COND
        ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |HOAGG-;every?;MAB;4|) NIL))
         (GO G191)))
      (SEQ
       (EXIT
        (PROGN
         (LETT #2# (SPADCALL |x| |f|) |HOAGG-;every?;MAB;4|)
         (COND
          (#4#
           (LETT #3#
            (COND (#3# #2#) ((QUOTE T) (QUOTE NIL)))
            |HOAGG-;every?;MAB;4|))
          ((QUOTE T)
           (PROGN
            (LETT #3# #2# |HOAGG-;every?;MAB;4|)
            (LETT #4# (QUOTE T) |HOAGG-;every?;MAB;4|)))))))
      (LETT #1# (CDR #1#) |HOAGG-;every?;MAB;4|)
      (GO G190)
      G191
      (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) (QUOTE T)))))))) 

(DEFUN |HOAGG-;count;MANni;5| (|f| |c| |$|)
 (PROG (|x| #1=#:G82406 #2=#:G82404 #3=#:G82402 #4=#:G82403)
  (RETURN
   (SEQ
    (PROGN 
     (LETT #4# NIL |HOAGG-;count;MANni;5|)
     (SEQ
      (LETT |x| NIL |HOAGG-;count;MANni;5|)
      (LETT #1# (SPADCALL |c| (QREFELT |$| 14)) |HOAGG-;count;MANni;5|)
      G190
      (COND
       ((OR (ATOM #1#) (PROGN (LETT |x| (CAR #1#) |HOAGG-;count;MANni;5|) NIL))
        (GO G191)))
      (SEQ 
       (EXIT
        (COND
         ((SPADCALL |x| |f|)
          (PROGN
           (LETT #2# 1 |HOAGG-;count;MANni;5|)
           (COND
            (#4# (LETT #3# (|+| #3# #2#) |HOAGG-;count;MANni;5|))
            ((QUOTE T)
             (PROGN
              (LETT #3# #2# |HOAGG-;count;MANni;5|)
              (LETT #4# (QUOTE T) |HOAGG-;count;MANni;5|)))))))))
      (LETT #1# (CDR #1#) |HOAGG-;count;MANni;5|)
      (GO G190)
      G191
      (EXIT NIL))
     (COND (#4# #3#) ((QUOTE T) 0))))))) 

(DEFUN |HOAGG-;members;AL;6| (|x| |$|) (SPADCALL |x| (QREFELT |$| 14))) 

(DEFUN |HOAGG-;count;SANni;7| (|s| |x| |$|)
 (SPADCALL
  (CONS (FUNCTION |HOAGG-;count;SANni;7!0|) (VECTOR |$| |s|))
  |x|
  (QREFELT |$| 24))) 

(DEFUN |HOAGG-;count;SANni;7!0| (|#1| |$$|)
 (SPADCALL (QREFELT |$$| 1) |#1| (QREFELT (QREFELT |$$| 0) 23))) 

(DEFUN |HOAGG-;member?;SAB;8| (|e| |c| |$|)
 (SPADCALL
  (CONS (FUNCTION |HOAGG-;member?;SAB;8!0|) (VECTOR |$| |e|))
  |c|
  (QREFELT |$| 26))) 

(DEFUN |HOAGG-;member?;SAB;8!0| (|#1| |$$|)
 (SPADCALL (QREFELT |$$| 1) |#1| (QREFELT (QREFELT |$$| 0) 23))) 

(DEFUN |HOAGG-;=;2AB;9| (|x| |y| |$|)
 (PROG (|b| #1=#:G82416 |a| #2=#:G82415 #3=#:G82412 #4=#:G82410 #5=#:G82411)
  (RETURN 
   (SEQ 
    (COND
     ((SPADCALL |x| (SPADCALL |y| (QREFELT |$| 28)) (QREFELT |$| 29))
      (PROGN
       (LETT #5# NIL |HOAGG-;=;2AB;9|)
       (SEQ
        (LETT |b| NIL |HOAGG-;=;2AB;9|)
        (LETT #1# (SPADCALL |y| (QREFELT |$| 14)) |HOAGG-;=;2AB;9|)
        (LETT |a| NIL |HOAGG-;=;2AB;9|)
        (LETT #2# (SPADCALL |x| (QREFELT |$| 14)) |HOAGG-;=;2AB;9|)
        G190
        (COND
         ((OR
           (ATOM #2#)
           (PROGN (LETT |a| (CAR #2#) |HOAGG-;=;2AB;9|) NIL)
           (ATOM #1#)
           (PROGN (LETT |b| (CAR #1#) |HOAGG-;=;2AB;9|) NIL))
          (GO G191)))
        (SEQ
         (EXIT
          (PROGN
           (LETT #3# (SPADCALL |a| |b| (QREFELT |$| 23)) |HOAGG-;=;2AB;9|)
           (COND
             (#5#
              (LETT #4#
               (COND (#4# #3#) ((QUOTE T) (QUOTE NIL)))
               |HOAGG-;=;2AB;9|))
             ((QUOTE T)
              (PROGN
               (LETT #4# #3# |HOAGG-;=;2AB;9|)
               (LETT #5# (QUOTE T) |HOAGG-;=;2AB;9|)))))))
        (LETT #2#
         (PROG1
          (CDR #2#)
          (LETT #1# (CDR #1#) |HOAGG-;=;2AB;9|))
         |HOAGG-;=;2AB;9|)
        (GO G190)
        G191
        (EXIT NIL))
       (COND (#5# #4#) ((QUOTE T) (QUOTE T)))))
     ((QUOTE T) (QUOTE NIL))))))) 

(DEFUN |HOAGG-;coerce;AOf;10| (|x| |$|)
 (PROG (#1=#:G82420 |a| #2=#:G82421)
  (RETURN
   (SEQ
    (SPADCALL
     (SPADCALL
      (PROGN
       (LETT #1# NIL |HOAGG-;coerce;AOf;10|)
       (SEQ
        (LETT |a| NIL |HOAGG-;coerce;AOf;10|)
        (LETT #2# (SPADCALL |x| (QREFELT |$| 14)) |HOAGG-;coerce;AOf;10|)
        G190
        (COND
         ((OR
           (ATOM #2#)
           (PROGN (LETT |a| (CAR #2#) |HOAGG-;coerce;AOf;10|) NIL))
          (GO G191)))
        (SEQ
         (EXIT
          (LETT #1#
           (CONS (SPADCALL |a| (QREFELT |$| 32)) #1#)
           |HOAGG-;coerce;AOf;10|)))
        (LETT #2# (CDR #2#) |HOAGG-;coerce;AOf;10|)
        (GO G190)
        G191
        (EXIT (NREVERSE0 #1#))))
      (QREFELT |$| 34))
     (QREFELT |$| 35)))))) 

(DEFUN |HomogeneousAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|HomogeneousAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |HomogeneousAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 38) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0
       (LIST
        (|HasAttribute| |#1| (QUOTE |finiteAggregate|))
        (|HasAttribute| |#1| (QUOTE |shallowlyMutable|))
        (|HasCategory| |#2| (LIST (QUOTE |Evalable|) (|devaluate| |#2|)))
        (|HasCategory| |#2| (QUOTE (|SetCategory|)))))
      . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
     ((|testBitVector| |pv$| 3)
       (QSETREFV |$| 12 (CONS (|dispatchFunction| |HOAGG-;eval;ALA;1|) |$|))))
    (COND
     ((|testBitVector| |pv$| 1)
      (PROGN
       (QSETREFV |$| 16 (CONS (|dispatchFunction| |HOAGG-;#;ANni;2|) |$|))
       (QSETREFV |$| 19 (CONS (|dispatchFunction| |HOAGG-;any?;MAB;3|) |$|))
       (QSETREFV |$| 20 (CONS (|dispatchFunction| |HOAGG-;every?;MAB;4|) |$|))
       (QSETREFV |$| 21 (CONS (|dispatchFunction| |HOAGG-;count;MANni;5|) |$|))
       (QSETREFV |$| 22 (CONS (|dispatchFunction| |HOAGG-;members;AL;6|) |$|))
       (COND
        ((|testBitVector| |pv$| 4)
         (PROGN
          (QSETREFV |$| 25
           (CONS (|dispatchFunction| |HOAGG-;count;SANni;7|) |$|))
          (QSETREFV |$| 27
           (CONS (|dispatchFunction| |HOAGG-;member?;SAB;8|) |$|))
          (QSETREFV |$| 30
           (CONS (|dispatchFunction| |HOAGG-;=;2AB;9|) |$|))
          (QSETREFV |$| 36
           (CONS (|dispatchFunction| |HOAGG-;coerce;AOf;10|) |$|))))))))
    |$|)))) 

(MAKEPROP
 (QUOTE |HomogeneousAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|List| 37) 
   (0 . |eval|) (|Mapping| 7 7) (6 . |map|) (12 . |eval|) (|List| 7) 
   (18 . |parts|) (|NonNegativeInteger|) (23 . |#|) (|Boolean|) 
   (|Mapping| 17 7) (28 . |any?|) (34 . |every?|) (40 . |count|) 
   (46 . |members|) (51 . |=|) (57 . |count|) (63 . |count|) (69 . |any?|) 
   (75 . |member?|) (81 . |#|) (86 . |size?|) (92 . |=|) (|OutputForm|) 
   (98 . |coerce|) (|List| |$|) (103 . |commaSeparate|) (108 . |bracket|) 
   (113 . |coerce|) (|Equation| 7)))
  (QUOTE #(|members| 118 |member?| 123 |every?| 129 |eval| 135 |count| 141 
   |coerce| 153 |any?| 158 |=| 164 |#| 170))
  (QUOTE NIL)
  (CONS 
   (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS 
    (QUOTE #())
    (CONS 
     (QUOTE #())
     (|makeByteWordVec2| 36 
      (QUOTE (2 7 0 0 8 9 2 6 0 10 0 11 2 0 0 0 8 12 1 6 13 0 14 1 0 15 0 
        16 2 0 17 18 0 19 2 0 17 18 0 20 2 0 15 18 0 21 1 0 13 0 22 2 7 17 
        0 0 23 2 6 15 18 0 24 2 0 15 7 0 25 2 6 17 18 0 26 2 0 17 7 0 27 1 
        6 15 0 28 2 6 17 0 15 29 2 0 17 0 0 30 1 7 31 0 32 1 31 0 33 34 1 
        31 0 0 35 1 0 31 0 36 1 0 13 0 22 2 0 17 7 0 27 2 0 17 18 0 20 2 0 
        0 0 8 12 2 0 15 7 0 25 2 0 15 18 0 21 1 0 31 0 36 2 0 17 18 0 19 2 
        0 17 0 0 30 1 0 15 0 16))))))
  (QUOTE |lookupComplete|))) 
@
\section{INTDOM.lsp BOOTSTRAP}
{\bf INTDOM} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf INTDOM}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf INTDOM.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<INTDOM.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |IntegralDomain;AL| (QUOTE NIL)) 

(DEFUN |IntegralDomain| NIL 
  (LET (#:G83060) 
    (COND 
      (|IntegralDomain;AL|) 
      (T (SETQ |IntegralDomain;AL| (|IntegralDomain;|)))))) 

(DEFUN |IntegralDomain;| NIL 
  (PROG (#1=#:G83058) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|CommutativeRing|)
            (|Algebra| (QUOTE |$|))
            (|EntireRing|)
            (|mkCategory| 
              (QUOTE |domain|) 
              (QUOTE (
                ((|exquo| ((|Union| |$| "failed") |$| |$|)) T)
                ((|unitNormal| 
                  ((|Record| 
                     (|:| |unit| |$|) 
                     (|:| |canonical| |$|)
                     (|:| |associate| |$|)) |$|)) T)
                ((|unitCanonical| (|$| |$|)) T)
                ((|associates?| ((|Boolean|) |$| |$|)) T)
                ((|unit?| ((|Boolean|) |$|)) T)))
               NIL
               (QUOTE ((|Boolean|)))
               NIL))
           |IntegralDomain|)
        (SETELT #1# 0 (QUOTE (|IntegralDomain|))))))) 

(MAKEPROP (QUOTE |IntegralDomain|) (QUOTE NILADIC) T) 

@
\section{INTDOM-.lsp BOOTSTRAP}
{\bf INTDOM-} depends on {\bf INTDOM}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf INTDOM-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf INTDOM-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<INTDOM-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |INTDOM-;unitNormal;SR;1| (|x| |$|) 
  (VECTOR (|spadConstant| |$| 7) |x| (|spadConstant| |$| 7))) 

(DEFUN |INTDOM-;unitCanonical;2S;2| (|x| |$|) 
  (QVELT (SPADCALL |x| (QREFELT |$| 10)) 1)) 

(DEFUN |INTDOM-;recip;SU;3| (|x| |$|) 
  (COND 
    ((SPADCALL |x| (QREFELT |$| 13)) (CONS 1 "failed"))
    ((QUOTE T) (SPADCALL (|spadConstant| |$| 7) |x| (QREFELT |$| 15))))) 

(DEFUN |INTDOM-;unit?;SB;4| (|x| |$|) 
  (COND 
    ((QEQCAR (SPADCALL |x| (QREFELT |$| 17)) 1) (QUOTE NIL))
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |INTDOM-;associates?;2SB;5| (|x| |y| |$|) 
  (SPADCALL 
    (QVELT (SPADCALL |x| (QREFELT |$| 10)) 1)
    (QVELT (SPADCALL |y| (QREFELT |$| 10)) 1)
    (QREFELT |$| 19))) 

(DEFUN |INTDOM-;associates?;2SB;6| (|x| |y| |$|) 
  (COND 
    ((SPADCALL |x| (QREFELT |$| 13)) (SPADCALL |y| (QREFELT |$| 13)))
    ((OR 
        (SPADCALL |y| (QREFELT |$| 13))
        (OR 
          (QEQCAR (SPADCALL |x| |y| (QREFELT |$| 15)) 1)
          (QEQCAR (SPADCALL |y| |x| (QREFELT |$| 15)) 1)))
      (QUOTE NIL))
    ((QUOTE T) (QUOTE T)))) 

(DEFUN |IntegralDomain&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|IntegralDomain&|))
        (LETT |dv$| (LIST (QUOTE |IntegralDomain&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 21) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        (COND 
          ((|HasCategory| |#1| (QUOTE (|Field|))))
          ((QUOTE T) 
            (QSETREFV |$| 9 
              (CONS (|dispatchFunction| |INTDOM-;unitNormal;SR;1|) |$|))))
        (COND 
          ((|HasAttribute| |#1| (QUOTE |canonicalUnitNormal|))
            (QSETREFV |$| 20 
              (CONS (|dispatchFunction| |INTDOM-;associates?;2SB;5|) |$|)))
          ((QUOTE T) 
            (QSETREFV |$| 20 
              (CONS (|dispatchFunction| |INTDOM-;associates?;2SB;6|) |$|))))
        |$|)))) 

(MAKEPROP 
  (QUOTE |IntegralDomain&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |One|)
        (|Record| 
          (|:| |unit| |$|)
          (|:| |canonical| |$|)
          (|:| |associate| |$|))
        (4 . |unitNormal|)
        (9 . |unitNormal|)
        |INTDOM-;unitCanonical;2S;2| 
        (|Boolean|)
        (14 . |zero?|)
        (|Union| |$| (QUOTE "failed"))
        (19 . |exquo|)
        |INTDOM-;recip;SU;3|
        (25 . |recip|)
        |INTDOM-;unit?;SB;4|
        (30 . |=|)
        (36 . |associates?|))) 
    (QUOTE 
      #(|unitNormal| 42 |unitCanonical| 47 |unit?| 52 |recip| 57 
        |associates?| 62)) 
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 20 
            (QUOTE 
              (0 6 0 7 1 0 8 0 9 1 6 8 0 10 1 6 12 0 13 2 6 14 0 0 15 1 6 14
               0 17 2 6 12 0 0 19 2 0 12 0 0 20 1 0 8 0 9 1 0 0 0 11 1 0 12 0
               18 1 0 14 0 16 2 0 12 0 0 20)))))) 
   (QUOTE |lookupComplete|))) 

@
\section{LNAGG.lsp BOOTSTRAP}
{\bf LNAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf LNAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf LNAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<LNAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |LinearAggregate;CAT| (QUOTE NIL)) 

(SETQ |LinearAggregate;AL| (QUOTE NIL)) 

(DEFUN |LinearAggregate| (#1=#:G85818)
 (LET (#2=#:G85819)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |LinearAggregate;AL|)) (CDR #2#))
   (T
    (SETQ |LinearAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|LinearAggregate;| #1#)))
      |LinearAggregate;AL|))
    #2#)))) 

(DEFUN |LinearAggregate;| (|t#1|)
 (PROG (#1=#:G85817)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (|sublisV|
       (PAIR (QUOTE (#2=#:G85816)) (LIST (QUOTE (|Integer|))))
       (COND
        (|LinearAggregate;CAT|)
        ((QUOTE T)
         (LETT |LinearAggregate;CAT|
          (|Join|
           (|IndexedAggregate| (QUOTE #2#) (QUOTE |t#1|))
           (|Collection| (QUOTE |t#1|))
           (|mkCategory|
            (QUOTE |domain|)
            (QUOTE (
             ((|new| (|$| (|NonNegativeInteger|) |t#1|)) T)
             ((|concat| (|$| |$| |t#1|)) T)
             ((|concat| (|$| |t#1| |$|)) T)
             ((|concat| (|$| |$| |$|)) T)
             ((|concat| (|$| (|List| |$|))) T)
             ((|map| (|$| (|Mapping| |t#1| |t#1| |t#1|) |$| |$|)) T)
             ((|elt| (|$| |$| (|UniversalSegment| (|Integer|)))) T)
             ((|delete| (|$| |$| (|Integer|))) T)
             ((|delete| (|$| |$| (|UniversalSegment| (|Integer|)))) T)
             ((|insert| (|$| |t#1| |$| (|Integer|))) T)
             ((|insert| (|$| |$| |$| (|Integer|))) T)
             ((|setelt| (|t#1| |$| (|UniversalSegment| (|Integer|)) |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))))
            NIL
            (QUOTE (
              (|UniversalSegment| (|Integer|))
              (|Integer|)
              (|List| |$|)
              (|NonNegativeInteger|)))
             NIL))
          . #3=(|LinearAggregate|))))))
      . #3#)
     (SETELT #1# 0 (LIST (QUOTE |LinearAggregate|) (|devaluate| |t#1|))))))) 
@
\section{LNAGG-.lsp BOOTSTRAP}
{\bf LNAGG-} depends on {\bf LNAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf LNAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf LNAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<LNAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |LNAGG-;indices;AL;1| (|a| |$|)
 (PROG (#1=#:G85833 |i| #2=#:G85834)
  (RETURN
   (SEQ
    (PROGN
     (LETT #1# NIL |LNAGG-;indices;AL;1|)
     (SEQ
      (LETT |i| (SPADCALL |a| (QREFELT |$| 9)) |LNAGG-;indices;AL;1|)
      (LETT #2# (SPADCALL |a| (QREFELT |$| 10)) |LNAGG-;indices;AL;1|)
      G190
      (COND ((|>| |i| #2#) (GO G191)))
      (SEQ (EXIT (LETT #1# (CONS |i| #1#) |LNAGG-;indices;AL;1|)))
      (LETT |i| (|+| |i| 1) |LNAGG-;indices;AL;1|)
      (GO G190)
      G191
      (EXIT (NREVERSE0 #1#)))))))) 

(DEFUN |LNAGG-;index?;IAB;2| (|i| |a| |$|)
 (COND
  ((OR 
     (|<| |i| (SPADCALL |a| (QREFELT |$| 9)))
     (|<| (SPADCALL |a| (QREFELT |$| 10)) |i|))
    (QUOTE NIL))
  ((QUOTE T) (QUOTE T)))) 

(DEFUN |LNAGG-;concat;ASA;3| (|a| |x| |$|)
 (SPADCALL |a| (SPADCALL 1 |x| (QREFELT |$| 16)) (QREFELT |$| 17))) 

(DEFUN |LNAGG-;concat;S2A;4| (|x| |y| |$|)
 (SPADCALL (SPADCALL 1 |x| (QREFELT |$| 16)) |y| (QREFELT |$| 17))) 

(DEFUN |LNAGG-;insert;SAIA;5| (|x| |a| |i| |$|)
 (SPADCALL (SPADCALL 1 |x| (QREFELT |$| 16)) |a| |i| (QREFELT |$| 20))) 

(DEFUN |LNAGG-;maxIndex;AI;6| (|l| |$|)
 (|+| (|-| (SPADCALL |l| (QREFELT |$| 22)) 1) (SPADCALL |l| (QREFELT |$| 9)))) 

(DEFUN |LinearAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|LinearAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |LinearAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 25) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0
       (LIST (|HasAttribute| |#1| (QUOTE |shallowlyMutable|))))
      . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND 
     ((|HasAttribute| |#1| (QUOTE |finiteAggregate|))
      (QSETREFV |$| 23
       (CONS (|dispatchFunction| |LNAGG-;maxIndex;AI;6|) |$|))))
    |$|)))) 

(MAKEPROP
 (QUOTE |LinearAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) (|Integer|) 
    (0 . |minIndex|) (5 . |maxIndex|) (|List| 8) |LNAGG-;indices;AL;1| 
    (|Boolean|) |LNAGG-;index?;IAB;2| (|NonNegativeInteger|) (10 . |new|) 
    (16 . |concat|) |LNAGG-;concat;ASA;3| |LNAGG-;concat;S2A;4| 
    (22 . |insert|) |LNAGG-;insert;SAIA;5| (29 . |#|) (34 . |maxIndex|) 
    (|List| |$|)))
  (QUOTE #(|maxIndex| 39 |insert| 44 |indices| 51 |index?| 56 |concat| 62))
  (QUOTE NIL)
  (CONS 
   (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS
    (QUOTE #())
    (CONS
     (QUOTE #())
     (|makeByteWordVec2| 23 (QUOTE (1 6 8 0 9 1 6 8 0 10 2 6 0 15 7 
      16 2 6 0 0 0 17 3 6 0 0 0 8 20 1 6 15 0 22 1 0 8 0 23 1 0 8 0 23 3 0 
      0 7 0 8 21 1 0 11 0 12 2 0 13 8 0 14 2 0 0 0 7 18 2 0 0 7 0 19))))))
  (QUOTE |lookupComplete|))) 
@
\section{LSAGG.lsp BOOTSTRAP}
{\bf LSAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf LSAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf LSAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<LSAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |ListAggregate;CAT| (QUOTE NIL)) 

(SETQ |ListAggregate;AL| (QUOTE NIL)) 

(DEFUN |ListAggregate| (#1=#:G87500)
 (LET (#2=#:G87501)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |ListAggregate;AL|)) (CDR #2#))
   (T
    (SETQ |ListAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|ListAggregate;| #1#)))
      |ListAggregate;AL|))
    #2#)))) 

(DEFUN |ListAggregate;| (|t#1|)
 (PROG (#1=#:G87499)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|ListAggregate;CAT|)
       ((QUOTE T)
        (LETT |ListAggregate;CAT|
         (|Join|
          (|StreamAggregate| (QUOTE |t#1|))
          (|FiniteLinearAggregate| (QUOTE |t#1|))
          (|ExtensibleLinearAggregate| (QUOTE |t#1|))
          (|mkCategory|
           (QUOTE |domain|)
           (QUOTE (((|list| (|$| |t#1|)) T)))
           NIL
           (QUOTE NIL)
            NIL))
          . #2=(|ListAggregate|)))))
     . #2#)
    (SETELT #1# 0 (LIST (QUOTE |ListAggregate|) (|devaluate| |t#1|))))))) 
@
\section{LSAGG-.lsp BOOTSTRAP}
{\bf LSAGG-} depends on {\bf LSAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf LSAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf LSAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<LSAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |LSAGG-;sort!;M2A;1| (|f| |l| |$|)
 (|LSAGG-;mergeSort| |f| |l| (SPADCALL |l| (QREFELT |$| 9)) |$|)) 

(DEFUN |LSAGG-;list;SA;2| (|x| |$|)
 (SPADCALL |x| (SPADCALL (QREFELT |$| 12)) (QREFELT |$| 13))) 

(DEFUN |LSAGG-;reduce;MAS;3| (|f| |x| |$|)
 (COND
  ((SPADCALL |x| (QREFELT |$| 16))
    (|error| "reducing over an empty list needs the 3 argument form"))
  ((QUOTE T) 
    (SPADCALL |f|
     (SPADCALL |x| (QREFELT |$| 17))
     (SPADCALL |x| (QREFELT |$| 18))
     (QREFELT |$| 20))))) 

(DEFUN |LSAGG-;merge;M3A;4| (|f| |p| |q| |$|)
 (SPADCALL |f|
  (SPADCALL |p| (QREFELT |$| 22))
  (SPADCALL |q| (QREFELT |$| 22))
  (QREFELT |$| 23))) 

(DEFUN |LSAGG-;select!;M2A;5| (|f| |x| |$|)
 (PROG (|y| |z|)
  (RETURN
   (SEQ
    (SEQ G190
     (COND
      ((NULL
        (COND
         ((OR
           (SPADCALL |x| (QREFELT |$| 16))
           (SPADCALL (SPADCALL |x| (QREFELT |$| 18)) |f|))
          (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (EXIT
       (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;select!;M2A;5|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT
     (COND
      ((SPADCALL |x| (QREFELT |$| 16)) |x|)
      ((QUOTE T)
       (SEQ 
        (LETT |y| |x| |LSAGG-;select!;M2A;5|)
        (LETT |z| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;select!;M2A;5|)
        (SEQ 
         G190
         (COND
          ((NULL
            (COND
             ((SPADCALL |z| (QREFELT |$| 16)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ
          (EXIT
           (COND
            ((SPADCALL (SPADCALL |z| (QREFELT |$| 18)) |f|)
              (SEQ
               (LETT |y| |z| |LSAGG-;select!;M2A;5|)
               (EXIT
                (LETT |z|
                 (SPADCALL |z| (QREFELT |$| 17))
                 |LSAGG-;select!;M2A;5|))))
            ((QUOTE T)
             (SEQ
              (LETT |z| (SPADCALL |z| (QREFELT |$| 17)) |LSAGG-;select!;M2A;5|)
              (EXIT (SPADCALL |y| |z| (QREFELT |$| 25))))))))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
        (EXIT |x|))))))))) 

(DEFUN |LSAGG-;merge!;M3A;6| (|f| |p| |q| |$|)
 (PROG (|r| |t|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |p| (QREFELT |$| 16)) |q|)
     ((SPADCALL |q| (QREFELT |$| 16)) |p|)
     ((SPADCALL |p| |q| (QREFELT |$| 28))
       (|error| "cannot merge a list into itself"))
     ((QUOTE T)
      (SEQ
       (COND 
        ((SPADCALL
          (SPADCALL |p| (QREFELT |$| 18))
          (SPADCALL |q| (QREFELT |$| 18))
          |f|)
         (SEQ
          (LETT |r| (LETT |t| |p| |LSAGG-;merge!;M3A;6|) |LSAGG-;merge!;M3A;6|)
          (EXIT
           (LETT |p| (SPADCALL |p| (QREFELT |$| 17)) |LSAGG-;merge!;M3A;6|))))
        ((QUOTE T)
         (SEQ
          (LETT |r| (LETT |t| |q| |LSAGG-;merge!;M3A;6|) |LSAGG-;merge!;M3A;6|)
          (EXIT
           (LETT |q| (SPADCALL |q| (QREFELT |$| 17)) |LSAGG-;merge!;M3A;6|)))))
       (SEQ 
        G190 
        (COND
         ((NULL
            (COND
             ((OR 
               (SPADCALL |p| (QREFELT |$| 16))
               (SPADCALL |q| (QREFELT |$| 16)))
              (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
          (GO G191)))
        (SEQ
         (EXIT
          (COND
           ((SPADCALL
              (SPADCALL |p| (QREFELT |$| 18))
              (SPADCALL |q| (QREFELT |$| 18))
              |f|)
            (SEQ
             (SPADCALL |t| |p| (QREFELT |$| 25))
             (LETT |t| |p| |LSAGG-;merge!;M3A;6|)
             (EXIT
              (LETT |p|
               (SPADCALL |p| (QREFELT |$| 17))
               |LSAGG-;merge!;M3A;6|))))
           ((QUOTE T)
            (SEQ
             (SPADCALL |t| |q| (QREFELT |$| 25))
             (LETT |t| |q| |LSAGG-;merge!;M3A;6|)
             (EXIT
              (LETT |q|
               (SPADCALL |q| (QREFELT |$| 17))
               |LSAGG-;merge!;M3A;6|)))))))
        NIL
        (GO G190)
        G191
        (EXIT NIL))
       (SPADCALL |t|
        (COND
         ((SPADCALL |p| (QREFELT |$| 16)) |q|)
         ((QUOTE T) |p|))
        (QREFELT |$| 25))
       (EXIT |r|)))))))) 

(DEFUN |LSAGG-;insert!;SAIA;7| (|s| |x| |i| |$|)
 (PROG (|m| #1=#:G87547 |y| |z|)
  (RETURN
   (SEQ
    (LETT |m| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;insert!;SAIA;7|)
    (EXIT
     (COND
      ((|<| |i| |m|) (|error| "index out of range"))
      ((EQL |i| |m|) (SPADCALL |s| |x| (QREFELT |$| 13)))
      ((QUOTE T)
       (SEQ
        (LETT |y|
         (SPADCALL |x|
          (PROG1
           (LETT #1# (|-| (|-| |i| 1) |m|) |LSAGG-;insert!;SAIA;7|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 32))
         |LSAGG-;insert!;SAIA;7|)
        (LETT |z| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;insert!;SAIA;7|)
        (SPADCALL |y| (SPADCALL |s| |z| (QREFELT |$| 13)) (QREFELT |$| 25))
        (EXIT |x|))))))))) 

(DEFUN |LSAGG-;insert!;2AIA;8| (|w| |x| |i| |$|)
 (PROG (|m| #1=#:G87551 |y| |z|)
  (RETURN
   (SEQ
    (LETT |m| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;insert!;2AIA;8|)
    (EXIT
     (COND
      ((|<| |i| |m|) (|error| "index out of range"))
      ((EQL |i| |m|) (SPADCALL |w| |x| (QREFELT |$| 34)))
      ((QUOTE T)
       (SEQ
        (LETT |y|
         (SPADCALL |x|
          (PROG1
           (LETT #1# (|-| (|-| |i| 1) |m|) |LSAGG-;insert!;2AIA;8|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 32))
         |LSAGG-;insert!;2AIA;8|)
        (LETT |z| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;insert!;2AIA;8|)
        (SPADCALL |y| |w| (QREFELT |$| 25))
        (SPADCALL |y| |z| (QREFELT |$| 34))
        (EXIT |x|))))))))) 

(DEFUN |LSAGG-;remove!;M2A;9| (|f| |x| |$|)
 (PROG (|p| |q|)
  (RETURN
   (SEQ
    (SEQ 
     G190 
     (COND
      ((NULL
        (COND
         ((SPADCALL |x| (QREFELT |$| 16)) (QUOTE NIL))
         ((QUOTE T) (SPADCALL (SPADCALL |x| (QREFELT |$| 18)) |f|))))
       (GO G191)))
     (SEQ
      (EXIT
       (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;remove!;M2A;9|)))
      NIL
      (GO G190)
      G191
      (EXIT NIL))
    (EXIT
     (COND
      ((SPADCALL |x| (QREFELT |$| 16)) |x|)
      ((QUOTE T)
       (SEQ
        (LETT |p| |x| |LSAGG-;remove!;M2A;9|)
        (LETT |q| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;remove!;M2A;9|)
        (SEQ
         G190
         (COND
          ((NULL
             (COND 
              ((SPADCALL |q| (QREFELT |$| 16)) (QUOTE NIL))
              ((QUOTE T) (QUOTE T))))
            (GO G191)))
         (SEQ
          (EXIT
           (COND
            ((SPADCALL (SPADCALL |q| (QREFELT |$| 18)) |f|)
              (LETT |q|
               (SPADCALL |p| (SPADCALL |q| (QREFELT |$| 17)) (QREFELT |$| 25))
               |LSAGG-;remove!;M2A;9|))
            ((QUOTE T)
              (SEQ 
               (LETT |p| |q| |LSAGG-;remove!;M2A;9|)
               (EXIT
                (LETT |q|
                  (SPADCALL |q| (QREFELT |$| 17))
                  |LSAGG-;remove!;M2A;9|)))))))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
        (EXIT |x|))))))))) 

(DEFUN |LSAGG-;delete!;AIA;10| (|x| |i| |$|) 
 (PROG (|m| #1=#:G87564 |y|)
  (RETURN
   (SEQ
    (LETT |m| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;delete!;AIA;10|)
    (EXIT
     (COND
      ((|<| |i| |m|) (|error| "index out of range"))
      ((EQL |i| |m|) (SPADCALL |x| (QREFELT |$| 17)))
      ((QUOTE T)
       (SEQ
        (LETT |y|
         (SPADCALL |x|
          (PROG1
           (LETT #1# (|-| (|-| |i| 1) |m|) |LSAGG-;delete!;AIA;10|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 32))
         |LSAGG-;delete!;AIA;10|)
        (SPADCALL |y| (SPADCALL |y| 2 (QREFELT |$| 32)) (QREFELT |$| 25))
        (EXIT |x|))))))))) 

(DEFUN |LSAGG-;delete!;AUsA;11| (|x| |i| |$|)
 (PROG (|l| |m| |h| #1=#:G87569 #2=#:G87570 |t| #3=#:G87571)
  (RETURN
   (SEQ
    (LETT |l| (SPADCALL |i| (QREFELT |$| 39)) |LSAGG-;delete!;AUsA;11|)
    (LETT |m| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;delete!;AUsA;11|)
    (EXIT
     (COND
      ((|<| |l| |m|) (|error| "index out of range"))
      ((QUOTE T)
       (SEQ
        (LETT |h|
         (COND
          ((SPADCALL |i| (QREFELT |$| 40)) (SPADCALL |i| (QREFELT |$| 41)))
          ((QUOTE T) (SPADCALL |x| (QREFELT |$| 42))))
         |LSAGG-;delete!;AUsA;11|)
        (EXIT
         (COND
          ((|<| |h| |l|) |x|)
          ((EQL |l| |m|)
           (SPADCALL |x|
            (PROG1
             (LETT #1# (|-| (|+| |h| 1) |m|) |LSAGG-;delete!;AUsA;11|)
             (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
            (QREFELT |$| 32)))
          ((QUOTE T)
           (SEQ
            (LETT |t|
             (SPADCALL |x|
              (PROG1
               (LETT #2# (|-| (|-| |l| 1) |m|) |LSAGG-;delete!;AUsA;11|)
               (|check-subtype| (|>=| #2# 0)
                 (QUOTE (|NonNegativeInteger|)) #2#))
              (QREFELT |$| 32))
             |LSAGG-;delete!;AUsA;11|)
            (SPADCALL |t|
             (SPADCALL |t|
              (PROG1
               (LETT #3# (|+| (|-| |h| |l|) 2) |LSAGG-;delete!;AUsA;11|)
               (|check-subtype| (|>=| #3# 0)
                (QUOTE (|NonNegativeInteger|)) #3#))
              (QREFELT |$| 32))
             (QREFELT |$| 25))
            (EXIT |x|))))))))))))) 

(DEFUN |LSAGG-;find;MAU;12| (|f| |x| |$|)
 (SEQ
  (SEQ
   G190 
   (COND 
    ((NULL
     (COND
      ((OR
         (SPADCALL |x| (QREFELT |$| 16))
         (SPADCALL (SPADCALL |x| (QREFELT |$| 18)) |f|))
        (QUOTE NIL))
      ((QUOTE T) (QUOTE T))))
     (GO G191)))
   (SEQ (EXIT (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;find;MAU;12|)))
   NIL
   (GO G190)
   G191
   (EXIT NIL))
  (EXIT
   (COND
    ((SPADCALL |x| (QREFELT |$| 16)) (CONS 1 "failed"))
    ((QUOTE T) (CONS 0 (SPADCALL |x| (QREFELT |$| 18)))))))) 

(DEFUN |LSAGG-;position;MAI;13| (|f| |x| |$|)
 (PROG (|k|)
  (RETURN
   (SEQ 
    (SEQ
     (LETT |k| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;position;MAI;13|)
     G190
     (COND
      ((NULL
        (COND
         ((OR
           (SPADCALL |x| (QREFELT |$| 16))
           (SPADCALL (SPADCALL |x| (QREFELT |$| 18)) |f|))
          (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (EXIT
       (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;position;MAI;13|)))
     (LETT |k| (|+| |k| 1) |LSAGG-;position;MAI;13|)
     (GO G190)
     G191 
     (EXIT NIL))
    (EXIT
     (COND
      ((SPADCALL |x| (QREFELT |$| 16)) (|-| (SPADCALL |x| (QREFELT |$| 31)) 1))
      ((QUOTE T) |k|))))))) 

(DEFUN |LSAGG-;mergeSort| (|f| |p| |n| |$|)
 (PROG (#1=#:G87593 |l| |q|)
  (RETURN
   (SEQ
    (COND
     ((EQL |n| 2)
      (COND
       ((SPADCALL 
         (SPADCALL (SPADCALL |p| (QREFELT |$| 17)) (QREFELT |$| 18))
         (SPADCALL |p| (QREFELT |$| 18)) |f|)
        (LETT |p| (SPADCALL |p| (QREFELT |$| 47)) |LSAGG-;mergeSort|)))))
    (EXIT
     (COND
      ((|<| |n| 3) |p|)
      ((QUOTE T)
       (SEQ
        (LETT |l|
         (PROG1
          (LETT #1# (QUOTIENT2 |n| 2) |LSAGG-;mergeSort|)
          (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
         |LSAGG-;mergeSort|)
        (LETT |q| (SPADCALL |p| |l| (QREFELT |$| 48)) |LSAGG-;mergeSort|)
        (LETT |p| (|LSAGG-;mergeSort| |f| |p| |l| |$|) |LSAGG-;mergeSort|)
        (LETT |q|
          (|LSAGG-;mergeSort| |f| |q| (|-| |n| |l|) |$|)
          |LSAGG-;mergeSort|)
        (EXIT (SPADCALL |f| |p| |q| (QREFELT |$| 23))))))))))) 

(DEFUN |LSAGG-;sorted?;MAB;15| (|f| |l| |$|)
 (PROG (#1=#:G87603 |p|)
  (RETURN
   (SEQ
    (EXIT
     (COND
      ((SPADCALL |l| (QREFELT |$| 16)) (QUOTE T))
      ((QUOTE T)
       (SEQ
        (LETT |p| (SPADCALL |l| (QREFELT |$| 17)) |LSAGG-;sorted?;MAB;15|)
        (SEQ 
         G190 
         (COND 
          ((NULL
            (COND
             ((SPADCALL |p| (QREFELT |$| 16)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ
          (EXIT
           (COND
            ((NULL
              (SPADCALL
               (SPADCALL |l| (QREFELT |$| 18))
               (SPADCALL |p| (QREFELT |$| 18))
               |f|))
              (PROGN (LETT #1# (QUOTE NIL) |LSAGG-;sorted?;MAB;15|) (GO #1#)))
            ((QUOTE T)
             (LETT |p|
              (SPADCALL
               (LETT |l| |p| |LSAGG-;sorted?;MAB;15|)
               (QREFELT |$| 17))
              |LSAGG-;sorted?;MAB;15|)))))
          NIL 
          (GO G190) 
          G191 
          (EXIT NIL))
        (EXIT (QUOTE T))))))
    #1# 
    (EXIT #1#))))) 

(DEFUN |LSAGG-;reduce;MA2S;16| (|f| |x| |i| |$|)
 (PROG (|r|)
  (RETURN
   (SEQ
    (LETT |r| |i| |LSAGG-;reduce;MA2S;16|)
    (SEQ
     G190 
     (COND
      ((NULL
        (COND
         ((SPADCALL |x| (QREFELT |$| 16)) (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (LETT |r|
       (SPADCALL |r| (SPADCALL |x| (QREFELT |$| 18)) |f|)
       |LSAGG-;reduce;MA2S;16|)
      (EXIT
       (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;reduce;MA2S;16|)))
     NIL 
     (GO G190) 
     G191 
     (EXIT NIL))
    (EXIT |r|))))) 

(DEFUN |LSAGG-;reduce;MA3S;17| (|f| |x| |i| |a| |$|)
 (PROG (|r|)
  (RETURN
   (SEQ 
    (LETT |r| |i| |LSAGG-;reduce;MA3S;17|)
    (SEQ
     G190
     (COND
      ((NULL
        (COND
         ((OR
            (SPADCALL |x| (QREFELT |$| 16))
            (SPADCALL |r| |a| (QREFELT |$| 51)))
           (QUOTE NIL))
         ((QUOTE T) (QUOTE T)))) (GO G191)))
     (SEQ
      (LETT |r|
       (SPADCALL |r| (SPADCALL |x| (QREFELT |$| 18)) |f|)
       |LSAGG-;reduce;MA3S;17|)
      (EXIT
       (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;reduce;MA3S;17|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |r|))))) 

(DEFUN |LSAGG-;new;NniSA;18| (|n| |s| |$|)
 (PROG (|k| |l|)
  (RETURN
   (SEQ 
    (LETT |l| (SPADCALL (QREFELT |$| 12)) |LSAGG-;new;NniSA;18|)
    (SEQ 
     (LETT |k| 1 |LSAGG-;new;NniSA;18|)
     G190 
     (COND ((QSGREATERP |k| |n|) (GO G191)))
     (SEQ
      (EXIT
       (LETT |l| (SPADCALL |s| |l| (QREFELT |$| 13)) |LSAGG-;new;NniSA;18|)))
     (LETT |k| (QSADD1 |k|) |LSAGG-;new;NniSA;18|)
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |l|))))) 

(DEFUN |LSAGG-;map;M3A;19| (|f| |x| |y| |$|) 
 (PROG (|z|) 
  (RETURN 
   (SEQ 
    (LETT |z| (SPADCALL (QREFELT |$| 12)) |LSAGG-;map;M3A;19|)
    (SEQ 
     G190 
     (COND
      ((NULL
        (COND
         ((OR (SPADCALL |x| (QREFELT |$| 16)) (SPADCALL |y| (QREFELT |$| 16)))
           (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ 
      (LETT |z|
       (SPADCALL
        (SPADCALL
          (SPADCALL |x| (QREFELT |$| 18))
          (SPADCALL |y| (QREFELT |$| 18))
          |f|)
         |z| 
         (QREFELT |$| 13))
       |LSAGG-;map;M3A;19|)
      (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;map;M3A;19|)
      (EXIT (LETT |y| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;map;M3A;19|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT (SPADCALL |z| (QREFELT |$| 47))))))) 

(DEFUN |LSAGG-;reverse!;2A;20| (|x| |$|)
 (PROG (|z| |y|)
  (RETURN
   (SEQ
    (COND
     ((OR
       (SPADCALL |x| (QREFELT |$| 16))
       (SPADCALL
        (LETT |y| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;reverse!;2A;20|)
        (QREFELT |$| 16)))
      |x|)
     ((QUOTE T)
      (SEQ
       (SPADCALL |x| (SPADCALL (QREFELT |$| 12)) (QREFELT |$| 25))
       (SEQ 
        G190 
        (COND
         ((NULL
           (COND
            ((SPADCALL |y| (QREFELT |$| 16)) (QUOTE NIL))
            ((QUOTE T) (QUOTE T))))
          (GO G191)))
        (SEQ
         (LETT |z| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;reverse!;2A;20|)
         (SPADCALL |y| |x| (QREFELT |$| 25))
         (LETT |x| |y| |LSAGG-;reverse!;2A;20|)
         (EXIT (LETT |y| |z| |LSAGG-;reverse!;2A;20|)))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
       (EXIT |x|)))))))) 

(DEFUN |LSAGG-;copy;2A;21| (|x| |$|)
 (PROG (|k| |y|)
  (RETURN
   (SEQ
    (LETT |y| (SPADCALL (QREFELT |$| 12)) |LSAGG-;copy;2A;21|)
    (SEQ
     (LETT |k| 0 |LSAGG-;copy;2A;21|)
     G190
     (COND
      ((NULL
        (COND
         ((SPADCALL |x| (QREFELT |$| 16)) (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (COND
       ((EQL |k| 1000)
         (COND
           ((SPADCALL |x| (QREFELT |$| 56)) (EXIT (|error| "cyclic list"))))))
      (LETT |y|
       (SPADCALL (SPADCALL |x| (QREFELT |$| 18)) |y| (QREFELT |$| 13))
       |LSAGG-;copy;2A;21|)
      (EXIT (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;copy;2A;21|)))
     (LETT |k| (QSADD1 |k|) |LSAGG-;copy;2A;21|)
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT (SPADCALL |y| (QREFELT |$| 47))))))) 

(DEFUN |LSAGG-;copyInto!;2AIA;22| (|y| |x| |s| |$|)
 (PROG (|m| #1=#:G87636 |z|)
  (RETURN 
   (SEQ 
    (LETT |m| (SPADCALL |y| (QREFELT |$| 31)) |LSAGG-;copyInto!;2AIA;22|)
    (EXIT
     (COND
      ((|<| |s| |m|) (|error| "index out of range"))
      ((QUOTE T)
       (SEQ
        (LETT |z|
         (SPADCALL |y|
          (PROG1
           (LETT #1# (|-| |s| |m|) |LSAGG-;copyInto!;2AIA;22|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 32))
         |LSAGG-;copyInto!;2AIA;22|)
        (SEQ 
         G190 
         (COND
          ((NULL
            (COND
             ((OR
               (SPADCALL |z| (QREFELT |$| 16))
               (SPADCALL |x| (QREFELT |$| 16)))
              (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ 
          (SPADCALL |z| (SPADCALL |x| (QREFELT |$| 18)) (QREFELT |$| 58))
          (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;copyInto!;2AIA;22|)
          (EXIT 
           (LETT |z|
            (SPADCALL |z| (QREFELT |$| 17))
            |LSAGG-;copyInto!;2AIA;22|)))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
        (EXIT |y|))))))))) 

(DEFUN |LSAGG-;position;SA2I;23| (|w| |x| |s| |$|)
 (PROG (|m| #1=#:G87644 |k|)
  (RETURN
   (SEQ
    (LETT |m| (SPADCALL |x| (QREFELT |$| 31)) |LSAGG-;position;SA2I;23|)
    (EXIT
     (COND
      ((|<| |s| |m|) (|error| "index out of range"))
      ((QUOTE T)
       (SEQ
        (LETT |x|
         (SPADCALL |x|
          (PROG1
           (LETT #1# (|-| |s| |m|) |LSAGG-;position;SA2I;23|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 32))
         |LSAGG-;position;SA2I;23|)
        (SEQ
         (LETT |k| |s| |LSAGG-;position;SA2I;23|)
         G190
         (COND
          ((NULL
            (COND
             ((OR
               (SPADCALL |x| (QREFELT |$| 16))
               (SPADCALL |w| (SPADCALL |x| (QREFELT |$| 18)) (QREFELT |$| 51)))
              (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ 
          (EXIT 
           (LETT |x|
            (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;position;SA2I;23|)))
         (LETT |k| (|+| |k| 1) |LSAGG-;position;SA2I;23|)
         (GO G190) 
         G191 
         (EXIT NIL))
        (EXIT
         (COND
          ((SPADCALL |x| (QREFELT |$| 16))
            (|-| (SPADCALL |x| (QREFELT |$| 31)) 1))
          ((QUOTE T) |k|))))))))))) 

(DEFUN |LSAGG-;removeDuplicates!;2A;24| (|l| |$|)
 (PROG (|p|)
  (RETURN
   (SEQ
    (LETT |p| |l| |LSAGG-;removeDuplicates!;2A;24|)
    (SEQ
     G190
     (COND
      ((NULL
        (COND 
         ((SPADCALL |p| (QREFELT |$| 16)) (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (EXIT
       (LETT |p|
        (SPADCALL |p|
         (SPADCALL
          (CONS
           (FUNCTION |LSAGG-;removeDuplicates!;2A;24!0|)
           (VECTOR |$| |p|))
          (SPADCALL |p| (QREFELT |$| 17))
          (QREFELT |$| 61))
         (QREFELT |$| 25))
        |LSAGG-;removeDuplicates!;2A;24|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |l|))))) 

(DEFUN |LSAGG-;removeDuplicates!;2A;24!0| (|#1| |$$|)
 (PROG (|$|)
  (LETT |$| (QREFELT |$$| 0) |LSAGG-;removeDuplicates!;2A;24|)
  (RETURN
   (PROGN
    (SPADCALL |#1|
     (SPADCALL (QREFELT |$$| 1) (QREFELT |$| 18))
     (QREFELT |$| 51)))))) 

(DEFUN |LSAGG-;<;2AB;25| (|x| |y| |$|)
 (PROG (#1=#:G87662)
  (RETURN
   (SEQ
    (EXIT
     (SEQ
      (SEQ 
       G190 
       (COND
        ((NULL
          (COND
           ((OR
              (SPADCALL |x| (QREFELT |$| 16))
              (SPADCALL |y| (QREFELT |$| 16)))
             (QUOTE NIL))
           ((QUOTE T) (QUOTE T))))
         (GO G191)))
       (SEQ 
        (EXIT 
         (COND 
          ((NULL 
            (SPADCALL 
             (SPADCALL |x| (QREFELT |$| 18))
             (SPADCALL |y| (QREFELT |$| 18))
             (QREFELT |$| 51)))
            (PROGN 
             (LETT #1#
               (SPADCALL
                (SPADCALL |x| (QREFELT |$| 18))
                (SPADCALL |y| (QREFELT |$| 18))
               (QREFELT |$| 63))
              |LSAGG-;<;2AB;25|)
             (GO #1#)))
          ((QUOTE T)
           (SEQ 
            (LETT |x| (SPADCALL |x| (QREFELT |$| 17)) |LSAGG-;<;2AB;25|)
            (EXIT 
             (LETT |y| (SPADCALL |y| (QREFELT |$| 17)) |LSAGG-;<;2AB;25|)))))))
       NIL
       (GO G190)
       G191
       (EXIT NIL))
      (EXIT
       (COND
        ((SPADCALL |x| (QREFELT |$| 16))
          (COND
           ((SPADCALL |y| (QREFELT |$| 16)) (QUOTE NIL))
           ((QUOTE T) (QUOTE T))))
        ((QUOTE T) (QUOTE NIL))))))
    #1# 
    (EXIT #1#))))) 

(DEFUN |ListAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|ListAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |ListAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 66) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
     ((|HasCategory| |#2| (QUOTE (|SetCategory|)))
       (QSETREFV |$| 52
         (CONS (|dispatchFunction| |LSAGG-;reduce;MA3S;17|) |$|))))
    (COND
     ((|HasCategory| |#2| (QUOTE (|SetCategory|)))
       (PROGN
        (QSETREFV |$| 60
         (CONS (|dispatchFunction| |LSAGG-;position;SA2I;23|) |$|))
        (QSETREFV |$| 62
         (CONS (|dispatchFunction| |LSAGG-;removeDuplicates!;2A;24|) |$|)))))
    (COND
     ((|HasCategory| |#2| (QUOTE (|OrderedSet|)))
       (QSETREFV |$| 64 (CONS (|dispatchFunction| |LSAGG-;<;2AB;25|) |$|))))
    |$|)))) 

(MAKEPROP
 (QUOTE |ListAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) 
   (|NonNegativeInteger|) (0 . |#|) (|Mapping| 15 7 7) |LSAGG-;sort!;M2A;1| 
   (5 . |empty|) (9 . |concat|) |LSAGG-;list;SA;2| (|Boolean|) 
   (15 . |empty?|) (20 . |rest|) (25 . |first|) (|Mapping| 7 7 7) 
   (30 . |reduce|) |LSAGG-;reduce;MAS;3| (37 . |copy|) (42 . |merge!|) 
   |LSAGG-;merge;M3A;4| (49 . |setrest!|) (|Mapping| 15 7) 
   |LSAGG-;select!;M2A;5| (55 . |eq?|) |LSAGG-;merge!;M3A;6| 
   (|Integer|) (61 . |minIndex|) (66 . |rest|) |LSAGG-;insert!;SAIA;7| 
   (72 . |concat!|) |LSAGG-;insert!;2AIA;8| |LSAGG-;remove!;M2A;9| 
   |LSAGG-;delete!;AIA;10| (|UniversalSegment| 30) (78 . |lo|) 
   (83 . |hasHi|) (88 . |hi|) (93 . |maxIndex|) |LSAGG-;delete!;AUsA;11| 
   (|Union| 7 (QUOTE "failed")) |LSAGG-;find;MAU;12| 
   |LSAGG-;position;MAI;13| (98 . |reverse!|) (103 . |split!|) 
   |LSAGG-;sorted?;MAB;15| |LSAGG-;reduce;MA2S;16| (109 . |=|) 
   (115 . |reduce|) |LSAGG-;new;NniSA;18| |LSAGG-;map;M3A;19| 
   |LSAGG-;reverse!;2A;20| (123 . |cyclic?|) |LSAGG-;copy;2A;21| 
   (128 . |setfirst!|) |LSAGG-;copyInto!;2AIA;22| (134 . |position|) 
   (141 . |remove!|) (147 . |removeDuplicates!|) (152 . |<|) (158 . |<|) 
   (|Mapping| 7 7)))
  (QUOTE #(|sorted?| 164 |sort!| 170 |select!| 176 |reverse!| 182 
    |removeDuplicates!| 187 |remove!| 192 |reduce| 198 |position| 219 
    |new| 232 |merge!| 238 |merge| 245 |map| 252 |list| 259 |insert!| 
    264 |find| 278 |delete!| 284 |copyInto!| 296 |copy| 303 |<| 308))
   (QUOTE NIL)
   (CONS 
    (|makeByteWordVec2| 1 (QUOTE NIL))
    (CONS 
     (QUOTE #())
     (CONS 
      (QUOTE #())
      (|makeByteWordVec2| 64 (QUOTE (1 6 8 0 9 0 6 0 12 2 6 0 7 0 13 1 6 
       15 0 16 1 6 0 0 17 1 6 7 0 18 3 6 7 19 0 7 20 1 6 0 0 22 3 6 0 10 
       0 0 23 2 6 0 0 0 25 2 6 15 0 0 28 1 6 30 0 31 2 6 0 0 8 32 2 6 0 0 
       0 34 1 38 30 0 39 1 38 15 0 40 1 38 30 0 41 1 6 30 0 42 1 6 0 0 47 
       2 6 0 0 30 48 2 7 15 0 0 51 4 0 7 19 0 7 7 52 1 6 15 0 56 2 6 7 0 
       7 58 3 0 30 7 0 30 60 2 6 0 26 0 61 1 0 0 0 62 2 7 15 0 0 63 2 0 15 
       0 0 64 2 0 15 10 0 49 2 0 0 10 0 11 2 0 0 26 0 27 1 0 0 0 55 1 0 0 
       0 62 2 0 0 26 0 36 3 0 7 19 0 7 50 4 0 7 19 0 7 7 52 2 0 7 19 0 21 
       2 0 30 26 0 46 3 0 30 7 0 30 60 2 0 0 8 7 53 3 0 0 10 0 0 29 3 0 0 
       10 0 0 24 3 0 0 19 0 0 54 1 0 0 7 14 3 0 0 7 0 30 33 3 0 0 0 0 30 
       35 2 0 44 26 0 45 2 0 0 0 38 43 2 0 0 0 30 37 3 0 0 0 0 30 59 1 0 
       0 0 57 2 0 15 0 0 64))))))
   (QUOTE |lookupComplete|))) 
@
\section{MONOID.lsp BOOTSTRAP}
{\bf MONOID} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf MONOID}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf MONOID.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<MONOID.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |Monoid;AL| (QUOTE NIL)) 

(DEFUN |Monoid| NIL 
  (LET (#:G82434) 
    (COND 
      (|Monoid;AL|)
      (T (SETQ |Monoid;AL| (|Monoid;|)))))) 

(DEFUN |Monoid;| NIL 
  (PROG (#1=#:G82432) 
    (RETURN 
      (PROG1
        (LETT #1# 
          (|Join|
            (|SemiGroup|)
            (|mkCategory|
              (QUOTE |domain|)
              (QUOTE (
                ((|One| (|$|) |constant|) T)
                ((|sample| (|$|) |constant|) T)
                ((|one?| ((|Boolean|) |$|)) T)
                ((|**| (|$| |$| (|NonNegativeInteger|))) T)
                ((|^| (|$| |$| (|NonNegativeInteger|))) T)
                ((|recip| ((|Union| |$| "failed") |$|)) T)))
              NIL
              (QUOTE ((|NonNegativeInteger|) (|Boolean|)))
              NIL))
            |Monoid|)
         (SETELT #1# 0 (QUOTE (|Monoid|))))))) 

(MAKEPROP (QUOTE |Monoid|) (QUOTE NILADIC) T) 

@
\section{MONOID-.lsp BOOTSTRAP}
{\bf MONOID-} depends on {\bf MONOID}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf MONOID-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf MONOID-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<MONOID-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |MONOID-;^;SNniS;1| (|x| |n| |$|) 
  (SPADCALL |x| |n| (QREFELT |$| 8))) 

(DEFUN |MONOID-;one?;SB;2| (|x| |$|) 
  (SPADCALL |x| (|spadConstant| |$| 10) (QREFELT |$| 12))) 

(DEFUN |MONOID-;sample;S;3| (|$|) 
  (|spadConstant| |$| 10)) 

(DEFUN |MONOID-;recip;SU;4| (|x| |$|) 
  (COND 
    ((SPADCALL |x| (QREFELT |$| 15)) (CONS 0 |x|))
    ((QUOTE T) (CONS 1 "failed")))) 

(DEFUN |MONOID-;**;SNniS;5| (|x| |n| |$|) 
  (COND 
    ((ZEROP |n|) (|spadConstant| |$| 10))
    ((QUOTE T) (SPADCALL |x| |n| (QREFELT |$| 20))))) 

(DEFUN |Monoid&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|Monoid&|))
        (LETT |dv$| (LIST (QUOTE |Monoid&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 22) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |Monoid&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (|NonNegativeInteger|)
        (0 . |**|)
        |MONOID-;^;SNniS;1|
        (6 . |One|)
        (|Boolean|)
        (10 . |=|)
        |MONOID-;one?;SB;2|
        |MONOID-;sample;S;3|
        (16 . |one?|)
        (|Union| |$| (QUOTE "failed"))
        |MONOID-;recip;SU;4|
        (|PositiveInteger|)
        (|RepeatedSquaring| 6)
        (21 . |expt|)
        |MONOID-;**;SNniS;5|)) 
    (QUOTE #(|sample| 27 |recip| 31 |one?| 36 |^| 41 |**| 47))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 21 
            (QUOTE 
              (2 6 0 0 7 8 0 6 0 10 2 6 11 0 0 12 1 6 11 0 15 2 19 6 6 18 20
              0 0 0 14 1 0 16 0 17 1 0 11 0 13 2 0 0 0 7 9 2 0 0 0 7 21))))))
  (QUOTE |lookupComplete|))) 

@
\section{OINTDOM.lsp BOOTSTRAP}
{\bf OINTDOM} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf OINTDOM}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf OINTDOM.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<OINTDOM.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |OrderedIntegralDomain;AL| (QUOTE NIL)) 

(DEFUN |OrderedIntegralDomain| NIL 
  (LET (#:G84531) 
    (COND 
      (|OrderedIntegralDomain;AL|)
      (T (SETQ |OrderedIntegralDomain;AL| (|OrderedIntegralDomain;|)))))) 

(DEFUN |OrderedIntegralDomain;| NIL 
  (PROG (#1=#:G84529) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| (|IntegralDomain|) (|OrderedRing|)) |OrderedIntegralDomain|)
        (SETELT #1# 0 (QUOTE (|OrderedIntegralDomain|))))))) 

(MAKEPROP (QUOTE |OrderedIntegralDomain|) (QUOTE NILADIC) T) 

@
\section{ORDRING.lsp BOOTSTRAP}
{\bf ORDRING} depends on {\bf INT}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ORDRING}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ORDRING.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Technically I can't justify this bootstrap stanza based on the lattice
since {\bf INT} is already bootstrapped. However using {\bf INT} naked
generates a "value stack overflow" error suggesting an infinite recursive
loop. This code is here to experiment with breaking that loop.

Note that this code is not included in the generated catdef.spad file.

<<ORDRING.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |OrderedRing;AL| (QUOTE NIL)) 

(DEFUN |OrderedRing| NIL 
  (LET (#:G84457)  
    (COND 
      (|OrderedRing;AL|) 
      (T (SETQ |OrderedRing;AL| (|OrderedRing;|)))))) 

(DEFUN |OrderedRing;| NIL 
  (PROG (#1=#:G84455) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|OrderedAbelianGroup|)
            (|Ring|)
            (|Monoid|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|positive?| ((|Boolean|) |$|)) T)
                ((|negative?| ((|Boolean|) |$|)) T)
                ((|sign| ((|Integer|) |$|)) T)
                ((|abs| (|$| |$|)) T)))
              NIL 
              (QUOTE ((|Integer|) (|Boolean|)))
              NIL)) 
           |OrderedRing|)
        (SETELT #1# 0 (QUOTE (|OrderedRing|))))))) 

(MAKEPROP (QUOTE |OrderedRing|) (QUOTE NILADIC) T) 

@
\section{ORDRING-.lsp BOOTSTRAP}
{\bf ORDRING-} depends on {\bf ORDRING}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf ORDRING-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf ORDRING-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<ORDRING-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |ORDRING-;positive?;SB;1| (|x| |$|) 
  (SPADCALL (|spadConstant| |$| 7) |x| (QREFELT |$| 9))) 

(DEFUN |ORDRING-;negative?;SB;2| (|x| |$|) 
  (SPADCALL |x| (|spadConstant| |$| 7) (QREFELT |$| 9))) 

(DEFUN |ORDRING-;sign;SI;3| (|x| |$|) 
  (COND 
    ((SPADCALL |x| (QREFELT |$| 12)) 1)
    ((SPADCALL |x| (QREFELT |$| 13)) -1)
    ((SPADCALL |x| (QREFELT |$| 15)) 0)
    ((QUOTE T) 
      (|error| "x satisfies neither positive?, negative? or zero?")))) 

(DEFUN |ORDRING-;abs;2S;4| (|x| |$|) 
  (COND 
    ((SPADCALL |x| (QREFELT |$| 12)) |x|)
    ((SPADCALL |x| (QREFELT |$| 13)) (SPADCALL |x| (QREFELT |$| 18)))
    ((SPADCALL |x| (QREFELT |$| 15)) (|spadConstant| |$| 7))
    ((QUOTE T) 
      (|error| "x satisfies neither positive?, negative? or zero?")))) 

(DEFUN |OrderedRing&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|OrderedRing&|))
        (LETT |dv$| (LIST (QUOTE |OrderedRing&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 20) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |OrderedRing&|)
  (QUOTE |infovec|)
  (LIST
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |Zero|)
        (|Boolean|)
        (4 . |<|)
        |ORDRING-;positive?;SB;1|
        |ORDRING-;negative?;SB;2|
        (10 . |positive?|)
        (15 . |negative?|)
        (20 . |One|)
        (24 . |zero?|)
        (|Integer|)
        |ORDRING-;sign;SI;3|
        (29 . |-|)
        |ORDRING-;abs;2S;4|)) 
    (QUOTE #(|sign| 34 |positive?| 39 |negative?| 44 |abs| 49))
    (QUOTE NIL)
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 19 
            (QUOTE 
              (0 6 0 7 2 6 8 0 0 9 1 6 8 0 12 1 6 8 0 13 0 6 0 14 1 6 8 0 15
               1 6 0 0 18 1 0 16 0 17 1 0 8 0 10 1 0 8 0 11 1 0 0 0 19))))))
   (QUOTE |lookupComplete|))) 
@
\section{RCAGG.lsp BOOTSTRAP}
{\bf RCAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf RCAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf RCAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<RCAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |RecursiveAggregate;CAT| (QUOTE NIL)) 

(SETQ |RecursiveAggregate;AL| (QUOTE NIL)) 

(DEFUN |RecursiveAggregate| (#1=#:G84501)
 (LET (#2=#:G84502)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |RecursiveAggregate;AL|)) (CDR #2#))
   (T 
    (SETQ |RecursiveAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|RecursiveAggregate;| #1#)))
      |RecursiveAggregate;AL|))
    #2#)))) 

(DEFUN |RecursiveAggregate;| (|t#1|)
 (PROG (#1=#:G84500)
  (RETURN
   (PROG1 
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|RecursiveAggregate;CAT|)
       ((QUOTE T)
        (LETT |RecursiveAggregate;CAT|
         (|Join|
          (|HomogeneousAggregate| (QUOTE |t#1|))
          (|mkCategory|
           (QUOTE |domain|)
           (QUOTE (
            ((|children| ((|List| |$|) |$|)) T)
            ((|nodes| ((|List| |$|) |$|)) T)
            ((|leaf?| ((|Boolean|) |$|)) T)
            ((|value| (|t#1| |$|)) T)
            ((|elt| (|t#1| |$| "value")) T)
            ((|cyclic?| ((|Boolean|) |$|)) T)
            ((|leaves| ((|List| |t#1|) |$|)) T)
            ((|distance| ((|Integer|) |$| |$|)) T)
            ((|child?| ((|Boolean|) |$| |$|)) (|has| |t#1| (|SetCategory|)))
            ((|node?| ((|Boolean|) |$| |$|)) (|has| |t#1| (|SetCategory|)))
            ((|setchildren!| (|$| |$| (|List| |$|)))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setelt| (|t#1| |$| "value" |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setvalue!| (|t#1| |$| |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))))
           NIL 
           (QUOTE ((|List| |$|) (|Boolean|) (|Integer|) (|List| |t#1|)))
           NIL))
         . #2=(|RecursiveAggregate|)))))
      . #2#)
    (SETELT #1# 0 (LIST (QUOTE |RecursiveAggregate|) (|devaluate| |t#1|))))))) 
@
\section{RCAGG-.lsp BOOTSTRAP}
{\bf RCAGG-} depends on {\bf RCAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf RCAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf RCAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<RCAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |RCAGG-;elt;AvalueS;1| (|x| G84515 |$|)
 (SPADCALL |x| (QREFELT |$| 8))) 

(DEFUN |RCAGG-;setelt;Avalue2S;2| (|x| G84517 |y| |$|)
 (SPADCALL |x| |y| (QREFELT |$| 11))) 

(DEFUN |RCAGG-;child?;2AB;3| (|x| |l| |$|)
 (SPADCALL |x| (SPADCALL |l| (QREFELT |$| 14)) (QREFELT |$| 17))) 

(DEFUN |RecursiveAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|RecursiveAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |RecursiveAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 19) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0 
       (LIST
        (|HasAttribute| |#1| (QUOTE |shallowlyMutable|))
        (|HasCategory| |#2| (QUOTE (|SetCategory|)))))
      . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
     ((|testBitVector| |pv$| 1)
      (QSETREFV |$| 12
       (CONS (|dispatchFunction| |RCAGG-;setelt;Avalue2S;2|) |$|))))
    (COND
     ((|testBitVector| |pv$| 2)
      (QSETREFV |$| 18 (CONS (|dispatchFunction| |RCAGG-;child?;2AB;3|) |$|))))
    |$|)))) 

(MAKEPROP
 (QUOTE |RecursiveAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) 
   (0 . |value|) (QUOTE "value") |RCAGG-;elt;AvalueS;1| (5 . |setvalue!|)
   (11 . |setelt|) (|List| |$|) (18 . |children|) (|Boolean|) (|List| 6)
   (23 . |member?|) (29 . |child?|)))
  (QUOTE #(|setelt| 35 |elt| 42 |child?| 48))
  (QUOTE NIL)
  (CONS (|makeByteWordVec2| 1 (QUOTE NIL))
 (CONS 
  (QUOTE #())
  (CONS
   (QUOTE #())
   (|makeByteWordVec2| 18 (QUOTE (1 6 7 0 8 2 6 7 0 7 11 3 0 7 0 9 7 12 
     1 6 13 0 14 2 16 15 6 0 17 2 0 15 0 0 18 3 0 7 0 9 7 12 2 0 7 0 9 
     10 2 0 15 0 0 18))))))
  (QUOTE |lookupComplete|))) 
@
\section{RING.lsp BOOTSTRAP}
{\bf RING} depends on itself. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf RING}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf RING.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<RING.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |Ring;AL| (QUOTE NIL)) 

(DEFUN |Ring| NIL 
  (LET (#:G82789) 
    (COND 
      (|Ring;AL|) 
      (T (SETQ |Ring;AL| (|Ring;|)))))) 

(DEFUN |Ring;| NIL 
  (PROG (#1=#:G82787) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|Rng|) 
            (|Monoid|) 
            (|LeftModule| (QUOTE |$|))
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|characteristic| ((|NonNegativeInteger|))) T)
                ((|coerce| (|$| (|Integer|))) T)))
              (QUOTE ((|unitsKnown| T)))
              (QUOTE ((|Integer|) (|NonNegativeInteger|)))
              NIL))
           |Ring|)
        (SETELT #1# 0 (QUOTE (|Ring|))))))) 

(MAKEPROP (QUOTE |Ring|) (QUOTE NILADIC) T) 

@
\section{RING-.lsp BOOTSTRAP}
{\bf RING-} depends on {\bf RING}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf RING-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf RING-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<RING-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |RING-;coerce;IS;1| (|n| |$|) 
  (SPADCALL |n| (|spadConstant| |$| 7) (QREFELT |$| 9))) 

(DEFUN |Ring&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|Ring&|))
        (LETT |dv$| (LIST (QUOTE |Ring&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 12) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |Ring&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (0 . |One|)
        (|Integer|)
        (4 . |*|)
        |RING-;coerce;IS;1| 
        (|OutputForm|))) 
  (QUOTE #(|coerce| 10)) 
  (QUOTE NIL) 
  (CONS 
    (|makeByteWordVec2| 1 (QUOTE NIL))
    (CONS 
      (QUOTE #())
      (CONS 
        (QUOTE #())
        (|makeByteWordVec2| 10 (QUOTE (0 6 0 7 2 6 0 8 0 9 1 0 0 8 10))))))
   (QUOTE |lookupComplete|))) 

@
\section{RNG.lsp BOOTSTRAP} 
{\bf RNG} depends on a chain of
files. We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf RNG} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf RNG.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<RNG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |Rng;AL| (QUOTE NIL)) 

(DEFUN |Rng| NIL 
  (LET (#:G82722) 
    (COND 
      (|Rng;AL|) 
      (T (SETQ |Rng;AL| (|Rng;|)))))) 

(DEFUN |Rng;| NIL 
  (PROG (#1=#:G82720) 
    (RETURN 
      (PROG1 
        (LETT #1# (|Join| (|AbelianGroup|) (|SemiGroup|)) |Rng|)
        (SETELT #1# 0 (QUOTE (|Rng|))))))) 

(MAKEPROP (QUOTE |Rng|) (QUOTE NILADIC) T) 

@
\section{SETAGG.lsp BOOTSTRAP}
{\bf SETAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf SETAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf SETAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<SETAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |SetAggregate;CAT| (QUOTE NIL)) 

(SETQ |SetAggregate;AL| (QUOTE NIL)) 

(DEFUN |SetAggregate| (#1=#:G83200)
 (LET (#2=#:G83201)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |SetAggregate;AL|)) (CDR #2#))
   (T
    (SETQ |SetAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|SetAggregate;| #1#)))
      |SetAggregate;AL|))
    #2#)))) 

(DEFUN |SetAggregate;| (|t#1|)
 (PROG (#1=#:G83199)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|SetAggregate;CAT|)
       ((QUOTE T)
        (LETT |SetAggregate;CAT|
         (|Join|
          (|SetCategory|)
          (|Collection| (QUOTE |t#1|))
          (|mkCategory| 
           (QUOTE |domain|)
           (QUOTE (
            ((|<| ((|Boolean|) |$| |$|)) T)
            ((|brace| (|$|)) T)
            ((|brace| (|$| (|List| |t#1|))) T)
            ((|set| (|$|)) T)
            ((|set| (|$| (|List| |t#1|))) T)
            ((|intersect| (|$| |$| |$|)) T)
            ((|difference| (|$| |$| |$|)) T)
            ((|difference| (|$| |$| |t#1|)) T)
            ((|symmetricDifference| (|$| |$| |$|)) T)
            ((|subset?| ((|Boolean|) |$| |$|)) T)
            ((|union| (|$| |$| |$|)) T)
            ((|union| (|$| |$| |t#1|)) T)
            ((|union| (|$| |t#1| |$|)) T))) 
           (QUOTE ((|partiallyOrderedSet| T)))
           (QUOTE ((|Boolean|) (|List| |t#1|)))
           NIL))
         . #2=(|SetAggregate|)))))
      . #2#)
    (SETELT #1# 0 (LIST (QUOTE |SetAggregate|) (|devaluate| |t#1|))))))) 
@
\section{SETAGG-.lsp BOOTSTRAP}
{\bf SETAGG-} depends on {\bf SETAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf SETAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf SETAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<SETAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |SETAGG-;symmetricDifference;3A;1| (|x| |y| |$|)
 (SPADCALL
  (SPADCALL |x| |y| (QREFELT |$| 8))
  (SPADCALL |y| |x| (QREFELT |$| 8))
  (QREFELT |$| 9))) 

(DEFUN |SETAGG-;union;ASA;2| (|s| |x| |$|)
 (SPADCALL |s| (SPADCALL (LIST |x|) (QREFELT |$| 12)) (QREFELT |$| 9))) 

(DEFUN |SETAGG-;union;S2A;3| (|x| |s| |$|)
 (SPADCALL |s| (SPADCALL (LIST |x|) (QREFELT |$| 12)) (QREFELT |$| 9))) 

(DEFUN |SETAGG-;difference;ASA;4| (|s| |x| |$|)
 (SPADCALL |s| (SPADCALL (LIST |x|) (QREFELT |$| 12)) (QREFELT |$| 8))) 

(DEFUN |SetAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|SetAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |SetAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 16) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    |$|)))) 

(MAKEPROP
 (QUOTE |SetAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) 
    (0 . |difference|) (6 . |union|) |SETAGG-;symmetricDifference;3A;1| 
    (|List| 7) (12 . |brace|) |SETAGG-;union;ASA;2| |SETAGG-;union;S2A;3| 
    |SETAGG-;difference;ASA;4|))
  (QUOTE #(|union| 17 |symmetricDifference| 29 |difference| 35))
  (QUOTE NIL)
  (CONS 
   (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS 
    (QUOTE #())
    (CONS 
     (QUOTE #())
     (|makeByteWordVec2| 15 (QUOTE (2 6 0 0 0 8 2 6 0 0 0 9 1 6 0 11 12 2 
       0 0 7 0 14 2 0 0 0 7 13 2 0 0 0 0 10 2 0 0 0 7 15))))))
  (QUOTE |lookupComplete|))) 
@
\section{SETCAT.lsp BOOTSTRAP}
{\bf SETCAT} needs 
{\bf SINT} which needs 
{\bf UFD} which needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG} which needs
{\bf SETCAT}. We break this chain with {\bf SETCAT.lsp} which we
cache here. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf SETCAT}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf SETCAT.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<SETCAT.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |SetCategory;AL| (QUOTE NIL)) 

(DEFUN |SetCategory| NIL 
  (LET (#:G82359) 
    (COND 
      (|SetCategory;AL|) 
      (T (SETQ |SetCategory;AL| (|SetCategory;|)))))) 

(DEFUN |SetCategory;| NIL 
  (PROG (#1=#:G82357) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|sublisV| 
            (PAIR 
              (QUOTE (#2=#:G82356))
              (LIST (QUOTE (|OutputForm|))))
            (|Join| 
              (|BasicType|)
              (|CoercibleTo| (QUOTE #2#))
              (|mkCategory| 
                (QUOTE |domain|)
                (QUOTE (
                  ((|hash| ((|SingleInteger|) |$|)) T)
                  ((|latex| ((|String|) |$|)) T)))
                NIL
                (QUOTE ((|String|) (|SingleInteger|)))
                NIL)))
          |SetCategory|)
        (SETELT #1# 0 (QUOTE (|SetCategory|))))))) 

(MAKEPROP (QUOTE |SetCategory|) (QUOTE NILADIC) T) 

@
\section{SETCAT-.lsp BOOTSTRAP}
{\bf SETCAT-} is the implementation of the operations exported
by {\bf SETCAT}. It comes into existance whenever {\bf SETCAT}
gets compiled by Axiom. However this will not happen at the
lisp level so we also cache this information here. See the
explanation under the {\bf SETCAT.lsp} section for more details.

Note that this code is not included in the generated catdef.spad file.

<<SETCAT-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(PUT 
  (QUOTE |SETCAT-;hash;SSi;1|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM (|s|) 0))) 

(DEFUN |SETCAT-;hash;SSi;1| (|s| |$|) 0) 

(PUT 
  (QUOTE |SETCAT-;latex;SS;2|)
  (QUOTE |SPADreplace|)
  (QUOTE (XLAM (|s|) "\\mbox{\\bf Unimplemented}"))) 

(DEFUN |SETCAT-;latex;SS;2| (|s| |$|) 
  "\\mbox{\\bf Unimplemented}") 

(DEFUN |SetCategory&| (|#1|) 
 (PROG (|DV$1| |dv$| |$| |pv$|)
   (RETURN 
     (PROGN 
       (LETT |DV$1| (|devaluate| |#1|) . #1=(|SetCategory&|))
       (LETT |dv$| (LIST (QUOTE |SetCategory&|) |DV$1|) . #1#)
       (LETT |$| (GETREFV 11) . #1#)
       (QSETREFV |$| 0 |dv$|)
       (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
       (|stuffDomainSlots| |$|)
       (QSETREFV |$| 6 |#1|)
       |$|)))) 

(MAKEPROP
  (QUOTE |SetCategory&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (|SingleInteger|)
        |SETCAT-;hash;SSi;1| 
        (|String|)
        |SETCAT-;latex;SS;2|))
    (QUOTE 
      #(|latex| 0 |hash| 5))
    (QUOTE NIL) 
    (CONS 
      (|makeByteWordVec2| 1 (QUOTE NIL))
      (CONS 
        (QUOTE #())
        (CONS 
          (QUOTE #())
          (|makeByteWordVec2| 
            10 
            (QUOTE (1 0 9 0 10 1 0 7 0 8))))))
    (QUOTE |lookupComplete|))) 

@
\section{STAGG.lsp BOOTSTRAP}
{\bf STAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf STAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf STAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<STAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |StreamAggregate;CAT| (QUOTE NIL)) 

(SETQ |StreamAggregate;AL| (QUOTE NIL)) 

(DEFUN |StreamAggregate| (#1=#:G87035)
 (LET (#2=#:G87036)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |StreamAggregate;AL|)) (CDR #2#))
   (T
    (SETQ |StreamAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|StreamAggregate;| #1#)))
      |StreamAggregate;AL|))
    #2#)))) 
v
(DEFUN |StreamAggregate;| (|t#1|)
 (PROG (#1=#:G87034)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|StreamAggregate;CAT|)
       ((QUOTE T)
        (LETT |StreamAggregate;CAT|
         (|Join|
          (|UnaryRecursiveAggregate| (QUOTE |t#1|))
          (|LinearAggregate| (QUOTE |t#1|))
          (|mkCategory|
           (QUOTE |domain|)
           (QUOTE (
            ((|explicitlyFinite?| ((|Boolean|) |$|)) T)
            ((|possiblyInfinite?| ((|Boolean|) |$|)) T)))
           NIL
           (QUOTE ((|Boolean|)))
           NIL))
         . #2=(|StreamAggregate|)))))
      . #2#)
    (SETELT #1# 0 (LIST (QUOTE |StreamAggregate|) (|devaluate| |t#1|))))))) 
@
\section{STAGG-.lsp BOOTSTRAP}
{\bf STAGG-} depends on {\bf STAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf STAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf STAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<STAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |STAGG-;explicitlyFinite?;AB;1| (|x| |$|)
 (COND ((SPADCALL |x| (QREFELT |$| 9)) (QUOTE NIL)) ((QUOTE T) (QUOTE T)))) 

(DEFUN |STAGG-;possiblyInfinite?;AB;2| (|x| |$|)
 (SPADCALL |x| (QREFELT |$| 9))) 

(DEFUN |STAGG-;first;ANniA;3| (|x| |n| |$|)
 (PROG (#1=#:G87053 |i|) 
  (RETURN 
   (SEQ 
    (SPADCALL
     (PROGN
      (LETT #1# NIL |STAGG-;first;ANniA;3|)
      (SEQ
       (LETT |i| 1 |STAGG-;first;ANniA;3|)
       G190
       (COND ((QSGREATERP |i| |n|) (GO G191)))
       (SEQ
        (EXIT
         (LETT #1#
          (CONS
           (|STAGG-;c2| |x|
            (LETT |x| (SPADCALL |x| (QREFELT |$| 12)) |STAGG-;first;ANniA;3|)
            |$|)
            #1#)
          |STAGG-;first;ANniA;3|)))
       (LETT |i| (QSADD1 |i|) |STAGG-;first;ANniA;3|)
       (GO G190)
       G191
       (EXIT (NREVERSE0 #1#))))
     (QREFELT |$| 14)))))) 

(DEFUN |STAGG-;c2| (|x| |r| |$|)
 (COND
   ((SPADCALL |x| (QREFELT |$| 17)) (|error| "Index out of range"))
   ((QUOTE T) (SPADCALL |x| (QREFELT |$| 18))))) 

(DEFUN |STAGG-;elt;AIS;5| (|x| |i| |$|)
 (PROG (#1=#:G87056)
  (RETURN
   (SEQ
    (LETT |i| (|-| |i| (SPADCALL |x| (QREFELT |$| 20))) |STAGG-;elt;AIS;5|)
    (COND
     ((OR 
       (|<| |i| 0)
       (SPADCALL
        (LETT |x|
         (SPADCALL |x|
          (PROG1
           (LETT #1# |i| |STAGG-;elt;AIS;5|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 21))
         |STAGG-;elt;AIS;5|)
        (QREFELT |$| 17)))
      (EXIT (|error| "index out of range"))))
    (EXIT (SPADCALL |x| (QREFELT |$| 18))))))) 

(DEFUN |STAGG-;elt;AUsA;6| (|x| |i| |$|)
 (PROG (|l| #1=#:G87060 |h| #2=#:G87062 #3=#:G87063)
  (RETURN
   (SEQ
    (LETT |l|
     (|-| (SPADCALL |i| (QREFELT |$| 24)) (SPADCALL |x| (QREFELT |$| 20)))
     |STAGG-;elt;AUsA;6|)
    (EXIT
     (COND
      ((|<| |l| 0) (|error| "index out of range"))
      ((NULL (SPADCALL |i| (QREFELT |$| 25)))
        (SPADCALL
         (SPADCALL |x| 
          (PROG1 
           (LETT #1# |l| |STAGG-;elt;AUsA;6|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 21))
         (QREFELT |$| 26)))
      ((QUOTE T)
       (SEQ
        (LETT |h|
         (|-| (SPADCALL |i| (QREFELT |$| 27)) (SPADCALL |x| (QREFELT |$| 20)))
         |STAGG-;elt;AUsA;6|)
        (EXIT
         (COND
          ((|<| |h| |l|) (SPADCALL (QREFELT |$| 28)))
          ((QUOTE T)
           (SPADCALL
            (SPADCALL |x|
             (PROG1
              (LETT #2# |l| |STAGG-;elt;AUsA;6|)
              (|check-subtype|
                (|>=| #2# 0) (QUOTE (|NonNegativeInteger|)) #2#))
             (QREFELT |$| 21))
            (PROG1
             (LETT #3# (|+| (|-| |h| |l|) 1) |STAGG-;elt;AUsA;6|)
             (|check-subtype| (|>=| #3# 0) (QUOTE (|NonNegativeInteger|)) #3#))
            (QREFELT |$| 29))))))))))))) 

(DEFUN |STAGG-;concat;3A;7| (|x| |y| |$|)
 (SPADCALL (SPADCALL |x| (QREFELT |$| 26)) |y| (QREFELT |$| 31))) 

(DEFUN |STAGG-;concat;LA;8| (|l| |$|)
 (COND
  ((NULL |l|) (SPADCALL (QREFELT |$| 28)))
  ((QUOTE T)
   (SPADCALL
    (SPADCALL (|SPADfirst| |l|) (QREFELT |$| 26))
    (SPADCALL (CDR |l|) (QREFELT |$| 34))
    (QREFELT |$| 31))))) 

(DEFUN |STAGG-;map!;M2A;9| (|f| |l| |$|)
 (PROG (|y|)
  (RETURN
   (SEQ
    (LETT |y| |l| |STAGG-;map!;M2A;9|)
    (SEQ 
     G190 
     (COND
      ((NULL
        (COND
         ((SPADCALL |l| (QREFELT |$| 17)) (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (SPADCALL |l|
       (SPADCALL (SPADCALL |l| (QREFELT |$| 18)) |f|) (QREFELT |$| 36))
      (EXIT (LETT |l| (SPADCALL |l| (QREFELT |$| 12)) |STAGG-;map!;M2A;9|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |y|))))) 

(DEFUN |STAGG-;fill!;ASA;10| (|x| |s| |$|)
 (PROG (|y|)
  (RETURN
   (SEQ 
    (LETT |y| |x| |STAGG-;fill!;ASA;10|)
    (SEQ 
     G190 
     (COND
      ((NULL
        (COND 
         ((SPADCALL |y| (QREFELT |$| 17)) (QUOTE NIL)) ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (SPADCALL |y| |s| (QREFELT |$| 36))
      (EXIT (LETT |y| (SPADCALL |y| (QREFELT |$| 12)) |STAGG-;fill!;ASA;10|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |x|))))) 

(DEFUN |STAGG-;setelt;AI2S;11| (|x| |i| |s| |$|)
 (PROG (#1=#:G87081)
  (RETURN
   (SEQ
    (LETT |i|
     (|-| |i| (SPADCALL |x| (QREFELT |$| 20))) |STAGG-;setelt;AI2S;11|)
    (COND
     ((OR 
       (|<| |i| 0)
       (SPADCALL
        (LETT |x|
         (SPADCALL |x|
          (PROG1
           (LETT #1# |i| |STAGG-;setelt;AI2S;11|)
           (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
          (QREFELT |$| 21))
         |STAGG-;setelt;AI2S;11|)
        (QREFELT |$| 17)))
      (EXIT (|error| "index out of range"))))
    (EXIT (SPADCALL |x| |s| (QREFELT |$| 36))))))) 

(DEFUN |STAGG-;setelt;AUs2S;12| (|x| |i| |s| |$|)
 (PROG (|l| |h| #1=#:G87086 #2=#:G87087 |z| |y|)
  (RETURN
   (SEQ 
    (LETT |l| 
     (|-| (SPADCALL |i| (QREFELT |$| 24)) (SPADCALL |x| (QREFELT |$| 20)))
      |STAGG-;setelt;AUs2S;12|)
    (EXIT
     (COND
      ((|<| |l| 0) (|error| "index out of range"))
      ((QUOTE T)
       (SEQ
        (LETT |h|
         (COND
          ((SPADCALL |i| (QREFELT |$| 25))
            (|-|
             (SPADCALL |i| (QREFELT |$| 27))
             (SPADCALL |x| (QREFELT |$| 20))))
          ((QUOTE T) (SPADCALL |x| (QREFELT |$| 41))))
         |STAGG-;setelt;AUs2S;12|)
        (EXIT
         (COND
          ((|<| |h| |l|) |s|)
          ((QUOTE T)
            (SEQ
             (LETT |y|
              (SPADCALL |x|
               (PROG1
                (LETT #1# |l| |STAGG-;setelt;AUs2S;12|)
                (|check-subtype|
                 (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
               (QREFELT |$| 21))
              |STAGG-;setelt;AUs2S;12|)
             (LETT |z|
              (SPADCALL |y|
               (PROG1
                (LETT #2# (|+| (|-| |h| |l|) 1) |STAGG-;setelt;AUs2S;12|)
                (|check-subtype|
                  (|>=| #2# 0) (QUOTE (|NonNegativeInteger|)) #2#))
               (QREFELT |$| 21))
              |STAGG-;setelt;AUs2S;12|)
             (SEQ 
               G190 
               (COND
                ((NULL
                  (COND
                   ((SPADCALL |y| |z| (QREFELT |$| 42)) (QUOTE NIL))
                   ((QUOTE T) (QUOTE T))))
                 (GO G191)))
               (SEQ
                (SPADCALL |y| |s| (QREFELT |$| 36))
                (EXIT
                 (LETT |y|
                  (SPADCALL |y| (QREFELT |$| 12))
                  |STAGG-;setelt;AUs2S;12|)))
               NIL
               (GO G190)
               G191
               (EXIT NIL))
             (EXIT |s|))))))))))))) 

(DEFUN |STAGG-;concat!;3A;13| (|x| |y| |$|)
 (SEQ
  (COND
   ((SPADCALL |x| (QREFELT |$| 17)) |y|)
   ((QUOTE T)
     (SEQ
      (SPADCALL (SPADCALL |x| (QREFELT |$| 44)) |y| (QREFELT |$| 45))
      (EXIT |x|)))))) 

(DEFUN |StreamAggregate&| (|#1| |#2|) 
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|StreamAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |StreamAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 51) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
     ((|HasAttribute| |#1| (QUOTE |shallowlyMutable|))
      (PROGN
       (QSETREFV |$| 32 (CONS (|dispatchFunction| |STAGG-;concat;3A;7|) |$|))
       (QSETREFV |$| 35 (CONS (|dispatchFunction| |STAGG-;concat;LA;8|) |$|))
       (QSETREFV |$| 38 (CONS (|dispatchFunction| |STAGG-;map!;M2A;9|) |$|))
       (QSETREFV |$| 39 (CONS (|dispatchFunction| |STAGG-;fill!;ASA;10|) |$|))
       (QSETREFV |$| 40
         (CONS (|dispatchFunction| |STAGG-;setelt;AI2S;11|) |$|))
       (QSETREFV |$| 43
         (CONS (|dispatchFunction| |STAGG-;setelt;AUs2S;12|) |$|))
       (QSETREFV |$| 46
         (CONS (|dispatchFunction| |STAGG-;concat!;3A;13|) |$|)))))
    |$|)))) 

(MAKEPROP
 (QUOTE |StreamAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) 
   (|Boolean|) (0 . |cyclic?|) |STAGG-;explicitlyFinite?;AB;1| 
   |STAGG-;possiblyInfinite?;AB;2| (5 . |rest|) (|List| 7) 
   (10 . |construct|) (|NonNegativeInteger|) |STAGG-;first;ANniA;3| 
   (15 . |empty?|) (20 . |first|) (|Integer|) (25 . |minIndex|) 
   (30 . |rest|) |STAGG-;elt;AIS;5| (|UniversalSegment| 19) (36 . |lo|) 
   (41 . |hasHi|) (46 . |copy|) (51 . |hi|) (56 . |empty|) (60 . |first|) 
   |STAGG-;elt;AUsA;6| (66 . |concat!|) (72 . |concat|) (|List| |$|) 
   (78 . |concat|) (83 . |concat|) (88 . |setfirst!|) (|Mapping| 7 7) 
   (94 . |map!|) (100 . |fill!|) (106 . |setelt|) (113 . |maxIndex|) 
   (118 . |eq?|) (124 . |setelt|) (131 . |tail|) (136 . |setrest!|) 
   (142 . |concat!|) (QUOTE "rest") (QUOTE "last") (QUOTE "first") 
   (QUOTE "value")))
  (QUOTE #(|setelt| 148 |possiblyInfinite?| 162 |map!| 167 |first| 173 
    |fill!| 179 |explicitlyFinite?| 185 |elt| 190 |concat!| 202 |concat| 208))
  (QUOTE NIL)
  (CONS 
   (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS 
    (QUOTE #())
    (CONS 
     (QUOTE #())
     (|makeByteWordVec2| 46 (QUOTE (1 6 8 0 9 1 6 0 0 12 1 6 0 13 14 1 6 
       8 0 17 1 6 7 0 18 1 6 19 0 20 2 6 0 0 15 21 1 23 19 0 24 1 23 8 
       0 25 1 6 0 0 26 1 23 19 0 27 0 6 0 28 2 6 0 0 15 29 2 6 0 0 0 31 
       2 0 0 0 0 32 1 6 0 33 34 1 0 0 33 35 2 6 7 0 7 36 2 0 0 37 0 38 2 
       0 0 0 7 39 3 0 7 0 19 7 40 1 6 19 0 41 2 6 8 0 0 42 3 0 7 0 23 7 43 
       1 6 0 0 44 2 6 0 0 0 45 2 0 0 0 0 46 3 0 7 0 19 7 40 3 0 7 0 23 7 43 
       1 0 8 0 11 2 0 0 37 0 38 2 0 0 0 15 16 2 0 0 0 7 39 1 0 8 0 10 2 0 7 
       0 19 22 2 0 0 0 23 30 2 0 0 0 0 46 1 0 0 33 35 2 0 0 0 0 32))))))
  (QUOTE |lookupComplete|))) 
@
\section{UFD.lsp BOOTSTRAP} 
{\bf UFD} needs
{\bf GCDDOM} which needs
{\bf COMRING} which needs
{\bf RING} which needs
{\bf RNG} which needs
{\bf ABELGRP} which needs
{\bf CABMON} which needs
{\bf ABELMON} which needs
{\bf ABELSG} which needs
{\bf SETCAT} which needs
{\bf SINT} which needs
{\bf UFD}.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf UFD} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf UFD.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<UFD.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |UniqueFactorizationDomain;AL| (QUOTE NIL)) 

(DEFUN |UniqueFactorizationDomain| NIL 
  (LET (#:G83334) 
    (COND 
      (|UniqueFactorizationDomain;AL|) 
      (T 
        (SETQ 
          |UniqueFactorizationDomain;AL| 
          (|UniqueFactorizationDomain;|)))))) 

(DEFUN |UniqueFactorizationDomain;| NIL 
  (PROG (#1=#:G83332) 
    (RETURN 
      (PROG1 
        (LETT #1# 
          (|Join| 
            (|GcdDomain|)
            (|mkCategory| 
              (QUOTE |domain|)
              (QUOTE (
                ((|prime?| ((|Boolean|) |$|)) T)
                ((|squareFree| ((|Factored| |$|) |$|)) T)
                ((|squareFreePart| (|$| |$|)) T)
                ((|factor| ((|Factored| |$|) |$|)) T)))
              NIL
              (QUOTE ((|Factored| |$|) (|Boolean|)))
              NIL))
          |UniqueFactorizationDomain|)
        (SETELT #1# 0 (QUOTE (|UniqueFactorizationDomain|))))))) 

(MAKEPROP (QUOTE |UniqueFactorizationDomain|) (QUOTE NILADIC) T) 

@
\section{UFD-.lsp BOOTSTRAP} 
{\bf UFD-} needs {\bf UFD}.
We need to break this cycle to build the algebra. So we keep a
cached copy of the translated {\bf UFD-} category which we can write
into the {\bf MID} directory. We compile the lisp code and copy the
{\bf UFD-.o} file to the {\bf OUT} directory.  This is eventually
forcibly replaced by a recompiled version.

Note that this code is not included in the generated catdef.spad file.

<<UFD-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |UFD-;squareFreePart;2S;1| (|x| |$|) 
  (PROG (|s| |f| #1=#:G83349 #2=#:G83347 #3=#:G83345 #4=#:G83346) 
    (RETURN 
      (SEQ 
        (SPADCALL 
          (SPADCALL 
            (LETT |s| 
              (SPADCALL |x| (QREFELT |$| 8))
              |UFD-;squareFreePart;2S;1|)
            (QREFELT |$| 10)) 
          (PROGN 
            (LETT #4# NIL |UFD-;squareFreePart;2S;1|)
            (SEQ 
              (LETT |f| NIL |UFD-;squareFreePart;2S;1|)
              (LETT #1# 
                (SPADCALL |s| (QREFELT |$| 13))
                |UFD-;squareFreePart;2S;1|)
              G190
              (COND 
                ((OR 
                   (ATOM #1#)
                   (PROGN 
                     (LETT |f| (CAR #1#) |UFD-;squareFreePart;2S;1|)
                     NIL))
                 (GO G191)))
              (SEQ 
                (EXIT 
                  (PROGN 
                    (LETT #2# (QCAR |f|) |UFD-;squareFreePart;2S;1|)
                    (COND 
                      (#4# 
                        (LETT #3# 
                          (SPADCALL #3# #2# (QREFELT |$| 14))
                          |UFD-;squareFreePart;2S;1|))
                      ((QUOTE T) 
                        (PROGN 
                          (LETT #3# #2# |UFD-;squareFreePart;2S;1|)
                          (LETT #4# (QUOTE T) 
                            |UFD-;squareFreePart;2S;1|)))))))
              (LETT #1# (CDR #1#) |UFD-;squareFreePart;2S;1|)
              (GO G190)
              G191
              (EXIT NIL))
            (COND 
              (#4# #3#) 
              ((QUOTE T) (|spadConstant| |$| 15))))
       (QREFELT |$| 14)))))) 

(DEFUN |UFD-;prime?;SB;2| (|x| |$|) 
  (EQL 
    (LENGTH (SPADCALL (SPADCALL |x| (QREFELT |$| 17)) (QREFELT |$| 21))) 1)) 

(DEFUN |UniqueFactorizationDomain&| (|#1|) 
  (PROG (|DV$1| |dv$| |$| |pv$|) 
    (RETURN 
      (PROGN 
        (LETT |DV$1| (|devaluate| |#1|) . #1=(|UniqueFactorizationDomain&|))
        (LETT |dv$| (LIST (QUOTE |UniqueFactorizationDomain&|) |DV$1|) . #1#)
        (LETT |$| (GETREFV 24) . #1#)
        (QSETREFV |$| 0 |dv$|)
        (QSETREFV |$| 3 (LETT |pv$| (|buildPredVector| 0 0 NIL) . #1#))
        (|stuffDomainSlots| |$|)
        (QSETREFV |$| 6 |#1|)
        |$|)))) 

(MAKEPROP 
  (QUOTE |UniqueFactorizationDomain&|)
  (QUOTE |infovec|)
  (LIST 
    (QUOTE 
      #(NIL NIL NIL NIL NIL NIL 
        (|local| |#1|)
        (|Factored| |$|)
        (0 . |squareFree|)
        (|Factored| 6)
        (5 . |unit|)
        (|Record| (|:| |factor| 6) (|:| |exponent| (|Integer|)))
        (|List| 11)
        (10 . |factors|)
        (15 . |*|)
        (21 . |One|)
        |UFD-;squareFreePart;2S;1| 
        (25 . |factor|)
        (|Union| 
          (QUOTE "nil") (QUOTE "sqfr") (QUOTE "irred") (QUOTE "prime"))
        (|Record| (|:| |flg| 18) (|:| |fctr| 6) (|:| |xpnt| (|Integer|)))
        (|List| 19)
        (30 . |factorList|)
        (|Boolean|)
        |UFD-;prime?;SB;2|)) 
     (QUOTE #(|squareFreePart| 35 |prime?| 40))
     (QUOTE NIL)
     (CONS 
       (|makeByteWordVec2| 1 (QUOTE NIL))
       (CONS 
         (QUOTE #())
         (CONS 
           (QUOTE #())
           (|makeByteWordVec2| 23 
             (QUOTE 
               (1 6 7 0 8 1 9 6 0 10 1 9 12 0 13 2 6 0 0 0 14 0 6 0 15 1 6 7
                0 17 1 9 20 0 21 1 0 0 0 16 1 0 22 0 23)))))) 
      (QUOTE |lookupComplete|))) 

@
\section{URAGG.lsp BOOTSTRAP}
{\bf URAGG} depends on a chain of files. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf URAGG}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf URAGG.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<URAGG.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(SETQ |UnaryRecursiveAggregate;CAT| (QUOTE NIL)) 

(SETQ |UnaryRecursiveAggregate;AL| (QUOTE NIL)) 

(DEFUN |UnaryRecursiveAggregate| (#1=#:G84596)
 (LET (#2=#:G84597)
  (COND
   ((SETQ #2# (|assoc| (|devaluate| #1#) |UnaryRecursiveAggregate;AL|))
     (CDR #2#))
   (T
    (SETQ |UnaryRecursiveAggregate;AL|
     (|cons5|
      (CONS (|devaluate| #1#) (SETQ #2# (|UnaryRecursiveAggregate;| #1#)))
      |UnaryRecursiveAggregate;AL|))
    #2#)))) 

(DEFUN |UnaryRecursiveAggregate;| (|t#1|)
 (PROG (#1=#:G84595)
  (RETURN
   (PROG1
    (LETT #1#
     (|sublisV|
      (PAIR (QUOTE (|t#1|)) (LIST (|devaluate| |t#1|)))
      (COND
       (|UnaryRecursiveAggregate;CAT|)
       ((QUOTE T)
        (LETT |UnaryRecursiveAggregate;CAT|
         (|Join|
          (|RecursiveAggregate| (QUOTE |t#1|))
          (|mkCategory|
           (QUOTE |domain|)
           (QUOTE (
            ((|concat| (|$| |$| |$|)) T)
            ((|concat| (|$| |t#1| |$|)) T)
            ((|first| (|t#1| |$|)) T)
            ((|elt| (|t#1| |$| "first")) T)
            ((|first| (|$| |$| (|NonNegativeInteger|))) T)
            ((|rest| (|$| |$|)) T)
            ((|elt| (|$| |$| "rest")) T)
            ((|rest| (|$| |$| (|NonNegativeInteger|))) T)
            ((|last| (|t#1| |$|)) T)
            ((|elt| (|t#1| |$| "last")) T)
            ((|last| (|$| |$| (|NonNegativeInteger|))) T)
            ((|tail| (|$| |$|)) T)
            ((|second| (|t#1| |$|)) T)
            ((|third| (|t#1| |$|)) T)
            ((|cycleEntry| (|$| |$|)) T)
            ((|cycleLength| ((|NonNegativeInteger|) |$|)) T)
            ((|cycleTail| (|$| |$|)) T)
            ((|concat!| (|$| |$| |$|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|concat!| (|$| |$| |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|cycleSplit!| (|$| |$|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setfirst!| (|t#1| |$| |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setelt| (|t#1| |$| "first" |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setrest!| (|$| |$| |$|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setelt| (|$| |$| "rest" |$|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setlast!| (|t#1| |$| |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|setelt| (|t#1| |$| "last" |t#1|))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))
            ((|split!| (|$| |$| (|Integer|)))
              (|has| |$| (ATTRIBUTE |shallowlyMutable|)))))
           NIL
           (QUOTE ((|Integer|) (|NonNegativeInteger|)))
           NIL))
         . #2=(|UnaryRecursiveAggregate|)))))
     . #2#)
    (SETELT #1# 0
     (LIST (QUOTE |UnaryRecursiveAggregate|) (|devaluate| |t#1|))))))) 
@
\section{URAGG-.lsp BOOTSTRAP}
{\bf URAGG-} depends on {\bf URAGG}. We need to break this cycle to build
the algebra. So we keep a cached copy of the translated {\bf URAGG-}
category which we can write into the {\bf MID} directory. We compile 
the lisp code and copy the {\bf URAGG-.o} file to the {\bf OUT} directory.
This is eventually forcibly replaced by a recompiled version. 

Note that this code is not included in the generated catdef.spad file.

<<URAGG-.lsp BOOTSTRAP>>=

(|/VERSIONCHECK| 2) 

(DEFUN |URAGG-;elt;AfirstS;1| (|x| G84610 |$|)
 (SPADCALL |x| (QREFELT |$| 8))) 

(DEFUN |URAGG-;elt;AlastS;2| (|x| G84612 |$|)
 (SPADCALL |x| (QREFELT |$| 11))) 

(DEFUN |URAGG-;elt;ArestA;3| (|x| G84614 |$|)
 (SPADCALL |x| (QREFELT |$| 14))) 

(DEFUN |URAGG-;second;AS;4| (|x| |$|)
 (SPADCALL (SPADCALL |x| (QREFELT |$| 14)) (QREFELT |$| 8))) 

(DEFUN |URAGG-;third;AS;5| (|x| |$|)
 (SPADCALL
  (SPADCALL (SPADCALL |x| (QREFELT |$| 14)) (QREFELT |$| 14))
  (QREFELT |$| 8))) 

(DEFUN |URAGG-;cyclic?;AB;6| (|x| |$|)
 (COND
  ((OR
    (SPADCALL |x| (QREFELT |$| 20))
    (SPADCALL (|URAGG-;findCycle| |x| |$|) (QREFELT |$| 20)))
     (QUOTE NIL))
   ((QUOTE T) (QUOTE T)))) 

(DEFUN |URAGG-;last;AS;7| (|x| |$|)
 (SPADCALL (SPADCALL |x| (QREFELT |$| 22)) (QREFELT |$| 8))) 

(DEFUN |URAGG-;nodes;AL;8| (|x| |$|)
 (PROG (|l|)
  (RETURN
   (SEQ
    (LETT |l| NIL |URAGG-;nodes;AL;8|)
    (SEQ 
     G190
     (COND
      ((NULL
        (COND
          ((SPADCALL |x| (QREFELT |$| 20)) (QUOTE NIL))
          ((QUOTE T) (QUOTE T))))
        (GO G191)))
     (SEQ
      (LETT |l| (CONS |x| |l|) |URAGG-;nodes;AL;8|)
      (EXIT (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;nodes;AL;8|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT (NREVERSE |l|)))))) 

(DEFUN |URAGG-;children;AL;9| (|x| |$|)
 (PROG (|l|)
  (RETURN
   (SEQ
    (LETT |l| NIL |URAGG-;children;AL;9|)
    (EXIT
     (COND
      ((SPADCALL |x| (QREFELT |$| 20)) |l|)
      ((QUOTE T) (CONS (SPADCALL |x| (QREFELT |$| 14)) |l|)))))))) 

(DEFUN |URAGG-;leaf?;AB;10| (|x| |$|)
 (SPADCALL |x| (QREFELT |$| 20))) 

(DEFUN |URAGG-;value;AS;11| (|x| |$|)
 (COND
  ((SPADCALL |x| (QREFELT |$| 20)) (|error| "value of empty object"))
  ((QUOTE T) (SPADCALL |x| (QREFELT |$| 8))))) 

(DEFUN |URAGG-;less?;ANniB;12| (|l| |n| |$|)
 (PROG (|i|)
  (RETURN
   (SEQ
    (LETT |i| |n| |URAGG-;less?;ANniB;12|)
    (SEQ 
     G190 
     (COND
      ((NULL
        (COND
         ((|<| 0 |i|)
          (COND
           ((SPADCALL |l| (QREFELT |$| 20)) (QUOTE NIL))
           ((QUOTE T) (QUOTE T))))
         ((QUOTE T) (QUOTE NIL))))
       (GO G191)))
     (SEQ 
      (LETT |l| (SPADCALL |l| (QREFELT |$| 14)) |URAGG-;less?;ANniB;12|)
      (EXIT (LETT |i| (|-| |i| 1) |URAGG-;less?;ANniB;12|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT (|<| 0 |i|)))))) 

(DEFUN |URAGG-;more?;ANniB;13| (|l| |n| |$|)
 (PROG (|i|)
  (RETURN
   (SEQ
    (LETT |i| |n| |URAGG-;more?;ANniB;13|)
    (SEQ
     G190
     (COND
      ((NULL
       (COND
        ((|<| 0 |i|)
         (COND
          ((SPADCALL |l| (QREFELT |$| 20)) (QUOTE NIL))
          ((QUOTE T) (QUOTE T))))
        ((QUOTE T) (QUOTE NIL))))
       (GO G191)))
     (SEQ
      (LETT |l| (SPADCALL |l| (QREFELT |$| 14)) |URAGG-;more?;ANniB;13|)
      (EXIT (LETT |i| (|-| |i| 1) |URAGG-;more?;ANniB;13|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT
     (COND
      ((ZEROP |i|)
       (COND
        ((SPADCALL |l| (QREFELT |$| 20)) (QUOTE NIL))
        ((QUOTE T) (QUOTE T))))
      ((QUOTE T) (QUOTE NIL)))))))) 

(DEFUN |URAGG-;size?;ANniB;14| (|l| |n| |$|)
 (PROG (|i|)
  (RETURN
   (SEQ
    (LETT |i| |n| |URAGG-;size?;ANniB;14|)
    (SEQ 
     G190 
     (COND
      ((NULL
       (COND
        ((SPADCALL |l| (QREFELT |$| 20)) (QUOTE NIL))
        ((QUOTE T) (|<| 0 |i|))))
       (GO G191)))
     (SEQ
      (LETT |l| (SPADCALL |l| (QREFELT |$| 14)) |URAGG-;size?;ANniB;14|)
      (EXIT (LETT |i| (|-| |i| 1) |URAGG-;size?;ANniB;14|)))
     NIL
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT
     (COND
      ((SPADCALL |l| (QREFELT |$| 20)) (ZEROP |i|))
      ((QUOTE T) (QUOTE NIL)))))))) 

(DEFUN |URAGG-;#;ANni;15| (|x| |$|)
 (PROG (|k|)
  (RETURN
   (SEQ
    (SEQ
     (LETT |k| 0 |URAGG-;#;ANni;15|)
     G190
     (COND
      ((NULL
        (COND
         ((SPADCALL |x| (QREFELT |$| 20)) (QUOTE NIL))
         ((QUOTE T) (QUOTE T))))
       (GO G191)))
     (SEQ
      (COND
       ((EQL |k| 1000)
         (COND
          ((SPADCALL |x| (QREFELT |$| 33)) (EXIT (|error| "cyclic list"))))))
       (EXIT (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;#;ANni;15|)))
     (LETT |k| (QSADD1 |k|) |URAGG-;#;ANni;15|)
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |k|))))) 

(DEFUN |URAGG-;tail;2A;16| (|x| |$|)
 (PROG (|k| |y|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |x| (QREFELT |$| 20)) (|error| "empty list"))
     ((QUOTE T)
      (SEQ
       (LETT |y| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;tail;2A;16|)
       (SEQ
        (LETT |k| 0 |URAGG-;tail;2A;16|)
        G190
        (COND
         ((NULL
           (COND
            ((SPADCALL |y| (QREFELT |$| 20)) (QUOTE NIL))
            ((QUOTE T) (QUOTE T))))
          (GO G191)))
        (SEQ
         (COND
          ((EQL |k| 1000)
            (COND
             ((SPADCALL |x| (QREFELT |$| 33))
               (EXIT (|error| "cyclic list"))))))
         (EXIT 
          (LETT |y|
           (SPADCALL (LETT |x| |y| |URAGG-;tail;2A;16|) (QREFELT |$| 14))
           |URAGG-;tail;2A;16|)))
        (LETT |k| (QSADD1 |k|) |URAGG-;tail;2A;16|)
        (GO G190)
        G191
        (EXIT NIL))
       (EXIT |x|)))))))) 

(DEFUN |URAGG-;findCycle| (|x| |$|)
 (PROG (#1=#:G84667 |y|)
  (RETURN
   (SEQ
    (EXIT
     (SEQ
      (LETT |y| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;findCycle|)
      (SEQ 
       G190 
       (COND
        ((NULL
          (COND
           ((SPADCALL |y| (QREFELT |$| 20)) (QUOTE NIL))
           ((QUOTE T) (QUOTE T))))
         (GO G191)))
       (SEQ
        (COND
         ((SPADCALL |x| |y| (QREFELT |$| 36))
           (PROGN (LETT #1# |x| |URAGG-;findCycle|) (GO #1#))))
        (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;findCycle|)
        (LETT |y| (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;findCycle|)
        (COND
         ((SPADCALL |y| (QREFELT |$| 20))
           (PROGN (LETT #1# |y| |URAGG-;findCycle|) (GO #1#))))
        (COND
         ((SPADCALL |x| |y| (QREFELT |$| 36))
           (PROGN (LETT #1# |y| |URAGG-;findCycle|) (GO #1#))))
        (EXIT (LETT |y| (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;findCycle|)))
       NIL
       (GO G190)
       G191
       (EXIT NIL))
      (EXIT |y|)))
    #1#
    (EXIT #1#))))) 

(DEFUN |URAGG-;cycleTail;2A;18| (|x| |$|)
 (PROG (|y| |z|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL
       (LETT |y|
        (LETT |x| (SPADCALL |x| (QREFELT |$| 37)) |URAGG-;cycleTail;2A;18|)
        |URAGG-;cycleTail;2A;18|)
       (QREFELT |$| 20))
      |x|)
     ((QUOTE T)
       (SEQ
        (LETT |z| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;cycleTail;2A;18|)
        (SEQ 
         G190
         (COND
          ((NULL
            (COND
             ((SPADCALL |x| |z| (QREFELT |$| 36)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ
          (LETT |y| |z| |URAGG-;cycleTail;2A;18|)
          (EXIT
           (LETT |z|
            (SPADCALL |z| (QREFELT |$| 14)) |URAGG-;cycleTail;2A;18|)))
         NIL
         (GO G190)
         G191
         (EXIT NIL))
        (EXIT |y|)))))))) 

(DEFUN |URAGG-;cycleEntry;2A;19| (|x| |$|)
 (PROG (|l| |z| |k| |y|)
  (RETURN
   (SEQ
    (COND
     ((SPADCALL |x| (QREFELT |$| 20)) |x|)
     ((SPADCALL
       (LETT |y| (|URAGG-;findCycle| |x| |$|) |URAGG-;cycleEntry;2A;19|)
       (QREFELT |$| 20))
      |y|)
     ((QUOTE T)
      (SEQ
       (LETT |z| (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;cycleEntry;2A;19|)
       (SEQ
        (LETT |l| 1 |URAGG-;cycleEntry;2A;19|)
        G190
        (COND 
         ((NULL
           (COND
            ((SPADCALL |y| |z| (QREFELT |$| 36)) (QUOTE NIL))
            ((QUOTE T) (QUOTE T))))
           (GO G191)))
        (SEQ
         (EXIT
          (LETT |z|
           (SPADCALL |z| (QREFELT |$| 14)) |URAGG-;cycleEntry;2A;19|)))
        (LETT |l|
         (QSADD1 |l|) |URAGG-;cycleEntry;2A;19|) (GO G190) G191 (EXIT NIL))
       (LETT |y| |x| |URAGG-;cycleEntry;2A;19|)
       (SEQ
        (LETT |k| 1 |URAGG-;cycleEntry;2A;19|)
        G190
        (COND ((QSGREATERP |k| |l|) (GO G191)))
        (SEQ
         (EXIT
          (LETT |y|
           (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;cycleEntry;2A;19|)))
        (LETT |k| (QSADD1 |k|) |URAGG-;cycleEntry;2A;19|)
        (GO G190)
        G191
        (EXIT NIL))
       (SEQ 
        G190 
        (COND
          ((NULL
            (COND
             ((SPADCALL |x| |y| (QREFELT |$| 36)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
        (SEQ
         (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;cycleEntry;2A;19|)
         (EXIT
          (LETT |y|
           (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;cycleEntry;2A;19|)))
        NIL
        (GO G190)
        G191 
        (EXIT NIL))
       (EXIT |x|)))))))) 

(DEFUN |URAGG-;cycleLength;ANni;20| (|x| |$|)
 (PROG (|k| |y|)
  (RETURN
   (SEQ
    (COND
     ((OR
       (SPADCALL |x| (QREFELT |$| 20))
       (SPADCALL
        (LETT |x| (|URAGG-;findCycle| |x| |$|) |URAGG-;cycleLength;ANni;20|)
        (QREFELT |$| 20)))
       0)
     ((QUOTE T)
      (SEQ
       (LETT |y| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;cycleLength;ANni;20|)
       (SEQ
        (LETT |k| 1 |URAGG-;cycleLength;ANni;20|)
        G190
        (COND
         ((NULL
           (COND
             ((SPADCALL |x| |y| (QREFELT |$| 36)) (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
          (GO G191)))
        (SEQ
         (EXIT
          (LETT |y|
           (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;cycleLength;ANni;20|)))
        (LETT |k| (QSADD1 |k|) |URAGG-;cycleLength;ANni;20|)
        (GO G190)
         G191
         (EXIT NIL))
       (EXIT |k|)))))))) 

(DEFUN |URAGG-;rest;ANniA;21| (|x| |n| |$|)
 (PROG (|i|)
  (RETURN
   (SEQ
    (SEQ
     (LETT |i| 1 |URAGG-;rest;ANniA;21|)
     G190
     (COND ((QSGREATERP |i| |n|) (GO G191)))
     (SEQ
      (EXIT
       (COND
        ((SPADCALL |x| (QREFELT |$| 20)) (|error| "Index out of range"))
        ((QUOTE T)
          (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;rest;ANniA;21|)))))
     (LETT |i| (QSADD1 |i|) |URAGG-;rest;ANniA;21|)
     (GO G190)
     G191
     (EXIT NIL))
    (EXIT |x|))))) 

(DEFUN |URAGG-;last;ANniA;22| (|x| |n| |$|)
 (PROG (|m| #1=#:G84694)
  (RETURN
   (SEQ
    (LETT |m| (SPADCALL |x| (QREFELT |$| 42)) |URAGG-;last;ANniA;22|)
    (EXIT
     (COND
      ((|<| |m| |n|) (|error| "index out of range"))
      ((QUOTE T)
       (SPADCALL
        (SPADCALL |x|
         (PROG1
          (LETT #1# (|-| |m| |n|) |URAGG-;last;ANniA;22|)
          (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
         (QREFELT |$| 43))
        (QREFELT |$| 44))))))))) 

(DEFUN |URAGG-;=;2AB;23| (|x| |y| |$|)
 (PROG (|k| #1=#:G84705) 
  (RETURN
   (SEQ
    (EXIT
     (COND
      ((SPADCALL |x| |y| (QREFELT |$| 36)) (QUOTE T))
      ((QUOTE T)
       (SEQ
        (SEQ
         (LETT |k| 0 |URAGG-;=;2AB;23|)
         G190 
         (COND
          ((NULL
            (COND
             ((OR
               (SPADCALL |x| (QREFELT |$| 20))
               (SPADCALL |y| (QREFELT |$| 20)))
               (QUOTE NIL))
             ((QUOTE T) (QUOTE T))))
           (GO G191)))
         (SEQ 
          (COND
           ((EQL |k| 1000)
            (COND
             ((SPADCALL |x| (QREFELT |$| 33))
               (EXIT (|error| "cyclic list"))))))
          (COND
           ((NULL
             (SPADCALL
              (SPADCALL |x| (QREFELT |$| 8))
              (SPADCALL |y| (QREFELT |$| 8))
              (QREFELT |$| 46)))
            (EXIT (PROGN (LETT #1# (QUOTE NIL) |URAGG-;=;2AB;23|) (GO #1#)))))
          (LETT |x| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;=;2AB;23|)
          (EXIT (LETT |y| (SPADCALL |y| (QREFELT |$| 14)) |URAGG-;=;2AB;23|)))
         (LETT |k| (QSADD1 |k|) |URAGG-;=;2AB;23|)
         (GO G190)
         G191
         (EXIT NIL))
        (EXIT
         (COND
          ((SPADCALL |x| (QREFELT |$| 20)) (SPADCALL |y| (QREFELT |$| 20)))
          ((QUOTE T) (QUOTE NIL))))))))
    #1# 
    (EXIT #1#))))) 

(DEFUN |URAGG-;node?;2AB;24| (|u| |v| |$|)
 (PROG (|k| #1=#:G84711)
  (RETURN
   (SEQ
    (EXIT
     (SEQ
      (SEQ
       (LETT |k| 0 |URAGG-;node?;2AB;24|)
       G190
       (COND
         ((NULL 
          (COND 
           ((SPADCALL |v| (QREFELT |$| 20)) (QUOTE NIL))
           ((QUOTE T) (QUOTE T)))) 
        (GO G191)))
       (SEQ 
        (EXIT 
         (COND 
          ((SPADCALL |u| |v| (QREFELT |$| 48))
            (PROGN (LETT #1# (QUOTE T) |URAGG-;node?;2AB;24|) (GO #1#)))
          ((QUOTE T)
           (SEQ
            (COND
             ((EQL |k| 1000)
              (COND
               ((SPADCALL |v| (QREFELT |$| 33))
                 (EXIT (|error| "cyclic list"))))))
            (EXIT
             (LETT |v|
              (SPADCALL |v| (QREFELT |$| 14))
              |URAGG-;node?;2AB;24|)))))))
       (LETT |k| (QSADD1 |k|) |URAGG-;node?;2AB;24|) (GO G190) G191 (EXIT NIL))
      (EXIT (SPADCALL |u| |v| (QREFELT |$| 48)))))
    #1# (EXIT #1#))))) 

(DEFUN |URAGG-;setelt;Afirst2S;25| (|x| G84713 |a| |$|)
 (SPADCALL |x| |a| (QREFELT |$| 50))) 

(DEFUN |URAGG-;setelt;Alast2S;26| (|x| G84715 |a| |$|) 
 (SPADCALL |x| |a| (QREFELT |$| 52))) 

(DEFUN |URAGG-;setelt;Arest2A;27| (|x| G84717 |a| |$|)
 (SPADCALL |x| |a| (QREFELT |$| 54))) 

(DEFUN |URAGG-;concat;3A;28| (|x| |y| |$|)
 (SPADCALL (SPADCALL |x| (QREFELT |$| 44)) |y| (QREFELT |$| 56))) 

(DEFUN |URAGG-;setlast!;A2S;29| (|x| |s| |$|)
 (SEQ
  (COND
   ((SPADCALL |x| (QREFELT |$| 20)) (|error| "setlast: empty list"))
   ((QUOTE T)
    (SEQ
     (SPADCALL (SPADCALL |x| (QREFELT |$| 22)) |s| (QREFELT |$| 50))
     (EXIT |s|)))))) 

(DEFUN |URAGG-;setchildren!;ALA;30| (|u| |lv| |$|)
 (COND
  ((EQL (LENGTH |lv|) 1) (SPADCALL |u| (|SPADfirst| |lv|) (QREFELT |$| 54)))
  ((QUOTE T) (|error| "wrong number of children specified")))) 

(DEFUN |URAGG-;setvalue!;A2S;31| (|u| |s| |$|)
 (SPADCALL |u| |s| (QREFELT |$| 50))) 

(DEFUN |URAGG-;split!;AIA;32| (|p| |n| |$|)
 (PROG (#1=#:G84725 |q|)
  (RETURN
   (SEQ
    (COND
     ((|<| |n| 1) (|error| "index out of range"))
     ((QUOTE T)
      (SEQ
       (LETT |p|
        (SPADCALL |p|
         (PROG1
          (LETT #1# (|-| |n| 1) |URAGG-;split!;AIA;32|)
          (|check-subtype| (|>=| #1# 0) (QUOTE (|NonNegativeInteger|)) #1#))
         (QREFELT |$| 43))
        |URAGG-;split!;AIA;32|)
       (LETT |q| (SPADCALL |p| (QREFELT |$| 14)) |URAGG-;split!;AIA;32|)
       (SPADCALL |p| (SPADCALL (QREFELT |$| 61)) (QREFELT |$| 54))
       (EXIT |q|)))))))) 

(DEFUN |URAGG-;cycleSplit!;2A;33| (|x| |$|)
 (PROG (|y| |z|)
  (RETURN
   (SEQ
    (COND
     ((OR 
       (SPADCALL
        (LETT |y| (SPADCALL |x| (QREFELT |$| 37)) |URAGG-;cycleSplit!;2A;33|)
        (QREFELT |$| 20))
       (SPADCALL |x| |y| (QREFELT |$| 36))) |y|)
     ((QUOTE T)
      (SEQ
       (LETT |z| (SPADCALL |x| (QREFELT |$| 14)) |URAGG-;cycleSplit!;2A;33|)
       (SEQ G190
        (COND 
         ((NULL
           (COND
            ((SPADCALL |z| |y| (QREFELT |$| 36)) (QUOTE NIL))
            ((QUOTE T) (QUOTE T))))
          (GO G191)))
        (SEQ
         (LETT |x| |z| |URAGG-;cycleSplit!;2A;33|)
         (EXIT
          (LETT |z|
           (SPADCALL |z| (QREFELT |$| 14)) |URAGG-;cycleSplit!;2A;33|)))
        NIL
        (GO G190)
        G191
        (EXIT NIL))
       (SPADCALL |x|
        (SPADCALL (QREFELT |$| 61)) (QREFELT |$| 54)) (EXIT |y|)))))))) 

(DEFUN |UnaryRecursiveAggregate&| (|#1| |#2|)
 (PROG (|DV$1| |DV$2| |dv$| |$| |pv$|)
  (RETURN
   (PROGN
    (LETT |DV$1| (|devaluate| |#1|) . #1=(|UnaryRecursiveAggregate&|))
    (LETT |DV$2| (|devaluate| |#2|) . #1#)
    (LETT |dv$| (LIST (QUOTE |UnaryRecursiveAggregate&|) |DV$1| |DV$2|) . #1#)
    (LETT |$| (GETREFV 66) . #1#)
    (QSETREFV |$| 0 |dv$|)
    (QSETREFV |$| 3
     (LETT |pv$|
      (|buildPredVector| 0 0
       (LIST (|HasAttribute| |#1| (QUOTE |shallowlyMutable|))))
      . #1#))
    (|stuffDomainSlots| |$|)
    (QSETREFV |$| 6 |#1|)
    (QSETREFV |$| 7 |#2|)
    (COND
      ((|HasAttribute| |#1| (QUOTE |finiteAggregate|))
        (QSETREFV |$| 45
          (CONS (|dispatchFunction| |URAGG-;last;ANniA;22|) |$|))))
    (COND
     ((|HasCategory| |#2| (QUOTE (|SetCategory|)))
      (PROGN
       (QSETREFV |$| 47 (CONS (|dispatchFunction| |URAGG-;=;2AB;23|) |$|))
       (QSETREFV |$| 49
        (CONS (|dispatchFunction| |URAGG-;node?;2AB;24|) |$|)))))
    (COND
     ((|testBitVector| |pv$| 1)
      (PROGN
       (QSETREFV |$| 51
        (CONS (|dispatchFunction| |URAGG-;setelt;Afirst2S;25|) |$|))
       (QSETREFV |$| 53
        (CONS (|dispatchFunction| |URAGG-;setelt;Alast2S;26|) |$|))
       (QSETREFV |$| 55
        (CONS (|dispatchFunction| |URAGG-;setelt;Arest2A;27|) |$|))
       (QSETREFV |$| 57
        (CONS (|dispatchFunction| |URAGG-;concat;3A;28|) |$|))
       (QSETREFV |$| 58
        (CONS (|dispatchFunction| |URAGG-;setlast!;A2S;29|) |$|))
       (QSETREFV |$| 59
        (CONS (|dispatchFunction| |URAGG-;setchildren!;ALA;30|) |$|))
       (QSETREFV |$| 60
        (CONS (|dispatchFunction| |URAGG-;setvalue!;A2S;31|) |$|))
       (QSETREFV |$| 63
        (CONS (|dispatchFunction| |URAGG-;split!;AIA;32|) |$|))
       (QSETREFV |$| 64
        (CONS (|dispatchFunction| |URAGG-;cycleSplit!;2A;33|) |$|)))))
    |$|)))) 

(MAKEPROP
 (QUOTE |UnaryRecursiveAggregate&|)
 (QUOTE |infovec|)
 (LIST
  (QUOTE #(NIL NIL NIL NIL NIL NIL (|local| |#1|) (|local| |#2|) 
   (0 . |first|) (QUOTE "first") |URAGG-;elt;AfirstS;1| (5 . |last|) 
   (QUOTE "last") |URAGG-;elt;AlastS;2| (10 . |rest|) (QUOTE "rest") 
   |URAGG-;elt;ArestA;3| |URAGG-;second;AS;4| |URAGG-;third;AS;5| 
   (|Boolean|) (15 . |empty?|) |URAGG-;cyclic?;AB;6| (20 . |tail|) 
   |URAGG-;last;AS;7| (|List| |$|) |URAGG-;nodes;AL;8| 
   |URAGG-;children;AL;9| |URAGG-;leaf?;AB;10| |URAGG-;value;AS;11| 
   (|NonNegativeInteger|) |URAGG-;less?;ANniB;12| |URAGG-;more?;ANniB;13| 
   |URAGG-;size?;ANniB;14| (25 . |cyclic?|) |URAGG-;#;ANni;15| 
   |URAGG-;tail;2A;16| (30 . |eq?|) (36 . |cycleEntry|) 
   |URAGG-;cycleTail;2A;18| |URAGG-;cycleEntry;2A;19| 
   |URAGG-;cycleLength;ANni;20| |URAGG-;rest;ANniA;21| (41 . |#|) 
   (46 . |rest|) (52 . |copy|) (57 . |last|) (63 . |=|) (69 . |=|) 
   (75 . |=|) (81 . |node?|) (87 . |setfirst!|) (93 . |setelt|) 
   (100 . |setlast!|) (106 . |setelt|) (113 . |setrest!|) 
   (119 . |setelt|) (126 . |concat!|) (132 . |concat|) (138 . |setlast!|) 
   (144 . |setchildren!|) (150 . |setvalue!|) (156 . |empty|) (|Integer|) 
   (160 . |split!|) (166 . |cycleSplit!|) (QUOTE "value")))
  (QUOTE #(|value| 171 |third| 176 |tail| 181 |split!| 186 |size?| 192 
   |setvalue!| 198 |setlast!| 204 |setelt| 210 |setchildren!| 231 |second| 
   237 |rest| 242 |nodes| 248 |node?| 253 |more?| 259 |less?| 265 |leaf?| 
   271 |last| 276 |elt| 287 |cyclic?| 305 |cycleTail| 310 |cycleSplit!| 
   315 |cycleLength| 320 |cycleEntry| 325 |concat| 330 |children| 336 |=| 
   341 |#| 347))
  (QUOTE NIL)
  (CONS 
   (|makeByteWordVec2| 1 (QUOTE NIL))
   (CONS 
    (QUOTE #())
    (CONS 
     (QUOTE #())
     (|makeByteWordVec2| 64 (QUOTE (1 6 7 0 8 1 6 7 0 11 1 6 0 0 14 1 6 
       19 0 20 1 6 0 0 22 1 6 19 0 33 2 6 19 0 0 36 1 6 0 0 37 1 6 29 0 
       42 2 6 0 0 29 43 1 6 0 0 44 2 0 0 0 29 45 2 7 19 0 0 46 2 0 19 0 
       0 47 2 6 19 0 0 48 2 0 19 0 0 49 2 6 7 0 7 50 3 0 7 0 9 7 51 2 6 
       7 0 7 52 3 0 7 0 12 7 53 2 6 0 0 0 54 3 0 0 0 15 0 55 2 6 0 0 0 56 
       2 0 0 0 0 57 2 0 7 0 7 58 2 0 0 0 24 59 2 0 7 0 7 60 0 6 0 61 2 0 
       0 0 62 63 1 0 0 0 64 1 0 7 0 28 1 0 7 0 18 1 0 0 0 35 2 0 0 0 62 63 
       2 0 19 0 29 32 2 0 7 0 7 60 2 0 7 0 7 58 3 0 7 0 12 7 53 3 0 0 0 15 
       0 55 3 0 7 0 9 7 51 2 0 0 0 24 59 1 0 7 0 17 2 0 0 0 29 41 1 0 24 0 
       25 2 0 19 0 0 49 2 0 19 0 29 31 2 0 19 0 29 30 1 0 19 0 27 2 0 0 0 
       29 45 1 0 7 0 23 2 0 7 0 12 13 2 0 0 0 15 16 2 0 7 0 9 10 1 0 19 0 
       21 1 0 0 0 38 1 0 0 0 64 1 0 29 0 40 1 0 0 0 39 2 0 0 0 0 57 1 0 24 
       0 26 2 0 19 0 0 47 1 0 29 0 34))))))
  (QUOTE |lookupComplete|))) 
@
\chapter{Chunk collections}
<<algebra>>=
<<category ABELGRP AbelianGroup>>
<<category ABELMON AbelianMonoid>>
<<category ABELSG AbelianSemiGroup>>
<<category AGG Aggregate>>
<<category AHYP ArcHyperbolicFunctionCategory>>
<<category ALAGG AssociationListAggregate>>
<<category ALGEBRA Algebra>>
<<category ARR2CAT TwoDimensionalArrayCategory>>
<<category ATRIG ArcTrigonometricFunctionCategory>>
<<category ATTREG AttributeRegistry>>
<<category A1AGG OneDimensionalArrayAggregate>>
<<category BASTYPE BasicType>>
<<category BGAGG BagAggregate>>
<<category BMODULE BiModule>>
<<category BRAGG BinaryRecursiveAggregate>>
<<category BTAGG BitAggregate>>
<<category CABMON CancellationAbelianMonoid>>
<<category CFCAT CombinatorialFunctionCategory>>
<<category CHARNZ CharacteristicNonZero>>
<<category CHARZ CharacteristicZero>>
<<category CLAGG Collection>>
<<category COMRING CommutativeRing>>
<<category DIAGG Dictionary>>
<<category DIFEXT DifferentialExtension>>
<<category DIFRING DifferentialRing>>
<<category DIOPS DictionaryOperations>>
<<category DIVRING DivisionRing>>
<<category DLAGG DoublyLinkedAggregate>>
<<category DQAGG DequeueAggregate>>
<<category ELAGG ExtensibleLinearAggregate>>
<<category ELEMFUN ElementaryFunctionCategory>>
<<category ELTAB Eltable>>
<<category ELTAGG EltableAggregate>>
<<category ENTIRER EntireRing>>
<<category EUCDOM EuclideanDomain>>
<<category EVALAB Evalable>>
<<category FIELD Field>>
<<category FINAALG FiniteRankNonAssociativeAlgebra>>
<<category FINITE Finite>>
<<category FINRALG FiniteRankAlgebra>>
<<category FFCAT FunctionFieldCategory>>
<<category FLAGG FiniteLinearAggregate>>
<<category FLINEXP FullyLinearlyExplicitRingOver>>
<<category FRAMALG FramedAlgebra>>
<<category FRETRCT FullyRetractableTo>>
<<category FRNAALG FramedNonAssociativeAlgebra>>
<<category FSAGG FiniteSetAggregate>>
<<category GCDDOM GcdDomain>>
<<category GRALG GradedAlgebra>>
<<category GRMOD GradedModule>>
<<category GROUP Group>>
<<category HOAGG HomogeneousAggregate>>
<<category HYPCAT HyperbolicFunctionCategory>>
<<category IEVALAB InnerEvalable>>
<<category INTDOM IntegralDomain>>
<<category IXAGG IndexedAggregate>>
<<category KDAGG KeyedDictionary>>
<<category KOERCE CoercibleTo>>
<<category KONVERT ConvertibleTo>>
<<category LFCAT LiouvillianFunctionCategory>>
<<category LINEXP LinearlyExplicitRingOver>>
<<category LMODULE LeftModule>>
<<category LNAGG LinearAggregate>>
<<category LOGIC Logic>>
<<category LSAGG ListAggregate>>
<<category MODULE Module>>
<<category MONAD Monad>>
<<category MONADWU MonadWithUnit>>
<<category MONOID Monoid>>
<<category MONOGEN MonogenicAlgebra>>
<<category MDAGG MultiDictionary>>
<<category MSETAGG MultisetAggregate>>
<<category NAALG NonAssociativeAlgebra>>
<<category NARNG NonAssociativeRng>>
<<category NASRING NonAssociativeRing>>
<<category OAGROUP OrderedAbelianGroup>>
<<category OAMON OrderedAbelianMonoid>>
<<category OAMONS OrderedAbelianMonoidSup>>
<<category OASGP OrderedAbelianSemiGroup>>
<<category OCAMON OrderedCancellationAbelianMonoid>>
<<category OINTDOM OrderedIntegralDomain>>
<<category OMSAGG OrderedMultisetAggregate>>
<<category ORDFIN OrderedFinite>>
<<category ORDMON OrderedMonoid>>
<<category ORDRING OrderedRing>>
<<category ORDSET OrderedSet>>
<<category PDRING PartialDifferentialRing>>
<<category PFECAT PolynomialFactorizationExplicit>>
<<category PID PrincipalIdealDomain>>
<<category PRIMCAT PrimitiveFunctionCategory>>
<<category PRQAGG PriorityQueueAggregate>>
<<category QUAGG QueueAggregate>>
<<category RCAGG RecursiveAggregate>>
<<category RETRACT RetractableTo>>
<<category RING Ring>>
<<category RMODULE RightModule>>
<<category RNG Rng>>
<<category SETAGG SetAggregate>>
<<category SETCAT SetCategory>>
<<category SGROUP SemiGroup>>
<<category SKAGG StackAggregate>>
<<category SPFCAT SpecialFunctionCategory>>
<<category SRAGG StringAggregate>>
<<category STAGG StreamAggregate>>
<<category STEP StepThrough>>
<<category TRANFUN TranscendentalFunctionCategory>>
<<category TRIGCAT TrigonometricFunctionCategory>>
<<category TYPE Type>>
<<category TBAGG TableAggregate>>
<<category UFD UniqueFactorizationDomain>>
<<category URAGG UnaryRecursiveAggregate>>
<<category VSPACE VectorSpace>>
@
<<dotabb>>=
digraph dotabb {
 ranksep=1.25;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

<<CATEGORY.dotabb>>
<<ABELGRP.dotabb>>
<<ABELMON.dotabb>>
<<ABELSG.dotabb>>
<<AGG.dotabb>>
<<AHYP.dotabb>>
<<ALAGG.dotabb>>
<<ALGEBRA.dotabb>>
<<ARR2CAT.dotabb>>
<<ATRIG.dotabb>>
<<ATTREG.dotabb>>
<<A1AGG.dotabb>>
<<BASTYPE.dotabb>>
<<BGAGG.dotabb>>
<<BMODULE.dotabb>>
<<BRAGG.dotabb>>
<<BTAGG.dotabb>>
<<CABMON.dotabb>>
<<CFCAT.dotabb>>
<<CHARNZ.dotabb>>
<<CHARZ.dotabb>>
<<CLAGG.dotabb>>
<<COMRING.dotabb>>
<<DIAGG.dotabb>>
<<DIFEXT.dotabb>>
<<DIOPS.dotabb>>
<<DIVRING.dotabb>>
<<DLAGG.dotabb>>
<<DQAGG.dotabb>>
<<ELAGG.dotabb>>
<<ELEMFUN.dotabb>>
<<ELTAB.dotabb>>
<<ELTAGG.dotabb>>
<<ENTIRER.dotabb>>
<<EUCDOM.dotabb>>
<<EVALAB.dotabb>>
<<FIELD.dotabb>>
<<FINAALG.dotabb>>
<<FINITE.dotabb>>
<<FINRALG.dotabb>>
<<FFCAT.dotabb>>
<<FLAGG.dotabb>>
<<FLINEXP.dotabb>>
<<FRAMALG.dotabb>>
<<FRETRCT.dotabb>>
<<FRNAALG.dotabb>>
<<FSAGG.dotabb>>
<<GCDDOM.dotabb>>
<<GRALG.dotabb>>
<<GRMOD.dotabb>>
<<HOAGG.dotabb>>
<<HYPCAT.dotabb>>
<<IEVALAB.dotabb>>
<<INTDOM.dotabb>>
<<IXAGG.dotabb>>
<<KDAGG.dotabb>>
<<KOERCE.dotabb>>
<<KONVERT.dotabb>>
<<LFCAT.dotabb>>
<<LINEXP.dotabb>>
<<LMODULE.dotabb>>
<<LNAGG.dotabb>>
<<LOGIC.dotabb>>
<<LSAGG.dotabb>>
<<MODULE.dotabb>>
<<MONAD.dotabb>>
<<MONADWU.dotabb>>
<<MDAGG.dotabb>>
<<MONOID.dotabb>>
<<MONOGEN.dotabb>>
<<MSETAGG.dotabb>>
<<NAALG.dotabb>>
<<NARNG.dotabb>>
<<NASRING.dotabb>>
<<OAGROUP.dotabb>>
<<OAMON.dotabb>>
<<OAMONS.dotabb>>
<<OASGP.dotabb>>
<<OCAMON.dotabb>>
<<OINTDOM.dotabb>>
<<OMSAGG.dotabb>>
<<ORDFIN.dotabb>>
<<ORDMON.dotabb>>
<<ORDRING.dotabb>>
<<ORDSET.dotabb>>
<<PDRING.dotabb>>
<<PFECAT.dotabb>>
<<PID.dotabb>>
<<PRIMCAT.dotabb>>
<<PRQAGG.dotabb>>
<<QUAGG.dotabb>>
<<RCAGG.dotabb>>
<<RETRACT.dotabb>>
<<RING.dotabb>>
<<RMODULE.dotabb>>
<<RNG.dotabb>>
<<SETAGG.dotabb>>
<<SETCAT.dotabb>>
<<SGROUP.dotabb>>
<<SKAGG.dotabb>>
<<SPFCAT.dotabb>>
<<SRAGG.dotabb>>
<<STAGG.dotabb>>
<<STEP.dotabb>>
<<TRANFUN.dotabb>>
<<TRIGCAT.dotabb>>
<<TYPE.dotabb>>
<<TBAGG.dotabb>>
<<UFD.dotabb>>
<<URAGG.dotabb>>
<<VSPACE.dotabb>>
}
@
<<dotfull>>=
digraph dotfull {
 ranksep=1.25;
 nodesep=1.5;
 fontsize=10;
 bgcolor="#FFFF66";
 node [shape=box, color=white, style=filled];

<<CATEGORY.dotfull>>
<<ABELGRP.dotfull>>
<<ABELMON.dotfull>>
<<ABELSG.dotfull>>
<<AGG.dotfull>>
<<AHYP.dotfull>>
<<ALAGG.dotfull>>
<<ALGEBRA.dotfull>>
<<ARR2CAT.dotfull>>
<<ATRIG.dotfull>>
<<ATTREG.dotfull>>
<<A1AGG.dotfull>>
<<BASTYPE.dotfull>>
<<BGAGG.dotfull>>
<<BMODULE.dotfull>>
<<BRAGG.dotfull>>
<<BTAGG.dotfull>>
<<CABMON.dotfull>>
<<CFCAT.dotfull>>
<<CHARNZ.dotfull>>
<<CHARZ.dotfull>>
<<CLAGG.dotfull>>
<<COMRING.dotfull>>
<<DIAGG.dotfull>>
<<DIFEXT.dotfull>>
<<DIOPS.dotfull>>
<<DIVRING.dotfull>>
<<DLAGG.dotfull>>
<<DQAGG.dotfull>>
<<ELAGG.dotfull>>
<<ELEMFUN.dotfull>>
<<ELTAB.dotfull>>
<<ELTAGG.dotfull>>
<<ENTIRER.dotfull>>
<<EUCDOM.dotfull>>
<<EVALAB.dotfull>>
<<FIELD.dotfull>>
<<FINAALG.dotfull>>
<<FINITE.dotfull>>
<<FINRALG.dotfull>>
<<FFCAT.dotfull>>
<<FLAGG.dotfull>>
<<FLINEXP.dotfull>>
<<FRAMALG.dotfull>>
<<FRETRCT.dotfull>>
<<FRNAALG.dotfull>>
<<FSAGG.dotfull>>
<<GCDDOM.dotfull>>
<<GRALG.dotfull>>
<<GRMOD.dotfull>>
<<HOAGG.dotfull>>
<<HYPCAT.dotfull>>
<<IEVALAB.dotfull>>
<<INTDOM.dotfull>>
<<IXAGG.dotfull>>
<<KDAGG.dotfull>>
<<KOERCE.dotfull>>
<<KONVERT.dotfull>>
<<LFCAT.dotfull>>
<<LINEXP.dotfull>>
<<LMODULE.dotfull>>
<<LNAGG.dotfull>>
<<LOGIC.dotfull>>
<<LSAGG.dotfull>>
<<MODULE.dotfull>>
<<MONAD.dotfull>>
<<MONADWU.dotfull>>
<<MDAGG.dotfull>>
<<MONOID.dotfull>>
<<MONOGEN.dotfull>>
<<MSETAGG.dotfull>>
<<NAALG.dotfull>>
<<NARNG.dotfull>>
<<NASRING.dotfull>>
<<OAGROUP.dotfull>>
<<OAMON.dotfull>>
<<OAMONS.dotabb>>
<<OASGP.dotfull>>
<<OCAMON.dotfull>>
<<OINTDOM.dotfull>>
<<OMSAGG.dotfull>>
<<ORDFIN.dotfull>>
<<ORDMON.dotfull>>
<<ORDRING.dotfull>>
<<ORDSET.dotfull>>
<<PDRING.dotfull>>
<<PFECAT.dotfull>>
<<PID.dotfull>>
<<PRIMCAT.dotfull>>
<<PRQAGG.dotfull>>
<<QUAGG.dotfull>>
<<RCAGG.dotfull>>
<<RETRACT.dotfull>>
<<RING.dotfull>>
<<RMODULE.dotfull>>
<<RNG.dotfull>>
<<SETAGG.dotfull>>
<<SETCAT.dotfull>>
<<SGROUP.dotfull>>
<<SKAGG.dotfull>>
<<SPFCAT.dotfull>>
<<SRAGG.dotfull>>
<<STAGG.dotfull>>
<<STEP.dotfull>>
<<TRANFUN.dotfull>>
<<TRIGCAT.dotfull>>
<<TYPE.dotfull>>
<<TBAGG.dotfull>>
<<UFD.dotfull>>
<<URAGG.dotfull>>
<<VSPACE.dotfull>>
}
@
\eject
\begin{thebibliography}{99}
\bibitem{1} N. Jacobson: Structure and Representations of Jordan Algebras
AMS, Providence, 1968
\bibitem{2} MacLane and Birkhoff, Algebra 2d Edition, MacMillan 1979
\bibitem{3} Encyclopedic Dictionary of Mathematics, MIT Press, 1977
\bibitem{4} R.D. Schafer: An Introduction to Nonassociative Algebras
Academic Press, New York, 1966
\bibitem{5} R. Wisbauer: Bimodule Structure of Algebra
Lecture Notes Univ. Duesseldorf 1991
\end{thebibliography}
\printindex
\end{document}
