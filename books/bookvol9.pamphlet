\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% defun marks a function definition and adds it to the index
%%
\newcommand{\defun}[2]{% e.g. \defun{functionname}
\subsection{defun #2}%
\label{#1}%
\index{#1}%
\index{defun!#1}%
\index{#1!defun}}

%%
%% defunsec marks a function definition and adds it to the index
%% It assumes that the second argument is a section title.
%%
\newcommand{\defunsec}[2]{% e.g. \defunsec{functionname}{section title}
\subsection{#2}%
\label{#1}%
\index{#1}%
\index{defun!#1}%
\index{#1!defun}}

%%
%% defmacro marks a macro definition and adds it to the index
%%
\newcommand{\defmacro}[1]{% e.g. \defmacro{functionname}
\subsection{defmacro {#1}}%
\label{#1}%
\index{#1}%
\index{defmacro!#1}%
\index{#1!defmacro}}

%%
%% defvar marks a var definition and adds it to the index
%%
\newcommand{\defvar}[1]{% e.g. \defvar{varname}
\subsection{defvar \${#1}}%
\label{#1}%
\index{#1}%
\index{defvar!#1}%
\index{#1!defvar}}


%%
%% defdollar marks a var definition (with leading $) and adds it to the index
%%
\newcommand{\defdollar}[1]{% e.g. \defdollar{functionname}
\subsection{defvar \${#1}}%
\label{#1}%
\index{\${#1}}%
\index{defvar!\${#1}}%
\index{\${#1}!defvar}}

\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 9: Axiom Compiler}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\setcounter{chapter}{0} % Chapter 1
\section{Makefile}
This book is actually a literate program\cite{2} and can contain 
executable source code. In particular, the Makefile for this book
is part of the source of the book and is included below. Axiom 
uses the ``noweb'' literate programming system by Norman Ramsey\cite{6}.
\chapter{Compiler top level}
\section{)compile}
This is the implementation of the )compile command.

You use this command to invoke the new Axiom library compiler or the
old Axiom system compiler.  The {\tt )compile} system command is
actually a combination of Axiom processing and a call to the Aldor
compiler.  It is performing double-duty, acting as a front-end to both
the Aldor compiler and the old Axiom system compiler.  (The old Axiom
system compiler was written in Lisp and was an integral part of the
Axiom environment.  The Aldor compiler is written in C and executed by
the operating system when called from within Axiom.)

\par\noindent{\bf User Level Required:} compiler

\par\noindent{\bf Command Syntax:}

\begin{list}{}
\item {\tt )compile}
\item {\tt )compile {\it fileName}}
\item {\tt )compile {\it fileName}.spad}
\item {\tt )compile {\it directory/fileName}.spad}
\item {\tt )compile {\it fileName} )old}
\item {\tt )compile {\it fileName} )translate}
\item {\tt )compile {\it fileName} )quiet}
\item {\tt )compile {\it fileName} )noquiet}
\item {\tt )compile {\it fileName} )moreargs}
\item {\tt )compile {\it fileName} )onlyargs}
\item {\tt )compile {\it fileName} )break}
\item {\tt )compile {\it fileName} )nobreak}
\item {\tt )compile {\it fileName} )library}
\item {\tt )compile {\it fileName} )nolibrary}
\item {\tt )compile {\it fileName} )vartrace}
\item {\tt )compile {\it fileName} )constructor} {\it nameOrAbbrev}
\end{list}

These command forms invoke the Aldor compiler.
\begin{list}{}
\item {\tt )compile {\it fileName}.as}
\item {\tt )compile {\it directory/fileName}.as}
\item {\tt )compile {\it fileName}.ao}
\item {\tt )compile {\it directory/fileName}.ao}
\item {\tt )compile {\it fileName}.al}
\item {\tt )compile {\it directory/fileName}.al}
\item {\tt )compile {\it fileName}.lsp}
\item {\tt )compile {\it directory/fileName}.lsp}
\item {\tt )compile {\it fileName} )new}
\end{list}

\par\noindent{\bf Command Description:}

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.spad
)compile /u/jones/mycode.spad
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/mycode.spad} if the current Axiom working
directory is {\tt /u/jones.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

If you omit the file extension, the command looks to see if you have
specified the {\tt )new} or {\tt )old} option.  If you have given one
of these options, the corresponding compiler is used.

The command first looks in the standard system directories for files
with extension {\it .as, .ao} and {\it .al} and then files with
extension {\it .spad}.  The first file found has the appropriate
compiler invoked on it.  If the command cannot find a matching file,
an error message is displayed and the command terminates.

The first thing {\tt )compile} does is look for a source code
filename among its arguments.
Thus
\begin{verbatim}
)compile mycode.as
)compile /u/jones/as/mycode.as
)compile mycode
\end{verbatim}
all invoke {\tt )compiler} on the file {\tt
/u/jones/as/mycode.as} if the current Axiom working
directory is {\tt /u/jones/as.} (Recall that you can set the
working directory via the {\tt )cd} command. If you don't set it
explicitly, it is the directory from which you started
Axiom.)

This is frequently all you need to compile your file.

This simple command:
\begin{enumerate}
\item Invokes the chosen compiler and produces Lisp output.
\item Calls the Lisp compiler if the compilation was
successful.
\item Uses the {\tt )library} command to tell Axiom about
the contents of your compiled file and arrange to have those
contents loaded on demand.
\end{enumerate}

Should you not want the {\tt )library} command automatically
invoked, call {\tt )compile} with the {\tt )nolibrary} option.
For example,
\begin{verbatim}
)compile mycode )nolibrary
\end{verbatim}

By default, the {\tt )library} system command {\it exposes} all
domains and categories it processes.
This means that the Axiom intepreter will consider those
domains and categories when it is trying to resolve a reference
to a function.
Sometimes domains and categories should not be exposed.
For example, a domain may just be used privately by another
domain and may not be meant for top-level use.
The {\tt )library} command should still be used, though, so that
the code will be loaded on demand.
In this case, you should use the {\tt )nolibrary} option on {\tt
)compile} and the {\tt )noexpose} option in the {\tt )library}
command. For example,
\begin{verbatim}
)compile mycode )nolibrary
)library mycode )noexpose
\end{verbatim}

Once you have established your own collection of compiled code,
you may find it handy to use the {\tt )dir} option on the
{\tt )library} command.
This causes {\tt )library} to process all compiled code in the
specified directory. For example,
\begin{verbatim}
)library )dir /u/jones/quantum
\end{verbatim}
You must give an explicit directory after {\tt )dir}, even if you
want all compiled code in the current working directory
processed, e.g.
\begin{verbatim}
)library )dir .
\end{verbatim}

\subsection{Spad compiler}
This command compiles files with file extension {\tt .spad}
with the old Axiom system compiler.  

The {\tt )translate} option is used to invoke a special version of the
old system compiler that will translate a {\it .spad} file to a {\it
.as} file.  That is, the {\it .spad} file will be parsed and analyzed
and a file using the new syntax will be created.

By default, the {\it .as} file is created in the same directory as the
{\it .spad} file. If that directory is not writable, the current
directory is used. If the current directory is not writable, an error
message is given and the command terminates.  Note that {\tt )translate} 
implies the {\tt )old} option so the file extension can
safely be omitted. If {\tt )translate} is given, all other options are
ignored.  Please be aware that the translation is not necessarily one
hundred percent complete or correct.  You should attempt to compile
the output with the Aldor compiler and make any necessary corrections.

You can compile category, domain, and package constructors contained
in files with file extension {\it .spad}.  You can compile individual
constructors or every constructor in a file.

The full filename is remembered between invocations of this command and
{\tt )edit} commands. The sequence of commands
\begin{verbatim}
)compile matrix.spad
)edit
)compile
\end{verbatim}
will call the compiler, edit, and then call the compiler again on the
file {\bf matrix.spad.}  If you do not specify a {\it directory,} the
working current directory is searched for the file.  If the file is
not found, the standard system directories are searched.

If you do not give any options, all constructors within a file are
compiled.  Each constructor should have an {\tt )abbreviation} command
in the file in which it is defined.  We suggest that you place the
{\tt )abbreviation} commands at the top of the file in the order in
which the constructors are defined.

The {\tt )library} option causes directories containing the compiled
code for each constructor to be created in the working current
directory.  The name of such a directory consists of the constructor
abbreviation and the {\bf .nrlib} file extension.  For example, the
directory containing the compiled code for the {\tt MATRIX}
constructor is called {\bf MATRIX.nrlib.}  The {\tt )nolibrary} option
says that such files should not be created.  The default is 
{\tt )library.}  Note that the semantics of {\tt )library} and 
{\tt )nolibrary} for the new Aldor compiler and for the old system 
compiler are completely different.

The {\tt )vartrace} option causes the compiler to generate
extra code for the constructor to support conditional tracing of
variable assignments. (see 
\ref{ugSysCmdtrace} on page~\pageref{ugSysCmdtrace}). Without
this option, this code is suppressed and one cannot use
the {\tt )vars} option for the trace command.

The {\tt )constructor} option is used to
specify a particular constructor to compile.
All other constructors in the file are ignored.
The constructor name or abbreviation follows {\tt )constructor.}
Thus either
\begin{verbatim}
)compile matrix.spad )constructor RectangularMatrix
\end{verbatim}
or
\begin{verbatim}
)compile matrix.spad )constructor RMATRIX
\end{verbatim}
compiles  the {\tt RectangularMatrix} constructor
defined in {\bf matrix.spad.}

The {\tt )break} and {\tt )nobreak} options determine what
the spad compiler does when it encounters an error.
{\tt )break} is the default and it indicates that processing
should stop at the first error.
The value of the {\tt )set break} variable then controls what happens.

\subsection{Aldor compiler}
This command compiles files with file extensions {\it .as, .ao} and
{\it .al} with the Aldor compiler. It also can compile files
with file extension {\it .lsp}. These are assumed to be Lisp files
genererated by the Aldor compiler.  

The general description of Aldor command line arguments is in
the Aldor documentation.
The default options used by the {\tt )compile} command can be
viewed and set using the {\tt )set compiler args} Axiom
system command.
The current defaults are
\begin{verbatim}
-O -Fasy -Fao -Flsp -laxiom -Mno-AXL_W_WillObsolete -DAxiom
\end{verbatim}
These options mean:
\begin{itemize}
\item {\tt -O}: perform all optimizations,
\item {\tt -Fasy}: generate a {\tt .asy} file,
\item {\tt -Fao}: generate a {\tt .ao} file,
\item {\tt -Flsp}: generate a {\tt .lsp} (Lisp) file,
\item {\tt -laxiom}: use the {\tt axiom} library {\tt libaxiom.al},
\item {\tt -Mno-AXL\_W\_WillObsolete}: do not display messages
about older generated files becoming obsolete, and
\item {\tt -DAxiom}: define the global assertion {\tt Axiom} so that the
Aldor libraries for generating stand-alone code
are not accidentally used with Axiom.
\end{itemize}

To supplement these default arguments, use the {\tt )moreargs} option on
{\tt )compile.}
For example,
\begin{verbatim}
)compile mycode.as )moreargs "-v"
\end{verbatim}
uses the default arguments and appends the {\tt -v} (verbose)
argument flag.
The additional argument specification {\bf must be enclosed in
double quotes.}

To completely replace these default arguments for a particular
use of {\tt )compile}, use the {\tt )onlyargs} option.
For example,
\begin{verbatim}
)compile mycode.as )onlyargs "-v -O"
\end{verbatim}
only uses the {\tt -v} (verbose) and {\tt -O} (optimize)
arguments.
The argument specification {\bf must be enclosed in double quotes.}
In this example, Lisp code is not produced and so the compilation
output will not be available to Axiom.

To completely replace the default arguments for all calls to {\tt
)compile} within your Axiom session, use {\tt )set compiler args.}
For example, to use the above arguments for all compilations, issue
\begin{verbatim}
)set compiler args "-v -O"
\end{verbatim}
Make sure you include the necessary {\tt -l} and {\tt -Y}
arguments along with those needed for Lisp file creation.
As above, {\bf the argument specification must be enclosed in double
quotes.}

The {\tt )compile} command works with several file extensions. We saw
above what happens when it is invoked on a file with extension {\tt
.as.} A {\tt .ao} file is a portable binary compiled version of a
{\tt .as} file, and {\tt )compile} simply passes the {\tt .ao} file
onto Aldor. The generated Lisp file is compiled and {\tt )library}
is automatically called, just as if you had specified a {\tt .as} file.

A {\tt .al} file is an archive file containing {\tt .ao} files. The
archive is created (on Unix systems) with the {\tt ar} program. When
{\tt )compile} is given a {\tt .al} file, it creates a directory whose
name is based on that of the archive. For example, if you issue
\begin{verbatim}
)compile mylib.al
\end{verbatim}
the directory {\tt mylib.axldir} is created. All members of the
archive are unarchived into the directory and {\tt )compile} is called
on each {\tt .ao} file found. It is your responsibility to remove the
directory and its contents, if you choose to do so.

A {\tt .lsp} file is a Lisp source file, generated by Aldor
when called with the {\tt -Flsp} option. When {\tt )compile} is used
with a {\tt .lsp} file, the Lisp file is compiled and {\tt )library}
is called. For Aldor, You must also have present a {\tt .asy}
generated from the same source file.

\defunsec{compiler}{The top level compiler command}
<<defun compiler>>=
(defun |compiler| (args)
 "The top level compiler command"
 (let (|$newConlist| optlist optname optargs havenew haveold aft ef af af1)
  (declare (special |$newConlist| |$options| /editfile))
  (setq |$newConlist| nil)
  (cond
   ((and (null args) (null |$options|) (null /editfile))
     (|helpSpad2Cmd| '(|compiler|)))
   (t
    (cond ((null args) (setq args (cons /editfile nil))))
    (setq optlist '(|new| |old| |translate| |constructor|))
    (setq havenew nil)
    (setq haveold nil)
    (do ((t0 |$options| (cdr t0)) (opt nil))
        ((or (atom t0) 
             (progn (setq opt (car t0)) nil)
             (null (null (and havenew haveold))))
          nil)
     (setq optname (car opt))
     (setq optargs (cdr opt))
     (case (|selectOptionLC| optname optlist nil)
      (|new|         (setq havenew t))
      (|translate|   (setq haveold t))
      (|constructor| (setq haveold t))
      (|old|         (setq haveold t))))
    (cond
     ((and havenew haveold) (|throwKeyedMsg| 's2iz0081 nil))
     (t
      (setq af (|pathname| args))
      (setq aft (|pathnameType| af))
      (cond
       ((or havenew (string= aft "as"))
        (if (null (setq af1 ($findfile af '(|as|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpCmd| (cons af1 nil))))
       ((or haveold (string= aft "spad"))
        (if (null (setq af1 ($findfile af '(|spad|))))
           (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
           (|compileSpad2Cmd| (cons af1 nil))))
       ((string= aft "lsp")
        (if (null (setq af1 ($findfile af '(|lsp|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpLispCmd| (cons af1 nil))))
       ((string= aft "nrlib")
        (if (null (setq af1 ($findfile af '(|nrlib|))))
          (|throwKeyedMsg| 'S2IL0003 (cons (namestring af) nil))
          (|compileSpadLispCmd| (cons af1 nil))))
       ((string= aft "ao")
        (if (null (setq af1 ($findfile af '(|ao|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
         (|compileAsharpCmd| (cons af1 nil))))
       ((string= aft "al")
        (if (null (setq af1 ($findfile af '(|al|))))
          (|throwKeyedMsg| 's2il0003 (cons (namestring af) nil))
          (|compileAsharpArchiveCmd| (cons af1 nil))))
       (t
        (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
        (cond
         ((and af1 (string= (|pathnameType| af1) "as"))
          (|compileAsharpCmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "ao"))
          (|compileAsharpCmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "spad"))
          (|compileSpad2Cmd| (cons af1 nil)))
         ((and af1 (string= (|pathnameType| af1) "asy"))
          (|compileAsharpArchiveCmd| (cons af1 nil)))
         (t
          (setq ef (|pathname| /editfile))
          (setq ef (|mergePathnames| af ef))
          (cond
           ((boot-equal ef af) (|throwKeyedMsg| 's2iz0039 nil))
           (t
            (setq af ef)
            (cond
             ((string= (|pathnameType| af) "as")
              (|compileAsharpCmd| args))
             ((string= (|pathnameType| af) "ao")
              (|compileAsharpCmd| args))
             ((string= (|pathnameType| af) "spad")
              (|compileSpad2Cmd| args))
             (t
              (setq af1 ($findfile af '(|as| |spad| |ao| |asy|)))
              (cond
               ((and af1 (string= (|pathnameType| af1) "as"))
                 (|compileAsharpCmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "ao"))
                 (|compileAsharpCmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "spad"))
                 (|compileSpad2Cmd| (cons af1 nil)))
               ((and af1 (string= (|pathnameType| af1) "asy"))
                (|compileAsharpArchiveCmd| (cons af1 nil)))
               (t (|throwKeyedMsg| 's2iz0039 nil)))))))))))))))))

@
\defunsec{compileSpad2Cmd}{The Spad compiler top level function}
This is the old compiler.
Assume we entered from the "compiler" function, so args is 
a file with file extension .spad.

The \verb|$f| and \verb|$m| are compiler variables, probably function
and mode.
<<defun compileSpad2Cmd>>=
(defun |compileSpad2Cmd| (args)
 (let (|$newcompMode| |$ncConverse| |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| path optlist fun optname 
       optargs fullopt translateoldtonew constructor)
  (declare (special |$newcompMode| |$ncConverse| |$newComp| |$scanIfTrue| 
       |$compileOnlyCertainItems| |$f| |$m| |$QuickLet| |$QuickCode| 
       |$sourceFileTypes| |$InteractiveMode| /editfile |$options|
       |$newConlist|)) 
   (setq path (|pathname| args))
   (cond
    ((nequal (|pathnameType| path) "spad") (|throwKeyedMsg| 's2iz0082 nil))
    ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
    (t
     (setq /editfile path)
     (|updateSourceFiles| path)
     (|sayKeyedMsg| 's2iz0038 (list (|namestring| args)))
     (setq optlist '(|break| |constructor| |functions| |library| |lisp|
         |new| |old| |nobreak| |nolibrary| |noquiet| |vartrace| |quiet|
         |translate|))
     (setq |$QuickLet| t)
     (setq |$QuickCode| t)
     (setq fun '(|rq| |lib|))
     (setq |$sourceFileTypes| '("SPAD"))
     (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (setq fullopt (|selectOptionLC| optname optlist nil))
      (case fullopt
       (|new| (|error| '|Internal error: compileSpad2Cmd got )new|))
       (|old| nil)
       (|translate| (setq translateoldtonew t))
       (|library| (setelt fun 1 '|lib|))
       (|nolibrary| (setelt fun 1 '|nolib|))
       (|quiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rq|)))
       (|noquiet| (when (nequal (elt fun 0) '|c|) (setelt fun 0 '|rf|)))
       (|nobreak| (setq |$scanIfTrue| t))
       (|break| (setq |$scanIfTrue| nil))
       (|vartrace| (setq |$QuickLet| nil))
       (|lisp| (|throwKeyedMsg| 's2iz0036 (list ")lisp")))
       (|functions|
        (if (null optargs) 
         (|throwKeyedMsg| 's2iz0037 (list ")functions"))
         (setq |$compileOnlyCertainItems| optargs)))
       (|constructor|
        (if (null optargs)
         (|throwKeyedMsg| 's2iz0037 (list ")constructor"))
         (progn
          (setelt fun 0 '|c|)
          (setq constructor (mapcar #'|unabbrev| optargs)))))
       (t
        (|throwKeyedMsg| 's2iz0036 
         (list (strconc ")" (|object2String| optname)))))))
    (setq |$InteractiveMode| nil)
    (cond
     (translateoldtonew
      (|oldParserAutoloadOnceTrigger|)
      (|browserAutoloadOnceTrigger|)
      (|spad2AsTranslatorAutoloadOnceTrigger|)
      (|sayKeyedMsg| 's2iz0085 nil)
      (|convertSpadToAsFile| path))
     (|$compileOnlyCertainItems|
      (if (null constructor)
       (|sayKeyedMsg| 's2iz0040 nil)
       (|compilerDoitWithScreenedLisplib| constructor fun)))
     (t (|compilerDoit| constructor fun)))
    (|extendLocalLibdb| |$newConlist|)
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@
\defun{compileSpadLispCmd}{compileSpadLispCmd}
<<defun compileSpadLispCmd>>=
(defun |compileSpadLispCmd| (args)
 (let (path optlist optname optargs beQuiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| (|fnameMake| (car args) "code" "lsp")))
  (cond
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq beQuiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
         (|quiet|     (setq beQuiet t))
         (|noquiet|   (setq beQuiet nil))
         (|library|   (setq dolibrary t))
         (|nolibrary| (setq dolibrary nil))
         (t
          (|throwKeyedMsg| 's2iz0036
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless beQuiet (|sayKeyedMsg| 's2iz0089 (list (|namestring| lsp))))
       (recompile-lib-file-if-necessary lsp))
     (t
      (|sayKeyedMsg| 's2il0003 (list (|namestring| lsp)))))
    (cond
     (dolibrary
      (unless beQuiet (|sayKeyedMsg| 's2iz0090 (list (|pathnameName| path))))
      (localdatabase (list (|pathnameName| (car args))) nil))
     ((null beQuiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{compileAsharpCmd}{compileAsharpCmd}
<<defun compileAsharpCmd>>=
(defun |compileAsharpCmd| (args)
  (|compileAsharpCmd1| args)
  (|terminateSystemCommand|)
  (|spadPrompt|))

@

\defun{compileAsharpCmd1}{compileAsharpCmd1}
<<defun compileAsharpCmd1>>=
(defun |compileAsharpCmd1| (args)
 (let (path pathtype optlist optname optargs bequiet docompilelisp 
        moreargs onlyargs dolibrary p tempargs s asharpargs command rc lsp)
   (declare (special |$options| |$asharpCmdlineFlags| |$newConlist|
             /editfile))
   (setq path (|pathname| args))
   (setq pathtype (|pathnameType| path))
   (cond
   ((and (nequal pathtype "as") (nequal pathtype "ao"))
     (|throwKeyedMsg| 's2iz0083 nil))
   ((null (probe-file path))
     (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil)))
   (t
    (setq /editfile path)
    (|updateSourceFiles| path)
    (setq optlist
     '(|new| |old| |translate| |onlyargs| |moreargs| |quiet| 
       |nolispcompile| |noquiet| |library| |nolibrary|))
    (setq bequiet nil)
    (setq dolibrary t)
    (setq docompilelisp t)
    (setq moreargs nil)
    (setq onlyargs nil)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
       (|new| nil)
       (|old| (|error| '|Internal error: compileAsharpCmd got )old|))
       (|translate|
        (|error| '|Internal error: compileAsharpCmd got )translate|))
       (|quiet|         (setq bequiet t))
       (|noquiet|       (setq bequiet nil))
       (|nolispcompile| (setq docompilelisp nil))
       (|moreargs|      (setq moreargs optargs))
       (|onlyargs|      (setq onlyargs optargs))
       (|library|       (setq dolibrary t))
       (|nolibrary|     (setq dolibrary nil))
       (t 
        (|throwKeyedMsg| 's2iz0036
         (cons (strconc ")" (|object2String| optname)) nil)))))
    (setq tempargs
     (if (string= pathtype "ao")
       (if (setq p (strpos "-Fao" |$asharpCmdlineFlags| 0 nil))
         (if (eql p 0) 
          (substring |$asharpCmdlineFlags| 5 nil)
          (strconc (substring |$asharpCmdlineFlags| 0 p) 
             " " (substring |$asharpCmdlineFlags| (plus p 5) nil)))
         |$asharpCmdlineFlags|)
       |$asharpCmdlineFlags|))
    (setq asharpargs
     (cond
      (onlyargs
       (setq s '||)
       (do ((t1 onlyargs (cdr t1)) (|a| nil))
           ((or (atom t1) (progn (setq |a| (car t1)) nil)) nil)
          (setq s (strconc s " " (|object2String| |a|))))
       s)
      (moreargs
       (setq s tempargs)
       (do ((t2 moreargs (cdr t2)) (|a| nil))
           ((or (atom t2) (progn (setq |a| (car t2)) nil)) nil)
          (setq s (strconc s " " (|object2String| |a|))))
       s)
      (t tempargs)))
    (unless bequiet
     (|sayKeyedMsg| 's2iz0038a  (list (|namestring| args) asharpargs )))
    (setq command
     (strconc
      (strconc (getenv "ALDORROOT") "/bin/")
      '|aldor | asharpargs " " (|namestring| args)))
    (setq rc (obey command))
    (cond
     ((and (eql rc 0) docompilelisp)
       (setq lsp (|fnameMake| "." (|pathnameName| args) "lsp"))
       (cond
        ((|fnameReadable?| lsp)
         (unless  bequiet
           (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
         (|compileFileQuietly| lsp))
        (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))))
    (cond
     ((and (eql rc 0) dolibrary)
      (unless bequiet
         (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|extendLocalLibdb| |$newConlist|)))))

@

\defun{compileAsharpArchiveCmd}{compileAsharpArchiveCmd}
<<defun compileAsharpArchiveCmd>>=
(defun |compileAsharpArchiveCmd| (args)
 (let (path dir exists isdir curdir cmd rc asos)
  (declare (special $current-directory))
  (setq path (|pathname| args))
  (if (null (probe-file path))
   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
   (progn
    (setq dir (|fnameMake| "." (|pathnameName| path) "axldir"))
    (setq exists (probe-file dir))
    (setq isdir (|directoryp| (|namestring| dir)))
    (if (and exists (nequal isdir 1))
     (|throwKeyedMsg| 's2il0027 (list (|namestring| dir) (|namestring| args)))
     (progn
      (when (nequal isdir 1)
        (setq cmd (strconc "mkdir " (|namestring| dir)))
        (setq rc (obey cmd))
        (when (nequal rc 0)
          (|throwKeyedMsg| 's2il0027 
           (list (|namestring| dir) (|namestring| args)))))
      (setq curdir $current-directory)
      (|cd| (cons (|object2Identifier| (|namestring| dir)) nil))
      (setq cmd (strconc "ar x " (|namestring| path)))
      (setq rc (obey cmd))
      (cond
       ((nequal rc 0)
        (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
        (|throwKeyedMsg| 's2il0028
         (cons (|namestring| dir) (cons (|namestring| args) nil))))
       (t
        (setq asos (directory "*.ao"))
        (if (null asos)
         (progn
          (|cd| (cons (|object2Identifier| (|namestring| curdir)) nil))
          (|throwKeyedMsg| 's2il0029
           (cons (|namestring| dir) (cons (|namestring| args) nil))))
         (progn
          (dolist (aso asos)
             (|compileAsharpCmd1| (list (|namestring| aso))))
          (|cd| (list (|object2Identifier| (|namestring| curdir))))
          (|terminateSystemCommand|)
          (|spadPrompt|)))))))))))

@

\defun{compileAsharpLispCmd}{compileAsharpLispCmd}
<<defun compileAsharpLispCmd>>=
(defun |compileAsharpLispCmd| (args)
 (let (path optlist optname optargs bequiet dolibrary lsp)
  (declare (special |$options|))
  (setq path (|pathname| args))
  (if (null (probe-file path)) 
   (|throwKeyedMsg| 's2il0003 (cons (|namestring| args) nil))
   (progn
    (setq optlist '(|quiet| |noquiet| |library| |nolibrary|))
    (setq bequiet nil)
    (setq dolibrary t)
    (dolist (opt |$options|)
      (setq optname (car opt))
      (setq optargs (cdr opt))
      (case (|selectOptionLC| optname optlist nil)
        (|quiet|     (setq bequiet t))
        (|noquiet|   (setq bequiet nil))
        (|library|   (setq dolibrary t))
        (|nolibrary| (setq dolibrary nil))
        (t
          (|throwKeyedMsg| 's2iz0036 
           (list (strconc ")" (|object2String| optname)))))))
    (setq lsp
     (|fnameMake|
      (|pathnameDirectory| path)
      (|pathnameName| path)
      (|pathnameType| path)))
    (cond
     ((|fnameReadable?| lsp)
      (unless bequiet
         (|sayKeyedMsg| 's2iz0089 (cons (|namestring| lsp) nil)))
      (|compileFileQuietly| lsp))
     (t (|sayKeyedMsg| 's2il0003 (cons (|namestring| lsp) nil))))
    (cond
     (dolibrary
      (unless  bequiet
        (|sayKeyedMsg| 's2iz0090 (cons (|pathnameName| path) nil)))
      (|withAsharpCmd| (cons (|pathnameName| path) nil)))
     ((null bequiet) (|sayKeyedMsg| 's2iz0084 nil))
     (t nil))
    (|terminateSystemCommand|)
    (|spadPrompt|)))))

@

\defun{withAsharpCmd}{withAsharpCmd}
<<defun withAsharpCmd>>=
(defun |withAsharpCmd| (args)
 (let (|$options|)
  (declare (special |$options|))
  (localdatabase args |$options|)))

@

\defun{compileFileQuietly}{compileFileQuietly}
if \verb|$InteractiveMode| then use a null outputstream 
<<defun compileFileQuietly>>=
(defun |compileFileQuietly| (fn) 
  (let (
	(*standard-output*
	 (if |$InteractiveMode| (make-broadcast-stream)
	   *standard-output*)))
  (declare (special *standard-output* |$InteractiveMode|))
  (compile-file fn)))

@
\defdollar{byConstructors}
<<initvars>>=
(defvar |$byConstructors| () "list of constructors to be compiled")

@
\defdollar{constructorsSeen}
<<initvars>>=
(defvar |$constructorsSeen| () "list of constructors found")

@
\defun{compilerDoit}{compilerDoit}
<<defun compilerDoit>>=
(defun |compilerDoit| (constructor fun)
 (let (|$byConstructors| |$constructorsSeen|)
 (declare (special |$byConstructors| |$constructorsSeen|))
  (setq |$byConstructors| nil)
  (setq |$constructorsSeen| nil)
  (cond
   ((equal fun '(|rf| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rf| |nolib|)) (/rf))
   ((equal fun '(|rq| |lib|))   (|/RQ,LIB|))
   ((equal fun '(|rq| |nolib|)) (/rq))
   ((equal fun '(|c| |lib|))
    (setq |$byConstructors| (mapcar #'|opOf| constructor))
    (|/RQ,LIB|)
    (dolist (con |$byConstructors|)
     (unless (|member| con |$constructorsSeen|)
      (|sayBrightly| `(">>> Warning " |%b| ,con |%d| " was not found"))))))))

@

\chapter{Dangling references}
\section{shell variables}
\begin{verbatim}
ALDORROOT
\end{verbatim}

\section{catch tags}
\begin{verbatim}
\end{verbatim}

\section{throw tags}
\begin{verbatim}
\end{verbatim}

\section{defined special variables}
\begin{verbatim}
\end{verbatim}

\section{undefined special variables}
\begin{verbatim}
|$asharpCmdlineFlags| 
|$compileOnlyCertainItems| 
$current-directory
/editfile 
|$f| 
|$InteractiveMode| 
|$m| 
|$ncConverse| 
|$newComp| 
|$newcompMode| 
|$newConlist|
|$options|
|$QuickCode| 
|$QuickLet| 
|$scanIfTrue| 
|$sourceFileTypes| 
*standard-output* 
$syscommands
|$systemCommands|
\end{verbatim}

\section{undefined functions}
\begin{verbatim}
|browserAutoloadOnceTrigger|
|compilerDoit|
|compilerDoitWithScreenedLisplib|
|convertSpadToAsFile|
directory
|directoryp|
|error|
|extendLocalLibdb|
|fnameMake|
|fnameReadable?|
getenv
|member|
|namestring|
nequal
obey
|object2Identifier|
|object2String|
|oldParserAutoloadOnceTrigger|
|pathname|
|pathnameDirectory|
|pathnameName|
|pathnameType|
recompile-lib-file-if-necessary
|sayBrightly|
|sayKeyedMsg|
|spadPrompt|
|spad2AsTranslatorAutoloadOnceTrigger|
strconc
strpos
|throwKeyedMsg|
|terminateSystemCommand|
|updateSourceFiles|
\end{verbatim}

\chapter{The Compiler}
<<Compiler>>=
(in-package "BOOT")

<<initvars>>

<<defun compileAsharpArchiveCmd>>
<<defun compileAsharpCmd>>
<<defun compileAsharpCmd1>>
<<defun compileAsharpLispCmd>>
<<defun compileFileQuietly>>
<<defun compilerDoit>>
<<defun compileSpad2Cmd>>
<<defun compileSpadLispCmd>>

<<defun withAsharpCmd>>
@
\eject
\begin{thebibliography}{99}
\bibitem{1} Jenks, R.J. and Sutor, R.S. 
``Axiom -- The Scientific Computation System''
Springer-Verlag New York (1992)
ISBN 0-387-97855-0
\bibitem{2} Knuth, Donald E., ``Literate Programming''
Center for the Study of Language and Information
ISBN 0-937073-81-4
Stanford CA (1992) 
\bibitem{3} Daly, Timothy, ``The Axiom Wiki Website''\\
{\bf http://axiom.axiom-developer.org}
\bibitem{4} Watt, Stephen, ``Aldor'',\\
{\bf http://www.aldor.org}
\bibitem{5} Lamport, Leslie, ``Latex -- A Document Preparation System'',
Addison-Wesley, New York ISBN 0-201-52983-1
\bibitem{6} Ramsey, Norman ``Noweb -- A Simple, Extensible Tool for
Literate Programming''\\
{\bf http://www.eecs.harvard.edu/ $\tilde{}$nr/noweb}
\bibitem{7} Daly, Timothy, "The Axiom Literate Documentation"\\
{\bf http://axiom.axiom-developer.org/axiom-website/documentation.html}
\end{thebibliography}
\chapter{Index}
\printindex
\end{document}
