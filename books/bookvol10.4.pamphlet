\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% pagehead consolidates standard page indexing
%%
\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
\section{#1}
\label{#1}%
\label{#2}%
\index{{#1}}%
\index{{#2}}}%
%%
%% pagepic adds an image and an index entry
%%
\newcommand{\pagepic}[2]{% e.g. \pagepic{pathandfile}{abb}
\includegraphics{#1}%
\index{images!#2}}
%%
%% pageto is a forward link to a referenced page
%%
\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% pageback is a backward link to a referencing page
%%
\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
% special meanings for math characters
\providecommand{\N}{\mbox{\bbold N}}
\providecommand{\Natural}{\mbox{\bbold N}}
\providecommand{\Z}{\mbox{\bbold Z}}
\providecommand{\Integer}{\mbox{\bbold Z}}
\providecommand{\Rational}{\mbox{\bbold Q}}
\providecommand{\Q}{\mbox{\bbold Q}}
\providecommand{\Complex}{\mbox{\bbold C}}
\providecommand{\C}{{\mathcal C}}
\providecommand{\Real}{\mbox{\bbold R}}
\providecommand{\F}{{\mathcal F}}
\providecommand{\R}{{\mathcal R}}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 10: Axiom Algebra: Packages}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\chapter{Chapter Overview}
This book contains the domains in Axiom, in alphabetical order.

Each domain has an associated 'dotpic' chunk which only lists the
domains, categories, and packages that are in the layer immediately
below in the build order. For the full list see the algebra Makefile
where this information is maintained.

Each domain is preceded by a picture. The picture indicates several 
things. The colors indicate whether the name refers to a category,
domain, or package. An ellipse means that the name refers to something
in the bootstrap set. Thus,

\includegraphics[scale=0.85]{ps/v103colorchart.ps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\pagehead{Domain}{ABB}
%\pagepic{ps/v103domain.ps}{ABB}{1.00}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter A}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AF AlgebraicFunction}
\pagehead{AlgebraicFunction}{AF}
\pagepic{ps/v104algebraicfunction.ps}{AF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AF AlgebraicFunction>>=
)abbrev package AF AlgebraicFunction
++ Author: Manuel Bronstein
++ Date Created: 21 March 1988
++ Date Last Updated: 11 November 1993
++ Description:
++   This package provides algebraic functions over an integral domain.
++ Keywords: algebraic, function.

AlgebraicFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  SE  ==> Symbol
  Z   ==> Integer
  Q   ==> Fraction Z
  OP  ==> BasicOperator
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  UPR ==> SparseUnivariatePolynomial R
  ALGOP       ==> "%alg"
  SPECIALDISP ==> "%specialDisp"
  SPECIALDIFF ==> "%specialDiff"

  Exports ==> with
    rootOf  : (UP, SE) -> F
      ++ rootOf(p, y) returns y such that \spad{p(y) = 0}.
      ++ The object returned displays as \spad{'y}.
    operator: OP -> OP
      ++ operator(op) returns a copy of \spad{op} with the domain-dependent
      ++ properties appropriate for \spad{F}.
      ++ Error: if op is not an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    belong? : OP -> Boolean
      ++ belong?(op) is true if \spad{op} is an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    inrootof: (UP, F) -> F
      ++ inrootof(p, x) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    droot : List F -> OutputForm
      ++ droot(l) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    if R has RetractableTo Integer then
      "**"   : (F, Q) -> F
        ++ x ** q is \spad{x} raised to the rational power \spad{q}.
      minPoly: K  -> UP
        ++ minPoly(k) returns the defining polynomial of \spad{k}.
      definingPolynomial: F -> F
        ++ definingPolynomial(f) returns the defining polynomial of \spad{f}
        ++ as an element of \spad{F}.
        ++ Error: if f is not a kernel.
      iroot : (R, Z) -> F
        ++ iroot(p, n) should be a non-exported function.
        -- un-export when the compiler accepts conditional local functions!

  Implementation ==> add
    ialg : List F -> F
    dvalg: (List F, SE) -> F
    dalg : List F -> OutputForm

    opalg  := operator("rootOf"::Symbol)$CommonOperators
    oproot := operator("nthRoot"::Symbol)$CommonOperators

    belong? op == has?(op, ALGOP)
    dalg l     == second(l)::OutputForm

    rootOf(p, x) ==
      k := kernel(x)$K
      (r := retractIfCan(p)@Union(F, "failed")) case "failed" =>
        inrootof(p, k::F)
      n := numer(f := univariate(r::F, k))
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(n, k::F)

    dvalg(l, x) ==
      p := numer univariate(first l, retract(second l)@K)
      alpha := kernel(opalg, l)
      - (map(differentiate(#1, x), p) alpha) / ((differentiate p) alpha)

    ialg l ==
      f := univariate(p := first l, retract(x := second l)@K)
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(numer f, x)

    operator op ==
      is?(op,  "rootOf"::Symbol) => opalg
      is?(op, "nthRoot"::Symbol) => oproot
      error "Unknown operator"

    if R has AlgebraicallyClosedField then
      UP2R: UP -> Union(UPR, "failed")

      inrootof(q, x) ==
        monomial? q => 0

        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d=> - leadingCoefficient(reductum q) / leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) / leadingCoefficient q
        ((rx := retractIfCan(x)@Union(SE, "failed")) case SE) and
          ((r := UP2R q) case UPR) => rootOf(r::UPR, rx::SE)::F
        kernel(opalg, [q x, x])

      UP2R p ==
        ans:UPR := 0
        while p ^= 0 repeat
          (r := retractIfCan(leadingCoefficient p)@Union(R, "failed"))
            case "failed" => return "failed"
          ans := ans + monomial(r::R, degree p)
          p   := reductum p
        ans

    else
      inrootof(q, x) ==
        monomial? q => 0
        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d => - leadingCoefficient(reductum q) /leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) /leadingCoefficient q
        kernel(opalg, [q x, x])

    evaluate(opalg, ialg)$BasicOperatorFunctions1(F)
    setProperty(opalg, SPECIALDIFF,
                              dvalg@((List F, SE) -> F) pretend None)
    setProperty(opalg, SPECIALDISP,
                              dalg@(List F -> OutputForm) pretend None)

    if R has RetractableTo Integer then
      import PolynomialRoots(IndexedExponents K, K, R, P, F)

      dumvar := "%%var"::Symbol::F

      lzero   : List F -> F
      dvroot  : List F -> F
      inroot  : List F -> F
      hackroot: (F, Z) -> F
      inroot0 : (F, Z, Boolean, Boolean) -> F

      lzero l == 0

      droot l ==
        x := first(l)::OutputForm
        (n := retract(second l)@Z) = 2 => root x
        root(x, n::OutputForm)

      dvroot l ==
        n := retract(second l)@Z
        (first(l) ** ((1 - n) / n)) / (n::F)

      x ** q ==
        qr := divide(numer q, denom q)
        x ** qr.quotient * inroot([x, (denom q)::F]) ** qr.remainder

      hackroot(x, n) ==
        (n = 1) or (x = 1) => x
        (((dx := denom x) ^= 1) and
           ((rx := retractIfCan(dx)@Union(Integer,"failed")) case Integer) and
           positive?(rx))
           => hackroot((numer x)::F, n)/hackroot(rx::Integer::F, n)
        (x = -1) and n = 4 =>
          ((-1::F) ** (1::Q / 2::Q) + 1) / ((2::F) ** (1::Q / 2::Q))
        kernel(oproot, [x, n::F])

      inroot l ==
        zero?(n := retract(second l)@Z) => error "root: exponent = 0"
--        one?(x := first l) or one? n => x
        ((x := first l) = 1) or (n = 1) => x
        (r := retractIfCan(x)@Union(R,"failed")) case R => iroot(r::R,n)
        (u := isExpt(x, oproot)) case Record(var:K, exponent:Z) =>
          pr := u::Record(var:K, exponent:Z)
          (first argument(pr.var)) **
              (pr.exponent /$Fraction(Z)
                   (n * retract(second argument(pr.var))@Z))
        inroot0(x, n, false, false)

-- removes powers of positive integers from numer and denom
-- num? or den? is true if numer or denom already processed
      inroot0(x, n, num?, den?) ==
        rn:Union(Z, "failed") := (num? => "failed"; retractIfCan numer x)
        rd:Union(Z, "failed") := (den? => "failed"; retractIfCan denom x)
        (rn case Z) and (rd case Z) =>
          rec := qroot(rn::Z / rd::Z, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)
        rn case Z =>
          rec := qroot(rn::Z::Fraction(Z), n::NonNegativeInteger)
          rec.coef * inroot0((rec.radicand**(n exquo rec.exponent)::Z)
                                / (denom(x)::F), n, true, den?)
        rd case Z =>
          rec := qroot(rd::Z::Fraction(Z), n::NonNegativeInteger)
          inroot0((numer(x)::F) /
                  (rec.radicand ** (n exquo rec.exponent)::Z),
                   n, num?, true) / rec.coef
        hackroot(x, n)

      if R has AlgebraicallyClosedField then iroot(r, n) == nthRoot(r, n)::F
      else
        iroot0: (R, Z) -> F

        if R has RadicalCategory then
          if R has imaginary:() -> R then iroot(r, n) == nthRoot(r, n)::F
          else
            iroot(r, n) ==
              odd? n or r >= 0 => nthRoot(r, n)::F
              iroot0(r, n)

        else iroot(r, n) == iroot0(r, n)

        iroot0(r, n) ==
          rec := rroot(r, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)

      definingPolynomial x ==
        (r := retractIfCan(x)@Union(K, "failed")) case K =>
          is?(k := r::K, opalg) => first argument k
          is?(k, oproot) =>
            dumvar ** retract(second argument k)@Z - first argument k
          dumvar - x
        dumvar - x

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        is?(k, oproot) =>
           monomial(1,retract(second argument k)@Z :: NonNegativeInteger)
             - first(argument k)::UP
        monomial(1, 1) - k::F::UP

      evaluate(oproot, inroot)$BasicOperatorFunctions1(F)
      derivative(oproot, [dvroot, lzero])

    else   -- R is not retractable to Integer
      droot l ==
        x := first(l)::OutputForm
        (n := second l) = 2::F => root x
        root(x, n::OutputForm)

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        monomial(1, 1) - k::F::UP

    setProperty(oproot, SPECIALDISP,
                              droot@(List F -> OutputForm) pretend None)

@
<<AF.dotabb>>=
"AF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AF"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGFACT AlgFactor}
\pagehead{AlgFactor}{ALGFACT}
\pagepic{ps/v104algfactor.ps}{ALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGFACT AlgFactor>>=
)abbrev package ALGFACT AlgFactor
++ Factorization of UP AN;
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in 
++ \spadtype{AlgebraicNumber}.
 
AlgFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory AlgebraicNumber
 
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Integer
  AN  ==> AlgebraicNumber
  K   ==> Kernel AN
  UPQ ==> SparseUnivariatePolynomial Q
  SUP ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
 
  Exports ==> with
    factor: (UP, List AN) -> FR
      ++ factor(p, [a1,...,an]) returns a prime factorisation of p
      ++ over the field generated by its coefficients and a1,...,an.
    factor: UP            -> FR
      ++ factor(p) returns a prime factorisation of p
      ++ over the field generated by its coefficients.
    split : UP            -> FR
      ++ split(p) returns a prime factorisation of p
      ++ over its splitting field.
    doublyTransitive?: UP -> Boolean
      ++ doublyTransitive?(p) is true if p is irreducible over
      ++ over the field K generated by its coefficients, and
      ++ if \spad{p(X) / (X - a)} is irreducible over 
      ++ \spad{K(a)} where \spad{p(a) = 0}.
 
  Implementation ==> add
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                           K, Z, SparseMultivariatePolynomial(Z, K), AN)

    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

    fact    : (UP,  List K) -> FR
    ifactor : (SUP, List K) -> Factored SUP
    extend  : (UP, Z) -> FR
    allk    : List AN -> List K
    downpoly: UP  -> UPQ
    liftpoly: UPQ -> UP
    irred?  : UP  -> Boolean
 
    allk l       == removeDuplicates concat [kernels x for x in l]
    liftpoly p   == map(#1::AN,  p)$UPCF2(Q, UPQ, AN, UP)
    downpoly p   == map(retract(#1)@Q, p)$UPCF2(AN, UP ,Q, UPQ)
    ifactor(p,l) == (fact(p pretend UP, l)) pretend Factored(SUP)
    factor p     == fact(p, allk coefficients p)
 
    factor(p, l) ==
      fact(p, allk removeDuplicates concat(l, coefficients p))
 
    split p ==
      fp := factor p
      unit(fp) *
            _*/[extend(fc.factor, fc.exponent) for fc in factors fp]
 
    extend(p, n) ==
--      one? degree p => primeFactor(p, n)
      (degree p = 1) => primeFactor(p, n)
      q := monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP
      primeFactor(q, n) * split((p exquo q)::UP) ** (n::N)
 
    doublyTransitive? p ==
      irred? p and irred?((p exquo
        (monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP))::UP)
 
    irred? p ==
      fp := factor p
--      one? numberOfFactors fp and one? nthExponent(fp, 1)
      (numberOfFactors fp = 1) and  (nthExponent(fp, 1) = 1)
 
    fact(p, l) ==
--      one? degree p => primeFactor(p, 1)
      (degree p = 1) => primeFactor(p, 1)
      empty? l =>
        dr := factor(downpoly p)$RationalFactorize(UPQ)
        (liftpoly unit dr) *
          _*/[primeFactor(liftpoly dc.factor,dc.exponent)
            for dc in factors dr]
      q   := minPoly(alpha := "max"/l)$AN
      newl  := remove(alpha = #1, l)
      sae := SimpleAlgebraicExtension(AN, SUP, q)
      ups := SparseUnivariatePolynomial sae
      fr  := factor(map(reduce univariate(#1, alpha, q),
                     p)$UPCF2(AN, UP, sae, ups),
                      ifactor(#1, newl))$InnerAlgFactor(AN, SUP, sae, ups)
      newalpha := alpha::AN
      map((lift(#1)$sae) newalpha, unit fr)$UPCF2(sae, ups, AN, UP) *
            _*/[primeFactor(map((lift(#1)$sae) newalpha,
                      fc.factor)$UPCF2(sae, ups, AN, UP),
                                 fc.exponent) for fc in factors fr]

@
<<ALGFACT.dotabb>>=
"ALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTPACK AnnaNumericalIntegrationPackage}
\pagehead{AnnaNumericalIntegrationPackage}{INTPACK}
\pagepic{ps/v104annanumericalintegrationpackage.ps}{INTPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTPACK AnnaNumericalIntegrationPackage>>=
)abbrev package INTPACK AnnaNumericalIntegrationPackage
++ Author: Brian Dupee
++ Date Created: August 1994
++ Date Last Updated: December 1997
++ Basic Operations: integrate, measure 
++ Related Constructors: Result, RoutinesTable
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \axiomType{AnnaNumericalIntegrationPackage} is a \axiom{package}
++ of functions for the \axiom{category} 
++ \axiomType{NumericalIntegrationCategory} 
++ with \axiom{measure}, and \axiom{integrate}.
EDF	==> Expression DoubleFloat
DF	==> DoubleFloat
EF	==> Expression Float
F	==> Float
INT	==> Integer
SOCDF	==> Segment OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
SBOCF	==> SegmentBinding OrderedCompletion Float
LSOCF	==> List Segment OrderedCompletion Float
SOCF	==> Segment OrderedCompletion Float
OCF	==> OrderedCompletion Float
LS	==> List Symbol
S	==> Symbol
LST	==> List String
ST	==> String
RT	==> RoutinesTable
NIA	==> Record(var:S, fn:EDF, range:SOCDF, abserr:DF, relerr:DF)
MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                   defaultMin:F, measure:F, failList:IFL, explList:List String)
Measure	==> Record(measure:F, name:ST, explanations:LST, extra:Result)


AnnaNumericalIntegrationPackage(): with

  integrate: (EF,SOCF,F,F,RT) -> Result
    ++ integrate(exp, a..b, epsrel, routines) is a top level ANNA function 
    ++ to integrate an expression, {\tt exp}, over a given range {\tt a} 
    ++ to {\tt b} to the required absolute and relative accuracy using 
    ++ the routines available in the RoutinesTable provided.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} 
    ++ to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
  integrate: NumericalIntegrationProblem -> Result
    ++ integrate(IntegrationProblem) is a top level ANNA function 
    ++ to integrate an expression over a given range or ranges 
    ++ to the required absolute and relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  

  integrate: (EF,SOCF,F,F) -> Result
    ++ integrate(exp, a..b, epsabs, epsrel) is a top level ANNA function 
    ++ to integrate an expression, {\tt exp}, over a given range {\tt a} 
    ++ to {\tt b} to the required absolute and relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  

  integrate: (EF,SOCF,F) -> Result
    ++ integrate(exp, a..b, epsrel) is a top level ANNA 
    ++ function to integrate an expression, {\tt exp}, over a given
    ++ range {\tt a} to {\tt b} to the required relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ If epsrel = 0, a default absolute accuracy is used.
 
  integrate: (EF,SOCF) -> Result
    ++ integrate(exp, a..b) is a top 
    ++ level ANNA function to integrate an expression, {\tt exp},
    ++ over a given range {\tt a} to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ Default values for the absolute and relative error are used.

  integrate:(EF,LSOCF) -> Result
    ++ integrate(exp, [a..b,c..d,...]) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ Default values for the absolute and relative error are used.

  integrate:(EF,LSOCF,F) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsrel) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required relative
    ++ accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ If epsrel = 0, a default absolute accuracy is used.

  integrate:(EF,LSOCF,F,F) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsabs, epsrel) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required absolute and relative
    ++ accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.

  integrate:(EF,LSOCF,F,F,RT) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsabs, epsrel, routines) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required absolute and relative
    ++ accuracy, using the routines available in the RoutinesTable provided.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.

  measure:NumericalIntegrationProblem -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine for solving the numerical integration
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{NumericalIntegrationCategory} in turn to calculate all measures
    ++ and returns the best 
    ++ i.e. the name of the most appropriate domain and any other relevant
    ++ information.
  measure:(NumericalIntegrationProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical integration
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{NumericalIntegrationCategory} in turn to calculate all measures
    ++ and returns the best 
    ++ i.e. the name of the most appropriate domain and any other relevant
    ++ information.
  integrate:(EF,SBOCF,ST) -> Union(Result,"failed")
    ++ integrate(exp, x = a..b, "numerical") is a top level ANNA function to 
    ++ integrate an expression, {\tt exp}, over a given range, {\tt a}
    ++ to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.\newline
    ++ 
    ++ Default values for the absolute and relative error are used.
    ++
    ++ It is an error of the last argument is not {\tt "numerical"}.
  integrate:(EF,SBOCF,S) -> Union(Result,"failed")
    ++ integrate(exp, x = a..b, numerical) is a top level ANNA function to 
    ++ integrate an expression, {\tt exp}, over a given range, {\tt a}
    ++ to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.\newline
    ++ 
    ++ Default values for the absolute and relative error are used.
    ++
    ++ It is an error if the last argument is not {\tt numerical}.

 ==  add

  zeroMeasure: Measure -> Result
  scriptedVariables?: MDNIA -> Boolean
  preAnalysis:(Union(nia:NIA,mdnia:MDNIA),RT) -> RT
  measureSpecific:(ST,RT,Union(nia:NIA,mdnia:MDNIA)) -> Record(measure:F,explanations:LST,extra:Result)
  changeName:(Result,ST) -> Result
  recoverAfterFail:(Union(nia:NIA,mdnia:MDNIA),RT,Measure,INT,Result) -> Record(a:Result,b:Measure)
  better?:(Result,Result) -> Boolean
  integrateConstant:(EF,SOCF) -> Result
  integrateConstantList: (EF,LSOCF) -> Result
  integrateArgs:(NumericalIntegrationProblem,RT) -> Result
  integrateSpecific:(Union(nia:NIA,mdnia:MDNIA),ST,Result) -> Result

  import ExpertSystemToolsPackage

  integrateConstantList(exp:EF,ras:LSOCF):Result ==
    c:OCF := ((retract(exp)@F)$EF)::OCF
    b := [hi(j)-lo(j) for j in ras]
    c := c*reduce((#1)*(#2),b)
    a := coerce(c)$AnyFunctions1(OCF)
    text := coerce("Constant Function")$AnyFunctions1(ST)
    construct([[result@S,a],[method@S,text]])$Result
    
  integrateConstant(exp:EF,ra:SOCF):Result ==
    c := (retract(exp)@F)$EF
    r:OCF := (c::OCF)*(hi(ra)-lo(ra))
    a := coerce(r)$AnyFunctions1(OCF)
    text := coerce("Constant Function")$AnyFunctions1(ST)
    construct([[result@S,a],[method@S,text]])$Result
    
  zeroMeasure(m:Measure):Result ==
    a := coerce(0$DF)$AnyFunctions1(DF)
    text := coerce("Constant Function")$AnyFunctions1(String)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  scriptedVariables?(mdnia:MDNIA):Boolean ==
    vars:List Symbol := variables(mdnia.fn)$EDF
    var1 := first(vars)$(List Symbol)
    not scripted?(var1) => false
    name1 := name(var1)$Symbol
    for i in 2..# vars repeat
      not ((scripted?(vars.i)$Symbol) and (name1 = name(vars.i)$Symbol)) => 
         return false
    true

  preAnalysis(args:Union(nia:NIA,mdnia:MDNIA),t:RT):RT ==
    import RT
    r:RT := selectIntegrationRoutines t
    args case nia => 
      arg:NIA := args.nia
      rangeIsFinite(arg)$d01AgentsPackage case finite => 
        selectFiniteRoutines r
      selectNonFiniteRoutines r
    selectMultiDimensionalRoutines r
    
  changeName(ans:Result,name:ST):Result ==
    sy:S := coerce(name "Answer")$S
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  measureSpecific(name:ST,R:RT,args:Union(nia:NIA,mdnia:MDNIA)):
      Record(measure:F,explanations:ST,extra:Result) ==
    args case nia => 
      arg:NIA := args.nia
      name = "d01ajfAnnaType" => measure(R,arg)$d01ajfAnnaType
      name = "d01akfAnnaType" => measure(R,arg)$d01akfAnnaType
      name = "d01alfAnnaType" => measure(R,arg)$d01alfAnnaType
      name = "d01amfAnnaType" => measure(R,arg)$d01amfAnnaType
      name = "d01anfAnnaType" => measure(R,arg)$d01anfAnnaType
      name = "d01apfAnnaType" => measure(R,arg)$d01apfAnnaType
      name = "d01aqfAnnaType" => measure(R,arg)$d01aqfAnnaType
      name = "d01asfAnnaType" => measure(R,arg)$d01asfAnnaType
      name = "d01TransformFunctionType" => 
                     measure(R,arg)$d01TransformFunctionType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    args case mdnia => 
      arg2:MDNIA := args.mdnia
      name = "d01gbfAnnaType" => measure(R,arg2)$d01gbfAnnaType
      name = "d01fcfAnnaType" => measure(R,arg2)$d01fcfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    error("measureSpecific","invalid type name")$ErrorFunctions

  measure(a:NumericalIntegrationProblem,R:RT):Measure ==
    args:Union(nia:NIA,mdnia:MDNIA) := retract(a)$NumericalIntegrationProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := preAnalysis(args,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth:LST := ["Trying " e.type " integration routines"]
    ext := empty()$Result
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,args)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        ext := concat(m.extra,ext)$ExpertSystemToolsPackage
        str:LST := [string(rout.key)$S "measure: " outputMeasure(m.measure) 
                     " - " m.explanations]
      else
        str:LST :=  [string(rout.key)$S " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth,ext]

  measure(a:NumericalIntegrationProblem):Measure ==
    measure(a,routines()$RT)

  integrateSpecific(args:Union(nia:NIA,mdnia:MDNIA),n:ST,ex:Result):Result ==
    args case nia => 
      arg:NIA := args.nia
      n = "d01ajfAnnaType" => numericalIntegration(arg,ex)$d01ajfAnnaType
      n = "d01TransformFunctionType" =>
        numericalIntegration(arg,ex)$d01TransformFunctionType
      n = "d01amfAnnaType" => numericalIntegration(arg,ex)$d01amfAnnaType
      n = "d01apfAnnaType" => numericalIntegration(arg,ex)$d01apfAnnaType
      n = "d01aqfAnnaType" => numericalIntegration(arg,ex)$d01aqfAnnaType
      n = "d01alfAnnaType" => numericalIntegration(arg,ex)$d01alfAnnaType
      n = "d01akfAnnaType" => numericalIntegration(arg,ex)$d01akfAnnaType
      n = "d01anfAnnaType" => numericalIntegration(arg,ex)$d01anfAnnaType
      n = "d01asfAnnaType" => numericalIntegration(arg,ex)$d01asfAnnaType
      error("integrateSpecific","invalid type name: " n)$ErrorFunctions
    args case mdnia => 
      arg2:MDNIA := args.mdnia
      n = "d01gbfAnnaType" => numericalIntegration(arg2,ex)$d01gbfAnnaType
      n = "d01fcfAnnaType" => numericalIntegration(arg2,ex)$d01fcfAnnaType
      error("integrateSpecific","invalid type name: " n)$ErrorFunctions
    error("integrateSpecific","invalid type name: " n)$ErrorFunctions

  better?(r:Result,s:Result):Boolean ==
    a1 := search("abserr"::S,r)$Result
    a1 case "failed" => false
    abserr1 := retract(a1)$AnyFunctions1(DF)
    negative?(abserr1) => false
    a2 := search("abserr"::S,s)$Result
    a2 case "failed" => true
    abserr2 := retract(a2)$AnyFunctions1(DF)
    negative?(abserr2) => true
    (abserr1 < abserr2) -- true if r.abserr better than s.abserr

  recoverAfterFail(n:Union(nia:NIA,mdnia:MDNIA),routs:RT,m:Measure,iint:INT,
                         r:Result):Record(a:Result,b:Measure) ==
    bestName := m.name
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RoutinesTable
      s case "failed" => iint := 0
      if s = "changeEps" then
        nn := n.nia
        zero?(nn.abserr) =>
          nn.abserr := 1.0e-8 :: DF
          m := measure(n::NumericalIntegrationProblem,routs)
          zero?(m.measure) => iint := 0
          r := integrateSpecific(n,m.name,m.extra)
          iint := 0
      rn := routineName(1..6)
      buttVal := getButtonValue(rn,"functionEvaluations")$AttributeButtons
      if (s = "incrFunEvals") and (buttVal < 0.8) then
        increase(rn,"functionEvaluations")$AttributeButtons
      if s = "increase tolerance" then
        (n.nia).relerr := (n.nia).relerr*(10.0::DF)
      if s = "decrease tolerance" then
        (n.nia).relerr := (n.nia).relerr/(10.0::DF)
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:S,entry:Any):=[failure@S,fl]
      m2 := measure(n::NumericalIntegrationProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := integrateSpecific(n,m2.name,m2.extra)
      better?(r,r2) => 
        m.name := m2.name
        insert!(flrec,r)$Result
      bestName := m2.name
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@S,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(INT)
    m.name := bestName
    [r,m]

  integrateArgs(prob:NumericalIntegrationProblem,t:RT):Result ==
    args:Union(nia:NIA,mdnia:MDNIA) := retract(prob)$NumericalIntegrationProblem
    routs := copy(t)$RT
    if args case mdnia then
      arg := args.mdnia
      v := (# variables(arg.fn))
      not scriptedVariables?(arg) => 
        error("MultiDimensionalNumericalIntegrationPackage",
                "invalid variable names")$ErrorFunctions
      (v ~= # arg.range)@Boolean =>
        error("MultiDimensionalNumericalIntegrationPackage",
          "number of variables do not match number of ranges")$ErrorFunctions
    m := measure(prob,routs)
    zero?(m.measure) => zeroMeasure m
    r := integrateSpecific(args,m.name,m.extra)
    iany := search(ifail@S,r)$Result
    iint := 0$INT
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(INT)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(args,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)$ExpertSystemToolsPackage
    n := m.name
    nn:ST := 
      (# n > 14) => "d01transform"
      n(1..6)
    expl := getExplanations(routs,nn)$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    args case nia =>
      att := showAttributes(args.nia)$IntegrationFunctionsTable
      att case "failed" => r
      concat(att2Result att,r)$ExpertSystemToolsPackage
    r

  integrate(args:NumericalIntegrationProblem):Result ==
    integrateArgs(args,routines()$RT)

  integrate(exp:EF,ra:SOCF,epsabs:F,epsrel:F,r:RT):Result ==
    Var:LS := variables(exp)$EF
    empty?(Var)$LS => integrateConstant(exp,ra)
    args:NIA := [first(Var)$LS,ef2edf exp,socf2socdf ra,f2df epsabs,f2df epsrel]
    integrateArgs(args::NumericalIntegrationProblem,r)

  integrate(exp:EF,ra:SOCF,epsabs:F,epsrel:F):Result ==
    integrate(exp,ra,epsabs,epsrel,routines()$RT)

  integrate(exp:EF,ra:SOCF,err:F):Result ==
    positive?(err)$F => integrate(exp,ra,0$F,err)
    integrate(exp,ra,1.0E-5,err)

  integrate(exp:EF,ra:SOCF):Result == integrate(exp,ra,0$F,1.0E-5)

  integrate(exp:EF,sb:SBOCF, st:ST) ==
    st = "numerical" => integrate(exp,segment sb)
    "failed"

  integrate(exp:EF,sb:SBOCF, s:S) ==
    s = (numerical::Symbol) => integrate(exp,segment sb)
    "failed"

  integrate(exp:EF,ra:LSOCF,epsabs:F,epsrel:F,r:RT):Result ==
    vars := variables(exp)$EF
    empty?(vars)$LS => integrateConstantList(exp,ra)
    args:MDNIA := [ef2edf exp,convert ra,f2df epsabs,f2df epsrel]
    integrateArgs(args::NumericalIntegrationProblem,r)

  integrate(exp:EF,ra:LSOCF,epsabs:F,epsrel:F):Result ==
    integrate(exp,ra,epsabs,epsrel,routines()$RT)

  integrate(exp:EF,ra:LSOCF,epsrel:F):Result ==
    zero? epsrel => integrate(exp,ra,1.0e-6,epsrel)
    integrate(exp,ra,0$F,epsrel)

  integrate(exp:EF,ra:LSOCF):Result == integrate(exp,ra,1.0e-4)

@
<<INTPACK.dotabb>>=
"INTPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTPACK"]
"TBAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TBAGG"]
"INTPACK" -> "TBAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OPTPACK AnnaNumericalOptimizationPackage}
\pagehead{AnnaNumericalOptimizationPackage}{OPTPACK}
\pagepic{ps/v104annanumericaloptimizationpackage.ps}{OPTPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OPTPACK AnnaNumericalOptimizationPackage>>=
)abbrev package OPTPACK AnnaNumericalOptimizationPackage
++ Author: Brian Dupee
++ Date Created: February 1995
++ Date Last Updated: December 1997
++ Basic Operations: measure, optimize, goodnessOfFit.
++ Description:
++ \axiomType{AnnaNumericalOptimizationPackage} is a \axiom{package} of 
++ functions for the \axiomType{NumericalOptimizationCategory} 
++ with \axiom{measure} and \axiom{optimize}.
EDF	==> Expression DoubleFloat
LEDF	==> List Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LOCF	==> List OrderedCompletion Float
OCF	==> OrderedCompletion Float
LEF	==> List Expression Float
EF	==> Expression Float
LF	==> List Float
F	==> Float
LS	==> List Symbol
LST	==> List String
INT	==> Integer
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
LSA	==> Record(lfn:LEDF, init:LDF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:String, explanations:List String)
Measure2	==> Record(measure:F,explanations:String)
RT	==> RoutinesTable
UNOALSA	==> Union(noa:NOA,lsa:LSA)

AnnaNumericalOptimizationPackage(): with
  measure:NumericalOptimizationProblem -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical optimization problem defined by 
    ++ \axiom{prob} by checking various attributes of the functions and 
    ++ calculating a measure of compatibility of each routine to these 
    ++ attributes.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{NumericalOptimizationCategory} in turn to calculate all 
    ++ measures and returns the best i.e. the name of the most 
    ++ appropriate domain and any other relevant information.

  measure:(NumericalOptimizationProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical optimization problem defined by 
    ++ \axiom{prob} by checking various attributes of the functions and 
    ++ calculating a measure of compatibility of each routine to these 
    ++ attributes.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{NumericalOptimizationCategory} in turn to calculate all 
    ++ measures and returns the best i.e. the name of the most 
    ++ appropriate domain and any other relevant information.

  optimize:(NumericalOptimizationProblem,RT) -> Result
    ++ optimize(prob,routines) is a top level ANNA function to 
    ++ minimize a function or a set of functions with any constraints
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} listed in \axiom{routines} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:NumericalOptimizationProblem -> Result
    ++ optimize(prob) is a top level ANNA function to 
    ++ minimize a function or a set of functions with any constraints
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  goodnessOfFit:NumericalOptimizationProblem -> Result
    ++ goodnessOfFit(prob) is a top level ANNA function to 
    ++ check to goodness of fit of a least squares model 
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then calls the numerical routine \axiomType{E04YCF} to get estimates
    ++ of the variance-covariance matrix of the regression coefficients of 
    ++ the least-squares problem.
    ++ 
    ++ It thus returns both the results of the optimization and the
    ++ variance-covariance calculation.

  optimize:(EF,LF,LOCF,LEF,LOCF) -> Result 
    ++ optimize(f,start,lower,cons,upper) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables with the 
    ++ given constraints.
    ++
    ++ These constraints may be simple constraints on the variables
    ++ in which case \axiom{cons} would be an empty list and the bounds on
    ++ those variables defined in \axiom{lower} and \axiom{upper}, or a 
    ++ mixture of simple, linear and non-linear constraints, where
    ++ \axiom{cons} contains the linear and non-linear constraints and
    ++ the bounds on these are added to \axiom{upper} and \axiom{lower}.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(EF,LF,LOCF,LOCF) -> Result 
    ++ optimize(f,start,lower,upper) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables with 
    ++ simple constraints.  The bounds on
    ++ the variables are defined in \axiom{lower} and \axiom{upper}.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(EF,LF) -> Result 
    ++ optimize(f,start) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables without
    ++ constraints. 
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(LEF,LF) -> Result 
    ++ optimize(lf,start) is a top level ANNA function to 
    ++ minimize a set of functions, \axiom{lf}, of one or more variables 
    ++ without constraints i.e. a least-squares problem. 
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  goodnessOfFit:(LEF,LF) -> Result 
    ++ goodnessOfFit(lf,start) is a top level ANNA function to 
    ++ check to goodness of fit of a least squares model i.e. the minimization
    ++ of a set of functions, \axiom{lf}, of one or more variables without 
    ++ constraints.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then calls the numerical routine \axiomType{E04YCF} to get estimates
    ++ of the variance-covariance matrix of the regression coefficients of 
    ++ the least-squares problem.
    ++ 
    ++ It thus returns both the results of the optimization and the
    ++ variance-covariance calculation.

    ++ goodnessOfFit(lf,start) is a top level function to iterate over 
    ++ the \axiom{domains} of \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then checks the goodness of fit of the least squares model.

 == add

  preAnalysis:RT -> RT
  zeroMeasure:Measure -> Result
  optimizeSpecific:(UNOALSA,String) -> Result
  measureSpecific:(String,RT,UNOALSA) -> Measure2
  changeName:(Result,String) -> Result
  recoverAfterFail:(UNOALSA,RT,Measure,INT,Result) -> Record(a:Result,b:Measure)
  constant:UNOALSA -> Union(DF, "failed")
  optimizeConstant:DF -> Result

  import ExpertSystemToolsPackage,e04AgentsPackage,NumericalOptimizationProblem

  constant(args:UNOALSA):Union(DF,"failed") ==
    args case noa =>
      Args := args.noa
      f := Args.fn
      retractIfCan(f)@Union(DoubleFloat,"failed")
    "failed"

  optimizeConstant(c:DF): Result ==
    a := coerce(c)$AnyFunctions1(DF)
    text := coerce("Constant Function")$AnyFunctions1(String)
    construct([[objf@Symbol,a],[method@Symbol,text]])$Result

  preAnalysis(args:UNOALSA,t:RT):RT == 
    r := selectOptimizationRoutines(t)$RT
    args case lsa =>
      selectSumOfSquaresRoutines(r)$RT
    r

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("Zero Measure")$AnyFunctions1(String)
    r := construct([[objf@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)

  measureSpecific(name:String,R:RT,args:UNOALSA): Measure2 ==
    args case noa =>
      arg:NOA := args.noa
      name = "e04dgfAnnaType" => measure(R,arg)$e04dgfAnnaType
      name = "e04fdfAnnaType" => measure(R,arg)$e04fdfAnnaType
      name = "e04gcfAnnaType" => measure(R,arg)$e04gcfAnnaType
      name = "e04jafAnnaType" => measure(R,arg)$e04jafAnnaType
      name = "e04mbfAnnaType" => measure(R,arg)$e04mbfAnnaType
      name = "e04nafAnnaType" => measure(R,arg)$e04nafAnnaType
      name = "e04ucfAnnaType" => measure(R,arg)$e04ucfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    args case lsa =>
      arg2:LSA := args.lsa
      name = "e04fdfAnnaType" => measure(R,arg2)$e04fdfAnnaType
      name = "e04gcfAnnaType" => measure(R,arg2)$e04gcfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    error("measureSpecific","invalid argument type")$ErrorFunctions

  measure(Args:NumericalOptimizationProblem,R:RT):Measure ==
    args:UNOALSA := retract(Args)$NumericalOptimizationProblem
    sofar := 0$F
    best := "none" :: String
    routs := copy R
    routs := preAnalysis(args,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$(List String)
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,args)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str := [concat(concat([string(rout.key)$Symbol,"measure: ",
                 outputMeasure(m.measure)," - "],
                   m.explanations)$(List String))$String]
      else 
        str := [concat([string(rout.key)$Symbol
                         ," is no better than other routines"])$String]
      meth := append(meth,str)$(List String)
    [sofar,best,meth]

  measure(args:NumericalOptimizationProblem):Measure == measure(args,routines()$RT)

  optimizeSpecific(args:UNOALSA,name:String):Result ==
    args case noa =>
      arg:NOA := args.noa
      name = "e04dgfAnnaType" => numericalOptimization(arg)$e04dgfAnnaType
      name = "e04fdfAnnaType" => numericalOptimization(arg)$e04fdfAnnaType
      name = "e04gcfAnnaType" => numericalOptimization(arg)$e04gcfAnnaType
      name = "e04jafAnnaType" => numericalOptimization(arg)$e04jafAnnaType
      name = "e04mbfAnnaType" => numericalOptimization(arg)$e04mbfAnnaType
      name = "e04nafAnnaType" => numericalOptimization(arg)$e04nafAnnaType
      name = "e04ucfAnnaType" => numericalOptimization(arg)$e04ucfAnnaType
      error("optimizeSpecific","invalid type name: " name)$ErrorFunctions
    args case lsa =>
      arg2:LSA := args.lsa
      name = "e04fdfAnnaType" => numericalOptimization(arg2)$e04fdfAnnaType
      name = "e04gcfAnnaType" => numericalOptimization(arg2)$e04gcfAnnaType
      error("optimizeSpecific","invalid type name: " name)$ErrorFunctions
    error("optimizeSpecific","invalid type name: " name)$ErrorFunctions

  changeName(ans:Result,name:String):Result ==
    st:String := concat([name,"Answer"])$String
    sy:Symbol := coerce(st)$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(args:UNOALSA,routs:RT,m:Measure,
                     iint:INT,r:Result):Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(String)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(args::NumericalOptimizationProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := optimizeSpecific(args,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(INT)
    [r,m]

  optimize(Args:NumericalOptimizationProblem,t:RT):Result ==
    args:UNOALSA := retract(Args)$NumericalOptimizationProblem
    routs := copy(t)$RT
    c:Union(DF,"failed") := constant(args)
    c case DF => optimizeConstant(c)
    m := measure(Args,routs)
    zero?(m.measure) => zeroMeasure m
    r := optimizeSpecific(args,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$INT
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(INT)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(args,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    att:List String := optAttributes(args)
    atta := coerce(att)$AnyFunctions1(List String)
    attr:Record(key:Symbol,entry:Any) := [attributes@Symbol,atta]
    insert!(attr,r)$Result

  optimize(args:NumericalOptimizationProblem):Result == optimize(args,routines()$RT)

  goodnessOfFit(Args:NumericalOptimizationProblem):Result ==
    r := optimize(Args)
    args1:UNOALSA := retract(Args)$NumericalOptimizationProblem
    args1 case noa => error("goodnessOfFit","Not an appropriate problem")
    args:LSA := args1.lsa
    lf := args.lfn
    n:INT := #(variables(args))
    m:INT := # lf
    me := search(method,r)$Result
    me case "failed" => r
    meth := retract(me)$AnyFunctions1(Result)
    na := search(nameOfRoutine,meth)$Result
    na case "failed" => r
    name := retract(na)$AnyFunctions1(String)
    temp:INT := (n*(n-1)) quo 2
    ns:INT :=
      name = "e04fdfAnnaType" => 6*n+(2+n)*m+1+max(1,temp)
      8*n+(n+2)*m+temp+1+max(1,temp)
    nv:INT := ns+n
    ww := search(w,r)$Result
    ww case "failed" => r
    ws:MDF := retract(ww)$AnyFunctions1(MDF)
    fr := search(objf,r)$Result
    fr case "failed" => r
    f := retract(fr)$AnyFunctions1(DF)
    s := subMatrix(ws,1,1,ns,nv-1)$MDF
    v := subMatrix(ws,1,1,nv,nv+n*n-1)$MDF
    r2 := e04ycf(0,m,n,f,s,n,v,-1)$NagOptimisationPackage
    concat(r,r2)

  optimize(f:EF,start:LF,lower:LOCF,cons:LEF,upper:LOCF):Result ==
    args:NOA := [ef2edf(f),[f2df i for i in start],[ocf2ocdf j for j in lower],
                 [ef2edf k for k in cons], [ocf2ocdf l for l in upper]]
    optimize(args::NumericalOptimizationProblem)

  optimize(f:EF,start:LF,lower:LOCF,upper:LOCF):Result ==
    optimize(f,start,lower,empty()$LEF,upper)

  optimize(f:EF,start:LF):Result ==
    optimize(f,start,empty()$LOCF,empty()$LOCF)

  optimize(lf:LEF,start:LF):Result ==
    args:LSA := [[ef2edf i for i in lf],[f2df j for j in start]]
    optimize(args::NumericalOptimizationProblem)

  goodnessOfFit(lf:LEF,start:LF):Result ==
    args:LSA := [[ef2edf i for i in lf],[f2df j for j in start]]
    goodnessOfFit(args::NumericalOptimizationProblem)

@
<<OPTPACK.dotabb>>=
"OPTPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OPTPACK"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"OPTPACK" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEPACK AnnaOrdinaryDifferentialEquationPackage}
\pagehead{AnnaOrdinaryDifferentialEquationPackage}{ODEPACK}
\pagepic{ps/v104annaordinarydifferentialequationpackage.ps}{ODEPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEPACK AnnaOrdinaryDifferentialEquationPackage>>=
)abbrev package ODEPACK AnnaOrdinaryDifferentialEquationPackage
++ Author: Brian Dupee
++ Date Created: February 1995
++ Date Last Updated: December 1997
++ Basic Operations: solve, measure
++ Description:
++ \axiomType{AnnaOrdinaryDifferentialEquationPackage} is a \axiom{package}
++ of functions for the \axiom{category} \axiomType{OrdinaryDifferentialEquationsSolverCategory} 
++ with \axiom{measure}, and \axiom{solve}.
++
EDF	==> Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
FI	==> Fraction Integer
EFI	==> Expression Fraction Integer
SOCDF	==> Segment OrderedCompletion DoubleFloat
VEDF	==> Vector Expression DoubleFloat
VEF	==> Vector Expression Float
EF	==> Expression Float
LF	==> List Float
F	==> Float
VDF	==> Vector DoubleFloat
VMF	==> Vector MachineFloat
MF	==> MachineFloat
LS	==> List Symbol
ST	==> String
LST	==> List String
INT	==> Integer
RT	==> RoutinesTable
ODEA	==> Record(xinit:DF,xend:DF,fn:VEDF,yinit:LDF,intvals:LDF,_
                    g:EDF,abserr:DF,relerr:DF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:String, explanations:List String)

AnnaOrdinaryDifferentialEquationPackage(): with
  solve:(NumericalODEProblem) -> Result
    ++ solve(odeProblem) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with starting values for X and Y[1]..Y[n] (called the initial
    ++ conditions), a final value of X, an accuracy requirement and any
    ++ intermediate points at which the result is required. 
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} 
    ++ to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(NumericalODEProblem,RT) -> Result
    ++ solve(odeProblem,R) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with starting values for X and Y[1]..Y[n] (called the initial
    ++ conditions), a final value of X, an accuracy requirement and any
    ++ intermediate points at which the result is required. 
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF) -> Result
    ++ solve(f,xStart,xEnd,yInitial) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with a starting value for X and Y[1]..Y[n] (called the initial
    ++ conditions) and a final value of X.  A default value
    ++ is used for the accuracy requirement.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}.  
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The calculation will stop if the function G(X,Y[1],..,Y[n]) evaluates to zero before
    ++ X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,intVals,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,intVals,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.  The calculation will stop if the function 
    ++ G(X,Y[1],..,Y[n]) evaluates to zero before X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,LF,F,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,intVals,epsabs,epsrel) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to an absolute error
    ++ requirement \axiom{epsabs} and relative error \axiom{epsrel}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.  The calculation will stop if the function 
    ++ G(X,Y[1],..,Y[n]) evaluates to zero before X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  measure:(NumericalODEProblem) -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical ODE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of ODEs
    ++ by checking various attributes of the system of ODEs and calculating
    ++ a measure of compatibility of each routine to these attributes.
  measure:(NumericalODEProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical ODE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of ODEs
    ++ by checking various attributes of the system of ODEs and calculating
    ++ a measure of compatibility of each routine to these attributes.

 == add

  import ODEA,NumericalODEProblem

  f2df:F -> DF
  ef2edf:EF -> EDF
  preAnalysis:(ODEA,RT) -> RT
  zeroMeasure:Measure -> Result
  measureSpecific:(ST,RT,ODEA) -> Record(measure:F,explanations:ST)
  solveSpecific:(ODEA,ST) -> Result
  changeName:(Result,ST) -> Result 
  recoverAfterFail:(ODEA,RT,Measure,Integer,Result) -> Record(a:Result,b:Measure)

  f2df(f:F):DF == (convert(f)@DF)$F

  ef2edf(f:EF):EDF == map(f2df,f)$ExpressionFunctions2(F,DF)

  preAnalysis(args:ODEA,t:RT):RT ==
    rt := selectODEIVPRoutines(t)$RT
    if positive?(# variables(args.g)) then 
      changeMeasure(rt,d02bbf@Symbol,getMeasure(rt,d02bbf@Symbol)*0.8)
    if positive?(# args.intvals) then 
      changeMeasure(rt,d02bhf@Symbol,getMeasure(rt,d02bhf@Symbol)*0.8)
    rt

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("Zero Measure")$AnyFunctions1(ST)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  measureSpecific(name:ST,R:RT,ode:ODEA):Record(measure:F,explanations:ST) ==
    name = "d02bbfAnnaType" => measure(R,ode)$d02bbfAnnaType
    name = "d02bhfAnnaType" => measure(R,ode)$d02bhfAnnaType
    name = "d02cjfAnnaType" => measure(R,ode)$d02cjfAnnaType
    name = "d02ejfAnnaType" => measure(R,ode)$d02ejfAnnaType
    error("measureSpecific","invalid type name: " name)$ErrorFunctions

  measure(Ode:NumericalODEProblem,R:RT):Measure ==
    ode:ODEA := retract(Ode)$NumericalODEProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := preAnalysis(ode,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$LST
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,ode)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str:LST := [string(rout.key)$Symbol "measure: " 
                    outputMeasure(m.measure)$ExpertSystemToolsPackage " - " 
                     m.explanations]
      else 
        str := [string(rout.key)$Symbol " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth]

  measure(ode:NumericalODEProblem):Measure == measure(ode,routines()$RT)

  solveSpecific(ode:ODEA,n:ST):Result ==
    n = "d02bbfAnnaType" => ODESolve(ode)$d02bbfAnnaType
    n = "d02bhfAnnaType" => ODESolve(ode)$d02bhfAnnaType
    n = "d02cjfAnnaType" => ODESolve(ode)$d02cjfAnnaType
    n = "d02ejfAnnaType" => ODESolve(ode)$d02ejfAnnaType
    error("solveSpecific","invalid type name: " n)$ErrorFunctions

  changeName(ans:Result,name:ST):Result ==
    sy:Symbol := coerce(name "Answer")$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(ode:ODEA,routs:RT,m:Measure,iint:Integer,r:Result):
                                            Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      if s = "increase tolerance" then
        ode.relerr := ode.relerr*(10.0::DF)
        ode.abserr := ode.abserr*(10.0::DF)
      if s = "decrease tolerance" then
        ode.relerr := ode.relerr/(10.0::DF)
        ode.abserr := ode.abserr/(10.0::DF)
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(ode::NumericalODEProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := solveSpecific(ode,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(Integer)
    [r,m]

  solve(Ode:NumericalODEProblem,t:RT):Result ==
    ode:ODEA := retract(Ode)$NumericalODEProblem
    routs := copy(t)$RT
    m := measure(Ode,routs)
    zero?(m.measure) => zeroMeasure m
    r := solveSpecific(ode,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$Integer
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(Integer)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(ode,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)$ExpertSystemToolsPackage
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    iflist := showIntensityFunctions(ode)$ODEIntensityFunctionsTable
    iflist case "failed" => r
    concat(iflist2Result iflist, r)$ExpertSystemToolsPackage

  solve(ode:NumericalODEProblem):Result == solve(ode,routines()$RT)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,G:EF,intVals:LF,epsabs:F,epsrel:F):Result ==
    d:ODEA := [f2df xStart,f2df xEnd,vector([ef2edf e for e in members f])$VEDF,
               [f2df i for i in yInitial], [f2df j for j in intVals],
                ef2edf G,f2df epsabs,f2df epsrel]
    solve(d::NumericalODEProblem,routines()$RT)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,G:EF,intVals:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,G,intVals,tol,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,intVals:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,1$EF,intVals,tol)

  solve(f:VEF,xStart:F,xEnd:F,y:LF,G:EF,tol:F):Result ==
    solve(f,xStart,xEnd,y,G,empty()$LF,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,1$EF,empty()$LF,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF):Result == solve(f,xStart,xEnd,yInitial,1.0e-4)

@
<<ODEPACK.dotabb>>=
"ODEPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEPACK"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"ODEPACK" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PDEPACK AnnaPartialDifferentialEquationPackage}
\pagehead{AnnaPartialDifferentialEquationPackage}{PDEPACK}
\pagepic{ps/v104annapartialdifferentialequationpackage.ps}{PDEPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PDEPACK AnnaPartialDifferentialEquationPackage>>=
)abbrev package PDEPACK AnnaPartialDifferentialEquationPackage
++ Author: Brian Dupee
++ Date Created: June 1996
++ Date Last Updated: December 1997
++ Basic Operations: 
++ Description: AnnaPartialDifferentialEquationPackage is an uncompleted
++ package for the interface to NAG PDE routines.  It has been realised that
++ a new approach to solving PDEs will need to be created.
++
LEDF	==> List Expression DoubleFloat
EDF	==> Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
LEF	==> List Expression Float
EF	==> Expression Float
MEF	==> Matrix Expression Float
LF	==> List Float
F	==> Float
LS	==> List Symbol
ST	==> String
LST	==> List String
INT	==> Integer
NNI	==> NonNegativeInteger
RT	==> RoutinesTable
PDEC	==> Record(start:DF, finish:DF, grid:NNI, boundaryType:INT, 
                    dStart:MDF, dFinish:MDF)
PDEB	==> Record(pde:LEDF, constraints:List PDEC,
                    f:List LEDF, st:ST, tol:DF)
IFL	==> List(Record(ifail:INT,instruction:ST))
Entry	==> Record(chapter:ST, type:ST, domainName: ST, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:ST, explanations:LST)

AnnaPartialDifferentialEquationPackage(): with
  solve:(NumericalPDEProblem) -> Result
    ++ solve(PDEProblem) is a top level ANNA function to solve numerically a system
    ++ of partial differential equations.  
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(NumericalPDEProblem,RT) -> Result
    ++ solve(PDEProblem,routines) is a top level ANNA function to solve numerically a system
    ++ of partial differential equations.  
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(F,F,F,F,NNI,NNI,LEF,List LEF,ST,DF) -> Result
    ++ solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st,tol) is a top level 
    ++ ANNA function to solve numerically a system of partial differential 
    ++ equations.  This is defined as a list of coefficients (\axiom{pde}),
    ++ a grid (\axiom{xmin}, \axiom{ymin}, \axiom{xmax}, \axiom{ymax}, 
    ++ \axiom{ngx}, \axiom{ngy}), the boundary values (\axiom{bounds}) and a
    ++ tolerance requirement (\axiom{tol}).  There is also a parameter 
    ++ (\axiom{st}) which should contain the value "elliptic" if the PDE is
    ++ known to be elliptic, or "unknown" if it is uncertain.  This causes the
    ++ routine to check whether the PDE is elliptic.
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(F,F,F,F,NNI,NNI,LEF,List LEF,ST) -> Result
    ++ solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st) is a top level 
    ++ ANNA function to solve numerically a system of partial differential 
    ++ equations.  This is defined as a list of coefficients (\axiom{pde}),
    ++ a grid (\axiom{xmin}, \axiom{ymin}, \axiom{xmax}, \axiom{ymax}, 
    ++ \axiom{ngx}, \axiom{ngy}) and the boundary values (\axiom{bounds}).  
    ++ A default value for tolerance is used.  There is also a parameter 
    ++ (\axiom{st}) which should contain the value "elliptic" if the PDE is
    ++ known to be elliptic, or "unknown" if it is uncertain.  This causes the
    ++ routine to check whether the PDE is elliptic.
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  measure:(NumericalPDEProblem) -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical PDE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{PartialDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of PDEs
    ++ by checking various attributes of the system of PDEs and calculating
    ++ a measure of compatibility of each routine to these attributes.
  measure:(NumericalPDEProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical PDE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{PartialDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of PDEs
    ++ by checking various attributes of the system of PDEs and calculating
    ++ a measure of compatibility of each routine to these attributes.


 == add

  import PDEB, d03AgentsPackage, ExpertSystemToolsPackage, NumericalPDEProblem

  zeroMeasure:Measure -> Result
  measureSpecific:(ST,RT,PDEB) -> Record(measure:F,explanations:ST)
  solveSpecific:(PDEB,ST) -> Result
  changeName:(Result,ST) -> Result
  recoverAfterFail:(PDEB,RT,Measure,Integer,Result) -> Record(a:Result,b:Measure)

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("No available routine appears appropriate")$AnyFunctions1(ST)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  measureSpecific(name:ST,R:RT,p:PDEB):Record(measure:F,explanations:ST) ==
    name = "d03eefAnnaType" => measure(R,p)$d03eefAnnaType
    --name = "d03fafAnnaType" => measure(R,p)$d03fafAnnaType
    error("measureSpecific","invalid type name: " name)$ErrorFunctions

  measure(P:NumericalPDEProblem,R:RT):Measure ==
    p:PDEB := retract(P)$NumericalPDEProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := selectPDERoutines(routs)$RT
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$LST
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,p)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str:LST := [string(rout.key)$Symbol "measure: " 
                    outputMeasure(m.measure)$ExpertSystemToolsPackage " - " 
                     m.explanations]
      else 
        str := [string(rout.key)$Symbol " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth]

  measure(P:NumericalPDEProblem):Measure == measure(P,routines()$RT)

  solveSpecific(p:PDEB,n:ST):Result ==
    n = "d03eefAnnaType" => PDESolve(p)$d03eefAnnaType
    --n = "d03fafAnnaType" => PDESolve(p)$d03fafAnnaType
    error("solveSpecific","invalid type name: " n)$ErrorFunctions

  changeName(ans:Result,name:ST):Result ==
    sy:Symbol := coerce(name "Answer")$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(p:PDEB,routs:RT,m:Measure,iint:Integer,r:Result):
                                            Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(p::NumericalPDEProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := solveSpecific(p,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(Integer)
    [r,m]

  solve(P:NumericalPDEProblem,t:RT):Result ==
    routs := copy(t)$RT
    m := measure(P,routs)
    p:PDEB := retract(P)$NumericalPDEProblem
    zero?(m.measure) => zeroMeasure m
    r := solveSpecific(p,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$Integer
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(Integer)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(p,routs,m,iint,r)
      r := tu.a
      m := tu.b
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  solve(P:NumericalPDEProblem):Result == solve(P,routines()$RT)

  solve(xmi:F,xma:F,ymi:F,yma:F,nx:NNI,ny:NNI,pe:LEF,bo:List
                LEF,s:ST,to:DF):Result ==
    cx:PDEC := [f2df xmi, f2df xma, nx, 1, empty()$MDF, empty()$MDF]
    cy:PDEC := [f2df ymi, f2df yma, ny, 1, empty()$MDF, empty()$MDF]
    p:PDEB := [[ef2edf e for e in pe],[cx,cy],
                [[ef2edf u for u in w] for w in bo],s,to]
    solve(p::NumericalPDEProblem,routines()$RT)

  solve(xmi:F,xma:F,ymi:F,yma:F,nx:NNI,ny:NNI,pe:LEF,bo:List
                LEF,s:ST):Result ==
    solve(xmi,xma,ymi,yma,nx,ny,pe,bo,s,0.0001::DF)

@
<<PDEPACK.dotabb>>=
"PDEPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PDEPACK"]
"TBAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TBAGG"]
"PDEPACK" -> "TBAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ANY1 AnyFunctions1}
\pagehead{AnyFunctions1}{ANY1}
\pagepic{ps/v104anyfunctions1.ps}{ANY1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ANY1 AnyFunctions1>>=
)abbrev package ANY1 AnyFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions:  coerce, retractIfCan, retractable?, retract
++ Related Constructors: Any
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{AnyFunctions1} implements several utility functions for
++   working with \spadtype{Any}. These functions are used to go back
++   and forth between objects of \spadtype{Any} and objects of other
++   types.

AnyFunctions1(S:Type): with
        coerce      : S -> Any
          ++ coerce(s) creates an object of \spadtype{Any} from the
          ++ object \spad{s} of type \spad{S}.
        retractIfCan: Any -> Union(S, "failed")
          ++ retractIfCan(a) tries change \spad{a} into an object
          ++ of type \spad{S}. If it can, then such an object is
          ++ returned. Otherwise, "failed" is returned.
        retractable?: Any -> Boolean
          ++ retractable?(a) tests if \spad{a} can be converted
          ++ into an object of type \spad{S}.
        retract     : Any -> S
          ++ retract(a) tries to convert \spad{a} into an object of
          ++ type \spad{S}. If possible, it returns the object.
          ++ Error: if no such retraction is possible.

    == add
        import NoneFunctions1(S)

        Sexpr:SExpression := devaluate(S)$Lisp

        retractable? a  == dom(a) = Sexpr
        coerce(s:S):Any == any(Sexpr, s::None)

        retractIfCan a ==
            retractable? a => obj(a) pretend S
            "failed"

        retract a ==
            retractable? a => obj(a) pretend S
            error "Cannot retract value."

@
<<ANY1.dotabb>>=
"ANY1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ANY1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"ANY1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMPRED AttachPredicates}
\pagehead{AttachPredicates}{PMPRED}
\pagepic{ps/v104attachpredicates.ps}{PMPRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMPRED AttachPredicates>>=
)abbrev package PMPRED AttachPredicates
++ Predicates for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching predicates to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
AttachPredicates(D:Type): Exports == Implementation where
  FE ==> Expression Integer

  Exports ==> with
    suchThat: (Symbol, D -> Boolean) -> FE
      ++ suchThat(x, foo) attaches the predicate foo to x.
    suchThat: (Symbol, List(D -> Boolean)) -> FE
      ++ suchThat(x, [f1, f2, ..., fn]) attaches the predicate
      ++ f1 and f2 and ... and fn to x.

  Implementation ==> add
    import FunctionSpaceAttachPredicates(Integer, FE, D)

    suchThat(p:Symbol, f:D -> Boolean)       == suchThat(p::FE, f)
    suchThat(p:Symbol, l:List(D -> Boolean)) == suchThat(p::FE, l)

@
<<PMPRED.dotabb>>=
"PMPRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMPRED"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"PMPRED" -> "PID"
"PMPRED" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AXSERV AxiomServer}
\pagehead{AxiomServer}{AXSERV}
\pagepic{ps/v104axiomserver.ps}{AXSERV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AXSERV AxiomServer>>=

)abbrev package AXSERV AxiomServer
AxiomServer: public == private where

 public == with

   axServer: (Integer, SExpression->Void) -> Void
   multiServ: SExpression -> Void
   getDatabase: (String,String) -> String

 private == add

   getFile: (SExpression,String) -> Void
   getCommand: (SExpression,String) -> Void
   getDescription: String -> String
   getInterp: (SExpression,String) -> Void
   getLisp:   (SExpression,String) -> Void
   getShow:   (SExpression,String) -> Void
   lastStep: () -> String
   lastType: () -> String
   formatMessages: String -> String
   makeErrorPage: String -> String
   getSourceFile: (String,String,String) -> String
   makeDBPage: String -> String
   getContentType: String -> String
   readTheFile: SExpression -> String 
   outputToSocket: (SExpression,String,String) -> Void 

   getDatabase(constructor:String, key:String):String ==
     answer:=string GETDATABASE(INTERN$Lisp constructor,INTERN$Lisp key)$Lisp
--     WriteLine$Lisp concat ["getDatabase: ",constructor," ",key," ",answer]
     answer

@
The axServer function handles the socket connection on the given port.
When it gets a input on the socket it calls the server
function on the socket input.
<<package AXSERV AxiomServer>>=
   axServer(port:Integer,serverfunc:SExpression->Void):Void ==
     WriteLine$Lisp "listening on port 8085"
     s := SiSock(port,serverfunc)$Lisp
     -- To listen for just one connection and then close the socket
     -- uncomment i := 0.
     i:Integer := 1
     while (i > 0) repeat
       if not null?(SiListen(s)$Lisp)$SExpression then
         w := SiAccept(s)$Lisp
         serverfunc(w)
--        i := 0

@
The multiServ function parses the socket input.
It expects either a GET or POST request.

A GET request fetches a new page, calling ``getFile''.
A POST request starts with 
\begin{itemize}
\item ``command='' which expects axiom interpreter commands. 
       When this is recognized we call the ``getCommand'' function.
\item ``lispcall='' which expects lisp interpreter input
       When this is recognized we call the ``getLisp'' function.
\end{itemize}
<<package AXSERV AxiomServer>>=

   multiServ(s:SExpression):Void ==
--     WriteLine("multiServ begin")$Lisp
     headers:String := ""
     char:String
     -- read in the http headers
     while (char := _
       STRING(READ_-CHAR_-NO_-HANG(s,NIL$Lisp,'EOF)$Lisp)$Lisp) ^= "EOF"_
        repeat
         headers := concat [headers,char]
--     sayTeX$Lisp headers
     StringMatch("([^ ]*)", headers)$Lisp
     u:UniversalSegment(Integer)
     u := segment(MatchBeginning(1)$Lisp+1,_
                  MatchEnd(1)$Lisp)$UniversalSegment(Integer)
     reqtype:String := headers.u
--     sayTeX$Lisp  concat ["request type: ",reqtype]
     if  reqtype = "GET" then
         StringMatch("GET ([^ ]*)",headers)$Lisp
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getFile(s,headers.u)
     if reqtype = "POST" and StringMatch("command=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getCommand(s,headers.u)
     if reqtype = "POST" and StringMatch("interpcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getInterp(s,headers.u)
     if reqtype = "POST" and StringMatch("lispcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getLisp(s,headers.u)
     if reqtype = "POST" and StringMatch("showcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getShow(s,headers.u)
--     WriteLine("multiServ end")$Lisp
--     WriteLine("")$Lisp

@
\subsubsection{getFile}
Given a socket and the URL of the file we create an input stream 
that contains the file. If the filename contains a question mark
then we need to parse the parameters and dynamically construct the
file contents.
<<package AXSERV AxiomServer>>=
   getFile(s:SExpression,pathvar:String):Void ==
--     WriteLine("")$Lisp
     WriteLine$Lisp concat ["getFile: ",pathvar]
     params:=split(pathvar,char "?")
     if #params = 1 
      then if not null? PATHNAME_-NAME(PATHNAME(pathvar)$Lisp)$Lisp 
       then
         contentType:String := getContentType(pathvar)
         q:=Open(pathvar)$Lisp
         if null? q 
           then
             q := MAKE_-STRING_-INPUT_-STREAM(_
                   makeErrorPage("File doesn't exist"))$Lisp
       else
         q:=MAKE_-STRING_-INPUT_-STREAM(_
             makeErrorPage("Problem with file path"))$Lisp
      else
       q:=MAKE_-STRING_-INPUT_-STREAM(makeDBPage(pathvar))$Lisp
     outputToSocket(s,readTheFile(q),contentType)     

@
\subsubsection{makeErrorPage}
<<package AXSERV AxiomServer>>=
   makeErrorPage(msg:String):String ==
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head><title>Error</title></head><body>" msg "</body></html>"
--     WriteLine(page)$Lisp
     page
@
\subsubsection{getDescription}
We need to fish around in the data structure to return the piece of 
documentation for the domain. We have to call the lisp version of
GETDATABASE because the version above returns a string object. The
string object is missing quotes and cannot be properly read. So we
need to get the lisp object and work with it in native form first.

The doc string also contains spad markup which we need to replace with html.
<<package AXSERV AxiomServer>>=
   getDescription(dom:String):String ==
    d:=CADR(CADAR(GETDATABASE(INTERN(dom)$Lisp,'DOCUMENTATION)$Lisp)$Lisp)$Lisp
    string d
@
\subsubsection{getSourceFile}
During build we construct a hash table that takes the chunk name as
the key and returns the filename. We reconstruct the chunk name here
and do a lookup for the source file.
<<package AXSERV AxiomServer>>=
   getSourceFile(constructorkind:String,_
                 abbreviation:String,_
                 dom:String):String ==
     sourcekey:="@<<" constructorkind " " abbreviation " " dom ">>"
--     WriteLine(sourcekey)$Lisp
     sourcefile:=lowerCase last split(getDatabase(dom,"SOURCEFILE"),char "/") 
     sourcefile:=sourcefile ".pamphlet"

@
\subsubsection{makeDBPage}
<<package AXSERV AxiomServer>>=
   makeDBPage(pathvar:String):String ==
     params:List(String):=split(pathvar,char "?")
     for i in 1..#params repeat WriteLine$Lisp concat ["params: ",params.i]
     pathparts:List(String):=split(params.1,char "/")
     for i in 1..#pathparts repeat 
       WriteLine$Lisp concat ["pathparts: ",pathparts.i]
     pagename:=last pathparts
     WriteLine$Lisp concat ["pagename: ",pagename]
     cmd:=first split(pagename,char ".")
     WriteLine$Lisp concat ["cmd: ",cmd]
     args:List(String):=split(params.2, char "&")
     for i in 1..#args repeat WriteLine$Lisp concat ["args: ",args.i]
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head>"
     page:=page "<meta http-equiv=_"Content-Type_" content=_"text/html_"" 
     page:=page " charset=_"us-ascii_"/>"
     page:=page "<title>" cmd " " args.1 "</title></head>"
     page:=page "<style> html { background-color: #FFFF66; } </style>"
     page:=page "<body>"
     cmd = "db" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
     cmd = "op" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
--     WriteLine(page)$Lisp
     page:=page "</body></html>"
     page
@
\subsubsection{readTheFile}
We have q which is a stream which contains the file. We read the file
into a string-stream to get it all into one string. We return the string.
<<package AXSERV AxiomServer>>=
   readTheFile(q:SExpression):String ==
--     WriteLine("begin reading file")$Lisp
     r := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
     SiCopyStream(q,r)$Lisp
     filestream:String := GET_-OUTPUT_-STREAM_-STRING(r)$Lisp
     CLOSE(r)$Lisp
     CLOSE(q)$Lisp
--     WriteLine("end reading file")$Lisp
     filestream

@
\subsubsection{outputToSocket}
We have ``s'' which is the socket, ``filestream'' which is the text of
the file to output, and ``contentType'' which is the HTML Content-Type.
We construct the HTML header information according to the standard and
prepend it to the file. The resulting string is output to the socket.
<<package AXSERV AxiomServer>>=
   outputToSocket(s:SExpression,filestream:String,contentType:String):Void ==
     filelength:String := string(#filestream)
     file:String := ""
     nl:String:=STRING(NewLine$Lisp)$Lisp
     file := concat ["Content-Length: ",filelength,nl,nl,file]
     file := concat ["Connection: close",nl,file]
     file := concat ["Content-Type: ",contentType,nl,file]
     file := concat ["HTTP/1.1 200 OK",nl,file]
     file := concat [file,filestream]
--     WriteLine(file)$Lisp
     f:=MAKE_-STRING_-INPUT_-STREAM(file)$Lisp
     SiCopyStream(f,s)$Lisp
     CLOSE(f)$Lisp
     CLOSE(s)$Lisp

@
\subsubsection{getCommand}
The getCommand function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getCommand(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getCommand: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getInterp}
The getInterp function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getInterp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getInterp: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getLisp}
The getLisp function is invoked when the HTTP request is a POST
and contains the string "lispcall".
<<package AXSERV AxiomServer>>=
   getLisp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getLisp: ",command]
       evalresult:=EVAL(READ_-FROM_-STRING(command)$Lisp)$Lisp
       mathml:String:=string(evalresult)
--       WriteLine$Lisp concat ["getLisp: after ",mathml]
--       WriteLine$Lisp concat ["getLisp output: ",mathml]
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", command, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{getShow}
The getShow function is invoked when the HTTP request is a POST
and contains the string "showcall". The )show command generates
output to lisp's *standard-output* so we wrap that stream to capture it.
The resulting string needs to be transformed into html-friendly form.
This is done in the call to replace-entitites (see http.lisp)
<<package AXSERV AxiomServer>>=
   getShow(s:SExpression,showarg:String):Void ==
       WriteLine$Lisp concat ["getShow: ",showarg]
       realarg:=SUBSEQ(showarg,6)$Lisp
       show:=_
        "(progn (setq |$options| '((|operations|))) (|show| '|" realarg "|))"
--       WriteLine$Lisp concat ["getShow: ",show]
       SETQ(SAVESTREAM$Lisp,_*STANDARD_-OUTPUT_*$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,_
             MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       evalresult:=EVAL(READ_-FROM_-STRING(show)$Lisp)$Lisp
       SETQ(evalresult,_
             GET_-OUTPUT_-STREAM_-STRING(_*STANDARD_-OUTPUT_*$Lisp)$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,SAVESTREAM$Lisp)$Lisp
       mathml:String:=string(REPLACE_-ENTITIES(evalresult)$Lisp)
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", showarg, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{lastType}
To examine the \$internalHistoryTable use the following line
\begin{verbatim}
  )lisp |$internalHistoryTable|
\end{verbatim}
We need to pick out first member of internalHistoryTable and then pick out
the element with \% as first element. Here is an example showing just
the first element of the list, which correponds to the last command.

Note that the last command does not necessarily correspond to the last
element of the first element of \$internalHistoryTable as it is in this
example.
\begin{verbatim}
   (
    (4 NIL
    (x (value (BasicOperator) WRAPPED . #<vector 09a93bd0>))
    (y (value (BasicOperator) WRAPPED . #<vector 09a93bb4>))
    (% (value (Matrix (Polynomial (Integer))) WRAPPED . #<vector 0982e0e0>))
    )
   ...
   )
\end{verbatim}

We also need to check for input error in which case the \$internalHistoryTable
is not changed and the type retrieved would be that for the last correct
input.
<<package AXSERV AxiomServer>>=
   lastType():String ==
     SETQ(first$Lisp,FIRST(_$internalHistoryTable$Lisp)$Lisp)$Lisp
     count:Integer := 0
     hisLength:Integer := LIST_-LENGTH(_$internalHistoryTable$Lisp)$Lisp
     length:Integer := LIST_-LENGTH(first$Lisp)$Lisp
     -- This initializes stepSav.  The test is a bit of a hack, maybe I'll
     -- figure out the right way to do it later.
     if string stepSav$Lisp = "#<OBJNULL>" then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     -- If hisLength = 0 then the history table has been reset to NIL
     -- and we're starting numbering over
     if hisLength = 0 then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     if hisLength > 0 and 
       car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp ^= stepSav$Lisp then
        SETQ(stepSav$Lisp,car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp)$Lisp
        while count < length  repeat
         position(char "%",string FIRST(first$Lisp)$Lisp) = 2 => 
           count := length+1
         count := count +1
         SETQ(first$Lisp,REST(first$Lisp)$Lisp)$Lisp
     count = length + 1 => 
         string SECOND(SECOND(FIRST(first$Lisp)$Lisp)$Lisp)$Lisp
     ""


   lastStep():String ==
       string car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp

   formatMessages(str:String):String ==
--       WriteLine("formatMessages")$Lisp
       -- I need to replace any ampersands with &amp; and may also need to
       -- replace < and > with &lt; and &gt;
       strlist:List String
--       WriteLine(str)$Lisp
       strlist := split(str,char "&")
       str := ""
       -- oops, if & is the last character in the string this method
       -- will eliminate it.  Need to redo this.
       for s in strlist repeat
           str := concat [str,s,"&amp;"]
       strlen:Integer := #str
       str := str.(1..(#str - 5))
--       WriteLine(str)$Lisp
       -- Here I split the string into lines and put each line in a "div".
       strlist := split(str, char string NewlineChar$Lisp)
       str := ""
--       WriteLine("formatMessages1")$Lisp
--       WriteLine(concat strlist)$Lisp
       for s in strlist repeat
--           WriteLine(s)$Lisp
           str := concat [str,"<div>",s,"</div>"]
       str

   getContentType(pathvar:String):String ==
--       WriteLine("getContentType begin")$Lisp
       -- set default content type
       contentType:String := "text/plain"
       -- need to test for successful match?
       StringMatch(".*\.(.*)$", pathvar)$Lisp
       u:UniversalSegment(Integer)
       u := segment(MatchBeginning(1)$Lisp+1,_
                    MatchEnd(1)$Lisp)$UniversalSegment(Integer)
       extension:String := pathvar.u
--       WriteLine$Lisp concat ["file extension: ",extension]
       -- test for extensions: html, htm, xml, xhtml, js, css
       if extension = "html" then
           contentType:String := "text/html"
       else if extension = "htm" then
           contentType:String := "text/html"
       else if extension = "xml" then
           contentType:String := "text/xml"
       else if extension = "xhtml" then
           contentType:String := "application/xhtml+xml"
       else if extension = "js" then
           contentType:String := "text/javascript"
       else if extension = "css" then
           contentType:String := "text/css"
       else if extension = "png" then
           contentType:String := "image/png"
       else if extension = "jpg" then
           contentType:String := "image/jpeg"
       else if extension = "jpeg" then
           contentType:String := "image/jpeg"
--       WriteLine$Lisp concat ["Content-Type: ",contentType]
--       WriteLine("getContentType end")$Lisp
       contentType

@
<<AXSERV.dotabb>>=
"AXSERV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AXSERV"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"AXSERV" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter B}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BEZOUT BezoutMatrix}
\pagehead{BezoutMatrix}{BEZOUT}
\pagepic{ps/v104bezoutmatrix.ps}{BEZOUT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BEZOUT BezoutMatrix>>=
)abbrev package BEZOUT BezoutMatrix
++ Author: Clifton J. Williamson
++ Date Created: 2 August 1988
++ Date Last Updated: 3 November 1993
++ Basic Operations: bezoutMatrix, bezoutResultant, bezoutDiscriminant
++ Related Domains
++ Also See:
++ AMS Classifiactions:
++ Keywords: Bezout matrix, resultant, discriminant
++ Examples:
++ Reference: Knuth, The Art of Computer Programming, 2nd edition,
++            Vol. 2, p. 619, problem 12.
++ Description:
++   \spadtype{BezoutMatrix} contains functions for computing resultants and
++   discriminants using Bezout matrices.

BezoutMatrix(R,UP,M,Row,Col): Exports == Implementation where
  R    : Ring
  UP   : UnivariatePolynomialCategory R
  Row  : FiniteLinearAggregate R
  Col  : FiniteLinearAggregate R
  M    : MatrixCategory(R,Row,Col)
  I  ==> Integer
  lc ==> leadingCoefficient

  Exports ==> with
    sylvesterMatrix: (UP,UP) -> M
      ++ sylvesterMatrix(p,q) returns the Sylvester matrix for the two
      ++ polynomials p and q.
    bezoutMatrix: (UP,UP) -> M
      ++ bezoutMatrix(p,q) returns the Bezout matrix for the two
      ++ polynomials p and q.

    if R has commutative("*") then
      bezoutResultant: (UP,UP) -> R
       ++ bezoutResultant(p,q) computes the resultant of the two
       ++ polynomials p and q by computing the determinant of a Bezout matrix.

      bezoutDiscriminant: UP -> R
       ++ bezoutDiscriminant(p) computes the discriminant of a polynomial p
       ++ by computing the determinant of a Bezout matrix.

  Implementation ==> add

    sylvesterMatrix(p,q) ==
      n1 := degree p; n2 := degree q; n := n1 + n2
      sylmat : M := new(n,n,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not zero? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        for i in 0..n2 - 1 repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        for i in 0..n1-1 repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      sylmat

    bezoutMatrix(p,q) ==
    -- This function computes the Bezout matrix for 'p' and 'q'.
    -- See Knuth, The Art of Computer Programming, Vol. 2, p. 619, # 12.
    -- One must have deg(p) >= deg(q), so the arguments are reversed
    -- if this is not the case.
      n1 := degree p; n2 := degree q; n := n1 + n2
      n1 < n2 => bezoutMatrix(q,p)
      m1 : I := n1 - 1; m2 : I := n2 - 1; m : I := n - 1
      -- 'sylmat' will be a matrix consisting of the first n1 columns
      -- of the standard Sylvester matrix for 'p' and 'q'
      sylmat : M := new(n,n1,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not ground? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        -- for i = 0...
        -- quit when i > m2 or when i + (n1 - k) > m1, whichever happens first
        for i in 0..min(m2,deg - 1) repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        -- put ak = coef(q,k) in sylmat(minR + n1 + i,minC + i + (n2 - k))
        -- for i = 0...
        -- quit when i > m1 or when i + (n2 - k) > m1, whichever happens first
        -- since n2 - k >= 0, we quit when i + (n2 - k) > m1
        for i in 0..(deg + n1 - n2 - 1) repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      -- 'bezmat' will be the 'Bezout matrix' as described in Knuth
      bezmat : M := new(n1,n1,0)
      for i in 0..m2 repeat
        -- replace A_i by (b_0 A_i + ... + b_{n_2-1-i} A_{n_2 - 1}) -
        -- (a_0 B_i + ... + a_{n_2-1-i} B_{n_2-1}), as in Knuth
        bound : I := n2 - i; q0 := q
        while not zero? q0 repeat
          deg := degree q0
          if (deg < bound) then
            -- add b_deg A_{n_2 - deg} to the new A_i
            coef := lc q0
            for k in minC..maxC repeat
              c := coef * qelt(sylmat,minR + m2 - i - deg,k) +
                          qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          q0 := reductum q0
        p0 := p
        while not zero? p0 repeat
          deg := degree p0
          if deg < bound then
            coef := lc p0
            -- subtract a_deg B_{n_2 - deg} from the new A_i
            for k in minC..maxC repeat
              c := -coef * qelt(sylmat,minR + m - i - deg,k) +
                           qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          p0 := reductum p0
      for i in n2..m1 repeat for k in minC..maxC repeat
        qsetelt_!(bezmat,minR + i,k,qelt(sylmat,minR + i,k))
      bezmat

    if R has commutative("*") then

      bezoutResultant(f,g) == determinant bezoutMatrix(f,g)

      if R has IntegralDomain then

        bezoutDiscriminant f ==
          degMod4 := (degree f) rem 4
          (degMod4 = 0) or (degMod4 = 1) =>
            (bezoutResultant(f,differentiate f) exquo (lc f)) :: R
          -((bezoutResultant(f,differentiate f) exquo (lc f)) :: R)

        else

          bezoutDiscriminant f ==
            lc f = 1 =>
              degMod4 := (degree f) rem 4
              (degMod4 = 0) or (degMod4 = 1) =>
                bezoutResultant(f,differentiate f)
              -bezoutResultant(f,differentiate f)
            error "bezoutDiscriminant: leading coefficient must be 1"

@
<<BEZOUT.dotabb>>=
"BEZOUT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BEZOUT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BEZOUT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BRILL BrillhartTests}
\pagehead{BrillhartTests}{BRILL}
\pagepic{ps/v104brillharttests.ps}{BRILL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BRILL BrillhartTests>>=
)abbrev package BRILL BrillhartTests
++ Author: Frederic Lehobey, James H. Davenport
++ Date Created: 28 June 1994
++ Date Last Updated: 11 July 1997
++ Basic Operations: brillhartIrreducible?
++ Related Domains: 
++ Also See:
++ AMS Classifications:
++ Keywords: factorization
++ Examples:
++ References:
++ [1] John Brillhart, Note on Irreducibility Testing,
++ Mathematics of Computation, vol. 35, num. 35, Oct. 1980, 1379-1381
++ [2] James Davenport, On Brillhart Irreducibility. To appear.
++ [3] John Brillhart, On the Euler and Bernoulli polynomials,
++ J. Reine Angew. Math., v. 234, (1969), pp. 45-64

BrillhartTests(UP): Exports == Implementation where
  N ==> NonNegativeInteger
  Z ==> Integer
  UP: UnivariatePolynomialCategory Z

  Exports ==> with
    brillhartIrreducible?: UP -> Boolean -- See [1]
      ++ brillhartIrreducible?(p) returns \spad{true} if p can be shown to be
      ++ irreducible by a remark of Brillhart, \spad{false} is inconclusive.
    brillhartIrreducible?: (UP,Boolean) -> Boolean -- See [1]
      ++ brillhartIrreducible?(p,noLinears) returns \spad{true} if p can be 
      ++ shown to be irreducible by a remark of Brillhart, \spad{false} else.
      ++ If noLinears is \spad{true}, we are being told p has no linear factors
      ++ \spad{false} does not mean that p is reducible.
    brillhartTrials: () -> N
      ++ brillhartTrials() returns the number of tests in
      ++ \spadfun{brillhartIrreducible?}.
    brillhartTrials: N -> N
      ++ brillhartTrials(n) sets to n the number of tests in 
      ++ \spadfun{brillhartIrreducible?} and returns the previous value.
    noLinearFactor?: UP -> Boolean -- See [3] p. 47
      ++ noLinearFactor?(p) returns \spad{true} if p can be shown to have no
      ++ linear factor by a theorem of Lehmer, \spad{false} else. I insist on
      ++ the fact that \spad{false} does not mean that p has a linear factor.

  Implementation ==> add

    import GaloisGroupFactorizationUtilities(Z,UP,Float)

    squaredPolynomial(p:UP):Boolean ==
      d := degree p
      d = 0 => true
      odd? d => false
      squaredPolynomial reductum p

    primeEnough?(n:Z,b:Z):Boolean ==
       -- checks if n is prime, with the possible exception of 
       -- factors whose product is at most b
       import Float
       bb: Float := b::Float
       for i in 2..b repeat
           while (d:= n exquo i) case Integer repeat
                 n:=d::Integer
                 bb:=bb / i::Float
                 bb < 1$Float => return false
                 --- we over-divided, so it can't be prime
       prime? n

    brillharttrials: N := 6
    brillhartTrials():N == brillharttrials

    brillhartTrials(n:N):N ==
      (brillharttrials,n) := (n,brillharttrials)
      n

    brillhartIrreducible?(p:UP):Boolean ==
      brillhartIrreducible?(p,noLinearFactor? p)

    brillhartIrreducible?(p:UP,noLinears:Boolean):Boolean == -- See [1]
      zero? brillharttrials => false
      origBound := (largeEnough := rootBound(p)+1)
      -- see remarks 2 and 4
      even0 := even? coefficient(p,0)
      even1 := even? p(1)
      polyx2 := squaredPolynomial(p)
      prime? p(largeEnough) => true
      not polyx2 and prime? p(-largeEnough) => true
--      one? brillharttrials => false
      (brillharttrials = 1) => false
      largeEnough := largeEnough+1
      primeEnough?(p(largeEnough),if noLinears then 4 else 2) => true
      not polyx2 and
       primeEnough?(p(-largeEnough),if noLinears then 4 else 2) => true
      if odd? largeEnough then 
        if even0 then largeEnough := largeEnough+1
      else 
        if even1 then largeEnough := largeEnough+1
      count :=(if polyx2 then 2 else 1)*(brillharttrials-2)+largeEnough
      for i in (largeEnough+1)..count repeat
        small := if noLinears then (i-origBound)**2 else (i-origBound)
        primeEnough?(p(i),small) => return true
        not polyx2 and primeEnough?(p(-i),small) => return true
      false

    noLinearFactor?(p:UP):Boolean ==
      (odd? leadingCoefficient p) and (odd? coefficient(p,0)) and (odd? p(1)) 

@
<<BRILL.dotabb>>=
"BRILL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BRILL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BRILL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter C}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CARTEN2 CartesianTensorFunctions2}
\pagehead{CartesianTensorFunctions2}{CARTEN2}
\pagepic{ps/v104cartesiantensorfunctions2.ps}{CARTEN2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CARTEN2 CartesianTensorFunctions2>>=
)abbrev package CARTEN2 CartesianTensorFunctions2
++ Author: Stephen M. Watt
++ Date Created: December 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations:  reshape, map
++ Related Domains: CartesianTensor
++ Also See:
++ AMS Classifications:
++ Keywords: tensor
++ Examples:
++ References:
++ Description:
++   This package provides functions to enable conversion of tensors
++   given conversion of the components.

CartesianTensorFunctions2(minix, dim, S, T): CTPcat == CTPdef where
    minix:  Integer
    dim:    NonNegativeInteger
    S, T:   CommutativeRing
    CS  ==> CartesianTensor(minix, dim, S)
    CT  ==> CartesianTensor(minix, dim, T)

    CTPcat == with
        reshape: (List T, CS) -> CT
            ++ reshape(lt,ts) organizes the list of components lt into
            ++ a tensor with the same shape as ts.
        map: (S->T,   CS) -> CT
            ++ map(f,ts) does a componentwise conversion of the tensor ts
            ++ to a tensor with components of type T.
    CTPdef == add
        reshape(l, s) == unravel l
        map(f, s)     == unravel [f e for e in ravel s]

@
<<CARTEN2.dotabb>>=
"CARTEN2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CARTEN2"]
"BMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BMODULE"]
"CARTEN2" -> "BMODULE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CHVAR ChangeOfVariable}
\pagehead{ChangeOfVariable}{CHVAR}
\pagepic{ps/v104changeofvariable.ps}{CHVAR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CHVAR ChangeOfVariable>>=
)abbrev package CHVAR ChangeOfVariable
++ Sends a point to infinity
++ Author: Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 22 Feb 1990
++ Description:
++  Tools to send a point to infinity on an algebraic curve.
ChangeOfVariable(F, UP, UPUP): Exports == Implementation where
  F   : UniqueFactorizationDomain
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP

  N  ==> NonNegativeInteger
  Z  ==> Integer
  Q  ==> Fraction Z
  RF ==> Fraction UP

  Exports ==> with
    mkIntegral: UPUP -> Record(coef:RF, poly:UPUP)
          ++ mkIntegral(p(x,y)) returns \spad{[c(x), q(x,z)]} such that
          ++ \spad{z = c * y} is integral.
          ++ The algebraic relation between x and y is \spad{p(x, y) = 0}.
          ++ The algebraic relation between x and z is \spad{q(x, z) = 0}.
    radPoly   : UPUP -> Union(Record(radicand:RF, deg:N), "failed")
          ++ radPoly(p(x, y)) returns \spad{[c(x), n]} if p is of the form
          ++ \spad{y**n - c(x)}, "failed" otherwise.
    rootPoly  : (RF, N) -> Record(exponent: N, coef:RF, radicand:UP)
          ++ rootPoly(g, n) returns \spad{[m, c, P]} such that
          ++ \spad{c * g ** (1/n) = P ** (1/m)}
          ++ thus if \spad{y**n = g}, then \spad{z**m = P}
          ++ where \spad{z = c * y}.
    goodPoint : (UPUP,UPUP) -> F
          ++ goodPoint(p, q) returns an integer a such that a is neither
          ++ a pole of \spad{p(x,y)} nor a branch point of \spad{q(x,y) = 0}.
    eval      : (UPUP, RF, RF) -> UPUP
          ++ eval(p(x,y), f(x), g(x)) returns \spad{p(f(x), y * g(x))}.
    chvar : (UPUP,UPUP) -> Record(func:UPUP,poly:UPUP,c1:RF,c2:RF,deg:N)
          ++ chvar(f(x,y), p(x,y)) returns
          ++ \spad{[g(z,t), q(z,t), c1(z), c2(z), n]}
          ++ such that under the change of variable
          ++ \spad{x = c1(z)}, \spad{y = t * c2(z)},
          ++ one gets \spad{f(x,y) = g(z,t)}.
          ++ The algebraic relation between x and y is \spad{p(x, y) = 0}.
          ++ The algebraic relation between z and t is \spad{q(z, t) = 0}.

  Implementation ==> add
    import UnivariatePolynomialCommonDenominator(UP, RF, UPUP)

    algPoly     : UPUP           -> Record(coef:RF, poly:UPUP)
    RPrim       : (UP, UP, UPUP) -> Record(coef:RF, poly:UPUP)
    good?       : (F, UP, UP)    -> Boolean
    infIntegral?: (UPUP, UPUP)   -> Boolean

    eval(p, x, y)  == map(#1 x, p)  monomial(y, 1)
    good?(a, p, q) == p(a) ^= 0 and q(a) ^= 0

    algPoly p ==
      ground?(a:= retract(leadingCoefficient(q:=clearDenominator p))@UP)
        => RPrim(1, a, q)
      c := d := squareFreePart a
      q := clearDenominator q monomial(inv(d::RF), 1)
      while not ground?(a := retract(leadingCoefficient q)@UP) repeat
        c := c * (d := gcd(a, d))
        q := clearDenominator q monomial(inv(d::RF), 1)
      RPrim(c, a, q)

    RPrim(c, a, q) ==
--      one? a => [c::RF, q]
      (a = 1) => [c::RF, q]
      [(a * c)::RF, clearDenominator q monomial(inv(a::RF), 1)]

-- always makes the algebraic integral, but does not send a point to infinity
-- if the integrand does not have a pole there (in the case of an nth-root)
    chvar(f, modulus) ==
      r1 := mkIntegral modulus
      f1 := f monomial(r1inv := inv(r1.coef), 1)
      infIntegral?(f1, r1.poly) =>
        [f1, r1.poly, monomial(1,1)$UP :: RF,r1inv,degree(retract(r1.coef)@UP)]
      x  := (a:= goodPoint(f1,r1.poly))::UP::RF + inv(monomial(1,1)::RF)
      r2c:= retract((r2 := mkIntegral map(#1 x, r1.poly)).coef)@UP
      t  := inv((monomial(1, 1)$UP - a::UP)::RF)
      [- inv(monomial(1, 2)$UP :: RF) * eval(f1, x, inv(r2.coef)),
                                r2.poly, t, r1.coef * r2c t, degree r2c]

-- returns true if y is an n-th root, and it can be guaranteed that p(x,y)dx
-- is integral at infinity
-- expects y to be integral.
    infIntegral?(p, modulus) ==
      (r := radPoly modulus) case "failed" => false
      ninv := inv(r.deg::Q)
      degy:Q := degree(retract(r.radicand)@UP) * ninv
      degp:Q := 0
      while p ^= 0 repeat
        c := leadingCoefficient p
        degp := max(degp,
            (2 + degree(numer c)::Z - degree(denom c)::Z)::Q + degree(p) * degy)
        p := reductum p
      degp <= ninv

    mkIntegral p ==
      (r := radPoly p) case "failed" => algPoly p
      rp := rootPoly(r.radicand, r.deg)
      [rp.coef, monomial(1, rp.exponent)$UPUP - rp.radicand::RF::UPUP]

    goodPoint(p, modulus) ==
      q :=
        (r := radPoly modulus) case "failed" =>
                   retract(resultant(modulus, differentiate modulus))@UP
        retract(r.radicand)@UP
      d := commonDenominator p
      for i in 0.. repeat
        good?(a := i::F, q, d) => return a
        good?(-a, q, d)        => return -a

    radPoly p ==
      (r := retractIfCan(reductum p)@Union(RF, "failed")) case "failed"
        => "failed"
      [- (r::RF), degree p]

-- we have y**m = g(x) = n(x)/d(x), so if we can write
-- (n(x) * d(x)**(m-1)) ** (1/m)  =  c(x) * P(x) ** (1/n)
-- then z**q = P(x) where z = (d(x) / c(x)) * y
    rootPoly(g, m) ==
      zero? g => error "Should not happen"
      pr := nthRoot(squareFree((numer g) * (d := denom g) ** (m-1)::N),
                                                m)$FactoredFunctions(UP)
      [pr.exponent, d / pr.coef, */(pr.radicand)]

@
<<CHVAR.dotabb>>=
"CHVAR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CHVAR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CHVAR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CPIMA CharacteristicPolynomialInMonogenicalAlgebra}
\pagehead{CharacteristicPolynomialInMonogenicalAlgebra}{CPIMA}
\pagepic{ps/v104characteristicpolynomialinmonogenicalalgebra.ps}{CPIMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>=
)abbrev package CPIMA CharacteristicPolynomialInMonogenicalAlgebra
++ Author: Claude Quitte
++ Date Created: 10/12/93
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package implements characteristicPolynomials for monogenic algebras
++ using resultants
CharacteristicPolynomialInMonogenicalAlgebra(R : CommutativeRing,
    PolR : UnivariatePolynomialCategory(R),
    E : MonogenicAlgebra(R, PolR)): with
     characteristicPolynomial : E -> PolR
	++ characteristicPolynomial(e) returns the characteristic polynomial 
	++ of e using resultants

  == add
    Pol ==> SparseUnivariatePolynomial

    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, Pol(PolR))
    XtoY(Q : PolR) : Pol(PolR) == map(monomial(#1, 0), Q)

    P : Pol(PolR) := XtoY(definingPolynomial()$E)
    X : Pol(PolR) := monomial(monomial(1, 1)$PolR, 0)

    characteristicPolynomial(x : E) : PolR ==
       Qx : PolR := lift(x)
       -- on utilise le fait que resultant_Y (P(Y), X - Qx(Y))
       return resultant(P, X - XtoY(Qx))

@
<<CPIMA.dotabb>>=
"CPIMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CPIMA"]
"MONOGEN" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MONOGEN"]
"CPIMA" -> "MONOGEN"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CHARPOL CharacteristicPolynomialPackage}
\pagehead{CharacteristicPolynomialPackage}{CHARPOL}
\pagepic{ps/v104characteristicpolynomialpackage.ps}{CHARPOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CHARPOL CharacteristicPolynomialPackage>>=
)abbrev package CHARPOL CharacteristicPolynomialPackage
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides a characteristicPolynomial function
++ for any matrix over a commutative ring.

CharacteristicPolynomialPackage(R:CommutativeRing):C == T where
   PI ==> PositiveInteger
   M ==> Matrix R
   C == with
      characteristicPolynomial: (M, R) -> R
        ++ characteristicPolynomial(m,r) computes the characteristic
        ++ polynomial of the matrix m evaluated at the point r.
        ++ In particular, if r is the polynomial 'x, then it returns
        ++ the characteristic polynomial expressed as a polynomial in 'x.
   T == add

           ---- characteristic polynomial  ----
     characteristicPolynomial(A:M,v:R) : R ==
       dimA :PI := (nrows A):PI
       dimA ^= ncols A => error " The matrix is not square"
       B:M:=zero(dimA,dimA)
       for i in 1..dimA repeat
         for j in 1..dimA repeat  B(i,j):=A(i,j)
         B(i,i) := B(i,i) - v
       determinant B

@
<<CHARPOL.dotabb>>=
"CHARPOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CHARPOL"]
"BMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BMODULE"]
"CHARPOL" -> "BMODULE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMBF CombinatorialFunction}
\pagehead{CombinatorialFunction}{COMBF}
\pagepic{ps/v104combinatorialfunction.ps}{COMBF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMBF CombinatorialFunction>>=
)abbrev package COMBF CombinatorialFunction
++ Provides the usual combinatorial functions
++ Author: Manuel Bronstein, Martin Rubey
++ Date Created: 2 Aug 1988
++ Date Last Updated: 30 October 2005
++ Description:
++   Provides combinatorial functions over an integral domain.
++ Keywords: combinatorial, function, factorial.
++ Examples:  )r COMBF INPUT

CombinatorialFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  OP  ==> BasicOperator
  K   ==> Kernel F
  SE  ==> Symbol
  O   ==> OutputForm
  SMP ==> SparseMultivariatePolynomial(R, K)
  Z   ==> Integer

  POWER        ==> "%power"::Symbol
  OPEXP        ==> "exp"::Symbol
  SPECIALDIFF  ==> "%specialDiff"
  SPECIALDISP  ==> "%specialDisp"
  SPECIALEQUAL ==> "%specialEqual"

  Exports ==> with
    belong?    : OP -> Boolean
      ++ belong?(op) is true if op is a combinatorial operator;
    operator   : OP -> OP
      ++ operator(op) returns a copy of op with the domain-dependent
      ++ properties appropriate for F;
      ++ error if op is not a combinatorial operator;
    "**"       : (F, F) -> F
      ++ a ** b is the formal exponential a**b;
    binomial   : (F, F) -> F
      ++ binomial(n, r) returns the number of subsets of r objects
      ++ taken among n objects, i.e. n!/(r! * (n-r)!);
@

We currently simplify binomial coefficients only for non-negative integral
second argument, using the formula
$$ \binom{n}{k}=\frac{1}{k!}\prod_{i=0..k-1} (n-i),$$
except if the second argument is symbolic: in this case [[binomial(n,n)]] is
simplified to one.
 
Note that there are at least two different ways to define binomial coefficients
for negative integral second argument. One way, particular suitable for
combinatorics, is to set the binomial coefficient equal to zero for negative
second argument. This is, partially, also the approach taken in
[[combinat.spad]], where we find

\begin{verbatim}
   binomial(n, m) ==
      n < 0 or m < 0 or m > n => 0
      m = 0 => 1
\end{verbatim}

Of course, here [[n]] and [[m]] are integers. This definition agrees with the
recurrence

$$\binom{n}{k}+\binom{n}{k+1}=\binom{n+1}{k+1}.$$

Alternatively, one can use the formula
$$ \binom{n}{k}=\frac{\Gamma(n+1)}{\Gamma(k+1)\Gamma(n-k+1)}, $$
and leave the case where $k\in {\bf Z}$, $n\in {\bf Z}$ and $k \leq n < 0$
undefined, since the limit does not exist in this case:

Since we then have that $n-k+1\geq 1$, $\Gamma(n-k+1)$ is finite. So it is
sufficient to consider $\frac{\Gamma(n+1)}{\Gamma(k+1)}$. On the one hand, we
have
$$\lim_{n_0\to n} \lim_{k_0\to k}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)} = 0,$$
since for any non-integral $n_0$, $\Gamma(n_0+1)$ is finite. On the other
hand,
$$\lim_{k_0\to k} \lim_{n_0\to n}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)}$$
does not exist, since for non-integral $k_0$, $\Gamma(k_0+1)$ is finite while
$\Gamma(n_0+1)$ is unbounded.

However, since for $k\in {\bf Z}$, $n\in {\bf Z}$ and $0 < k < n$ both
definitions agree, one could also combine them. This is what, for example,
Mathematica does. It seems that MuPAD sets [[binomial(n,n)=1]] for all
arguments [[n]], and returns [[binomial(-2, n)]] unevaluated. Provisos may help
here.

<<package COMBF CombinatorialFunction>>=
    permutation: (F, F) -> F
      ++ permutation(n, r) returns the number of permutations of
      ++ n objects taken r at a time, i.e. n!/(n-r)!;
    factorial  : F -> F
      ++ factorial(n) returns the factorial of n, i.e. n!;
    factorials : F -> F
      ++ factorials(f) rewrites the permutations and binomials in f
      ++ in terms of factorials;
    factorials : (F, SE) -> F
      ++ factorials(f, x) rewrites the permutations and binomials in f
      ++ involving x in terms of factorials;
    summation  : (F, SE) -> F
      ++ summation(f(n), n) returns the formal sum S(n) which verifies
      ++ S(n+1) - S(n) = f(n);
    summation  : (F, SegmentBinding F)  -> F
      ++ summation(f(n), n = a..b) returns f(a) + ... + f(b) as a
      ++ formal sum;
    product    : (F, SE) -> F
      ++ product(f(n), n) returns the formal product P(n) which verifies
      ++ P(n+1)/P(n) = f(n);
    product    : (F, SegmentBinding  F) -> F
      ++ product(f(n), n = a..b) returns f(a) * ... * f(b) as a
      ++ formal product;
    iifact     : F -> F
      ++ iifact(x) should be local but conditional;
    iibinom    : List F -> F
      ++ iibinom(l) should be local but conditional;
    iiperm     : List F -> F
      ++ iiperm(l) should be local but conditional;
    iipow      : List F -> F
      ++ iipow(l) should be local but conditional;
    iidsum     : List F -> F
      ++ iidsum(l) should be local but conditional;
    iidprod    : List F -> F
      ++ iidprod(l) should be local but conditional;
    ipow       : List F -> F
      ++ ipow(l) should be local but conditional;

  Implementation ==> add
    ifact     : F -> F
    iiipow    : List F -> F
    iperm     : List F -> F
    ibinom    : List F -> F
    isum      : List F -> F
    idsum     : List F -> F
    iprod     : List F -> F
    idprod    : List F -> F
    dsum      : List F -> O
    ddsum     : List F -> O
    dprod     : List F -> O
    ddprod    : List F -> O
    equalsumprod  : (K, K) -> Boolean 
    equaldsumprod : (K, K) -> Boolean 
    fourth    : List F -> F
    dvpow1    : List F -> F
    dvpow2    : List F -> F
    summand   : List F -> F
    dvsum     : (List F, SE) -> F
    dvdsum    : (List F, SE) -> F
    dvprod    : (List F, SE) -> F
    dvdprod   : (List F, SE) -> F
    facts     : (F, List SE) -> F
    K2fact    : (K, List SE) -> F
    smpfact   : (SMP, List SE) -> F

    dummy == new()$SE :: F
@
This macro will be used in [[product]] and [[summation]], both the $5$ and $3$
argument forms. It is used to introduce a dummy variable in place of the
summation index within the summands. This in turn is necessary to keep the
indexing variable local, circumventing problems, for example, with
differentiation.

This works if we don't accidently use such a symbol as a bound of summation or
product.

Note that up to [[patch--25]] this used to read
\begin{verbatim}
    dummy := new()$SE :: F
\end{verbatim}
thus introducing the same dummy variable for all products and summations, which
caused nested products and summations to fail. (Issue~\#72)

<<package COMBF CombinatorialFunction>>=
    opfact  := operator("factorial"::Symbol)$CommonOperators
    opperm  := operator("permutation"::Symbol)$CommonOperators
    opbinom := operator("binomial"::Symbol)$CommonOperators
    opsum   := operator("summation"::Symbol)$CommonOperators
    opdsum  := operator("%defsum"::Symbol)$CommonOperators
    opprod  := operator("product"::Symbol)$CommonOperators
    opdprod := operator("%defprod"::Symbol)$CommonOperators
    oppow   := operator(POWER::Symbol)$CommonOperators

    factorial x          == opfact x
    binomial(x, y)       == opbinom [x, y]
    permutation(x, y)    == opperm [x, y]

    import F
    import Kernel F

    number?(x:F):Boolean ==
      if R has RetractableTo(Z) then
        ground?(x) or
         ((retractIfCan(x)@Union(Fraction(Z),"failed")) case Fraction(Z))
      else
        ground?(x)

    x ** y               == 
      -- Do some basic simplifications
      is?(x,POWER) =>
        args : List F := argument first kernels x
        not(#args = 2) => error "Too many arguments to **"
        number?(first args) and number?(y) =>
          oppow [first(args)**y, second args]
        oppow [first args, (second args)* y]
      -- Generic case
      exp : Union(Record(val:F,exponent:Z),"failed") := isPower x
      exp case Record(val:F,exponent:Z) =>
        expr := exp::Record(val:F,exponent:Z)
        oppow [expr.val, (expr.exponent)*y]
      oppow [x, y]

    belong? op           == has?(op, "comb")
    fourth l             == third rest l
    dvpow1 l             == second(l) * first(l) ** (second l - 1)
    factorials x         == facts(x, variables x)
    factorials(x, v)     == facts(x, [v])
    facts(x, l)          == smpfact(numer x, l) / smpfact(denom x, l)
    summand l            == eval(first l, retract(second l)@K, third l)

    product(x:F, i:SE) ==
      dm := dummy
      opprod [eval(x, k := kernel(i)$K, dm), dm, k::F]

    summation(x:F, i:SE) ==
      dm := dummy
      opsum [eval(x, k := kernel(i)$K, dm), dm, k::F]

@
These two operations return the product or the sum as unevaluated operators. A
dummy variable is introduced to make the indexing variable \lq local\rq.

<<package COMBF CombinatorialFunction>>=
    dvsum(l, x) ==
      opsum [differentiate(first l, x), second l, third l]

    dvdsum(l, x) ==
      x = retract(y := third l)@SE => 0
      if member?(x, variables(h := third rest rest l)) or 
         member?(x, variables(g := third rest l)) then
        error "a sum cannot be differentiated with respect to a bound"
      else
        opdsum [differentiate(first l, x), second l, y, g, h]

@
The above two operations implement differentiation of sums with and without
bounds. Note that the function
$$n\mapsto\sum_{k=1}^n f(k,n)$$
is well defined only for integral values of $n$ greater than or equal to zero.
There is not even consensus how to define this function for $n<0$. Thus, it is
not differentiable. Therefore, we need to check whether we erroneously are
differentiating with respect to the upper bound or the lower bound, where the
same reasoning holds.

Differentiating a sum with respect to its indexing variable correctly gives
zero. This is due to the introduction of dummy variables in the internal
representation of a sum: the operator [[%defsum]] takes 5 arguments, namely

\begin{enumerate}
\item the summands, where each occurrence of the indexing variable is replaced
  by 
\item the dummy variable,
\item the indexing variable,
\item the lower bound, and
\item the upper bound.
\end{enumerate}

Note that up to [[patch--40]] the following incorrect code was used, which 
tried to parallel the known rules for integration: (Issue~\#180)

\begin{verbatim}
    dvdsum(l, x) ==
      x = retract(y := third l)@SE => 0
      k := retract(d := second l)@K
      differentiate(h := third rest rest l,x) * eval(f := first l, k, h)
        - differentiate(g := third rest l, x) * eval(f, k, g)
             + opdsum [differentiate(f, x), d, y, g, h]
\end{verbatim}

Up to [[patch--45]] a similar mistake could be found in the code for
differentiation of formal sums, which read
\begin{verbatim}
    dvsum(l, x) ==
      k  := retract(second l)@K
      differentiate(third l, x) * summand l
          + opsum [differentiate(first l, x), second l, third l]
\end{verbatim}

<<package COMBF CombinatorialFunction>>=
    dvprod(l, x) ==
      dm := retract(dummy)@SE
      f := eval(first l, retract(second l)@K, dm::F)
      p := product(f, dm)

      opsum [differentiate(first l, x)/first l * p, second l, third l]


    dvdprod(l, x) ==
      x = retract(y := third l)@SE => 0
      if member?(x, variables(h := third rest rest l)) or 
         member?(x, variables(g := third rest l)) then
        error "a product cannot be differentiated with respect to a bound"
      else
        opdsum cons(differentiate(first l, x)/first l, rest l) * opdprod l 

@ 
The above two operations implement differentiation of products with and without
bounds. Note again, that we cannot even properly define products with bounds
that are not integral.

To differentiate the product, we use Leibniz rule:
$$\frac{d}{dx}\prod_{i=a}^b f(i,x) = 
  \sum_{i=a}^b \frac{\frac{d}{dx} f(i,x)}{f(i,x)}\prod_{i=a}^b f(i,x)
$$

There is one situation where this definition might produce wrong results,
namely when the product is zero, but axiom failed to recognize it: in this
case,
$$
  \frac{d}{dx} f(i,x)/f(i,x)  
$$
is undefined for some $i$. However, I was not able to come up with an
example. The alternative definition
$$
  \frac{d}{dx}\prod_{i=a}^b f(i,x) = 
  \sum_{i=a}^b \left(\frac{d}{dx} f(i,x)\right)\prod_{j=a,j\neq i}^b f(j,x)
$$
has the slight (display) problem that we would have to come up with a new index
variable, which looks very ugly. Furthermore, it seems to me that more
simplifications will occur with the first definition.

<<TEST COMBF>>=
  f := operator 'f
  D(product(f(i,x),i=1..m),x)
@

Note that up to [[patch--45]] these functions did not exist and products were
differentiated according to the usual chain rule, which gave incorrect
results. (Issue~\#211)

<<package COMBF CombinatorialFunction>>=
    dprod l ==
      prod(summand(l)::O, third(l)::O)

    ddprod l ==
      prod(summand(l)::O, third(l)::O = fourth(l)::O, fourth(rest l)::O)

    dsum l ==
      sum(summand(l)::O, third(l)::O)

    ddsum l ==
      sum(summand(l)::O, third(l)::O = fourth(l)::O, fourth(rest l)::O)

@ 
These four operations handle the conversion of sums and products to
[[OutputForm]]. Note that up to [[patch--45]] the definitions for sums and
products without bounds were missing and output was illegible.

<<package COMBF CombinatorialFunction>>=
    equalsumprod(s1, s2) ==
      l1 := argument s1
      l2 := argument s2

      (eval(first l1, retract(second l1)@K, second l2) = first l2)

    equaldsumprod(s1, s2) ==
      l1 := argument s1
      l2 := argument s2

      ((third rest l1 = third rest l2) and
       (third rest rest l1 = third rest rest l2) and
       (eval(first l1, retract(second l1)@K, second l2) = first l2))

@ 
The preceding two operations handle the testing for equality of sums and
products. This functionality was missing up to [[patch--45]]. (Issue~\#213) The
corresponding property [[%specialEqual]] set below is checked in
[[Kernel]]. Note that we can assume that the operators are equal, since this is
checked in [[Kernel]] itself.
<<package COMBF CombinatorialFunction>>=
    product(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)$K
      dm := dummy
      opdprod [eval(x,k,dm), dm, k::F, lo segment s, hi segment s]

    summation(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)$K
      dm := dummy
      opdsum [eval(x,k,dm), dm, k::F, lo segment s, hi segment s]

@
These two operations return the product or the sum as unevaluated operators. A
dummy variable is introduced to make the indexing variable \lq local\rq.

<<package COMBF CombinatorialFunction>>=
    smpfact(p, l) ==
      map(K2fact(#1, l), #1::F, p)$PolynomialCategoryLifting(
        IndexedExponents K, K, R, SMP, F)

    K2fact(k, l) ==
      empty? [v for v in variables(kf := k::F) | member?(v, l)] => kf
      empty?(args:List F := [facts(a, l) for a in argument k]) => kf
      is?(k, opperm) =>
        factorial(n := first args) / factorial(n - second args)
      is?(k, opbinom) =>
        n := first args
        p := second args
        factorial(n) / (factorial(p) * factorial(n-p))
      (operator k) args

    operator op ==
      is?(op, "factorial"::Symbol)   => opfact
      is?(op, "permutation"::Symbol) => opperm
      is?(op, "binomial"::Symbol)    => opbinom
      is?(op, "summation"::Symbol)   => opsum
      is?(op, "%defsum"::Symbol)     => opdsum
      is?(op, "product"::Symbol)     => opprod
      is?(op, "%defprod"::Symbol)    => opdprod
      is?(op, POWER)                 => oppow
      error "Not a combinatorial operator"

    iprod l ==
      zero? first l => 0
--      one? first l => 1
      (first l = 1) => 1
      kernel(opprod, l)

    isum l ==
      zero? first l => 0
      kernel(opsum, l)

    idprod l ==
      member?(retract(second l)@SE, variables first l) =>
        kernel(opdprod, l)
      first(l) ** (fourth rest l - fourth l + 1)

    idsum l ==
      member?(retract(second l)@SE, variables first l) =>
        kernel(opdsum, l)
      first(l) * (fourth rest l - fourth l + 1)

    ifact x ==
--      zero? x or one? x => 1
      zero? x or (x = 1) => 1
      kernel(opfact, x)

    ibinom l ==
      n := first l
      ((p := second l) = 0) or (p = n) => 1
--      one? p or (p = n - 1) => n
      (p = 1) or (p = n - 1) => n
      kernel(opbinom, l)

    iperm l ==
      zero? second l => 1
      kernel(opperm, l)

    if R has RetractableTo Z then
      iidsum l ==
        (r1:=retractIfCan(fourth l)@Union(Z,"failed"))
         case "failed" or
          (r2:=retractIfCan(fourth rest l)@Union(Z,"failed"))
            case "failed" or
             (k:=retractIfCan(second l)@Union(K,"failed")) case "failed"
               => idsum l
        +/[eval(first l,k::K,i::F) for i in r1::Z .. r2::Z]

      iidprod l ==
        (r1:=retractIfCan(fourth l)@Union(Z,"failed"))
         case "failed" or
          (r2:=retractIfCan(fourth rest l)@Union(Z,"failed"))
            case "failed" or
             (k:=retractIfCan(second l)@Union(K,"failed")) case "failed"
               => idprod l
        */[eval(first l,k::K,i::F) for i in r1::Z .. r2::Z]

      iiipow l ==
          (u := isExpt(x := first l, OPEXP)) case "failed" => kernel(oppow, l)
          rec := u::Record(var: K, exponent: Z)
          y := first argument(rec.var)
          (r := retractIfCan(y)@Union(Fraction Z, "failed")) case
              "failed" => kernel(oppow, l)
          (operator(rec.var)) (rec.exponent * y * second l)

      if F has RadicalCategory then
        ipow l ==
          (r := retractIfCan(second l)@Union(Fraction Z,"failed"))
            case "failed" => iiipow l
          first(l) ** (r::Fraction(Z))
      else
        ipow l ==
          (r := retractIfCan(second l)@Union(Z, "failed"))
            case "failed" => iiipow l
          first(l) ** (r::Z)

    else
      ipow l ==
        zero?(x := first l) =>
          zero? second l => error "0 ** 0"
          0
--        one? x or zero?(n := second l) => 1
        (x = 1) or zero?(n: F := second l) => 1
--        one? n => x
        (n = 1) => x
        (u := isExpt(x, OPEXP)) case "failed" => kernel(oppow, l)
        rec := u::Record(var: K, exponent: Z)
--        one?(y := first argument(rec.var)) or y = -1 =>
        ((y := first argument(rec.var))=1) or y = -1 =>
            (operator(rec.var)) (rec.exponent * y * n)
        kernel(oppow, l)

    if R has CombinatorialFunctionCategory then
      iifact x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => ifact x
        factorial(r::R)::F

      iiperm l ==
        (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
          (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
            => iperm l
        permutation(r1::R, r2::R)::F

      if R has RetractableTo(Z) and F has Algebra(Fraction(Z)) then
         iibinom l ==
           (s:=retractIfCan(second l)@Union(R,"failed")) case R and
              (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
                ans:=1::F
                for i in 0..t-1 repeat
                    ans:=ans*(first l - i::R::F)
                (1/factorial t) * ans
           (s:=retractIfCan(first l-second l)@Union(R,"failed")) case R and
             (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
                ans:=1::F
                for i in 1..t repeat
                    ans:=ans*(second l+i::R::F)
                (1/factorial t) * ans
           (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
             (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
               => ibinom l
           binomial(r1::R, r2::R)::F

@

[[iibinom]] checks those cases in which the binomial coefficient may be
evaluated explicitly. Note that up to [[patch--51]], the case where the second
argument is a positive integer was not checked.(Issue~\#336) Currently, the
naive iterative algorithm is used to calculate the coefficient, there is room
for improvement here.

<<package COMBF CombinatorialFunction>>=

      else
         iibinom l ==
           (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
             (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
               => ibinom l
           binomial(r1::R, r2::R)::F

    else
      iifact x  == ifact x
      iibinom l == ibinom l
      iiperm l  == iperm l

    if R has ElementaryFunctionCategory then
      iipow l ==
        (r1:=retractIfCan(first l)@Union(R,"failed")) case "failed" or
          (r2:=retractIfCan(second l)@Union(R,"failed")) case "failed"
            => ipow l
        (r1::R ** r2::R)::F
    else
      iipow l == ipow l

    if F has ElementaryFunctionCategory then
      dvpow2 l == if zero?(first l) then
                    0
                  else
                    log(first l) * first(l) ** second(l)

@
This operation implements the differentiation of the power operator [[%power]]
with respect to its second argument, i.e., the exponent. It uses the formula
$$\frac{d}{dx} g(y)^x = \frac{d}{dx} e^{x\log g(y)} = \log g(y) g(y)^x.$$

If $g(y)$ equals zero, this formula is not valid, since the logarithm is not
defined there. Although strictly speaking $0^x$ is not differentiable at zero,
we return zero for convenience. 

Note that up to [[patch--25]] this used to read
\begin{verbatim}
    if F has ElementaryFunctionCategory then
      dvpow2 l == log(first l) * first(l) ** second(l)
\end{verbatim}
which caused differentiating $0^x$ to fail. (Issue~\#19)

<<package COMBF CombinatorialFunction>>=
    evaluate(opfact, iifact)$BasicOperatorFunctions1(F)
    evaluate(oppow, iipow)
    evaluate(opperm, iiperm)
    evaluate(opbinom, iibinom)
    evaluate(opsum, isum)
    evaluate(opdsum, iidsum)
    evaluate(opprod, iprod)
    evaluate(opdprod, iidprod)
    derivative(oppow, [dvpow1, dvpow2])
    setProperty(opsum,   SPECIALDIFF, dvsum@((List F, SE) -> F) pretend None)
    setProperty(opdsum,  SPECIALDIFF, dvdsum@((List F, SE)->F) pretend None)
    setProperty(opprod,  SPECIALDIFF, dvprod@((List F, SE)->F) pretend None)
    setProperty(opdprod, SPECIALDIFF, dvdprod@((List F, SE)->F) pretend None)
@
The last four properties define special differentiation rules for sums and
products. Note that up to [[patch--45]] the rules for products were missing.
Thus products were differentiated according the usual chain-rule, which gave
incorrect results.

<<package COMBF CombinatorialFunction>>=
    setProperty(opsum,   SPECIALDISP, dsum@(List F -> O) pretend None)
    setProperty(opdsum,  SPECIALDISP, ddsum@(List F -> O) pretend None)
    setProperty(opprod,  SPECIALDISP, dprod@(List F -> O) pretend None)
    setProperty(opdprod, SPECIALDISP, ddprod@(List F -> O) pretend None)
    setProperty(opsum,   SPECIALEQUAL, equalsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opdsum,  SPECIALEQUAL, equaldsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opprod,  SPECIALEQUAL, equalsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opdprod, SPECIALEQUAL, equaldsumprod@((K,K) -> Boolean) pretend None)

@ 
Finally, we set the properties for displaying sums and products and testing for
equality.


<<COMBF.dotabb>>=
"COMBF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMBF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMBF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CDEN CommonDenominator}
\pagehead{CommonDenominator}{CDEN}
\pagepic{ps/v104commondenominator.ps}{CDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CDEN CommonDenominator>>=
)abbrev package CDEN CommonDenominator
--% CommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Nov 1989
++ Description: CommonDenominator provides functions to compute the
++ common denominator of a finite linear aggregate of elements of
++ the quotient field of an integral domain.
++ Keywords: gcd, quotient, common, denominator.
CommonDenominator(R, Q, A): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
  A: FiniteLinearAggregate Q
 
  Exports ==> with
    commonDenominator: A -> R
      ++ commonDenominator([q1,...,qn]) returns a common denominator
      ++ d for q1,...,qn.
    clearDenominator : A -> A
      ++ clearDenominator([q1,...,qn]) returns \spad{[p1,...,pn]} such that
      ++ \spad{qi = pi/d} where d is a common denominator for the qi's.
    splitDenominator : A -> Record(num: A, den: R)
      ++ splitDenominator([q1,...,qn]) returns
      ++ \spad{[[p1,...,pn], d]} such that
      ++ \spad{qi = pi/d} and d is a common denominator for the qi's.
 
  Implementation ==> add
    clearDenominator l ==
      d := commonDenominator l
      map(numer(d * #1)::Q, l)
 
    splitDenominator l ==
      d := commonDenominator l
      [map(numer(d * #1)::Q, l), d]
 
    if R has GcdDomain then
      qlcm: (Q, Q) -> Q
 
      qlcm(a, b)          == lcm(numer a, numer b)::Q
      commonDenominator l == numer reduce(qlcm, map(denom(#1)::Q, l), 1)
    else
      commonDenominator l == numer reduce("*", map(denom(#1)::Q, l), 1)

@
<<CDEN.dotabb>>=
"CDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CRFP ComplexRootFindingPackage}
\pagehead{ComplexRootFindingPackage}{CRFP}
\pagepic{ps/v104complexrootfindingpackage.ps}{CRFP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CRFP ComplexRootFindingPackage>>=
)abbrev package CRFP ComplexRootFindingPackage
++ Author: J. Grabmeier
++ Date Created: 31 January 1991
++ Date Last Updated: 12 April 1991
++ Basic Operations: factor, pleskenSplit
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex zeros, roots
++ References: J. Grabmeier: On Plesken's root finding algorithm,
++  in preparation
++  A. Schoenhage: The fundamental theorem of algebra in terms of computational
++  complexity, preliminary report, Univ. Tuebingen, 1982
++ Description:
++  \spadtype{ComplexRootFindingPackage} provides functions to
++  find all roots of a polynomial p over the complex number by
++  using Plesken's idea to calculate in the polynomial ring
++  modulo f and employing the Chinese Remainder Theorem.
++  In this first version, the precision (see \spadfunFrom{digits}{Float})
++  is not increased when this is necessary to
++  avoid rounding errors. Hence it is the user's responsibility to
++  increase the precision if necessary.
++  Note also, if this package is called with e.g. \spadtype{Fraction Integer},
++  the precise calculations could require a lot of time.
++  Also note that evaluating the zeros is not necessarily a good check
++  whether the result is correct: already evaluation can cause
++  rounding errors.
ComplexRootFindingPackage(R, UP): public == private where
   -- R   : Join(Field, OrderedRing, CharacteristicZero)
   -- Float not in CharacteristicZero !|
   R   : Join(Field, OrderedRing)
   UP  : UnivariatePolynomialCategory Complex R

   C      ==> Complex R
   FR     ==> Factored
   I      ==> Integer
   L      ==> List
   FAE    ==> Record(factors : L UP, error : R)
   NNI    ==> NonNegativeInteger
   OF     ==> OutputForm
   ICF    ==> IntegerCombinatoricFunctions(I)

   public ==> with
     complexZeros : UP -> L C
       ++ complexZeros(p) tries to determine all complex zeros
       ++ of the polynomial p with accuracy given by the package
       ++ constant {\em globalEps} which you may change by
       ++ {\em setErrorBound}.
     complexZeros : (UP, R) -> L C
       ++ complexZeros(p, eps) tries to determine all complex zeros
       ++ of the polynomial p with accuracy given by {\em eps}.
     divisorCascade : (UP,UP, Boolean) -> L FAE
       ++ divisorCascade(p,tp) assumes that degree of polynomial {\em tp}
       ++ is smaller than degree of polynomial p, both monic.
       ++ A sequence of divisions are calculated
       ++ using the remainder, made monic, as divisor
       ++ for the the next division. The result contains also the error of the
       ++ factorizations, i.e. the norm of the remainder polynomial.
       ++ If {\em info} is {\em true}, then information messages are issued.
     divisorCascade : (UP,UP) -> L FAE
       ++ divisorCascade(p,tp) assumes that degree of polynomial {\em tp}
       ++ is smaller than degree of polynomial p, both monic.
       ++ A sequence of divisions is calculated
       ++ using the remainder, made monic, as divisor
       ++ for the  the next division. The result contains also the error of the
       ++ factorizations, i.e. the norm of the remainder polynomial.
     factor: (UP,R,Boolean)  ->  FR UP
       ++ factor(p, eps, info) tries to factor p into linear factors
       ++ with error atmost {\em eps}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
       ++ If {\em info} is {\em true}, then information messages are given.
     factor: (UP,R)  ->  FR UP
       ++ factor(p, eps) tries to factor p into linear factors
       ++ with error atmost {\em eps}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
     factor: UP  ->  FR UP
       ++ factor(p) tries to factor p into linear factors
       ++ with error atmost {\em globalEps}, the internal error bound,
       ++ which can be set by {\em setErrorBound}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
     graeffe : UP -> UP
       ++ graeffe p determines q such that \spad{q(-z**2) = p(z)*p(-z)}.
       ++ Note that the roots of q are the squares of the roots of p.
     norm : UP -> R
       ++ norm(p) determines sum of absolute values of coefficients
       ++ Note: this function depends on \spadfunFrom{abs}{Complex}.
     pleskenSplit: (UP, R, Boolean)  ->  FR UP
       ++ pleskenSplit(poly,eps,info) determines a start polynomial {\em start}
       ++ by using "startPolynomial then it increases the exponent
       ++ n of {\em start ** n mod poly} to get an approximate factor of
       ++ {\em poly}, in general of degree "degree poly -1". Then a divisor
       ++ cascade is calculated and the best splitting is chosen, as soon
       ++ as the error is small enough.
       --++ In a later version we plan
       --++ to use the whole information to get a split into more than 2
       --++ factors.
       ++ If {\em info} is {\em true}, then information messages are issued.
     pleskenSplit: (UP, R)  ->  FR UP
       ++ pleskenSplit(poly, eps)  determines a start polynomial {\em start}\
       ++ by using "startPolynomial then it increases the exponent
       ++ n of {\em start ** n mod poly} to get an approximate factor of
       ++ {\em poly}, in general of degree "degree poly -1". Then a divisor
       ++ cascade is calculated and the best splitting is chosen, as soon
       ++ as the error is small enough.
       --++ In a later version we plan
       --++ to use the whole information to get a split into more than 2
       --++ factors.
     reciprocalPolynomial: UP  -> UP
       ++ reciprocalPolynomial(p) calulates a polynomial which has exactly
       ++ the inverses of the non-zero roots of p as roots, and the same
       ++ number of 0-roots.
     rootRadius: (UP,R) -> R
       ++ rootRadius(p,errQuot) calculates the root radius of p with a
       ++ maximal error quotient of {\em errQuot}.
     rootRadius: UP -> R
       ++ rootRadius(p) calculates the root radius of p with a
       ++ maximal error quotient of {\em 1+globalEps}, where
       ++ {\em globalEps} is the internal error bound, which can be
       ++ set by {\em setErrorBound}.
     schwerpunkt: UP ->  C
       ++ schwerpunkt(p) determines the 'Schwerpunkt' of the roots of the
       ++ polynomial p of degree n, i.e. the center of gravity, which is
       ++ {\em coeffient of \spad{x**(n-1)}} divided by
       ++ {\em n times coefficient of \spad{x**n}}.
     setErrorBound : R -> R
       ++ setErrorBound(eps) changes the internal error bound,
       -- by default being {\em 10 ** (-20)} to eps, if R is
       ++ by default being {\em 10 ** (-3)} to eps, if R is
       ++ a member in the category \spadtype{QuotientFieldCategory Integer}.
       ++ The internal {\em globalDigits} is set to
       -- {\em ceiling(1/r)**2*10} being {\em 10**41} by default.
       ++ {\em ceiling(1/r)**2*10} being {\em 10**7} by default.
     startPolynomial: UP  -> Record(start: UP, factors: FR UP)
       ++ startPolynomial(p) uses the ideas of Schoenhage's
       ++ variant of Graeffe's method to construct circles which separate
       ++ roots to get a good start polynomial, i.e. one whose
       ++ image under the Chinese Remainder Isomorphism has both entries
       ++ of norm smaller and greater or equal to 1. In case the
       ++ roots are found during internal calculations.
       ++ The corresponding factors
       ++ are in {\em factors} which are otherwise 1.

   private ==> add


     Rep := ModMonic(C, UP)

     -- constants
     c : C
     r : R
     --globalDigits : I := 10 ** 41
     globalDigits : I := 10 ** 7
     globalEps : R :=
       --a : R := (1000000000000000000000 :: I) :: R
       a : R := (1000 :: I) :: R
       1/a
     emptyLine : OF := "  "
     dashes : OF := center "---------------------------------------------------"
     dots : OF :=   center "..................................................."
     one : R := 1$R
     two : R := 2 * one
     ten : R := 10 * one
     eleven : R := 11 * one
     weakEps := eleven/ten
     --invLog2 : R := 1/log10 (2*one)

     -- signatures of local functions

     absC : C -> R
       --
     absR : R -> R
       --
     calculateScale : UP -> R
       --
     makeMonic : UP -> UP
       -- 'makeMonic p' divides 'p' by the leading coefficient,
       -- to guarantee new leading coefficient to be 1$R  we cannot
       -- simply divide the leading monomial by the leading coefficient
       -- because of possible rounding errors
     min: (FAE, FAE) -> FAE
       -- takes factorization with smaller error
     nthRoot : (R, NNI) -> R
       -- nthRoot(r,n) determines an approximation to the n-th
       -- root of r, if \spadtype{R} has {\em ?**?: (R,Fraction Integer)->R}
       -- we use this, otherwise we use {\em approxNthRoot} via
       -- \spadtype{Integer}
     shift: (UP,C) ->  UP
       -- shift(p,c) changes p(x) into p(x+c), thereby modifying the
       -- roots u_j of p to the roots (u_j - c)  of shift(p,c)
     scale: (UP,C) -> UP
       -- scale(p,c) changes p(x) into p(cx), thereby modifying the
       -- roots u_j of p to the roots ((1/c) u_j)  of scale(p,c)


     -- implementation of exported functions


     complexZeros(p,eps) ==
       --r1 : R := rootRadius(p,weakEps)
       --eps0 : R = r1 * nthRoot(eps, degree p)
       -- right now we are content with
       eps0 : R := eps/(ten ** degree p)
       facs : FR UP := factor(p,eps0)
       [-coefficient(linfac.factor,0) for linfac in factors facs]

     complexZeros p == complexZeros(p,globalEps)
     setErrorBound r ==
       r <= 0 => error "setErrorBound: need error bound greater 0"
       globalEps := r
       if R has QuotientFieldCategory Integer then
         rd : Integer := ceiling(1/r)
         globalDigits := rd * rd * 10
         lof : List OF := _
           ["setErrorBound: internal digits set to",globalDigits::OF]
         print hconcat lof
       messagePrint  "setErrorBound: internal error bound set to"
       globalEps

     pleskenSplit(poly,eps,info) ==
       p := makeMonic poly
       fp : FR UP
       if not zero? (md := minimumDegree p) then
         fp : FR UP := irreducibleFactor(monomial(1,1)$UP,md)$(FR UP)
         p := p quo monomial(1,md)$UP
       sP : Record(start: UP, factors: FR UP) := startPolynomial p
       fp : FR UP := sP.factors
--       if not one? fp then
       if not (fp = 1) then
         qr: Record(quotient: UP, remainder: UP):= divide(p,makeMonic expand fp)
         p := qr.quotient
       st := sP.start
       zero? degree st => fp
         -- we calculate in ModMonic(C, UP),
         -- next line defines the polynomial, which is used for reducing
       setPoly p
       nm : R := eps
       split : FAE
       sR : Rep := st :: Rep
       psR : Rep := sR ** (degree poly)

       notFoundSplit : Boolean := true
       while notFoundSplit repeat
       --  if info then
       --    lof : L OF := ["not successfull, new exponent:", nn::OF]
       --    print hconcat lof
         psR := psR * psR * sR   -- exponent (2*d +1)
         -- be careful, too large exponent results in rounding errors
         -- tp is the first approximation of a divisor of poly:
         tp : UP  := lift psR
         zero? degree tp  =>
           if info then print "we leave as we got constant factor"
           nilFactor(poly,1)$(FR UP)
         -- this was the case where we don't find a non-trivial factorization
         -- we refine tp by repeated polynomial division and hope that
         -- the norm of the remainder gets small  from time to time
         splits : L FAE :=  divisorCascade(p, makeMonic tp, info)
         split := reduce(min,splits)
         notFoundSplit := (eps <=  split.error)

       for fac in split.factors repeat
         fp :=
--           one? degree fac => fp * nilFactor(fac,1)$(FR UP)
           (degree fac = 1) => fp * nilFactor(fac,1)$(FR UP)
           fp * irreducibleFactor(fac,1)$(FR UP)
       fp

     startPolynomial p == -- assume minimumDegree is 0
       --print (p :: OF)
       fp : FR UP := 1
--       one? degree p =>
       (degree p = 1) =>
         p := makeMonic p
         [p,irreducibleFactor(p,1)]
       startPoly : UP := monomial(1,1)$UP
       eps : R := weakEps   -- 10 per cent errors allowed
       r1 : R := rootRadius(p, eps)
       rd : R := 1/rootRadius(reciprocalPolynomial p, eps)
       (r1 > (2::R)) and (rd < 1/(2::R)) => [startPoly,fp] -- unit circle splitting!
       -- otherwise the norms of the roots are too closed so we
       -- take the center of gravity as new origin:
       u  : C := schwerpunkt p
       startPoly := startPoly-monomial(u,0)
       p := shift(p,-u)
       -- determine new rootRadius:
       r1 : R := rootRadius(p, eps)
       startPoly := startPoly/(r1::C)
       -- use one of the 4 points r1*zeta, where zeta is a 4th root of unity
       -- as new origin, this could be changed to an arbitrary list
       -- of elements of norm 1.
       listOfCenters : L C := [complex(r1,0), complex(0,r1), _
         complex(-r1,0), complex(0,-r1)]
       lp   : L UP := [shift(p,v) for v in listOfCenters]
       -- next we check if one of these centers is a root
       centerIsRoot : Boolean := false
       for i in 1..maxIndex lp repeat
         if (mD := minimumDegree lp.i) > 0 then
           pp : UP := monomial(1,1)-monomial(listOfCenters.i-u,0)
           centerIsRoot := true
           fp := fp * irreducibleFactor(pp,mD)
       centerIsRoot =>
         p := shift(p,u) quo expand fp
         --print (p::OF)
         zero? degree p => [p,fp]
         sP:= startPolynomial(p)
         [sP.start,fp]
       -- choose the best one w.r.t. maximal quotient of norm of largest
       -- root and norm of smallest root
       lpr1 : L R := [rootRadius(q,eps) for  q in lp]
       lprd : L R := [1/rootRadius(reciprocalPolynomial q,eps) for  q in lp]
       -- later we should check here of an rd is smaller than globalEps
       lq : L R := []
       for i in 1..maxIndex lpr1 repeat
         lq := cons(lpr1.i/lprd.i, lq)
       --lq : L R := [(l/s)::R for l in lpr1 for s in lprd])
       lq := reverse lq
       po := position(reduce(max,lq),lq)
       --p := lp.po
       --lrr : L R := [rootRadius(p,i,1+eps) for i in 2..(degree(p)-1)]
       --lrr := concat(concat(lpr1.po,lrr),lprd.po)
       --lu : L R := [(lrr.i + lrr.(i+1))/2 for i in 1..(maxIndex(lrr)-1)]
       [startPoly - monomial(listOfCenters.po,0),fp]

     norm p ==
      -- reduce(_+$R,map(absC,coefficients p))
      nm : R := 0
      for c in  coefficients p repeat
        nm := nm + absC c
      nm

     pleskenSplit(poly,eps) == pleskenSplit(poly,eps,false)

     graeffe p ==
       -- If  p = ao x**n + a1 x**(n-1) + ... + a<n-1> x + an
       -- and q = bo x**n + b1 x**(n-1) + ... + b<n-1> x + bn
       -- are such that q(-x**2) = p(x)p(-x), then
       -- bk := ak**2 + 2 * ((-1) * a<k-1>*a<k+1> + ... +
       --                    (-1)**l * a<l>*a<l>) where l = min(k, n-k).
       -- graeffe(p) constructs q using these identities.
       n   : NNI  := degree p
       aForth : L C := []
       for k in 0..n repeat  --  aForth = [a0, a1, ..., a<n-1>, an]
         aForth := cons(coefficient(p, k::NNI), aForth)
       aBack  : L C := [] --  after k steps
                             --  aBack = [ak, a<k-1>, ..., a1, a0]
       gp : UP := 0$UP
       for k in 0..n repeat
         ak : C := first aForth
         aForth := rest aForth
         aForthCopy : L C := aForth  -- we iterate over aForth and
         aBackCopy  : L C := aBack   -- aBack but do not want to
                                      -- destroy them
         sum        :   C := 0
         const : I  := -1  --  after i steps const = (-1)**i
         for aminus in aBack for aplus in aForth repeat
           -- after i steps aminus = a<k-i> and aplus = a<k+i>
           sum := sum + const * aminus * aplus
           aForthCopy := rest aForthCopy
           aBackCopy  := rest aBackCopy
           const := -const
         gp := gp + monomial(ak*ak + 2 * sum, (n-k)::NNI)
         aBack := cons(ak, aBack)
       gp



     rootRadius(p,errorQuotient) ==
       errorQuotient <= 1$R =>
         error "rootRadius: second Parameter must be greater than 1"
       pp   : UP  := p
       rho  : R   := calculateScale makeMonic pp
       rR   : R   := rho
       pp := makeMonic scale(pp,complex(rho,0$R))
       expo : NNI := 1
       d    : NNI := degree p
       currentError:  R   := nthRoot(2::R, 2)
       currentError     := d*20*currentError
       while nthRoot(currentError, expo) >= errorQuotient repeat
         -- if info then print (expo :: OF)
         pp := graeffe pp
         rho := calculateScale pp
         expo := 2 * expo
         rR := nthRoot(rho, expo) * rR
         pp :=  makeMonic scale(pp,complex(rho,0$R))
       rR

     rootRadius(p) == rootRadius(p, 1+globalEps)

     schwerpunkt p ==
       zero? p => 0$C
       zero? (d := degree p) => error _
       "schwerpunkt: non-zero const. polynomial has no roots and no schwerpunkt"
       -- coeffient of x**d and x**(d-1)
       lC : C :=  coefficient(p,d)  -- ^= 0
       nC : C :=  coefficient(p,(d-1) pretend NNI)
       (denom := recip ((d::I::C)*lC)) case "failed" => error  "schwerpunkt: _
         degree * leadingCoefficient not invertible in ring of coefficients"
       - (nC*(denom::C))

     reciprocalPolynomial p ==
       zero? p => 0
       d : NNI := degree p
       md : NNI := d+minimumDegree p
       lm : L UP := [monomial(coefficient(p,i),(md-i) :: NNI) for i in 0..d]
       sol := reduce(_+, lm)

     divisorCascade(p, tp, info) ==
       lfae : L FAE :=  nil()
       for i in 1..degree tp while (degree tp > 0)  repeat
         -- USE monicDivide !!!
         qr  : Record(quotient: UP, remainder: UP)  :=  divide(p,tp)
         factor1 : UP := tp
         factor2 : UP := makeMonic qr.quotient
         -- refinement of tp:
         tp := qr.remainder
         nm : R := norm tp
         listOfFactors  : L UP := cons(factor2,nil()$(L UP))
         listOfFactors := cons(factor1,listOfFactors)
         lfae := cons( [listOfFactors,nm], lfae)
         if info then
           --lof : L OF :=  [i :: OF,"-th division:"::OF]
           --print center box hconcat lof
           print emptyLine
           lof : L OF :=  ["error polynomial has degree " ::OF,_
             (degree tp)::OF, " and norm " :: OF, nm :: OF]
           print center hconcat lof
           lof : L OF := ["degrees of factors:" ::OF,_
             (degree factor1)::OF,"  ", (degree factor2)::OF]
           print center hconcat lof
       if info then print emptyLine
       reverse lfae

     divisorCascade(p, tp) == divisorCascade(p, tp, false)

     factor(poly,eps) == factor(poly,eps,false)
     factor(p) == factor(p, globalEps)

     factor(poly,eps,info) ==
       result : FR  UP := coerce monomial(leadingCoefficient poly,0)
       d : NNI := degree poly
       --should be
       --den : R := (d::I)::R * two**(d::Integer) * norm poly
       --eps0 : R := eps / den
       -- for now only
       eps0 : R := eps / (ten*ten)
--       one? d  => irreducibleFactor(poly,1)$(FR UP)
       (d = 1) => irreducibleFactor(poly,1)$(FR UP)
       listOfFactors : L Record(factor: UP,exponent: I) :=_
         list [makeMonic poly,1]
       if info then
         lof : L OF := [dashes,dots,"list of Factors:",dots,listOfFactors::OF, _
           dashes, "list of Linear Factors:", dots, result::OF, _
           dots,dashes]
         print vconcat lof
       while not null listOfFactors  repeat
         p : UP := (first listOfFactors).factor
         exponentOfp : I := (first listOfFactors).exponent
         listOfFactors := rest listOfFactors
         if info then
           lof : L OF := ["just now we try to split the polynomial:",p::OF]
           print vconcat lof
         split : FR UP  := pleskenSplit(p, eps0, info)
--         one? numberOfFactors split =>
         (numberOfFactors split = 1) =>
           -- in a later version we will change error bound and
           -- accuracy here to deal this case as well
           lof : L OF := ["factor: couldn't split factor",_
             center(p :: OF), "with required error bound"]
           print vconcat lof
           result := result * nilFactor(p, exponentOfp)
         -- now we got 2 good factors of p, we drop p and continue
         -- with the factors, if they are not linear, or put a
         -- linear factor to the result
         for rec in factors(split)$(FR UP) repeat
           newFactor : UP := rec.factor
           expOfFactor := exponentOfp * rec.exponent
--           one? degree newFactor =>
           (degree newFactor = 1) =>
             result := result * nilFactor(newFactor,expOfFactor)
           listOfFactors:=cons([newFactor,expOfFactor],_
             listOfFactors)
       result

     -- implementation of local functions

     absC c == nthRoot(norm(c)$C,2)
     absR r ==
       r < 0 => -r
       r
     min(fae1,fae2) ==
       fae2.error <  fae1.error => fae2
       fae1
     calculateScale p ==
       d  := degree p
       maxi :R := 0
       for j in 1..d for cof in rest coefficients p repeat
         -- here we need abs: R -> R
         rc :  R := absR real cof
         ic :  R := absR imag cof
         locmax: R := max(rc,ic)
         maxi := max( nthRoot( locmax/(binomial(d,j)$ICF::R), j), maxi)
       -- Maybe I should use some type of logarithm for the following:
       maxi = 0$R => error("Internal Error: scale cannot be 0")
       rho  :R := one
       rho < maxi =>
         while rho < maxi repeat rho := ten * rho
         rho / ten
       while maxi < rho repeat rho := rho / ten
       rho = 0 => one
       rho
     makeMonic p  ==
       p = 0 => p
       monomial(1,degree p)$UP + (reductum p)/(leadingCoefficient p)

     scale(p, c) ==
       -- eval(p,cx) is missing !!
       eq : Equation UP := equation(monomial(1,1), monomial(c,1))
       eval(p,eq)
       -- improvement?: direct calculation of the new coefficients

     shift(p,c) ==
       rhs : UP := monomial(1,1) + monomial(c,0)
       eq : Equation UP := equation(monomial(1,1), rhs)
       eval(p,eq)
       -- improvement?: direct calculation of the new coefficients

     nthRoot(r,n) ==
       R has RealNumberSystem =>  r ** (1/n)
       R has QuotientFieldCategory Integer =>
         den : I := approxNthRoot(globalDigits * denom r ,n)$IntegerRoots(I)
         num : I := approxNthRoot(globalDigits * numer r ,n)$IntegerRoots(I)
         num/den
       -- the following doesn't compile
       --R has coerce: % -> Fraction Integer =>
       --  q : Fraction Integer := coerce(r)@Fraction(Integer)
       --  den : I := approxNthRoot(globalDigits * denom q ,n)$IntegerRoots(I)
       --  num : I := approxNthRoot(globalDigits * numer q ,n)$IntegerRoots(I)
       --  num/den
       r -- this is nonsense, perhaps a Newton iteration for x**n-r here

)fin
     -- for late use:

     graeffe2 p ==
       -- substitute x by -x :
       eq : Equation UP := equation(monomial(1,1), monomial(-1$C,1))
       pp : UP := p*eval(p,eq)
       gp : UP :=  0$UP
       while pp ^= 0 repeat
          i:NNI := (degree pp) quo (2::NNI)
          coef:C:=
            even? i => leadingCoefficient pp
            - leadingCoefficient pp
          gp    := gp + monomial(coef,i)
          pp    := reductum pp
       gp
     shift2(p,c) ==
       d := degree p
       cc : C := 1
       coef := List C := [cc := c * cc for i in 1..d]
       coef := cons(1,coef)
       coef := [coefficient(p,i)*coef.(1+i) for i in 0..d]
       res : UP := 0
       for j in 0..d repeat
         cc := 0
         for i in j..d repeat
           cc := cc + coef.i * (binomial(i,j)$ICF :: R)
         res := res + monomial(cc,j)$UP
       res
     scale2(p,c) ==
       d := degree p
       cc : C := 1
       coef := List C := [cc := c * cc for i in 1..d]
       coef := cons(1,coef)
       coef := [coefficient(p,i)*coef.(i+1) for i in 0..d]
       res : UP := 0
       for i in 0..d repeat  res := res + monomial(coef.(i+1),i)$UP
       res
     scale2: (UP,C) -> UP
     shift2: (UP,C) ->  UP
     graeffe2 : UP -> UP
       ++ graeffe2 p determines q such that \spad{q(-z**2) = p(z)*p(-z)}.
       ++ Note that the roots of q are the squares of the roots of p.

@
<<CRFP.dotabb>>=
"CRFP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CRFP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CRFP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CMPLXRT ComplexRootPackage}
\pagehead{ComplexRootPackage}{CMPLXRT}
\pagepic{ps/v104complexrootpackage.ps}{CMPLXRT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CMPLXRT ComplexRootPackage>>=
)abbrev package CMPLXRT ComplexRootPackage
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: Complex, Float, Fraction, UnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package provides functions complexZeros
++ for finding the complex zeros
++ of univariate polynomials with complex rational number coefficients.
++ The results are to any user specified precision and are returned
++ as either complex rational number or complex floating point numbers
++ depending on the type of the second argument which specifies the
++ precision.

-- Packages for the computation of complex roots of
-- univariate polynomials with rational or gaussian coefficients.

-- Simplified version, the old original based on Gebauer's solver is
-- in ocmplxrt spad
RN     ==> Fraction Integer
I      ==> Integer
NF     ==> Float

ComplexRootPackage(UP,Par) : T == C where
   UP   :   UnivariatePolynomialCategory Complex Integer
   Par  :   Join(Field, OrderedRing) -- will be Float or RN
   CP   ==> Complex Par
   PCI  ==> Polynomial Complex Integer

   T == with
        complexZeros:(UP,Par)  -> List CP
          ++ complexZeros(poly, eps) finds the complex zeros of the
          ++ univariate polynomial poly to precision eps with
          ++ solutions returned as complex floats or rationals
          ++ depending on the type of eps.

   C == add
    complexZeros(p:UP,eps:Par):List CP ==
      x1:Symbol():=new()
      x2:Symbol():=new()
      vv:Symbol():=new()
      lpf:=factors factor(p)$ComplexFactorization(I,UP)
      ris:List CP:=empty()
      for pf in lpf repeat
          pp:=pf.factor pretend SparseUnivariatePolynomial Complex Integer
          q:PCI :=multivariate(pp,vv)
          q:=eval(q,vv,x1::PCI+complex(0,1)*(x2::PCI))
          p1:=map(real,q)$PolynomialFunctions2(Complex I,I)
          p2:=map(imag,q)$PolynomialFunctions2(Complex I,I)
          lz:=innerSolve([p1,p2],[],[x1,x2],
                          eps)$InnerNumericFloatSolvePackage(I,Par,Par)
          ris:=append([complex(first z,second z) for z in lz],ris)
      ris

@
<<CMPLXRT.dotabb>>=
"CMPLXRT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CMPLXRT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CMPLXRT" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CTRIGMNP ComplexTrigonometricManipulations}
\pagehead{ComplexTrigonometricManipulations}{CTRIGMNP}
\pagepic{ps/v104complextrigonometricmanipulations.ps}{CTRIGMNP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CTRIGMNP ComplexTrigonometricManipulations>>=
)abbrev package CTRIGMNP ComplexTrigonometricManipulations
++ Real and Imaginary parts of complex functions
++ Author: Manuel Bronstein
++ Date Created: 11 June 1993
++ Date Last Updated: 14 June 1993
++ Description:
++   \spadtype{ComplexTrigonometricManipulations} provides function that
++   compute the real and imaginary parts of complex functions.
++ Keywords: complex, function, manipulation.
ComplexTrigonometricManipulations(R, F): Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace Complex R)


  SY  ==> Symbol
  FR  ==> Expression R
  K   ==> Kernel F


  Exports ==> with
    complexNormalize: F -> F
      ++ complexNormalize(f) rewrites \spad{f} using the least possible number
      ++ of complex independent kernels.
    complexNormalize: (F, SY) -> F
      ++ complexNormalize(f, x) rewrites \spad{f} using the least possible
      ++ number of complex independent kernels involving \spad{x}.
    complexElementary: F -> F
      ++ complexElementary(f) rewrites \spad{f} in terms of the 2 fundamental
      ++ complex transcendental elementary functions: \spad{log, exp}.
    complexElementary: (F, SY) -> F
      ++ complexElementary(f, x) rewrites the kernels of \spad{f} involving
      ++ \spad{x} in terms of the 2 fundamental complex
      ++ transcendental elementary functions: \spad{log, exp}.
    real   : F -> FR
      ++ real(f) returns the real part of \spad{f} where \spad{f} is a complex
      ++ function.
    imag   : F -> FR
      ++ imag(f) returns the imaginary part of \spad{f} where \spad{f}
      ++ is a complex function.
    real?  : F -> Boolean
      ++ real?(f) returns \spad{true} if \spad{f = real f}.
    trigs  : F -> F
      ++ trigs(f) rewrites all the complex logs and exponentials
      ++ appearing in \spad{f} in terms of trigonometric functions.
    complexForm: F -> Complex FR
      ++ complexForm(f) returns \spad{[real f, imag f]}.

  Implementation ==> add
    import InnerTrigonometricManipulations(R, FR, F)
    import ElementaryFunctionStructurePackage(Complex R, F)

    rreal?: Complex R -> Boolean
    kreal?: Kernel F -> Boolean
    localexplogs  : (F, F, List SY) -> F

    real f        == real complexForm f
    imag f        == imag complexForm f
    rreal? r      == zero? imag r
    kreal? k      == every?(real?, argument k)$List(F)
    complexForm f == explogs2trigs f

    trigs f ==
      GF2FG explogs2trigs f

    real? f ==
      every?(rreal?, coefficients numer f)
        and every?(rreal?, coefficients denom f) and every?(kreal?, kernels f)

    localexplogs(f, g, lx) ==
      trigs2explogs(g, [k for k in tower f
                          | is?(k, "tan"::SY) or is?(k, "cot"::SY)], lx)

    complexElementary f ==
      any?(has?(#1, "rtrig"),
        operators(g := realElementary f))$List(BasicOperator) =>
          localexplogs(f, g, variables g)
      g

    complexElementary(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
                 | member?(x, variables(k::F))]$List(K))$List(K) =>
                     localexplogs(f, g, [x])
      g

    complexNormalize(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
               | member?(x, variables(k::F))]$List(K))$List(K) =>
                   (rischNormalize(localexplogs(f, g, [x]), x).func)
      rischNormalize(g, x).func

    complexNormalize f ==
      l := variables(g := realElementary f)
      any?(has?(#1, "rtrig"), operators g)$List(BasicOperator) =>
        h := localexplogs(f, g, l)
        for x in l repeat h := rischNormalize(h, x).func
        h
      for x in l repeat g := rischNormalize(g, x).func
      g

@
<<CTRIGMNP.dotabb>>=
"CTRIGMNP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CTRIGMNP"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CTRIGMNP" -> "ACF"
"CTRIGMNP" -> "FS"
"CTRIGMNP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COORDSYS CoordinateSystems}
\pagehead{CoordinateSystems}{COORDSYS}
\pagepic{ps/v104coordinatesystems.ps}{COORDSYS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COORDSYS CoordinateSystems>>=
)abbrev package COORDSYS CoordinateSystems
++ Author: Jim Wen
++ Date Created: 12 March 1990
++ Date Last Updated: 19 June 1990, Clifton J. Williamson
++ Basic Operations: cartesian, polar, cylindrical, spherical, parabolic, elliptic, 
++ parabolicCylindrical, paraboloidal, ellipticCylindrical, prolateSpheroidal,
++ oblateSpheroidal, bipolar, bipolarCylindrical, toroidal, conical
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: CoordinateSystems provides coordinate transformation functions 
++ for plotting.  Functions in this package return conversion functions 
++ which take points expressed in other coordinate systems and return points 
++ with the corresponding Cartesian coordinates.
 
CoordinateSystems(R): Exports == Implementation where

  R : Join(Field,TranscendentalFunctionCategory,RadicalCategory)
  Pt ==> Point R

  Exports ==> with
    cartesian : Pt -> Pt
      ++ cartesian(pt) returns the Cartesian coordinates of point pt.
    polar: Pt -> Pt
      ++ polar(pt) transforms pt from polar coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta)}
      ++ to \spad{x = r * cos(theta)} , \spad{y = r * sin(theta)}.
    cylindrical: Pt -> Pt
      ++ cylindrical(pt) transforms pt from polar coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta,z)}
      ++ to \spad{x = r * cos(theta)}, \spad{y = r * sin(theta)}, \spad{z}.
    spherical: Pt -> Pt
      ++ spherical(pt) transforms pt from spherical coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta,phi)}
      ++ to \spad{x = r*sin(phi)*cos(theta)}, \spad{y = r*sin(phi)*sin(theta)},
      ++ \spad{z = r*cos(phi)}.
    parabolic: Pt -> Pt
      ++ parabolic(pt) transforms pt from parabolic coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(u,v)} to
      ++ \spad{x = 1/2*(u**2 - v**2)}, \spad{y = u*v}.
    parabolicCylindrical: Pt -> Pt
      ++ parabolicCylindrical(pt) transforms pt from parabolic cylindrical 
      ++ coordinates to Cartesian coordinates: the function produced will 
      ++ map the point \spad{(u,v,z)} to \spad{x = 1/2*(u**2 - v**2)}, 
      ++ \spad{y = u*v}, \spad{z}.
    paraboloidal: Pt -> Pt
      ++ paraboloidal(pt) transforms pt from paraboloidal coordinates to 
      ++ Cartesian coordinates: the function produced will map the point 
      ++ \spad{(u,v,phi)} to \spad{x = u*v*cos(phi)}, \spad{y = u*v*sin(phi)},
      ++ \spad{z = 1/2 * (u**2 - v**2)}.
    elliptic: R -> (Pt -> Pt)
      ++ elliptic(a) transforms from elliptic coordinates to Cartesian 
      ++ coordinates: \spad{elliptic(a)} is a function which will map the 
      ++ point \spad{(u,v)} to \spad{x = a*cosh(u)*cos(v)}, \spad{y = a*sinh(u)*sin(v)}.
    ellipticCylindrical: R -> (Pt -> Pt)
      ++ ellipticCylindrical(a) transforms from elliptic cylindrical coordinates 
      ++ to Cartesian coordinates: \spad{ellipticCylindrical(a)} is a function
      ++ which will map the point \spad{(u,v,z)} to \spad{x = a*cosh(u)*cos(v)},
      ++ \spad{y = a*sinh(u)*sin(v)}, \spad{z}.
    prolateSpheroidal: R -> (Pt -> Pt)
      ++ prolateSpheroidal(a) transforms from prolate spheroidal coordinates to 
      ++ Cartesian coordinates: \spad{prolateSpheroidal(a)} is a function 
      ++ which will map the point \spad{(xi,eta,phi)} to 
      ++ \spad{x = a*sinh(xi)*sin(eta)*cos(phi)}, \spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, 
      ++ \spad{z = a*cosh(xi)*cos(eta)}.
    oblateSpheroidal: R -> (Pt -> Pt)
      ++ oblateSpheroidal(a) transforms from oblate spheroidal coordinates to 
      ++ Cartesian coordinates: \spad{oblateSpheroidal(a)} is a function which
      ++ will map the point \spad{(xi,eta,phi)} to \spad{x = a*sinh(xi)*sin(eta)*cos(phi)},
      ++ \spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, \spad{z = a*cosh(xi)*cos(eta)}.
    bipolar: R -> (Pt -> Pt)
      ++ bipolar(a) transforms from bipolar coordinates to Cartesian coordinates:
      ++ \spad{bipolar(a)} is a function which will map the point \spad{(u,v)} to
      ++ \spad{x = a*sinh(v)/(cosh(v)-cos(u))}, \spad{y = a*sin(u)/(cosh(v)-cos(u))}.
    bipolarCylindrical: R -> (Pt -> Pt)
      ++ bipolarCylindrical(a) transforms from bipolar cylindrical coordinates 
      ++ to Cartesian coordinates: \spad{bipolarCylindrical(a)} is a function which 
      ++ will map the point \spad{(u,v,z)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},
      ++ \spad{y = a*sin(u)/(cosh(v)-cos(u))}, \spad{z}.
    toroidal: R -> (Pt -> Pt)
      ++ toroidal(a) transforms from toroidal coordinates to Cartesian 
      ++ coordinates: \spad{toroidal(a)} is a function which will map the point 
      ++ \spad{(u,v,phi)} to \spad{x = a*sinh(v)*cos(phi)/(cosh(v)-cos(u))},
      ++ \spad{y = a*sinh(v)*sin(phi)/(cosh(v)-cos(u))}, \spad{z = a*sin(u)/(cosh(v)-cos(u))}.
    conical: (R,R) -> (Pt -> Pt)
      ++ conical(a,b) transforms from conical coordinates to Cartesian coordinates:
      ++ \spad{conical(a,b)} is a function which will map the point \spad{(lambda,mu,nu)} to
      ++ \spad{x = lambda*mu*nu/(a*b)},
      ++ \spad{y = lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))},
      ++ \spad{z = lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))}.

  Implementation ==> add

    cartesian pt ==
      -- we just want to interpret the cartesian coordinates
      -- from the first N elements of the point - so the
      -- identity function will do
      pt

    polar pt0 ==
      pt := copy pt0
      r := elt(pt0,1); theta := elt(pt0,2)
      pt.1 := r * cos(theta); pt.2 := r * sin(theta)
      pt

    cylindrical pt0 == polar pt0 
    -- apply polar transformation to first 2 coordinates

    spherical pt0 ==
      pt := copy pt0
      r := elt(pt0,1); theta := elt(pt0,2); phi := elt(pt0,3)
      pt.1 := r * sin(phi) * cos(theta); pt.2 := r * sin(phi) * sin(theta)
      pt.3 := r * cos(phi)
      pt

    parabolic pt0 ==
      pt := copy pt0
      u := elt(pt0,1); v := elt(pt0,2)
      pt.1 := (u*u - v*v)/(2::R) ; pt.2 := u*v
      pt

    parabolicCylindrical pt0 == parabolic pt0
    -- apply parabolic transformation to first 2 coordinates

    paraboloidal pt0 ==
      pt := copy pt0
      u := elt(pt0,1); v := elt(pt0,2); phi := elt(pt0,3)
      pt.1 := u*v*cos(phi); pt.2 := u*v*sin(phi); pt.3 := (u*u - v*v)/(2::R)
      pt

    elliptic a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2)
      pt.1 := a*cosh(u)*cos(v); pt.2 := a*sinh(u)*sin(v)
      pt

    ellipticCylindrical a == elliptic a
    -- apply elliptic transformation to first 2 coordinates

    prolateSpheroidal a ==
      pt := copy(#1)
      xi := elt(#1,1); eta := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(xi)*sin(eta)*cos(phi)
      pt.2 := a*sinh(xi)*sin(eta)*sin(phi)
      pt.3 := a*cosh(xi)*cos(eta)
      pt

    oblateSpheroidal a ==
      pt := copy(#1)
      xi := elt(#1,1); eta := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(xi)*sin(eta)*cos(phi)
      pt.2 := a*cosh(xi)*cos(eta)*sin(phi)
      pt.3 := a*sinh(xi)*sin(eta)
      pt

    bipolar a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2)
      pt.1 := a*sinh(v)/(cosh(v)-cos(u))
      pt.2 := a*sin(u)/(cosh(v)-cos(u))
      pt

    bipolarCylindrical a == bipolar a
    -- apply bipolar transformation to first 2 coordinates

    toroidal a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(v)*cos(phi)/(cosh(v)-cos(u))
      pt.2 := a*sinh(v)*sin(phi)/(cosh(v)-cos(u))
      pt.3 := a*sin(u)/(cosh(v)-cos(u))
      pt

    conical(a,b) ==
      pt := copy(#1)
      lambda := elt(#1,1); mu := elt(#1,2); nu := elt(#1,3)
      pt.1 := lambda*mu*nu/(a*b)
      pt.2 := lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))
      pt.3 := lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))
      pt

@
<<COORDSYS.dotabb>>=
"COORDSYS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COORDSYS"]
"PTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PTCAT"]
"COORDSYS" -> "PTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CRAPACK CRApackage}
\pagehead{CRApackage}{CRAPACK}
\pagepic{ps/v104crapackage.ps}{CRAPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CRAPACK CRApackage>>=
)abbrev package CRAPACK CRApackage
 
++ This package \undocumented{}
CRApackage(R:EuclideanDomain): Exports == Implementation where
  Exports == with
    modTree: (R,List R) -> List R
	++ modTree(r,l) \undocumented{}
    chineseRemainder: (List R, List R) -> R
    ++ chineseRemainder(lv,lm) returns a value \axiom{v} such that, if
    ++ x is \axiom{lv.i} modulo \axiom{lm.i} for all \axiom{i}, then
    ++ x is \axiom{v} modulo \axiom{lm(1)*lm(2)*...*lm(n)}.
    chineseRemainder: (List List R, List R) -> List R
    ++ chineseRemainder(llv,lm) returns a list of values, each of which
    ++ corresponds to the Chinese remainder of the associated element of
    ++ \axiom{llv} and axiom{lm}.  This is more efficient than applying
    ++ chineseRemainder several times.
    multiEuclideanTree: (List R, R) -> List R
	++ multiEuclideanTree(l,r) \undocumented{}
  Implementation == add

    BB:=BalancedBinaryTree(R)
    x:BB

    -- Definition for modular reduction mapping with several moduli
    modTree(a,lm) ==
      t := balancedBinaryTree(#lm, 0$R)
      setleaves_!(t,lm)
      mapUp_!(t,"*")
      leaves mapDown_!(t, a, "rem")

    chineseRemainder(lv:List(R), lm:List(R)):R ==
      #lm ^= #lv => error "lists of moduli and values not of same length"
      x := balancedBinaryTree(#lm, 0$R)
      x := setleaves_!(x, lm)
      mapUp_!(x,"*")
      y := balancedBinaryTree(#lm, 1$R)
      y := mapUp_!(copy y,x,#1 * #4 + #2 * #3)
      (u := extendedEuclidean(value y, value x,1)) case "failed" =>
        error "moduli not relatively prime"
      inv := u . coef1
      linv := modTree(inv, lm)
      l := [(u*v) rem m for v in lv for u in linv for m in lm]
      y := setleaves_!(y,l)
      value(mapUp_!(y, x, #1 * #4 + #2 * #3)) rem value(x)

    chineseRemainder(llv:List List(R), lm:List(R)):List(R) ==
      x := balancedBinaryTree(#lm, 0$R)
      x := setleaves_!(x, lm)
      mapUp_!(x,"*")
      y := balancedBinaryTree(#lm, 1$R)
      y := mapUp_!(copy y,x,#1 * #4 + #2 * #3)
      (u := extendedEuclidean(value y, value x,1)) case "failed" =>
        error "moduli not relatively prime"
      inv := u . coef1
      linv := modTree(inv, lm)
      retVal:List(R) := []
      for lv in llv repeat
        l := [(u3*v) rem m for v in lv for u3 in linv for m in lm]
        y := setleaves!(y,l)
        retVal := cons(value(mapUp!(y, x, #1*#4+#2*#3)) rem value(x),retVal)
      reverse retVal

    extEuclidean: (R, R, R) -> List R
    extEuclidean(a, b, c) ==
      u := extendedEuclidean(a, b, c)
      u case "failed" => error [c, " not spanned by ", a, " and ",b]
      [u.coef2, u.coef1]

    multiEuclideanTree(fl, rhs) ==
      x := balancedBinaryTree(#fl, rhs)
      x := setleaves_!(x, fl)
      mapUp_!(x,"*")
      leaves mapDown_!(x, rhs, extEuclidean)

@
<<CRAPACK.dotabb>>=
"CRAPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CRAPACK"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"CRAPACK" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CYCLES CycleIndicators}
<<CycleIndicators.input>>=
-- cycles.spad.pamphlet CycleIndicators.input
)spool CycleIndicators.output
)set message test on
)set message auto off
)clear all
--S 1 of 47
complete 1
--R 
--R
--R   (1)  (1)
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 1

--S 2 of 47
complete 2
--R 
--R
--R        1       1   2
--R   (2)  - (2) + - (1 )
--R        2       2
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 2

--S 3 of 47
complete 3
--R 
--R
--R        1       1         1   3
--R   (3)  - (3) + - (2 1) + - (1 )
--R        3       2         6
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 3

--S 4 of 47
complete 7
--R 
--R
--R   (4)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R      1      5      1    7
--R     --- (2 1 ) + ---- (1 )
--R     240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 4

--S 5 of 47
elementary 7
--R 
--R
--R   (5)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R        1      5      1    7
--R     - --- (2 1 ) + ---- (1 )
--R       240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 5

--S 6 of 47
alternating 7
--R 
--R
--R   (6)
--R     2       1     2    1           1   2      1     2     1     4     1   2 3
--R     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
--R     7       5          4           9         12          36          24
--R   + 
--R       1    7
--R     ---- (1 )
--R     2520
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 6

--S 7 of 47
cyclic 7
--R 
--R
--R        6       1   7
--R   (7)  - (7) + - (1 )
--R        7       7
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 7

--S 8 of 47
dihedral 7
--R 
--R
--R        3       1   3      1   7
--R   (8)  - (7) + - (2 1) + -- (1 )
--R        7       2         14
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 8

--S 9 of 47
graphs 5
--R 
--R
--R   (9)
--R   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
--R   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
--R   6           5        4         6         8          12          120
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 9

--S 10 of 47
cap(complete 2**2, complete 2*complete 1**2)
--R 
--R
--R   (10)  4
--R                                                       Type: Fraction Integer
--E 10

--S 11 of 47
cap(elementary 2**2, complete 2*complete 1**2)
--R 
--R
--R   (11)  2
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 47
cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
--R 
--R
--R   (12)  24
--R                                                       Type: Fraction Integer
--E 12

--S 13 of 47
cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
--R 
--R
--R   (13)  8
--R                                                       Type: Fraction Integer
--E 13

--S 14 of 47
cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
--R 
--R
--R   (14)  8
--R                                                       Type: Fraction Integer
--E 14

--S 15 of 47
eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
--R 
--R
--R   (15)  1500
--R                                                       Type: Fraction Integer
--E 15

--S 16 of 47
square:=dihedral 4
--R 
--R
--R         1       3   2    1     2    1   4
--R   (16)  - (4) + - (2 ) + - (2 1 ) + - (1 )
--R         4       8        4          8
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 16

--S 17 of 47
cap(complete 2**2,square)
--R 
--R
--R   (17)  2
--R                                                       Type: Fraction Integer
--E 17

--S 18 of 47
cap(complete 3*complete 2**2,dihedral 7)
--R 
--R
--R   (18)  18
--R                                                       Type: Fraction Integer
--E 18

--S 19 of 47
cap(graphs 5,complete 7*complete 3)
--R 
--R
--R   (19)  4
--R                                                       Type: Fraction Integer
--E 19

--S 20 of 47
s(x) == powerSum(x)
--R 
--R                                                                   Type: Void
--E 20

--S 21 of 47
cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
--R 
--R   Compiling function s with type PositiveInteger -> 
--R      SymmetricPolynomial Fraction Integer 
--R
--R         1   2    1   2 2    3   4     1   8
--R   (21)  - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
--R         4        3          8        24
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 21

--S 22 of 47
cap(complete 4**2,cube)
--R 
--R
--R   (22)  7
--R                                                       Type: Fraction Integer
--E 22

--S 23 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
--R 
--R
--R   (23)  7
--R                                                       Type: Fraction Integer
--E 23

--S 24 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
--R 
--R
--R   (24)  17
--R                                                       Type: Fraction Integer
--E 24

--S 25 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
--R 
--R
--R   (25)  10
--R                                                       Type: Fraction Integer
--E 25

--S 26 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
--R 
--R
--R   (26)  23
--R                                                       Type: Fraction Integer
--E 26

--S 27 of 47
x: ULS(FRAC INT,'x,0) := 'x 
--R 
--R
--R   (27)  x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 27

--S 28 of 47
ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 28

--S 29 of 47
Integers: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 29

--S 30 of 47
ZeroOrOne n == 1+x**n
--R 
--R                                                                   Type: Void
--E 30

--S 31 of 47
ZeroOrOne 5 
--R 
--R   Compiling function ZeroOrOne with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5
--R   (31)  1 + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 31

--S 32 of 47
Integers n == 1/(1-x**n) 
--R 
--R                                                                   Type: Void
--E 32

--S 33 of 47
Integers 5 
--R 
--R   Compiling function Integers with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5    10      11
--R   (33)  1 + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 33

--S 34 of 47
)expose EVALCYC
--R 
--I   EvaluateCycleIndicators is now explicitly exposed in frame frame0 
--E 34

--S 35 of 47
eval(ZeroOrOne, graphs 5) 
--R 
--R
--R                   2     3     4     5     6     7     8    9    10      11
--R   (34)  1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 35

--S 36 of 47
eval(ZeroOrOne,dihedral 8) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (35)  1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 36

--S 37 of 47
eval(Integers,complete 4) 
--R 
--R
--R   (36)
--R             2     3     4     5     6      7      8      9      10      11
--R   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 37

--S 38 of 47
eval(Integers,elementary 4)
--R 
--R
--R   (37)
--R      6    7     8     9     10     11     12      13      14      15      16
--R     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
--R   + 
--R        17
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 38

--S 39 of 47
eval(ZeroOrOne,cube) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (38)  1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 39

--S 40 of 47
eval(Integers,cube) 
--R 
--R
--R   (39)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 40

--S 41 of 47
eval(Integers,graphs 5) 
--R 
--R
--R   (40)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 41

--S 42 of 47
eval(ZeroOrOne ,graphs 15) 
--R 
--R
--R   (41)
--R               2     3      4      5      6       7       8        9        10
--R     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 42

--S 43 of 47
cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
--R 
--R
--R   (42)  49958972383320
--R                                                       Type: Fraction Integer
--E 43

--S 44 of 47
sf3221:= SFunction [3,2,2,1] 
--R 
--R
--R   (43)
--R      1          1     2     1   2     1            1     4     1   2
--R     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
--R     12         12          16        12           24          36
--R   + 
--R      1   2 2     1     2      1       3     1     5     1    4     1   3 2
--R     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
--R     36          24           36            72          192        48
--R   + 
--R      1   2 4     1      6     1    8
--R     -- (2 1 ) - --- (2 1 ) + --- (1 )
--R     96          144          576
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 44

--S 45 of 47
cap(sf3221,complete 2**4) 
--R 
--R
--R   (44)  3
--R                                                       Type: Fraction Integer
--E 45

--S 46 of 47
cap(sf3221, powerSum 1**8)
--R 
--R
--R   (45)  70
--R                                                       Type: Fraction Integer
--E 46

--S 47 of 47
eval(Integers, sf3221)
--R 
--R
--R   (46)
--R      9     10     11      12      13      14      15       16       17       18
--R     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x   + 294x
--R   + 
--R         19      20
--R     432x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 47
)spool
)lisp (bye)
@
<<CycleIndicators.help>>=
====================================================================
CycleIndicators examples
====================================================================

This section is based upon the paper J. H. Redfield, ``The Theory of
Group-Reduced Distributions'', American J. Math.,49 (1927) 433-455,
and is an application of group theory to enumeration problems.  It is
a development of the work by P. A. MacMahon on the application of
symmetric functions and Hammond operators to combinatorial theory.

The theory is based upon the power sum symmetric functions s(i) which
are the sum of the i-th powers of the variables.  The cycle index of a
permutation is an expression that specifies the sizes of the cycles of
a permutation, and may be represented as a partition.  A partition of
a non-negative integer n is a collection of positive integers called
its parts whose sum is n.  For example, the partition (3^2 2 1^2) will
be used to represent s^2_3 s_2 s^2_1 and will indicate that the
permutation has two cycles of length 3, one of length 2 and two of
length 1.  The cycle index of a permutation group is the sum of the
cycle indices of its permutations divided by the number of
permutations.  The cycle indices of certain groups are provided.

The operation complete returns the cycle index of the symmetric group
of order n for argument n.  Alternatively, it is the n-th complete
homogeneous symmetric function expressed in terms of power sum
symmetric functions.

  complete 1
   (1)
                      Type: SymmetricPolynomial Fraction Integer

  complete 2
   1       1   2
   - (2) + - (1 )
   2       2
                      Type: SymmetricPolynomial Fraction Integer

  complete 3
   1       1         1   3
   - (3) + - (2 1) + - (1 )
   3       2         6
                      Type: SymmetricPolynomial Fraction Integer

  complete 7
     1       1          1          1     2     1         1            1     3
     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
      1      5      1    7
     --- (2 1 ) + ---- (1 )
     240          5040
                   Type: SymmetricPolynomial Fraction Integer

The operation elementary computes the n-th elementary symmetric
function for argument n.

  elementary 7
     1       1          1          1     2     1         1            1     3
     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
        1      5      1    7
     - --- (2 1 ) + ---- (1 )
       240          5040
                  Type: SymmetricPolynomial Fraction Integer

The operation alternating returns the cycle index of the alternating 
group having an even number of even parts in each cycle partition.

  alternating 7
     2       1     2    1           1   2      1     2     1     4     1   2 3
     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
     7       5          4           9         12          36          24
   + 
       1    7
     ---- (1 )
     2520
                  Type: SymmetricPolynomial Fraction Integer

The operation cyclic returns the cycle index of the cyclic group.

  cyclic 7
   6       1   7
   - (7) + - (1 )
   7       7
                  Type: SymmetricPolynomial Fraction Integer

The operation dihedral is the cycle index of the dihedral group.

  dihedral 7
   3       1   3      1   7
   - (7) + - (2 1) + -- (1 )
   7       2         14
                  Type: SymmetricPolynomial Fraction Integer

The operation graphs for argument n returns the cycle index of the
group of permutations on the edges of the complete graph with n nodes
induced by applying the symmetric group to the nodes.

  graphs 5
   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
   6           5        4         6         8          12          120
                  Type: SymmetricPolynomial Fraction Integer

The cycle index of a direct product of two groups is the product of
the cycle indices of the groups.  Redfield provided two operations on
two cycle indices which will be called "cup" and "cap" here.  The cup
of two cycle indices is a kind of scalar product that combines
monomials for permutations with the same cycles.  The cap operation
provides the sum of the coefficients of the result of the cup
operation which will be an integer that enumerates what Redfield
called group-reduced distributions.

We can, for example, represent complete 2 * complete 2 as the set of
objects a a b b and complete 2 * complete 1 * complete 1 as c c d e.

This integer is the number of different sets of four pairs.

  cap(complete 2**2, complete 2*complete 1**2)
    4
                  Type: Fraction Integer

For example,
  a a b b     a a b b    a a b b   a a b b
  c c d e     c d c e    c e c d   d e c c

This integer is the number of different sets of four pairs no two
pairs being equal.

  cap(elementary 2**2, complete 2*complete 1**2)
    2
                  Type: Fraction Integer

For example,

  a a b b    a a b b
  c d c e    c e c d

In this case the configurations enumerated are easily constructed,
however the theory merely enumerates them providing little help in
actually constructing them.

Here are the number of 6-pairs, first from a a a b b c, second
from d d e e f g.

  cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
    24
                     Type: Fraction Integer

Here it is again, but with no equal pairs.

  cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
    8
                     Type: Fraction Integer

  cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
    8
                     Type: Fraction Integer

The number of 6-triples, first from a a a b b c, second from
d d e e f g, third from h h i i j j.

  eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
    1500
                     Type: Fraction Integer

The cycle index of vertices of a square is dihedral 4.

  square:=dihedral 4
   1       3   2    1     2    1   4
   - (4) + - (2 ) + - (2 1 ) + - (1 )
   4       8        4          8
                     Type: SymmetricPolynomial Fraction Integer

The number of different squares with 2 red vertices and 2 blue vertices.

  cap(complete 2**2,square)
    2
                     Type: Fraction Integer

The number of necklaces with 3 red beads, 2 blue beads and 2 green beads.

  cap(complete 3*complete 2**2,dihedral 7)
    18
                     Type: Fraction Integer

The number of graphs with 5 nodes and 7 edges.

  cap(graphs 5,complete 7*complete 3)
    4
                     Type: Fraction Integer

The cycle index of rotations of vertices of a cube.

  s(x) == powerSum(x)
                     Type: Void

  cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
   1   2    1   2 2    3   4     1   8
   - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
   4        3          8        24
                     Type: SymmetricPolynomial Fraction Integer

The number of cubes with 4 red vertices and 4 blue vertices.

  cap(complete 4**2,cube)
    7
                     Type: Fraction Integer

The number of labeled graphs with degree sequence 2 2 2 1 1 with no 
loops or multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
    7
                     Type: Fraction Integer

Again, but with loops allowed but not multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
    17
                     Type: Fraction Integer

Again, but with multiple edges allowed, but not loops

  cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
    10
                     Type: Fraction Integer

Again, but with both multiple edges and loops allowed

  cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
    23
                     Type: Fraction Integer

Having constructed a cycle index for a configuration we are at liberty
to evaluate the s_i components any way we please.  For example we can
produce enumerating generating functions.  This is done by providing a
function f on an integer i to the value required of s_i, and then
evaluating eval(f, cycleindex).

  x: ULS(FRAC INT,'x,0) := 'x 
   x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

  ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

  Integers: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

For the integers 0 and 1, or two colors.

  ZeroOrOne n == 1+x**n
                     Type: Void

  ZeroOrOne 5 
         5
    1 + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

For the integers 0, 1, 2, ... we have this.

  Integers n == 1/(1-x**n) 
                     Type: Void

  Integers 5 
         5    10      11
    1 + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and n edges. 

Note that there is an eval function that takes two arguments. It has the 
signature:

  ((Integer -> D1),SymmetricPolynomial Fraction Integer) -> D1
    from EvaluateCycleIndicators D1 if D1 has ALGEBRA FRAC INT

This function is not normally exposed (it will not normally be considered
in the list of eval functions) as it is only useful for this particular
domain. To use it we ask that it be considered thus:

  )expose EVALCYC

and now we can use it:

  eval(ZeroOrOne, graphs 5) 
              2     3     4     5     6     7     8    9    10      11
    1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of necklaces with n red beads 
and n-8 green beads.

  eval(ZeroOrOne,dihedral 8) 
              2     3     4     5     6    7    8
    1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 or fewer parts.

  eval(Integers,complete 4) 
             2     3     4     5     6      7      8      9      10      11
   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 boxes
containing ordered distinct parts.

  eval(Integers,elementary 4)
      6    7     8     9     10     11     12      13      14      15      16
     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
   + 
        17
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with n red
vertices and 8-n green ones.

  eval(ZeroOrOne,cube) 
              2     3     4     5     6    7    8
    1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with integers
on the vertices whose sum is n.

  eval(Integers,cube) 
               2     3      4      5      6       7       8       9       10
     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
   + 
        11
     O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and with
integers on the edges whose sum is n.  In other words, the enumeration
is of multigraphs with 5 nodes and n edges.

  eval(Integers,graphs 5) 
               2     3      4      5      6       7       8       9       10
     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Graphs with 15 nodes enumerated with respect to number of edges.

  eval(ZeroOrOne ,graphs 15) 
               2     3      4      5      6       7       8        9        10
     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Necklaces with 7 green beads, 8 white beads, 5 yellow beads and 10
red beads.

  cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
    49958972383320
                     Type: Fraction Integer

The operation SFunction is the S-function or Schur function of a
partition written as a descending list of integers expressed in terms
of power sum symmetric functions.

In this case the argument partition represents a tableau shape.  For
example 3,2,2,1 represents a tableau with three boxes in the first
row, two boxes in the second and third rows, and one box in the fourth
row.  SFunction [3,2,2,1] counts the number of different tableaux of
shape 3, 2, 2, 1 filled with objects with an ascending order in the
columns and a non-descending order in the rows.

  sf3221:= SFunction [3,2,2,1] 
      1          1     2     1   2     1            1     4     1   2
     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
     12         12          16        12           24          36
   + 
      1   2 2     1     2      1       3     1     5     1    4     1   3 2
     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
     36          24           36            72          192        48
   + 
      1   2 4     1      6     1    8
     -- (2 1 ) - --- (2 1 ) + --- (1 )
     96          144          576
                     Type: SymmetricPolynomial Fraction Integer

This is the number filled with a a b b c c d d.

  cap(sf3221,complete 2**4) 
    3
                     Type: Fraction Integer

The configurations enumerated above are:

  a a b    a a c    a a d
  b c      b b      b b
  c d      c d      c c
  d        d        d

This is the number of tableaux filled with 1..8.

  cap(sf3221, powerSum 1**8)
    70
                     Type: Fraction Integer

The coefficient of x^n is the number of column strict reverse plane
partitions of n of shape 3 2 2 1.

  eval(Integers, sf3221)
      9     10     11      12      13      14      15       16       17
     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x  
   + 
        18      19      20
    294x  + 432x   + O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The smallest is

  0 0 0
  1 1
  2 2
  3

See Also:
o )show CycleIndicators
o $AXIOM/doc/src/algebra/cycles.spad.dvi

@
\pagehead{CycleIndicators}{CYCLES}
\pagepic{ps/v104cycleindicators.ps}{CYCLES}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CYCLES CycleIndicators>>=
)abbrev package CYCLES CycleIndicators
++ Polya-Redfield enumeration by cycle indices.
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: 11 Feb 1992
++ Keywords:Polya, Redfield, enumeration
++ Examples:
++ References: J.H.Redfield, 'The Theory of Group-Reduced Distributions',
++             American J. Math., 49 (1927) 433-455.
++             G.Polya, 'Kombinatorische Anzahlbestimmungen fur Gruppen,
++               Graphen und chemische Verbindungen', Acta Math. 68
++                (1937) 145-254.
++ Description: Enumeration by cycle indices. 
CycleIndicators: Exports == Implementation where
  I    ==> Integer
  L    ==> List
  B    ==> Boolean
  SPOL ==> SymmetricPolynomial
  PTN  ==> Partition
  RN   ==> Fraction Integer
  FR   ==> Factored Integer
  h ==> complete
  s ==> powerSum
  --a ==> elementary
  alt ==> alternating
  cyc ==> cyclic
  dih ==> dihedral
  ev == eval
  Exports ==> with
 
    complete: I -> SPOL RN
      ++\spad{complete n} is the \spad{n} th complete homogeneous
      ++ symmetric function expressed in terms of power sums.
      ++ Alternatively it is the cycle index of the symmetric
      ++ group of degree n.
 
    powerSum: I -> SPOL RN
      ++\spad{powerSum n} is the \spad{n} th power sum symmetric
      ++ function.
 
    elementary: I -> SPOL RN
      ++\spad{elementary n} is the \spad{n} th elementary symmetric
      ++ function expressed in terms of power sums.
 
 -- s2h: I -> SPOL RN--s to h
 
    alternating: I -> SPOL RN
      ++\spad{alternating n} is the cycle index of the
      ++ alternating group of degree n.
 
    cyclic: I -> SPOL RN    --cyclic group
      ++\spad{cyclic n} is the cycle index of the
      ++ cyclic group of degree n.
 
    dihedral: I -> SPOL RN    --dihedral group
      ++\spad{dihedral n} is the cycle index of the
      ++ dihedral group of degree n.
 
    graphs: I -> SPOL RN
      ++\spad{graphs n} is the cycle index of the group induced on
      ++ the edges of a graph by applying the symmetric function to the
      ++ n nodes.
 
    cap: (SPOL RN,SPOL RN) -> RN
      ++\spad{cap(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices.
 
    cup: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{cup(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices, in which the
      ++ power sums are retained to produce a cycle index.
 
    eval: SPOL RN -> RN
      ++\spad{eval s} is the sum of the coefficients of a cycle index.
 
    wreath: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{wreath(s1,s2)} is the cycle index of the wreath product
      ++ of the two groups whose cycle indices are \spad{s1} and
      ++ \spad{s2}.
 
    SFunction:L I -> SPOL RN
      ++\spad{SFunction(li)} is the S-function of the partition \spad{li}
      ++ expressed in terms of power sum symmetric functions.
 
    skewSFunction:(L I,L I) -> SPOL RN
      ++\spad{skewSFunction(li1,li2)} is the S-function
      ++ of the partition difference \spad{li1 - li2}
      ++ expressed in terms of power sum symmetric functions.
 
  Implementation ==> add
    import PartitionsAndPermutations
    import IntegerNumberTheoryFunctions
 
    trm: PTN -> SPOL RN
    trm pt == monomial(inv(pdct(pt) :: RN),pt)
 
    list: Stream L I -> L L I
    list st == entries complete st
 
    complete i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                   _+/[trm(partition pt) for pt in list(partitions i)]
 
 
    even?: L I -> B
    even? li == even?( #([i for i in li | even? i]))
 
    alt i ==
      2 * _+/[trm(partition li) for li in list(partitions i) | even? li]
    elementary i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                  _+/[(spol := trm(partition pt); even? pt => spol; -spol)
                          for pt in list(partitions i)]
 
    divisors: I -> L I
    divisors n ==
      b := factors(n :: FR)
      c := concat(1,"append"/
                 [[a.factor**j for j in 1..a.exponent] for a in b]);
      if #(b) = 1 then c else concat(n,c)
 
    ss: (I,I) -> SPOL RN
    ss(n,m) ==
      li : L I := [n for j in 1..m]
      monomial(1,partition li)
 
    s n == ss(n,1)
 
    cyc n ==
      n = 1 => s 1
      _+/[(eulerPhi(i) / n) * ss(i,numer(n/i)) for i in divisors n]
 
    dih n ==
      k := n quo 2
      odd? n => (1/2) * cyc n + (1/2) * ss(2,k) * s 1
      (1/2) * cyc n + (1/4) * ss(2,k) + (1/4) * ss(2,k-1) * ss(1,2)
 
    trm2: L I -> SPOL RN
    trm2 li ==
      lli := powers(li)$PTN
      xx := 1/(pdct partition li)
      prod : SPOL RN := 1
      for ll in lli repeat
        ll0 := first ll; ll1 := second ll
        k := ll0 quo 2
        c :=
          odd? ll0 => ss(ll0,ll1 * k)
          ss(k,ll1) * ss(ll0,ll1 * (k - 1))
        c := c * ss(ll0,ll0 * ((ll1*(ll1 - 1)) quo 2))
        prod2 : SPOL RN := 1
        for r in lli | first(r) < ll0 repeat
          r0 := first r; r1 := second r
          prod2 := ss(lcm(r0,ll0),gcd(r0,ll0) * r1 * ll1) * prod2
        prod := c * prod2 * prod
      xx * prod
 
    graphs n == _+/[trm2 li for li in list(partitions n)]
 
    cupp: (PTN,SPOL RN) -> SPOL RN
    cupp(pt,spol) ==
      zero? spol => 0
      (dg := degree spol) < pt => 0
      dg = pt => (pdct pt) * monomial(leadingCoefficient spol,dg)
      cupp(pt,reductum spol)
 
    cup(spol1,spol2) ==
      zero? spol1 => 0
      p := leadingCoefficient(spol1) * cupp(degree spol1,spol2)
      p + cup(reductum spol1,spol2)
 
    ev spol ==
      zero? spol => 0
      leadingCoefficient(spol) + ev(reductum spol)
 
    cap(spol1,spol2) == ev cup(spol1,spol2)
 
    mtpol: (I,SPOL RN) -> SPOL RN
    mtpol(n,spol)==
      zero? spol => 0
      deg := partition [n*k for k in (degree spol)::L(I)]
      monomial(leadingCoefficient spol,deg) + mtpol(n,reductum spol)
 
    fn2: I -> SPOL RN
    evspol: ((I -> SPOL RN),SPOL RN) -> SPOL RN
    evspol(fn2,spol) ==
      zero? spol => 0
      lc := leadingCoefficient spol
      prod := _*/[fn2 i for i in (degree spol)::L(I)]
      lc * prod + evspol(fn2,reductum spol)
 
    wreath(spol1,spol2) == evspol(mtpol(#1,spol2),spol1)
 
    hh: I -> SPOL RN      --symmetric group
    hh n == if n=0 then 1 else if n<0 then 0 else h n
    SFunction li==
      a:Matrix SPOL RN:=matrix [[hh(k -j+i) for k in li for j in 1..#li]
                    for i in 1..#li]
      determinant a
 
    roundup:(L I,L I)-> L I
    roundup(li1,li2)==
              #li1 > #li2 => roundup(li1,concat(li2,0))
              li2
 
    skewSFunction(li1,li2)==
      #li1 < #li2 =>
        error "skewSFunction: partition1 does not include partition2"
      li2:=roundup (li1,li2)
      a:Matrix SPOL RN:=matrix [[hh(k-li2.i-j+i)
               for k in li1 for j in 1..#li1]  for i in 1..#li1]
      determinant a

@
<<CYCLES.dotabb>>=
"CYCLES" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CYCLES"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CYCLES" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CYCLOTOM CyclotomicPolynomialPackage}
\pagehead{CyclotomicPolynomialPackage}{CYCLOTOM}
\pagepic{ps/v104cyclotomicpolynomialpackage.ps}{CYCLOTOM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CYCLOTOM CyclotomicPolynomialPackage>>=
)abbrev package CYCLOTOM CyclotomicPolynomialPackage
++ This package \undocumented{} 
CyclotomicPolynomialPackage: public == private where
  SUP  ==> SparseUnivariatePolynomial(Integer)
  LSUP ==> List(SUP)
  NNI  ==> NonNegativeInteger
  FR   ==> Factored SUP
  IFP  ==> IntegerFactorizationPackage Integer
 
  public == with
    cyclotomicDecomposition: Integer -> LSUP
	++ cyclotomicDecomposition(n) \undocumented{}
    cyclotomic:              Integer -> SUP
	++ cyclotomic(n) \undocumented{}
    cyclotomicFactorization: Integer -> FR
	++ cyclotomicFactorization(n) \undocumented{}
 
  private == add
    cyclotomic(n:Integer): SUP ==
      x,y,z,l: SUP
      g := factors factor(n)$IFP
      --Now, for each prime in the factorization apply recursion
      l := monomial(1,1) - monomial(1,0)
      for u in g repeat
         l := (monicDivide(multiplyExponents(l,u.factor::NNI),l)).quotient
         if u.exponent>1 then
            l := multiplyExponents(l,((u.factor)**((u.exponent-1)::NNI))::NNI)
      l
 
    cyclotomicDecomposition(n:Integer):LSUP ==
      x,y,z: SUP
      l,ll,m: LSUP
      rr: Integer
      g := factors factor(n)$IFP
      l := [monomial(1,1) - monomial(1,0)]
      --Now, for each prime in the factorization apply recursion
      for u in g repeat
         m := [(monicDivide(
            multiplyExponents(z,u.factor::NNI),z)).quotient for z in l]
         for rr in 1..(u.exponent-1) repeat
            l := append(l,m)
            m := [multiplyExponents(z,u.factor::NNI) for z in m]
         l := append(l,m)
      l
 
    cyclotomicFactorization(n:Integer):FR ==
      f :  SUP
      fr : FR := 1$FR
      for f in cyclotomicDecomposition(n) repeat
        fr := fr * primeFactor(f,1$Integer)
      fr

@
<<CYCLOTOM.dotabb>>=
"CYCLOTOM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CYCLOTOM"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CYCLOTOM" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DFINTTLS DefiniteIntegrationTools}
\pagehead{DefiniteIntegrationTools}{DFINTTLS}
\pagepic{ps/v104definiteintegrationtools.ps}{DFINTTLS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DFINTTLS DefiniteIntegrationTools>>=
)abbrev package DFINTTLS DefiniteIntegrationTools
++ Tools for definite integration
++ Author: Manuel Bronstein
++ Date Created: 15 April 1992
++ Date Last Updated: 24 February 1993
++ Description:
++   \spadtype{DefiniteIntegrationTools} provides common tools used
++   by the definite integration of both rational and elementary functions.
DefiniteIntegrationTools(R, F): Exports == Implementation where
  R : Join(GcdDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)

  B   ==> Boolean
  Z   ==> Integer
  Q   ==> Fraction Z
  SE  ==> Symbol
  P   ==> Polynomial R
  RF  ==> Fraction P
  UP  ==> SparseUnivariatePolynomial F
  K   ==> Kernel F
  OFE ==> OrderedCompletion F
  UPZ ==> SparseUnivariatePolynomial Z
  UPQ ==> SparseUnivariatePolynomial Q
  REC ==> Record(left:Q, right:Q)
  REC2==> Record(endpoint:Q, dir:Z)
  U   ==> Union(fin:REC, halfinf:REC2, all:"all", failed:"failed")
  IGNOR ==> "noPole"

  Exports ==> with
    ignore?: String -> B
      ++ ignore?(s) is true if s is the string that tells the integrator
      ++ to assume that the function has no pole in the integration interval.
    computeInt: (K, F, OFE, OFE, B) -> Union(OFE, "failed")
      ++ computeInt(x, g, a, b, eval?) returns the integral of \spad{f} for x
      ++ between a and b, assuming that g is an indefinite integral of
      ++ \spad{f} and \spad{f} has no pole between a and b.
      ++ If \spad{eval?} is true, then \spad{g} can be evaluated safely
      ++ at \spad{a} and \spad{b}, provided that they are finite values.
      ++ Otherwise, limits must be computed.
    checkForZero: (P,  SE, OFE, OFE, B) -> Union(B, "failed")
      ++ checkForZero(p, x, a, b, incl?) is true if p has a zero for x between
      ++ a and b, false otherwise, "failed" if this cannot be determined.
      ++ Check for a and b inclusive if incl? is true, exclusive otherwise.
    checkForZero: (UP, OFE, OFE, B) -> Union(B, "failed")
      ++ checkForZero(p, a, b, incl?) is true if p has a zero between
      ++ a and b, false otherwise, "failed" if this cannot be determined.
      ++ Check for a and b inclusive if incl? is true, exclusive otherwise.

  Implementation ==> add
    import RealZeroPackage UPZ
    import InnerPolySign(F, UP)
    import ElementaryFunctionSign(R, F)
    import PowerSeriesLimitPackage(R, F)
    import UnivariatePolynomialCommonDenominator(Z, Q, UPQ)

    mkLogPos    : F -> F
    keeprec?    : (Q, REC) -> B
    negative    : F -> Union(B, "failed")
    mkKerPos    : K -> Union(F, "positive")
    posRoot     : (UP, B) -> Union(B, "failed")
    realRoot    : UP -> Union(B, "failed")
    var         : UP -> Union(Z, "failed")
    maprat      : UP -> Union(UPZ, "failed")
    variation   : (UP, F) -> Union(Z, "failed")
    infeval     : (UP, OFE) -> Union(F, "failed")
    checkHalfAx : (UP, F, Z, B) -> Union(B, "failed")
    findLimit   : (F, K, OFE, String, B) -> Union(OFE, "failed")
    checkBudan  : (UP, OFE, OFE, B) -> Union(B, "failed")
    checkDeriv  : (UP, OFE, OFE) -> Union(B, "failed")
    sameSign    : (UP, OFE, OFE) -> Union(B, "failed")
    intrat      : (OFE, OFE) -> U
    findRealZero: (UPZ, U, B) -> List REC

    variation(p, a)      == var p(monomial(1, 1)$UP - a::UP)
    keeprec?(a, rec)     == (a > rec.right) or (a < rec.left)

    checkHalfAx(p, a, d, incl?) ==
      posRoot(p(d * (monomial(1, 1)$UP - a::UP)), incl?)

    ignore? str ==
      str = IGNOR => true
      error "integrate: last argument must be 'noPole'"

    computeInt(k, f, a, b, eval?) ==
      is?(f, "integral"::SE) => "failed"
      if not eval? then f := mkLogPos f
      ((ib := findLimit(f, k, b, "left", eval?)) case "failed") or
          ((ia := findLimit(f, k, a, "right", eval?)) case "failed") => "failed"
      infinite?(ia::OFE) and (ia::OFE = ib::OFE) => "failed"
      ib::OFE - ia::OFE

    findLimit(f, k, a, dir, eval?) ==
      r := retractIfCan(a)@Union(F, "failed")
      r case F =>
        eval? => mkLogPos(eval(f, k, r::F))::OFE
        (u := limit(f, equation(k::F, r::F), dir)) case OFE => u::OFE
        "failed"
      (u := limit(f, equation(k::F::OFE, a))) case OFE => u::OFE
      "failed"

    mkLogPos f ==
      lk := empty()$List(K)
      lv := empty()$List(F)
      for k in kernels f | is?(k, "log"::SE) repeat
        if (v := mkKerPos k) case F then
          lk := concat(k, lk)
          lv := concat(v::F, lv)
      eval(f, lk, lv)

    mkKerPos k ==
      (u := negative(f := first argument k)) case "failed" =>
                                                     log(f**2) / (2::F)
      u::B => log(-f)
      "positive"

    negative f ==
      (u := sign f) case "failed" => "failed"
      u::Z < 0

    checkForZero(p, x, a, b, incl?) ==
      checkForZero(
        map(#1::F, univariate(p, x))$SparseUnivariatePolynomialFunctions2(P, F),
            a, b, incl?)

    checkForZero(q, a, b, incl?) ==
      ground? q => false
      (d := maprat q) case UPZ and not((i := intrat(a, b)) case failed) =>
          not empty? findRealZero(d::UPZ, i, incl?)
      (u := checkBudan(q, a, b, incl?)) case "failed" =>
         incl? => checkDeriv(q, a, b)
         "failed"
      u::B

    maprat p ==
      ans:UPQ := 0
      while p ^= 0 repeat
        (r := retractIfCan(c := leadingCoefficient p)@Union(Q,"failed"))
          case "failed"  => return "failed"
        ans := ans + monomial(r::Q, degree p)
        p   := reductum p
      map(numer,(splitDenominator ans).num
         )$SparseUnivariatePolynomialFunctions2(Q, Z)

    intrat(a, b) ==
      (n := whatInfinity a) ^= 0 =>
        (r := retractIfCan(b)@Union(F,"failed")) case "failed" => ["all"]
        (q := retractIfCan(r::F)@Union(Q, "failed")) case "failed" =>
          ["failed"]
        [[q::Q, n]]
      (q := retractIfCan(retract(a)@F)@Union(Q,"failed")) case "failed"
        => ["failed"]
      (n := whatInfinity b) ^= 0 => [[q::Q, n]]
      (t := retractIfCan(retract(b)@F)@Union(Q,"failed")) case "failed"
        => ["failed"]
      [[q::Q, t::Q]]

    findRealZero(p, i, incl?) ==
      i case fin =>
        l := realZeros(p, r := i.fin)
        incl? => l
        select_!(keeprec?(r.left, #1) and keeprec?(r.right, #1), l)
      i case all => realZeros p
      i case halfinf =>
        empty?(l := realZeros p) => empty()
        bounds:REC :=
          i.halfinf.dir > 0 => [i.halfinf.endpoint, "max"/[t.right for t in l]]
          ["min"/[t.left for t in l], i.halfinf.endpoint]
        l := [u::REC for t in l | (u := refine(p, t, bounds)) case REC]
        incl? => l
        select_!(keeprec?(i.halfinf.endpoint, #1), l)
      error "findRealZero: should not happpen"

    checkBudan(p, a, b, incl?) ==
      r := retractIfCan(b)@Union(F, "failed")
      (n := whatInfinity a) ^= 0 =>
        r case "failed" => realRoot p
        checkHalfAx(p, r::F, n, incl?)
      (za? := zero? p(aa := retract(a)@F)) and incl? => true
      (n := whatInfinity b) ^= 0 => checkHalfAx(p, aa, n, incl?)
      (zb? := zero? p(bb := r::F)) and incl? => true
      (va := variation(p, aa)) case "failed" or
                   (vb := variation(p, bb)) case "failed" => "failed"
      m:Z := 0
      if za? then m := inc m
      if zb? then m := inc m
      odd?(v := va::Z - vb::Z) =>          -- p has an odd number of roots
        incl? or even? m => true
--        one? v => false
        (v = 1) => false
        "failed"
      zero? v => false                     -- p has no roots
--      one? m => true                    -- p has an even number > 0 of roots
      (m = 1) => true                     -- p has an even number > 0 of roots
      "failed"

    checkDeriv(p, a, b) ==
      (r := retractIfCan(p)@Union(F, "failed")) case F => zero?(r::F)
      (s := sameSign(p, a, b)) case "failed" => "failed"
      s::B =>                  -- p has the same nonzero sign at a and b
        (u := checkDeriv(differentiate p,a,b)) case "failed" => "failed"
        u::B => "failed"
        false
      true

    realRoot p ==
      (b := posRoot(p, true)) case "failed" => "failed"
      b::B => true
      posRoot(p(p - monomial(1, 1)$UP), true)

    sameSign(p, a, b) ==
      (ea := infeval(p, a)) case "failed" => "failed"
      (eb := infeval(p, b)) case "failed" => "failed"
      (s := sign(ea::F * eb::F)) case "failed" => "failed"
      s::Z > 0

-- returns true if p has a positive root. Include 0 is incl0? is true
    posRoot(p, incl0?) ==
      (z0? := zero?(coefficient(p, 0))) and incl0? => true
      (v := var p) case "failed" => "failed"
      odd?(v::Z) =>            -- p has an odd number of positive roots
        incl0? or not(z0?) => true
--        one?(v::Z) => false
        (v::Z) = 1 => false
        "failed"
      zero?(v::Z) => false     -- p has no positive roots
      z0? => true              -- p has an even number > 0 of positive roots
      "failed"

    infeval(p, a) ==
      zero?(n := whatInfinity a) => p(retract(a)@F)
      (u := signAround(p, n, sign)) case "failed" => "failed"
      u::Z::F

    var q ==
      i:Z := 0
      (lastCoef := negative leadingCoefficient q) case "failed" =>
        "failed"
      while ((q := reductum q) ^= 0) repeat
        (next := negative leadingCoefficient q) case "failed" =>
          return "failed"
        if ((not(lastCoef::B)) and next::B) or
                        ((not(next::B)) and lastCoef::B) then i := i + 1
        lastCoef := next
      i

@
<<DFINTTLS.dotabb>>=
"DFINTTLS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DFINTTLS"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DFINTTLS" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEGRED DegreeReductionPackage}
\pagehead{DegreeReductionPackage}{DEGRED}
\pagepic{ps/v104degreereductionpackage.ps}{DEGRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEGRED DegreeReductionPackage>>=
)abbrev package DEGRED DegreeReductionPackage
++ This package \undocumented{}
DegreeReductionPackage(R1, R2): Cat == Capsule where
    R1: Ring
    R2: Join(IntegralDomain,OrderedSet)
 
    I    ==> Integer
    PI   ==> PositiveInteger
    UP   ==> SparseUnivariatePolynomial
    RE   ==> Expression R2
 
    Cat == with
        reduce:  UP R1    ->  Record(pol: UP R1, deg: PI)
	 	++ reduce(p) \undocumented{}
        expand:  (RE, PI) ->  List RE
		++ expand(f,n) \undocumented{}
 
    Capsule == add
 
 
        degrees(u: UP R1): List Integer ==
            l: List Integer := []
            while u ^= 0 repeat
              l := concat(degree u,l)
              u := reductum u
            l
        reduce(u: UP R1) ==
            g := "gcd"/[d for d in degrees u]
            u := divideExponents(u, g:PI)::(UP R1)
            [u, g:PI]
 
        import Fraction Integer
 
        rootOfUnity(j:I,n:I):RE ==
            j = 0 => 1
            arg:RE := 2*j*pi()/(n::RE)
            cos arg + (-1)**(1/2) * sin arg
 
        expand(s, g) ==
            g = 1 => [s]
            [rootOfUnity(i,g)*s**(1/g) for i in 0..g-1]

@
<<DEGRED.dotabb>>=
"DEGRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEGRED"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"DEGRED" -> "PID"
"DEGRED" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DDFACT DistinctDegreeFactorize}
\pagehead{DistinctDegreeFactorize}{DDFACT}
\pagepic{ps/v104distinctdegreefactorize.ps}{DDFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DDFACT DistinctDegreeFactorize>>=
)abbrev package DDFACT DistinctDegreeFactorize
++ Author: P. Gianni, B.Trager
++ Date Created: 1983
++ Date Last Updated: 22 November 1993
++ Basic Functions: factor, irreducible?
++ Related Constructors: PrimeField, FiniteField
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   Package for the factorization of a univariate polynomial with
++   coefficients in a finite field. The algorithm used is the
++   "distinct degree" algorithm of Cantor-Zassenhaus, modified
++   to use trace instead of the norm and a table for computing
++   Frobenius as suggested by Naudin and Quitte .
    
DistinctDegreeFactorize(F,FP): C == T
  where
   F  : FiniteFieldCategory
   FP : UnivariatePolynomialCategory(F)
 
   fUnion ==> Union("nil", "sqfr", "irred", "prime")
   FFE    ==> Record(flg:fUnion, fctr:FP, xpnt:Integer)
   NNI       == NonNegativeInteger
   Z         == Integer
   fact      == Record(deg : NNI,prod : FP)
   ParFact   == Record(irr:FP,pow:Z)
   FinalFact == Record(cont:F,factors:List(ParFact))
 
   C == with
      factor        :         FP      -> Factored FP
        ++ factor(p) produces the complete factorization of the polynomial p.
      factorSquareFree :         FP      -> Factored FP
        ++ factorSquareFree(p) produces the complete factorization of the 
        ++ square free polynomial p.
      distdfact       :   (FP,Boolean)  -> FinalFact
        ++ distdfact(p,sqfrflag) produces the complete factorization
        ++ of the polynomial p returning an internal data structure.
        ++ If argument sqfrflag is true, the polynomial is assumed square free.
      separateDegrees :         FP      -> List fact
        ++ separateDegrees(p) splits the square free polynomial p into 
        ++ factors each of which is a product of irreducibles of the same degree.
      separateFactors :  List fact  -> List FP
        ++ separateFactors(lfact) takes the list produced by 
        ++ \spadfunFrom{separateDegrees}{DistinctDegreeFactorization}
        ++ and produces the complete list of factors.
      exptMod         :   (FP,NNI,FP)   -> FP
        ++ exptMod(u,k,v) raises the polynomial u to the kth power
        ++ modulo the polynomial v.
      trace2PowMod     :   (FP,NNI,FP)   -> FP
        ++ trace2PowMod(u,k,v) produces the sum of \spad{u**(2**i)} for i running
        ++ from 1 to k all computed modulo the polynomial v.
      tracePowMod     :   (FP,NNI,FP)   -> FP
        ++ tracePowMod(u,k,v) produces the sum of \spad{u**(q**i)} 
        ++ for i running and q= size F
      irreducible?    :         FP      -> Boolean
        ++ irreducible?(p) tests whether the polynomial p is irreducible.
 
 
   T == add
      --declarations
      D:=ModMonic(F,FP)
      import UnivariatePolynomialSquareFree(F,FP)
 
      --local functions
      notSqFr : (FP,FP -> List(FP)) -> List(ParFact)
      ddffact : FP -> List(FP)
      ddffact1 : (FP,Boolean) -> List fact
      ranpol :         NNI       -> FP
      
      charF : Boolean := characteristic()$F = 2

      --construct a random polynomial of random degree < d
      ranpol(d:NNI):FP ==
        k1: NNI := 0
        while k1 = 0 repeat k1 := random d
        -- characteristic F = 2
        charF =>
           u:=0$FP
           for j in 1..k1 repeat u:=u+monomial(random()$F,j)
           u
        u := monomial(1,k1)
        for j in 0..k1-1 repeat u:=u+monomial(random()$F,j)
        u
 
      notSqFr(m:FP,appl: FP->List(FP)):List(ParFact) ==
        factlist : List(ParFact) :=empty()
        llf : List FFE
        fln :List(FP) := empty()
        if (lcm:=leadingCoefficient m)^=1 then m:=(inv lcm)*m
        llf:= factorList(squareFree(m))
        for lf in llf repeat
          d1:= lf.xpnt
          pol := lf.fctr
          if (lcp:=leadingCoefficient pol)^=1 then pol := (inv lcp)*pol
          degree pol=1 => factlist:=cons([pol,d1]$ParFact,factlist)
          fln := appl(pol)
          factlist :=append([[pf,d1]$ParFact for pf in fln],factlist)
        factlist
 
      -- compute u**k mod v (requires call to setPoly of multiple of v)
      -- characteristic not equal 2
      exptMod(u:FP,k:NNI,v:FP):FP == (reduce(u)$D**k):FP rem v
 
      -- compute u**k mod v (requires call to setPoly of multiple of v)
      -- characteristic equal 2
      trace2PowMod(u:FP,k:NNI,v:FP):FP ==
        uu:=u
        for i in 1..k repeat uu:=(u+uu*uu) rem v
        uu

      -- compute u+u**q+..+u**(q**k) mod v 
      -- (requires call to setPoly of multiple of v) where q=size< F
      tracePowMod(u:FP,k:NNI,v:FP):FP ==
        u1 :D :=reduce(u)$D
        uu : D := u1
        for i in 1..k repeat uu:=(u1+frobenius uu) 
        (lift uu) rem v

      -- compute u**(1+q+..+q**k) rem v where q=#F 
      -- (requires call to setPoly of multiple of v)
      -- frobenius map is used
      normPowMod(u:FP,k:NNI,v:FP):FP ==
        u1 :D :=reduce(u)$D
        uu : D := u1
        for i in 1..k repeat uu:=(u1*frobenius uu) 
        (lift uu) rem v
 
      --find the factorization of m as product of factors each containing
      --terms of equal degree .
      -- if testirr=true the function returns the first factor found
      ddffact1(m:FP,testirr:Boolean):List(fact) ==
        p:=size$F
        dg:NNI :=0
        ddfact:List(fact):=empty()
        --evaluation of x**p mod m
        k1:NNI
        u:= m
        du := degree u
        setPoly u
        mon: FP := monomial(1,1)
        v := mon
        for k1 in 1.. while k1 <= (du quo 2) repeat
            v := lift frobenius reduce(v)$D
            g := gcd(v-mon,u)
            dg := degree g
            dg =0  => "next k1"
            if leadingCoefficient g ^=1 then g := (inv leadingCoefficient g)*g
            ddfact := cons([k1,g]$fact,ddfact)
            testirr => return ddfact
            u := u quo g
            du := degree u
            du = 0 => return ddfact
            setPoly u
        cons([du,u]$fact,ddfact)
 
      -- test irreducibility
      irreducible?(m:FP):Boolean ==
        mf:fact:=first ddffact1(m,true)
        degree m = mf.deg
 
      --export ddfact1
      separateDegrees(m:FP):List(fact) == ddffact1(m,false)
 
      --find the complete factorization of m, using the result of ddfact1
      separateFactors(distf : List fact) :List FP ==
        ddfact := distf
        n1:Integer
        p1:=size()$F
        if charF then n1:=length(p1)-1
        newaux,aux,ris : List FP
        ris := empty()
        t,fprod : FP
        for ffprod in ddfact repeat
          fprod := ffprod.prod
          d := ffprod.deg
          degree fprod = d => ris := cons(fprod,ris)
          aux:=[fprod]
          setPoly fprod
          while ^(empty? aux) repeat
            t := ranpol(2*d)
            if charF then t:=trace2PowMod(t,(n1*d-1)::NNI,fprod)
            else t:=exptMod(tracePowMod(t,(d-1)::NNI,fprod),
                                     (p1 quo 2)::NNI,fprod)-1$FP
            newaux:=empty()
            for u in aux repeat
                g := gcd(u,t)
                dg:= degree g
                dg=0 or dg = degree u => newaux:=cons(u,newaux)
                v := u quo g
                if dg=d then ris := cons(inv(leadingCoefficient g)*g,ris)
                        else newaux := cons(g,newaux)
                if degree v=d then ris := cons(inv(leadingCoefficient v)*v,ris)
                              else newaux := cons(v,newaux)
            aux:=newaux
        ris
 
      --distinct degree algorithm for monic ,square-free polynomial
      ddffact(m:FP):List(FP)==
        ddfact:=ddffact1(m,false)
        empty? ddfact => [m]
        separateFactors ddfact
 
      --factorize a general polynomial with distinct degree algorithm
      --if test=true no check is executed on square-free
      distdfact(m:FP,test:Boolean):FinalFact ==
        factlist: List(ParFact):= empty()
        fln : List(FP) :=empty()
 
        --make m monic
        if (lcm := leadingCoefficient m) ^=1 then m := (inv lcm)*m
 
        --is x**d factor of m?
        if (d := minimumDegree m)>0 then
          m := (monicDivide (m,monomial(1,d))).quotient
          factlist := [[monomial(1,1),d]$ParFact]
        d:=degree m
 
        --is m constant?
        d=0 => [lcm,factlist]$FinalFact
 
        --is m linear?
        d=1 => [lcm,cons([m,d]$ParFact,factlist)]$FinalFact
 
        --m is square-free
        test =>
          fln := ddffact m
          factlist := append([[pol,1]$ParFact for pol in fln],factlist)
          [lcm,factlist]$FinalFact
 
        --factorize the monic,square-free terms
        factlist:= append(notSqFr(m,ddffact),factlist)
        [lcm,factlist]$FinalFact
 
      --factorize the polynomial m
      factor(m:FP) ==
        m = 0 => 0
        flist := distdfact(m,false)
        makeFR(flist.cont::FP,[["prime",u.irr,u.pow]$FFE 
                                 for u in flist.factors])


      --factorize the square free polynomial m
      factorSquareFree(m:FP) ==
        m = 0 => 0
        flist := distdfact(m,true)
        makeFR(flist.cont::FP,[["prime",u.irr,u.pow]$FFE 
                                 for u in flist.factors])

@
<<DDFACT.dotabb>>=
"DDFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DDFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"DDFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCX DrawComplex}
\pagehead{DrawComplex}{DRAWCX}
\pagepic{ps/v104drawcomplex.ps}{DRAWCX}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCX DrawComplex>>=
)abbrev package DRAWCX DrawComplex
++ Description: \axiomType{DrawComplex} provides some facilities
++ for drawing complex functions.
C ==> Complex DoubleFloat
S ==> Segment DoubleFloat
PC ==> Record(rr:SF, th:SF)
INT ==> Integer
SF ==> DoubleFloat
NNI ==> NonNegativeInteger
VIEW3D ==> ThreeDimensionalViewport
ARRAY2 ==> TwoDimensionalArray
 
DrawComplex(): Exports == Implementation where
  Exports == with
    drawComplex: (C -> C,S,S,Boolean) -> VIEW3D
      ++ drawComplex(f,rRange,iRange,arrows?)
      ++ draws a complex function as a height field.
      ++ It uses the complex norm as the height and the complex 
      ++ argument as the color.
      ++ It will optionally draw arrows on the surface indicating the direction
      ++ of the complex value.\newline
      ++ Sample call:
      ++   \spad{f z == exp(1/z)}
      ++   \spad{drawComplex(f, 0.3..3, 0..2*%pi, false)}
      ++ Parameter descriptions:
      ++   f:  the function to draw
      ++   rRange : the range of the real values
      ++   iRange : the range of imaginary values
      ++   arrows? : a flag indicating whether to draw the phase arrows for f
      ++ Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and 
      ++ \axiomFunFrom{setImagSteps}{DrawComplex} to change the
      ++ number of steps used in each direction.
    drawComplexVectorField: (C -> C,S,S) -> VIEW3D
      ++ drawComplexVectorField(f,rRange,iRange)
      ++ draws a complex vector field using arrows on the \spad{x--y} plane.
      ++ These vector fields should be viewed from the top by pressing the
      ++ "XY" translate button on the 3-d viewport control panel.\newline
      ++ Sample call:
      ++    \spad{f z == sin z}
      ++    \spad{drawComplexVectorField(f, -2..2, -2..2)}
      ++ Parameter descriptions:
      ++   f : the function to draw
      ++   rRange : the range of the real values
      ++   iRange : the range of the imaginary values
      ++ Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and 
      ++ \axiomFunFrom{setImagSteps}{DrawComplex} to change the
      ++ number of steps used in each direction.
    setRealSteps: INT -> INT
      ++ setRealSteps(i)
      ++ sets to i the number of steps to use in the real direction 
      ++ when drawing complex functions. Returns i.
    setImagSteps: INT -> INT
      ++ setImagSteps(i)
      ++ sets to i  the number of steps to use in the imaginary direction
      ++ when drawing complex functions. Returns i.
    setClipValue: SF-> SF
      ++ setClipValue(x)
      ++ sets to x the maximum value to plot when drawing complex functions. Returns x.
  Implementation == add
    -- relative size of the arrow head compared to the length of the arrow
    arrowScale : SF := (0.125)::SF
    arrowAngle: SF := pi()-pi()/(20::SF)    -- angle of the arrow head
    realSteps: INT  := 11     -- the number of steps in the real direction
    imagSteps: INT  := 11     -- the number of steps in the imaginary direction
    clipValue: SF  := 10::SF -- the maximum length of a vector to draw
 
 
    -- Add an arrow head to a line segment, which starts at 'p1', ends at 'p2',
    -- has length 'len', and and angle 'arg'.  We pass 'len' and 'arg' as
    -- arguments since thet were already computed by the calling program
    makeArrow(p1:Point SF, p2:Point SF, len: SF, arg:SF):List List Point SF ==
      c1 := cos(arg + arrowAngle) 
      s1 := sin(arg + arrowAngle)
      c2 := cos(arg - arrowAngle) 
      s2 := sin(arg - arrowAngle)
      p3 := point [p2.1 + c1*arrowScale*len, p2.2 + s1*arrowScale*len, 
                   p2.3, p2.4]
      p4 := point [p2.1 + c2*arrowScale*len, p2.2 + s2*arrowScale*len, 
                   p2.3, p2.4]
      [[p1, p2, p3], [p2, p4]]
     
    -- clip a value in the interval (-clip...clip)
    clipFun(x:SF):SF == 
      min(max(x, -clipValue), clipValue)
 
    drawComplex(f, realRange, imagRange, arrows?) ==
      delReal := (hi(realRange) - lo(realRange))/realSteps::SF
      delImag := (hi(imagRange) - lo(imagRange))/imagSteps::SF
      funTable: ARRAY2(PC) := 
         new((realSteps::NNI)+1, (imagSteps::NNI)+1, [0,0]$PC)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        for j in 1..imagSteps+1 repeat
          z := f complex(real, imag)
          funTable(i,j) := [clipFun(sqrt norm z), argument(z)]$PC
          imag := imag + delImag
        real := real + delReal
      llp := empty()$(List List Point SF)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        lp := empty()$(List Point SF)
        for j in 1..imagSteps+1 repeat
          p := point [real, imag, funTable(i,j).rr, funTable(i,j).th]
          lp := cons(p, lp)
          imag := imag + delImag
        real := real + delReal
        llp := cons(lp, llp)
      space := mesh(llp)$(ThreeSpace SF)
      if arrows? then 
        real := lo(realRange)
        for i in 1..realSteps+1 repeat
          imag := lo(imagRange)
          for j in 1..imagSteps+1 repeat
            arg := funTable(i,j).th
            p1 := point [real,imag, funTable(i,j).rr, arg]
            len := delReal*2.0::SF
            p2 := point [p1.1 + len*cos(arg), p1.2 + len*sin(arg), 
                         p1.3, p1.4]
            arrow := makeArrow(p1, p2, len, arg)
            for a in arrow repeat curve(space, a)$(ThreeSpace SF)
            imag := imag + delImag
          real := real + delReal
      makeViewport3D(space, "Complex Function")$VIEW3D
 
    drawComplexVectorField(f, realRange, imagRange): VIEW3D ==
      -- compute the steps size of the grid
      delReal := (hi(realRange) - lo(realRange))/realSteps::SF
      delImag := (hi(imagRange) - lo(imagRange))/imagSteps::SF
      -- create the space to hold the arrows
      space := create3Space()$(ThreeSpace SF)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        for j in 1..imagSteps+1 repeat
          -- compute the function
          z := f complex(real, imag)
          -- get the direction of the arrow
          arg := argument z
          -- get the length of the arrow
          len := clipFun(sqrt norm z)
          -- create point at the base of the arrow
          p1 :=  point [real, imag, 0::SF, arg]
          -- scale the arrow length so it isn't too long
          scaleLen := delReal * len
          -- create the point at the top of the arrow
          p2 := point [p1.1 + scaleLen*cos(arg), p1.2 + scaleLen*sin(arg), 
                       0::SF, arg]
          -- make the pointer at the top of the arrow
          arrow := makeArrow(p1, p2, scaleLen, arg)
          -- add the line segments in the arrow to the space
          for a in arrow repeat curve(space, a)$(ThreeSpace SF)
          imag := imag + delImag
        real := real + delReal
      -- draw the vector feild
      makeViewport3D(space, "Complex Vector Field")$VIEW3D
 
    -- set the number of steps to use in the real direction
    setRealSteps(n) ==
      realSteps := n
     
    -- set the number of steps to use in the imaginary direction
    setImagSteps(n) ==
      imagSteps := n
     
    -- set the maximum value to plot 
    setClipValue clip ==
      clipValue := clip

@
<<DRAWCX.dotabb>>=
"DRAWCX" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCX"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"DRAWCX" -> "FIELD"
"DRAWCX" -> "RADCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DROPT0 DrawOptionFunctions0}
\pagehead{DrawOptionFunctions0}{DROPT0}
\pagepic{ps/v104drawoptionfunctions0.ps}{DROPT0}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DROPT0 DrawOptionFunctions0>>=
)abbrev package DROPT0 DrawOptionFunctions0
-- The functions here are not in DrawOptions since they are not
-- visible to the interpreter.
++ This package \undocumented{}
DrawOptionFunctions0(): Exports == Implementation where
 RANGE ==> List Segment Float
 UNIT  ==> List Float
 PAL   ==> Palette
 POINT ==> Point(DoubleFloat)
 SEG   ==> Segment Float
 SF     ==> DoubleFloat
 SPACE3 ==> ThreeSpace(DoubleFloat)
 VIEWPT ==> Record( theta:SF, phi:SF, scale:SF, scaleX:SF, scaleY:SF, scaleZ:SF, deltaX:SF, deltaY:SF )

 Exports ==> with
  adaptive: (List DrawOption, Boolean) -> Boolean
    ++ adaptive(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{adaptive}.
    ++ If the option does not exist the value, b is returned.
  clipBoolean: (List DrawOption, Boolean) -> Boolean
    ++ clipBoolean(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{clipBoolean}.
    ++ If the option does not exist the value, b is returned.
  viewpoint: (List DrawOption, VIEWPT) -> VIEWPT
    ++ viewpoint(l,ls) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{viewpoint}.
    ++ IF the option does not exist, the value ls is returned.
  title: (List DrawOption, String) -> String
    ++ title(l,s) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{title}.
    ++ If the option does not exist the value, s is returned.
  style: (List DrawOption, String) -> String
    ++ style(l,s) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{style}.
    ++ If the option does not exist the value, s is returned.
  toScale: (List DrawOption, Boolean) -> Boolean
    ++ toScale(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{toScale}.
    ++ If the option does not exist the value, b is returned.

  pointColorPalette: (List DrawOption,PAL) -> PAL
    ++ pointColorPalette(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{pointColorPalette}.
    ++ If the option does not exist the value, p is returned.
  curveColorPalette: (List DrawOption,PAL) -> PAL
    ++ curveColorPalette(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{curveColorPalette}.
    ++ If the option does not exist the value, p is returned.

  ranges: (List DrawOption, RANGE) -> RANGE
    ++ ranges(l,r) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{ranges}.
    ++ If the option does not exist the value, r is returned.
  var1Steps: (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ var1Steps(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{var1Steps}.
    ++ If the option does not exist the value, n is returned.
  var2Steps: (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ var2Steps(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{var2Steps}.
    ++ If the option does not exist the value, n is returned.
  space: (List DrawOption) -> SPACE3
    ++ space(l) takes a list of draw options, l, and checks to see
    ++ if it contains the option \spad{space}.  If the the option
    ++ doesn't exist, then an empty space is returned.
  tubePoints : (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ tubePoints(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{tubePoints}.
    ++ If the option does not exist the value, n is returned.
  tubeRadius : (List DrawOption, Float) -> Float
    ++ tubeRadius(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{tubeRadius}.
    ++ If the option does not exist the value, n is returned.
  coord: (List DrawOption, (POINT->POINT)) -> (POINT->POINT)
    ++ coord(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{coord}.
    ++ If the option does not exist the value, p is returned.
  units: (List DrawOption, UNIT) -> UNIT
    ++ units(l,u) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{unit}.
    ++ If the option does not exist the value, u is returned.

 Implementation ==> add
  adaptive(l,s) ==
    (u := option(l, "adaptive"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  clipBoolean(l,s) ==
    (u := option(l, "clipBoolean"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  title(l, s) ==
    (u := option(l, "title"::Symbol)$DrawOptionFunctions1(String))
      case "failed" => s
    u::String

  viewpoint(l, vp) ==
    (u := option(l, "viewpoint"::Symbol)$DrawOptionFunctions1(VIEWPT))
      case "failed" => vp
    u::VIEWPT

  style(l, s) ==
    (u := option(l, "style"::Symbol)$DrawOptionFunctions1(String))
      case "failed" => s
    u::String

  toScale(l,s) ==
    (u := option(l, "toScale"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  pointColorPalette(l,s) ==
    (u := option(l, "pointColorPalette"::Symbol)$DrawOptionFunctions1(PAL))
      case "failed" => s
    u::PAL

  curveColorPalette(l,s) ==
    (u := option(l, "curveColorPalette"::Symbol)$DrawOptionFunctions1(PAL))
      case "failed" => s
    u::PAL



  ranges(l, s) ==
    (u := option(l, "ranges"::Symbol)$DrawOptionFunctions1(RANGE))
      case "failed" => s
    u::RANGE

  space(l) ==
    (u := option(l, "space"::Symbol)$DrawOptionFunctions1(SPACE3))
      case "failed" => create3Space()$SPACE3
    u::SPACE3

  var1Steps(l,s) ==
    (u := option(l, "var1Steps"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  var2Steps(l,s) ==
    (u := option(l, "var2Steps"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  tubePoints(l,s) ==
    (u := option(l, "tubePoints"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  tubeRadius(l,s) ==
    (u := option(l, "tubeRadius"::Symbol)$DrawOptionFunctions1(Float))
      case "failed" => s
    u::Float

  coord(l,s) ==
    (u := option(l, "coord"::Symbol)$DrawOptionFunctions1(POINT->POINT))
      case "failed" => s
    u::(POINT->POINT)

  units(l,s) ==
    (u := option(l, "unit"::Symbol)$DrawOptionFunctions1(UNIT))
      case "failed" => s
    u::UNIT

@
<<DROPT0.dotabb>>=
"DROPT0" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DROPT0"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DROPT0" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DROPT1 DrawOptionFunctions1}
\pagehead{DrawOptionFunctions1}{DROPT1}
\pagepic{ps/v104drawoptionfunctions1.ps}{DROPT1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DROPT1 DrawOptionFunctions1>>=
)abbrev package DROPT1 DrawOptionFunctions1
++ This package \undocumented{}
DrawOptionFunctions1(S:Type): Exports == Implementation where
 RANGE ==> List Segment Float
 UNIT  ==> List Float
 PAL   ==> Palette
 POINT ==> Point(DoubleFloat)
 SEG   ==> Segment Float
 SF     ==> DoubleFloat
 SPACE3 ==> ThreeSpace(DoubleFloat)
 VIEWPT ==> Record( theta:SF, phi:SF, scale:SF, scaleX:SF, scaleY:SF, scaleZ:SF, deltaX:SF, deltaY:SF )
 
 Exports ==> with
  option: (List DrawOption, Symbol) -> Union(S, "failed")
    ++ option(l,s) determines whether the indicated drawing option, s,
    ++ is contained in the list of drawing options, l, which is defined
    ++ by the draw command.
 Implementation ==> add
  option(l, s) ==
    (u := option(l, s)@Union(Any, "failed")) case "failed" => "failed"
    retract(u::Any)$AnyFunctions1(S)

@
<<DROPT1.dotabb>>=
"DROPT1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DROPT1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"DROPT1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D01AGNT d01AgentsPackage}
\pagehead{d01AgentsPackage}{D01AGNT}
\pagepic{ps/v104d01agentspackage.ps}{D01AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D01AGNT d01AgentsPackage>>=
)abbrev package D01AGNT d01AgentsPackage
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: rangeIsFinite, functionIsContinuousAtEndPoints,
++ functionIsOscillatory
++ Description:
++ \axiomType{d01AgentsPackage} is a package of numerical agents to be used
++ to investigate attributes of an input function so as to decide the
++ \axiomFun{measure} of an appropriate numerical integration routine.
++ It contains functions \axiomFun{rangeIsFinite} to test the input range and
++ \axiomFun{functionIsContinuousAtEndPoints} to check for continuity at 
++ the end points of the range.


d01AgentsPackage(): E == I where
  EF2	==> ExpressionFunctions2
  EFI	==> Expression Fraction Integer
  FI	==> Fraction Integer
  LEDF	==> List Expression DoubleFloat
  KEDF	==> Kernel Expression DoubleFloat
  EEDF	==> Equation Expression DoubleFloat
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  F	==> Float
  ST	==> String
  LST	==> List String
  SI	==> SingleInteger
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat
  OCEDF	==> OrderedCompletion Expression DoubleFloat
  EOCEFI  ==> Equation OrderedCompletion Expression Fraction Integer
  OCEFI   ==> OrderedCompletion Expression Fraction Integer
  OCFI    ==> OrderedCompletion Fraction Integer
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  CTYPE	==> Union(continuous: "Continuous at the end points",
             lowerSingular: "There is a singularity at the lower end point",
              upperSingular: "There is a singularity at the upper end point",
               bothSingular: "There are singularities at both end points",
                notEvaluated: "End point continuity not yet evaluated")
  RTYPE	==> Union(finite: "The range is finite",
              lowerInfinite: "The bottom of range is infinite",
                upperInfinite: "The top of range is infinite",
                  bothInfinite: "Both top and bottom points are infinite",
                    notEvaluated: "Range not yet evaluated")
  STYPE	==> Union(str:SDF,
                   notEvaluated:"Internal singularities not yet evaluated")
  ATT	==> Record(endPointContinuity:CTYPE,
                    singularitiesStream:STYPE,range:RTYPE)
  ROA	==> Record(key:NIA,entry:ATT)

  E ==> with
    
    rangeIsFinite : NIA -> RTYPE
      ++ rangeIsFinite(args) tests the endpoints of \spad{args.range} for 
      ++ infinite end points. 
    functionIsContinuousAtEndPoints: NIA -> CTYPE
      ++ functionIsContinuousAtEndPoints(args) uses power series limits
      ++ to check for problems at the end points of the range of \spad{args}.
    getlo : SOCDF -> DF
      ++ getlo(x) gets the \axiomType{DoubleFloat} equivalent of
      ++ the first endpoint of the range \axiom{x}
    gethi : SOCDF -> DF
      ++ gethi(x) gets the \axiomType{DoubleFloat} equivalent of
      ++ the second endpoint of the range \axiom{x}
    functionIsOscillatory:NIA -> F
      ++ functionIsOscillatory(a) tests whether the function \spad{a.fn}
      ++ has many zeros of its derivative.
    problemPoints: (EDF, Symbol, SOCDF) -> List DF
      ++ problemPoints(f,var,range) returns a list of possible problem points
      ++ by looking at the zeros of the denominator of the function if it
      ++ can be retracted to \axiomType{Polynomial DoubleFloat}.
    singularitiesOf:NIA -> SDF
      ++ singularitiesOf(args) returns a list of potential 
      ++ singularities of the function within the given range
    df2st:DF -> String 
      ++ df2st(n) coerces a \axiomType{DoubleFloat} to \axiomType{String}
    ldf2lst:LDF -> LST
      ++ ldf2lst(ln) coerces a List of \axiomType{DoubleFloat} to 
      ++ \axiomType{List String}
    sdf2lst:SDF -> LST
      ++ sdf2lst(ln) coerces a Stream of \axiomType{DoubleFloat} to 
      ++ \axiomType{List String}
    commaSeparate:LST -> ST
      ++ commaSeparate(l) produces a comma separated string from a 
      ++ list of strings.
    changeName:(Symbol,Symbol,Result) -> Result
      ++ changeName(s,t,r) changes the name of item \axiom{s} in \axiom{r}
      ++ to \axiom{t}.

  I ==> ExpertSystemContinuityPackage add

    import ExpertSystemToolsPackage
    import ExpertSystemContinuityPackage

    -- local functions
    ocdf2ocefi : OCDF -> OCEFI
    rangeOfArgument : (KEDF, NIA) -> DF
    continuousAtPoint? : (EFI,EOCEFI) -> Boolean
    rand:(SOCDF,INT) -> LDF 
    eval:(EDF,Symbol,LDF) -> LDF
    numberOfSignChanges:LDF -> INT
    rangeIsFiniteFunction:NIA -> RTYPE
    functionIsContinuousAtEndPointsFunction:NIA -> CTYPE
 
    changeName(s:Symbol,t:Symbol,r:Result):Result ==
      a := remove!(s,r)$Result
      a case Any =>
        insert!([t,a],r)$Result
        r
      r

    commaSeparate(l:LST):ST ==
      empty?(l)$LST => ""
--      one?(#(l)) => concat(l)$ST
      (#(l) = 1) => concat(l)$ST
      f := first(l)$LST
      t := [concat([", ",l.i])$ST for i in 2..#(l)]
      concat(f,concat(t)$ST)$ST

    rand(seg:SOCDF,n:INT):LDF ==
      -- produced a sorted list of random numbers in the given range
      l:DF := getlo seg
      s:DF := (gethi seg) - l
      seed:INT := random()$INT
      dseed:DF := seed :: DF
      r:LDF := [(((random(seed)$INT) :: DF)*s/dseed + l) for i in 1..n]
      sort(r)$LDF

    eval(f:EDF,var:Symbol,l:LDF):LDF ==
      empty?(l)$LDF => [0$DF]
      ve := var::EDF
      [retract(eval(f,equation(ve,u::EDF)$EEDF)$EDF)@DF for u in l]

    numberOfSignChanges(l:LDF):INT ==
      -- calculates the number of sign changes in a list
      a := 0$INT
      empty?(l)$LDF => 0
      for i in 2..# l repeat
        if negative?(l.i*l.(i-1))  then
          a := a + 1
      a

    rangeOfArgument(k: KEDF, args:NIA): DF ==
      Args := copy args
      Args.fn := arg := first(argument(k)$KEDF)$LEDF
      functionIsContinuousAtEndPoints(Args) case continuous =>
        r:SOCDF := args.range
        low:EDF := (getlo r) :: EDF
        high:EDF := (gethi r) :: EDF
        eql := equation(a := args.var :: EDF, low)$EEDF
        eqh := equation(a, high)$EEDF
        e1 := (numeric(eval(arg,eql)$EDF)$Numeric(DF)) :: DF
        e2 := (numeric(eval(arg,eqh)$EDF)$Numeric(DF)) :: DF
        e2-e1
      0$DF

    ocdf2ocefi(r:OCDF):OCEFI ==
      finite?(r)$OCDF => (edf2efi(((retract(r)@DF)$OCDF)::EDF))::OCEFI
      r pretend OCEFI

    continuousAtPoint?(f:EFI,e:EOCEFI):Boolean ==
      (l := limit(f,e)$PowerSeriesLimitPackage(FI,EFI)) case OCEFI =>
                       finite?(l :: OCEFI)
      -- if the left hand limit equals the right hand limit, or if neither
      -- side has a limit at this point, the return type of  limit() is
      -- Union(Ordered Completion Expression Fraction Integer,"failed")
      false

    -- exported functions
    
    rangeIsFiniteFunction(args:NIA): RTYPE ==
      -- rangeIsFinite(x) tests the endpoints of x.range for infinite
      -- end points. 
      --             [-inf,  inf]  =>  4
      --             [ x  ,  inf]  =>  3
      --             [-inf,  x  ]  =>  1
      --             [ x  ,  y  ]  =>  0
      fr:SI := (3::SI * whatInfinity(hi(args.range))$OCDF 
                      - whatInfinity(lo(args.range))$OCDF)
      fr = 0 => ["The range is finite"]
      fr = 1 => ["The bottom of range is infinite"]
      fr = 3 => ["The top of range is infinite"]
      fr = 4 => ["Both top and bottom points are infinite"]
      error("rangeIsFinite",["this is not a valid range"])$ErrorFunctions

    rangeIsFinite(args:NIA): RTYPE ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        s.range case notEvaluated => 
          s.range := rangeIsFiniteFunction(nia)
          r:ROA := [nia,s]
          insert!(r)$IntegrationFunctionsTable
          s.range
        s.range
      a:ATT := [["End point continuity not yet evaluated"],
                  ["Internal singularities not yet evaluated"],
                      e:=rangeIsFiniteFunction(nia)]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

    functionIsContinuousAtEndPointsFunction(args:NIA):CTYPE ==

      v := args.var :: EFI :: OCEFI
      high:OCEFI := ocdf2ocefi(hi(args.range))
      low:OCEFI := ocdf2ocefi(lo(args.range))
      f := edf2efi(args.fn)
      l:Boolean := continuousAtPoint?(f,equation(v,low)$EOCEFI)
      h:Boolean := continuousAtPoint?(f,equation(v,high)$EOCEFI)
      l and h => ["Continuous at the end points"]
      l => ["There is a singularity at the upper end point"]
      h => ["There is a singularity at the lower end point"]
      ["There are singularities at both end points"]

    functionIsContinuousAtEndPoints(args:NIA): CTYPE ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        s.endPointContinuity case notEvaluated => 
          s.endPointContinuity := functionIsContinuousAtEndPointsFunction(nia)
          r:ROA := [nia,s]
          insert!(r)$IntegrationFunctionsTable
          s.endPointContinuity
        s.endPointContinuity
      a:ATT := [e:=functionIsContinuousAtEndPointsFunction(nia),
                 ["Internal singularities not yet evaluated"],
                   ["Range not yet evaluated"]]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

    functionIsOscillatory(a:NIA):F ==

      args := copy a
      k := tower(numerator args.fn)$EDF
      p:F := pi()$F
      for i in 1..# k repeat
        is?(ker := k.i, sin :: Symbol) => 
          ra := convert(rangeOfArgument(ker,args))@F
          ra > 2*p => return (ra/p)
        is?(ker, cos :: Symbol) => 
          ra := convert(rangeOfArgument(ker,args))@F
          ra > 2*p => return (ra/p)
      l:LDF := rand(args.range,30)
      l := eval(args.fn,args.var,l)
      numberOfSignChanges(l) :: F   

    singularitiesOf(args:NIA):SDF ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s:ATT := coerce(t)@ATT
        p:STYPE := s.singularitiesStream
        p case str => p.str
        e:SDF := singularitiesOf(nia.fn,[nia.var],nia.range)
        if not empty?(e) then
          if less?(e,10)$SDF then extend(e,10)$SDF
        s.singularitiesStream := [e]
        r:ROA := [nia,s]
        insert!(r)$IntegrationFunctionsTable
        e
      e:=singularitiesOf(nia.fn,[nia.var],nia.range)
      if not empty?(e) then
        if less?(e,10)$SDF then extend(e,10)$SDF
      a:ATT := [["End point continuity not yet evaluated"],[e],
                          ["Range not yet evaluated"]]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

@
<<D01AGNT.dotabb>>=
"D01AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D01AGNT"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D01AGNT" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D01WGTS d01WeightsPackage}
\pagehead{d01WeightsPackage}{D01WGTS}
\pagepic{ps/v104d01weightspackage.ps}{D01WGTS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D01WGTS d01WeightsPackage>>=
)abbrev package D01WGTS d01WeightsPackage
++ Author: Brian Dupee
++ Date Created: July 1994
++ Date Last Updated: January 1998 (Bug fix - exprHasListOfWeightsCosWXorSinWX)
++ Basic Operations: exprHasWeightCosWXorSinWX, exprHasAlgebraicWeight, 
++ exprHasLogarithmicWeights
++ Description:
++ \axiom{d01WeightsPackage} is a package for functions used to investigate
++ whether a function can be divided into a simpler function and a weight
++ function.  The types of weights investigated are those giving rise to
++ end-point singularities of the algebraico-logarithmic type, and 
++ trigonometric weights.
d01WeightsPackage(): E == I where
  LEDF	==> List Expression DoubleFloat
  KEDF	==> Kernel Expression DoubleFloat
  LKEDF	==> List Kernel Expression DoubleFloat
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  FI	==> Fraction Integer
  LDF	==> List DoubleFloat
  DF	==> DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  URBODF	==> Union(Record(op:BasicOperator,w:DF),"failed")
  LURBODF	==> List(Union(Record(op:BasicOperator,w:DF), "failed"))
 
  E ==> with
    exprHasWeightCosWXorSinWX:NIA -> URBODF 
      ++ \axiom{exprHasWeightCosWXorSinWX} looks for trigonometric
      ++ weights in an expression of the form \axiom{cos \omega x} or
      ++ \axiom{sin \omega x}, returning the value of \omega 
      ++ (\notequal 1) and the operator. 
    exprHasAlgebraicWeight:NIA -> Union(LDF,"failed")
      ++ \axiom{exprHasAlgebraicWeight} looks for algebraic weights
      ++ giving rise to singularities of the function at the end-points.
    exprHasLogarithmicWeights:NIA -> INT
      ++ \axiom{exprHasLogarithmicWeights} looks for logarithmic weights
      ++ giving rise to singularities of the function at the end-points.
 
 
    
  I ==> add
    score:(EDF,EDF) -> FI
    kernelIsLog:KEDF -> Boolean 
    functionIsPolynomial?:EDF -> Boolean
    functionIsNthRoot?:(EDF,EDF) -> Boolean 
    functionIsQuotient:EDF -> Union(EDF,"failed")
    findCommonFactor:LEDF -> Union(LEDF,"failed")
    findAlgebraicWeight:(NIA,EDF) -> Union(DF,"failed")
    exprHasListOfWeightsCosWXorSinWX:(EDF,Symbol) -> LURBODF
    exprOfFormCosWXorSinWX:(EDF,Symbol) -> URBODF
    bestWeight:LURBODF -> URBODF
    weightIn?:(URBODF,LURBODF) -> Boolean
    inRest?:(EDF,LEDF)->Boolean
    factorIn?:(EDF,LEDF)->Boolean
    voo?:(EDF,EDF)->Boolean
   
    kernelIsLog(k:KEDF):Boolean ==
      (name k = (log :: Symbol))@Boolean
 
    factorIn?(a:EDF,l:LEDF):Boolean ==
      for i in 1..# l repeat
        (a = l.i)@Boolean => return true
      false
 
    voo?(b:EDF,a:EDF):Boolean ==
       (voo:=isTimes(b)) case LEDF and factorIn?(a,voo)
 
    inRest?(a:EDF,l:LEDF):Boolean ==
      every?( voo?(#1,a) ,l)
 
    findCommonFactor(l:LEDF):Union(LEDF,"failed") ==
      empty?(l)$LEDF => "failed"
      f := first(l)$LEDF
      r := rest(l)$LEDF
      (t := isTimes(f)$EDF) case LEDF =>
        pos:=select(inRest?(#1,r),t)
        empty?(pos) => "failed"
        pos
      "failed"
 
    exprIsLogarithmicWeight(f:EDF,Var:EDF,a:EDF,b:EDF):INT ==
      ans := 0$INT
      k := tower(f)$EDF
      lf := select(kernelIsLog,k)$LKEDF
      empty?(lf)$LKEDF => ans
      for i in 1..# lf repeat
        arg := argument lf.i
        if (arg.1 = (Var - a)) then
          ans := ans + 1
        else if (arg.1 = (b - Var)) then
          ans := ans + 2
      ans      
 
    exprHasLogarithmicWeights(args:NIA):INT ==
      ans := 1$INT
      a := getlo(args.range)$d01AgentsPackage :: EDF
      b := gethi(args.range)$d01AgentsPackage :: EDF
      Var := args.var :: EDF
      (l := isPlus numerator args.fn) case LEDF =>
        (cf := findCommonFactor l) case LEDF =>
          for j in 1..# cf repeat
            ans := ans + exprIsLogarithmicWeight(cf.j,Var,a,b)
          ans
        ans
      ans := ans + exprIsLogarithmicWeight(args.fn,Var,a,b)
 
    functionIsQuotient(expr:EDF):Union(EDF,"failed") ==
      (k := mainKernel expr) case KEDF =>
        expr = inv(f := k :: KEDF :: EDF)$EDF => f
--        one?(numerator expr) => denominator expr
        (numerator expr = 1) => denominator expr
        "failed"
      "failed"
 
    functionIsPolynomial?(f:EDF):Boolean ==
      (retractIfCan(f)@Union(PDF,"failed"))$EDF case PDF
 
    functionIsNthRoot?(f:EDF,e:EDF):Boolean ==
      (m := mainKernel f) case "failed" => false
--      (one?(# (kernels f))) 
      ((# (kernels f)) = 1) 
        and (name operator m = (nthRoot :: Symbol))@Boolean
          and (((argument m).1 = e)@Boolean)
 
    score(f:EDF,e:EDF):FI ==
      ans := 0$FI
      (t := isTimes f) case LEDF =>
        for i in 1..# t repeat
          ans := ans + score(t.i,e)
        ans
      (q := functionIsQuotient f) case EDF =>
        ans := ans - score(q,e)
      functionIsPolynomial? f =>
        g:EDF := f/e
        if functionIsPolynomial? g then
          ans := 1+score(g,e)
        else
          ans 
      (l := isPlus f) case LEDF =>
        (cf := findCommonFactor l) case LEDF =>
          factor := 1$EDF
          for i in 1..# cf repeat
            factor := factor*cf.i
          ans := ans + score(f/factor,e) + score(factor,e)
        ans
      functionIsNthRoot?(f,e) =>
        (p := isPower f) case "failed" => ans
        exp := p.exponent
        m := mainKernel f
        m case KEDF => 
          arg := argument m
          a:INT := (retract(arg.2)@INT)$EDF
          exp / a
        ans
      ans
 
    findAlgebraicWeight(args:NIA,e:EDF):Union(DF,"failed") == 
      zero?(s := score(args.fn,e)) => "failed"
      s :: DF
 
    exprHasAlgebraicWeight(args:NIA):Union(LDF,"failed") ==
      (f := functionIsContinuousAtEndPoints(args)$d01AgentsPackage) 
                                          case continuous =>"failed"
      Var := args.var :: EDF
      a := getlo(args.range)$d01AgentsPackage :: EDF
      b := gethi(args.range)$d01AgentsPackage :: EDF
      A := Var - a
      B := b - Var
      f case lowerSingular => 
        (h := findAlgebraicWeight(args,A)) case "failed" => "failed"
        [h,0] 
      f case upperSingular => 
        (g := findAlgebraicWeight(args,B)) case "failed" => "failed"
        [0,g] 
      h := findAlgebraicWeight(args,A) 
      g := findAlgebraicWeight(args,B)
      r := (h case "failed")
      s := (g case "failed")
      (r) and (s) => "failed"
      r => [0,coerce(g)@DF]
      s => [coerce(h)@DF,0]  
      [coerce(h)@DF,coerce(g)@DF]
 
    exprOfFormCosWXorSinWX(f:EDF,var:Symbol): URBODF ==
      l:LKEDF := kernels(f)$EDF
--      one?((# l)$LKEDF)$INT => 
      # l = 1 => 
        a:LEDF := argument(e:KEDF := first(l)$LKEDF)$KEDF
        empty?(a) => "failed"
        m:Union(LEDF,"failed") := isTimes(first(a)$LEDF)$EDF 
        m case LEDF => -- if it is a list, it will have at least two elements
          is?(second(m)$LEDF,var)$EDF =>
            omega:DF := retract(first(m)$LEDF)@DF
            o:BOP := operator(n:Symbol:=name(e)$KEDF)$BOP
            (n = cos@Symbol)@Boolean => [o,omega]
            (n = sin@Symbol)@Boolean => [o,omega]
            "failed"
          "failed"
        "failed"
      "failed"
 
    exprHasListOfWeightsCosWXorSinWX(f:EDF,var:Symbol): LURBODF ==
      (e := isTimes(f)$EDF) case LEDF => 
        [exprOfFormCosWXorSinWX(u,var) for u in e]
      empty?(k := kernels f) => ["failed"]
      ((first(k)::EDF) = f) => 
        [exprOfFormCosWXorSinWX(f,var)]
      ["failed"]
 
    bestWeight(l:LURBODF): URBODF ==
      empty?(l)$LURBODF => "failed"
      best := first(l)$LURBODF        --  best is first in list
      empty?(rest(l)$LURBODF) => best
      for i in 2..# l repeat          --  unless next is better
        r:URBODF := l.i
        if r case "failed" then leave
        else if best case "failed" then
          best := r
        else if r.w > best.w then
          best := r
      best
 
    weightIn?(weight:URBODF,listOfWeights:LURBODF):Boolean ==
      n := # listOfWeights
      for i in 1..n repeat                               -- cycle through list
        (weight = listOfWeights.i)@Boolean => return true -- return when found
      false
 
    exprHasWeightCosWXorSinWX(args:NIA):URBODF ==
      ans := empty()$LURBODF
      f:EDF := numerator(args.fn)$EDF
      (t:Union(LEDF,"failed") := isPlus(f)) case "failed" => 
        bestWeight(exprHasListOfWeightsCosWXorSinWX(f,args.var))
      if t case LEDF then
        e1 := first(t)$LEDF
        le1:LURBODF := exprHasListOfWeightsCosWXorSinWX(e1,args.var)
        le1 := [u for u in le1 | (not (u case "failed"))]
        empty?(le1)$LURBODF => "failed"
        test := true
        for i in 1..# le1 repeat
          le1i:URBODF := le1.i
          for j in 2..# t repeat
            if test then
              tj:LURBODF := exprHasListOfWeightsCosWXorSinWX(t.j,args.var)
              test := weightIn?(le1i,tj)
          if test then
            ans := concat([le1i],ans)
        bestWeight ans
      else "failed"

@
<<D01WGTS.dotabb>>=
"D01WGTS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D01WGTS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D01WGTS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D02AGNT d02AgentsPackage}
\pagehead{d02AgentsPackage}{D02AGNT}
\pagepic{ps/v104d02agentspackage.ps}{D02AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D02AGNT d02AgentsPackage>>=
)abbrev package D02AGNT d02AgentsPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: January 1997
++ Basic Operations: stiffnessFactor, jacobian
++ Description:
++ \axiom{d02AgentsPackage} contains a set of computational agents 
++ for use with Ordinary Differential Equation solvers.
d02AgentsPackage(): E == I where
  LEDF	==> List Expression DoubleFloat
  LEEDF	==> List Equation Expression DoubleFloat
  EEDF	==> Equation Expression DoubleFloat
  VEDF	==> Vector Expression DoubleFloat
  MEDF	==> Matrix Expression DoubleFloat
  MDF	==> Matrix DoubleFloat
  EDF	==> Expression DoubleFloat
  DF	==> DoubleFloat
  F	==> Float
  INT	==> Integer
  CDF	==> Complex DoubleFloat
  LDF	==> List DoubleFloat
  LF	==> List Float
  S	==> Symbol
  LS	==> List Symbol
  MFI	==> Matrix Fraction Integer
  LFI	==> List Fraction Integer
  FI	==> Fraction Integer
  ODEA	==> Record(xinit:DF,xend:DF,fn:VEDF,yinit:LDF,intvals:LDF,g:EDF,abserr:DF,relerr:DF)
  ON	==> Record(additions:INT,multiplications:INT,exponentiations:INT,functionCalls:INT)
  RVE 	==> Record(val:EDF,exponent:INT)
  RSS	==> Record(stiffnessFactor:F,stabilityFactor:F)
  ATT	==> Record(stiffness:F,stability:F,expense:F,accuracy:F,intermediateResults:F)
  ROA	==> Record(key:ODEA,entry:ATT)

  E ==>  with
    combineFeatureCompatibility: (F,F) -> F
      ++ combineFeatureCompatibility(C1,C2) is for interacting attributes
    combineFeatureCompatibility: (F,LF) -> F
      ++ combineFeatureCompatibility(C1,L) is for interacting attributes
    sparsityIF: MEDF -> F
      ++ sparsityIF(m) calculates the sparsity of a jacobian matrix
    jacobian: (VEDF,LS) -> MEDF
      ++ jacobian(v,w) is a local function to make a jacobian matrix
    eval: (MEDF,LS,VEDF) -> MEDF
      ++ eval(mat,symbols,values) evaluates a multivariable matrix at given values
      ++ for each of a list of variables
    stiffnessAndStabilityFactor: MEDF -> RSS
      ++ stiffnessAndStabilityFactor(me) calculates the stability and
      ++ stiffness factor of a system of first-order differential equations
      ++ (by evaluating the maximum difference in the real parts of the
      ++ negative eigenvalues of the jacobian of the system for which O(10)
      ++ equates to mildly stiff wheras stiffness ratios of O(10^6) are not
      ++ uncommon) and whether the system is likely to show any oscillations
      ++ (identified by the closeness to the imaginary axis of the complex
      ++ eigenvalues of the jacobian).
    stiffnessAndStabilityOfODEIF:ODEA -> RSS
      ++ stiffnessAndStabilityOfODEIF(ode) calculates the intensity values
      ++ of stiffness of a system of first-order differential equations
      ++ (by evaluating the maximum difference in the real parts of the
      ++ negative eigenvalues of the jacobian of the system for which O(10)
      ++ equates to mildly stiff wheras stiffness ratios of O(10^6) are not
      ++ uncommon) and whether the system is likely to show any oscillations
      ++ (identified by the closeness to the imaginary axis of the complex
      ++ eigenvalues of the jacobian).
      ++
      ++ It returns two values in the range [0,1].
    systemSizeIF:ODEA -> F
      ++ systemSizeIF(ode) returns the intensity value of the size of
      ++ the system of ODEs.  20 equations corresponds to the neutral
      ++ value.  It returns a value in the range [0,1].
    expenseOfEvaluationIF:ODEA -> F
      ++ expenseOfEvaluationIF(o) returns the intensity value of the 
      ++ cost of evaluating the input ODE.  This is in terms of the number
      ++ of ``operational units''.  It returns a value in the range
      ++ [0,1].\newline\indent{20}
      ++ 400 ``operation units'' -> 0.75 \newline
      ++ 200 ``operation units'' -> 0.5 \newline
      ++ 83 ``operation units'' -> 0.25 \newline\indent{15}
      ++ exponentiation = 4 units , function calls = 10 units.
    accuracyIF:ODEA -> F
      ++ accuracyIF(o) returns the intensity value of the accuracy
      ++ requirements of the input ODE.  A request of accuracy of 10^-6 
      ++ corresponds to the neutral intensity.  It returns a value
      ++ in the range [0,1].
    intermediateResultsIF:ODEA -> F
      ++ intermediateResultsIF(o) returns a value corresponding to the 
      ++ required number of intermediate results required and, therefore, 
      ++ an indication of how much this would affect the step-length of the 
      ++ calculation.  It returns a value in the range [0,1].

  I ==> add

    import ExpertSystemToolsPackage

    accuracyFactor:ODEA -> F
    expenseOfEvaluation:ODEA -> F
    eval1:(LEDF,LEEDF) -> LEDF
    stiffnessAndStabilityOfODE:ODEA -> RSS
    intermediateResultsFactor:ODEA -> F
    leastStabilityAngle:(LDF,LDF) -> F

    intermediateResultsFactor(ode:ODEA):F ==
      resultsRequirement := #(ode.intvals)
      (1.0-exp(-(resultsRequirement::F)/50.0)$F)

    intermediateResultsIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.intermediateResults)$F => 
          s.intermediateResults := intermediateResultsFactor(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.intermediateResults
        s.intermediateResults
      a:ATT := [-1.0,-1.0,-1.0,-1.0,e:=intermediateResultsFactor(ode)]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    accuracyFactor(ode:ODEA):F ==
      accuracyRequirements := convert(ode.abserr)@F
      if zero?(accuracyRequirements) then
        accuracyRequirements := convert(ode.relerr)@F
      val := inv(accuracyRequirements)$F
      n := log10(val)$F
      (1.0-exp(-(n/(2.0))**2/(15.0))$F)

    accuracyIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.accuracy)$F => 
          s.accuracy := accuracyFactor(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.accuracy
        s.accuracy
      a:ATT := [-1.0,-1.0,-1.0,e:=accuracyFactor(ode),-1.0]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    systemSizeIF(ode:ODEA):F ==
      n := #(ode.fn)
      (1.0-exp((-n::F/75.0))$F)

    expenseOfEvaluation(o:ODEA):F ==
      -- expense of evaluation of an ODE -- <0.3 inexpensive - 0.5 neutral - >0.7 very expensive
      -- 400 `operation units' -> 0.75 
      -- 200 `operation units' -> 0.5 
      -- 83 `operation units' -> 0.25
      -- ** = 4 units , function calls = 10 units.
      ode := copy o.fn
      expenseOfEvaluation(ode)

    expenseOfEvaluationIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.expense)$F => 
          s.expense := expenseOfEvaluation(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.expense
        s.expense
      a:ATT := [-1.0,-1.0,e:=expenseOfEvaluation(ode),-1.0,-1.0]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    leastStabilityAngle(realPartsList:LDF,imagPartsList:LDF):F ==
      complexList := [complex(u,v)$CDF for u in realPartsList for v in imagPartsList]
      argumentList := [abs((abs(argument(u)$CDF)$DF)-(pi()$DF)/2)$DF for u in complexList]
      sortedArgumentList := sort(argumentList)$LDF
      list := [u for u in sortedArgumentList | not zero?(u) ]
      empty?(list)$LDF => 0$F
      convert(first(list)$LDF)@F

    stiffnessAndStabilityFactor(me:MEDF):RSS ==

      -- search first for real eigenvalues of the jacobian (symbolically)
      -- if the system isn't too big
      r:INT := ncols(me)$MEDF  
      b:Boolean := ((# me) < 150)
      if b then
        mc:MFI := map(edf2fi,me)$ExpertSystemToolsPackage2(EDF,FI)
        e:LFI := realEigenvalues(mc,1/100)$NumericRealEigenPackage(FI)
        b := ((# e) >= r-1)@Boolean       
      b =>
        -- if all the eigenvalues are real, find negative ones
        e := sort(neglist(e)$ExpertSystemToolsPackage1(FI))
        -- if there are two or more, calculate stiffness ratio
        ((n:=#e)>1)@Boolean => [coerce(e.1/e.n)@F,0$F] 
        -- otherwise stiffness not present
        [0$F,0$F]

      md:MDF := map(edf2df,me)$ExpertSystemToolsPackage2(EDF,DF)

      -- otherwise calculate numerically the complex eigenvalues
      -- using NAG routine f02aff.

      res:Result := f02aff(r,r,md,-1)$NagEigenPackage
      realParts:Union(Any,"failed") := search(rr::Symbol,res)$Result
      realParts case "failed" => [0$F,0$F]
      realPartsMatrix:MDF := retract(realParts)$AnyFunctions1(MDF) -- array === matrix
      imagParts:Union(Any,"failed") := search(ri::Symbol,res)$Result
      imagParts case "failed" => [0$F,0$F]
      imagPartsMatrix:MDF := retract(imagParts)$AnyFunctions1(MDF) -- array === matrix
      imagPartsList:LDF := members(imagPartsMatrix)$MDF
      realPartsList:LDF := members(realPartsMatrix)$MDF
      stabilityAngle := leastStabilityAngle(realPartsList,imagPartsList)
      negRealPartsList := sort(neglist(realPartsList)$ExpertSystemToolsPackage1(DF))
      empty?(negRealPartsList)$LDF => [0$F,stabilityAngle]
      ((n:=#negRealPartsList)>1)@Boolean => 
        out := convert(negRealPartsList.1/negRealPartsList.n)@F
        [out,stabilityAngle]    -- calculate stiffness ratio
      [-convert(negRealPartsList.1)@F,stabilityAngle]
      
    eval1(l:LEDF,e:LEEDF):LEDF ==
      [eval(u,e)$EDF for u in l]

    eval(mat:MEDF,symbols:LS,values:VEDF):MEDF ==
      l := listOfLists(mat)
      ledf := entries(values)$VEDF
      e := [equation(u::EDF,v)$EEDF for u in symbols for v in ledf]
      l := [eval1(w,e) for w in l]
      matrix l

    combineFeatureCompatibility(C1:F,C2:F):F ==

      --                        C1 C2
      --    s(C1,C2) = -----------------------
      --               C1 C2 + (1 - C1)(1 - C2)

      C1*C2/((C1*C2)+(1$F-C1)*(1$F-C2))

    combineFeatureCompatibility(C1:F,L:LF):F ==

      empty?(L)$LF => C1
      C2 := combineFeatureCompatibility(C1,first(L)$LF)
      combineFeatureCompatibility(C2,rest(L)$LF)

    jacobian(v:VEDF,w:LS):Matrix EDF ==
      jacobian(v,w)$MultiVariableCalculusFunctions(S,EDF,VEDF,LS)

    sparsityIF(m:Matrix EDF):F ==
      l:LEDF :=parts m
      z:LEDF := [u for u in l | zero?(u)$EDF]
      ((#z)::F/(#l)::F)

    sum(a:EDF,b:EDF):EDF == a+b

    stiffnessAndStabilityOfODE(ode:ODEA):RSS ==
      odefns := copy ode.fn
      ls:LS := [subscript(Y,[coerce(n)])$Symbol for n in 1..# odefns]
      yvals := copy ode.yinit
      for i in 1..#yvals repeat
        zero?(yvals.i) => yvals.i := 0.1::DF
      yexpr := [coerce(v)@EDF for v in yvals]
      yv:VEDF := vector(yexpr)
      j1:MEDF := jacobian(odefns,ls)
      ej1:MEDF := eval(j1,ls,yv)
      ej1 := eval(ej1,variables(reduce(sum,members(ej1)$MEDF)),vector([(ode.xinit)::EDF]))
      ssf := stiffnessAndStabilityFactor(ej1)
      stability := 1.0-sqrt((ssf.stabilityFactor)*(2.0)/(pi()$F))
      stiffness := (1.0)-exp(-(ssf.stiffnessFactor)/(500.0))
      [stiffness,stability]

    stiffnessAndStabilityOfODEIF(ode:ODEA):RSS ==
      odefn := copy ode
      (t := showIntensityFunctions(odefn)$ODEIntensityFunctionsTable) case ATT =>
        s:ATT := coerce(t)@ATT
        negative?(s.stiffness)$F => 
          ssf:RSS := stiffnessAndStabilityOfODE(odefn)
          s := [ssf.stiffnessFactor,ssf.stabilityFactor,s.expense,
                  s.accuracy,s.intermediateResults]
          r:ROA := [odefn,s]
          insert!(r)$ODEIntensityFunctionsTable
          ssf
        [s.stiffness,s.stability]
      ssf:RSS := stiffnessAndStabilityOfODE(odefn)
      s:ATT := [ssf.stiffnessFactor,ssf.stabilityFactor,-1.0,-1.0,-1.0]
      r:ROA := [odefn,s]
      insert!(r)$ODEIntensityFunctionsTable
      ssf

@
<<D02AGNT.dotabb>>=
"D02AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D02AGNT"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D02AGNT" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D03AGNT d03AgentsPackage}
\pagehead{d03AgentsPackage}{D03AGNT}
\pagepic{ps/v104d03agentspackage.ps}{D03AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D03AGNT d03AgentsPackage>>=
)abbrev package D03AGNT d03AgentsPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: December 1997
++ Basic Operations: 
++ Description:
++ \axiom{d03AgentsPackage} contains a set of computational agents 
++ for use with Partial Differential Equation solvers.
LEDF	==> List Expression DoubleFloat
EDF	==> Expression DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
F	==> Float
INT	==> Integer
NNI	==> NonNegativeInteger
EEDF	==> Equation Expression DoubleFloat
LEEDF	==> List Equation Expression DoubleFloat
LDF	==> List DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LS	==> List Symbol
PDEC	==> Record(start:DF, finish:DF, grid:NNI, boundaryType:INT,
                    dStart:MDF, dFinish:MDF)
PDEB	==> Record(pde:LEDF, constraints:List PDEC,
                    f:List LEDF, st:String, tol:DF)
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)

d03AgentsPackage(): E == I where
  E ==>  with
    varList:(Symbol,NonNegativeInteger) -> LS
      ++ varList(s,n) \undocumented{}
    subscriptedVariables:EDF -> EDF
      ++ subscriptedVariables(e) \undocumented{}
    central?:(DF,DF,LEDF) -> Boolean
      ++ central?(f,g,l) \undocumented{}
    elliptic?:PDEB -> Boolean    
      ++ elliptic?(r) \undocumented{}

  I ==> add

    import ExpertSystemToolsPackage

    sum(a:EDF,b:EDF):EDF == a+b

    varList(s:Symbol,n:NonNegativeInteger):LS ==
      [subscript(s,[t::OutputForm]) for t in expand([1..n])$Segment(Integer)]

    subscriptedVariables(e:EDF):EDF ==
      oldVars:List Symbol := variables(e)
      o := [a :: EDF for a in oldVars]
      newVars := varList(X::Symbol,# oldVars)
      n := [b :: EDF for b in newVars]
      subst(e,[a=b for a in o for b in n])

    central?(x:DF,y:DF,p:LEDF):Boolean ==
      ls := variables(reduce(sum,p))
      le := [equation(u::EDF,v)$EEDF for u in ls for v in [x::EDF,y::EDF]]
      l := [eval(u,le)$EDF for u in p]
      max(l.4,l.5) < 20 * max(l.1,max(l.2,l.3))

    elliptic?(args:PDEB):Boolean ==
      (args.st)="elliptic" => true
      p := args.pde
      xcon:PDEC := first(args.constraints)
      ycon:PDEC := second(args.constraints)
      xs := xcon.start
      ys := ycon.start
      xf := xcon.finish
      yf := ycon.finish
      xstart:DF := ((xf-xs)/2)$DF
      ystart:DF := ((yf-ys)/2)$DF
      optStart:LDF := [xstart,ystart]
      lower:LOCDF := [xs::OCDF,ys::OCDF]
      upper:LOCDF := [xf::OCDF,yf::OCDF]
      v := variables(e := 4*first(p)*third(p)-(second(p))**2)
      eq := subscriptedVariables(e)
      noa:NOA := 
--        one?(# v) =>
        (# v) = 1 =>
          ((first v) = X@Symbol) => 
            [eq,[xstart],[xs::OCDF],empty()$LEDF,[xf::OCDF]]
          [eq,[ystart],[ys::OCDF],empty()$LEDF,[yf::OCDF]]
        [eq,optStart,lower,empty()$LEDF,upper]
      ell := optimize(noa::NumericalOptimizationProblem)$AnnaNumericalOptimizationPackage
      o:Union(Any,"failed") := search(objf::Symbol,ell)$Result
      o case "failed" => false
      ob := o :: Any
      obj:DF := retract(ob)$AnyFunctions1(DF)
      positive?(obj)

@
<<D03AGNT.dotabb>>=
"D03AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D03AGNT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"D03AGNT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EP EigenPackage}
\pagehead{EigenPackage}{EP}
\pagepic{ps/v104eigenpackage.ps}{EP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EP EigenPackage>>=
)abbrev package EP EigenPackage
++ Author: P. Gianni
++ Date Created: summer 1986
++ Date Last Updated: October 1992
++ Basic Functions:
++ Related Constructors: NumericRealEigenPackage,  NumericComplexEigenPackage,
++ RadicalEigenPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This is a package for the exact computation of eigenvalues and eigenvectors.
++ This package can be made to work for matrices with coefficients which are
++ rational functions over a ring where we can factor polynomials.
++ Rational eigenvalues are always explicitly computed while the
++ non-rational ones are expressed in terms of their minimal
++ polynomial.
-- Functions for the numeric computation of eigenvalues and eigenvectors
-- are in numeigen spad.
EigenPackage(R) : C == T
 where
   R     : GcdDomain
   P     ==> Polynomial R
   F     ==> Fraction P
   SE    ==> Symbol()
   SUP   ==> SparseUnivariatePolynomial(P)
   SUF   ==> SparseUnivariatePolynomial(F)
   M     ==> Matrix(F)
   NNI   ==> NonNegativeInteger
   ST    ==> SuchThat(SE,P)

   Eigenvalue  ==> Union(F,ST)
   EigenForm   ==> Record(eigval:Eigenvalue,eigmult:NNI,eigvec : List M)
   GenEigen    ==> Record(eigval:Eigenvalue,geneigvec:List M)

   C == with
     characteristicPolynomial :  (M,Symbol)  ->  P
       ++ characteristicPolynomial(m,var) returns the
       ++ characteristicPolynomial of the matrix m using
       ++ the symbol var as the main variable.

     characteristicPolynomial :      M       ->  P
       ++ characteristicPolynomial(m) returns the
       ++ characteristicPolynomial of the matrix m using
       ++ a new generated symbol symbol as the main variable.

     eigenvalues       :    M        ->  List Eigenvalue
       ++ eigenvalues(m) returns the
       ++ eigenvalues of the matrix m which are expressible
       ++ as rational functions over the rational numbers.

     eigenvector       :   (Eigenvalue,M)  ->  List M
       ++ eigenvector(eigval,m) returns the
       ++ eigenvectors belonging to the eigenvalue eigval
       ++ for the matrix m.

     generalizedEigenvector  : (Eigenvalue,M,NNI,NNI) -> List M
       ++ generalizedEigenvector(alpha,m,k,g)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue alpha.
       ++ The integers k and g are respectively the algebraic and the
       ++ geometric multiplicity of tye eigenvalue alpha.
       ++ alpha can be either rational or not.
       ++ In the seconda case apha is the minimal polynomial of the
       ++ eigenvalue.

     generalizedEigenvector  : (EigenForm,M) -> List M
       ++ generalizedEigenvector(eigen,m)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue eigen, as 
       ++ returned by the function eigenvectors.

     generalizedEigenvectors  : M -> List GenEigen
       ++ generalizedEigenvectors(m)
       ++ returns the generalized eigenvectors
       ++ of the matrix m.

     eigenvectors      :    M        ->  List(EigenForm)
       ++ eigenvectors(m) returns the eigenvalues and eigenvectors
       ++ for the matrix m.
       ++ The rational eigenvalues and the correspondent eigenvectors
       ++ are explicitely computed, while the non rational ones
       ++ are given via their minimal polynomial and the corresponding
       ++ eigenvectors are expressed in terms of a "generic" root of
       ++ such a polynomial.

   T == add
     PI       ==> PositiveInteger


     MF  := GeneralizedMultivariateFactorize(SE,IndexedExponents SE,R,R,P)
     UPCF2:= UnivariatePolynomialCategoryFunctions2(P,SUP,F,SUF)
    

                 ----  Local  Functions  ----
     tff              :  (SUF,SE)      ->  F
     fft              :  (SUF,SE)      ->  F
     charpol          :   (M,SE)       ->   F
     intRatEig        :  (F,M,NNI)    ->   List M
     intAlgEig        :  (ST,M,NNI)    ->   List M 
     genEigForm       : (EigenForm,M)  ->   GenEigen

    ---- next functions needed for defining  ModularField ----
     reduction(u:SUF,p:SUF):SUF == u rem p

     merge(p:SUF,q:SUF):Union(SUF,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

     exactquo(u:SUF,v:SUF,p:SUF):Union(SUF,"failed") ==
        val:=extendedEuclidean(v,p,u)
        val case "failed" => "failed"
        val.coef1

               ----  functions for conversions  ----
     fft(t:SUF,x:SE):F ==
       n:=degree(t)
       cf:=monomial(1,x,n)$P :: F
       cf * leadingCoefficient t

     tff(p:SUF,x:SE) : F ==
       degree p=0 => leadingCoefficient p
       r:F:=0$F
       while p^=0 repeat
         r:=r+fft(p,x)
         p := reductum p
       r

      ---- generalized eigenvectors associated to a given eigenvalue ---       
     genEigForm(eigen : EigenForm,A:M) : GenEigen ==
       alpha:=eigen.eigval
       k:=eigen.eigmult
       g:=#(eigen.eigvec)
       k = g  => [alpha,eigen.eigvec]
       [alpha,generalizedEigenvector(alpha,A,k,g)]

           ---- characteristic polynomial  ----
     charpol(A:M,x:SE) : F ==
       dimA :PI := (nrows A):PI
       dimA ^= ncols A => error " The matrix is not square"
       B:M:=zero(dimA,dimA)
       for i in 1..dimA repeat
         for j in 1..dimA repeat  B(i,j):=A(i,j)
         B(i,i) := B(i,i) - monomial(1$P,x,1)::F
       determinant B

          --------  EXPORTED  FUNCTIONS  --------
   
            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:M):P ==
       x:SE:=new()$SE
       numer charpol(A,x)

            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:M,x:SE) : P == numer charpol(A,x)
     
                ----  Eigenvalues of the matrix A  ----
     eigenvalues(A:M): List Eigenvalue  ==
       x:=new()$SE
       pol:= charpol(A,x)
       lrat:List F :=empty()
       lsym:List ST :=empty()
       for eq in solve(pol,x)$SystemSolvePackage(R) repeat
         alg:=numer lhs eq
         degree(alg, x)=1 => lrat:=cons(rhs eq,lrat)
         lsym:=cons([x,alg],lsym)
       append([lr::Eigenvalue for lr in lrat],
              [ls::Eigenvalue for ls in lsym])

          ----  Eigenvectors belonging to a given eigenvalue  ----
                ----  the eigenvalue must be exact  ----
     eigenvector(alpha:Eigenvalue,A:M) : List M  ==
       alpha case F => intRatEig(alpha::F,A,1$NNI)
       intAlgEig(alpha::ST,A,1$NNI)

   ----  Eigenvectors belonging to a given rational eigenvalue  ----
                ---- Internal function -----
     intRatEig(alpha:F,A:M,m:NNI) : List M  ==
       n:=nrows A
       B:M := zero(n,n)$M
       for i in 1..n repeat
         for j in 1..n repeat B(i,j):=A(i,j)
         B(i,i):= B(i,i) - alpha
       [v::M for v in nullSpace(B**m)]
   
   ----  Eigenvectors belonging to a given algebraic eigenvalue  ----
         ------   Internal  Function  -----
     intAlgEig(alpha:ST,A:M,m:NNI) : List M  ==
       n:=nrows A
       MM := ModularField(SUF,SUF,reduction,merge,exactquo)
       AM:=Matrix MM
       x:SE:=lhs alpha
       pol:SUF:=unitCanonical map(coerce,univariate(rhs alpha,x))$UPCF2
       alg:MM:=reduce(monomial(1,1),pol)
       B:AM := zero(n,n)
       for i in 1..n repeat
         for j in 1..n repeat B(i,j):=reduce(A(i,j)::SUF,pol)
         B(i,i):= B(i,i) - alg
       sol: List M :=empty()
       for vec in nullSpace(B**m) repeat
         w:M:=zero(n,1)
         for i in 1..n repeat w(i,1):=tff((vec.i)::SUF,x)
         sol:=cons(w,sol)
       sol

     ----  Generalized Eigenvectors belonging to a given eigenvalue  ----
     generalizedEigenvector(alpha:Eigenvalue,A:M,k:NNI,g:NNI) : List M  ==
       alpha case F => intRatEig(alpha::F,A,(1+k-g)::NNI)
       intAlgEig(alpha::ST,A,(1+k-g)::NNI)

     ----  Generalized Eigenvectors belonging to a given eigenvalue  ----
     generalizedEigenvector(eigen :EigenForm,A:M) : List M  ==
       generalizedEigenvector(eigen.eigval,A,eigen.eigmult,# eigen.eigvec)

          ----  Generalized Eigenvectors -----
     generalizedEigenvectors(A:M) : List GenEigen  ==
       n:= nrows A
       leig:=eigenvectors A
       [genEigForm(leg,A) for leg in leig]
         
                 ----  eigenvectors and eigenvalues  ----
     eigenvectors(A:M):List(EigenForm) ==
       n:=nrows A
       x:=new()$SE
       p:=numer charpol(A,x)
       MM := ModularField(SUF,SUF,reduction,merge,exactquo)
       AM:=Matrix(MM)
       ratSol : List EigenForm := empty()
       algSol : List EigenForm := empty()
       lff:=factors factor  p
       for fact in lff repeat
         pol:=fact.factor   
         degree(pol,x)=1 =>
           vec:F :=-coefficient(pol,x,0)/coefficient(pol,x,degree(pol,x))
           ratSol:=cons([vec,fact.exponent :: NNI,
                         intRatEig(vec,A,1$NNI)]$EigenForm,ratSol)
         alpha:ST:=[x,pol]     
         algSol:=cons([alpha,fact.exponent :: NNI,
                       intAlgEig(alpha,A,1$NNI)]$EigenForm,algSol)
       append(ratSol,algSol)

@
<<EP.dotabb>>=
"EP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EP"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"EP" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EF ElementaryFunction}
\pagehead{ElementaryFunction}{EF}
\pagepic{ps/v104elementaryfunction.ps}{EF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EF ElementaryFunction>>=
)abbrev package EF ElementaryFunction
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 10 April 1995
++ Keywords: elementary, function, logarithm, exponential.
++ Examples:  )r EF INPUT
++ Description: Provides elementary functions over an integral domain.
ElementaryFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: Join(FunctionSpace R, RadicalCategory)

  B   ==> Boolean
  L   ==> List
  Z   ==> Integer
  OP  ==> BasicOperator
  K   ==> Kernel F
  INV ==> error "Invalid argument"

  Exports ==> with
    exp     : F -> F
	++ exp(x) applies the exponential operator to x
    log     : F -> F
	++ log(x) applies the logarithm operator to x
    sin     : F -> F
	++ sin(x) applies the sine operator to x
    cos     : F -> F
	++ cos(x) applies the cosine operator to x 
    tan     : F -> F
	++ tan(x) applies the tangent operator to x
    cot     : F -> F
	++ cot(x) applies the cotangent operator to x
    sec     : F -> F
	++ sec(x) applies the secant operator to x
    csc     : F -> F
	++ csc(x) applies the cosecant operator to x
    asin    : F -> F
	++ asin(x) applies the inverse sine operator to x 
    acos    : F -> F
	++ acos(x) applies the inverse cosine operator to x
    atan    : F -> F
	++ atan(x) applies the inverse tangent operator to x
    acot    : F -> F
	++ acot(x) applies the inverse cotangent operator to x
    asec    : F -> F
	++ asec(x) applies the inverse secant operator to x
    acsc    : F -> F
	++ acsc(x) applies the inverse cosecant operator to x
    sinh    : F -> F
	++ sinh(x) applies the hyperbolic sine operator to x 
    cosh    : F -> F
	++ cosh(x) applies the hyperbolic cosine operator to x
    tanh    : F -> F
	++ tanh(x) applies the hyperbolic tangent operator to x
    coth    : F -> F
	++ coth(x) applies the hyperbolic cotangent operator to x
    sech    : F -> F
	++ sech(x) applies the hyperbolic secant operator to x
    csch    : F -> F
	++ csch(x) applies the hyperbolic cosecant operator to x
    asinh   : F -> F
	++ asinh(x) applies the inverse hyperbolic sine operator to x
    acosh   : F -> F
	++ acosh(x) applies the inverse hyperbolic cosine operator to x
    atanh   : F -> F
	++ atanh(x) applies the inverse hyperbolic tangent operator to x
    acoth   : F -> F
	++ acoth(x) applies the inverse hyperbolic cotangent operator to x
    asech   : F -> F
	++ asech(x) applies the	inverse hyperbolic secant operator to x
    acsch   : F -> F
	++ acsch(x) applies the inverse hyperbolic cosecant operator to x
    pi      : () -> F
	++ pi() returns the pi operator
    belong? : OP -> Boolean
	++ belong?(p) returns true if operator p is elementary
    operator: OP -> OP
	++ operator(p) returns an elementary operator with the same symbol as p
    -- the following should be local, but are conditional
    iisqrt2   : () -> F
	++ iisqrt2() should be local but conditional
    iisqrt3   : () -> F
	++ iisqrt3() should be local but conditional
    iiexp     : F -> F
	++ iiexp(x) should be local but conditional
    iilog     : F -> F
	++ iilog(x) should be local but conditional
    iisin     : F -> F
	++ iisin(x) should be local but conditional
    iicos     : F -> F
	++ iicos(x) should be local but conditional
    iitan     : F -> F
	++ iitan(x) should be local but conditional
    iicot     : F -> F
	++ iicot(x) should be local but conditional
    iisec     : F -> F
	++ iisec(x) should be local but conditional
    iicsc     : F -> F
	++ iicsc(x) should be local but conditional
    iiasin    : F -> F
	++ iiasin(x) should be local but conditional
    iiacos    : F -> F
	++ iiacos(x) should be local but conditional
    iiatan    : F -> F
	++ iiatan(x) should be local but conditional
    iiacot    : F -> F
	++ iiacot(x) should be local but conditional
    iiasec    : F -> F
	++ iiasec(x) should be local but conditional
    iiacsc    : F -> F
	++ iiacsc(x) should be local but conditional
    iisinh    : F -> F
	++ iisinh(x) should be local but conditional
    iicosh    : F -> F
	++ iicosh(x) should be local but conditional
    iitanh    : F -> F
	++ iitanh(x) should be local but conditional
    iicoth    : F -> F
	++ iicoth(x) should be local but conditional
    iisech    : F -> F
	++ iisech(x) should be local but conditional
    iicsch    : F -> F
	++ iicsch(x) should be local but conditional
    iiasinh   : F -> F
	++ iiasinh(x) should be local but conditional
    iiacosh   : F -> F
	++ iiacosh(x) should be local but conditional
    iiatanh   : F -> F
	++ iiatanh(x) should be local but conditional
    iiacoth   : F -> F
	++ iiacoth(x) should be local but conditional
    iiasech   : F -> F
	++ iiasech(x) should be local but conditional
    iiacsch   : F -> F
	++ iiacsch(x) should be local but conditional
    specialTrigs:(F, L Record(func:F,pole:B)) -> Union(F, "failed")
	++ specialTrigs(x,l) should be local but conditional
    localReal?: F -> Boolean
	++ localReal?(x) should be local but conditional

  Implementation ==> add
    ipi      : List F -> F
    iexp     : F -> F
    ilog     : F -> F
    iiilog   : F -> F
    isin     : F -> F
    icos     : F -> F
    itan     : F -> F
    icot     : F -> F
    isec     : F -> F
    icsc     : F -> F
    iasin    : F -> F
    iacos    : F -> F
    iatan    : F -> F
    iacot    : F -> F
    iasec    : F -> F
    iacsc    : F -> F
    isinh    : F -> F
    icosh    : F -> F
    itanh    : F -> F
    icoth    : F -> F
    isech    : F -> F
    icsch    : F -> F
    iasinh   : F -> F
    iacosh   : F -> F
    iatanh   : F -> F
    iacoth   : F -> F
    iasech   : F -> F
    iacsch   : F -> F
    dropfun  : F -> F
    kernel   : F -> K
    posrem   :(Z, Z) -> Z
    iisqrt1  : () -> F
    valueOrPole : Record(func:F, pole:B) -> F

    oppi  := operator("pi"::Symbol)$CommonOperators
    oplog := operator("log"::Symbol)$CommonOperators
    opexp := operator("exp"::Symbol)$CommonOperators
    opsin := operator("sin"::Symbol)$CommonOperators
    opcos := operator("cos"::Symbol)$CommonOperators
    optan := operator("tan"::Symbol)$CommonOperators
    opcot := operator("cot"::Symbol)$CommonOperators
    opsec := operator("sec"::Symbol)$CommonOperators
    opcsc := operator("csc"::Symbol)$CommonOperators
    opasin := operator("asin"::Symbol)$CommonOperators
    opacos := operator("acos"::Symbol)$CommonOperators
    opatan := operator("atan"::Symbol)$CommonOperators
    opacot := operator("acot"::Symbol)$CommonOperators
    opasec := operator("asec"::Symbol)$CommonOperators
    opacsc := operator("acsc"::Symbol)$CommonOperators
    opsinh := operator("sinh"::Symbol)$CommonOperators
    opcosh := operator("cosh"::Symbol)$CommonOperators
    optanh := operator("tanh"::Symbol)$CommonOperators
    opcoth := operator("coth"::Symbol)$CommonOperators
    opsech := operator("sech"::Symbol)$CommonOperators
    opcsch := operator("csch"::Symbol)$CommonOperators
    opasinh := operator("asinh"::Symbol)$CommonOperators
    opacosh := operator("acosh"::Symbol)$CommonOperators
    opatanh := operator("atanh"::Symbol)$CommonOperators
    opacoth := operator("acoth"::Symbol)$CommonOperators
    opasech := operator("asech"::Symbol)$CommonOperators
    opacsch := operator("acsch"::Symbol)$CommonOperators

    -- Pi is a domain...
    Pie, isqrt1, isqrt2, isqrt3: F

    -- following code is conditionalized on arbitraryPrecesion to recompute in
    -- case user changes the precision

    if R has TranscendentalFunctionCategory then
      Pie := pi()$R :: F
    else
      Pie := kernel(oppi, nil()$List(F))

    if R has TranscendentalFunctionCategory and R has arbitraryPrecision then
      pi() == pi()$R :: F
    else
      pi() == Pie

    if R has imaginary: () -> R then
      isqrt1 := imaginary()$R :: F
    else isqrt1 := sqrt(-1::F)

    if R has RadicalCategory then
      isqrt2 := sqrt(2::R)::F
      isqrt3 := sqrt(3::R)::F
    else
      isqrt2 := sqrt(2::F)
      isqrt3 := sqrt(3::F)

    iisqrt1() == isqrt1
    if R has RadicalCategory and R has arbitraryPrecision then
      iisqrt2() == sqrt(2::R)::F
      iisqrt3() == sqrt(3::R)::F
    else
      iisqrt2() == isqrt2
      iisqrt3() == isqrt3

    ipi l == pi()
    log x == oplog x
    exp x == opexp x
    sin x == opsin x
    cos x == opcos x
    tan x == optan x
    cot x == opcot x
    sec x == opsec x
    csc x == opcsc x
    asin x == opasin x
    acos x == opacos x
    atan x == opatan x
    acot x == opacot x
    asec x == opasec x
    acsc x == opacsc x
    sinh x == opsinh x
    cosh x == opcosh x
    tanh x == optanh x
    coth x == opcoth x
    sech x == opsech x
    csch x == opcsch x
    asinh x == opasinh x
    acosh x == opacosh x
    atanh x == opatanh x
    acoth x == opacoth x
    asech x == opasech x
    acsch x == opacsch x
    kernel x == retract(x)@K

    posrem(n, m)    == ((r := n rem m) < 0 => r + m; r)
    valueOrPole rec == (rec.pole => INV; rec.func)
    belong? op      == has?(op, "elem")

    operator op ==
      is?(op, "pi"::Symbol)    => oppi
      is?(op, "log"::Symbol)   => oplog
      is?(op, "exp"::Symbol)   => opexp
      is?(op, "sin"::Symbol)   => opsin
      is?(op, "cos"::Symbol)   => opcos
      is?(op, "tan"::Symbol)   => optan
      is?(op, "cot"::Symbol)   => opcot
      is?(op, "sec"::Symbol)   => opsec
      is?(op, "csc"::Symbol)   => opcsc
      is?(op, "asin"::Symbol)  => opasin
      is?(op, "acos"::Symbol)  => opacos
      is?(op, "atan"::Symbol)  => opatan
      is?(op, "acot"::Symbol)  => opacot
      is?(op, "asec"::Symbol)  => opasec
      is?(op, "acsc"::Symbol)  => opacsc
      is?(op, "sinh"::Symbol)  => opsinh
      is?(op, "cosh"::Symbol)  => opcosh
      is?(op, "tanh"::Symbol)  => optanh
      is?(op, "coth"::Symbol)  => opcoth
      is?(op, "sech"::Symbol)  => opsech
      is?(op, "csch"::Symbol)  => opcsch
      is?(op, "asinh"::Symbol) => opasinh
      is?(op, "acosh"::Symbol) => opacosh
      is?(op, "atanh"::Symbol) => opatanh
      is?(op, "acoth"::Symbol) => opacoth
      is?(op, "asech"::Symbol) => opasech
      is?(op, "acsch"::Symbol) => opacsch
      error "Not an elementary operator"

    dropfun x ==
      ((k := retractIfCan(x)@Union(K, "failed")) case "failed") or
        empty?(argument(k::K)) => 0
      first argument(k::K)

    if R has RetractableTo Z then
      specialTrigs(x, values) ==
        (r := retractIfCan(y := x/pi())@Union(Fraction Z, "failed"))
          case "failed" => "failed"
        q := r::Fraction(Integer)
        m := minIndex values
        (n := retractIfCan(q)@Union(Z, "failed")) case Z =>
          even?(n::Z) => valueOrPole(values.m)
          valueOrPole(values.(m+1))
        (n := retractIfCan(2*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 4)) => valueOrPole(values.(m+2))
          (s := posrem(n::Z, 4)) = 1 => valueOrPole(values.(m+2))
          valueOrPole(values.(m+3))
        (n := retractIfCan(3*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 6)) => valueOrPole(values.(m+4))
          (s := posrem(n::Z, 6)) = 1 => valueOrPole(values.(m+4))
          s = 2 => valueOrPole(values.(m+5))
          s = 4 => valueOrPole(values.(m+6))
          valueOrPole(values.(m+7))
        (n := retractIfCan(4*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 8)) => valueOrPole(values.(m+8))
          (s := posrem(n::Z, 8)) = 1 => valueOrPole(values.(m+8))
          s = 3 => valueOrPole(values.(m+9))
          s = 5 => valueOrPole(values.(m+10))
          valueOrPole(values.(m+11))
        (n := retractIfCan(6*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 12)) => valueOrPole(values.(m+12))
          (s := posrem(n::Z, 12)) = 1 => valueOrPole(values.(m+12))
          s = 5 => valueOrPole(values.(m+13))
          s = 7 => valueOrPole(values.(m+14))
          valueOrPole(values.(m+15))
        "failed"

    else specialTrigs(x, values) == "failed"

    isin x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasin) => y
      is?(x, opacos) => sqrt(1 - y**2)
      is?(x, opatan) => y / sqrt(1 + y**2)
      is?(x, opacot) => inv sqrt(1 + y**2)
      is?(x, opasec) => sqrt(y**2 - 1) / y
      is?(x, opacsc) => inv y
      h  := inv(2::F)
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x, [[0,false], [0,false], [1,false], [-1,false],
                         [s3,false], [s3,false], [-s3,false], [-s3,false],
                          [s2,false], [s2,false], [-s2,false], [-s2,false],
                           [h,false], [h,false], [-h,false], [-h,false]])
      u case F => u :: F
      kernel(opsin, x)

    icos x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasin) => sqrt(1 - y**2)
      is?(x, opacos) => y
      is?(x, opatan) => inv sqrt(1 + y**2)
      is?(x, opacot) => y / sqrt(1 + y**2)
      is?(x, opasec) => inv y
      is?(x, opacsc) => sqrt(y**2 - 1) / y
      h  := inv(2::F)
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x, [[1,false],[-1,false], [0,false], [0,false],
                             [h,false],[-h,false],[-h,false],[h,false],
                              [s2,false],[-s2,false],[-s2,false],[s2,false],
                               [s3,false], [-s3,false],[-s3,false],[s3,false]])
      u case F => u :: F
      kernel(opcos, x)

    itan x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasin) => y / sqrt(1 - y**2)
      is?(x, opacos) => sqrt(1 - y**2) / y
      is?(x, opatan) => y
      is?(x, opacot) => inv y
      is?(x, opasec) => sqrt(y**2 - 1)
      is?(x, opacsc) => inv sqrt(y**2 - 1)
      s33 := (s3 := iisqrt3()) / (3::F)
      u := specialTrigs(x, [[0,false], [0,false], [0,true], [0,true],
                      [s3,false], [-s3,false], [s3,false], [-s3,false],
                       [1,false], [-1,false], [1,false], [-1,false],
                        [s33,false], [-s33, false], [s33,false], [-s33, false]])
      u case F => u :: F
      kernel(optan, x)

    icot x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasin) => sqrt(1 - y**2) / y
      is?(x, opacos) => y / sqrt(1 - y**2)
      is?(x, opatan) => inv y
      is?(x, opacot) => y
      is?(x, opasec) => inv sqrt(y**2 - 1)
      is?(x, opacsc) => sqrt(y**2 - 1)
      s33 := (s3 := iisqrt3()) / (3::F)
      u := specialTrigs(x, [[0,true], [0,true], [0,false], [0,false],
                         [s33,false], [-s33,false], [s33,false], [-s33,false],
                          [1,false], [-1,false], [1,false], [-1,false],
                           [s3,false], [-s3, false], [s3,false], [-s3, false]])
      u case F => u :: F
      kernel(opcot, x)

    isec x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasin) => inv sqrt(1 - y**2)
      is?(x, opacos) => inv y
      is?(x, opatan) => sqrt(1 + y**2)
      is?(x, opacot) => sqrt(1 + y**2) / y
      is?(x, opasec) => y
      is?(x, opacsc) => y / sqrt(y**2 - 1)
      s2 := iisqrt2()
      s3 := 2 * iisqrt3() / (3::F)
      h  := 2::F
      u  := specialTrigs(x, [[1,false],[-1,false],[0,true],[0,true],
                           [h,false], [-h,false], [-h,false], [h,false],
                            [s2,false], [-s2,false], [-s2,false], [s2,false],
                             [s3,false], [-s3,false], [-s3,false], [s3,false]])
      u case F => u :: F
      kernel(opsec, x)

    icsc x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasin) => inv y
      is?(x, opacos) => inv sqrt(1 - y**2)
      is?(x, opatan) => sqrt(1 + y**2) / y
      is?(x, opacot) => sqrt(1 + y**2)
      is?(x, opasec) => y / sqrt(y**2 - 1)
      is?(x, opacsc) => y
      s2 := iisqrt2()
      s3 := 2 * iisqrt3() / (3::F)
      h  := 2::F
      u  := specialTrigs(x, [[0,true], [0,true], [1,false], [-1,false],
                            [s3,false], [s3,false], [-s3,false], [-s3,false],
                              [s2,false], [s2,false], [-s2,false], [-s2,false],
                                 [h,false], [h,false], [-h,false], [-h,false]])
      u case F => u :: F
      kernel(opcsc, x)

    iasin x ==
      zero? x => 0
--      one? x =>   pi() / (2::F)
      (x = 1) =>   pi() / (2::F)
      x = -1 => - pi() / (2::F)
      y := dropfun x
      is?(x, opsin) => y
      is?(x, opcos) => pi() / (2::F) - y
      kernel(opasin, x)

    iacos x ==
      zero? x => pi() / (2::F)
--      one? x => 0
      (x = 1) => 0
      x = -1 => pi()
      y := dropfun x
      is?(x, opsin) => pi() / (2::F) - y
      is?(x, opcos) => y
      kernel(opacos, x)

    iatan x ==
      zero? x => 0
--      one? x =>   pi() / (4::F)
      (x = 1) =>   pi() / (4::F)
      x = -1 => - pi() / (4::F)
      x = (r3:=iisqrt3()) => pi() / (3::F)
--      one?(x*r3)          => pi() / (6::F)
      (x*r3) = 1          => pi() / (6::F)
      y := dropfun x
      is?(x, optan) => y
      is?(x, opcot) => pi() / (2::F) - y
      kernel(opatan, x)

    iacot x ==
      zero? x =>   pi() / (2::F)
--      one? x  =>   pi() / (4::F)
      (x = 1)  =>   pi() / (4::F)
      x = -1  =>   3 * pi() / (4::F)
      x = (r3:=iisqrt3())  =>  pi() / (6::F)
      x = -r3              =>  5 * pi() / (6::F)
--      one?(xx:=x*r3)       =>  pi() / (3::F)
      (xx:=x*r3) = 1      =>  pi() / (3::F)
      xx = -1           =>     2* pi() / (3::F)
      y := dropfun x
      is?(x, optan) => pi() / (2::F) - y
      is?(x, opcot) => y
      kernel(opacot, x)

    iasec x ==
      zero? x => INV
--      one? x => 0
      (x = 1) => 0
      x = -1 => pi()
      y := dropfun x
      is?(x, opsec) => y
      is?(x, opcsc) => pi() / (2::F) - y
      kernel(opasec, x)

    iacsc x ==
      zero? x => INV
--      one? x =>   pi() / (2::F)
      (x = 1) =>   pi() / (2::F)
      x = -1 => - pi() / (2::F)
      y := dropfun x
      is?(x, opsec) => pi() / (2::F) - y
      is?(x, opcsc) => y
      kernel(opacsc, x)

    isinh x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasinh) => y
      is?(x, opacosh) => sqrt(y**2 - 1)
      is?(x, opatanh) => y / sqrt(1 - y**2)
      is?(x, opacoth) => - inv sqrt(y**2 - 1)
      is?(x, opasech) => sqrt(1 - y**2) / y
      is?(x, opacsch) => inv y
      kernel(opsinh, x)

    icosh x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasinh) => sqrt(y**2 + 1)
      is?(x, opacosh) => y
      is?(x, opatanh) => inv sqrt(1 - y**2)
      is?(x, opacoth) => y / sqrt(y**2 - 1)
      is?(x, opasech) => inv y
      is?(x, opacsch) => sqrt(y**2 + 1) / y
      kernel(opcosh, x)

    itanh x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasinh) => y / sqrt(y**2 + 1)
      is?(x, opacosh) => sqrt(y**2 - 1) / y
      is?(x, opatanh) => y
      is?(x, opacoth) => inv y
      is?(x, opasech) => sqrt(1 - y**2)
      is?(x, opacsch) => inv sqrt(y**2 + 1)
      kernel(optanh, x)

    icoth x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasinh) => sqrt(y**2 + 1) / y
      is?(x, opacosh) => y / sqrt(y**2 - 1)
      is?(x, opatanh) => inv y
      is?(x, opacoth) => y
      is?(x, opasech) => inv sqrt(1 - y**2)
      is?(x, opacsch) => sqrt(y**2 + 1)
      kernel(opcoth, x)

    isech x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasinh) => inv sqrt(y**2 + 1)
      is?(x, opacosh) => inv y
      is?(x, opatanh) => sqrt(1 - y**2)
      is?(x, opacoth) => sqrt(y**2 - 1) / y
      is?(x, opasech) => y
      is?(x, opacsch) => y / sqrt(y**2 + 1)
      kernel(opsech, x)

    icsch x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasinh) => inv y
      is?(x, opacosh) => inv sqrt(y**2 - 1)
      is?(x, opatanh) => sqrt(1 - y**2) / y
      is?(x, opacoth) => - sqrt(y**2 - 1)
      is?(x, opasech) => y / sqrt(1 - y**2)
      is?(x, opacsch) => y
      kernel(opcsch, x)

    iasinh x ==
      is?(x, opsinh) => first argument kernel x
      kernel(opasinh, x)

    iacosh x ==
      is?(x, opcosh) => first argument kernel x
      kernel(opacosh, x)

    iatanh x ==
      is?(x, optanh) => first argument kernel x
      kernel(opatanh, x)

    iacoth x ==
      is?(x, opcoth) => first argument kernel x
      kernel(opacoth, x)

    iasech x ==
      is?(x, opsech) => first argument kernel x
      kernel(opasech, x)

    iacsch x ==
      is?(x, opcsch) => first argument kernel x
      kernel(opacsch, x)

    iexp x ==
      zero? x => 1
      is?(x, oplog) => first argument kernel x
      x < 0 and empty? variables x => inv iexp(-x)
      h  := inv(2::F)
      i  := iisqrt1()
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x / i, [[1,false],[-1,false], [i,false], [-i,false],
            [h + i * s3,false], [-h + i * s3, false], [-h - i * s3, false],
             [h - i * s3, false], [s2 + i * s2, false], [-s2 + i * s2, false],
              [-s2 - i * s2, false], [s2 - i * s2, false], [s3 + i * h, false],
               [-s3 + i * h, false], [-s3 - i * h, false], [s3 - i * h, false]])
      u case F => u :: F
      kernel(opexp, x)

-- THIS DETERMINES WHEN TO PERFORM THE log exp f -> f SIMPLIFICATION
-- CURRENT BEHAVIOR:
--     IF R IS COMPLEX(S) THEN ONLY ELEMENTS WHICH ARE RETRACTABLE TO R
--     AND EQUAL TO THEIR CONJUGATES ARE DEEMED REAL (OVERRESTRICTIVE FOR NOW)
--     OTHERWISE (e.g. R = INT OR FRAC INT), ALL THE ELEMENTS ARE DEEMED REAL

    if (R has imaginary:() -> R) and (R has conjugate: R -> R) then
         localReal? x ==
            (u := retractIfCan(x)@Union(R, "failed")) case R
               and (u::R) = conjugate(u::R)

    else localReal? x == true

    iiilog x ==
      zero? x => INV
--      one? x => 0
      (x = 1) => 0
      (u := isExpt(x, opexp)) case Record(var:K, exponent:Integer) =>
           rec := u::Record(var:K, exponent:Integer)
           arg := first argument(rec.var);
           localReal? arg => rec.exponent * first argument(rec.var);
           ilog x
      ilog x

    ilog x ==
--      ((num1 := one?(num := numer x)) or num = -1) and (den := denom x) ^= 1
      ((num1 := ((num := numer x) = 1)) or num = -1) and (den := denom x) ^= 1
        and empty? variables x => - kernel(oplog, (num1 => den; -den)::F)
      kernel(oplog, x)

    if R has ElementaryFunctionCategory then
      iilog x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iiilog x
        log(r::R)::F

      iiexp x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iexp x
        exp(r::R)::F

    else
      iilog x == iiilog x
      iiexp x == iexp x

    if R has TrigonometricFunctionCategory then
      iisin x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isin x
        sin(r::R)::F

      iicos x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icos x
        cos(r::R)::F

      iitan x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => itan x
        tan(r::R)::F

      iicot x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icot x
        cot(r::R)::F

      iisec x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isec x
        sec(r::R)::F

      iicsc x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icsc x
        csc(r::R)::F

    else
      iisin x == isin x
      iicos x == icos x
      iitan x == itan x
      iicot x == icot x
      iisec x == isec x
      iicsc x == icsc x

    if R has ArcTrigonometricFunctionCategory then
      iiasin x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasin x
        asin(r::R)::F

      iiacos x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacos x
        acos(r::R)::F

      iiatan x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iatan x
        atan(r::R)::F

      iiacot x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacot x
        acot(r::R)::F

      iiasec x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasec x
        asec(r::R)::F

      iiacsc x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacsc x
        acsc(r::R)::F

    else
      iiasin x == iasin x
      iiacos x == iacos x
      iiatan x == iatan x
      iiacot x == iacot x
      iiasec x == iasec x
      iiacsc x == iacsc x

    if R has HyperbolicFunctionCategory then
      iisinh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isinh x
        sinh(r::R)::F

      iicosh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icosh x
        cosh(r::R)::F

      iitanh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => itanh x
        tanh(r::R)::F

      iicoth x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icoth x
        coth(r::R)::F

      iisech x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isech x
        sech(r::R)::F

      iicsch x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icsch x
        csch(r::R)::F

    else
      iisinh x == isinh x
      iicosh x == icosh x
      iitanh x == itanh x
      iicoth x == icoth x
      iisech x == isech x
      iicsch x == icsch x

    if R has ArcHyperbolicFunctionCategory then
      iiasinh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasinh x
        asinh(r::R)::F

      iiacosh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacosh x
        acosh(r::R)::F

      iiatanh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iatanh x
        atanh(r::R)::F

      iiacoth x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacoth x
        acoth(r::R)::F

      iiasech x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasech x
        asech(r::R)::F

      iiacsch x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacsch x
        acsch(r::R)::F

    else
      iiasinh x == iasinh x
      iiacosh x == iacosh x
      iiatanh x == iatanh x
      iiacoth x == iacoth x
      iiasech x == iasech x
      iiacsch x == iacsch x

    evaluate(oppi, ipi)$BasicOperatorFunctions1(F)
    evaluate(oplog, iilog)
    evaluate(opexp, iiexp)
    evaluate(opsin, iisin)
    evaluate(opcos, iicos)
    evaluate(optan, iitan)
    evaluate(opcot, iicot)
    evaluate(opsec, iisec)
    evaluate(opcsc, iicsc)
    evaluate(opasin, iiasin)
    evaluate(opacos, iiacos)
    evaluate(opatan, iiatan)
    evaluate(opacot, iiacot)
    evaluate(opasec, iiasec)
    evaluate(opacsc, iiacsc)
    evaluate(opsinh, iisinh)
    evaluate(opcosh, iicosh)
    evaluate(optanh, iitanh)
    evaluate(opcoth, iicoth)
    evaluate(opsech, iisech)
    evaluate(opcsch, iicsch)
    evaluate(opasinh, iiasinh)
    evaluate(opacosh, iiacosh)
    evaluate(opatanh, iiatanh)
    evaluate(opacoth, iiacoth)
    evaluate(opasech, iiasech)
    evaluate(opacsch, iiacsch)
    derivative(opexp, exp)
    derivative(oplog, inv)
    derivative(opsin, cos)
    derivative(opcos, - sin #1)
    derivative(optan, 1 + tan(#1)**2)
    derivative(opcot, - 1 - cot(#1)**2)
    derivative(opsec, tan(#1) * sec(#1))
    derivative(opcsc, - cot(#1) * csc(#1))
    derivative(opasin, inv sqrt(1 - #1**2))
    derivative(opacos, - inv sqrt(1 - #1**2))
    derivative(opatan, inv(1 + #1**2))
    derivative(opacot, - inv(1 + #1**2))
    derivative(opasec, inv(#1 * sqrt(#1**2 - 1)))
    derivative(opacsc, - inv(#1 * sqrt(#1**2 - 1)))
    derivative(opsinh, cosh)
    derivative(opcosh, sinh)
    derivative(optanh, 1 - tanh(#1)**2)
    derivative(opcoth, 1 - coth(#1)**2)
    derivative(opsech, - tanh(#1) * sech(#1))
    derivative(opcsch, - coth(#1) * csch(#1))
    derivative(opasinh, inv sqrt(1 + #1**2))
    derivative(opacosh, inv sqrt(#1**2 - 1))
    derivative(opatanh, inv(1 - #1**2))
    derivative(opacoth, inv(1 - #1**2))
    derivative(opasech, - inv(#1 * sqrt(1 - #1**2)))
    derivative(opacsch, - inv(#1 * sqrt(1 + #1**2)))

@
<<EF.dotabb>>=
"EF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEFINTEF ElementaryFunctionDefiniteIntegration}
\pagehead{ElementaryFunctionDefiniteIntegration}{DEFINTEF}
\pagepic{ps/v104elementaryfunctiondefiniteintegration.ps}{DEFINTEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEFINTEF ElementaryFunctionDefiniteIntegration>>=
)abbrev package DEFINTEF ElementaryFunctionDefiniteIntegration
++ Definite integration of elementary functions.
++ Author: Manuel Bronstein
++ Date Created: 14 April 1992
++ Date Last Updated: 2 February 1993
++ Description:
++   \spadtype{ElementaryFunctionDefiniteIntegration}
++   provides functions to compute definite
++   integrals of elementary functions.
ElementaryFunctionDefiniteIntegration(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory, PrimitiveFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)

  B   ==> Boolean
  SE  ==> Symbol
  Z   ==> Integer
  P   ==> SparseMultivariatePolynomial(R, K)
  K   ==> Kernel F
  UP  ==> SparseUnivariatePolynomial F
  OFE ==> OrderedCompletion F
  U   ==> Union(f1:OFE, f2:List OFE, fail:"failed", pole:"potentialPole")

  Exports ==> with
    integrate: (F, SegmentBinding OFE) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (F, SegmentBinding OFE, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".
    innerint: (F, SE, OFE, OFE, B) -> U
      ++ innerint(f, x, a, b, ignore?) should be local but conditional

  Implementation ==> add
    import ElementaryFunctionSign(R, F)
    import DefiniteIntegrationTools(R, F)
    import FunctionSpaceIntegration(R, F)

    polyIfCan   : (P, K) -> Union(UP, "failed")
    int         : (F, SE, OFE, OFE, B) -> U
    nopole      : (F, SE, K, OFE, OFE) -> U
    checkFor0   : (P, K, OFE, OFE) -> Union(B, "failed")
    checkSMP    : (P, SE, K, OFE, OFE) -> Union(B, "failed")
    checkForPole: (F, SE, K, OFE, OFE) -> Union(B, "failed")
    posit       : (F, SE, K, OFE, OFE) -> Union(B, "failed")
    negat       : (F, SE, K, OFE, OFE) -> Union(B, "failed")
    moreThan    : (OFE, Fraction Z) -> Union(B, "failed")

    if R has Join(ConvertibleTo Pattern Integer, PatternMatchable Integer)
      and F has SpecialFunctionCategory then
        import PatternMatchIntegration(R, F)

        innerint(f, x, a, b, ignor?) ==
          ((u := int(f, x, a, b, ignor?)) case f1) or (u case f2)
            or ((v := pmintegrate(f, x, a, b)) case "failed") => u
          [v::F::OFE]

    else
      innerint(f, x, a, b, ignor?) == int(f, x, a, b, ignor?)

    integrate(f:F, s:SegmentBinding OFE) ==
      innerint(f, variable s, lo segment s, hi segment s, false)

    integrate(f:F, s:SegmentBinding OFE, str:String) ==
      innerint(f, variable s, lo segment s, hi segment s, ignore? str)

    int(f, x, a, b, ignor?) ==
      a = b => [0::OFE]
      k := kernel(x)@Kernel(F)
      (z := checkForPole(f, x, k, a, b)) case "failed" =>
        ignor? => nopole(f, x, k, a, b)
        ["potentialPole"]
      z::B => error "integrate: pole in path of integration"
      nopole(f, x, k, a, b)

    checkForPole(f, x, k, a, b) ==
      ((u := checkFor0(d := denom f, k, a, b)) case "failed") or (u::B) => u
      ((u := checkSMP(d, x, k, a, b)) case "failed") or (u::B) => u
      checkSMP(numer f, x, k, a, b)

-- true if p has a zero between a and b exclusive
    checkFor0(p, x, a, b) ==
      (u := polyIfCan(p, x)) case UP => checkForZero(u::UP, a, b, false)
      (v := isTimes p) case List(P) =>
         for t in v::List(P) repeat
           ((w := checkFor0(t, x, a, b)) case "failed") or (w::B) => return w
         false
      (r := retractIfCan(p)@Union(K, "failed")) case "failed" => "failed"
      k := r::K
-- functions with no real zeros
      is?(k, "exp"::SE) or is?(k, "acot"::SE) or is?(k, "cosh"::SE) => false
-- special case for log
      is?(k, "log"::SE) =>
        (w := moreThan(b, 1)) case "failed" or not(w::B) => w
        moreThan(-a, -1)
      "failed"

-- returns true if a > b, false if a < b, "failed" if can't decide
    moreThan(a, b) ==
      (r := retractIfCan(a)@Union(F, "failed")) case "failed" =>  -- infinite
        whatInfinity(a) > 0
      (u := retractIfCan(r::F)@Union(Fraction Z, "failed")) case "failed" =>
        "failed"
      u::Fraction(Z) > b

-- true if p has a pole between a and b
    checkSMP(p, x, k, a, b) ==
      (u := polyIfCan(p, k)) case UP => false
      (v := isTimes p) case List(P) =>
         for t in v::List(P) repeat
           ((w := checkSMP(t, x, k, a, b)) case "failed") or (w::B) => return w
         false
      (v := isPlus p) case List(P) =>
         n := 0              -- number of summand having a pole
         for t in v::List(P) repeat
           (w := checkSMP(t, x, k, a, b)) case "failed" => return w
           if w::B then n := n + 1
         zero? n => false    -- no summand has a pole
--         one? n => true      -- only one summand has a pole
         (n = 1) => true      -- only one summand has a pole
         "failed"            -- at least 2 summands have a pole
      (r := retractIfCan(p)@Union(K, "failed")) case "failed" => "failed"
      kk := r::K
      -- nullary operators have no poles
      nullary? operator kk => false
      f := first argument kk
      -- functions which are defined over all the reals:
      is?(kk, "exp"::SE) or is?(kk, "sin"::SE) or is?(kk, "cos"::SE)
        or is?(kk, "sinh"::SE) or is?(kk, "cosh"::SE) or is?(kk, "tanh"::SE)
          or is?(kk, "sech"::SE) or is?(kk, "atan"::SE) or is?(kk, "acot"::SE)
            or is?(kk, "asinh"::SE) => checkForPole(f, x, k, a, b)
      -- functions which are defined on (-1,+1):
      is?(kk, "asin"::SE) or is?(kk, "acos"::SE) or is?(kk, "atanh"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        ((w := posit(f - 1, x, k, a, b)) case "failed") or (w::B) => w
        negat(f + 1, x, k, a, b)
      -- functions which are defined on (+1, +infty):
      is?(kk, "acosh"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        negat(f - 1, x, k, a, b)
      -- functions which are defined on (0, +infty):
      is?(kk, "log"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        negat(f, x, k, a, b)
      "failed"

-- returns true if it is certain that f takes at least one strictly positive
-- value for x in (a,b), false if it is certain that f takes no strictly
-- positive value in (a,b), "failed" otherwise
-- f must be known to have no poles in (a,b)
    posit(f, x, k, a, b) ==
      z :=
        (r := retractIfCan(a)@Union(F, "failed")) case "failed" => sign(f, x, a)
        sign(f, x, r::F, "right")
      (b1 := z case Z) and z::Z > 0 => true
      z :=
        (r := retractIfCan(b)@Union(F, "failed")) case "failed" => sign(f, x, b)
        sign(f, x, r::F, "left")
      (b2 := z case Z) and z::Z > 0 => true
      b1 and b2 =>
        ((w := checkFor0(numer f, k, a, b)) case "failed") or (w::B) => "failed"
        false
      "failed"

-- returns true if it is certain that f takes at least one strictly negative
-- value for x in (a,b), false if it is certain that f takes no strictly
-- negative value in (a,b), "failed" otherwise
-- f must be known to have no poles in (a,b)
    negat(f, x, k, a, b) ==
      z :=
        (r := retractIfCan(a)@Union(F, "failed")) case "failed" => sign(f, x, a)
        sign(f, x, r::F, "right")
      (b1 := z case Z) and z::Z < 0 => true
      z :=
        (r := retractIfCan(b)@Union(F, "failed")) case "failed" => sign(f, x, b)
        sign(f, x, r::F, "left")
      (b2 := z case Z) and z::Z < 0 => true
      b1 and b2 =>
        ((w := checkFor0(numer f, k, a, b)) case "failed") or (w::B) => "failed"
        false
      "failed"

-- returns a UP if p is only a poly w.r.t. the kernel x
    polyIfCan(p, x) ==
      q := univariate(p, x)
      ans:UP := 0
      while q ^= 0 repeat
        member?(x, tower(c := leadingCoefficient(q)::F)) => return "failed"
        ans := ans + monomial(c, degree q)
        q := reductum q
      ans

-- integrate f for x between a and b assuming that f has no pole in between
    nopole(f, x, k, a, b) ==
      (u := integrate(f, x)) case F =>
        (v := computeInt(k, u::F, a, b, false)) case "failed" => ["failed"]
        [v::OFE]
      ans := empty()$List(OFE)
      for g in u::List(F) repeat
        (v := computeInt(k, g, a, b, false)) case "failed" => return ["failed"]
        ans := concat_!(ans, [v::OFE])
      [ans]

@
<<DEFINTEF.dotabb>>=
"DEFINTEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEFINTEF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DEFINTEF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFSTRUC ElementaryFunctionStructurePackage}
<<package EFSTRUC ElementaryFunctionStructurePackage>>=
)abbrev package EFSTRUC ElementaryFunctionStructurePackage
++ Risch structure theorem
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 16 August 1995
++ Description:
++   ElementaryFunctionStructurePackage provides functions to test the
++   algebraic independence of various elementary functions, using the
++   Risch structure theorem (real and complex versions).
++   It also provides transformations on elementary functions
++   which are not considered simplifications.
++ Keywords: elementary, function, structure.
ElementaryFunctionStructurePackage(R,F): Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  B   ==> Boolean
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Z
  SY  ==> Symbol
  K   ==> Kernel F
  UP  ==> SparseUnivariatePolynomial F
  SMP ==> SparseMultivariatePolynomial(R, K)
  REC ==> Record(func:F, kers: List K, vals:List F)
  U   ==> Union(vec:Vector Q, func:F, fail: Boolean)
  POWER ==> "%power"::SY
  NTHR  ==> "nthRoot"::SY

  Exports ==> with
    normalize: F -> F
      ++ normalize(f) rewrites \spad{f} using the least possible number of
      ++ real algebraically independent kernels.
    normalize: (F, SY) -> F
      ++ normalize(f, x) rewrites \spad{f} using the least possible number of
      ++ real algebraically independent kernels involving \spad{x}.
    rischNormalize: (F, SY) -> REC
      ++ rischNormalize(f, x) returns \spad{[g, [k1,...,kn], [h1,...,hn]]}
      ++ such that \spad{g = normalize(f, x)} and each \spad{ki} was
      ++ rewritten as \spad{hi} during the normalization.
    realElementary: F -> F
      ++ realElementary(f) rewrites \spad{f} in terms of the 4 fundamental real
      ++ transcendental elementary functions: \spad{log, exp, tan, atan}.
    realElementary: (F, SY) -> F
      ++ realElementary(f,x) rewrites the kernels of \spad{f} involving \spad{x}
      ++ in terms of the 4 fundamental real
      ++ transcendental elementary functions: \spad{log, exp, tan, atan}.
    validExponential: (List K, F, SY) -> Union(F, "failed")
      ++ validExponential([k1,...,kn],f,x) returns \spad{g} if \spad{exp(f)=g}
      ++ and \spad{g} involves only \spad{k1...kn}, and "failed" otherwise.
    rootNormalize: (F, K) -> F
      ++ rootNormalize(f, k) returns \spad{f} rewriting either \spad{k} which
      ++ must be an nth-root in terms of radicals already in \spad{f}, or some
      ++ radicals in \spad{f} in terms of \spad{k}.
    tanQ: (Q, F) -> F
      ++ tanQ(q,a) is a local function with a conditional implementation.

  Implementation ==> add
    import TangentExpansions F
    import IntegrationTools(R, F)
    import IntegerLinearDependence F
    import AlgebraicManipulations(R, F)
    import InnerCommonDenominator(Z, Q, Vector Z, Vector Q)

    k2Elem             : (K, List SY) -> F
    realElem           : (F, List SY) -> F
    smpElem            : (SMP, List SY) -> F
    deprel             : (List K, K, SY) -> U
    rootDep            : (List K, K)     -> U
    qdeprel            : (List F, F)     -> U
    factdeprel         : (List K, K)     -> U
    toR                : (List K, F) -> List K
    toY                : List K -> List F
    toZ                : List K -> List F
    toU                : List K -> List F
    toV                : List K -> List F
    ktoY               : K  -> F
    ktoZ               : K  -> F
    ktoU               : K  -> F
    ktoV               : K  -> F
    gdCoef?            : (Q, Vector Q) -> Boolean
    goodCoef           : (Vector Q, List K, SY) ->
                                 Union(Record(index:Z, ker:K), "failed")
    tanRN              : (Q, K) -> F
    localnorm          : F -> F
    rooteval           : (F, List K, K, Q) -> REC
    logeval            : (F, List K, K, Vector Q) -> REC
    expeval            : (F, List K, K, Vector Q) -> REC
    taneval            : (F, List K, K, Vector Q) -> REC
    ataneval           : (F, List K, K, Vector Q) -> REC
    depeval            : (F, List K, K, Vector Q) -> REC
    expnosimp          : (F, List K, K, Vector Q, List F, F) -> REC
    tannosimp          : (F, List K, K, Vector Q, List F, F) -> REC
    rtNormalize        : F -> F
    rootNormalize0     : F -> REC
    rootKernelNormalize: (F, List K, K) -> Union(REC, "failed")
    tanSum             : (F, List F) -> F

    comb?     := F has CombinatorialOpsCategory
    mpiover2:F := pi()$F / (-2::F)

    realElem(f, l)       == smpElem(numer f, l) / smpElem(denom f, l)
    realElementary(f, x) == realElem(f, [x])
    realElementary f     == realElem(f, variables f)
    toY ker              == [func for k in ker | (func := ktoY k) ^= 0]
    toZ ker              == [func for k in ker | (func := ktoZ k) ^= 0]
    toU ker              == [func for k in ker | (func := ktoU k) ^= 0]
    toV ker              == [func for k in ker | (func := ktoV k) ^= 0]
    rtNormalize f        == rootNormalize0(f).func
    toR(ker, x) == select(is?(#1, NTHR) and first argument(#1) = x, ker)

    if R has GcdDomain then
      tanQ(c, x) ==
        tanNa(rootSimp zeroOf tanAn(x, denom(c)::PositiveInteger), numer c)
    else
      tanQ(c, x) ==
        tanNa(zeroOf tanAn(x, denom(c)::PositiveInteger), numer c)

    -- tanSum(c, [a1,...,an]) returns f(c, a1,...,an) such that
    -- if ai = tan(ui) then f(c, a1,...,an) = tan(c + u1 + ... + un).
    -- MUST BE CAREFUL FOR WHEN c IS AN ODD MULTIPLE of pi/2
    tanSum(c, l) ==
      k := c / mpiover2        -- k = - 2 c / pi, check for odd integer
                               -- tan((2n+1) pi/2 x) = - 1 / tan x
      (r := retractIfCan(k)@Union(Z, "failed")) case Z and odd?(r::Z) =>
           - inv tanSum l
      tanSum concat(tan c, l)

    rootNormalize0 f ==
      ker := select_!(is?(#1, NTHR) and empty? variables first argument #1,
                      tower f)$List(K)
      empty? ker => [f, empty(), empty()]
      (n := (#ker)::Z - 1) < 1 => [f, empty(), empty()]
      for i in 1..n for kk in rest ker repeat
        (u := rootKernelNormalize(f, first(ker, i), kk)) case REC =>
          rec := u::REC
          rn  := rootNormalize0(rec.func)
          return [rn.func, concat(rec.kers, rn.kers), concat(rec.vals, rn.vals)]
      [f, empty(), empty()]

    deprel(ker, k, x) ==
      is?(k, "log"::SY) or is?(k, "exp"::SY) =>
        qdeprel([differentiate(g, x) for g in toY ker],
                 differentiate(ktoY k, x))
      is?(k, "atan"::SY) or is?(k, "tan"::SY) =>
        qdeprel([differentiate(g, x) for g in toU ker],
                 differentiate(ktoU k, x))
      is?(k, NTHR) => rootDep(ker, k)
      comb? and is?(k, "factorial"::SY) =>
        factdeprel([x for x in ker | is?(x,"factorial"::SY) and x^=k],k)
      [true]

    ktoY k ==
      is?(k, "log"::SY) => k::F
      is?(k, "exp"::SY) => first argument k
      0

    ktoZ k ==
      is?(k, "log"::SY) => first argument k
      is?(k, "exp"::SY) => k::F
      0

    ktoU k ==
      is?(k, "atan"::SY) => k::F
      is?(k,  "tan"::SY) => first argument k
      0

    ktoV k ==
      is?(k,  "tan"::SY) => k::F
      is?(k, "atan"::SY) => first argument k
      0

    smpElem(p, l) ==
      map(k2Elem(#1, l), #1::F, p)$PolynomialCategoryLifting(
                                       IndexedExponents K, K, R, SMP, F)

    k2Elem(k, l) ==
      ez, iez, tz2: F
      kf := k::F
      not(empty? l) and empty? [v for v in variables kf | member?(v, l)] => kf
      empty?(args :List F := [realElem(a, l) for a in argument k]) => kf
      z := first args
      is?(k, POWER)       => (zero? z => 0; exp(last(args) * log z))
      is?(k, "cot"::SY)   => inv tan z
      is?(k, "acot"::SY)  => atan inv z
      is?(k, "asin"::SY)  => atan(z / sqrt(1 - z**2))
      is?(k, "acos"::SY)  => atan(sqrt(1 - z**2) / z)
      is?(k, "asec"::SY)  => atan sqrt(1 - z**2)
      is?(k, "acsc"::SY)  => atan inv sqrt(1 - z**2)
      is?(k, "asinh"::SY) => log(sqrt(1 + z**2) + z)
      is?(k, "acosh"::SY) => log(sqrt(z**2 - 1) + z)
      is?(k, "atanh"::SY) => log((z + 1) / (1 - z)) / (2::F)
      is?(k, "acoth"::SY) => log((z + 1) / (z - 1)) / (2::F)
      is?(k, "asech"::SY) => log((inv z) + sqrt(inv(z**2) - 1))
      is?(k, "acsch"::SY) => log((inv z) + sqrt(1 + inv(z**2)))
      is?(k, "%paren"::SY) or is?(k, "%box"::SY) =>
        empty? rest args => z
        kf
      if has?(op := operator k, "htrig") then iez  := inv(ez  := exp z)
      is?(k, "sinh"::SY)  => (ez - iez) / (2::F)
      is?(k, "cosh"::SY)  => (ez + iez) / (2::F)
      is?(k, "tanh"::SY)  => (ez - iez) / (ez + iez)
      is?(k, "coth"::SY)  => (ez + iez) / (ez - iez)
      is?(k, "sech"::SY)  => 2 * inv(ez + iez)
      is?(k, "csch"::SY)  => 2 * inv(ez - iez)
      if has?(op, "trig") then tz2  := tan(z / (2::F))
      is?(k, "sin"::SY)   => 2 * tz2 / (1 + tz2**2)
      is?(k, "cos"::SY)   => (1 - tz2**2) / (1 + tz2**2)
      is?(k, "sec"::SY)   => (1 + tz2**2) / (1 - tz2**2)
      is?(k, "csc"::SY)   => (1 + tz2**2) / (2 * tz2)
      op args

--The next 5 functions are used by normalize, once a relation is found
    depeval(f, lk, k, v) ==
      is?(k, "log"::SY)  => logeval(f, lk, k, v)
      is?(k, "exp"::SY)  => expeval(f, lk, k, v)
      is?(k, "tan"::SY)  => taneval(f, lk, k, v)
      is?(k, "atan"::SY) => ataneval(f, lk, k, v)
      is?(k, NTHR) => rooteval(f, lk, k, v(minIndex v))
      [f, empty(), empty()]

    rooteval(f, lk, k, n) ==
      nv := nthRoot(x := first argument k, m := retract(n)@Z)
      l  := [r for r in concat(k, toR(lk, x)) |
             retract(second argument r)@Z ^= m]
      lv := [nv ** (n / (retract(second argument r)@Z::Q)) for r in l]
      [eval(f, l, lv), l, lv]

    ataneval(f, lk, k, v) ==
      w := first argument k
      s := tanSum [tanQ(qelt(v,i), x)
                   for i in minIndex v .. maxIndex v for x in toV lk]
      g := +/[qelt(v, i) * x for i in minIndex v .. maxIndex v for x in toU lk]
      h:F :=
        zero?(d := 1 + s * w) => mpiover2
        atan((w - s) / d)
      g := g + h
      [eval(f, [k], [g]), [k], [g]]

    gdCoef?(c, v) ==
      for i in minIndex v .. maxIndex v repeat
        retractIfCan(qelt(v, i) / c)@Union(Z, "failed") case "failed" =>
          return false
      true

    goodCoef(v, l, s) ==
      for i in minIndex v .. maxIndex v for k in l repeat
        is?(k, s) and
           ((r:=recip(qelt(v,i))) case Q) and
            (retractIfCan(r::Q)@Union(Z, "failed") case Z)
              and gdCoef?(qelt(v, i), v) => return([i, k])
      "failed"

    taneval(f, lk, k, v) ==
      u := first argument k
      fns := toU lk
      c := u - +/[qelt(v, i) * x for i in minIndex v .. maxIndex v for x in fns]
      (rec := goodCoef(v, lk, "tan"::SY)) case "failed" =>
          tannosimp(f, lk, k, v, fns, c)
      v0 := retract(inv qelt(v, rec.index))@Z
      lv := [qelt(v, i) for i in minIndex v .. maxIndex v |
                                                 i ^= rec.index]$List(Q)
      l  := [kk for kk in lk | kk ^= rec.ker]
      g := tanSum(-v0 * c, concat(tanNa(k::F, v0),
           [tanNa(x, - retract(a * v0)@Z) for a in lv for x in toV l]))
      [eval(f, [rec.ker], [g]), [rec.ker], [g]]

    tannosimp(f, lk, k, v, fns, c) ==
      every?(is?(#1, "tan"::SY), lk) =>
        dd := (d := (cd := splitDenominator v).den)::F
        newt := [tan(u / dd) for u in fns]$List(F)
        newtan := [tanNa(t, d) for t in newt]$List(F)
        h := tanSum(c, [tanNa(t, qelt(cd.num, i))
                        for i in minIndex v .. maxIndex v for t in newt])
        lk := concat(k, lk)
        newtan := concat(h, newtan)
        [eval(f, lk, newtan), lk, newtan]
      h := tanSum(c, [tanQ(qelt(v, i), x)
                      for i in minIndex v .. maxIndex v for x in toV lk])
      [eval(f, [k], [h]), [k], [h]]

    expnosimp(f, lk, k, v, fns, g) ==
      every?(is?(#1, "exp"::SY), lk) =>
        dd := (d := (cd := splitDenominator v).den)::F
        newe := [exp(y / dd) for y in fns]$List(F)
        newexp := [e ** d for e in newe]$List(F)
        h := */[e ** qelt(cd.num, i)
                for i in minIndex v .. maxIndex v for e in newe] * g
        lk := concat(k, lk)
        newexp := concat(h, newexp)
        [eval(f, lk, newexp), lk, newexp]
      h := */[exp(y) ** qelt(v, i)
                for i in minIndex v .. maxIndex v for y in fns] * g
      [eval(f, [k], [h]), [k], [h]]

    logeval(f, lk, k, v) ==
      z := first argument k
      c := z / (*/[x**qelt(v, i)
                   for x in toZ lk for i in minIndex v .. maxIndex v])
-- CHANGED log ktoZ x TO ktoY x SINCE WE WANT log exp f TO BE REPLACED BY f.
      g := +/[qelt(v, i) * x
              for i in minIndex v .. maxIndex v for x in toY lk] + log c
      [eval(f, [k], [g]), [k], [g]]

    rischNormalize(f, v) ==
      empty?(ker := varselect(tower f, v)) => [f, empty(), empty()]
      first(ker) ^= kernel(v)@K => error "Cannot happen"
      ker := rest ker
      (n := (#ker)::Z - 1) < 1 => [f, empty(), empty()]
      for i in 1..n for kk in rest ker repeat
        klist := first(ker, i)
        -- NO EVALUATION ON AN EMPTY VECTOR, WILL CAUSE INFINITE LOOP
        (c := deprel(klist, kk, v)) case vec and not empty?(c.vec) =>
          rec := depeval(f, klist, kk, c.vec)
          rn  := rischNormalize(rec.func, v)
          return [rn.func,
                   concat(rec.kers, rn.kers), concat(rec.vals, rn.vals)]
        c case func =>
          rn := rischNormalize(eval(f, [kk], [c.func]), v)
          return [rn.func, concat(kk, rn.kers), concat(c.func, rn.vals)]
      [f, empty(), empty()]

    rootNormalize(f, k) ==
      (u := rootKernelNormalize(f, toR(tower f, first argument k), k))
         case "failed" => f
      (u::REC).func

    rootKernelNormalize(f, l, k) ==
      (c := rootDep(l, k)) case vec =>
        rooteval(f, l, k, (c.vec)(minIndex(c.vec)))
      "failed"

    localnorm f ==
      for x in variables f repeat
        f := rischNormalize(f, x).func
      f

    validExponential(twr, eta, x) ==
      (c := solveLinearlyOverQ(construct([differentiate(g, x)
         for g in (fns := toY twr)]$List(F))@Vector(F),
           differentiate(eta, x))) case "failed" => "failed"
      v := c::Vector(Q)
      g := eta - +/[qelt(v, i) * yy
                        for i in minIndex v .. maxIndex v for yy in fns]
      */[exp(yy) ** qelt(v, i)
                for i in minIndex v .. maxIndex v for yy in fns] * exp g

    rootDep(ker, k) ==
      empty?(ker := toR(ker, first argument k)) => [true]
      [new(1,lcm(retract(second argument k)@Z,
       "lcm"/[retract(second argument r)@Z for r in ker])::Q)$Vector(Q)]

    qdeprel(l, v) ==
      (u := solveLinearlyOverQ(construct(l)@Vector(F), v))
        case Vector(Q) => [u::Vector(Q)]
      [true]

    expeval(f, lk, k, v) ==
      y   := first argument k
      fns := toY lk
      g := y - +/[qelt(v, i) * z for i in minIndex v .. maxIndex v for z in fns]
      (rec := goodCoef(v, lk, "exp"::SY)) case "failed" =>
        expnosimp(f, lk, k, v, fns, exp g)
      v0 := retract(inv qelt(v, rec.index))@Z
      lv := [qelt(v, i) for i in minIndex v .. maxIndex v |
                                                 i ^= rec.index]$List(Q)
      l  := [kk for kk in lk | kk ^= rec.ker]
      h :F := */[exp(z) ** (- retract(a * v0)@Z) for a in lv for z in toY l]
      h := h * exp(-v0 * g) * (k::F) ** v0
      [eval(f, [rec.ker], [h]), [rec.ker], [h]]

    if F has CombinatorialOpsCategory then
      normalize f == rtNormalize localnorm factorials realElementary f

      normalize(f, x) ==
        rtNormalize(rischNormalize(factorials(realElementary(f,x),x),x).func)

      factdeprel(l, k) ==
        ((r := retractIfCan(n := first argument k)@Union(Z, "failed"))
          case Z) and (r::Z > 0) => [factorial(r::Z)::F]
        for x in l repeat
          m := first argument x
          ((r := retractIfCan(n - m)@Union(Z, "failed")) case Z) and
            (r::Z > 0) => return([*/[(m + i::F) for i in 1..r] * x::F])
        [true]

    else
      normalize f     == rtNormalize localnorm realElementary f
      normalize(f, x) == rtNormalize(rischNormalize(realElementary(f,x),x).func)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFULS ElementaryFunctionsUnivariateLaurentSeries}
\pagehead{ElementaryFunctionsUnivariateLaurentSeries}{EFULS}
\pagepic{ps/v104elementaryfunctionsunivariatelaurentseries.ps}{EFULS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EFULS ElementaryFunctionsUnivariateLaurentSeries>>=
)abbrev package EFULS ElementaryFunctionsUnivariateLaurentSeries
++ This package provides elementary functions on Laurent series.
++ Author: Clifton J. Williamson
++ Date Created: 6 February 1990
++ Date Last Updated: 25 February 1990
++ Keywords: elementary function, Laurent series
++ Examples:
++ References:
ElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS):_
 Exports == Implementation where
  ++ This package provides elementary functions on any Laurent series
  ++ domain over a field which was constructed from a Taylor series
  ++ domain.  These functions are implemented by calling the
  ++ corresponding functions on the Taylor series domain.  We also
  ++ provide 'partial functions' which compute transcendental
  ++ functions of Laurent series when possible and return "failed"
  ++ when this is not possible.
  Coef   : Algebra Fraction Integer
  UTS    : UnivariateTaylorSeriesCategory Coef
  ULS    : UnivariateLaurentSeriesConstructorCategory(Coef,UTS)
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  RN   ==> Fraction Integer
  S    ==> String
  STTF ==> StreamTranscendentalFunctions(Coef)
 
  Exports ==> PartialTranscendentalFunctions(ULS) with
 
    if Coef has Field then
      "**": (ULS,RN) -> ULS
        ++ s ** r raises a Laurent series s to a rational power r
 
--% Exponentials and Logarithms
 
    exp: ULS -> ULS
      ++ exp(z) returns the exponential of Laurent series z.
    log: ULS -> ULS
      ++ log(z) returns the logarithm of Laurent series z.
 
--% TrigonometricFunctionCategory
 
    sin: ULS -> ULS
      ++ sin(z) returns the sine of Laurent series z.
    cos: ULS -> ULS
      ++ cos(z) returns the cosine of Laurent series z.
    tan: ULS -> ULS
      ++ tan(z) returns the tangent of Laurent series z.
    cot: ULS -> ULS
      ++ cot(z) returns the cotangent of Laurent series z.
    sec: ULS -> ULS
      ++ sec(z) returns the secant of Laurent series z.
    csc: ULS -> ULS
      ++ csc(z) returns the cosecant of Laurent series z.
 
--% ArcTrigonometricFunctionCategory
 
    asin: ULS -> ULS
      ++ asin(z) returns the arc-sine of Laurent series z.
    acos: ULS -> ULS
      ++ acos(z) returns the arc-cosine of Laurent series z.
    atan: ULS -> ULS
      ++ atan(z) returns the arc-tangent of Laurent series z.
    acot: ULS -> ULS
      ++ acot(z) returns the arc-cotangent of Laurent series z.
    asec: ULS -> ULS
      ++ asec(z) returns the arc-secant of Laurent series z.
    acsc: ULS -> ULS
      ++ acsc(z) returns the arc-cosecant of Laurent series z.
 
--% HyperbolicFunctionCategory
 
    sinh: ULS -> ULS
      ++ sinh(z) returns the hyperbolic sine of Laurent series z.
    cosh: ULS -> ULS
      ++ cosh(z) returns the hyperbolic cosine of Laurent series z.
    tanh: ULS -> ULS
      ++ tanh(z) returns the hyperbolic tangent of Laurent series z.
    coth: ULS -> ULS
      ++ coth(z) returns the hyperbolic cotangent of Laurent series z.
    sech: ULS -> ULS
      ++ sech(z) returns the hyperbolic secant of Laurent series z.
    csch: ULS -> ULS
      ++ csch(z) returns the hyperbolic cosecant of Laurent series z.
 
--% ArcHyperbolicFunctionCategory
 
    asinh: ULS -> ULS
      ++ asinh(z) returns the inverse hyperbolic sine of Laurent series z.
    acosh: ULS -> ULS
      ++ acosh(z) returns the inverse hyperbolic cosine of Laurent series z.
    atanh: ULS -> ULS
      ++ atanh(z) returns the inverse hyperbolic tangent of Laurent series z.
    acoth: ULS -> ULS
      ++ acoth(z) returns the inverse hyperbolic cotangent of Laurent series z.
    asech: ULS -> ULS
      ++ asech(z) returns the inverse hyperbolic secant of Laurent series z.
    acsch: ULS -> ULS
      ++ acsch(z) returns the inverse hyperbolic cosecant of Laurent series z.
 
  Implementation ==> add
 
--% roots
 
    RATPOWERS : Boolean := Coef has "**":(Coef,RN) -> Coef
    TRANSFCN  : Boolean := Coef has TranscendentalFunctionCategory
    RATS      : Boolean := Coef has retractIfCan: Coef -> Union(RN,"failed")
 
    nthRootUTS:(UTS,I) -> Union(UTS,"failed")
    nthRootUTS(uts,n) ==
      -- assumed: n > 1, uts has non-zero constant term
--      one? coefficient(uts,0) => uts ** inv(n::RN)
      coefficient(uts,0) = 1 => uts ** inv(n::RN)
      RATPOWERS => uts ** inv(n::RN)
      "failed"
 
    nthRootIfCan(uls,nn) ==
      (n := nn :: I) < 1 => error "nthRootIfCan: n must be positive"
      n = 1 => uls
      deg := degree uls
      if zero? (coef := coefficient(uls,deg)) then
        uls := removeZeroes(1000,uls); deg := degree uls
        zero? (coef := coefficient(uls,deg)) =>
          error "root of series with many leading zero coefficients"
      (k := deg exquo n) case "failed" => "failed"
      uts := taylor(uls * monomial(1,-deg))
      (root := nthRootUTS(uts,n)) case "failed" => "failed"
      monomial(1,k :: I) * (root :: UTS :: ULS)
 
    if Coef has Field then
       (uls:ULS) ** (r:RN) ==
         num := numer r; den := denom r
--         one? den => uls ** num
         den = 1 => uls ** num
         deg := degree uls
         if zero? (coef := coefficient(uls,deg)) then
           uls := removeZeroes(1000,uls); deg := degree uls
           zero? (coef := coefficient(uls,deg)) =>
             error "power of series with many leading zero coefficients"
         (k := deg exquo den) case "failed" =>
           error "**: rational power does not exist"
         uts := taylor(uls * monomial(1,-deg)) ** r
         monomial(1,(k :: I) * num) * (uts :: ULS)
 
--% transcendental functions
 
    applyIfCan: (UTS -> UTS,ULS) -> Union(ULS,"failed")
    applyIfCan(fcn,uls) ==
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      fcn(uts :: UTS) :: ULS
 
    expIfCan   uls == applyIfCan(exp,uls)
    sinIfCan   uls == applyIfCan(sin,uls)
    cosIfCan   uls == applyIfCan(cos,uls)
    asinIfCan  uls == applyIfCan(asin,uls)
    acosIfCan  uls == applyIfCan(acos,uls)
    asecIfCan  uls == applyIfCan(asec,uls)
    acscIfCan  uls == applyIfCan(acsc,uls)
    sinhIfCan  uls == applyIfCan(sinh,uls)
    coshIfCan  uls == applyIfCan(cosh,uls)
    asinhIfCan uls == applyIfCan(asinh,uls)
    acoshIfCan uls == applyIfCan(acosh,uls)
    atanhIfCan uls == applyIfCan(atanh,uls)
    acothIfCan uls == applyIfCan(acoth,uls)
    asechIfCan uls == applyIfCan(asech,uls)
    acschIfCan uls == applyIfCan(acsch,uls)
 
    logIfCan uls ==
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      zero? coefficient(ts := uts :: UTS,0) => "failed"
      log(ts) :: ULS
 
    tanIfCan uls ==
      -- don't call 'tan' on a UTS (tan(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sincos(coefficients(uts :: UTS))$STTF
      (cosInv := recip(series(sc.cos) :: ULS)) case "failed" => "failed"
      (series(sc.sin) :: ULS) * (cosInv :: ULS)
 
    cotIfCan uls ==
      -- don't call 'cot' on a UTS (cot(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sincos(coefficients(uts :: UTS))$STTF
      (sinInv := recip(series(sc.sin) :: ULS)) case "failed" => "failed"
      (series(sc.cos) :: ULS) * (sinInv :: ULS)
 
    secIfCan uls ==
      cos := cosIfCan uls
      cos case "failed" => "failed"
      (cosInv := recip(cos :: ULS)) case "failed" => "failed"
      cosInv :: ULS
 
    cscIfCan uls ==
      sin := sinIfCan uls
      sin case "failed" => "failed"
      (sinInv := recip(sin :: ULS)) case "failed" => "failed"
      sinInv :: ULS

    atanIfCan uls ==
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 => "failed"
      cc : Coef := 
        ord < 0 =>
          TRANSFCN =>
            RATS =>
              lc := coefficient(uls,ord)
              (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" =>
                (1/2) * pi()
              (rat :: RN) > 0 => (1/2) * pi()
              (-1/2) * pi()
            (1/2) * pi()
          return "failed"
        coef = 0 => 0
        TRANSFCN => atan coef
        return "failed"
      (z := recip(1 + uls*uls)) case "failed" => "failed"
      (cc :: ULS) + integrate(differentiate(uls) * (z :: ULS))

    acotIfCan uls ==
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 => "failed"
      cc : Coef := 
        ord < 0 =>
          RATS =>
            lc := coefficient(uls,ord)
            (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" => 0
            (rat :: RN) > 0 => 0
            TRANSFCN => pi()
            return "failed"
          0
        TRANSFCN => acot coef
        return "failed"
      (z := recip(1 + uls*uls)) case "failed" => "failed"
      (cc :: ULS) - integrate(differentiate(uls) * (z :: ULS))
 
    tanhIfCan uls ==
      -- don't call 'tanh' on a UTS (tanh(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sinhcosh(coefficients(uts :: UTS))$STTF
      (coshInv := recip(series(sc.cosh) :: ULS)) case "failed" =>
        "failed"
      (series(sc.sinh) :: ULS) * (coshInv :: ULS)
 
    cothIfCan uls ==
      -- don't call 'coth' on a UTS (coth(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sinhcosh(coefficients(uts :: UTS))$STTF
      (sinhInv := recip(series(sc.sinh) :: ULS)) case "failed" =>
        "failed"
      (series(sc.cosh) :: ULS) * (sinhInv :: ULS)
 
    sechIfCan uls ==
      cosh := coshIfCan uls
      cosh case "failed" => "failed"
      (coshInv := recip(cosh :: ULS)) case "failed" => "failed"
      coshInv :: ULS
 
    cschIfCan uls ==
      sinh := sinhIfCan uls
      sinh case "failed" => "failed"
      (sinhInv := recip(sinh :: ULS)) case "failed" => "failed"
      sinhInv :: ULS
 
    applyOrError:(ULS -> Union(ULS,"failed"),S,ULS) -> ULS
    applyOrError(fcn,name,uls) ==
      ans := fcn uls
      ans case "failed" =>
        error concat(name," of function with singularity")
      ans :: ULS
 
    exp uls   == applyOrError(expIfCan,"exp",uls)
    log uls   == applyOrError(logIfCan,"log",uls)
    sin uls   == applyOrError(sinIfCan,"sin",uls)
    cos uls   == applyOrError(cosIfCan,"cos",uls)
    tan uls   == applyOrError(tanIfCan,"tan",uls)
    cot uls   == applyOrError(cotIfCan,"cot",uls)
    sec uls   == applyOrError(secIfCan,"sec",uls)
    csc uls   == applyOrError(cscIfCan,"csc",uls)
    asin uls  == applyOrError(asinIfCan,"asin",uls)
    acos uls  == applyOrError(acosIfCan,"acos",uls)
    asec uls  == applyOrError(asecIfCan,"asec",uls)
    acsc uls  == applyOrError(acscIfCan,"acsc",uls)
    sinh uls  == applyOrError(sinhIfCan,"sinh",uls)
    cosh uls  == applyOrError(coshIfCan,"cosh",uls)
    tanh uls  == applyOrError(tanhIfCan,"tanh",uls)
    coth uls  == applyOrError(cothIfCan,"coth",uls)
    sech uls  == applyOrError(sechIfCan,"sech",uls)
    csch uls  == applyOrError(cschIfCan,"csch",uls)
    asinh uls == applyOrError(asinhIfCan,"asinh",uls)
    acosh uls == applyOrError(acoshIfCan,"acosh",uls)
    atanh uls == applyOrError(atanhIfCan,"atanh",uls)
    acoth uls == applyOrError(acothIfCan,"acoth",uls)
    asech uls == applyOrError(asechIfCan,"asech",uls)
    acsch uls == applyOrError(acschIfCan,"acsch",uls)

    atan uls ==
    -- code is duplicated so that correct error messages will be returned
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 =>
        error "atan: series expansion has logarithmic term"
      cc : Coef := 
        ord < 0 =>
          TRANSFCN =>
            RATS =>
              lc := coefficient(uls,ord)
              (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" =>
                (1/2) * pi()
              (rat :: RN) > 0 => (1/2) * pi()
              (-1/2) * pi()
            (1/2) * pi()
          error "atan: series expansion involves transcendental constants"
        coef = 0 => 0
        TRANSFCN => atan coef
        error "atan: series expansion involves transcendental constants"
      (z := recip(1 + uls*uls)) case "failed" =>
        error "atan: leading coefficient not invertible"
      (cc :: ULS) + integrate(differentiate(uls) * (z :: ULS))

    acot uls ==
    -- code is duplicated so that correct error messages will be returned
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 =>
        error "acot: series expansion has logarithmic term"
      cc : Coef := 
        ord < 0 =>
          RATS =>
            lc := coefficient(uls,ord)
            (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" => 0
            (rat :: RN) > 0 => 0
            TRANSFCN => pi()
            error "acot: series expansion involves transcendental constants"
          0
        TRANSFCN => acot coef
        error "acot: series expansion involves transcendental constants"
      (z := recip(1 + uls*uls)) case "failed" =>
        error "acot: leading coefficient not invertible"
      (cc :: ULS) - integrate(differentiate(uls) * (z :: ULS))

@
<<EFULS.dotabb>>=
"EFULS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EFULS"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"EFULS" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries}
\pagehead{ElementaryFunctionsUnivariatePuiseuxSeries}{EFUPXS}
\pagepic{ps/v104elementaryfunctionsunivariatepuiseuxseries.ps}{EFUPXS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries>>=
)abbrev package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries
++ This package provides elementary functions on Puiseux series.
++ Author: Clifton J. Williamson
++ Date Created: 20 February 1990
++ Date Last Updated: 20 February 1990
++ Keywords: elementary function, Laurent series
++ Examples:
++ References:
ElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS):_
 Exports == Implementation where
  ++ This package provides elementary functions on any Laurent series
  ++ domain over a field which was constructed from a Taylor series
  ++ domain.  These functions are implemented by calling the
  ++ corresponding functions on the Taylor series domain.  We also
  ++ provide 'partial functions' which compute transcendental
  ++ functions of Laurent series when possible and return "failed"
  ++ when this is not possible.
  Coef   : Algebra Fraction Integer
  ULS    : UnivariateLaurentSeriesCategory Coef
  UPXS   : UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)
  EFULS  : PartialTranscendentalFunctions(ULS)
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  RN   ==> Fraction Integer
 
  Exports ==> PartialTranscendentalFunctions(UPXS) with
 
    if Coef has Field then
      "**": (UPXS,RN) -> UPXS
        ++ z ** r raises a Puiseaux series z to a rational power r
 
--% Exponentials and Logarithms
 
    exp: UPXS -> UPXS
      ++ exp(z) returns the exponential of a Puiseux series z.
    log: UPXS -> UPXS
      ++ log(z) returns the logarithm of a Puiseux series z.
 
--% TrigonometricFunctionCategory
 
    sin: UPXS -> UPXS
      ++ sin(z) returns the sine of a Puiseux series z.
    cos: UPXS -> UPXS
      ++ cos(z) returns the cosine of a Puiseux series z.
    tan: UPXS -> UPXS
      ++ tan(z) returns the tangent of a Puiseux series z.
    cot: UPXS -> UPXS
      ++ cot(z) returns the cotangent of a Puiseux series z.
    sec: UPXS -> UPXS
      ++ sec(z) returns the secant of a Puiseux series z.
    csc: UPXS -> UPXS
      ++ csc(z) returns the cosecant of a Puiseux series z.
 
--% ArcTrigonometricFunctionCategory
 
    asin: UPXS -> UPXS
      ++ asin(z) returns the arc-sine of a Puiseux series z.
    acos: UPXS -> UPXS
      ++ acos(z) returns the arc-cosine of a Puiseux series z.
    atan: UPXS -> UPXS
      ++ atan(z) returns the arc-tangent of a Puiseux series z.
    acot: UPXS -> UPXS
      ++ acot(z) returns the arc-cotangent of a Puiseux series z.
    asec: UPXS -> UPXS
      ++ asec(z) returns the arc-secant of a Puiseux series z.
    acsc: UPXS -> UPXS
      ++ acsc(z) returns the arc-cosecant of a Puiseux series z.
 
--% HyperbolicFunctionCategory
 
    sinh: UPXS -> UPXS
      ++ sinh(z) returns the hyperbolic sine of a Puiseux series z.
    cosh: UPXS -> UPXS
      ++ cosh(z) returns the hyperbolic cosine of a Puiseux series z.
    tanh: UPXS -> UPXS
      ++ tanh(z) returns the hyperbolic tangent of a Puiseux series z.
    coth: UPXS -> UPXS
      ++ coth(z) returns the hyperbolic cotangent of a Puiseux series z.
    sech: UPXS -> UPXS
      ++ sech(z) returns the hyperbolic secant of a Puiseux series z.
    csch: UPXS -> UPXS
      ++ csch(z) returns the hyperbolic cosecant of a Puiseux series z.
 
--% ArcHyperbolicFunctionCategory
 
    asinh: UPXS -> UPXS
      ++ asinh(z) returns the inverse hyperbolic sine of a Puiseux series z.
    acosh: UPXS -> UPXS
      ++ acosh(z) returns the inverse hyperbolic cosine of a Puiseux series z.
    atanh: UPXS -> UPXS
      ++ atanh(z) returns the inverse hyperbolic tangent of a Puiseux series z.
    acoth: UPXS -> UPXS
      ++ acoth(z) returns the inverse hyperbolic cotangent 
      ++ of a Puiseux series z.
    asech: UPXS -> UPXS
      ++ asech(z) returns the inverse hyperbolic secant of a Puiseux series z.
    acsch: UPXS -> UPXS
      ++ acsch(z) returns the inverse hyperbolic cosecant 
      ++ of a Puiseux series z.
 
  Implementation ==> add

    TRANSFCN : Boolean := Coef has TranscendentalFunctionCategory
 
--% roots
 
    nthRootIfCan(upxs,n) ==
--      one? n => upxs
      n = 1 => upxs
      r := rationalPower upxs; uls := laurentRep upxs
      deg := degree uls
      if zero?(coef := coefficient(uls,deg)) then
        deg := order(uls,deg + 1000)
        zero?(coef := coefficient(uls,deg)) =>
          error "root of series with many leading zero coefficients"
      uls := uls * monomial(1,-deg)$ULS
      (ulsRoot := nthRootIfCan(uls,n)) case "failed" => "failed"
      puiseux(r,ulsRoot :: ULS) * monomial(1,deg * r * inv(n :: RN))
 
    if Coef has Field then
       (upxs:UPXS) ** (q:RN) ==
         num := numer q; den := denom q
--         one? den => upxs ** num
         den = 1 => upxs ** num
         r := rationalPower upxs; uls := laurentRep upxs
         deg := degree uls
         if zero?(coef := coefficient(uls,deg)) then
           deg := order(uls,deg + 1000)
           zero?(coef := coefficient(uls,deg)) =>
             error "power of series with many leading zero coefficients"
         ulsPow := (uls * monomial(1,-deg)$ULS) ** q
         puiseux(r,ulsPow) * monomial(1,deg*q*r)
 
--% transcendental functions
 
    applyIfCan: (ULS -> Union(ULS,"failed"),UPXS) -> Union(UPXS,"failed")
    applyIfCan(fcn,upxs) ==
      uls := fcn laurentRep upxs
      uls case "failed" => "failed"
      puiseux(rationalPower upxs,uls :: ULS)
 
    expIfCan   upxs == applyIfCan(expIfCan,upxs)
    logIfCan   upxs == applyIfCan(logIfCan,upxs)
    sinIfCan   upxs == applyIfCan(sinIfCan,upxs)
    cosIfCan   upxs == applyIfCan(cosIfCan,upxs)
    tanIfCan   upxs == applyIfCan(tanIfCan,upxs)
    cotIfCan   upxs == applyIfCan(cotIfCan,upxs)
    secIfCan   upxs == applyIfCan(secIfCan,upxs)
    cscIfCan   upxs == applyIfCan(cscIfCan,upxs)
    atanIfCan  upxs == applyIfCan(atanIfCan,upxs)
    acotIfCan  upxs == applyIfCan(acotIfCan,upxs)
    sinhIfCan  upxs == applyIfCan(sinhIfCan,upxs)
    coshIfCan  upxs == applyIfCan(coshIfCan,upxs)
    tanhIfCan  upxs == applyIfCan(tanhIfCan,upxs)
    cothIfCan  upxs == applyIfCan(cothIfCan,upxs)
    sechIfCan  upxs == applyIfCan(sechIfCan,upxs)
    cschIfCan  upxs == applyIfCan(cschIfCan,upxs)
    asinhIfCan upxs == applyIfCan(asinhIfCan,upxs)
    acoshIfCan upxs == applyIfCan(acoshIfCan,upxs)
    atanhIfCan upxs == applyIfCan(atanhIfCan,upxs)
    acothIfCan upxs == applyIfCan(acothIfCan,upxs)
    asechIfCan upxs == applyIfCan(asechIfCan,upxs)
    acschIfCan upxs == applyIfCan(acschIfCan,upxs)

    asinIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      (coef := coefficient(upxs,0)) = 0 =>
        integrate((1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      TRANSFCN =>
        cc := asin(coef) :: UPXS
        cc + integrate((1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      "failed"

    acosIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := acos(coefficient(upxs,0)) :: UPXS
        cc + integrate(-(1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      "failed"

    asecIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := asec(coefficient(upxs,0)) :: UPXS
        f := (upxs*upxs - 1)**(-1/2) * (differentiate upxs)
        (rec := recip upxs) case "failed" => "failed"
        cc + integrate(f * (rec :: UPXS))
      "failed"

    acscIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := acsc(coefficient(upxs,0)) :: UPXS
        f := -(upxs*upxs - 1)**(-1/2) * (differentiate upxs)
        (rec := recip upxs) case "failed" => "failed"
        cc + integrate(f * (rec :: UPXS))
      "failed"

    asinhIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN or (coefficient(upxs,0) = 0) =>
        log(upxs + (1 + upxs*upxs)**(1/2))
      "failed"

    acoshIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        log(upxs + (upxs*upxs - 1)**(1/2))
      "failed"

    asechIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        (rec := recip upxs) case "failed" => "failed"
        log((1 + (1 - upxs*upxs)*(1/2)) * (rec :: UPXS))
      "failed"

    acschIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        (rec := recip upxs) case "failed" => "failed"
        log((1 + (1 + upxs*upxs)*(1/2)) * (rec :: UPXS))
      "failed"
 
    applyOrError:(UPXS -> Union(UPXS,"failed"),String,UPXS) -> UPXS
    applyOrError(fcn,name,upxs) ==
      ans := fcn upxs
      ans case "failed" =>
        error concat(name," of function with singularity")
      ans :: UPXS
 
    exp upxs   == applyOrError(expIfCan,"exp",upxs)
    log upxs   == applyOrError(logIfCan,"log",upxs)
    sin upxs   == applyOrError(sinIfCan,"sin",upxs)
    cos upxs   == applyOrError(cosIfCan,"cos",upxs)
    tan upxs   == applyOrError(tanIfCan,"tan",upxs)
    cot upxs   == applyOrError(cotIfCan,"cot",upxs)
    sec upxs   == applyOrError(secIfCan,"sec",upxs)
    csc upxs   == applyOrError(cscIfCan,"csc",upxs)
    asin upxs  == applyOrError(asinIfCan,"asin",upxs)
    acos upxs  == applyOrError(acosIfCan,"acos",upxs)
    atan upxs  == applyOrError(atanIfCan,"atan",upxs)
    acot upxs  == applyOrError(acotIfCan,"acot",upxs)
    asec upxs  == applyOrError(asecIfCan,"asec",upxs)
    acsc upxs  == applyOrError(acscIfCan,"acsc",upxs)
    sinh upxs  == applyOrError(sinhIfCan,"sinh",upxs)
    cosh upxs  == applyOrError(coshIfCan,"cosh",upxs)
    tanh upxs  == applyOrError(tanhIfCan,"tanh",upxs)
    coth upxs  == applyOrError(cothIfCan,"coth",upxs)
    sech upxs  == applyOrError(sechIfCan,"sech",upxs)
    csch upxs  == applyOrError(cschIfCan,"csch",upxs)
    asinh upxs == applyOrError(asinhIfCan,"asinh",upxs)
    acosh upxs == applyOrError(acoshIfCan,"acosh",upxs)
    atanh upxs == applyOrError(atanhIfCan,"atanh",upxs)
    acoth upxs == applyOrError(acothIfCan,"acoth",upxs)
    asech upxs == applyOrError(asechIfCan,"asech",upxs)
    acsch upxs == applyOrError(acschIfCan,"acsch",upxs)

@
<<EFUPXS.dotabb>>=
"EFUPXS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EFUPXS"]
"UPXSCCA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UPXSCCA"]
"EFUPXS" -> "UPXSCCA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ELFUTS EllipticFunctionsUnivariateTaylorSeries}
\pagehead{EllipticFunctionsUnivariateTaylorSeries}{ELFUTS}
\pagepic{ps/v104ellipticfunctionsunivariatetaylorseries.ps}{ELFUTS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ELFUTS EllipticFunctionsUnivariateTaylorSeries>>=
)abbrev package ELFUTS EllipticFunctionsUnivariateTaylorSeries
++ Elliptic functions expanded as Taylor series
++ Author: Bill Burge, Clifton J. Williamson
++ Date Created: 1986
++ Date Last Updated: 17 February 1992
++ Keywords: elliptic function, Taylor series
++ Examples:
++ References:
++ Description: The elliptic functions sn, sc and dn are expanded as
++ Taylor series.
EllipticFunctionsUnivariateTaylorSeries(Coef,UTS):
 Exports == Implementation where
  Coef : Field
  UTS  : UnivariateTaylorSeriesCategory Coef
 
  L   ==> List
  I   ==> Integer
  RN  ==> Fraction Integer
  ST  ==> Stream Coef
  STT ==> StreamTaylorSeriesOperations Coef
  YS  ==> Y$ParadoxicalCombinatorsForStreams(Coef)
 
  Exports ==> with
    sn     : (UTS,Coef) -> UTS
      ++\spad{sn(x,k)} expands the elliptic function sn as a Taylor
      ++ series.
    cn     : (UTS,Coef) -> UTS
      ++\spad{cn(x,k)} expands the elliptic function cn as a Taylor
      ++ series.
    dn     : (UTS,Coef) -> UTS
      ++\spad{dn(x,k)} expands the elliptic function dn as a Taylor
      ++ series.
    sncndn: (ST,Coef) -> L ST
       ++\spad{sncndn(s,c)} is used internally.
 
  Implementation ==> add
    import StreamTaylorSeriesOperations Coef
    UPS==> StreamTaylorSeriesOperations Coef
    integrate ==> lazyIntegrate
    sncndnre:(Coef,L ST,ST,Coef) -> L ST
    sncndnre(k,scd,dx,sign) ==
            [integrate(0,      scd.2*$UPS scd.3*$UPS dx),  _
             integrate(1,  sign*scd.1*$UPS scd.3*$UPS dx),  _
             integrate(1,sign*k**2*$UPS scd.1*$UPS scd.2*$UPS dx)]
 
    sncndn(z,k) ==
      empty? z => [0 :: ST,1 :: ST,1::ST]
      frst z = 0 => YS(sncndnre(k,#1,deriv z,-1),3)
      error "ELFUTS:sncndn: constant coefficient should be 0"
    sn(x,k)  == series sncndn.(coefficients x,k).1
    cn(x,k)  == series sncndn.(coefficients x,k).2
    dn(x,k)  == series sncndn.(coefficients x,k).3

@
<<ELFUTS.dotabb>>=
"ELFUTS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ELFUTS"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"ELFUTS" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EQ2 EquationFunctions2}
\pagehead{EquationFunctions2}{EQ2}
\pagepic{ps/v104equationfunctions2.ps}{EQ2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EQ2 EquationFunctions2>>=
)abbrev package EQ2 EquationFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains: Equation
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping the sides of equations.
EquationFunctions2(S: Type, R: Type): with
    map: (S ->R ,Equation S) -> Equation R
	++ map(f,eq) returns an equation where f is applied to the sides of eq
 == add
    map(fn, eqn) == equation(fn lhs eqn, fn rhs eqn)

@
<<EQ2.dotabb>>=
"EQ2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EQ2"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"EQ2" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ERROR ErrorFunctions}
\pagehead{ErrorFunctions}{ERROR}
\pagepic{ps/v104errorfunctions.ps}{ERROR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ERROR ErrorFunctions>>=
)abbrev package ERROR ErrorFunctions
++ Author: Robert S. Sutor
++ Date Created: 29 May 1990
++ Date Last Updated: 29 May 1990
++ Description:
++ ErrorFunctions implements error functions callable from the system
++ interpreter.  Typically, these functions would be called in user
++ functions.  The simple forms of the functions take one argument
++ which is either a string (an error message) or a list of strings
++ which all together make up a message.  The list can contain
++ formatting codes (see below).  The more sophisticated versions takes
++ two arguments where the first argument is the name of the function
++ from which the error was invoked and the second argument is either a
++ string or a list of strings, as above.  When you use the one
++ argument version in an interpreter function, the system will
++ automatically insert the name of the function as the new first
++ argument.  Thus in the user interpreter function
++   \spad{f x == if x < 0 then error "negative argument" else x}
++ the call to error will actually be of the form
++   \spad{error("f","negative argument")}
++ because the interpreter will have created a new first argument.
++
++ Formatting codes:  error messages may contain the following
++ formatting codes (they should either start or end a string or
++ else have blanks around them):
++    \spad{%l}      start a new line
++    \spad{%b}      start printing in a bold font (where available)
++    \spad{%d}      stop  printing in a bold font (where available)
++    \spad{ %ceon}  start centering message lines
++    \spad{%ceoff}  stop  centering message lines
++    \spad{%rjon}   start displaying lines "ragged left"
++    \spad{%rjoff}  stop  displaying lines "ragged left"
++    \spad{%i}      indent   following lines 3 additional spaces
++    \spad{%u}      unindent following lines 3 additional spaces
++    \spad{%xN}     insert N blanks (eg, \spad{%x10} inserts 10 blanks)
++
++ Examples:
++   1.  \spad{error "Whoops, you made a %l %ceon %b big %d %ceoff %l mistake!"}
++   2.  \spad{error ["Whoops, you made a","%l %ceon %b","big",
++              "%d %ceoff %l","mistake!"]}
 
ErrorFunctions() : Exports == Implementation where
  Exports ==> with
    error: String -> Exit 
      ++ error(msg) displays error message msg and terminates.
    error: List String -> Exit            
      ++ error(lmsg) displays error message lmsg and terminates.
    error: (String,String) -> Exit        
      ++ error(nam,msg) displays error message msg preceded by a
      ++ message containing the name nam of the function in which
      ++ the error is contained.
    error: (String,List String) -> Exit   
      ++ error(nam,lmsg) displays error messages lmsg preceded by a
      ++ message containing the name nam of the function in which
      ++ the error is contained.
  Implementation ==> add
 
    prefix1 : String := "Error signalled from user code: %l "
    prefix2 : String := "Error signalled from user code in function %b "
 
    doit(s : String) : Exit ==
      throwPatternMsg(s,nil$(List String))$Lisp
      -- there are no objects of type Exit, so we'll fake one,
      -- knowing we will never get to this step anyway.
      "exit" pretend Exit
 
    error(s : String) : Exit ==
      doit concat [prefix1,s]
 
    error(l : List String) : Exit ==
      s : String := prefix1
      for x in l repeat s := concat [s," ",x]
      doit s
 
    error(fn : String,s : String) : Exit ==
      doit concat [prefix2,fn,": %d %l ",s]
 
    error(fn : String, l : List String) : Exit ==
      s : String := concat [prefix2,fn,": %d %l"]
      for x in l repeat s := concat [s," ",x]
      doit s

@
<<ERROR.dotabb>>=
"ERROR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ERROR"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"ERROR" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EVALCYC EvaluateCycleIndicators}
\pagehead{EvaluateCycleIndicators}{EVALCYC}
\pagepic{ps/v104evaluatecycleindicators.ps}{EVALCYC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EVALCYC EvaluateCycleIndicators>>=
)abbrev package EVALCYC EvaluateCycleIndicators
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: Feb 1992
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: This package is to be used in conjuction with
++             the CycleIndicators package. It provides an evaluation
++             function for SymmetricPolynomials.
EvaluateCycleIndicators(F):T==C where
    F:Algebra Fraction Integer
    I==>Integer
    L==>List
    SPOL==SymmetricPolynomial
    RN==>Fraction Integer
    PR==>Polynomial(RN)
    PTN==>Partition()
    lc ==> leadingCoefficient
    red ==> reductum
    T== with
       eval:((I->F),SPOL RN)->F
         ++\spad{eval(f,s)} evaluates the cycle index s by applying
         ++ the function f to each integer in a monomial partition,
         ++ forms their product and sums the results over all monomials.
    C== add
       evp:((I->F),PTN)->F
       fn:I->F
       pt:PTN
       spol:SPOL RN
       i:I
       evp(fn, pt)== _*/[fn i for i in pt::(L I)]
 
       eval(fn,spol)==
        if spol=0
        then 0
        else ((lc spol)* evp(fn,degree spol)) + eval(fn,red spol)

@
<<EVALCYC.dotabb>>=
"EVALCYC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EVALCYC"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"EVALCYC" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ESCONT ExpertSystemContinuityPackage}
\pagehead{ExpertSystemContinuityPackage}{ESCONT}
\pagepic{ps/v104expertsystemcontinuitypackage.ps}{ESCONT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<ESCONT.dotabb>>=
"ESCONT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT"]

@
<<package ESCONT ExpertSystemContinuityPackage>>=
)abbrev package ESCONT ExpertSystemContinuityPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: June 1995
++ Basic Operations: problemPoints, singularitiesOf, zerosOf
++ Related Constructors:
++ Description:
++ ExpertSystemContinuityPackage is a package of functions for the use of domains
++ belonging to the category \axiomType{NumericalIntegration}.

ExpertSystemContinuityPackage(): E == I where
  EF2   ==> ExpressionFunctions2
  FI    ==> Fraction Integer
  EFI   ==> Expression Fraction Integer
  PFI   ==> Polynomial Fraction Integer
  DF    ==> DoubleFloat
  LDF   ==> List DoubleFloat
  EDF   ==> Expression DoubleFloat
  VEDF  ==> Vector Expression DoubleFloat
  SDF   ==> Stream DoubleFloat
  SS    ==> Stream String
  EEDF  ==> Equation Expression DoubleFloat
  LEDF  ==> List Expression DoubleFloat
  KEDF  ==> Kernel Expression DoubleFloat
  LKEDF ==> List Kernel Expression DoubleFloat
  PDF   ==> Polynomial DoubleFloat
  FPDF  ==> Fraction Polynomial DoubleFloat
  OCDF  ==> OrderedCompletion DoubleFloat
  SOCDF ==> Segment OrderedCompletion DoubleFloat
  NIA   ==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  UP    ==> UnivariatePolynomial
  BO    ==> BasicOperator
  RS    ==> Record(zeros: SDF,ones: SDF,singularities: SDF)

  E ==> with

    getlo : SOCDF -> DF
      ++ getlo(u) gets the \axiomType{DoubleFloat} equivalent of
      ++ the first endpoint of the range \axiom{u}
    gethi : SOCDF -> DF
      ++ gethi(u) gets the \axiomType{DoubleFloat} equivalent of
      ++ the second endpoint of the range \axiom{u}
    functionIsFracPolynomial?: NIA -> Boolean
      ++ functionIsFracPolynomial?(args) tests whether the function
      ++ can be retracted to \axiomType{Fraction(Polynomial(DoubleFloat))}
    problemPoints:(EDF,Symbol,SOCDF) -> List DF
      ++ problemPoints(f,var,range) returns a list of possible problem points
      ++ by looking at the zeros of the denominator of the function \spad{f}
      ++ if it can be retracted to \axiomType{Polynomial(DoubleFloat)}.
    zerosOf:(EDF,List Symbol,SOCDF) -> SDF
      ++ zerosOf(e,vars,range) returns a list of points  
      ++ (\axiomType{Doublefloat}) at which a NAG fortran version of \spad{e}
      ++ will most likely produce an error.
    singularitiesOf: (EDF,List Symbol,SOCDF) -> SDF
      ++ singularitiesOf(e,vars,range) returns a list of points 
      ++ (\axiomType{Doublefloat}) at which a NAG fortran 
      ++ version of \spad{e} will most likely produce
      ++ an error.  This includes those points which evaluate to 0/0.
    singularitiesOf: (Vector EDF,List Symbol,SOCDF) -> SDF
      ++ singularitiesOf(v,vars,range) returns a list of points 
      ++ (\axiomType{Doublefloat}) at which a NAG fortran 
      ++ version of \spad{v} will most likely produce
      ++ an error.  This includes those points which evaluate to 0/0.
    polynomialZeros:(PFI,Symbol,SOCDF) -> LDF
      ++ polynomialZeros(fn,var,range) calculates the real zeros of the 
      ++ polynomial which are contained in the given interval. It returns 
      ++ a list of points (\axiomType{Doublefloat}) for which the univariate 
      ++ polynomial \spad{fn} is zero.
    df2st:DF -> String 
      ++ df2st(n) coerces a \axiomType{DoubleFloat} to \axiomType{String}
    ldf2lst:LDF -> List String
      ++ ldf2lst(ln) coerces a List of \axiomType{DoubleFloat} to 
      ++ \axiomType{List}(\axiomType{String})
    sdf2lst:SDF -> List String
      ++ sdf2lst(ln) coerces a Stream of \axiomType{DoubleFloat} to 
      ++ \axiomType{List}(\axiomType{String})

  I ==> ExpertSystemToolsPackage add

    import ExpertSystemToolsPackage

    functionIsPolynomial?(args:NIA):Boolean ==
      -- tests whether the function can be retracted to a polynomial
      (retractIfCan(args.fn)@Union(PDF,"failed"))$EDF case PDF

    isPolynomial?(f:EDF):Boolean ==
      -- tests whether the function can be retracted to a polynomial
      (retractIfCan(f)@Union(PDF,"failed"))$EDF case PDF

    isConstant?(f:EDF):Boolean ==
      -- tests whether the function can be retracted to a constant (DoubleFloat)
      (retractIfCan(f)@Union(DF,"failed"))$EDF case DF

    denominatorIsPolynomial?(args:NIA):Boolean ==
      -- tests if the denominator can be retracted to polynomial
      a:= copy args
      a.fn:=denominator(args.fn)
      (functionIsPolynomial?(a))@Boolean

    denIsPolynomial?(f:EDF):Boolean ==
      -- tests if the denominator can be retracted to polynomial
      (isPolynomial?(denominator f))@Boolean

    listInRange(l:LDF,range:SOCDF):LDF ==
      -- returns a list with only those elements internal to the range range
      [t for t in l | in?(t,range)]

    loseUntil(l:SDF,a:DF):SDF ==
      empty?(l)$SDF => l
      f := first(l)$SDF
      (abs(f) <= abs(a)) => loseUntil(rest(l)$SDF,a)
      l

    retainUntil(l:SDF,a:DF,b:DF,flag:Boolean):SDF ==
      empty?(l)$SDF => l
      f := first(l)$SDF
      (in?(f)$ExpertSystemContinuityPackage1(a,b)) =>
        concat(f,retainUntil(rest(l),a,b,false)) 
      flag => empty()$SDF
      retainUntil(rest(l),a,b,true)

    streamInRange(l:SDF,range:SOCDF):SDF ==
      -- returns a stream with only those elements internal to the range range
      a := getlo(range := dfRange(range))
      b := gethi(range)
      explicitlyFinite?(l) =>
        select(in?$ExpertSystemContinuityPackage1(a,b),l)$SDF
      negative?(a*b) => retainUntil(l,a,b,false)                
      negative?(a) => 
        l := loseUntil(l,b)
        retainUntil(l,a,b,false)
      l := loseUntil(l,a)
      retainUntil(l,a,b,false)

    getStream(n:Symbol,s:String):SDF ==
      import RS
      entry?(n,bfKeys()$BasicFunctions)$(List(Symbol)) =>
        c := bfEntry(n)$BasicFunctions
        (s = "zeros")@Boolean => c.zeros
        (s = "singularities")@Boolean => c.singularities
        (s = "ones")@Boolean => c.ones
      empty()$SDF

    polynomialZeros(fn:PFI,var:Symbol,range:SOCDF):LDF ==
      up := unmakeSUP(univariate(fn)$PFI)$UP(var,FI)
      range := dfRange(range)
      r:Record(left:FI,right:FI) := [df2fi(getlo(range)), df2fi(gethi(range))]
      ans:List(Record(left:FI,right:FI)) := 
          realZeros(up,r,1/1000000000000000000)$RealZeroPackageQ(UP(var,FI))
      listInRange(dflist(ans),range)

    functionIsFracPolynomial?(args:NIA):Boolean ==
      -- tests whether the function can be retracted to a fraction
      -- where both numerator and denominator are polynomial
      (retractIfCan(args.fn)@Union(FPDF,"failed"))$EDF case FPDF

    problemPoints(f:EDF,var:Symbol,range:SOCDF):LDF ==
      (denIsPolynomial?(f))@Boolean =>
        c := retract(edf2efi(denominator(f)))@PFI
        polynomialZeros(c,var,range)
      empty()$LDF

    zerosOf(e:EDF,vars:List Symbol,range:SOCDF):SDF ==
      (u := isQuotient(e)) case EDF =>
        singularitiesOf(u,vars,range)
      k := kernels(e)$EDF
      ((nk := # k) = 0)@Boolean => empty()$SDF -- constant found.
      (nk = 1)@Boolean =>                      -- single expression found.
        ker := first(k)$LKEDF
        n := name(operator(ker)$KEDF)$BO
        entry?(n,vars) =>                   -- polynomial found.
          c := retract(edf2efi(e))@PFI
          coerce(polynomialZeros(c,n,range))$SDF
        a := first(argument(ker)$KEDF)$LEDF
        (not (n = log :: Symbol)@Boolean) and ((w := isPlus a) case LEDF) =>
          var:Symbol := first(variables(a))
          c:EDF := w.2
          c1:EDF := w.1
--          entry?(c1,[b::EDF for b in vars]) and (one?(# vars)) =>
          entry?(c1,[b::EDF for b in vars]) and ((# vars) = 1) =>
            c2:DF := edf2df c
            c3 := c2 :: OCDF
            varEdf := var :: EDF
            varEqn := equation(varEdf,c1-c)$EEDF
            range2 := (lo(range)+c3)..(hi(range)+c3)
            s := zerosOf(subst(e,varEqn)$EDF,vars,range2)
            st := map(#1-c2,s)$StreamFunctions2(DF,DF)
            streamInRange(st,range)
          zerosOf(a,vars,range)
        (t := isPlus(e)$EDF) case LEDF =>    -- constant + expression
          # t > 2 => empty()$SDF
          entry?(a,[b::EDF for b in vars]) =>   -- finds entries like sqrt(x)
            st := getStream(n,"ones")
            o := edf2df(second(t)$LEDF)
--            one?(o) or one?(-o) =>           -- is it like (f(x) -/+ 1)
            (o = 1) or (-o = 1) =>           -- is it like (f(x) -/+ 1)
              st := map(-#1/o,st)$StreamFunctions2(DF,DF)
              streamInRange(st,range)
            empty()$SDF
          empty()$SDF
        entry?(a,[b::EDF for b in vars]) =>     -- finds entries like sqrt(x)
          st := getStream(n,"zeros")
          streamInRange(st,range)
        (n = tan :: Symbol)@Boolean => 
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        (n = sin :: Symbol)@Boolean => 
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        empty()$SDF
      (t := isPlus(e)$EDF) case LEDF => empty()$SDF  -- INCOMPLETE!!!
      (v := isTimes(e)$EDF) case LEDF =>
        concat([zerosOf(u,vars,range) for u in v])
      empty()$SDF

    singularitiesOf(e:EDF,vars:List Symbol,range:SOCDF):SDF ==
      (u := isQuotient(e)) case EDF =>
        zerosOf(u,vars,range)
      (t := isPlus e) case LEDF =>
        concat([singularitiesOf(u,vars,range) for u in t])
      (v := isTimes e) case LEDF =>
        concat([singularitiesOf(u,vars,range) for u in v])
      (k := mainKernel e) case KEDF => 
        n := name(operator k)
        entry?(n,vars) => coerce(problemPoints(e,n,range))$SDF
        a:EDF := (argument k).1
        (not (n = log :: Symbol)@Boolean) and ((w := isPlus a) case LEDF) =>
          var:Symbol := first(variables(a))
          c:EDF := w.2
          c1:EDF := w.1
--          entry?(c1,[b::EDF for b in vars]) and (one?(# vars)) =>
          entry?(c1,[b::EDF for b in vars]) and ((# vars) = 1) =>
            c2:DF := edf2df c
            c3 := c2 :: OCDF
            varEdf := var :: EDF
            varEqn := equation(varEdf,c1-c)$EEDF
            range2 := (lo(range)+c3)..(hi(range)+c3)
            s := singularitiesOf(subst(e,varEqn)$EDF,vars,range2)
            st := map(#1-c2,s)$StreamFunctions2(DF,DF)
            streamInRange(st,range)
          singularitiesOf(a,vars,range)
        entry?(a,[b::EDF for b in vars]) =>
          st := getStream(n,"singularities")
          streamInRange(st,range)
        (n = log :: Symbol)@Boolean =>
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        singularitiesOf(a,vars,range)
      empty()$SDF

    singularitiesOf(v:VEDF,vars:List Symbol,range:SOCDF):SDF ==
      ls := [singularitiesOf(u,vars,range) for u in entries(v)$VEDF]
      concat(ls)$SDF

@
<<ESCONT.dotabb>>=
"ESCONT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ESCONT1 ExpertSystemContinuityPackage1}
\pagehead{ExpertSystemContinuityPackage1}{ESCONT1}
\pagepic{ps/v104expertsystemcontinuitypackage1.ps}{ESCONT1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ESCONT1 ExpertSystemContinuityPackage1>>=
)abbrev package ESCONT1 ExpertSystemContinuityPackage1
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: June 1995
++ Basic Operations: problemPoints, singularitiesOf, zerosOf
++ Related Constructors:
++ Description:
++ ExpertSystemContinuityPackage1 exports a function to check range inclusion

ExpertSystemContinuityPackage1(A:DF,B:DF): E == I where
  EF2   ==> ExpressionFunctions2
  FI    ==> Fraction Integer
  EFI   ==> Expression Fraction Integer
  PFI   ==> Polynomial Fraction Integer
  DF    ==> DoubleFloat
  LDF   ==> List DoubleFloat
  EDF   ==> Expression DoubleFloat
  VEDF  ==> Vector Expression DoubleFloat
  SDF   ==> Stream DoubleFloat
  SS    ==> Stream String
  EEDF  ==> Equation Expression DoubleFloat
  LEDF  ==> List Expression DoubleFloat
  KEDF  ==> Kernel Expression DoubleFloat
  LKEDF ==> List Kernel Expression DoubleFloat
  PDF   ==> Polynomial DoubleFloat
  FPDF  ==> Fraction Polynomial DoubleFloat
  OCDF  ==> OrderedCompletion DoubleFloat
  SOCDF ==> Segment OrderedCompletion DoubleFloat
  NIA   ==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  UP    ==> UnivariatePolynomial
  BO    ==> BasicOperator
  RS    ==> Record(zeros: SDF,ones: SDF,singularities: SDF)

  E ==> with

    in?:DF -> Boolean
      ++ in?(p) tests whether point p is internal to the range [\spad{A..B}]

  I ==> add 

    in?(p:DF):Boolean ==
      a:Boolean := (p < B)$DF
      b:Boolean := (A < p)$DF
      (a and b)@Boolean

@
<<ESCONT1.dotabb>>=
"ESCONT1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT1"]
"ESCONT1" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPR2 ExpressionFunctions2}
\pagehead{ExpressionFunctions2}{EXPR2}
\pagepic{ps/v104ExpressionFunctions2.ps}{EXPR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPR2 ExpressionFunctions2>>=
)abbrev package EXPR2 ExpressionFunctions2
++ Lifting of maps to Expressions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to Expressions.
++ Date Created: 16 Jan 1989
++ Date Last Updated: 22 Jan 1990
ExpressionFunctions2(R:OrderedSet, S:OrderedSet):
 Exports == Implementation where
  K   ==> Kernel R
  F2  ==> FunctionSpaceFunctions2(R, Expression R, S, Expression S)
  E2  ==> ExpressionSpaceFunctions2(Expression R, Expression S)

  Exports ==> with
    map: (R -> S, Expression R) -> Expression S
      ++ map(f, e) applies f to all the constants appearing in e.

  Implementation == add
    if S has Ring and R has Ring then
      map(f, r) == map(f, r)$F2
    else
      map(f, r) == map(map(f, #1), retract r)$E2

@
<<EXPR2.dotabb>>=
"EXPR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPR2"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EXPR2" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPRODE ExpressionSpaceODESolver}
\pagehead{ExpressionSpaceODESolver}{EXPRODE}
\pagepic{ps/v104expressionspaceodesolver.ps}{EXPRODE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPRODE ExpressionSpaceODESolver>>=
)abbrev package EXPRODE ExpressionSpaceODESolver
++ Taylor series solutions of ODE's
++ Author: Manuel Bronstein
++ Date Created: 5 Mar 1990
++ Date Last Updated: 30 September 1993
++ Description: Taylor series solutions of explicit ODE's;
++ Keywords: differential equation, ODE, Taylor series
ExpressionSpaceODESolver(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain, ConvertibleTo InputForm)
  F: FunctionSpace R

  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  OP  ==> BasicOperator
  SY  ==> Symbol
  UTS ==> UnivariateTaylorSeries(F, x, center)
  MKF ==> MakeUnaryCompiledFunction(F, UTS, UTS)
  MKL ==> MakeUnaryCompiledFunction(F, List UTS, UTS)
  A1  ==> AnyFunctions1(UTS)
  AL1 ==> AnyFunctions1(List UTS)
  EQ  ==> Equation F
  ODE ==> UnivariateTaylorSeriesODESolver(F, UTS)

  Exports ==> with
    seriesSolve: (EQ, OP, EQ, EQ) -> Any
      ++ seriesSolve(eq,y,x=a, y a = b) returns a Taylor series solution
      ++ of eq around x = a with initial condition \spad{y(a) = b}.
      ++ Note: eq must be of the form
      ++ \spad{f(x, y x) y'(x) + g(x, y x) = h(x, y x)}.
    seriesSolve: (EQ, OP, EQ, List F) -> Any
      ++ seriesSolve(eq,y,x=a,[b0,...,b(n-1)]) returns a Taylor series
      ++ solution of eq around \spad{x = a} with initial conditions
      ++ \spad{y(a) = b0}, \spad{y'(a) = b1},
      ++ \spad{y''(a) = b2}, ...,\spad{y(n-1)(a) = b(n-1)}
      ++ eq must be of the form
      ++ \spad{f(x, y x, y'(x),..., y(n-1)(x)) y(n)(x) +
      ++ g(x,y x,y'(x),...,y(n-1)(x)) = h(x,y x, y'(x),..., y(n-1)(x))}.
    seriesSolve: (List EQ, List OP, EQ, List EQ) -> Any
      ++ seriesSolve([eq1,...,eqn],[y1,...,yn],x = a,[y1 a = b1,...,yn a = bn])
      ++ returns a taylor series solution of \spad{[eq1,...,eqn]} around
      ++ \spad{x = a} with initial conditions \spad{yi(a) = bi}.
      ++ Note: eqi must be of the form
      ++ \spad{fi(x, y1 x, y2 x,..., yn x) y1'(x) +
      ++ gi(x, y1 x, y2 x,..., yn x) = h(x, y1 x, y2 x,..., yn x)}.
    seriesSolve: (List EQ, List OP, EQ, List F) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1,...,eqn], [y1,...,yn], x = a,
      ++ [y1 a = b1,..., yn a = bn])}.
    seriesSolve: (List F, List OP, EQ, List F) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], x=a, [b1,...,bn])}.
    seriesSolve: (List F, List OP, EQ, List EQ) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x = a,[y1 a = b1,..., yn a = bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], x = a,
      ++ [y1 a = b1,..., yn a = bn])}.
    seriesSolve: (EQ, OP, EQ, F) -> Any
      ++ seriesSolve(eq,y, x=a, b) is equivalent to
      ++ \spad{seriesSolve(eq, y, x=a, y a = b)}.
    seriesSolve: (F, OP, EQ, F) -> Any
      ++ seriesSolve(eq, y, x = a, b) is equivalent to
      ++ \spad{seriesSolve(eq = 0, y, x = a, y a = b)}.
    seriesSolve: (F, OP, EQ, EQ) -> Any
      ++ seriesSolve(eq, y, x = a, y a = b) is equivalent to
      ++ \spad{seriesSolve(eq=0, y, x=a, y a = b)}.
    seriesSolve: (F, OP, EQ, List F) -> Any
      ++ seriesSolve(eq, y, x = a, [b0,...,bn]) is equivalent to
      ++ \spad{seriesSolve(eq = 0, y, x = a, [b0,...,b(n-1)])}.

  Implementation ==> add
    checkCompat: (OP, EQ, EQ) -> F
    checkOrder1: (F, OP, K, SY, F) -> F
    checkOrderN: (F, OP, K, SY, F, NonNegativeInteger) -> F
    checkSystem: (F, List K, List F) -> F
    div2exquo  : F -> F
    smp2exquo  : P -> F
    k2exquo    : K -> F
    diffRhs    : (F, F) -> F
    diffRhsK   : (K, F) -> F
    findCompat : (F, List EQ) -> F
    findEq     : (K, SY, List F) -> F
    localInteger: F -> F

    opelt := operator("elt"::Symbol)$OP
    --opex  := operator("exquo"::Symbol)$OP
    opex  := operator("fixedPointExquo"::Symbol)$OP
    opint := operator("integer"::Symbol)$OP

    Rint? := R has IntegerNumberSystem

    localInteger n == (Rint? => n; opint n)
    diffRhs(f, g) == diffRhsK(retract(f)@K, g)

    k2exquo k ==
      is?(op := operator k, "%diff"::Symbol) =>
        error "Improper differential equation"
      kernel(op, [div2exquo f for f in argument k]$List(F))

    smp2exquo p ==
      map(k2exquo,#1::F,p)$PolynomialCategoryLifting(IndexedExponents K,
                                                             K, R, P, F)

    div2exquo f ==
--      one?(d := denom f) => f
      ((d := denom f) = 1) => f
      opex(smp2exquo numer f, smp2exquo d)

-- if g is of the form a * k + b, then return -b/a
    diffRhsK(k, g) ==
      h := univariate(g, k)
      (degree(numer h) <= 1) and ground? denom h =>
        - coefficient(numer h, 0) / coefficient(numer h, 1)
      error "Improper differential equation"

    checkCompat(y, eqx, eqy) ==
      lhs(eqy) =$F y(rhs eqx) => rhs eqy
      error "Improper initial value"

    findCompat(yx, l) ==
      for eq in l repeat
        yx =$F lhs eq => return rhs eq
      error "Improper initial value"

    findEq(k, x, sys) ==
      k := retract(differentiate(k::F, x))@K
      for eq in sys repeat
        member?(k, kernels eq) => return eq
      error "Improper differential equation"

    checkOrder1(diffeq, y, yx, x, sy) ==
      div2exquo subst(diffRhs(differentiate(yx::F,x),diffeq),[yx],[sy])

    checkOrderN(diffeq, y, yx, x, sy, n) ==
      zero? n => error "No initial value(s) given"
      m     := (minIndex(l := [retract(f := yx::F)@K]$List(K)))::F
      lv    := [opelt(sy, localInteger m)]$List(F)
      for i in 2..n repeat
        l  := concat(retract(f := differentiate(f, x))@K, l)
        lv := concat(opelt(sy, localInteger(m := m + 1)), lv)
      div2exquo subst(diffRhs(differentiate(f, x), diffeq), l, lv)

    checkSystem(diffeq, yx, lv) ==
      for k in kernels diffeq repeat
        is?(k, "%diff"::SY) =>
          return div2exquo subst(diffRhsK(k, diffeq), yx, lv)
      0

    seriesSolve(l:List EQ, y:List OP, eqx:EQ, eqy:List EQ) ==
      seriesSolve([lhs deq - rhs deq for deq in l]$List(F), y, eqx, eqy)

    seriesSolve(l:List EQ, y:List OP, eqx:EQ, y0:List F) ==
      seriesSolve([lhs deq - rhs deq for deq in l]$List(F), y, eqx, y0)

    seriesSolve(l:List F, ly:List OP, eqx:EQ, eqy:List EQ) ==
      seriesSolve(l, ly, eqx,
                  [findCompat(y rhs eqx, eqy) for y in ly]$List(F))

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, eqy:EQ) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, eqy)

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, y0:F) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, y0)

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, y0:List F) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, y0)

    seriesSolve(diffeq:F, y:OP, eqx:EQ, eqy:EQ) ==
      seriesSolve(diffeq, y, eqx, checkCompat(y, eqx, eqy))

    seriesSolve(diffeq:F, y:OP, eqx:EQ, y0:F) ==
      x      := symbolIfCan(retract(lhs eqx)@K)::SY
      sy     := name y
      yx     := retract(y lhs eqx)@K
      f      := checkOrder1(diffeq, y, yx, x, sy::F)
      center := rhs eqx
      coerce(ode1(compiledFunction(f, sy)$MKF, y0)$ODE)$A1

    seriesSolve(diffeq:F, y:OP, eqx:EQ, y0:List F) ==
      x      := symbolIfCan(retract(lhs eqx)@K)::SY
      sy     := new()$SY
      yx     := retract(y lhs eqx)@K
      f      := checkOrderN(diffeq, y, yx, x, sy::F, #y0)
      center := rhs eqx
      coerce(ode(compiledFunction(f, sy)$MKL, y0)$ODE)$A1

    seriesSolve(sys:List F, ly:List OP, eqx:EQ, l0:List F) ==
      x      := symbolIfCan(kx := retract(lhs eqx)@K)::SY
      fsy    := (sy := new()$SY)::F
      m      := (minIndex(l0) - 1)::F
      yx     := concat(kx, [retract(y lhs eqx)@K for y in ly]$List(K))
      lelt   := [opelt(fsy, localInteger(m := m+1)) for k in yx]$List(F)
      sys    := [findEq(k, x, sys) for k in rest yx]
      l      := [checkSystem(eq, yx, lelt) for eq in sys]$List(F)
      center := rhs eqx
      coerce(mpsode(l0,[compiledFunction(f,sy)$MKL for f in l])$ODE)$AL1

@
<<EXPRODE.dotabb>>=
"EXPRODE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPRODE"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EXPRODE" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPR2UPS ExpressionToUnivariatePowerSeries}
\pagehead{ExpressionToUnivariatePowerSeries}{EXPR2UPS}
\pagepic{ps/v104expressiontounivariatepowerseries.ps}{EXPR2UPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPR2UPS ExpressionToUnivariatePowerSeries>>=
)abbrev package EXPR2UPS ExpressionToUnivariatePowerSeries
++ Author: Clifton J. Williamson
++ Date Created: 9 May 1989
++ Date Last Updated: 20 September 1993
++ Basic Operations: taylor, laurent, puiseux, series
++ Related Domains: UnivariateTaylorSeries, UnivariateLaurentSeries,
++   UnivariatePuiseuxSeries, Expression
++ Also See: FunctionSpaceToUnivariatePowerSeries
++ AMS Classifications:
++ Keywords: Taylor series, Laurent series, Puiseux series
++ Examples:
++ References:
++ Description:
++   This package provides functions to convert functional expressions
++   to power series.
ExpressionToUnivariatePowerSeries(R,FE): Exports == Implementation where
  R  : Join(GcdDomain,OrderedSet,RetractableTo Integer,_
            LinearlyExplicitRingOver Integer)
  FE : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
            FunctionSpace R)

  EQ     ==> Equation
  I      ==> Integer
  NNI    ==> NonNegativeInteger
  RN     ==> Fraction Integer
  SY     ==> Symbol
  UTS    ==> UnivariateTaylorSeries
  ULS    ==> UnivariateLaurentSeries
  UPXS   ==> UnivariatePuiseuxSeries
  GSER   ==> GeneralUnivariatePowerSeries
  EFULS  ==> ElementaryFunctionsUnivariateLaurentSeries
  EFUPXS ==> ElementaryFunctionsUnivariatePuiseuxSeries
  FS2UPS ==> FunctionSpaceToUnivariatePowerSeries
  Prob   ==> Record(func:String,prob:String)
  ANY1   ==> AnyFunctions1

  Exports ==> with
    taylor: SY -> Any
      ++ \spad{taylor(x)} returns x viewed as a Taylor series.
    taylor: FE -> Any
      ++ \spad{taylor(f)} returns a Taylor expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    taylor: (FE,NNI) -> Any
      ++ \spad{taylor(f,n)} returns a Taylor expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    taylor: (FE,EQ FE) -> Any
      ++ \spad{taylor(f,x = a)} expands the expression f as a Taylor series
      ++ in powers of \spad{(x - a)}.
    taylor: (FE,EQ FE,NNI) -> Any
      ++ \spad{taylor(f,x = a)} expands the expression f as a Taylor series
      ++ in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.

    laurent: SY -> Any
      ++ \spad{laurent(x)} returns x viewed as a Laurent series.
    laurent: FE -> Any
      ++ \spad{laurent(f)} returns a Laurent expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    laurent: (FE,I) -> Any
      ++ \spad{laurent(f,n)} returns a Laurent expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    laurent: (FE,EQ FE) -> Any
      ++ \spad{laurent(f,x = a)} expands the expression f as a Laurent series
      ++ in powers of \spad{(x - a)}.
    laurent: (FE,EQ FE,I) -> Any
      ++ \spad{laurent(f,x = a,n)} expands the expression f as a Laurent
      ++ series in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.
    puiseux: SY -> Any
      ++ \spad{puiseux(x)} returns x viewed as a Puiseux series.
    puiseux: FE -> Any
      ++ \spad{puiseux(f)} returns a Puiseux expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    puiseux: (FE,RN) -> Any
      ++ \spad{puiseux(f,n)} returns a Puiseux expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    puiseux: (FE,EQ FE) -> Any
      ++ \spad{puiseux(f,x = a)} expands the expression f as a Puiseux series
      ++ in powers of \spad{(x - a)}.
    puiseux: (FE,EQ FE,RN) -> Any
      ++ \spad{puiseux(f,x = a,n)} expands the expression f as a Puiseux
      ++ series in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.

    series: SY -> Any
      ++ \spad{series(x)} returns x viewed as a series.
    series: FE -> Any
      ++ \spad{series(f)} returns a series expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    series: (FE,RN) -> Any
      ++ \spad{series(f,n)} returns a series expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    series: (FE,EQ FE) -> Any
      ++ \spad{series(f,x = a)} expands the expression f as a series
      ++ in powers of (x - a).
    series: (FE,EQ FE,RN) -> Any
      ++ \spad{series(f,x = a,n)} expands the expression f as a series
      ++ in powers of (x - a); terms will be computed up to order
      ++ at least n.

  Implementation ==> add
    performSubstitution: (FE,SY,FE) -> FE
    performSubstitution(fcn,x,a) ==
      zero? a => fcn
      xFE := x :: FE
      eval(fcn,xFE = xFE + a)

    iTaylor: (FE,SY,FE) -> Any
    iTaylor(fcn,x,a) ==
      pack := FS2UPS(R,FE,I,ULS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a)),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Taylor expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Taylor expansion: logarithmic singularity"
        ans.%problem.func = "nth root" =>
          error "No Taylor expansion: fractional powers in expansion"
        error "No Taylor expansion"
      uls := ans.%series
      (uts := taylorIfCan uls) case "failed" =>
        error "No Taylor expansion: pole"
      any1 := ANY1(UTS(FE,x,a))
      coerce(uts :: UTS(FE,x,a))$any1

    taylor(x:SY) ==
      uts := UTS(FE,x,0$FE); any1 := ANY1(uts)
      coerce(monomial(1,1)$uts)$any1

    taylor(fcn:FE) ==
      null(vars := variables fcn) =>
        error "taylor: expression has no variables"
      not null rest vars =>
        error "taylor: expression has more than one variable"
      taylor(fcn,(first(vars) :: FE) = 0)

    taylor(fcn:FE,n:NNI) ==
      null(vars := variables fcn) =>
        error "taylor: expression has no variables"
      not null rest vars =>
        error "taylor: expression has more than one variable"
      x := first vars
      uts := UTS(FE,x,0$FE); any1 := ANY1(uts)
      series := retract(taylor(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    taylor(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iTaylor(performSubstitution(fcn,x,a),x,a)

    taylor(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UTS(FE,x,a))
      series := retract(iTaylor(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iLaurent: (FE,SY,FE) -> Any
    iLaurent(fcn,x,a) ==
      pack := FS2UPS(R,FE,I,ULS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a)),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Laurent expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Laurent expansion: logarithmic singularity"
        ans.%problem.func = "nth root" =>
          error "No Laurent expansion: fractional powers in expansion"
        error "No Laurent expansion"
      any1 := ANY1(ULS(FE,x,a))
      coerce(ans.%series)$any1

    laurent(x:SY) ==
      uls := ULS(FE,x,0$FE); any1 := ANY1(uls)
      coerce(monomial(1,1)$uls)$any1

    laurent(fcn:FE) ==
      null(vars := variables fcn) =>
        error "laurent: expression has no variables"
      not null rest vars =>
        error "laurent: expression has more than one variable"
      laurent(fcn,(first(vars) :: FE) = 0)

    laurent(fcn:FE,n:I) ==
      null(vars := variables fcn) =>
        error "laurent: expression has no variables"
      not null rest vars =>
        error "laurent: expression has more than one variable"
      x := first vars
      uls := ULS(FE,x,0$FE); any1 := ANY1(uls)
      series := retract(laurent(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    laurent(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iLaurent(performSubstitution(fcn,x,a),x,a)

    laurent(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(ULS(FE,x,a))
      series := retract(iLaurent(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iPuiseux: (FE,SY,FE) -> Any
    iPuiseux(fcn,x,a) ==
      pack := FS2UPS(R,FE,RN,UPXS(FE,x,a),_
                     EFUPXS(FE,ULS(FE,x,a),UPXS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a))),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Puiseux expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Puiseux expansion: logarithmic singularity"
        error "No Puiseux expansion"
      any1 := ANY1(UPXS(FE,x,a))
      coerce(ans.%series)$any1

    puiseux(x:SY) ==
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      coerce(monomial(1,1)$upxs)$any1

    puiseux(fcn:FE) ==
      null(vars := variables fcn) =>
        error "puiseux: expression has no variables"
      not null rest vars =>
        error "puiseux: expression has more than one variable"
      puiseux(fcn,(first(vars) :: FE) = 0)

    puiseux(fcn:FE,n:RN) ==
      null(vars := variables fcn) =>
        error "puiseux: expression has no variables"
      not null rest vars =>
        error "puiseux: expression has more than one variable"
      x := first vars
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      series := retract(puiseux(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    puiseux(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iPuiseux(performSubstitution(fcn,x,a),x,a)

    puiseux(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UPXS(FE,x,a))
      series := retract(iPuiseux(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iSeries: (FE,SY,FE) -> Any
    iSeries(fcn,x,a) ==
      pack := FS2UPS(R,FE,RN,UPXS(FE,x,a), _
                     EFUPXS(FE,ULS(FE,x,a),UPXS(FE,x,a), _
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a))),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ansG := exprToGenUPS(fcn,false,"just do it")$pack
        ansG case %problem =>
          ansG.%problem.prob = "essential singularity" =>
            error "No series expansion: essential singularity"
          error "No series expansion"
        anyone := ANY1(GSER(FE,x,a))
        coerce((ansG.%series) :: GSER(FE,x,a))$anyone
      any1 := ANY1(UPXS(FE,x,a))
      coerce(ans.%series)$any1

    series(x:SY) ==
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      coerce(monomial(1,1)$upxs)$any1

    series(fcn:FE) ==
      null(vars := variables fcn) =>
        error "series: expression has no variables"
      not null rest vars =>
        error "series: expression has more than one variable"
      series(fcn,(first(vars) :: FE) = 0)

    series(fcn:FE,n:RN) ==
      null(vars := variables fcn) =>
        error "series: expression has no variables"
      not null rest vars =>
        error "series: expression has more than one variable"
      x := first vars
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      series := retract(series(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    series(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iSeries(performSubstitution(fcn,x,a),x,a)

    series(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UPXS(FE,x,a))
      series := retract(iSeries(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

@
<<EXPR2UPS.dotabb>>=
"EXPR2UPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPR2UPS"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"EXPR2UPS" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package E04AGNT e04AgentsPackage}
\pagehead{e04AgentsPackage}{E04AGNT}
\pagepic{ps/v104e04agentspackage.ps}{E04AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package E04AGNT e04AgentsPackage>>=
)abbrev package E04AGNT e04AgentsPackage
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: June 1996
++ Basic Operations: simple? linear?, quadratic?, nonLinear?
++ Description:
++ \axiomType{e04AgentsPackage} is a package of numerical agents to be used
++ to investigate attributes of an input function so as to decide the
++ \axiomFun{measure} of an appropriate numerical optimization routine.
MDF	==> Matrix DoubleFloat
VEDF	==> Vector Expression DoubleFloat
EDF	==> Expression DoubleFloat
EFI	==> Expression Fraction Integer
PFI	==> Polynomial Fraction Integer
FI	==> Fraction Integer
F	==> Float
DF	==> DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
LEDF	==> List Expression DoubleFloat
PDF	==> Polynomial DoubleFloat
LDF	==> List DoubleFloat
INT	==> Integer
NNI	==> NonNegativeInteger
LS	==> List Symbol
EF2	==> ExpressionFunctions2
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
LSA	==> Record(lfn:LEDF, init:LDF)

e04AgentsPackage(): E == I where
  E ==> with
    finiteBound:(LOCDF,DF) -> LDF 
      ++ finiteBound(l,b) repaces all instances of an infinite entry in
      ++ \axiom{l} by a finite entry \axiom{b} or \axiom{-b}.
    sortConstraints:NOA -> NOA
      ++ sortConstraints(args) uses a simple bubblesort on the list of
      ++ constraints using the degree of the expression on which to sort.
      ++ Of course, it must match the bounds to the constraints.
    sumOfSquares:EDF -> Union(EDF,"failed")
      ++ sumOfSquares(f) returns either an expression for which the square is
      ++ the original function of "failed".
    splitLinear:EDF -> EDF 
      ++ splitLinear(f) splits the linear part from an expression which it
      ++ returns.
    simpleBounds?:LEDF -> Boolean
      ++ simpleBounds?(l) returns true if the list of expressions l are
      ++ simple.
    linear?:LEDF -> Boolean
      ++ linear?(l) returns true if all the bounds l are either linear or
      ++ simple.
    linear?:EDF -> Boolean
      ++ linear?(e) tests if \axiom{e} is a linear function.
    linearMatrix:(LEDF, NNI) -> MDF
      ++ linearMatrix(l,n) returns a matrix of coefficients of the linear
      ++ functions in \axiom{l}.  If l is empty, the matrix has at least one
      ++ row.
    linearPart:LEDF -> LEDF
      ++ linearPart(l) returns the list of linear functions of \axiom{l}.
    nonLinearPart:LEDF -> LEDF
      ++ nonLinearPart(l) returns the list of non-linear functions of \axiom{l}.
    quadratic?:EDF -> Boolean
      ++ quadratic?(e) tests if \axiom{e} is a quadratic function.
    variables:LSA -> LS
      ++ variables(args) returns the list of variables in \axiom{args.lfn}
    varList:(EDF,NNI) -> LS
      ++ varList(e,n) returns a list of \axiom{n} indexed variables with name
      ++ as in \axiom{e}.
    changeNameToObjf:(Symbol,Result) -> Result
      ++ changeNameToObjf(s,r) changes the name of item \axiom{s} in \axiom{r}
      ++ to objf.
    expenseOfEvaluation:LSA -> F
      ++ expenseOfEvaluation(o) returns the intensity value of the 
      ++ cost of evaluating the input set of functions.  This is in terms 
      ++ of the number of ``operational units''.  It returns a value 
      ++ in the range [0,1].
    optAttributes:Union(noa:NOA,lsa:LSA) -> List String
      ++ optAttributes(o) is a function for supplying a list of attributes
      ++ of an optimization problem.

  I ==> add

    import ExpertSystemToolsPackage, ExpertSystemContinuityPackage

    sumOfSquares2:EFI -> Union(EFI,"failed")
    nonLinear?:EDF -> Boolean
    finiteBound2:(OCDF,DF) -> DF 
    functionType:EDF -> String

    finiteBound2(a:OCDF,b:DF):DF ==
      not finite?(a) =>
        positive?(a) => b
        -b
      retract(a)@DF

    finiteBound(l:LOCDF,b:DF):LDF == [finiteBound2(i,b) for i in l]

    sortConstraints(args:NOA):NOA ==
      Args := copy args
      c:LEDF := Args.cf
      l:LOCDF := Args.lb
      u:LOCDF := Args.ub
      m:INT := (# c) - 1      
      n:INT := (# l) - m
      for j in m..1 by -1 repeat
        for i in 1..j repeat
          s:EDF := c.i
          t:EDF := c.(i+1)
          if linear?(t) and (nonLinear?(s) or quadratic?(s)) then
            swap!(c,i,i+1)$LEDF
            swap!(l,n+i-1,n+i)$LOCDF
            swap!(u,n+i-1,n+i)$LOCDF
      Args
        
    changeNameToObjf(s:Symbol,r:Result):Result ==
      a := remove!(s,r)$Result
      a case Any =>
        insert!([objf@Symbol,a],r)$Result
        r
      r

    sum(a:EDF,b:EDF):EDF == a+b

    variables(args:LSA): LS == variables(reduce(sum,(args.lfn)))

    sumOfSquares(f:EDF):Union(EDF,"failed") ==
      e := edf2efi(f)
      s:Union(EFI,"failed") := sumOfSquares2(e)
      s case EFI =>
        map(fi2df,s)$EF2(FI,DF)
      "failed"

    sumOfSquares2(f:EFI):Union(EFI,"failed") ==
      p := retractIfCan(f)@Union(PFI,"failed")
      p case PFI => 
        r := squareFreePart(p)$PFI
        (p=r)@Boolean => "failed"
        tp := totalDegree(p)$PFI
        tr := totalDegree(r)$PFI
        t := tp quo tr
        found := false
        q := r
        for i in 2..t by 2 repeat
          s := q**2
          (s=p)@Boolean => 
            found := true
            leave
          q := r**i
        if found then 
          q :: EFI
        else
          "failed"
      "failed"

    splitLinear(f:EDF):EDF ==
      out := 0$EDF
      (l := isPlus(f)$EDF) case LEDF =>
        for i in l repeat
          if not quadratic? i then
            out := out + i
        out
      out

    edf2pdf(f:EDF):PDF == (retract(f)@PDF)$EDF

    varList(e:EDF,n:NNI):LS ==
      s := name(first(variables(edf2pdf(e))$PDF)$LS)$Symbol
      [subscript(s,[t::OutputForm]) for t in expand([1..n])$Segment(Integer)]

    functionType(f:EDF):String ==
      n := #(variables(f))$EDF
      p := (retractIfCan(f)@Union(PDF,"failed"))$EDF
      p case PDF =>
        d := totalDegree(p)$PDF
--        one?(n*d) => "simple"
        (n*d) = 1 => "simple"
--        one?(d) => "linear"
        (d = 1) => "linear"
        (d=2)@Boolean => "quadratic"
        "non-linear"
      "non-linear"
     
    simpleBounds?(l: LEDF):Boolean ==
      a := true
      for e in l repeat
        not (functionType(e) = "simple")@Boolean => 
          a := false
          leave
      a

    simple?(e:EDF):Boolean == (functionType(e) = "simple")@Boolean

    linear?(e:EDF):Boolean == (functionType(e) = "linear")@Boolean

    quadratic?(e:EDF):Boolean == (functionType(e) = "quadratic")@Boolean

    nonLinear?(e:EDF):Boolean == (functionType(e) = "non-linear")@Boolean

    linear?(l: LEDF):Boolean ==
      a := true
      for e in l repeat
        s := functionType(e)
        (s = "quadratic")@Boolean or (s = "non-linear")@Boolean => 
          a := false
          leave
      a

    simplePart(l:LEDF):LEDF == [i for i in l | simple?(i)]

    linearPart(l:LEDF):LEDF == [i for i in l | linear?(i)]

    nonLinearPart(l:LEDF):LEDF ==
      [i for i in l | not linear?(i) and not simple?(i)]

    linearMatrix(l:LEDF, n:NNI):MDF ==
      empty?(l) => mat([],n)
      L := linearPart l
      M := zero(max(1,# L)$NNI,n)$MDF
      vars := varList(first(l)$LEDF,n)
      row:INT := 1
      for a in L repeat
        for j in monomials(edf2pdf(a))$PDF repeat
          col:INT := 1
          for c in vars repeat
            if ((first(variables(j)$PDF)$LS)=c)@Boolean then
              M(row,col):= first(coefficients(j)$PDF)$LDF
            col := col+1
        row := row + 1
      M

    expenseOfEvaluation(o:LSA):F ==
      expenseOfEvaluation(vector(copy o.lfn)$VEDF)

    optAttributes(o:Union(noa:NOA,lsa:LSA)):List String ==
      o case noa =>
        n := o.noa
        s1:String := "The object function is " functionType(n.fn)
        if empty?(n.lb) then
          s2:String := "There are no bounds on the variables" 
        else
          s2:String := "There are simple bounds on the variables"
        c := n.cf
        if empty?(c) then
          s3:String := "There are no constraint functions"
        else
          t := #(c)
          lin := #(linearPart(c))
          nonlin := #(nonLinearPart(c))
          s3:String := "There are " string(lin)$String " linear and "_
                          string(nonlin)$String " non-linear constraints"
        [s1,s2,s3]
      l := o.lsa
      s:String := "non-linear"
      if linear?(l.lfn) then
        s := "linear"
      ["The object functions are " s]

@
<<E04AGNT.dotabb>>=
"E04AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=E04AGNT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"E04AGNT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter F}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FDIV2 FiniteDivisorFunctions2}
\pagehead{FiniteDivisorFunctions2}{FDIV2}
\pagepic{ps/v104finitedivisorfunctions2.ps}{FDIV2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FDIV2 FiniteDivisorFunctions2>>=
)abbrev package FDIV2 FiniteDivisorFunctions2
++ Lift a map to finite divisors.
++ Author: Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 19 May 1993
FiniteDivisorFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 Exports == Implementation where
  R1   : Field
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  F1   : FunctionFieldCategory(R1, UP1, UPUP1)
  R2   : Field
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2
  F2   : FunctionFieldCategory(R2, UP2, UPUP2)

  Exports ==> with
    map: (R1 -> R2, FiniteDivisor(R1, UP1, UPUP1, F1)) ->
                                       FiniteDivisor(R2, UP2, UPUP2, F2)
	++ map(f,d) \undocumented{} 

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R1,UP1,R2,UP2)
    import FunctionFieldCategoryFunctions2(R1,UP1,UPUP1,F1,R2,UP2,UPUP2,F2)
    import FractionalIdealFunctions2(UP1, Fraction UP1, UPUP1, F1,
                                     UP2, Fraction UP2, UPUP2, F2)

    map(f, d) ==
      rec := decompose d
      divisor map(f, rec.principalPart) + divisor map(map(f, #1), rec.id)

@
<<FDIV2.dotabb>>=
"FDIV2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FDIV2"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"FDIV2" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLAGG2 FiniteLinearAggregateFunctions2}
\pagehead{FiniteLinearAggregateFunctions2}{FLAGG2}
\pagepic{ps/v104finitelinearaggregatefunctions2.ps}{FLAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLAGG2 FiniteLinearAggregateFunctions2>>=
)abbrev package FLAGG2 FiniteLinearAggregateFunctions2
--% FiniteLinearAggregateFunctions2

++ Author: ???
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ FiniteLinearAggregateFunctions2 provides functions involving two
++ FiniteLinearAggregates where the underlying domains might be
++ different. An example of this might be creating a list of rational
++ numbers by mapping a function across a list of integers where the
++ function divides each integer by 1000.

FiniteLinearAggregateFunctions2(S, A, R, B):
 Exports == Implementation where
  S, R: Type
  A   : FiniteLinearAggregate S
  B   : FiniteLinearAggregate R

  Exports ==> with
    map    : (S -> R, A) -> B          
     ++ map(f,a) applies function f to each member of aggregate
     ++ \spad{a} resulting in a new aggregate over a
     ++ possibly different underlying domain.
    reduce : ((S, R) -> R, A, R) -> R  
     ++ reduce(f,a,r) applies function f to each
     ++ successive element of the
     ++ aggregate \spad{a} and an accumulant initialized to r.
     ++ For example,
     ++ \spad{reduce(_+$Integer,[1,2,3],0)}
     ++ does \spad{3+(2+(1+0))}. Note: third argument r
     ++ may be regarded as the
     ++ identity element for the function f.
    scan   : ((S, R) -> R, A, R) -> B  
     ++ scan(f,a,r) successively applies
     ++ \spad{reduce(f,x,r)} to more and more leading sub-aggregates
     ++ x of aggregrate \spad{a}.
     ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
     ++ \spad{scan(f,a,r)} returns
     ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
  Implementation ==> add
    if A has ListAggregate(S) then         -- A is a list-oid
      reduce(fn, l, ident) ==
        empty? l => ident
        reduce(fn, rest l, fn(first l, ident))

      if B has ListAggregate(R) or not(B has shallowlyMutable) then
        -- A is a list-oid, and B is either list-oids or not mutable
        map(f, l) == construct [f s for s in entries l]

        scan(fn, l, ident) ==
          empty? l => empty()
          val := fn(first l, ident)
          concat(val, scan(fn, rest l, val))

      else                      -- A is a list-oid, B a mutable array-oid
        map(f, l) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          for a in entries l repeat (qsetelt_!(w, i, f a); i := inc i)
          w

        scan(fn, l, ident) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          vl := ident
          for a in entries l repeat
            vl := qsetelt_!(w, i, fn(a, vl))
            i := inc i
          w

    else                              -- A is an array-oid
      reduce(fn, v, ident) ==
        val := ident
        for i in minIndex v .. maxIndex v repeat
          val := fn(qelt(v, i), val)
        val

      if B has ListAggregate(R) then   -- A is an array-oid, B a list-oid
        map(f, v) ==
          construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

        scan(fn, v, ident) ==
          w := empty()$B
          for i in minIndex v .. maxIndex v repeat
            ident := fn(qelt(v, i), ident)
            w := concat(ident, w)
          reverse_! w

      else                             -- A and B are array-oid's
        if B has shallowlyMutable then -- B is also mutable
          map(f, v) ==
            w := new(#v,NIL$Lisp)$B
            for i in minIndex w .. maxIndex w repeat
              qsetelt_!(w, i, f qelt(v, i))
            w

          scan(fn, v, ident) ==
            w   := new(#v,NIL$Lisp)$B
            vl := ident
            for i in minIndex v .. maxIndex v repeat
              vl := qsetelt_!(w, i, fn(qelt(v, i), vl))
            w

        else                                   -- B non mutable array-oid
          map(f, v) ==
            construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

          scan(fn, v, ident) ==
            w := empty()$B
            for i in minIndex v .. maxIndex v repeat
              ident := fn(qelt(v, i), ident)
              w := concat(w, ident)
            w

@
<<FLAGG2.dotabb>>=
"FLAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLAGG2"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"FLAGG2" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLASORT FiniteLinearAggregateSort}
\pagehead{FiniteLinearAggregateSort}{FLASORT}
\pagepic{ps/v104finitelinearaggregatesort.ps}{FLASORT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLASORT FiniteLinearAggregateSort>>=
)abbrev package FLASORT FiniteLinearAggregateSort
++ FiniteLinearAggregateSort
++ Sort package (in-place) for shallowlyMutable Finite Linear Aggregates
++ Author: Michael Monagan Sep/88
++ RelatedOperations: sort
++ Description:
++  This package exports 3 sorting algorithms which work over 
++  FiniteLinearAggregates.
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains
 
)bo PUSH('FiniteLinearAggregateSort, $mutableDomains) 

FiniteLinearAggregateSort(S, V): Exports == Implementation where
  S: Type
  V: FiniteLinearAggregate(S) with shallowlyMutable
 
  B ==> Boolean
  I ==> Integer
 
  Exports ==> with
    quickSort: ((S, S) -> B, V) -> V
      ++ quickSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the quicksort algorithm.
    heapSort : ((S, S) -> B, V) -> V
      ++ heapSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the heapsort algorithm.
    shellSort: ((S, S) -> B, V) -> V
      ++ shellSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the shellSort algorithm.
 
  Implementation ==> add
    siftUp   : ((S, S) -> B, V, I, I) -> Void
    partition: ((S, S) -> B, V, I, I, I) -> I
    QuickSort: ((S, S) -> B, V, I, I) -> V
 
    quickSort(l, r) == QuickSort(l, r, minIndex r, maxIndex r)
 
    siftUp(l, r, i, n) ==
      t := qelt(r, i)
      while (j := 2*i+1) < n repeat
        if (k := j+1) < n and l(qelt(r, j), qelt(r, k)) then j := k
        if l(t,qelt(r,j)) then
           qsetelt_!(r, i, qelt(r, j))
           qsetelt_!(r, j, t)
           i := j
        else leave
 
    heapSort(l, r) ==
      not zero? minIndex r => error "not implemented"
      n := (#r)::I
      for k in shift(n,-1) - 1 .. 0 by -1 repeat siftUp(l, r, k, n)
      for k in n-1 .. 1 by -1 repeat
         swap_!(r, 0, k)
         siftUp(l, r, 0, k)
      r
 
    partition(l, r, i, j, k) ==
      -- partition r[i..j] such that r.s <= r.k <= r.t
      x := qelt(r, k)
      t := qelt(r, i)
      qsetelt_!(r, k, qelt(r, j))
      while i < j repeat
         if l(x,t) then
           qsetelt_!(r, j, t)
           j := j-1
           t := qsetelt_!(r, i, qelt(r, j))
         else (i := i+1; t := qelt(r, i))
      qsetelt_!(r, j, x)
      j
 
    QuickSort(l, r, i, j) ==
      n := j - i
--      if one? n and l(qelt(r, j), qelt(r, i)) then swap_!(r, i, j)
      if (n = 1) and l(qelt(r, j), qelt(r, i)) then swap_!(r, i, j)
      n < 2 => return r
      -- for the moment split at the middle item
      k := partition(l, r, i, j, i + shift(n,-1))
      QuickSort(l, r, i, k - 1)
      QuickSort(l, r, k + 1, j)
 
    shellSort(l, r) ==
      m := minIndex r
      n := maxIndex r
      -- use Knuths gap sequence: 1,4,13,40,121,...
      g := 1
      while g <= (n-m) repeat g := 3*g+1
      g := g quo 3
      while g > 0 repeat
         for i in m+g..n repeat
            j := i-g
            while j >= m and l(qelt(r, j+g), qelt(r, j)) repeat
               swap_!(r,j,j+g)
               j := j-g
         g := g quo 3
      r

@
<<FLASORT.dotabb>>=
"FLASORT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLASORT"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"FLASORT" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSAGG2 FiniteSetAggregateFunctions2}
\pagehead{FiniteSetAggregateFunctions2}{FSAGG2}
\pagepic{ps/v104finitesetaggregatefunctions2.ps}{FSAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSAGG2 FiniteSetAggregateFunctions2>>=
)abbrev package FSAGG2 FiniteSetAggregateFunctions2

--% FiniteSetAggregateFunctions2

++ Author: Robert S. Sutor
++ Date Created: 15 May 1990
++ Date Last Updated: 14 Oct 1993
++ Description:
++ FiniteSetAggregateFunctions2 provides functions involving two
++ finite set aggregates where the underlying domains might be
++ different. An example of this is to create a set of rational
++ numbers by mapping a function across a set of integers, where the
++ function divides each integer by 1000.

FiniteSetAggregateFunctions2(S, A, R, B): Exports == Implementation where
   S, R: SetCategory
   A   : FiniteSetAggregate S
   B   : FiniteSetAggregate R

   Exports ==> with
     map    : (S -> R, A) -> B          
      ++ map(f,a) applies function f to each member of
      ++ aggregate \spad{a}, creating a new aggregate with
      ++ a possibly different underlying domain.
     reduce : ((S, R) -> R, A, R) -> R  
      ++ reduce(f,a,r) applies function f to each
      ++ successive element of the aggregate \spad{a} and an
      ++ accumulant initialised to r.
      ++ For example,
      ++ \spad{reduce(_+$Integer,[1,2,3],0)}
      ++ does a \spad{3+(2+(1+0))}.
      ++ Note: third argument r may be regarded
      ++ as an identity element for the function.
     scan   : ((S, R) -> R, A, R) -> B  
      ++ scan(f,a,r) successively applies \spad{reduce(f,x,r)}
      ++ to more and more leading sub-aggregates x of
      ++ aggregate \spad{a}.
      ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
      ++ \spad{scan(f,a,r)} returns
      ++ \spad {[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
   Implementation ==> add
     map(fn, a) ==
       set(map(fn, parts a)$ListFunctions2(S, R))$B
     reduce(fn, a, ident) ==
       reduce(fn, parts a, ident)$ListFunctions2(S, R)
     scan(fn, a, ident) ==
       set(scan(fn, parts a, ident)$ListFunctions2(S, R))$B

@
<<FSAGG2.dotabb>>=
"FSAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSAGG2"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"FSAGG2" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FRIDEAL2 FractionalIdealFunctions2}
\pagehead{FractionalIdealFunctions2}{FRIDEAL2}
\pagepic{ps/v104fractionalidealfunctions2.ps}{FRIDEAL2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FRIDEAL2 FractionalIdealFunctions2>>=
)abbrev package FRIDEAL2 FractionalIdealFunctions2
++ Lifting of morphisms to fractional ideals.
++ Author: Manuel Bronstein
++ Date Created: 1 Feb 1989
++ Date Last Updated: 27 Feb 1990
++ Keywords: ideal, algebra, module.
FractionalIdealFunctions2(R1, F1, U1, A1, R2, F2, U2, A2):
 Exports == Implementation where
  R1, R2: EuclideanDomain
  F1: QuotientFieldCategory R1
  U1: UnivariatePolynomialCategory F1
  A1: Join(FramedAlgebra(F1, U1), RetractableTo F1)
  F2: QuotientFieldCategory R2
  U2: UnivariatePolynomialCategory F2
  A2: Join(FramedAlgebra(F2, U2), RetractableTo F2)

  Exports ==> with
    map: (R1 -> R2, FractionalIdeal(R1, F1, U1, A1)) ->
                                         FractionalIdeal(R2, F2, U2, A2)
	++ map(f,i) \undocumented{}

  Implementation ==> add
    fmap: (F1 -> F2, A1) -> A2

    fmap(f, a) ==
      v := coordinates a
      represents
        [f qelt(v, i) for i in minIndex v .. maxIndex v]$Vector(F2)

    map(f, i) ==
      b := basis i
      ideal [fmap(f(numer #1) / f(denom #1), qelt(b, j))
             for j in minIndex b .. maxIndex b]$Vector(A2)

@
<<FRIDEAL2.dotabb>>=
"FRIDEAL2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FRIDEAL2"]
"FRAMALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRAMALG"]
"FRIDEAL2" -> "FRAMALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFCAT2 FunctionFieldCategoryFunctions2}
\pagehead{FunctionFieldCategoryFunctions2}{FFCAT2}
\pagepic{ps/v104functionfieldcategoryfunctions2.ps}{FFCAT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFCAT2 FunctionFieldCategoryFunctions2>>=
)abbrev package FFCAT2 FunctionFieldCategoryFunctions2
++ Lifts a map from rings to function fields over them
++ Author: Manuel Bronstein
++ Date Created: May 1988
++ Date Last Updated: 26 Jul 1988
++ Description: Lifts a map from rings to function fields over them.
FunctionFieldCategoryFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 Exports == Implementation where
  R1   : UniqueFactorizationDomain
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  F1   : FunctionFieldCategory(R1, UP1, UPUP1)
  R2   : UniqueFactorizationDomain
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2
  F2   : FunctionFieldCategory(R2, UP2, UPUP2)

  Exports ==> with
    map: (R1 -> R2, F1) -> F2
      ++ map(f, p) lifts f to F1 and applies it to p.

  Implementation ==> add
    map(f, f1) ==
      reduce(map(f, lift f1)$MultipleMap(R1, UP1, UPUP1, R2, UP2, UPUP2))

@
<<FFCAT2.dotabb>>=
"FFCAT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFCAT2"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"FFCAT2" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMASSFS FunctionSpaceAssertions}
\pagehead{FunctionSpaceAssertions}{PMASSFS}
\pagepic{ps/v104functionspaceassertions.ps}{PMASSFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMASSFS FunctionSpaceAssertions>>=
)abbrev package PMASSFS FunctionSpaceAssertions
++ Assertions for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching assertions to symbols for pattern matching;
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
FunctionSpaceAssertions(R, F): Exports == Implementation where
  R: OrderedSet
  F: FunctionSpace R

  K  ==> Kernel F
  PMOPT   ==> "%pmoptional"
  PMMULT  ==> "%pmmultiple"
  PMCONST ==> "%pmconstant"

  Exports ==> with
    assert  : (F, String) -> F
      ++ assert(x, s) makes the assertion s about x.
      ++ Error: if x is not a symbol.
    constant: F -> F
      ++ constant(x) tells the pattern matcher that x should
      ++ match only the symbol 'x and no other quantity.
      ++ Error: if x is not a symbol.
    optional: F -> F
      ++ optional(x) tells the pattern matcher that x can match
      ++ an identity (0 in a sum, 1 in a product or exponentiation).
      ++ Error: if x is not a symbol.
    multiple: F -> F
      ++ multiple(x) tells the pattern matcher that x should
      ++ preferably match a multi-term quantity in a sum or product.
      ++ For matching on lists, multiple(x) tells the pattern matcher
      ++ that x should match a list instead of an element of a list.
      ++ Error: if x is not a symbol.

  Implementation ==> add
    ass  : (K, String) -> F
    asst : (K, String) -> F
    mkk  : BasicOperator -> F

    mkk op == kernel(op, empty()$List(F))

    ass(k, s) ==
      has?(op := operator k, s) => k::F
      mkk assert(copy op, s)

    asst(k, s) ==
      has?(op := operator k, s) => k::F
      mkk assert(op, s)

    assert(x, s) ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        asst(retract(x)@K, s)
      error "assert must be applied to symbols only"

    constant x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMCONST)
      error "constant must be applied to symbols only"

    optional x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMOPT)
      error "optional must be applied to symbols only"

    multiple x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMMULT)
      error "multiple must be applied to symbols only"

@
<<PMASSFS.dotabb>>=
"PMASSFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMASSFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PMASSFS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMPREDFS FunctionSpaceAttachPredicates}
\pagehead{FunctionSpaceAttachPredicates}{PMPREDFS}
\pagepic{ps/v104functionspaceattachpredicates.ps}{PMPREDFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMPREDFS FunctionSpaceAttachPredicates>>=
)abbrev package PMPREDFS FunctionSpaceAttachPredicates
++ Predicates for pattern-matching.
++ Author: Manuel Bronstein
++ Description: Attaching predicates to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
FunctionSpaceAttachPredicates(R, F, D): Exports == Implementation where
  R: OrderedSet
  F: FunctionSpace R
  D: Type

  K  ==> Kernel F
  PMPRED  ==> "%pmpredicate"

  Exports ==> with
    suchThat: (F, D -> Boolean) -> F
      ++ suchThat(x, foo) attaches the predicate foo to x;
      ++ error if x is not a symbol.
    suchThat: (F, List(D -> Boolean)) -> F
      ++ suchThat(x, [f1, f2, ..., fn]) attaches the predicate
      ++ f1 and f2 and ... and fn to x.
      ++ Error: if x is not a symbol.

  Implementation ==> add
    import AnyFunctions1(D -> Boolean)

    st   : (K, List Any) -> F
    preds: K -> List Any
    mkk  : BasicOperator -> F

    suchThat(p:F, f:D -> Boolean) == suchThat(p, [f])
    mkk op                        == kernel(op, empty()$List(F))

    preds k ==
      (u := property(operator k, PMPRED)) case "failed" => empty()
      (u::None) pretend List(Any)

    st(k, l) ==
      mkk assert(setProperty(copy operator k, PMPRED,
                 concat(preds k, l) pretend None), string(new()$Symbol))

    suchThat(p:F, l:List(D -> Boolean)) ==
      retractIfCan(p)@Union(Symbol, "failed") case Symbol =>
        st(retract(p)@K, [f::Any for f in l])
      error "suchThat must be applied to symbols only"

@
<<PMPREDFS.dotabb>>=
"PMPREDFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMPREDFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PMPREDFS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUMFS FunctionSpaceSum}
\pagehead{FunctionSpaceSum}{SUMFS}
\pagepic{ps/v104functionspacesum.ps}{SUMFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUMFS FunctionSpaceSum>>=
)abbrev package SUMFS FunctionSpaceSum
++ Top-level sum function
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 19 April 1991
++ Description: computes sums of top-level expressions;
FunctionSpaceSum(R, F): Exports == Implementation where
  R: Join(IntegralDomain, OrderedSet,
          RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F: Join(FunctionSpace R, CombinatorialOpsCategory,
          AlgebraicallyClosedField, TranscendentalFunctionCategory)

  SE  ==> Symbol
  K   ==> Kernel F

  Exports ==> with
    sum: (F, SE) -> F
      ++ sum(a(n), n) returns A(n) such that A(n+1) - A(n) = a(n);
    sum: (F, SegmentBinding F) -> F
      ++ sum(f(n), n = a..b) returns f(a) + f(a+1) + ... + f(b);

  Implementation ==> add
    import ElementaryFunctionStructurePackage(R, F)
    import GosperSummationMethod(IndexedExponents K, K, R,
                                 SparseMultivariatePolynomial(R, K), F)

    innersum: (F, K) -> Union(F, "failed")
    notRF?  : (F, K) -> Boolean
    newk    : () -> K

    newk() == kernel(new()$SE)

    sum(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)@K
      (u := innersum(x, k)) case "failed" => summation(x, s)
      eval(u::F, k, 1 + hi segment s) - eval(u::F, k, lo segment s)

    sum(x:F, v:SE) ==
      (u := innersum(x, kernel(v)@K)) case "failed" => summation(x,v)
      u::F

    notRF?(f, k) ==
      for kk in tower f repeat
        member?(k, tower(kk::F)) and (symbolIfCan(kk) case "failed") =>
          return true
      false

    innersum(x, k) ==
      zero? x => 0
      notRF?(f := normalize(x / (x1 := eval(x, k, k::F - 1))), k) =>
        "failed"
      (u := GospersMethod(f, k, newk)) case "failed" => "failed"
      x1 * eval(u::F, k, k::F - 1)

@
<<SUMFS.dotabb>>=
"SUMFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUMFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"SUMFS" -> "FS"
"SUMFS" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSPECF FunctionalSpecialFunction}
\pagehead{FunctionalSpecialFunction}{FSPECF}
\pagepic{ps/v104functionalspecialfunction.ps}{FSPECF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSPECF FunctionalSpecialFunction>>=
)abbrev package FSPECF FunctionalSpecialFunction
++ Provides the special functions
++ Author: Manuel Bronstein
++ Date Created: 18 Apr 1989
++ Date Last Updated: 4 October 1993
++ Description: Provides some special functions over an integral domain.
++ Keywords: special, function.
FunctionalSpecialFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  OP  ==> BasicOperator
  K   ==> Kernel F
  SE  ==> Symbol
  SPECIALDIFF  ==> "%specialDiff"

  Exports ==> with
    belong? : OP -> Boolean
      ++ belong?(op) is true if op is a special function operator;
    operator: OP -> OP
      ++ operator(op) returns a copy of op with the domain-dependent
      ++ properties appropriate for F;
      ++ error if op is not a special function operator
    abs     : F -> F
      ++ abs(f) returns the absolute value operator applied to f
    Gamma   : F -> F
      ++ Gamma(f) returns the formal Gamma function applied to f
    Gamma   : (F,F) -> F
      ++ Gamma(a,x) returns the incomplete Gamma function applied to a and x
    Beta:      (F,F) -> F
      ++ Beta(x,y) returns the beta function applied to x and y
    digamma:   F->F
      ++ digamma(x) returns the digamma function applied to x 
    polygamma: (F,F) ->F
      ++ polygamma(x,y) returns the polygamma function applied to x and y
    besselJ:   (F,F) -> F
      ++ besselJ(x,y) returns the besselj function applied to x and y
    besselY:   (F,F) -> F
      ++ besselY(x,y) returns the bessely function applied to x and y
    besselI:   (F,F) -> F
      ++ besselI(x,y) returns the besseli function applied to x and y
    besselK:   (F,F) -> F
      ++ besselK(x,y) returns the besselk function applied to x and y
    airyAi:    F -> F
      ++ airyAi(x) returns the airyai function applied to x 
    airyBi:    F -> F
      ++ airyBi(x) returns the airybi function applied to x

@

In case we want to have more special function operators here, do not forget to
add them to the list [[specop]] in [[CommonOperators]].  Otherwise they will
not have the \lq special\rq\ attribute and will not be recognised here.  One
effect could be that
\begin{verbatim}
myNewSpecOp(1::Expression Integer)::Expression DoubleFloat
\end{verbatim}
might not re-evaluate the operator.

<<package FSPECF FunctionalSpecialFunction>>=
    iiGamma : F -> F
      ++ iiGamma(x) should be local but conditional;
    iiabs     : F -> F
      ++ iiabs(x) should be local but conditional;
    iiBeta     : List F -> F
      ++ iiGamma(x) should be local but conditional;
    iidigamma  : F -> F
      ++ iidigamma(x) should be local but conditional;
    iipolygamma: List F -> F
      ++ iipolygamma(x) should be local but conditional;
    iiBesselJ  : List F -> F
      ++ iiBesselJ(x) should be local but conditional;
    iiBesselY  : List F -> F
      ++ iiBesselY(x) should be local but conditional;
    iiBesselI  : List F -> F
      ++ iiBesselI(x) should be local but conditional;
    iiBesselK  : List F -> F
      ++ iiBesselK(x) should be local but conditional;
    iiAiryAi   : F -> F
      ++ iiAiryAi(x) should be local but conditional;
    iiAiryBi   : F -> F
      ++ iiAiryBi(x) should be local but conditional;

  Implementation ==> add
    iabs      : F -> F
    iGamma    : F -> F
    iBeta     : (F, F) -> F
    idigamma  : F -> F
    iiipolygamma: (F, F) -> F
    iiiBesselJ  : (F, F) -> F
    iiiBesselY  : (F, F) -> F
    iiiBesselI  : (F, F) -> F
    iiiBesselK  : (F, F) -> F
    iAiryAi   : F -> F
    iAiryBi   : F -> F

    opabs       := operator("abs"::Symbol)$CommonOperators
    opGamma     := operator("Gamma"::Symbol)$CommonOperators
    opGamma2    := operator("Gamma2"::Symbol)$CommonOperators
    opBeta      := operator("Beta"::Symbol)$CommonOperators
    opdigamma   := operator("digamma"::Symbol)$CommonOperators
    oppolygamma := operator("polygamma"::Symbol)$CommonOperators
    opBesselJ   := operator("besselJ"::Symbol)$CommonOperators
    opBesselY   := operator("besselY"::Symbol)$CommonOperators
    opBesselI   := operator("besselI"::Symbol)$CommonOperators
    opBesselK   := operator("besselK"::Symbol)$CommonOperators
    opAiryAi    := operator("airyAi"::Symbol)$CommonOperators
    opAiryBi    := operator("airyBi"::Symbol)$CommonOperators

    abs x         == opabs x
    Gamma(x)      == opGamma(x)
    Gamma(a,x)    == opGamma2(a,x)
    Beta(x,y)     == opBeta(x,y)
    digamma x     == opdigamma(x)
    polygamma(k,x)== oppolygamma(k,x)
    besselJ(a,x)  == opBesselJ(a,x)
    besselY(a,x)  == opBesselY(a,x)
    besselI(a,x)  == opBesselI(a,x)
    besselK(a,x)  == opBesselK(a,x)
    airyAi(x)     == opAiryAi(x)
    airyBi(x)     == opAiryBi(x)

    belong? op == has?(op, "special")

    operator op ==
      is?(op, "abs"::Symbol)      => opabs
      is?(op, "Gamma"::Symbol)    => opGamma
      is?(op, "Gamma2"::Symbol)   => opGamma2
      is?(op, "Beta"::Symbol)     => opBeta
      is?(op, "digamma"::Symbol)  => opdigamma
      is?(op, "polygamma"::Symbol)=> oppolygamma
      is?(op, "besselJ"::Symbol)  => opBesselJ
      is?(op, "besselY"::Symbol)  => opBesselY
      is?(op, "besselI"::Symbol)  => opBesselI
      is?(op, "besselK"::Symbol)  => opBesselK
      is?(op, "airyAi"::Symbol)   => opAiryAi
      is?(op, "airyBi"::Symbol)   => opAiryBi

      error "Not a special operator"

    -- Could put more unconditional special rules for other functions here
    iGamma x ==
--      one? x => x
      (x = 1) => x
      kernel(opGamma, x)

    iabs x ==
      zero? x => 0
      is?(x, opabs) => x
      x < 0 => kernel(opabs, -x)
      kernel(opabs, x)

    iBeta(x, y) == kernel(opBeta, [x, y])
    idigamma x == kernel(opdigamma, x)
    iiipolygamma(n, x) == kernel(oppolygamma, [n, x])
    iiiBesselJ(x, y) == kernel(opBesselJ, [x, y])
    iiiBesselY(x, y) == kernel(opBesselY, [x, y])
    iiiBesselI(x, y) == kernel(opBesselI, [x, y])
    iiiBesselK(x, y) == kernel(opBesselK, [x, y])
    iAiryAi x == kernel(opAiryAi, x)
    iAiryBi x == kernel(opAiryBi, x)


    -- Could put more conditional special rules for other functions here

    if R has abs : R -> R then
      iiabs x ==
        (r := retractIfCan(x)@Union(Fraction Polynomial R, "failed"))
          case "failed" => iabs x
        f := r::Fraction Polynomial R
        (a := retractIfCan(numer f)@Union(R, "failed")) case "failed" or
          (b := retractIfCan(denom f)@Union(R,"failed")) case "failed" => iabs x
        abs(a::R)::F / abs(b::R)::F

    else iiabs x == iabs x

    if R has SpecialFunctionCategory then
      iiGamma x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iGamma x
        Gamma(r::R)::F

      iiBeta l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iBeta(first l, second l)
        Beta(r::R, s::R)::F

      iidigamma x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => idigamma x
        digamma(r::R)::F

      iipolygamma l ==
        (s:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (r:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiipolygamma(first l, second l)
        polygamma(s::R, r::R)::F

      iiBesselJ l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselJ(first l, second l)
        besselJ(r::R, s::R)::F

      iiBesselY l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselY(first l, second l)
        besselY(r::R, s::R)::F

      iiBesselI l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselI(first l, second l)
        besselI(r::R, s::R)::F

      iiBesselK l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselK(first l, second l)
        besselK(r::R, s::R)::F

      iiAiryAi x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iAiryAi x
        airyAi(r::R)::F

      iiAiryBi x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iAiryBi x
        airyBi(r::R)::F

    else
      if R has RetractableTo Integer then
        iiGamma x ==
          (r := retractIfCan(x)@Union(Integer, "failed")) case Integer
            and (r::Integer >= 1) => factorial(r::Integer - 1)::F
          iGamma x
      else
        iiGamma x == iGamma x

      iiBeta l == iBeta(first l, second l)
      iidigamma x == idigamma x 
      iipolygamma l == iiipolygamma(first l, second l)
      iiBesselJ l == iiiBesselJ(first l, second l) 
      iiBesselY l == iiiBesselY(first l, second l)
      iiBesselI l == iiiBesselI(first l, second l)
      iiBesselK l == iiiBesselK(first l, second l)
      iiAiryAi x == iAiryAi x
      iiAiryBi x == iAiryBi x

    -- Default behaviour is to build a kernel
    evaluate(opGamma, iiGamma)$BasicOperatorFunctions1(F)
    evaluate(opabs, iiabs)$BasicOperatorFunctions1(F)
--    evaluate(opGamma2    ,iiGamma2   )$BasicOperatorFunctions1(F)
    evaluate(opBeta      ,iiBeta     )$BasicOperatorFunctions1(F)
    evaluate(opdigamma   ,iidigamma  )$BasicOperatorFunctions1(F)
    evaluate(oppolygamma ,iipolygamma)$BasicOperatorFunctions1(F)
    evaluate(opBesselJ   ,iiBesselJ  )$BasicOperatorFunctions1(F)
    evaluate(opBesselY   ,iiBesselY  )$BasicOperatorFunctions1(F)
    evaluate(opBesselI   ,iiBesselI  )$BasicOperatorFunctions1(F)
    evaluate(opBesselK   ,iiBesselK  )$BasicOperatorFunctions1(F)
    evaluate(opAiryAi    ,iiAiryAi   )$BasicOperatorFunctions1(F)
    evaluate(opAiryBi    ,iiAiryBi   )$BasicOperatorFunctions1(F)
@

\subsection{differentiation of special functions}

In the following we define the symbolic derivatives of the special functions we
provide.  The formulas we use for the Bessel functions can be found in Milton
Abramowitz and Irene A. Stegun, eds.  (1965). Handbook of Mathematical
Functions with Formulas, Graphs, and Mathematical Tables. New York: Dover. ISBN
0-486-61272-4, Equations~9.1.27 and 9.6.26.  Up to [[patch--50]] the formula
for $K$ missed the minus sign.  (Issue~\#355)

We do not attempt to provide formulas for the derivative with respect to the
first argument currently.  Instead, we leave such derivatives unevaluated.

<<package FSPECF FunctionalSpecialFunction>>=
    import Fraction Integer
    ahalf:  F    := recip(2::F)::F
    athird: F    := recip(2::F)::F
    twothirds: F := 2*recip(3::F)::F
@

We need to get hold of the differentiation operator as modified by
[[FunctionSpace]]. Otherwise, for example, display will be ugly.  We accomplish
that by differentiating an operator, which will certainly result in a single
kernel only.

<<package FSPECF FunctionalSpecialFunction>>=
    dummyArg: SE := new()$SE
    opdiff := operator first kernels D((operator(new()$SE)$BasicOperator)
                                            (dummyArg::F), dummyArg)
@

The differentiation operator [[opdiff]] takes three arguments corresponding to
$$
F_{,i}(a_1,a_2,\dots,a_n):
$$
\begin{enumerate}
\item $F(a_1,...,dm,...a_n)$, where the $i$\textsuperscript{th} argument is a
  dummy variable,
\item $dm$, the dummy variable, and
\item $a_i$, the point at which the differential is evaluated.
\end{enumerate}

In the following, it seems to be safe to use the same dummy variable
troughout.  At least, this is done also in [[FunctionSpace]], and did not cause
problems.

The operation [[symbolicGrad]] returns the first component of the gradient of
[[op l]].

<<package FSPECF FunctionalSpecialFunction>>=
    dm := new()$SE :: F

    iBesselJ(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselJ [dm, x], dm, n])
          + differentiate(x, t) * ahalf * (besselJ (n-1,x) - besselJ (n+1,x))

    iBesselY(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselY [dm, x], dm, n])
          + differentiate(x, t) * ahalf * (besselY (n-1,x) - besselY (n+1,x))

    iBesselI(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselI [dm, x], dm, n])
          + differentiate(x, t)* ahalf * (besselI (n-1,x) + besselI (n+1,x))

    iBesselK(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselK [dm, x], dm, n])
          - differentiate(x, t)* ahalf * (besselK (n-1,x) + besselK (n+1,x))

@

For the moment we throw an error if we try to differentiate [[polygamma]] with
respect to the first argument.

<<package FSPECF FunctionalSpecialFunction>>=
    ipolygamma(l: List F, x: SE): F ==
        member?(x, variables first l) =>
            error "cannot differentiate polygamma with respect to the first argument"
        n := first l; y := second l
        differentiate(y, x)*polygamma(n+1, y)
    iBetaGrad1(l: List F): F ==
        x := first l; y := second l
        Beta(x,y)*(digamma x - digamma(x+y))
    iBetaGrad2(l: List F): F ==
        x := first l; y := second l
        Beta(x,y)*(digamma y - digamma(x+y))

    if F has ElementaryFunctionCategory then
      iGamma2(l: List F, t: SE): F ==
        a := first l; x := second l
        differentiate(a, t)*kernel(opdiff, [opGamma2 [dm, x], dm, a])
          - differentiate(x, t)* x ** (a - 1) * exp(-x)
      setProperty(opGamma2, SPECIALDIFF, iGamma2@((List F, SE)->F) 
                                                 pretend None)
@

Finally, we tell Axiom to use these functions for differentiation.  Note that
up to [[patch--50]], the properties for the Bessel functions were set using
[[derivative(oppolygamma, [lzero, ipolygammaGrad])]], where [[lzero]] returned
zero always.  Trying to replace [[lzero]] by a function that returns the first
component of the gradient failed, it resulted in an infinite loop for
[[integrate(D(besselJ(a,x),a),a)]].

<<package FSPECF FunctionalSpecialFunction>>=
    derivative(opabs,       abs(#1) * inv(#1))
    derivative(opGamma,     digamma #1 * Gamma #1)
    derivative(opBeta,      [iBetaGrad1, iBetaGrad2])
    derivative(opdigamma,   polygamma(1, #1))
    setProperty(oppolygamma, SPECIALDIFF, ipolygamma@((List F, SE)->F)
                                                     pretend None)
    setProperty(opBesselJ, SPECIALDIFF, iBesselJ@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselY, SPECIALDIFF, iBesselY@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselI, SPECIALDIFF, iBesselI@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselK, SPECIALDIFF, iBesselK@((List F, SE)->F) 
                                                 pretend None)

@
<<FSPECF.dotabb>>=
"FSPECF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSPECF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"FSPECF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter G}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENMFACT GeneralizedMultivariateFactorize}
\pagehead{GeneralizedMultivariateFactorize}{GENMFACT}
\pagepic{ps/v104generalizedmultivariatefactorize.ps}{GENMFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENMFACT GeneralizedMultivariateFactorize>>=
)abbrev package GENMFACT GeneralizedMultivariateFactorize
++ Author: P. Gianni
++ Date Created: 1983
++ Date Last Updated: Sept. 1990
++ Basic Functions:
++ Related Constructors: MultFiniteFactorize, AlgebraicMultFact, MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This is the top level package for doing multivariate factorization
++ over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.

GeneralizedMultivariateFactorize(OV,E,S,R,P) : C == T
 where
  R          :   IntegralDomain
                    -- with factor on R[x]
  S          :   IntegralDomain
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(R,E,OV)

  C == with
    factor      :      P  ->  Factored P
      ++ factor(p) factors the multivariate polynomial p over its coefficient
      ++ domain

  T == add
    factor(p:P) : Factored P ==
      R has FiniteFieldCategory => factor(p)$MultFiniteFactorize(OV,E,R,P)
      R is Polynomial(S) and S has EuclideanDomain =>
         factor(p)$MPolyCatPolyFactorizer(E,OV,S,P)
      R is Fraction(S) and S has CharacteristicZero and 
        S has EuclideanDomain =>
            factor(p)$MRationalFactorize(E,OV,S,P)
      R is Fraction Polynomial S =>
         factor(p)$MPolyCatRationalFunctionFactorizer(E,OV,S,P)
      R has CharacteristicZero and R has EuclideanDomain =>
               factor(p)$MultivariateFactorize(OV,E,R,P)
      squareFree p

@
<<GENMFACT.dotabb>>=
"GENMFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENMFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GENMFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter H}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter I}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INFINITY Infinity}
\pagehead{Infinity}{INFINITY}
\pagepic{ps/v104infinity.ps}{INFINITY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INFINITY Infinity>>=
)abbrev package INFINITY Infinity
++ Top-level infinity
++ Author: Manuel Bronstein
++ Description: Default infinity signatures for the interpreter;
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
Infinity(): with
  infinity     : () -> OnePointCompletion Integer
    ++ infinity() returns infinity.
  plusInfinity : () -> OrderedCompletion  Integer
    ++ plusInfinity() returns plusIinfinity.
  minusInfinity: () -> OrderedCompletion  Integer
    ++ minusInfinity() returns minusInfinity.
 == add
  infinity()      == infinity()$OnePointCompletion(Integer)
  plusInfinity()  == plusInfinity()$OrderedCompletion(Integer)
  minusInfinity() == minusInfinity()$OrderedCompletion(Integer)

@
<<INFINITY.dotabb>>=
"INFINITY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INFINITY"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"INFINITY" -> "PID"
"INFINITY" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IALGFACT InnerAlgFactor}
\pagehead{InnerAlgFactor}{IALGFACT}
\pagepic{ps/v104inneralgfactor.ps}{IALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IALGFACT InnerAlgFactor>>=
)abbrev package IALGFACT InnerAlgFactor
++ Factorisation in a simple algebraic extension
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: 20 Jul 1988
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of a field over which we can factor UP's;
++ Keywords: factorization, algebraic extension, univariate polynomial

InnerAlgFactor(F, UP, AlExt, AlPol): Exports == Implementation where
  F    : Field
  UP   : UnivariatePolynomialCategory F
  AlPol: UnivariatePolynomialCategory AlExt
  AlExt : Join(Field, CharacteristicZero, MonogenicAlgebra(F,UP))
  NUP   ==> SparseUnivariatePolynomial UP
  N     ==> NonNegativeInteger
  Z     ==> Integer
  FR    ==> Factored UP
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2


  Exports ==> with
    factor: (AlPol, UP -> FR)  ->  Factored AlPol
      ++ factor(p, f) returns a prime factorisation of p;
      ++ f is a factorisation map for elements of UP;
 
  Implementation ==> add
    pnorm        : AlPol -> UP
    convrt       : AlPol -> NUP
    change       : UP    -> AlPol
    perturbfactor: (AlPol, Z, UP -> FR) -> List AlPol
    irrfactor    : (AlPol, Z, UP -> FR) -> List AlPol
 
 
    perturbfactor(f, k, fact) ==
      pol   := monomial(1$AlExt,1)-
               monomial(reduce monomial(k::F,1)$UP ,0)
      newf  := elt(f, pol)
      lsols := irrfactor(newf, k, fact)
      pol   := monomial(1, 1) +
               monomial(reduce monomial(k::F,1)$UP,0)
      [elt(pp, pol) for pp in lsols]
 
    ---  factorize the square-free parts of f  ---
    irrfactor(f, k, fact) ==
      degree(f) =$N 1 => [f]
      newf := f
      nn   := pnorm f
      --newval:RN:=1
      --pert:=false
      --if ^ SqFr? nn then
      --  pert:=true
      --  newterm:=perturb(f)
      --  newf:=newterm.ppol
      --  newval:=newterm.pval
      --  nn:=newterm.nnorm
      listfact := factors fact nn
      #listfact =$N 1 =>
        first(listfact).exponent =$Z 1 => [f]
        perturbfactor(f, k + 1, fact)
      listerm:List(AlPol):= []
      for pelt in listfact repeat
        g    := gcd(change(pelt.factor), newf)
        newf := (newf exquo g)::AlPol
        listerm :=
          pelt.exponent =$Z 1 => cons(g, listerm)
          append(perturbfactor(g, k + 1, fact), listerm)
      listerm
 
    factor(f, fact) ==
      sqf := squareFree f
      unit(sqf) * _*/[_*/[primeFactor(pol, sqterm.exponent)
                          for pol in irrfactor(sqterm.factor, 0, fact)]
                                            for sqterm in factors sqf]
 
    p := definingPolynomial()$AlExt
    newp := map(#1::UP, p)$UPCF2(F, UP, UP, NUP)
 
    pnorm  q == resultant(convrt q, newp)
    change q == map(coerce, q)$UPCF2(F,UP,AlExt,AlPol)
 
    convrt q ==
      swap(map(lift, q)$UPCF2(AlExt, AlPol,
           UP, NUP))$CommuteUnivariatePolynomialCategory(F, UP, NUP)

@
<<IALGFACT.dotabb>>=
"IALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ICDEN InnerCommonDenominator}
\pagehead{InnerCommonDenominator}{ICDEN}
\pagepic{ps/v104innercommondenominator.ps}{ICDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ICDEN InnerCommonDenominator>>=
)abbrev package ICDEN InnerCommonDenominator
--% InnerCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Nov 1989
++ Description: InnerCommonDenominator provides functions to compute
++ the common denominator of a finite linear aggregate of elements
++ of the quotient field of an integral domain.
++ Keywords: gcd, quotient, common, denominator.
InnerCommonDenominator(R, Q, A, B): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
  A: FiniteLinearAggregate R
  B: FiniteLinearAggregate Q
 
  Exports ==> with
    commonDenominator: B -> R 
      ++ commonDenominator([q1,...,qn]) returns a common denominator
      ++ d for q1,...,qn.
    clearDenominator : B -> A 
      ++ clearDenominator([q1,...,qn]) returns \spad{[p1,...,pn]} such that
      ++ \spad{qi = pi/d} where d is a common denominator for the qi's.
    splitDenominator : B -> Record(num: A, den: R)
      ++ splitDenominator([q1,...,qn]) returns
      ++ \spad{[[p1,...,pn], d]} such that
      ++ \spad{qi = pi/d} and d is a common denominator for the qi's.
 
  Implementation ==> add
    import FiniteLinearAggregateFunctions2(Q, B, R, A)
 
    clearDenominator l ==
      d := commonDenominator l
      map(numer(d * #1), l)
 
    splitDenominator l ==
      d := commonDenominator l
      [map(numer(d * #1), l), d]
 
    if R has GcdDomain then
      commonDenominator l == reduce(lcm, map(denom, l),1)
    else
      commonDenominator l == reduce("*", map(denom, l), 1)

@
<<ICDEN.dotabb>>=
"ICDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ICDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"ICDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ITRIGMNP InnerTrigonometricManipulations}
\pagehead{InnerTrigonometricManipulations}{ITRIGMNP}
\pagepic{ps/v104innertrigonometricmanipulations.ps}{ITRIGMNP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ITRIGMNP InnerTrigonometricManipulations>>=
)abbrev package ITRIGMNP InnerTrigonometricManipulations
++ Trigs to/from exps and logs
++ Author: Manuel Bronstein
++ Date Created: 4 April 1988
++ Date Last Updated: 9 October 1993
++ Description:
++   This package provides transformations from trigonometric functions
++   to exponentials and logarithms, and back.
++   F and FG should be the same type of function space.
++ Keywords: trigonometric, function, manipulation.
InnerTrigonometricManipulations(R,F,FG): Exports == Implementation where
  R  : Join(IntegralDomain, OrderedSet)
  F  : Join(FunctionSpace R, RadicalCategory,
            TranscendentalFunctionCategory)
  FG : Join(FunctionSpace Complex R, RadicalCategory,
            TranscendentalFunctionCategory)

  Z   ==> Integer
  SY  ==> Symbol
  OP  ==> BasicOperator
  GR  ==> Complex R
  GF  ==> Complex F
  KG  ==> Kernel FG
  PG  ==> SparseMultivariatePolynomial(GR, KG)
  UP  ==> SparseUnivariatePolynomial PG
  NTHR  ==> "nthRoot"::SY

  Exports ==> with
    GF2FG        : GF -> FG
      ++ GF2FG(a + i b) returns \spad{a + i b} viewed as a function with
      ++ the \spad{i} pushed down into the coefficient domain.
    FG2F         : FG -> F
      ++ FG2F(a + i b) returns \spad{a + sqrt(-1) b}.
    F2FG         : F  -> FG
      ++ F2FG(a + sqrt(-1) b) returns \spad{a + i b}.
    explogs2trigs: FG -> GF
      ++ explogs2trigs(f) rewrites all the complex logs and
      ++ exponentials appearing in \spad{f} in terms of trigonometric
      ++ functions.
    trigs2explogs: (FG, List KG, List SY) -> FG
      ++ trigs2explogs(f, [k1,...,kn], [x1,...,xm]) rewrites
      ++ all the trigonometric functions appearing in \spad{f} and involving
      ++ one of the \spad{xi's} in terms of complex logarithms and
      ++ exponentials. A kernel of the form \spad{tan(u)} is expressed
      ++ using \spad{exp(u)**2} if it is one of the \spad{ki's}, in terms of
      ++ \spad{exp(2*u)} otherwise.

  Implementation ==> add
    ker2explogs: (KG, List KG, List SY) -> FG
    smp2explogs: (PG, List KG, List SY) -> FG
    supexp     : (UP, GF, GF, Z) -> GF
    GR2GF      : GR -> GF
    GR2F       : GR -> F
    KG2F       : KG -> F
    PG2F       : PG -> F
    ker2trigs  : (OP, List GF) -> GF
    smp2trigs  : PG -> GF
    sup2trigs  : (UP, GF) -> GF

    nth := R has RetractableTo(Integer) and F has RadicalCategory

    GR2F g        == real(g)::F + sqrt(-(1::F)) * imag(g)::F
    KG2F k        == map(FG2F, k)$ExpressionSpaceFunctions2(FG, F)
    FG2F f        == (PG2F numer f) / (PG2F denom f)
    F2FG f        == map(#1::GR, f)$FunctionSpaceFunctions2(R,F,GR,FG)
    GF2FG f       == (F2FG real f) + complex(0, 1)$GR ::FG * F2FG imag f
    GR2GF gr      == complex(real(gr)::F, imag(gr)::F)

-- This expects the argument to have only tan and atans left.
-- Does a half-angle correction if k is not in the initial kernel list.
    ker2explogs(k, l, lx) ==
      empty?([v for v in variables(kf := k::FG) |
                                         member?(v, lx)]$List(SY)) => kf
      empty?(args := [trigs2explogs(a, l, lx)
                                    for a in argument k]$List(FG)) => kf
      im := complex(0, 1)$GR :: FG
      z  := first args
      is?(k, "tan"::Symbol)  =>
        e := (member?(k, l) => exp(im * z) ** 2;  exp(2 * im * z))
        - im * (e - 1) /$FG (e + 1)
      is?(k, "atan"::Symbol) =>
        im * log((1 -$FG im *$FG z)/$FG (1 +$FG im *$FG z))$FG / (2::FG)
      (operator k) args

    trigs2explogs(f, l, lx) ==
      smp2explogs(numer f, l, lx) / smp2explogs(denom f, l, lx)

    -- return op(arg) as f + %i g
    -- op is already an operator with semantics over R, not GR
    ker2trigs(op, arg) ==
      "and"/[zero? imag x for x in arg] =>
        complex(op [real x for x in arg]$List(F), 0)
      a := first arg
      is?(op, "exp"::Symbol)  => exp a
      is?(op, "log"::Symbol)  => log a
      is?(op, "sin"::Symbol)  => sin a
      is?(op, "cos"::Symbol)  => cos a
      is?(op, "tan"::Symbol)  => tan a
      is?(op, "cot"::Symbol)  => cot a
      is?(op, "sec"::Symbol)  => sec a
      is?(op, "csc"::Symbol)  => csc a
      is?(op, "asin"::Symbol)  => asin a
      is?(op, "acos"::Symbol)  => acos a
      is?(op, "atan"::Symbol)  => atan a
      is?(op, "acot"::Symbol)  => acot a
      is?(op, "asec"::Symbol)  => asec a
      is?(op, "acsc"::Symbol)  => acsc a
      is?(op, "sinh"::Symbol)  => sinh a
      is?(op, "cosh"::Symbol)  => cosh a
      is?(op, "tanh"::Symbol)  => tanh a
      is?(op, "coth"::Symbol)  => coth a
      is?(op, "sech"::Symbol)  => sech a
      is?(op, "csch"::Symbol)  => csch a
      is?(op, "asinh"::Symbol)  => asinh a
      is?(op, "acosh"::Symbol)  => acosh a
      is?(op, "atanh"::Symbol)  => atanh a
      is?(op, "acoth"::Symbol)  => acoth a
      is?(op, "asech"::Symbol)  => asech a
      is?(op, "acsch"::Symbol)  => acsch a
      is?(op, "abs"::Symbol)    => sqrt(norm a)::GF
      nth and is?(op, NTHR) => nthRoot(a, retract(second arg)@Z)
      error "ker2trigs: cannot convert kernel to gaussian function"

    sup2trigs(p, f) ==
      map(smp2trigs, p)$SparseUnivariatePolynomialFunctions2(PG, GF) f

    smp2trigs p ==
      map(explogs2trigs(#1::FG),GR2GF, p)$PolynomialCategoryLifting(
                                    IndexedExponents KG, KG, GR, PG, GF)

    explogs2trigs f ==
      (m := mainKernel f) case "failed" =>
        GR2GF(retract(numer f)@GR) / GR2GF(retract(denom f)@GR)
      op  := operator(operator(k := m::KG))$F
      arg := [explogs2trigs x for x in argument k]
      num := univariate(numer f, k)
      den := univariate(denom f, k)
      is?(op, "exp"::Symbol) =>
        e  := exp real first arg
        y  := imag first arg
        g  := complex(e *  cos y, e * sin y)$GF
        gi := complex(cos(y) / e, - sin(y) / e)$GF
        supexp(num,g,gi,b := (degree num)::Z quo 2)/supexp(den,g,gi,b)
      sup2trigs(num, g := ker2trigs(op, arg)) / sup2trigs(den, g)

    supexp(p, f1, f2, bse) ==
      ans:GF := 0
      while p ^= 0 repeat
        g := explogs2trigs(leadingCoefficient(p)::FG)
        if ((d := degree(p)::Z - bse) >= 0) then
             ans := ans + g * f1 ** d
        else ans := ans + g * f2 ** (-d)
        p := reductum p
      ans

    PG2F p ==
      map(KG2F, GR2F, p)$PolynomialCategoryLifting(IndexedExponents KG,
                                                          KG, GR, PG, F)

    smp2explogs(p, l, lx) ==
      map(ker2explogs(#1, l, lx), #1::FG, p)$PolynomialCategoryLifting(
                                    IndexedExponents KG, KG, GR, PG, FG)

@
<<ITRIGMNP.dotabb>>=
"ITRIGMNP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ITRIGMNP"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"ITRIGMNP" -> "FS"
"ITRIGMNP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMBINAT IntegerCombinatoricFunctions}
\pagehead{IntegerCombinatoricFunctions}{COMBINAT}
\pagepic{ps/v104integercombinatoricfunctions.ps}{COMBINAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMBINAT IntegerCombinatoricFunctions>>=
)abbrev package COMBINAT IntegerCombinatoricFunctions
++ Authors: Martin Brock, Robert Sutor, Michael Monagan
++ Date Created: June 1987
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: integer, combinatoric function
++ Examples:
++ References:
++ Description:
++   The \spadtype{IntegerCombinatoricFunctions} package provides some
++   standard functions in combinatorics.
Z   ==> Integer
N   ==> NonNegativeInteger
SUP ==> SparseUnivariatePolynomial

IntegerCombinatoricFunctions(I:IntegerNumberSystem): with
   binomial: (I, I) -> I
      ++ \spad{binomial(n,r)} returns the binomial coefficient
      ++ \spad{C(n,r) = n!/(r! (n-r)!)}, where \spad{n >= r >= 0}.
      ++ This is the number of combinations of n objects taken r at a time.
   factorial: I -> I
      ++ \spad{factorial(n)} returns \spad{n!}. this is the product of all
      ++ integers between 1 and n (inclusive). 
      ++ Note: \spad{0!} is defined to be 1.
   multinomial: (I, List I) -> I
      ++ \spad{multinomial(n,[m1,m2,...,mk])} returns the multinomial
      ++ coefficient \spad{n!/(m1! m2! ... mk!)}.
   partition: I -> I
      ++ \spad{partition(n)} returns the number of partitions of the integer n.
      ++ This is the number of distinct ways that n can be written as
      ++ a sum of positive integers.
   permutation: (I, I) -> I
      ++ \spad{permutation(n)} returns \spad{!P(n,r) = n!/(n-r)!}. This is
      ++ the number of permutations of n objects taken r at a time.
   stirling1: (I, I) -> I
      ++ \spad{stirling1(n,m)} returns the Stirling number of the first kind
      ++ denoted \spad{S[n,m]}.
   stirling2: (I, I) -> I
      ++ \spad{stirling2(n,m)} returns the Stirling number of the second kind
      ++ denoted \spad{SS[n,m]}.
 == add
   F : Record(Fn:I, Fv:I) := [0,1]
   B : Record(Bn:I, Bm:I, Bv:I) := [0,0,0]
   S : Record(Sn:I, Sp:SUP I) := [0,0]
   P : IndexedFlexibleArray(I,0) := new(1,1)$IndexedFlexibleArray(I,0)
 
   partition n ==
      -- This is the number of ways of expressing n as a sum of positive
      -- integers, without regard to order.  For example partition 5 = 7
      -- since 5 = 1+1+1+1+1 = 1+1+1+2 = 1+2+2 = 1+1+3 = 1+4 = 2+3 = 5 .
      -- Uses O(sqrt n) term recurrence from Abramowitz & Stegun pp. 825
      -- p(n) = sum (-1)**k p(n-j) where 0 < j := (3*k**2+-k) quo 2 <= n
      minIndex(P) ^= 0 => error "Partition: must have minIndex of 0"
      m := #P
      n < 0 => error "partition is not defined for negative integers"
      n < m::I => P(convert(n)@Z)
      concat_!(P, new((convert(n+1)@Z - m)::N,0)$IndexedFlexibleArray(I,0))
      for i in m..convert(n)@Z repeat
         s:I := 1
         t:I := 0
         for k in 1.. repeat
            l := (3*k*k-k) quo 2
            l > i => leave
            u := l+k
            t := t + s * P(convert(i-l)@Z)
            u > i => leave
            t := t + s * P(convert(i-u)@Z)
            s := -s
         P.i := t
      P(convert(n)@Z)
 
   factorial n ==
      s,f,t : I
      n < 0 => error "factorial not defined for negative integers"
      if n <= F.Fn then s := f := 1 else (s, f) := F
      for k in convert(s+1)@Z .. convert(n)@Z by 2 repeat
         if k::I = n then t := n else t := k::I * (k+1)::I
         f := t * f
      F.Fn := n
      F.Fv := f
 
   binomial(n, m) ==
      s,b:I
      n < 0 or m < 0 or m > n => 0
      m = 0 => 1
      n < 2*m => binomial(n, n-m)
      (s,b) := (0,1)
      if B.Bn = n then
         B.Bm = m+1 =>
            b := (B.Bv * (m+1)) quo (n-m)
            B.Bn := n
            B.Bm := m
            return(B.Bv := b)
         if m >= B.Bm then (s := B.Bm; b := B.Bv) else (s,b) := (0,1)
      for k in convert(s+1)@Z .. convert(m)@Z repeat
        b := (b*(n-k::I+1)) quo k::I
      B.Bn := n
      B.Bm := m
      B.Bv := b
 
   multinomial(n, m) ==
      for t in m repeat t < 0 => return 0
      n < _+/m => 0
      s:I := 1
      for t in m repeat s := s * factorial t
      factorial n quo s
 
   permutation(n, m) ==
      t:I
      m < 0 or n < m => 0
      m := n-m
      p:I := 1
      for k in convert(m+1)@Z .. convert(n)@Z by 2 repeat
         if k::I = n then t := n else t := (k*(k+1))::I
         p := p * t
      p
 
   stirling1(n, m) ==
      -- Definition: (-1)**(n-m) S[n,m] is the number of
      -- permutations of n symbols which have m cycles.
      n < 0 or m < 1 or m > n => 0
      m = n => 1
      S.Sn = n => coefficient(S.Sp, convert(m)@Z :: N)
      x := monomial(1, 1)$SUP(I)
      S.Sn := n
      S.Sp := x
      for k in 1 .. convert(n-1)@Z repeat S.Sp := S.Sp * (x - k::SUP(I))
      coefficient(S.Sp, convert(m)@Z :: N)
 
   stirling2(n, m) ==
      -- definition: SS[n,m] is the number of ways of partitioning
      -- a set of n elements into m non-empty subsets
      n < 0 or m < 1 or m > n => 0
      m = 1 or n = m => 1
      s:I := if odd? m then -1 else 1
      t:I := 0
      for k in 1..convert(m)@Z repeat
         s := -s
         t := t + s * binomial(m, k::I) * k::I ** (convert(n)@Z :: N)
      t quo factorial m

@
<<COMBINAT.dotabb>>=
"COMBINAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMBINAT"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"COMBINAT" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter J}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter K}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter L}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter M}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MCDEN MatrixCommonDenominator}
\pagehead{MatrixCommonDenominator}{MCDEN}
\pagepic{ps/v104matrixcommondenominator.ps}{MCDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MCDEN MatrixCommonDenominator>>=
)abbrev package MCDEN MatrixCommonDenominator
--% MatrixCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 20 Jul 1990
++ Description: MatrixCommonDenominator provides functions to
++ compute the common denominator of a matrix of elements of the
++ quotient field of an integral domain.
++ Keywords: gcd, quotient, matrix, common, denominator.
MatrixCommonDenominator(R, Q): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
 
  VR ==> Vector R
  VQ ==> Vector Q
 
  Exports ==> with
    commonDenominator: Matrix Q -> R
      ++ commonDenominator(q) returns a common denominator d for
      ++ the elements of q.
    clearDenominator : Matrix Q -> Matrix R
      ++ clearDenominator(q) returns p such that \spad{q = p/d} where d is
      ++ a common denominator for the elements of q.
    splitDenominator : Matrix Q -> Record(num: Matrix R, den: R)
      ++ splitDenominator(q) returns \spad{[p, d]} such that \spad{q = p/d} and d
      ++ is a common denominator for the elements of q.
 
  Implementation ==> add
    import ListFunctions2(Q, R)
    import MatrixCategoryFunctions2(Q,VQ,VQ,Matrix Q,R,VR,VR,Matrix R)
 
    clearDenominator m ==
      d := commonDenominator m
      map(numer(d * #1), m)
 
    splitDenominator m ==
      d := commonDenominator m
      [map(numer(d * #1), m), d]
 
    if R has GcdDomain then
      commonDenominator m == lcm map(denom, parts m)
    else
      commonDenominator m == reduce("*",map(denom, parts m),1)$List(R)

@
<<MCDEN.dotabb>>=
"MCDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MCDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MCDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MTHING MergeThing}
\pagehead{MergeThing}{MTHING}
\pagepic{ps/v104mergething.ps}{MTHING}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MTHING MergeThing>>=
)abbrev package MTHING MergeThing
++ This package exports tools for merging lists
MergeThing(S:OrderedSet): Exports == Implementation where
  Exports == with
    mergeDifference: (List(S),List(S)) -> List(S)
	++ mergeDifference(l1,l2) returns a list of elements in l1 not present
	++ in l2. Assumes lists are ordered and all x in l2 are also in l1.
  Implementation == add
    mergeDifference1: (List S,S,List S) -> List S
    mergeDifference(x,y) == 
      null x or null y => x
      mergeDifference1(x,y.first,y.rest)
      x.first=y.first => x.rest
      x
    mergeDifference1(x,fy,ry) ==  
      rx := x
      while not null rx repeat
        rx := rx.rest
        frx := rx.first
        while fy < frx repeat
          null ry => return x
          fy := first ry
          ry := rest ry
        frx = fy =>
          x.rest := rx.rest
          null ry => return x
          fy := ry.first
          ry := ry.rest
        x := rx

@
<<MTHING.dotabb>>=
"MTHING" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MTHING"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"MTHING" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MHROWRED ModularHermitianRowReduction}
\pagehead{ModularHermitianRowReduction}{MHROWRED}
\pagepic{ps/v104modularhermitianrowreduction.ps}{MHROWRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MHROWRED ModularHermitianRowReduction>>=
)abbrev package MHROWRED ModularHermitianRowReduction
++ Modular hermitian row reduction.
++ Author: Manuel Bronstein
++ Date Created: 22 February 1989
++ Date Last Updated: 24 November 1993
++ Keywords: matrix, reduction.
-- should be moved into matrix whenever possible
ModularHermitianRowReduction(R): Exports == Implementation where
  R: EuclideanDomain

  Z   ==> Integer
  V   ==> Vector R
  M   ==> Matrix R
  REC ==> Record(val:R, cl:Z, rw:Z)

  Exports ==> with
    rowEch       : M -> M
      ++ rowEch(m) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus.
    rowEchelon   : (M, R) -> M
      ++ rowEchelon(m, d) computes a modular row-echelon form mod d of
      ++    [d     ]
      ++    [  d   ]
      ++    [    . ]
      ++    [     d]
      ++    [   M  ]
      ++ where \spad{M = m mod d}.
    rowEchLocal    : (M, R) -> M
      ++ rowEchLocal(m,p) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus over a local ring where p is the only prime.
    rowEchelonLocal: (M, R, R) -> M
      ++ rowEchelonLocal(m, d, p) computes the row-echelon form of m
      ++ concatenated with d times the identity matrix
      ++ over a local ring where p is the only prime.
    normalizedDivide: (R, R) -> Record(quotient:R, remainder:R)
      ++ normalizedDivide(n,d) returns a normalized quotient and
      ++ remainder such that consistently unique representatives
      ++ for the residue class are chosen, e.g. positive remainders



  Implementation ==> add
    order   : (R, R) -> Z
    vconc   : (M, R) -> M
    non0    : (V, Z) -> Union(REC, "failed")
    nonzero?: V -> Boolean
    mkMat   : (M, List Z) -> M
    diagSubMatrix: M -> Union(Record(val:R, mat:M), "failed")
    determinantOfMinor: M -> R
    enumerateBinomial: (List Z, Z, Z) -> List Z

    nonzero? v == any?(#1 ^= 0, v)

-- returns [a, i, rown] if v = [0,...,0,a,0,...,0]
-- where a <> 0 and i is the index of a, "failed" otherwise.
    non0(v, rown) ==
      ans:REC
      allZero:Boolean := true
      for i in minIndex v .. maxIndex v repeat
        if qelt(v, i) ^= 0 then
          if allZero then
            allZero := false
            ans := [qelt(v, i), i, rown]
          else return "failed"
      allZero => "failed"
      ans

-- returns a matrix made from the non-zero rows of x whose row number
-- is not in l
    mkMat(x, l) ==
      empty?(ll := [parts row(x, i)
         for i in minRowIndex x .. maxRowIndex x |
           (not member?(i, l)) and nonzero? row(x, i)]$List(List R)) =>
              zero(1, ncols x)
      matrix ll

-- returns [m, d] where m = x with the zero rows and the rows of
-- the diagonal of d removed, if x has a diagonal submatrix of d's,
-- "failed" otherwise.
    diagSubMatrix x ==
      l  := [u::REC for i in minRowIndex x .. maxRowIndex x |
                                     (u := non0(row(x, i), i)) case REC]
      for a in removeDuplicates([r.val for r in l]$List(R)) repeat
        {[r.cl for r in l | r.val = a]$List(Z)}$Set(Z) =
          {[z for z in minColIndex x .. maxColIndex x]$List(Z)}$Set(Z)
            => return [a, mkMat(x, [r.rw for r in l | a = r.val])]
      "failed"

-- returns a non-zero determinant of a minor of x of rank equal to
-- the number of columns of x, if there is one, 0 otherwise
    determinantOfMinor x ==
-- do not compute a modulus for square matrices, since this is as expensive
-- as the Hermite reduction itself
      (nr := nrows x) <= (nc := ncols x) => 0
      lc := [i for i in minColIndex x .. maxColIndex x]$List(Integer)
      lr := [i for i in minRowIndex x .. maxRowIndex x]$List(Integer)
      for i in 1..(n := binomial(nr, nc)) repeat
        (d := determinant x(enumerateBinomial(lr, nc, i), lc)) ^= 0 =>
          j := i + 1 + (random()$Z rem (n - i))
          return gcd(d, determinant x(enumerateBinomial(lr, nc, j), lc))
      0

-- returns the i-th selection of m elements of l = (a1,...,an),
--                 /n\
-- where 1 <= i <= | |
--                 \m/
    enumerateBinomial(l, m, i) ==
      m1 := minIndex l - 1
      zero?(m := m - 1) => [l(m1 + i)]
      for j in 1..(n := #l) repeat
        i <= (b := binomial(n - j, m)) =>
          return concat(l(m1 + j), enumerateBinomial(rest(l, j), m, i))
        i := i - b
      error "Should not happen"

    rowEch x ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelon(x, d)
      rowEchelon(u.mat, u.val)

    vconc(y, m) ==
      vertConcat(diagonalMatrix new(ncols y, m)$V, map(#1 rem m, y))

    order(m, p) ==
      zero? m => -1
      for i in 0.. repeat
        (mm := m exquo p) case "failed" => return i
        m := mm::R

    if R has IntegerNumberSystem then
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            qr := divide(n, d)
            qr.remainder >= 0 => qr
            d > 0 =>
                qr.remainder := qr.remainder + d
                qr.quotient := qr.quotient - 1
                qr
            qr.remainder := qr.remainder - d
            qr.quotient := qr.quotient + 1
            qr
    else
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            divide(n, d)

    rowEchLocal(x,p) ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelonLocal(x, d, p)
      rowEchelonLocal(u.mat, u.val, p)

    rowEchelonLocal(y, m, p) ==
        m := p**(order(m,p)::NonNegativeInteger)
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave x
          rown := minr - 1
          pivord : Integer
          npivord : Integer
          for k in i .. nrows repeat
            qelt(x,k,j) = 0 => "next k"
            npivord := order(qelt(x,k,j),p)
            (rown = minr - 1) or (npivord  <  pivord) =>
                    rown := k
                    pivord := npivord
          rown = minr - 1 => "enuf"
          x := swapRows_!(x, i, rown)
          (a, b, d) := extendedEuclidean(qelt(x,i,j), m)
          qsetelt_!(x,i,j,d)
          pivot := d
          for k in j+1 .. ncols repeat
            qsetelt_!(x,i,k, a * qelt(x,i,k) rem m)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            q := (qelt(x,k,j) exquo pivot) :: R
            for k1 in j+1 .. ncols repeat
              v2 := (qelt(x,k,k1) - q * qelt(x,i,k1)) rem m
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, k, j, 0)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "enuf"
            qr    := normalizedDivide(qelt(x,k,j), pivot)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

    if R has Field then
      rowEchelon(y, m) == rowEchelon vconc(y, m)

    else

      rowEchelon(y, m) ==
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave
          rown := minr - 1
          for k in i .. nrows repeat
            if (qelt(x,k,j) ^= 0) and ((rown = minr - 1) or
                  sizeLess?(qelt(x,k,j), qelt(x,rown,j))) then rown := k
          rown = minr - 1 => "next j"
          x := swapRows_!(x, i, rown)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            (a, b, d) := extendedEuclidean(qelt(x,i,j), qelt(x,k,j))
            (b1, a1) :=
               ((qelt(x,i,j) exquo d)::R, (qelt(x,k,j) exquo d)::R)
            -- a*b1+a1*b = 1
            for k1 in j+1 .. ncols repeat
              v1 := (a  * qelt(x,i,k1) +  b * qelt(x,k,k1)) rem m
              v2 := (b1 * qelt(x,k,k1) - a1 * qelt(x,i,k1)) rem m
              qsetelt_!(x, i, k1, v1)
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, i, j, d)
            qsetelt_!(x, k, j, 0)
          un := unitNormal qelt(x,i,j)
          qsetelt_!(x,i,j,un.canonical)
          if un.associate ^= 1 then for jj in (j+1)..ncols repeat
              qsetelt_!(x,i,jj,un.associate * qelt(x,i,jj))

          xij := qelt(x,i,j)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "next k"
            qr    := normalizedDivide(qelt(x,k,j), xij)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

@
<<MHROWRED.dotabb>>=
"MHROWRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MHROWRED"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"MHROWRED" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPCPF MPolyCatPolyFactorizer}
\pagehead{MPolyCatPolyFactorizer}{MPCPF}
\pagepic{ps/v104mpolycatpolyfactorizer.ps}{MPCPF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPCPF MPolyCatPolyFactorizer>>=
)abbrev package MPCPF MPolyCatPolyFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are polynomials over
++ some ring R over which we can factor. It is used internally by packages
++ such as the solve package which need to work with polynomials in a specific
++ set of variables with coefficients which are polynomials in all the other
++ variables.

MPolyCatPolyFactorizer(E,OV,R,PPR) : C == T
 where
  R     :   EuclideanDomain
  E     :   OrderedAbelianMonoidSup
    -- following type is required by PushVariables
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  PR    ==> Polynomial R
  PPR   :   PolynomialCategory(PR,E,OV)
  NNI   ==> NonNegativeInteger
  ISY   ==> IndexedExponents Symbol
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial PR
  UPPR  ==> SparseUnivariatePolynomial PPR

  C  == with
     factor      :        PPR             ->   Factored PPR
       ++ factor(p) factors a polynomial with polynomial
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

     import PushVariables(R,E,OV,PPR)

        ----  factorization of p ----
     factor(p:PPR) : Factored PPR ==
       ground? p => nilFactor(p,1)
       c := content p
       p := (p exquo c)::PPR
       vars:List OV :=variables p
       g:PR:=retract pushdown(p, vars)
       flist := factor(g)$GeneralizedMultivariateFactorize(Symbol,ISY,R,R,PR)
       ffact : List(Record(irr:PPR,pow:Integer))
       ffact:=[[pushup(u.factor::PPR,vars),u.exponent] for u in factors flist]
       fcont:=(unit flist)::PPR
       nilFactor(c*fcont,1)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])

@
<<MPCPF.dotabb>>=
"MPCPF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPCPF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPCPF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPRFF MPolyCatRationalFunctionFactorizer}
\pagehead{MPolyCatRationalFunctionFactorizer}{MPRFF}
\pagepic{ps/v104mpolycatrationalfunctionfactorizer.ps}{MPRFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPRFF MPolyCatRationalFunctionFactorizer>>=
)abbrev package MPRFF MPolyCatRationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are rational functions over
++ some ring R over which we can factor. It is used internally by packages
++ such as primary decomposition which need to work with polynomials
++ with rational function coefficients, i.e. themselves fractions of
++ polynomials.

MPolyCatRationalFunctionFactorizer(E,OV,R,PRF) : C == T
 where
  R     :   IntegralDomain
  F     ==> Fraction Polynomial R
  RN    ==> Fraction Integer
  E     :   OrderedAbelianMonoidSup
  OV    :   OrderedSet  with 
                convert : % -> Symbol
                  ++ convert(x) converts x to a symbol
  PRF   :   PolynomialCategory(F,E,OV)
  NNI   ==> NonNegativeInteger
  P     ==> Polynomial R
  ISE   ==> IndexedExponents  SE
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial P
  UF    ==> SparseUnivariatePolynomial F
  UPRF  ==> SparseUnivariatePolynomial PRF
  QuoForm   ==> Record(sup:P,inf:P)

  C  == with
     totalfract  :        PRF             ->   QuoForm
       ++ totalfract(prf) takes a polynomial whose coefficients are
       ++ themselves fractions of polynomials and returns a record
       ++ containing the numerator and denominator resulting from
       ++ putting prf over a common denominator.
     pushdown    :      (PRF,OV)          ->   PRF
       ++ pushdown(prf,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the polynomial prf.
     pushdterm   :      (UPRF,OV)         ->   PRF
       ++ pushdterm(monom,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the monomial monom.
     pushup      :      (PRF,OV)          ->   PRF
       ++ pushup(prf,var) raises all occurences of the
       ++ variable var in the coefficients of the polynomial prf
       ++ back to the polynomial level.
     pushucoef   :       (UP,OV)          ->   PRF
       ++ pushucoef(upoly,var) converts the anonymous univariate
       ++ polynomial upoly to a polynomial in var over rational functions.
     pushuconst  :        (F,OV)          ->   PRF
       ++ pushuconst(r,var) takes a rational function and raises
       ++ all occurances of the variable var to the polynomial level.
     factor      :        PRF             ->   Factored PRF
       ++ factor(prf) factors a polynomial with rational function
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

        ----  factorization of p ----
     factor(p:PRF) : Factored PRF ==
       truelist:List OV :=variables p
       tp:=totalfract(p)
       nump:P:= tp.sup
       denp:F:=inv(tp.inf ::F)
       ffact : List(Record(irr:PRF,pow:Integer))
       flist:Factored P
       if R is Fraction Integer then
         flist:=
           ((factor nump)$MRationalFactorize(ISE,SE,Integer,P))
                          pretend (Factored P)
       else
         if R has FiniteFieldCategory  then
            flist:= ((factor nump)$MultFiniteFactorize(SE,ISE,R,P))
                    pretend (Factored P)

         else
            if R has Field then error "not done yet"

            else
              if R has CharacteristicZero then 
                flist:= ((factor nump)$MultivariateFactorize(SE,ISE,R,P))
                                                pretend (Factored P)
              else error "can't happen"  
       ffact:=[[u.factor::F::PRF,u.exponent] for u in factors flist]
       fcont:=(unit flist)::F::PRF
       for x in truelist repeat
         fcont:=pushup(fcont,x)
         ffact:=[[pushup(ff.irr,x),ff.pow] for ff in ffact]
       (denp*fcont)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])


-- the following functions are used to "push" x in the coefficient ring -

        ----  push x in the coefficient domain for a polynomial ----
     pushdown(g:PRF,x:OV) : PRF ==
       ground? g => g
       rf:PRF:=0$PRF
       ug:=univariate(g,x)
       while ug^=0 repeat
         rf:=rf+pushdterm(ug,x)
         ug := reductum ug
       rf

      ----  push x in the coefficient domain for a term ----
     pushdterm(t:UPRF,x:OV):PRF ==
       n:=degree(t)
       cf:=monomial(1,convert x,n)$P :: F
       cf * leadingCoefficient t

               ----  push back the variable  ----
     pushup(f:PRF,x:OV) :PRF ==
       ground? f => pushuconst(retract f,x)
       v:=mainVariable(f)::OV
       g:=univariate(f,v)
       multivariate(map(pushup(#1,x),g),v)

      ----  push x back from the coefficient domain ----
     pushuconst(r:F,x:OV):PRF ==
       xs:SE:=convert x
       degree(denom r,xs)>0 => error "bad polynomial form"
       inv((denom r)::F)*pushucoef(univariate(numer r,xs),x)


     pushucoef(c:UP,x:OV):PRF ==
       c = 0 => 0
       monomial((leadingCoefficient c)::F::PRF,x,degree c) +
                 pushucoef(reductum c,x)


           ----  write p with a common denominator  ----

     totalfract(p:PRF) : QuoForm ==
       p=0 => [0$P,1$P]$QuoForm
       for x in variables p repeat p:=pushdown(p,x)
       g:F:=retract p
       [numer g,denom g]$QuoForm

@
<<MPRFF.dotabb>>=
"MPRFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPRFF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPRFF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MRATFAC MRationalFactorize}
\pagehead{MRationalFactorize}{MRATFAC}
\pagepic{ps/v104mrationalfactorize.ps}{MRATFAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MRATFAC MRationalFactorize>>=
)abbrev package MRATFAC MRationalFactorize
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  MRationalFactorize contains the factor function for multivariate
++ polynomials over the quotient field of a ring R such that the package
++ MultivariateFactorize can factor multivariate polynomials over R.


MRationalFactorize(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   Join(EuclideanDomain, CharacteristicZero)  -- with factor over R[x]
  FR  ==> Fraction R
  P  :    PolynomialCategory(FR,E,OV)
  MPR ==> SparseMultivariatePolynomial(R,OV)
  SUP ==> SparseUnivariatePolynomial

  C  == with
     factor      : P   ->  Factored P
       ++ factor(p) factors the multivariate polynomial p with coefficients
       ++ which are fractions of elements of R.

  T  == add
     IE     ==> IndexedExponents OV
     PCLFRR ==> PolynomialCategoryLifting(E,OV,FR,P,MPR)
     PCLRFR ==> PolynomialCategoryLifting(IE,OV,R,MPR,P)
     MFACT  ==> MultivariateFactorize(OV,IE,R,MPR)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     numer1(c:FR): MPR   == (numer c) :: MPR
     numer2(pol:P) : MPR == map(coerce,numer1,pol)$PCLFRR
     coerce1(d:R) : P == (d::FR)::P
     coerce2(pp:MPR) :P == map(coerce,coerce1,pp)$PCLRFR 

     factor(p:P) : Factored P ==
       pden:R:=lcm([denom c for c in coefficients p])
       pol :P:= (pden::FR)*p
       ipol:MPR:= map(coerce,numer1,pol)$PCLFRR
       ffact:=(factor ipol)$MFACT
       (1/pden)*map(coerce,coerce1,(unit ffact))$PCLRFR *
           _*/[primeFactor(map(coerce,coerce1,u.factor)$PCLRFR,
                           u.exponent) for u in factors ffact]

@
<<MRATFAC.dotabb>>=
"MRATFAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MRATFAC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MMAP MultipleMap}
\pagehead{MultipleMap}{MMAP}
\pagepic{ps/v104multiplemap.ps}{MMAP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MMAP MultipleMap>>=
)abbrev package MMAP MultipleMap
++ Lifting a map through 2 levels of polynomials
++ Author: Manuel Bronstein
++ Date Created: May 1988
++ Date Last Updated: 11 Jul 1990
++ Description: Lifting of a map through 2 levels of polynomials;
MultipleMap(R1,UP1,UPUP1,R2,UP2,UPUP2): Exports == Implementation where
  R1   : IntegralDomain
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  R2   : IntegralDomain
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2

  Q1 ==> Fraction UP1
  Q2 ==> Fraction UP2

  Exports ==> with
    map: (R1 -> R2, UPUP1) -> UPUP2
      ++ map(f, p) lifts f to the domain of p then applies it to p.

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R1, UP1, R2, UP2)

    rfmap: (R1 -> R2, Q1) -> Q2

    rfmap(f, q) == map(f, numer q) / map(f, denom q)

    map(f, p) ==
      map(rfmap(f, #1),
          p)$UnivariatePolynomialCategoryFunctions2(Q1, UPUP1, Q2, UPUP2)

@
<<MMAP.dotabb>>=
"MMAP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MMAP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MMAP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter N}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE02 NagFittingPackage}
\pagehead{NagFittingPackage}{NAGE02}
\pagepic{ps/v104nagfittingpackage.ps}{NAGE02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE02 NagFittingPackage>>=
)abbrev package NAGE02 NagFittingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:59 1994
++ Description:
++ This package uses the NAG Library to find a
++ function which approximates a set of data points. Typically the
++ data contain random errors, as of experimental measurement, which
++ need to be smoothed out. To seek an approximation to the data, it
++ is first necessary to specify for the approximating function a
++ mathematical form (a polynomial, for example) which contains a
++ number of unspecified coefficients: the appropriate fitting
++ routine then derives for the coefficients the values which
++ provide the best fit of that particular form. The package deals
++ mainly with curve and surface fitting (i.e., fitting with
++ functions of one and of two variables) when a polynomial or a
++ cubic spline is used as the fitting function, since these cover
++ the most common needs. However, fitting with other functions
++ and/or more variables can be undertaken by means of general
++ linear or nonlinear routines (some of which are contained in
++ other packages) depending on whether the coefficients in the
++ function occur linearly or nonlinearly. Cases where a graph
++ rather than a set of data points is given can be treated simply
++ by first reading a suitable set of points from the graph.
++ The package also contains routines for evaluating,
++ differentiating and integrating polynomial and spline curves and
++ surfaces, once the numerical values of their coefficients have
++ been determined.
++ See \downlink{Manual Page}{manpageXXe02}.


NagFittingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e02adf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02adf(m,kplus1,nrows,x,y,w,ifail)
     ++ computes weighted least-squares polynomial approximations 
     ++ to an arbitrary set of data points.
     ++ See \downlink{Manual Page}{manpageXXe02adf}.
    e02aef : (Integer,Matrix DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e02aef(nplus1,a,xcap,ifail)
     ++ evaluates a polynomial from its Chebyshev-series 
     ++ representation.
     ++ See \downlink{Manual Page}{manpageXXe02aef}.
    e02agf : (Integer,Integer,Integer,DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Matrix Integer,Integer,Integer,Integer) -> Result 
     ++ e02agf(m,kplus1,nrows,xmin,xmax,x,y,w,mf,xf,yf,lyf,ip,lwrk,liwrk,ifail)
     ++ computes constrained weighted least-squares polynomial 
     ++ approximations in Chebyshev-series form to an arbitrary set of 
     ++ data points. The values of the approximations and any number of 
     ++ their derivatives can be specified at selected points.
     ++ See \downlink{Manual Page}{manpageXXe02agf}.
    e02ahf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,Integer,Integer,Integer) -> Result 
     ++ e02ahf(np1,xmin,xmax,a,ia1,la,iadif1,ladif,ifail)
     ++ determines the coefficients in the Chebyshev-series 
     ++ representation of the derivative of a polynomial given in 
     ++ Chebyshev-series form.
     ++ See \downlink{Manual Page}{manpageXXe02ahf}.
    e02ajf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02ajf(np1,xmin,xmax,a,ia1,la,qatm1,iaint1,laint,ifail)
     ++ determines the coefficients in the Chebyshev-series 
     ++ representation of the indefinite integral of a polynomial given 
     ++ in Chebyshev-series form.
     ++ See \downlink{Manual Page}{manpageXXe02ajf}.
    e02akf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,Integer) -> Result 
     ++ e02akf(np1,xmin,xmax,a,ia1,la,x,ifail)
     ++ evaluates a polynomial from its Chebyshev-series 
     ++ representation, allowing an arbitrary index increment for 
     ++ accessing the array of coefficients.
     ++ See \downlink{Manual Page}{manpageXXe02akf}.
    e02baf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02baf(m,ncap7,x,y,w,lamda,ifail)
     ++ computes a weighted least-squares approximation to an 
     ++ arbitrary set of data points by a cubic splines 
     ++ prescribed by the user. Cubic spline can also be 
     ++ carried out.
     ++ See \downlink{Manual Page}{manpageXXe02baf}.
    e02bbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,_
	Integer) -> Result 
     ++ e02bbf(ncap7,lamda,c,x,ifail)
     ++ evaluates a cubic spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bbf}.
    e02bcf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,_
	Integer,Integer) -> Result 
     ++ e02bcf(ncap7,lamda,c,x,left,ifail)
     ++ evaluates a cubic spline and its first three derivatives 
     ++ from its B-spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bcf}.
    e02bdf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02bdf(ncap7,lamda,c,ifail)
     ++ computes the definite integral from its 
     ++ B-spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bdf}.
    e02bef : (String,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix Integer) -> Result 
     ++ e02bef(start,m,x,y,w,s,nest,lwrk,n,lamda,ifail,wrk,iwrk)
     ++ computes a cubic spline approximation to an arbitrary set 
     ++ of data points. The knot are located 
     ++ automatically, but a single parameter must be specified to 
     ++ control the trade-off between closeness of fit and smoothness of 
     ++ fit.
     ++ See \downlink{Manual Page}{manpageXXe02bef}.
    e02daf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix Integer,Integer,Integer,Integer,DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02daf(m,px,py,x,y,f,w,mu,point,npoint,nc,nws,eps,lamda,ifail)
     ++ forms a minimal, weighted least-squares bicubic spline 
     ++ surface fit with prescribed knots to a given set of data points.
     ++ See \downlink{Manual Page}{manpageXXe02daf}.
    e02dcf : (String,Integer,Matrix DoubleFloat,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix Integer,Integer) -> Result 
     ++ e02dcf(start,mx,x,my,y,f,s,nxest,nyest,lwrk,liwrk,nx,lamda,ny,mu,wrk,iwrk,ifail)
     ++ computes a bicubic spline approximation to a set of data 
     ++ values, given on a rectangular grid in the x-y plane. The knots 
     ++ of the spline are located automatically, but a single parameter 
     ++ must be specified to control the trade-off between closeness of 
     ++ fit and smoothness of fit.
     ++ See \downlink{Manual Page}{manpageXXe02dcf}.
    e02ddf : (String,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02ddf(start,m,x,y,f,w,s,nxest,nyest,lwrk,liwrk,nx,lamda,ny,mu,wrk,ifail)
     ++ computes a bicubic spline approximation to a set of 
     ++ scattered data are located 
     ++ automatically, but a single parameter must be specified to 
     ++ control the trade-off between closeness of fit and smoothness of 
     ++ fit.
     ++ See \downlink{Manual Page}{manpageXXe02ddf}.
    e02def : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02def(m,px,py,x,y,lamda,mu,c,ifail)
     ++ calculates values of a bicubic spline 
     ++ representation.
     ++ See \downlink{Manual Page}{manpageXXe02def}.
    e02dff : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02dff(mx,my,px,py,x,y,lamda,mu,c,lwrk,liwrk,ifail)
     ++ calculates values of a bicubic spline 
     ++ representation. The spline is evaluated at all points on a 
     ++ rectangular grid.
     ++ See \downlink{Manual Page}{manpageXXe02dff}.
    e02gaf : (Integer,Integer,Integer,DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02gaf(m,la,nplus2,toler,a,b,ifail)
     ++ calculates an l  solution to an over-determined system of 
     ++                       1                                         
     ++ linear equations.
     ++ See \downlink{Manual Page}{manpageXXe02gaf}.
    e02zaf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02zaf(px,py,lamda,mu,m,x,y,npoint,nadres,ifail)
     ++ sorts two-dimensional data into rectangular panels.
     ++ See \downlink{Manual Page}{manpageXXe02zaf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix Integer)
    import AnyFunctions1(String)


    e02adf(mArg:Integer,kplus1Arg:Integer,nrowsArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02adf",_
	["m"::S,"kplus1"::S,"nrows"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"a"::S,"s"::S_
	,"work1"::S,"work2"::S]$Lisp,_
	["a"::S,"s"::S,"work1"::S,"work2"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,["a"::S,"nrows"::S,"kplus1"::S]$Lisp,["s"::S,"kplus1"::S]$Lisp,["work1"::S,["*"::S,3$Lisp,"m"::S]$Lisp]$Lisp_
	,["work2"::S,["*"::S,2$Lisp,"kplus1"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"kplus1"::S,"nrows"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["a"::S,"s"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kplus1Arg::Any,nrowsArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02aef(nplus1Arg:Integer,aArg:Matrix DoubleFloat,xcapArg:DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02aef",_
	["nplus1"::S,"xcap"::S,"p"::S,"ifail"::S,"a"::S]$Lisp,_
	["p"::S]$Lisp,_
	[["double"::S,["a"::S,"nplus1"::S]$Lisp,"xcap"::S_
	,"p"::S]$Lisp_
	,["integer"::S,"nplus1"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["p"::S,"ifail"::S]$Lisp,_
	[([nplus1Arg::Any,xcapArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02agf(mArg:Integer,kplus1Arg:Integer,nrowsArg:Integer,_
	xminArg:DoubleFloat,xmaxArg:DoubleFloat,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,mfArg:Integer,_
	xfArg:Matrix DoubleFloat,yfArg:Matrix DoubleFloat,lyfArg:Integer,_
	ipArg:Matrix Integer,lwrkArg:Integer,liwrkArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02agf",_
	["m"::S,"kplus1"::S,"nrows"::S,"xmin"::S,"xmax"::S_
	,"mf"::S,"lyf"::S,"lwrk"::S,"liwrk"::S,"np1"::S_
	,"ifail"::S,"x"::S,"y"::S,"w"::S,"xf"::S,"yf"::S_
	,"ip"::S,"a"::S,"s"::S,"wrk"::S,"iwrk"::S_
	]$Lisp,_
	["a"::S,"s"::S,"np1"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["x"::S,"m"::S]$Lisp_
	,["y"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,["xf"::S,"mf"::S]$Lisp,["yf"::S,"lyf"::S]$Lisp,["a"::S,"nrows"::S,"kplus1"::S]$Lisp_
	,["s"::S,"kplus1"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"kplus1"::S,"nrows"::S_
	,"mf"::S,"lyf"::S,["ip"::S,"mf"::S]$Lisp,"lwrk"::S,"liwrk"::S,"np1"::S,"ifail"::S,["iwrk"::S,"liwrk"::S]$Lisp]$Lisp_
	]$Lisp,_
	["a"::S,"s"::S,"np1"::S,"wrk"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kplus1Arg::Any,nrowsArg::Any,xminArg::Any,xmaxArg::Any,mfArg::Any,lyfArg::Any,lwrkArg::Any,liwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,xfArg::Any,yfArg::Any,ipArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ahf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	iadif1Arg:Integer,ladifArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ahf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"iadif1"::S,"ladif"::S,"patm1"::S,"ifail"::S,"a"::S,"adif"::S]$Lisp,_
	["patm1"::S,"adif"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"patm1"::S,["adif"::S,"ladif"::S]$Lisp]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"iadif1"::S_
	,"ladif"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["patm1"::S,"adif"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,iadif1Arg::Any,ladifArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ajf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	qatm1Arg:DoubleFloat,iaint1Arg:Integer,laintArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ajf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"qatm1"::S,"iaint1"::S,"laint"::S,"ifail"::S,"a"::S,"aint"::S]$Lisp,_
	["aint"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"qatm1"::S,["aint"::S,"laint"::S]$Lisp]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"iaint1"::S_
	,"laint"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["aint"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,qatm1Arg::Any,iaint1Arg::Any,laintArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02akf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	xArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02akf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"x"::S,"result"::S,"ifail"::S,"a"::S]$Lisp,_
	["result"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"x"::S,"result"::S]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["result"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,xArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02baf(mArg:Integer,ncap7Arg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,lamdaArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02baf",_
	["m"::S,"ncap7"::S,"ss"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"c"::S,"lamda"::S_
	,"work1"::S,"work2"::S]$Lisp,_
	["c"::S,"ss"::S,"work1"::S,"work2"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,["c"::S,"ncap7"::S]$Lisp,"ss"::S,["lamda"::S,"ncap7"::S]$Lisp,["work1"::S,"m"::S]$Lisp_
	,["work2"::S,["*"::S,4$Lisp,"ncap7"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"ncap7"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["c"::S,"ss"::S,"lamda"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,ncap7Arg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,lamdaArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bbf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	xArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bbf",_
	["ncap7"::S,"x"::S,"s"::S,"ifail"::S,"lamda"::S,"c"::S]$Lisp,_
	["s"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"x"::S,"s"::S]$Lisp_
	,["integer"::S,"ncap7"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["s"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,xArg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bcf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	xArg:DoubleFloat,leftArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bcf",_
	["ncap7"::S,"x"::S,"left"::S,"ifail"::S,"lamda"::S,"c"::S,"s"::S]$Lisp,_
	["s"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"x"::S,["s"::S,4$Lisp]$Lisp]$Lisp_
	,["integer"::S,"ncap7"::S,"left"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["s"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,xArg::Any,leftArg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bdf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bdf",_
	["ncap7"::S,"defint"::S,"ifail"::S,"lamda"::S,"c"::S]$Lisp,_
	["defint"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"defint"::S]$Lisp_
	,["integer"::S,"ncap7"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["defint"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bef(startArg:String,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,sArg:DoubleFloat,_
	nestArg:Integer,lwrkArg:Integer,nArg:Integer,_
	lamdaArg:Matrix DoubleFloat,ifailArg:Integer,wrkArg:Matrix DoubleFloat,_
	iwrkArg:Matrix Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bef",_
	["start"::S,"m"::S,"s"::S,"nest"::S,"lwrk"::S_
	,"fp"::S,"n"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"c"::S,"lamda"::S_
	,"wrk"::S,"iwrk"::S]$Lisp,_
	["c"::S,"fp"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,"s"::S,["c"::S,"nest"::S]$Lisp,"fp"::S,["lamda"::S,"nest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nest"::S,"lwrk"::S,"n"::S_
	,"ifail"::S,["iwrk"::S,"nest"::S]$Lisp]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"n"::S,"lamda"::S,"ifail"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[([startArg::Any,mArg::Any,sArg::Any,nestArg::Any,lwrkArg::Any,nArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,lamdaArg::Any,wrkArg::Any,iwrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02daf(mArg:Integer,pxArg:Integer,pyArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	wArg:Matrix DoubleFloat,muArg:Matrix DoubleFloat,pointArg:Matrix Integer,_
	npointArg:Integer,ncArg:Integer,nwsArg:Integer,_
	epsArg:DoubleFloat,lamdaArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02daf",_
	["m"::S,"px"::S,"py"::S,"npoint"::S,"nc"::S_
	,"nws"::S,"eps"::S,"sigma"::S,"rank"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"w"::S,"mu"::S_
	,"point"::S,"dl"::S,"c"::S,"lamda"::S,"ws"::S_
	]$Lisp,_
	["dl"::S,"c"::S,"sigma"::S,"rank"::S,"ws"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,["mu"::S,"py"::S]$Lisp,"eps"::S,["dl"::S,"nc"::S]$Lisp,["c"::S,"nc"::S]$Lisp_
	,"sigma"::S,["lamda"::S,"px"::S]$Lisp,["ws"::S,"nws"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"px"::S,"py"::S,["point"::S,"npoint"::S]$Lisp_
	,"npoint"::S,"nc"::S,"nws"::S,"rank"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["dl"::S,"c"::S,"sigma"::S,"rank"::S,"lamda"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,npointArg::Any,ncArg::Any,nwsArg::Any,epsArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,wArg::Any,muArg::Any,pointArg::Any,lamdaArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02dcf(startArg:String,mxArg:Integer,xArg:Matrix DoubleFloat,_
	myArg:Integer,yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	sArg:DoubleFloat,nxestArg:Integer,nyestArg:Integer,_
	lwrkArg:Integer,liwrkArg:Integer,nxArg:Integer,_
	lamdaArg:Matrix DoubleFloat,nyArg:Integer,muArg:Matrix DoubleFloat,_
	wrkArg:Matrix DoubleFloat,iwrkArg:Matrix Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02dcf",_
	["start"::S,"mx"::S,"my"::S,"s"::S,"nxest"::S_
	,"nyest"::S,"lwrk"::S,"liwrk"::S,"fp"::S,"nx"::S_
	,"ny"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"c"::S,"lamda"::S_
	,"mu"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["c"::S,"fp"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["f"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,"s"::S,["c"::S,["*"::S,["-"::S,"nxest"::S,4$Lisp]$Lisp,["-"::S,"nyest"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,"fp"::S,["lamda"::S,"nxest"::S]$Lisp,["mu"::S,"nyest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"nx"::S,"ny"::S,["iwrk"::S,"liwrk"::S]$Lisp,"ifail"::S]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"nx"::S,"lamda"::S,"ny"::S,"mu"::S,"wrk"::S,"iwrk"::S,"ifail"::S]$Lisp,_
	[([startArg::Any,mxArg::Any,myArg::Any,sArg::Any,nxestArg::Any,nyestArg::Any,lwrkArg::Any,liwrkArg::Any,nxArg::Any,nyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,lamdaArg::Any,muArg::Any,wrkArg::Any,iwrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ddf(startArg:String,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,_
	sArg:DoubleFloat,nxestArg:Integer,nyestArg:Integer,_
	lwrkArg:Integer,liwrkArg:Integer,nxArg:Integer,_
	lamdaArg:Matrix DoubleFloat,nyArg:Integer,muArg:Matrix DoubleFloat,_
	wrkArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ddf",_
	["start"::S,"m"::S,"s"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"fp"::S,"rank"::S,"nx"::S_
	,"ny"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"w"::S,"c"::S_
	,"iwrk"::S,"lamda"::S,"mu"::S,"wrk"::S]$Lisp,_
	["c"::S,"fp"::S,"rank"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,"s"::S,["c"::S,["*"::S,["-"::S,"nxest"::S,4$Lisp]$Lisp,["-"::S,"nyest"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,"fp"::S,["lamda"::S,"nxest"::S]$Lisp,["mu"::S,"nyest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"rank"::S,["iwrk"::S,"liwrk"::S]$Lisp,"nx"::S,"ny"::S,"ifail"::S]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"rank"::S,"iwrk"::S,"nx"::S,"lamda"::S,"ny"::S,"mu"::S,"wrk"::S,"ifail"::S]$Lisp,_
	[([startArg::Any,mArg::Any,sArg::Any,nxestArg::Any,nyestArg::Any,lwrkArg::Any,liwrkArg::Any,nxArg::Any,nyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,wArg::Any,lamdaArg::Any,muArg::Any,wrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02def(mArg:Integer,pxArg:Integer,pyArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,lamdaArg:Matrix DoubleFloat,_
	muArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02def",_
	["m"::S,"px"::S,"py"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"mu"::S,"c"::S_
	,"ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp,["c"::S,["*"::S,["-"::S,"px"::S,4$Lisp]$Lisp,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["ff"::S,"m"::S]$Lisp,["wrk"::S,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"px"::S,"py"::S,"ifail"::S_
	,["iwrk"::S,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	]$Lisp,_
	["ff"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,lamdaArg::Any,muArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02dff(mxArg:Integer,myArg:Integer,pxArg:Integer,_
	pyArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	lamdaArg:Matrix DoubleFloat,muArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	lwrkArg:Integer,liwrkArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02dff",_
	["mx"::S,"my"::S,"px"::S,"py"::S,"lwrk"::S_
	,"liwrk"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"mu"::S,"c"::S_
	,"ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp,["c"::S,["*"::S,["-"::S,"px"::S,4$Lisp]$Lisp,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["ff"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"px"::S,"py"::S_
	,"lwrk"::S,"liwrk"::S,"ifail"::S,["iwrk"::S,"liwrk"::S]$Lisp]$Lisp_
	]$Lisp,_
	["ff"::S,"ifail"::S]$Lisp,_
	[([mxArg::Any,myArg::Any,pxArg::Any,pyArg::Any,lwrkArg::Any,liwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any,lamdaArg::Any,muArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02gaf(mArg:Integer,laArg:Integer,nplus2Arg:Integer,_
	tolerArg:DoubleFloat,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02gaf",_
	["m"::S,"la"::S,"nplus2"::S,"toler"::S,"resid"::S_
	,"irank"::S,"iter"::S,"ifail"::S,"x"::S,"a"::S,"b"::S,"iwork"::S]$Lisp,_
	["x"::S,"resid"::S,"irank"::S,"iter"::S,"iwork"::S]$Lisp,_
	[["double"::S,"toler"::S,["x"::S,"nplus2"::S]$Lisp_
	,"resid"::S,["a"::S,"la"::S,"nplus2"::S]$Lisp,["b"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"la"::S,"nplus2"::S,"irank"::S_
	,"iter"::S,"ifail"::S,["iwork"::S,"m"::S]$Lisp]$Lisp_
	]$Lisp,_
	["x"::S,"resid"::S,"irank"::S,"iter"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,laArg::Any,nplus2Arg::Any,tolerArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02zaf(pxArg:Integer,pyArg:Integer,lamdaArg:Matrix DoubleFloat,_
	muArg:Matrix DoubleFloat,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,npointArg:Integer,nadresArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02zaf",_
	["px"::S,"py"::S,"m"::S,"npoint"::S,"nadres"::S_
	,"ifail"::S,"lamda"::S,"mu"::S,"x"::S,"y"::S,"point"::S_
	,"adres"::S]$Lisp,_
	["point"::S,"adres"::S]$Lisp,_
	[["double"::S,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp_
	,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"px"::S,"py"::S,"m"::S,"npoint"::S_
	,"nadres"::S,["point"::S,"npoint"::S]$Lisp,"ifail"::S,["adres"::S,"nadres"::S]$Lisp]$Lisp_
	]$Lisp,_
	["point"::S,"ifail"::S]$Lisp,_
	[([pxArg::Any,pyArg::Any,mArg::Any,npointArg::Any,nadresArg::Any,ifailArg::Any,lamdaArg::Any,muArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE02.dotabb>>=
"NAGE02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE02"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE02" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD01 NagIntegrationPackage}
\pagehead{NagIntegrationPackage}{NAGD01}
\pagepic{ps/v104nagintegrationpackage.ps}{NAGD01}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD01 NagIntegrationPackage>>=
)abbrev package NAGD01 NagIntegrationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:37 1994
++ Description:
++ This package uses the NAG Library to calculate the numerical value of
++ definite integrals in one or more dimensions and to evaluate
++ weights and abscissae of integration rules.
++ See \downlink{Manual Page}{manpageXXd01}.

NagIntegrationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d01ajf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01ajf(a,b,epsabs,epsrel,lw,liw,ifail,f)
     ++ is a general-purpose integrator which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01ajf}.
    d01akf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01akf(a,b,epsabs,epsrel,lw,liw,ifail,f)
     ++ is an adaptive integrator, especially suited to 
     ++ oscillating, non-singular integrands, which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01akf}.
    d01alf : (DoubleFloat,DoubleFloat,Integer,Matrix DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01alf(a,b,npts,points,epsabs,epsrel,lw,liw,ifail,f)
     ++ is a general purpose integrator which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01alf}.
    d01amf : (DoubleFloat,Integer,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01amf(bound,inf,epsabs,epsrel,lw,liw,ifail,f)
     ++ calculates an approximation to the integral of a function 
     ++ f(x) over an infinite or semi-infinite interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01amf}.
    d01anf : (DoubleFloat,DoubleFloat,DoubleFloat,Integer,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01anf(a,b,omega,key,epsabs,epsrel,lw,liw,ifail,g)
     ++ calculates an approximation to the sine or the cosine 
     ++ transform of a function g over [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01anf}.
    d01apf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01apf(a,b,alfa,beta,key,epsabs,epsrel,lw,liw,ifail,g)
     ++ is an adaptive integrator which calculates an 
     ++ approximation to the integral of a function g(x)w(x) over a 
     ++ finite interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01apf}.
    d01aqf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01aqf(a,b,c,epsabs,epsrel,lw,liw,ifail,g)
     ++ calculates an approximation to the Hilbert transform of a 
     ++ function g(x) over [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01aqf}.
    d01asf : (DoubleFloat,DoubleFloat,Integer,DoubleFloat,_
	Integer,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01asf(a,omega,key,epsabs,limlst,lw,liw,ifail,g)
     ++ calculates an approximation to the sine or the cosine 
     ++ transform of a function g over [a,infty):
     ++ See \downlink{Manual Page}{manpageXXd01asf}.
    d01bbf : (DoubleFloat,DoubleFloat,Integer,Integer,_
	Integer,Integer) -> Result 
     ++ d01bbf(a,b,itype,n,gtype,ifail)
     ++ returns the weight appropriate to a 
     ++ Gaussian quadrature.
     ++ The formulae provided are Gauss-Legendre, Gauss-Rational, Gauss-
     ++ Laguerre and Gauss-Hermite.
     ++ See \downlink{Manual Page}{manpageXXd01bbf}.
    d01fcf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp4(FUNCTN))) -> Result 
     ++ d01fcf(ndim,a,b,maxpts,eps,lenwrk,minpts,ifail,functn)
     ++ attempts to evaluate a multi-dimensional integral (up to 
     ++ 15 dimensions), with constant and finite limits, to a specified 
     ++ relative accuracy, using an adaptive subdivision strategy.
     ++ See \downlink{Manual Page}{manpageXXd01fcf}.
    d01gaf : (Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer) -> Result 
     ++ d01gaf(x,y,n,ifail)
     ++ integrates a function which is specified numerically at 
     ++ four or more points, over the whole of its specified range, using
     ++ third-order finite-difference formulae with error estimates, 
     ++ according to a method due to Gill and Miller.
     ++ See \downlink{Manual Page}{manpageXXd01gaf}.
    d01gbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	DoubleFloat,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp4(FUNCTN))) -> Result 
     ++ d01gbf(ndim,a,b,maxcls,eps,lenwrk,mincls,wrkstr,ifail,functn)
     ++ returns an approximation to the integral of a function 
     ++ over a hyper-rectangular region, using a Monte Carlo method. An 
     ++ approximate relative error estimate is also returned. This 
     ++ routine is suitable for low accuracy work.
     ++ See \downlink{Manual Page}{manpageXXd01gbf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp1(F))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)


    d01ajf(aArg:DoubleFloat,bArg:DoubleFloat,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01ajf",_
	["a"::S,"b"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01akf(aArg:DoubleFloat,bArg:DoubleFloat,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01akf",_
	["a"::S,"b"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01alf(aArg:DoubleFloat,bArg:DoubleFloat,nptsArg:Integer,_
	pointsArg:Matrix DoubleFloat,epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,_
	lwArg:Integer,liwArg:Integer,ifailArg:Integer,_
	fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01alf",_
	["a"::S,"b"::S,"npts"::S,"epsabs"::S,"epsrel"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"ifail"::S_
	,"f"::S,"points"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,["points"::S,"*"::S]$Lisp_
	,"epsabs"::S,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"npts"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,nptsArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any,pointsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01amf(boundArg:DoubleFloat,infArg:Integer,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01amf",_
	["bound"::S,"inf"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"bound"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"inf"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([boundArg::Any,infArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01anf(aArg:DoubleFloat,bArg:DoubleFloat,omegaArg:DoubleFloat,_
	keyArg:Integer,epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,_
	lwArg:Integer,liwArg:Integer,ifailArg:Integer,_
	gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01anf",_
	["a"::S,"b"::S,"omega"::S,"key"::S,"epsabs"::S_
	,"epsrel"::S,"lw"::S,"liw"::S,"result"::S,"abserr"::S_
	,"ifail"::S,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"omega"::S,"epsabs"::S_
	,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,omegaArg::Any,keyArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01apf(aArg:DoubleFloat,bArg:DoubleFloat,alfaArg:DoubleFloat,_
	betaArg:DoubleFloat,keyArg:Integer,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01apf",_
	["a"::S,"b"::S,"alfa"::S,"beta"::S,"key"::S_
	,"epsabs"::S,"epsrel"::S,"lw"::S,"liw"::S,"result"::S_
	,"abserr"::S,"ifail"::S,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"alfa"::S,"beta"::S_
	,"epsabs"::S,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,alfaArg::Any,betaArg::Any,keyArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01aqf(aArg:DoubleFloat,bArg:DoubleFloat,cArg:DoubleFloat,_
	epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,lwArg:Integer,_
	liwArg:Integer,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01aqf",_
	["a"::S,"b"::S,"c"::S,"epsabs"::S,"epsrel"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"ifail"::S_
	,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"c"::S,"epsabs"::S_
	,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,cArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01asf(aArg:DoubleFloat,omegaArg:DoubleFloat,keyArg:Integer,_
	epsabsArg:DoubleFloat,limlstArg:Integer,lwArg:Integer,_
	liwArg:Integer,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01asf",_
	["a"::S,"omega"::S,"key"::S,"epsabs"::S,"limlst"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"lst"::S_
	,"ifail"::S,"g"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"w"::S_
	]$Lisp,_
	["result"::S,"abserr"::S,"lst"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"w"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"omega"::S,"epsabs"::S_
	,"result"::S,"abserr"::S,["erlst"::S,"limlst"::S]$Lisp,["rslst"::S,"limlst"::S]$Lisp,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"limlst"::S,"lw"::S_
	,"liw"::S,"lst"::S,["ierlst"::S,"limlst"::S]$Lisp,["iw"::S,"liw"::S]$Lisp,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"lst"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,omegaArg::Any,keyArg::Any,epsabsArg::Any,limlstArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01bbf(aArg:DoubleFloat,bArg:DoubleFloat,itypeArg:Integer,_
	nArg:Integer,gtypeArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d01bbf",_
	["a"::S,"b"::S,"itype"::S,"n"::S,"gtype"::S_
	,"ifail"::S,"weight"::S,"abscis"::S]$Lisp,_
	["weight"::S,"abscis"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,["weight"::S,"n"::S]$Lisp_
	,["abscis"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"itype"::S,"n"::S,"gtype"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["weight"::S,"abscis"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,itypeArg::Any,nArg::Any,gtypeArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01fcf(ndimArg:Integer,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	maxptsArg:Integer,epsArg:DoubleFloat,lenwrkArg:Integer,_
	minptsArg:Integer,ifailArg:Integer,functnArg:Union(fn:FileName,fp:Asp4(FUNCTN))): Result == 
	pushFortranOutputStack(functnFilename := aspFilename "functn")$FOP
	if functnArg case fn
		  then outputAsFortran(functnArg.fn)
		  else outputAsFortran(functnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([functnFilename]$Lisp,_
	"d01fcf",_
	["ndim"::S,"maxpts"::S,"eps"::S,"lenwrk"::S,"acc"::S_
	,"finval"::S,"minpts"::S,"ifail"::S,"functn"::S,"a"::S,"b"::S,"wrkstr"::S]$Lisp,_
	["acc"::S,"finval"::S,"wrkstr"::S,"functn"::S]$Lisp,_
	[["double"::S,["a"::S,"ndim"::S]$Lisp,["b"::S,"ndim"::S]$Lisp_
	,"eps"::S,"acc"::S,"finval"::S,["wrkstr"::S,"lenwrk"::S]$Lisp,"functn"::S]$Lisp_
	,["integer"::S,"ndim"::S,"maxpts"::S,"lenwrk"::S_
	,"minpts"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["acc"::S,"finval"::S,"minpts"::S,"ifail"::S]$Lisp,_
	[([ndimArg::Any,maxptsArg::Any,epsArg::Any,lenwrkArg::Any,minptsArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01gaf(xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,nArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d01gaf",_
	["n"::S,"ans"::S,"er"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	["ans"::S,"er"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	,"ans"::S,"er"::S]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["ans"::S,"er"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01gbf(ndimArg:Integer,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	maxclsArg:Integer,epsArg:DoubleFloat,lenwrkArg:Integer,_
	minclsArg:Integer,wrkstrArg:Matrix DoubleFloat,ifailArg:Integer,_
	functnArg:Union(fn:FileName,fp:Asp4(FUNCTN))): Result == 
	pushFortranOutputStack(functnFilename := aspFilename "functn")$FOP
	if functnArg case fn
		  then outputAsFortran(functnArg.fn)
		  else outputAsFortran(functnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([functnFilename]$Lisp,_
	"d01gbf",_
	["ndim"::S,"maxcls"::S,"eps"::S,"lenwrk"::S,"acc"::S_
	,"finest"::S,"mincls"::S,"ifail"::S,"functn"::S,"a"::S,"b"::S,"wrkstr"::S]$Lisp,_
	["acc"::S,"finest"::S,"functn"::S]$Lisp,_
	[["double"::S,["a"::S,"ndim"::S]$Lisp,["b"::S,"ndim"::S]$Lisp_
	,"eps"::S,"acc"::S,"finest"::S,["wrkstr"::S,"lenwrk"::S]$Lisp,"functn"::S]$Lisp_
	,["integer"::S,"ndim"::S,"maxcls"::S,"lenwrk"::S_
	,"mincls"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["acc"::S,"finest"::S,"mincls"::S,"wrkstr"::S,"ifail"::S]$Lisp,_
	[([ndimArg::Any,maxclsArg::Any,epsArg::Any,lenwrkArg::Any,minclsArg::Any,ifailArg::Any,aArg::Any,bArg::Any,wrkstrArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD01.dotabb>>=
"NAGD01" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD01"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD01" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE01 NagInterpolationPackage}
\pagehead{NagInterpolationPackage}{NAGE01}
\pagepic{ps/v104naginterpolationpackage.ps}{NAGE01}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE01 NagInterpolationPackage>>=
)abbrev package NAGE01 NagInterpolationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:53 1994
++ Description:
++ This package uses the NAG Library to calculate the interpolation of a 
++ function of one or two variables. When provided with the value of the
++ function (and possibly one or more of its lowest-order
++ derivatives) at each of a number of values of the variable(s),
++ the routines provide either an interpolating function or an
++ interpolated value. For some of the interpolating functions,
++ there are supporting routines to evaluate, differentiate or
++ integrate them.
++ See \downlink{Manual Page}{manpageXXe01}.


NagInterpolationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e01baf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	Integer,Integer) -> Result 
     ++ e01baf(m,x,y,lck,lwrk,ifail)
     ++ determines a cubic spline to a given set of 
     ++ data.
     ++ See \downlink{Manual Page}{manpageXXe01baf}.
    e01bef : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bef(n,x,f,ifail)
     ++ computes a monotonicity-preserving piecewise cubic Hermite
     ++ interpolant to a set of data points.
     ++ See \downlink{Manual Page}{manpageXXe01bef}.
    e01bff : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bff(n,x,f,d,m,px,ifail)
     ++ evaluates a piecewise cubic Hermite interpolant at a set 
     ++ of points.
     ++ See \downlink{Manual Page}{manpageXXe01bff}.
    e01bgf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bgf(n,x,f,d,m,px,ifail)
     ++ evaluates a piecewise cubic Hermite interpolant and its 
     ++ first derivative at a set of points.
     ++ See \downlink{Manual Page}{manpageXXe01bgf}.
    e01bhf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01bhf(n,x,f,d,a,b,ifail)
     ++ evaluates the definite integral of a piecewise cubic 
     ++ Hermite interpolant over the interval [a,b].
     ++ See \downlink{Manual Page}{manpageXXe01bhf}.
    e01daf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ e01daf(mx,my,x,y,f,ifail)
     ++ computes a bicubic spline interpolating surface through a 
     ++ set of data values, given on a rectangular grid in the x-y plane.
     ++ See \downlink{Manual Page}{manpageXXe01daf}.
    e01saf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ e01saf(m,x,y,f,ifail)
     ++ generates a two-dimensional surface interpolating a set of
     ++ scattered data points, using the method of Renka and Cline.
     ++ See \downlink{Manual Page}{manpageXXe01saf}.
    e01sbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix Integer,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sbf(m,x,y,f,triang,grads,px,py,ifail)
     ++ evaluates at a given point the two-dimensional interpolant
     ++ function computed by E01SAF.
     ++ See \downlink{Manual Page}{manpageXXe01sbf}.
    e01sef : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sef(m,x,y,f,nw,nq,rnw,rnq,ifail)
     ++ generates a two-dimensional surface interpolating a set of
     ++ scattered data points, using a modified Shepard method.
     ++ See \downlink{Manual Page}{manpageXXe01sef}.
    e01sff : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sff(m,x,y,f,rnw,fnodes,px,py,ifail)
     ++ evaluates at a given point the two-dimensional 
     ++ interpolating function computed by E01SEF.
     ++ See \downlink{Manual Page}{manpageXXe01sff}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Integer)
    import AnyFunctions1(DoubleFloat)


    e01baf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	lckArg:Integer,lwrkArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01baf",_
	["m"::S,"lck"::S,"lwrk"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"c"::S,"wrk"::S_
	]$Lisp,_
	["lamda"::S,"c"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["lamda"::S,"lck"::S]$Lisp,["c"::S,"lck"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"lck"::S,"lwrk"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["lamda"::S,"c"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,lckArg::Any,lwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bef(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bef",_
	["n"::S,"ifail"::S,"x"::S,"f"::S,"d"::S]$Lisp,_
	["d"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["d"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bff(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,mArg:Integer,pxArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bff",_
	["n"::S,"m"::S,"ifail"::S,"x"::S,"f"::S,"d"::S,"px"::S,"pf"::S_
	]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,["px"::S,"m"::S]$Lisp,["pf"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any,pxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bgf(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,mArg:Integer,pxArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bgf",_
	["n"::S,"m"::S,"ifail"::S,"x"::S,"f"::S,"d"::S,"px"::S,"pf"::S_
	,"pd"::S]$Lisp,_
	["pf"::S,"pd"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,["px"::S,"m"::S]$Lisp,["pf"::S,"m"::S]$Lisp,["pd"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"pd"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any,pxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bhf(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,aArg:DoubleFloat,bArg:DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bhf",_
	["n"::S,"a"::S,"b"::S,"pint"::S,"ifail"::S_
	,"x"::S,"f"::S,"d"::S]$Lisp,_
	["pint"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,"a"::S,"b"::S,"pint"::S]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pint"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,aArg::Any,bArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01daf(mxArg:Integer,myArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01daf",_
	["mx"::S,"my"::S,"px"::S,"py"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"lamda"::S,"mu"::S_
	,"c"::S,"wrk"::S]$Lisp,_
	["px"::S,"py"::S,"lamda"::S,"mu"::S,"c"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["f"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["lamda"::S,["+"::S,"mx"::S,4$Lisp]$Lisp]$Lisp,["mu"::S,["+"::S,"mx"::S,4$Lisp]$Lisp]$Lisp_
	,["c"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["wrk"::S,["*"::S,["+"::S,"mx"::S,6$Lisp]$Lisp,["+"::S,"my"::S,6$Lisp]$Lisp]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"px"::S,"py"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["px"::S,"py"::S,"lamda"::S,"mu"::S,"c"::S,"ifail"::S]$Lisp,_
	[([mxArg::Any,myArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01saf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01saf",_
	["m"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"triang"::S,"grads"::S_
	]$Lisp,_
	["triang"::S,"grads"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["grads"::S,2$Lisp,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,["triang"::S,["*"::S,7$Lisp,"m"::S]$Lisp]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["triang"::S,"grads"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sbf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,triangArg:Matrix Integer,gradsArg:Matrix DoubleFloat,_
	pxArg:DoubleFloat,pyArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sbf",_
	["m"::S,"px"::S,"py"::S,"pf"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"triang"::S,"grads"::S_
	]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["grads"::S,2$Lisp,"m"::S]$Lisp,"px"::S,"py"::S,"pf"::S]$Lisp_
	,["integer"::S,"m"::S,["triang"::S,["*"::S,7$Lisp,"m"::S]$Lisp]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,triangArg::Any,gradsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sef(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,nwArg:Integer,nqArg:Integer,_
	rnwArg:DoubleFloat,rnqArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sef",_
	["m"::S,"nw"::S,"nq"::S,"minnq"::S,"rnw"::S_
	,"rnq"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"fnodes"::S,"wrk"::S_
	]$Lisp,_
	["fnodes"::S,"minnq"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["fnodes"::S,["*"::S,5$Lisp,"m"::S]$Lisp]$Lisp,"rnw"::S,"rnq"::S,["wrk"::S,["*"::S,6$Lisp,"m"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nw"::S,"nq"::S,"minnq"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["fnodes"::S,"minnq"::S,"rnw"::S,"rnq"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nwArg::Any,nqArg::Any,rnwArg::Any,rnqArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sff(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,rnwArg:DoubleFloat,fnodesArg:Matrix DoubleFloat,_
	pxArg:DoubleFloat,pyArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sff",_
	["m"::S,"rnw"::S,"px"::S,"py"::S,"pf"::S_
	,"ifail"::S,"x"::S,"y"::S,"f"::S,"fnodes"::S]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,"rnw"::S,["fnodes"::S,["*"::S,5$Lisp,"m"::S]$Lisp]$Lisp,"px"::S,"py"::S,"pf"::S]$Lisp_
	,["integer"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,rnwArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,fnodesArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE01.dotabb>>=
"NAGE01" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE01"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE01" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE04 NagOptimisationPackage}
\pagehead{NagOptimisationPackage}{NAGE04}
\pagepic{ps/v104nagoptimisationpackage.ps}{NAGE04}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE04 NagOptimisationPackage>>=
)abbrev package NAGE04 NagOptimisationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:09 1994
++ Description:
++ This package uses the NAG Library to perform optimization.
++ An optimization problem involves minimizing a function (called
++ the objective function) of several variables, possibly subject to
++ restrictions on the values of the variables defined by a set of
++ constraint functions. The routines in the NAG Foundation Library
++ are concerned with function minimization only, since the problem
++ of maximizing a given function can be transformed into a
++ minimization problem simply by multiplying the function by -1.
++ See \downlink{Manual Page}{manpageXXe04}.
NagOptimisationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e04dgf : (Integer,DoubleFloat,DoubleFloat,Integer,_
	DoubleFloat,Boolean,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp49(OBJFUN))) -> Result 
     ++ e04dgf(n,es,fu,it,lin,list,ma,op,pr,sta,sto,ve,x,ifail,objfun)
     ++ minimizes an unconstrained nonlinear function of several 
     ++ variables using a pre-conditioned, limited memory quasi-Newton 
     ++ conjugate gradient method. First derivatives are required. The 
     ++ routine is intended for use on large scale problems.
     ++ See \downlink{Manual Page}{manpageXXe04dgf}.
    e04fdf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp50(LSFUN1))) -> Result 
     ++ e04fdf(m,n,liw,lw,x,ifail,lsfun1)
     ++ is an easy-to-use algorithm for finding an unconstrained 
     ++ minimum of a sum of squares of m nonlinear functions in n 
     ++ variables (m>=n). No derivatives are required.
     ++ See \downlink{Manual Page}{manpageXXe04fdf}.
    e04gcf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp19(LSFUN2))) -> Result 
     ++ e04gcf(m,n,liw,lw,x,ifail,lsfun2)
     ++ is an easy-to-use quasi-Newton algorithm for finding an 
     ++ unconstrained minimum of m nonlinear 
     ++ functions in n variables (m>=n). First derivatives are required.
     ++ See \downlink{Manual Page}{manpageXXe04gcf}.
    e04jaf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp24(FUNCT1))) -> Result 
     ++ e04jaf(n,ibound,liw,lw,bl,bu,x,ifail,funct1)
     ++ is an easy-to-use quasi-Newton algorithm for finding a 
     ++ minimum of a function F(x ,x ,...,x ), subject to fixed upper and
     ++                          1  2      n                          
     ++ lower bounds of the independent variables x ,x ,...,x , using 
     ++                                            1  2      n       
     ++ function values only.
     ++ See \downlink{Manual Page}{manpageXXe04jaf}.
    e04mbf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Boolean,Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e04mbf(itmax,msglvl,n,nclin,nctotl,nrowa,a,bl,bu,cvec,linobj,liwork,lwork,x,ifail)
     ++ is an easy-to-use routine for solving linear programming 
     ++ problems, or for finding a feasible point for such problems. It 
     ++ is not intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04mbf}.
    e04naf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Integer,Integer,DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Boolean,Boolean,Boolean,Integer,Integer,Matrix DoubleFloat,Matrix Integer,Integer,Union(fn:FileName,fp:Asp20(QPHESS))) -> Result 
     ++ e04naf(itmax,msglvl,n,nclin,nctotl,nrowa,nrowh,ncolh,bigbnd,a,bl,bu,cvec,featol,hess,cold,lpp,orthog,liwork,lwork,x,istate,ifail,qphess)
     ++ is a comprehensive 
     ++ programming (QP) or linear programming (LP) problems. It is not 
     ++ intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04naf}.
    e04ucf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Boolean,DoubleFloat,Integer,DoubleFloat,DoubleFloat,Boolean,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Boolean,Integer,Integer,Integer,Integer,Integer,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp55(CONFUN)),Union(fn:FileName,fp:Asp49(OBJFUN))) -> Result 
     ++ e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,liwork,lwork,sta,cra,der,fea,fun,hes,infb,infs,linf,lint,list,maji,majp,mini,minp,mon,nonf,opt,ste,stao,stac,stoo,stoc,ve,istate,cjac,clamda,r,x,ifail,confun,objfun)
     ++ is designed to minimize an arbitrary smooth function 
     ++ subject to constraints on the 
     ++ variables, linear constraints.  
     ++ (E04UCF  may be used for unconstrained, bound-constrained and 
     ++ linearly constrained optimization.) The user must provide 
     ++ subroutines that define the objective and constraint functions 
     ++ and as many of their first partial derivatives as possible. 
     ++ Unspecified derivatives are approximated by finite differences. 
     ++ All matrices are treated as dense, and hence E04UCF is not 
     ++ intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04ucf}.
    e04ycf : (Integer,Integer,Integer,DoubleFloat,_
	Matrix DoubleFloat,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e04ycf(job,m,n,fsumsq,s,lv,v,ifail)
     ++ returns estimates of elements of the variance 
     ++ matrix of the estimated regression coefficients for a nonlinear 
     ++ least squares problem. The estimates are derived from the 
     ++ Jacobian of the function f(x) at the solution.
     ++ See \downlink{Manual Page}{manpageXXe04ycf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp49(OBJFUN))
    import AnyFunctions1(Integer)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Boolean)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Integer)


    e04dgf(nArg:Integer,esArg:DoubleFloat,fuArg:DoubleFloat,_
	itArg:Integer,linArg:DoubleFloat,listArg:Boolean,_
	maArg:DoubleFloat,opArg:DoubleFloat,prArg:Integer,_
	staArg:Integer,stoArg:Integer,veArg:Integer,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,objfunArg:Union(fn:FileName,fp:Asp49(OBJFUN))): Result == 
	pushFortranOutputStack(objfunFilename := aspFilename "objfun")$FOP
	if objfunArg case fn
		  then outputAsFortran(objfunArg.fn)
		  else outputAsFortran(objfunArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([objfunFilename]$Lisp,_
	"e04dgf",_
	["n"::S,"es"::S,"fu"::S,"it"::S,"lin"::S_
	,"list"::S,"ma"::S,"op"::S,"pr"::S,"sta"::S_
	,"sto"::S,"ve"::S,"iter"::S,"objf"::S,"ifail"::S_
	,"objfun"::S,"objgrd"::S,"x"::S,"iwork"::S,"work"::S,"iuser"::S_
	,"user"::S]$Lisp,_
	["iter"::S,"objf"::S,"objgrd"::S,"iwork"::S,"work"::S,"iuser"::S,"user"::S,"objfun"::S]$Lisp,_
	[["double"::S,"es"::S,"fu"::S,"lin"::S,"ma"::S_
	,"op"::S,"objf"::S,["objgrd"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,["*"::S,13$Lisp,"n"::S]$Lisp]$Lisp,["user"::S,"*"::S]$Lisp_
	,"objfun"::S]$Lisp_
	,["integer"::S,"n"::S,"it"::S,"pr"::S,"sta"::S_
	,"sto"::S,"ve"::S,"iter"::S,"ifail"::S,["iwork"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,["iuser"::S,"*"::S]$Lisp]$Lisp_
	,["logical"::S,"list"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"objf"::S,"objgrd"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,esArg::Any,fuArg::Any,itArg::Any,linArg::Any,listArg::Any,maArg::Any,opArg::Any,prArg::Any,staArg::Any,stoArg::Any,veArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04fdf(mArg:Integer,nArg:Integer,liwArg:Integer,_
	lwArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	lsfun1Arg:Union(fn:FileName,fp:Asp50(LSFUN1))): Result == 
	pushFortranOutputStack(lsfun1Filename := aspFilename "lsfun1")$FOP
	if lsfun1Arg case fn
		  then outputAsFortran(lsfun1Arg.fn)
		  else outputAsFortran(lsfun1Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([lsfun1Filename]$Lisp,_
	"e04fdf",_
	["m"::S,"n"::S,"liw"::S,"lw"::S,"fsumsq"::S_
	,"ifail"::S,"lsfun1"::S,"w"::S,"x"::S,"iw"::S]$Lisp,_
	["fsumsq"::S,"w"::S,"iw"::S,"lsfun1"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["w"::S,"lw"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"lsfun1"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"liw"::S,"lw"::S_
	,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["fsumsq"::S,"w"::S,"x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04gcf(mArg:Integer,nArg:Integer,liwArg:Integer,_
	lwArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	lsfun2Arg:Union(fn:FileName,fp:Asp19(LSFUN2))): Result == 
	pushFortranOutputStack(lsfun2Filename := aspFilename "lsfun2")$FOP
	if lsfun2Arg case fn
		  then outputAsFortran(lsfun2Arg.fn)
		  else outputAsFortran(lsfun2Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([lsfun2Filename]$Lisp,_
	"e04gcf",_
	["m"::S,"n"::S,"liw"::S,"lw"::S,"fsumsq"::S_
	,"ifail"::S,"lsfun2"::S,"w"::S,"x"::S,"iw"::S]$Lisp,_
	["fsumsq"::S,"w"::S,"iw"::S,"lsfun2"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["w"::S,"lw"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"lsfun2"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"liw"::S,"lw"::S_
	,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["fsumsq"::S,"w"::S,"x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04jaf(nArg:Integer,iboundArg:Integer,liwArg:Integer,_
	lwArg:Integer,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,funct1Arg:Union(fn:FileName,fp:Asp24(FUNCT1))): Result == 
	pushFortranOutputStack(funct1Filename := aspFilename "funct1")$FOP
	if funct1Arg case fn
		  then outputAsFortran(funct1Arg.fn)
		  else outputAsFortran(funct1Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([funct1Filename]$Lisp,_
	"e04jaf",_
	["n"::S,"ibound"::S,"liw"::S,"lw"::S,"f"::S_
	,"ifail"::S,"funct1"::S,"bl"::S,"bu"::S,"x"::S,"iw"::S,"w"::S_
	]$Lisp,_
	["f"::S,"iw"::S,"w"::S,"funct1"::S]$Lisp,_
	[["double"::S,"f"::S,["bl"::S,"n"::S]$Lisp_
	,["bu"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["w"::S,"lw"::S]$Lisp,"funct1"::S]$Lisp_
	,["integer"::S,"n"::S,"ibound"::S,"liw"::S_
	,"lw"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["f"::S,"bl"::S,"bu"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,iboundArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,blArg::Any,buArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04mbf(itmaxArg:Integer,msglvlArg:Integer,nArg:Integer,_
	nclinArg:Integer,nctotlArg:Integer,nrowaArg:Integer,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	cvecArg:Matrix DoubleFloat,linobjArg:Boolean,liworkArg:Integer,_
	lworkArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e04mbf",_
	["itmax"::S,"msglvl"::S,"n"::S,"nclin"::S,"nctotl"::S_
	,"nrowa"::S,"linobj"::S,"liwork"::S,"lwork"::S,"objlp"::S_
	,"ifail"::S,"a"::S,"bl"::S,"bu"::S,"cvec"::S,"istate"::S_
	,"clamda"::S,"x"::S,"iwork"::S,"work"::S]$Lisp,_
	["istate"::S,"objlp"::S,"clamda"::S,"iwork"::S,"work"::S]$Lisp,_
	[["double"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,"nctotl"::S]$Lisp,["bu"::S,"nctotl"::S]$Lisp,["cvec"::S,"n"::S]$Lisp,"objlp"::S,["clamda"::S,"nctotl"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp]$Lisp_
	,["integer"::S,"itmax"::S,"msglvl"::S,"n"::S_
	,"nclin"::S,"nctotl"::S,"nrowa"::S,"liwork"::S,"lwork"::S,["istate"::S,"nctotl"::S]$Lisp,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp_
	]$Lisp_
	,["logical"::S,"linobj"::S]$Lisp_
	]$Lisp,_
	["istate"::S,"objlp"::S,"clamda"::S,"x"::S,"ifail"::S]$Lisp,_
	[([itmaxArg::Any,msglvlArg::Any,nArg::Any,nclinArg::Any,nctotlArg::Any,nrowaArg::Any,linobjArg::Any,liworkArg::Any,lworkArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,cvecArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04naf(itmaxArg:Integer,msglvlArg:Integer,nArg:Integer,_
	nclinArg:Integer,nctotlArg:Integer,nrowaArg:Integer,_
	nrowhArg:Integer,ncolhArg:Integer,bigbndArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	cvecArg:Matrix DoubleFloat,featolArg:Matrix DoubleFloat,hessArg:Matrix DoubleFloat,_
	coldArg:Boolean,lppArg:Boolean,orthogArg:Boolean,_
	liworkArg:Integer,lworkArg:Integer,xArg:Matrix DoubleFloat,_
	istateArg:Matrix Integer,ifailArg:Integer,qphessArg:Union(fn:FileName,fp:Asp20(QPHESS))): Result == 
	pushFortranOutputStack(qphessFilename := aspFilename "qphess")$FOP
	if qphessArg case fn
		  then outputAsFortran(qphessArg.fn)
		  else outputAsFortran(qphessArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([qphessFilename]$Lisp,_
	"e04naf",_
	["itmax"::S,"msglvl"::S,"n"::S,"nclin"::S,"nctotl"::S_
	,"nrowa"::S,"nrowh"::S,"ncolh"::S,"bigbnd"::S,"cold"::S_
	,"lpp"::S,"orthog"::S,"liwork"::S,"lwork"::S,"iter"::S_
	,"obj"::S,"ifail"::S,"qphess"::S,"a"::S,"bl"::S,"bu"::S,"cvec"::S,"featol"::S_
	,"hess"::S,"clamda"::S,"x"::S,"istate"::S,"iwork"::S_
	,"work"::S]$Lisp,_
	["iter"::S,"obj"::S,"clamda"::S,"iwork"::S,"work"::S,"qphess"::S]$Lisp,_
	[["double"::S,"bigbnd"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,"nctotl"::S]$Lisp,["bu"::S,"nctotl"::S]$Lisp,["cvec"::S,"n"::S]$Lisp,["featol"::S,"nctotl"::S]$Lisp_
	,["hess"::S,"nrowh"::S,"ncolh"::S]$Lisp,"obj"::S,["clamda"::S,"nctotl"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp_
	,"qphess"::S]$Lisp_
	,["integer"::S,"itmax"::S,"msglvl"::S,"n"::S_
	,"nclin"::S,"nctotl"::S,"nrowa"::S,"nrowh"::S,"ncolh"::S,"liwork"::S,"lwork"::S,"iter"::S,["istate"::S,"nctotl"::S]$Lisp_
	,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	,["logical"::S,"cold"::S,"lpp"::S,"orthog"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"obj"::S,"clamda"::S,"x"::S,"istate"::S,"ifail"::S]$Lisp,_
	[([itmaxArg::Any,msglvlArg::Any,nArg::Any,nclinArg::Any,nctotlArg::Any,nrowaArg::Any,nrowhArg::Any,ncolhArg::Any,bigbndArg::Any,coldArg::Any,lppArg::Any,orthogArg::Any,liworkArg::Any,lworkArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,cvecArg::Any,featolArg::Any,hessArg::Any,xArg::Any,istateArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04ucf(nArg:Integer,nclinArg:Integer,ncnlnArg:Integer,_
	nrowaArg:Integer,nrowjArg:Integer,nrowrArg:Integer,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	liworkArg:Integer,lworkArg:Integer,staArg:Boolean,_
	craArg:DoubleFloat,derArg:Integer,feaArg:DoubleFloat,_
	funArg:DoubleFloat,hesArg:Boolean,infbArg:DoubleFloat,_
	infsArg:DoubleFloat,linfArg:DoubleFloat,lintArg:DoubleFloat,_
	listArg:Boolean,majiArg:Integer,majpArg:Integer,_
	miniArg:Integer,minpArg:Integer,monArg:Integer,_
	nonfArg:DoubleFloat,optArg:DoubleFloat,steArg:DoubleFloat,_
	staoArg:Integer,stacArg:Integer,stooArg:Integer,_
	stocArg:Integer,veArg:Integer,istateArg:Matrix Integer,_
	cjacArg:Matrix DoubleFloat,clamdaArg:Matrix DoubleFloat,rArg:Matrix DoubleFloat,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,confunArg:Union(fn:FileName,fp:Asp55(CONFUN)),_
	objfunArg:Union(fn:FileName,fp:Asp49(OBJFUN))): Result == 
	pushFortranOutputStack(confunFilename := aspFilename "confun")$FOP
	if confunArg case fn
		  then outputAsFortran(confunArg.fn)
		  else outputAsFortran(confunArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(objfunFilename := aspFilename "objfun")$FOP
	if objfunArg case fn
		  then outputAsFortran(objfunArg.fn)
		  else outputAsFortran(objfunArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([confunFilename,objfunFilename]$Lisp,_
	"e04ucf",_
	["n"::S,"nclin"::S,"ncnln"::S,"nrowa"::S,"nrowj"::S_
	,"nrowr"::S,"liwork"::S,"lwork"::S,"sta"::S,"cra"::S_
	,"der"::S,"fea"::S,"fun"::S,"hes"::S,"infb"::S_
	,"infs"::S,"linf"::S,"lint"::S,"list"::S,"maji"::S_
	,"majp"::S,"mini"::S,"minp"::S,"mon"::S,"nonf"::S_
	,"opt"::S,"ste"::S,"stao"::S,"stac"::S,"stoo"::S_
	,"stoc"::S,"ve"::S,"iter"::S,"objf"::S,"ifail"::S_
	,"confun"::S,"objfun"::S,"a"::S,"bl"::S,"bu"::S,"c"::S,"objgrd"::S_
	,"istate"::S,"cjac"::S,"clamda"::S,"r"::S,"x"::S_
	,"iwork"::S,"work"::S,"iuser"::S,"user"::S]$Lisp,_
	["iter"::S,"c"::S,"objf"::S,"objgrd"::S,"iwork"::S,"work"::S,"iuser"::S,"user"::S,"confun"::S,"objfun"::S]$Lisp,_
	[["double"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp,["bu"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,"cra"::S,"fea"::S,"fun"::S,"infb"::S,"infs"::S,"linf"::S,"lint"::S,"nonf"::S,"opt"::S,"ste"::S_
	,["c"::S,"ncnln"::S]$Lisp,"objf"::S,["objgrd"::S,"n"::S]$Lisp,["cjac"::S,"nrowj"::S,"n"::S]$Lisp,["clamda"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,["r"::S,"nrowr"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp_
	,["user"::S,1$Lisp]$Lisp,"confun"::S,"objfun"::S]$Lisp_
	,["integer"::S,"n"::S,"nclin"::S,"ncnln"::S_
	,"nrowa"::S,"nrowj"::S,"nrowr"::S,"liwork"::S,"lwork"::S,"der"::S,"maji"::S,"majp"::S,"mini"::S,"minp"::S,"mon"::S,"stao"::S_
	,"stac"::S,"stoo"::S,"stoc"::S,"ve"::S,"iter"::S,["istate"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp,["iuser"::S,1$Lisp]$Lisp]$Lisp_
	,["logical"::S,"sta"::S,"hes"::S,"list"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"c"::S,"objf"::S,"objgrd"::S,"istate"::S,"cjac"::S,"clamda"::S,"r"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nclinArg::Any,ncnlnArg::Any,nrowaArg::Any,nrowjArg::Any,nrowrArg::Any,liworkArg::Any,lworkArg::Any,staArg::Any,craArg::Any,derArg::Any,feaArg::Any,funArg::Any,hesArg::Any,infbArg::Any,infsArg::Any,linfArg::Any,lintArg::Any,listArg::Any,majiArg::Any,majpArg::Any,miniArg::Any,minpArg::Any,monArg::Any,nonfArg::Any,optArg::Any,steArg::Any,staoArg::Any,stacArg::Any,stooArg::Any,stocArg::Any,veArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,istateArg::Any,cjacArg::Any,clamdaArg::Any,rArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04ycf(jobArg:Integer,mArg:Integer,nArg:Integer,_
	fsumsqArg:DoubleFloat,sArg:Matrix DoubleFloat,lvArg:Integer,_
	vArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e04ycf",_
	["job"::S,"m"::S,"n"::S,"fsumsq"::S,"lv"::S_
	,"ifail"::S,"s"::S,"cj"::S,"v"::S,"work"::S]$Lisp,_
	["cj"::S,"work"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["s"::S,"n"::S]$Lisp_
	,["cj"::S,"n"::S]$Lisp,["v"::S,"lv"::S,"n"::S]$Lisp,["work"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"job"::S,"m"::S,"n"::S,"lv"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["cj"::S,"v"::S,"ifail"::S]$Lisp,_
	[([jobArg::Any,mArg::Any,nArg::Any,fsumsqArg::Any,lvArg::Any,ifailArg::Any,sArg::Any,vArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE04.dotabb>>=
"NAGE04" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE04"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE04" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD02 NagOrdinaryDifferentialEquationsPackage}
\pagehead{NagOrdinaryDifferentialEquationsPackage}{NAGD02}
\pagepic{ps/v104nagordinarydifferentialequationspackage.ps}{NAGD02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD02 NagOrdinaryDifferentialEquationsPackage>>=
)abbrev package NAGD02 NagOrdinaryDifferentialEquationsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Mon Jun 20 17:56:33 1994
++ Description:
++ This package uses the NAG Library to calculate the numerical solution of 
++ ordinary differential equations. There are two main types of problem,
++ those in which all boundary conditions are specified at one point
++ (initial-value problems), and those in which the boundary
++ conditions are distributed between two or more points (boundary-
++ value problems and eigenvalue problems). Routines are available
++ for initial-value problems, two-point boundary-value problems and
++ Sturm-Liouville eigenvalue problems.
++ See \downlink{Manual Page}{manpageXXd02}.
NagOrdinaryDifferentialEquationsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d02bbf : (DoubleFloat,Integer,Integer,Integer,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02bbf(xend,m,n,irelab,x,y,tol,ifail,fcn,output)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over an interval with suitable initial conditions, 
     ++ using a Runge-Kutta-Merson method, and returns the solution at 
     ++ points specified by the user.
     ++ See \downlink{Manual Page}{manpageXXd02bbf}.
    d02bhf : (DoubleFloat,Integer,Integer,DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN))) -> Result 
     ++ d02bhf(xend,n,irelab,hmax,x,y,tol,ifail,g,fcn)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over an interval with suitable initial conditions, 
     ++ using a Runge-Kutta-Merson method, until a user-specified 
     ++ function of the solution is zero.
     ++ See \downlink{Manual Page}{manpageXXd02bhf}.
    d02cjf : (DoubleFloat,Integer,Integer,DoubleFloat,_
	String,DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02cjf(xend,m,n,tol,relabs,x,y,ifail,g,fcn,output)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over a range with suitable initial conditions, using a 
     ++ variable-order, variable-step Adams method until a user-specified
     ++ function, if supplied, of the solution is zero, and returns the 
     ++ solution at points specified by the user, if desired.
     ++ See \downlink{Manual Page}{manpageXXd02cjf}.
    d02ejf : (DoubleFloat,Integer,Integer,String,_
	Integer,DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp31(PEDERV)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02ejf(xend,m,n,relabs,iw,x,y,tol,ifail,g,fcn,pederv,output)
     ++ integrates a stiff system of first-order ordinary 
     ++ differential equations over an interval with suitable initial 
     ++ conditions, using a variable-order, variable-step method 
     ++ implementing the Backward Differentiation Formulae (BDF), until a
     ++ user-specified function, if supplied, of the solution is zero, 
     ++ and returns the solution at points specified by the user, if 
     ++ desired.
     ++ See \downlink{Manual Page}{manpageXXd02ejf}.
    d02gaf : (Matrix DoubleFloat,Matrix DoubleFloat,Integer,DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp7(FCN))) -> Result 
     ++ d02gaf(u,v,n,a,b,tol,mnp,lw,liw,x,np,ifail,fcn)
     ++ solves the two-point boundary-value problem with assigned 
     ++ boundary values for a system of ordinary differential equations, 
     ++ using a deferred correction technique and a Newton iteration.
     ++ See \downlink{Manual Page}{manpageXXd02gaf}.
    d02gbf : (DoubleFloat,DoubleFloat,Integer,DoubleFloat,_
	Integer,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp77(FCNF)),Union(fn:FileName,fp:Asp78(FCNG))) -> Result 
     ++ d02gbf(a,b,n,tol,mnp,lw,liw,c,d,gam,x,np,ifail,fcnf,fcng)
     ++ solves a general linear two-point boundary value problem 
     ++ for a system of ordinary differential equations using a deferred 
     ++ correction technique.
     ++ See \downlink{Manual Page}{manpageXXd02gbf}.
    d02kef : (Matrix DoubleFloat,Integer,Integer,DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp10(COEFFN)),Union(fn:FileName,fp:Asp80(BDYVAL))) -> Result 
     ++ d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,hmax,maxit,ifail,coeffn,bdyval)
     ++ finds a specified eigenvalue of a regular singular second-
     ++ order Sturm-Liouville system on a finite or infinite range, using
     ++ a Pruefer transformation and a shooting method. It also reports 
     ++ values of the eigenfunction and its derivatives. Provision is 
     ++ made for discontinuities in the coefficient functions or their 
     ++ derivatives.
     ++ See \downlink{Manual Page}{manpageXXd02kef}.
     ++ ASP domains Asp12 and Asp33 are used to supply default
     ++ subroutines for the MONIT and REPORT arguments via their \axiomOp{outputAsFortran} operation.
    d02kef : (Matrix DoubleFloat,Integer,Integer,DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp10(COEFFN)),Union(fn:FileName,fp:Asp80(BDYVAL)),FileName,FileName) -> Result 
     ++ d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,hmax,maxit,ifail,coeffn,bdyval,monit,report)
     ++ finds a specified eigenvalue of a regular singular second-
     ++ order Sturm-Liouville system on a finite or infinite range, using
     ++ a Pruefer transformation and a shooting method. It also reports 
     ++ values of the eigenfunction and its derivatives. Provision is 
     ++ made for discontinuities in the coefficient functions or their 
     ++ derivatives.
     ++ See \downlink{Manual Page}{manpageXXd02kef}.
     ++ Files \spad{monit} and \spad{report} will be used to define the subroutines for the
     ++ MONIT and REPORT arguments.
     ++ See \downlink{Manual Page}{manpageXXd02gbf}.
    d02raf : (Integer,Integer,Integer,Integer,_
	DoubleFloat,Integer,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp41(FCN,JACOBF,JACEPS)),Union(fn:FileName,fp:Asp42(G,JACOBG,JACGEP))) -> Result 
     ++ d02raf(n,mnp,numbeg,nummix,tol,init,iy,ijac,lwork,liwork,np,x,y,deleps,ifail,fcn,g)
     ++ solves the two-point boundary-value problem with general 
     ++ boundary conditions for a system of ordinary differential 
     ++ equations, using a deferred correction technique and Newton 
     ++ iteration.
     ++ See \downlink{Manual Page}{manpageXXd02raf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp7(FCN))
    import Union(fn:FileName,fp:Asp8(OUTPUT))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(Matrix DoubleFloat)


    d02bbf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	irelabArg:Integer,xArg:DoubleFloat,yArg:Matrix DoubleFloat,_
	tolArg:DoubleFloat,ifailArg:Integer,fcnArg:Union(fn:FileName,fp:Asp7(FCN)),_
	outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename, outputFilename]$Lisp,_
	"d02bbf",_
	["xend"::S,"m"::S,"n"::S,"irelab"::S,"x"::S_
	,"tol"::S,"ifail"::S,"fcn"::S,"output"::S,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"fcn"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,"tol"::S,["w"::S,"n"::S,7$Lisp]$Lisp,"fcn"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"irelab"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,irelabArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02bhf(xendArg:DoubleFloat,nArg:Integer,irelabArg:Integer,_
	hmaxArg:DoubleFloat,xArg:DoubleFloat,yArg:Matrix DoubleFloat,_
	tolArg:DoubleFloat,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp9(G)),_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename]$Lisp,_
	"d02bhf",_
	["xend"::S,"n"::S,"irelab"::S,"hmax"::S,"x"::S_
	,"tol"::S,"ifail"::S,"g"::S,"fcn"::S,"y"::S,"w"::S]$Lisp,_
	["w"::S,"g"::S,"fcn"::S]$Lisp,_
	[["double"::S,"xend"::S,"hmax"::S,"x"::S,["y"::S,"n"::S]$Lisp_
	,"tol"::S,["w"::S,"n"::S,7$Lisp]$Lisp,"g"::S,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"irelab"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,nArg::Any,irelabArg::Any,hmaxArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02cjf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	tolArg:DoubleFloat,relabsArg:String,xArg:DoubleFloat,_
	yArg:Matrix DoubleFloat,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp9(G)),_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN)),outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename,outputFilename]$Lisp,_
	"d02cjf",_
	["xend"::S,"m"::S,"n"::S,"tol"::S,"relabs"::S_
	,"x"::S,"ifail"::S,"g"::S,"fcn"::S,"output"::S_
	,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"g"::S,"fcn"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,"tol"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,["w"::S,["+"::S,["*"::S,21$Lisp,"n"::S]$Lisp,28$Lisp]$Lisp]$Lisp,"g"::S_
	,"fcn"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"relabs"::S]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,tolArg::Any,relabsArg::Any,xArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02ejf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	relabsArg:String,iwArg:Integer,xArg:DoubleFloat,_
	yArg:Matrix DoubleFloat,tolArg:DoubleFloat,ifailArg:Integer,_
	gArg:Union(fn:FileName,fp:Asp9(G)),fcnArg:Union(fn:FileName,fp:Asp7(FCN)),pedervArg:Union(fn:FileName,fp:Asp31(PEDERV)),_
	outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(pedervFilename := aspFilename "pederv")$FOP
	if pedervArg case fn
		  then outputAsFortran(pedervArg.fn)
		  else outputAsFortran(pedervArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename,pedervFilename,outputFilename]$Lisp,_
	"d02ejf",_
	["xend"::S,"m"::S,"n"::S,"relabs"::S,"iw"::S_
	,"x"::S,"tol"::S,"ifail"::S,"g"::S,"fcn"::S_
	,"pederv"::S,"output"::S,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"g"::S,"fcn"::S,"pederv"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,"tol"::S,["w"::S,"iw"::S]$Lisp,"g"::S,"fcn"::S,"pederv"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"iw"::S,"ifail"::S_
	]$Lisp_
	,["character"::S,"relabs"::S]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,relabsArg::Any,iwArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02gaf(uArg:Matrix DoubleFloat,vArg:Matrix DoubleFloat,nArg:Integer,_
	aArg:DoubleFloat,bArg:DoubleFloat,tolArg:DoubleFloat,_
	mnpArg:Integer,lwArg:Integer,liwArg:Integer,_
	xArg:Matrix DoubleFloat,npArg:Integer,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"d02gaf",_
	["n"::S,"a"::S,"b"::S,"tol"::S,"mnp"::S_
	,"lw"::S,"liw"::S,"np"::S,"ifail"::S,"fcn"::S_
	,"u"::S,"v"::S,"y"::S,"x"::S,"w"::S_
	,"iw"::S]$Lisp,_
	["y"::S,"w"::S,"iw"::S,"fcn"::S]$Lisp,_
	[["double"::S,["u"::S,"n"::S,2$Lisp]$Lisp,["v"::S,"n"::S,2$Lisp]$Lisp_
	,"a"::S,"b"::S,"tol"::S,["y"::S,"n"::S,"mnp"::S]$Lisp,["x"::S,"mnp"::S]$Lisp,["w"::S,"lw"::S]$Lisp_
	,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"lw"::S,"liw"::S_
	,"np"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["y"::S,"x"::S,"np"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,aArg::Any,bArg::Any,tolArg::Any,mnpArg::Any,lwArg::Any,liwArg::Any,npArg::Any,ifailArg::Any,uArg::Any,vArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02gbf(aArg:DoubleFloat,bArg:DoubleFloat,nArg:Integer,_
	tolArg:DoubleFloat,mnpArg:Integer,lwArg:Integer,_
	liwArg:Integer,cArg:Matrix DoubleFloat,dArg:Matrix DoubleFloat,_
	gamArg:Matrix DoubleFloat,xArg:Matrix DoubleFloat,npArg:Integer,_
	ifailArg:Integer,fcnfArg:Union(fn:FileName,fp:Asp77(FCNF)),fcngArg:Union(fn:FileName,fp:Asp78(FCNG))): Result == 
	pushFortranOutputStack(fcnfFilename := aspFilename "fcnf")$FOP
	if fcnfArg case fn
		  then outputAsFortran(fcnfArg.fn)
		  else outputAsFortran(fcnfArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcngFilename := aspFilename "fcng")$FOP
	if fcngArg case fn
		  then outputAsFortran(fcngArg.fn)
		  else outputAsFortran(fcngArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnfFilename,fcngFilename]$Lisp,_
	"d02gbf",_
	["a"::S,"b"::S,"n"::S,"tol"::S,"mnp"::S_
	,"lw"::S,"liw"::S,"np"::S,"ifail"::S,"fcnf"::S_
	,"fcng"::S,"y"::S,"c"::S,"d"::S,"gam"::S,"x"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["y"::S,"w"::S,"iw"::S,"fcnf"::S,"fcng"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"tol"::S,["y"::S,"n"::S,"mnp"::S]$Lisp_
	,["c"::S,"n"::S,"n"::S]$Lisp,["d"::S,"n"::S,"n"::S]$Lisp,["gam"::S,"n"::S]$Lisp,["x"::S,"mnp"::S]$Lisp_
	,["w"::S,"lw"::S]$Lisp,"fcnf"::S,"fcng"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"lw"::S,"liw"::S_
	,"np"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["y"::S,"c"::S,"d"::S,"gam"::S,"x"::S,"np"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,nArg::Any,tolArg::Any,mnpArg::Any,lwArg::Any,liwArg::Any,npArg::Any,ifailArg::Any,cArg::Any,dArg::Any,gamArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02kef(xpointArg:Matrix DoubleFloat,mArg:Integer,kArg:Integer,_
	tolArg:DoubleFloat,maxfunArg:Integer,matchArg:Integer,_
	elamArg:DoubleFloat,delamArg:DoubleFloat,hmaxArg:Matrix DoubleFloat,_
	maxitArg:Integer,ifailArg:Integer,coeffnArg:Union(fn:FileName,fp:Asp10(COEFFN)),_
	bdyvalArg:Union(fn:FileName,fp:Asp80(BDYVAL))): Result == 
	pushFortranOutputStack(coeffnFilename := aspFilename "coeffn")$FOP
	if coeffnArg case fn
		  then outputAsFortran(coeffnArg.fn)
		  else outputAsFortran(coeffnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bdyvalFilename := aspFilename "bdyval")$FOP
	if bdyvalArg case fn
		  then outputAsFortran(bdyvalArg.fn)
		  else outputAsFortran(bdyvalArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran()$Asp12(MONIT)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(reportFilename := aspFilename "report")$FOP
	outputAsFortran()$Asp33(REPORT)
	popFortranOutputStack()$FOP
	[(invokeNagman([coeffnFilename,bdyvalFilename,monitFilename,reportFilename]$Lisp,_
	"d02kef",_
	["m"::S,"k"::S,"tol"::S,"maxfun"::S,"match"::S_
	,"elam"::S,"delam"::S,"maxit"::S,"ifail"::S,"coeffn"::S_
	,"bdyval"::S,"monit"::S,"report"::S,"xpoint"::S,"hmax"::S]$Lisp,_
	["coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp,_
	[["double"::S,["xpoint"::S,"m"::S]$Lisp,"tol"::S_
	,"elam"::S,"delam"::S,["hmax"::S,2$Lisp,"m"::S]$Lisp,"coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp_
	,["integer"::S,"m"::S,"k"::S,"maxfun"::S,"match"::S_
	,"maxit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["match"::S,"elam"::S,"delam"::S,"hmax"::S,"maxit"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kArg::Any,tolArg::Any,maxfunArg::Any,matchArg::Any,elamArg::Any,delamArg::Any,maxitArg::Any,ifailArg::Any,xpointArg::Any,hmaxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02kef(xpointArg:Matrix DoubleFloat,mArg:Integer,kArg:Integer,_
	tolArg:DoubleFloat,maxfunArg:Integer,matchArg:Integer,_
	elamArg:DoubleFloat,delamArg:DoubleFloat,hmaxArg:Matrix DoubleFloat,_
	maxitArg:Integer,ifailArg:Integer,coeffnArg:Union(fn:FileName,fp:Asp10(COEFFN)),_
	bdyvalArg:Union(fn:FileName,fp:Asp80(BDYVAL)),monitArg:FileName,reportArg:FileName): Result == 
	pushFortranOutputStack(coeffnFilename := aspFilename "coeffn")$FOP
	if coeffnArg case fn
		  then outputAsFortran(coeffnArg.fn)
		  else outputAsFortran(coeffnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bdyvalFilename := aspFilename "bdyval")$FOP
	if bdyvalArg case fn
		  then outputAsFortran(bdyvalArg.fn)
		  else outputAsFortran(bdyvalArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran(monitArg)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(reportFilename := aspFilename "report")$FOP
	outputAsFortran(reportArg)
	popFortranOutputStack()$FOP
	[(invokeNagman([coeffnFilename,bdyvalFilename,monitFilename,reportFilename]$Lisp,_
	"d02kef",_
	["m"::S,"k"::S,"tol"::S,"maxfun"::S,"match"::S_
	,"elam"::S,"delam"::S,"maxit"::S,"ifail"::S,"coeffn"::S_
	,"bdyval"::S,"monit"::S,"report"::S,"xpoint"::S,"hmax"::S]$Lisp,_
	["coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp,_
	[["double"::S,["xpoint"::S,"m"::S]$Lisp,"tol"::S_
	,"elam"::S,"delam"::S,["hmax"::S,2$Lisp,"m"::S]$Lisp,"coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp_
	,["integer"::S,"m"::S,"k"::S,"maxfun"::S,"match"::S_
	,"maxit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["match"::S,"elam"::S,"delam"::S,"hmax"::S,"maxit"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kArg::Any,tolArg::Any,maxfunArg::Any,matchArg::Any,elamArg::Any,delamArg::Any,maxitArg::Any,ifailArg::Any,xpointArg::Any,hmaxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02raf(nArg:Integer,mnpArg:Integer,numbegArg:Integer,_
	nummixArg:Integer,tolArg:DoubleFloat,initArg:Integer,_
	iyArg:Integer,ijacArg:Integer,lworkArg:Integer,_
	liworkArg:Integer,npArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,delepsArg:DoubleFloat,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp41(FCN,JACOBF,JACEPS)),gArg:Union(fn:FileName,fp:Asp42(G,JACOBG,JACGEP))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename,gFilename]$Lisp,_
	"d02raf",_
	["n"::S,"mnp"::S,"numbeg"::S,"nummix"::S,"tol"::S_
	,"init"::S,"iy"::S,"ijac"::S,"lwork"::S,"liwork"::S_
	,"np"::S,"deleps"::S,"ifail"::S,"fcn"::S,"g"::S_
	,"abt"::S,"x"::S,"y"::S,"work"::S,"iwork"::S_
	]$Lisp,_
	["abt"::S,"work"::S,"iwork"::S,"fcn"::S,"g"::S]$Lisp,_
	[["double"::S,"tol"::S,["abt"::S,"n"::S]$Lisp_
	,["x"::S,"mnp"::S]$Lisp,["y"::S,"iy"::S,"mnp"::S]$Lisp,"deleps"::S,["work"::S,"lwork"::S]$Lisp,"fcn"::S,"g"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"numbeg"::S_
	,"nummix"::S,"init"::S,"iy"::S,"ijac"::S,"lwork"::S,"liwork"::S,"np"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	]$Lisp,_
	["abt"::S,"np"::S,"x"::S,"y"::S,"deleps"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mnpArg::Any,numbegArg::Any,nummixArg::Any,tolArg::Any,initArg::Any,iyArg::Any,ijacArg::Any,lworkArg::Any,liworkArg::Any,npArg::Any,delepsArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD02.dotabb>>=
"NAGD02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD02"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD02" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD03 NagPartialDifferentialEquationsPackage}
\pagehead{NagPartialDifferentialEquationsPackage}{NAGD03}
\pagepic{ps/v104nagpartialdifferentialequationspackage.ps}{NAGD03}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD03 NagPartialDifferentialEquationsPackage>>=
)abbrev package NAGD03 NagPartialDifferentialEquationsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:51 1994
++ Description:
++ This package uses the NAG Library to solve partial
++ differential equations.
++ See \downlink{Manual Page}{manpageXXd03}.
NagPartialDifferentialEquationsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d03edf : (Integer,Integer,Integer,Integer,_
	DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ d03edf(ngx,ngy,lda,maxit,acc,iout,a,rhs,ub,ifail)
     ++ solves seven-diagonal systems of linear equations which 
     ++ arise from the discretization of an elliptic partial differential
     ++ equation on a rectangular region. This routine uses a multigrid 
     ++ technique.
     ++ See \downlink{Manual Page}{manpageXXd03edf}.
    d03eef : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,String,Integer,Union(fn:FileName,fp:Asp73(PDEF)),Union(fn:FileName,fp:Asp74(BNDY))) -> Result 
     ++ d03eef(xmin,xmax,ymin,ymax,ngx,ngy,lda,scheme,ifail,pdef,bndy)
     ++ discretizes a second order elliptic partial differential 
     ++ equation (PDE) on a rectangular region.
     ++ See \downlink{Manual Page}{manpageXXd03eef}.
    d03faf : (DoubleFloat,DoubleFloat,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,ThreeDimensionalMatrix DoubleFloat,Integer) -> Result 
     ++ d03faf(xs,xf,l,lbdcnd,bdxs,bdxf,ys,yf,m,mbdcnd,bdys,bdyf,zs,zf,n,nbdcnd,bdzs,bdzf,lambda,ldimf,mdimf,lwrk,f,ifail)
     ++ solves the Helmholtz equation in Cartesian co-ordinates in
     ++ three dimensions using the standard seven-point finite difference
     ++ approximation. This routine is designed to be particularly 
     ++ efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXd03faf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(ThreeDimensionalMatrix DoubleFloat)
    import FortranPackage
    import Union(fn:FileName,fp:Asp73(PDEF))
    import Union(fn:FileName,fp:Asp74(BNDY))




    d03edf(ngxArg:Integer,ngyArg:Integer,ldaArg:Integer,_
	maxitArg:Integer,accArg:DoubleFloat,ioutArg:Integer,_
	aArg:Matrix DoubleFloat,rhsArg:Matrix DoubleFloat,ubArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d03edf",_
	["ngx"::S,"ngy"::S,"lda"::S,"maxit"::S,"acc"::S_
	,"iout"::S,"numit"::S,"ifail"::S,"us"::S,"u"::S,"a"::S,"rhs"::S,"ub"::S_
	]$Lisp,_
	["us"::S,"u"::S,"numit"::S]$Lisp,_
	[["double"::S,"acc"::S,["us"::S,"lda"::S]$Lisp_
	,["u"::S,"lda"::S]$Lisp,["a"::S,"lda"::S,7$Lisp]$Lisp,["rhs"::S,"lda"::S]$Lisp,["ub"::S,["*"::S,"ngx"::S,"ngy"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"ngx"::S,"ngy"::S,"lda"::S,"maxit"::S_
	,"iout"::S,"numit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["us"::S,"u"::S,"numit"::S,"a"::S,"rhs"::S,"ub"::S,"ifail"::S]$Lisp,_
	[([ngxArg::Any,ngyArg::Any,ldaArg::Any,maxitArg::Any,accArg::Any,ioutArg::Any,ifailArg::Any,aArg::Any,rhsArg::Any,ubArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d03eef(xminArg:DoubleFloat,xmaxArg:DoubleFloat,yminArg:DoubleFloat,_
	ymaxArg:DoubleFloat,ngxArg:Integer,ngyArg:Integer,_
	ldaArg:Integer,schemeArg:String,ifailArg:Integer,_
	pdefArg:Union(fn:FileName,fp:Asp73(PDEF)),bndyArg:Union(fn:FileName,fp:Asp74(BNDY))): Result == 
	pushFortranOutputStack(pdefFilename := aspFilename "pdef")$FOP
	if pdefArg case fn
		  then outputAsFortran(pdefArg.fn)
		  else outputAsFortran(pdefArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bndyFilename := aspFilename "bndy")$FOP
	if bndyArg case fn
		  then outputAsFortran(bndyArg.fn)
		  else outputAsFortran(bndyArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([pdefFilename,bndyFilename]$Lisp,_
	"d03eef",_
	["xmin"::S,"xmax"::S,"ymin"::S,"ymax"::S,"ngx"::S_
	,"ngy"::S,"lda"::S,"scheme"::S,"ifail"::S,"pdef"::S_
	,"bndy"::S,"a"::S,"rhs"::S]$Lisp,_
	["a"::S,"rhs"::S,"pdef"::S,"bndy"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,"ymin"::S_
	,"ymax"::S,["a"::S,"lda"::S,7$Lisp]$Lisp,["rhs"::S,"lda"::S]$Lisp,"pdef"::S,"bndy"::S]$Lisp_
	,["integer"::S,"ngx"::S,"ngy"::S,"lda"::S,"ifail"::S_
	]$Lisp_
	,["character"::S,"scheme"::S]$Lisp_
	]$Lisp,_
	["a"::S,"rhs"::S,"ifail"::S]$Lisp,_
	[([xminArg::Any,xmaxArg::Any,yminArg::Any,ymaxArg::Any,ngxArg::Any,ngyArg::Any,ldaArg::Any,schemeArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d03faf(xsArg:DoubleFloat,xfArg:DoubleFloat,lArg:Integer,_
	lbdcndArg:Integer,bdxsArg:Matrix DoubleFloat,bdxfArg:Matrix DoubleFloat,_
	ysArg:DoubleFloat,yfArg:DoubleFloat,mArg:Integer,_
	mbdcndArg:Integer,bdysArg:Matrix DoubleFloat,bdyfArg:Matrix DoubleFloat,_
	zsArg:DoubleFloat,zfArg:DoubleFloat,nArg:Integer,_
	nbdcndArg:Integer,bdzsArg:Matrix DoubleFloat,bdzfArg:Matrix DoubleFloat,_
	lambdaArg:DoubleFloat,ldimfArg:Integer,mdimfArg:Integer,_
	lwrkArg:Integer,fArg:ThreeDimensionalMatrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d03faf",_
	["xs"::S,"xf"::S,"l"::S,"lbdcnd"::S,"ys"::S_
	,"yf"::S,"m"::S,"mbdcnd"::S,"zs"::S,"zf"::S_
	,"n"::S,"nbdcnd"::S,"lambda"::S,"ldimf"::S,"mdimf"::S_
	,"lwrk"::S,"pertrb"::S,"ifail"::S,"bdxs"::S,"bdxf"::S,"bdys"::S,"bdyf"::S,"bdzs"::S_
	,"bdzf"::S,"f"::S,"w"::S]$Lisp,_
	["pertrb"::S,"w"::S]$Lisp,_
	[["double"::S,"xs"::S,"xf"::S,["bdxs"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["bdxf"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,"ys"::S,"yf"::S,["bdys"::S,"ldimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["bdyf"::S,"ldimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,"zs"::S_
	,"zf"::S,["bdzs"::S,"ldimf"::S,["+"::S,"m"::S,1$Lisp]$Lisp]$Lisp,["bdzf"::S,"ldimf"::S,["+"::S,"m"::S,1$Lisp]$Lisp]$Lisp_
	,"lambda"::S,"pertrb"::S,["f"::S,"ldimf"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,["w"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"l"::S,"lbdcnd"::S,"m"::S,"mbdcnd"::S_
	,"n"::S,"nbdcnd"::S,"ldimf"::S,"mdimf"::S,"lwrk"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pertrb"::S,"f"::S,"ifail"::S]$Lisp,_
	[([xsArg::Any,xfArg::Any,lArg::Any,lbdcndArg::Any,ysArg::Any,yfArg::Any,mArg::Any,mbdcndArg::Any,zsArg::Any,zfArg::Any,nArg::Any,nbdcndArg::Any,lambdaArg::Any,ldimfArg::Any,mdimfArg::Any,lwrkArg::Any,ifailArg::Any,bdxsArg::Any,bdxfArg::Any,bdysArg::Any,bdyfArg::Any,bdzsArg::Any,bdzfArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD03.dotabb>>=
"NAGD03" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD03"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD03" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC02 NagPolynomialRootsPackage}
\pagehead{NagPolynomialRootsPackage}{NAGC02}
\pagepic{ps/v104nagpolynomialrootspackage.ps}{NAGC02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC02 NagPolynomialRootsPackage>>=
)abbrev package NAGC02 NagPolynomialRootsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:27 1994
++ Description:
++ This package uses the NAG Library to compute the zeros of a
++ polynomial with real or complex coefficients.
++ See \downlink{Manual Page}{manpageXXc02}.

NagPolynomialRootsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c02aff : (Matrix DoubleFloat,Integer,Boolean,Integer) -> Result 
     ++ c02aff(a,n,scale,ifail)
     ++ finds all the roots of a complex polynomial equation, 
     ++ using a variant of Laguerre's Method.
     ++ See \downlink{Manual Page}{manpageXXc02aff}.
    c02agf : (Matrix DoubleFloat,Integer,Boolean,Integer) -> Result 
     ++ c02agf(a,n,scale,ifail)
     ++ finds all the roots of a real polynomial equation, using a
     ++ variant of Laguerre's Method.
     ++ See \downlink{Manual Page}{manpageXXc02agf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Matrix DoubleFloat
    import Any
    import Record
    import Integer
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(Boolean)


    c02aff(aArg:Matrix DoubleFloat,nArg:Integer,scaleArg:Boolean,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c02aff",_
	["n"::S,"scale"::S,"ifail"::S,"a"::S,"z"::S,"w"::S]$Lisp,_
	["z"::S,"w"::S]$Lisp,_
	[["double"::S,["a"::S,2$Lisp,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["z"::S,2$Lisp,"n"::S]$Lisp,["w"::S,["*"::S,["+"::S,"n"::S,1$Lisp]$Lisp,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	,["logical"::S,"scale"::S]$Lisp_
	]$Lisp,_
	["z"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,scaleArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result



    c02agf(aArg:Matrix DoubleFloat,nArg:Integer,scaleArg:Boolean,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c02agf",_
	["n"::S,"scale"::S,"ifail"::S,"a"::S,"z"::S,"w"::S]$Lisp,_
	["z"::S,"w"::S]$Lisp,_
	[["double"::S,["a"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["z"::S,2$Lisp,"n"::S]$Lisp,["w"::S,["*"::S,["+"::S,"n"::S,1$Lisp]$Lisp,2$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	,["logical"::S,"scale"::S]$Lisp_
	]$Lisp,_
	["z"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,scaleArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC02.dotabb>>=
"NAGC02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC02"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC05 NagRootFindingPackage}
\pagehead{NagRootFindingPackage}{NAGC05}
\pagepic{ps/v104nagrootfindingpackage.ps}{NAGC05}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC05 NagRootFindingPackage>>=
)abbrev package NAGC05 NagRootFindingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:28 1994
++ Description: 
++ This package uses the NAG Library to calculate real zeros of
++ continuous real functions of one or more variables. (Complex
++ equations must be expressed in terms of the equivalent larger
++ system of real equations.)
++ See \downlink{Manual Page}{manpageXXc05}.

NagRootFindingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c05adf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ c05adf(a,b,eps,eta,ifail,f)
     ++ locates a zero of a continuous function in a given 
     ++ interval by a combination of the methods of linear interpolation,
     ++ extrapolation and bisection.
     ++ See \downlink{Manual Page}{manpageXXc05adf}.
    c05nbf : (Integer,Integer,Matrix DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp6(FCN))) -> Result 
     ++ c05nbf(n,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method.
     ++ See \downlink{Manual Page}{manpageXXc05nbf}.
    c05pbf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	DoubleFloat,Integer,Union(fn:FileName,fp:Asp35(FCN))) -> Result 
     ++ c05pbf(n,ldfjac,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method. The user must provide the Jacobian.
     ++ See \downlink{Manual Page}{manpageXXc05pbf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp1(F))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Integer)


    c05adf(aArg:DoubleFloat,bArg:DoubleFloat,epsArg:DoubleFloat,_
	etaArg:DoubleFloat,ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"c05adf",_
	["a"::S,"b"::S,"eps"::S,"eta"::S,"x"::S_
	,"ifail"::S,"f"::S]$Lisp,_
	["x"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"eps"::S,"eta"::S_
	,"x"::S,"f"::S]$Lisp_
	,["integer"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsArg::Any,etaArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05nbf(nArg:Integer,lwaArg:Integer,xArg:Matrix DoubleFloat,_
	xtolArg:DoubleFloat,ifailArg:Integer,fcnArg:Union(fn:FileName,fp:Asp6(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05nbf",_
	["n"::S,"lwa"::S,"xtol"::S,"ifail"::S,"fcn"::S_
	,"fvec"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp_
	,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"lwa"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05pbf(nArg:Integer,ldfjacArg:Integer,lwaArg:Integer,_
	xArg:Matrix DoubleFloat,xtolArg:DoubleFloat,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp35(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05pbf",_
	["n"::S,"ldfjac"::S,"lwa"::S,"xtol"::S,"ifail"::S_
	,"fcn"::S,"fvec"::S,"fjac"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"fjac"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["fjac"::S,"ldfjac"::S,"n"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"ldfjac"::S,"lwa"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"fjac"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ldfjacArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC05.dotabb>>=
"NAGC05" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC05"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC06 NagSeriesSummationPackage}
\pagehead{NagSeriesSummationPackage}{NAGC06}
\pagepic{ps/v104nagseriessummationpackage.ps}{NAGC06}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC06 NagSeriesSummationPackage>>=
)abbrev package NAGC06 NagSeriesSummationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:30 1994
++ Description:
++ This package uses the NAG Library to calculate the discrete Fourier
++ transform of a sequence of real or complex data values, and
++ applies it to calculate convolutions and correlations.
++ See \downlink{Manual Page}{manpageXXc06}.

NagSeriesSummationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c06eaf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06eaf(n,x,ifail)
     ++ calculates the discrete Fourier transform of a sequence of
     ++ n real data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06eaf}.
    c06ebf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06ebf(n,x,ifail)
     ++ calculates the discrete Fourier transform of a Hermitian 
     ++ sequence of n complex data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06ebf}.
    c06ecf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06ecf(n,x,y,ifail)
     ++ calculates the discrete Fourier transform of a sequence of
     ++ n complex data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06ecf}.
    c06ekf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ c06ekf(job,n,x,y,ifail)
     ++ calculates the circular convolution of two 
     ++ real vectors of period n. No extra workspace is required.
     ++ See \downlink{Manual Page}{manpageXXc06ekf}.
    c06fpf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ c06fpf(m,n,init,x,trig,ifail)
     ++ computes the discrete Fourier transforms of m sequences, 
     ++ each containing n real data values. This routine is designed to 
     ++ be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fpf}.
    c06fqf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ c06fqf(m,n,init,x,trig,ifail)
     ++ computes the discrete Fourier transforms of m Hermitian 
     ++ sequences, each containing n complex data values. This routine is
     ++ designed to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fqf}.
    c06frf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06frf(m,n,init,x,y,trig,ifail)
     ++ computes the discrete Fourier transforms of m sequences, 
     ++ each containing n complex data values. This routine is designed 
     ++ to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06frf}.
    c06fuf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06fuf(m,n,init,x,y,trigm,trign,ifail)
     ++ computes the two-dimensional discrete Fourier transform of
     ++ a bivariate sequence of complex data values. This routine is 
     ++ designed to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fuf}.
    c06gbf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gbf(n,x,ifail)
     ++ forms the complex conjugate of n 
     ++ data values.
     ++ See \downlink{Manual Page}{manpageXXc06gbf}.
    c06gcf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gcf(n,y,ifail)
     ++ forms the complex conjugate of a sequence of n data 
     ++ values.
     ++ See \downlink{Manual Page}{manpageXXc06gcf}.
    c06gqf : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gqf(m,n,x,ifail)
     ++ forms the complex conjugates, 
     ++ each containing n data values.
     ++ See \downlink{Manual Page}{manpageXXc06gqf}.
    c06gsf : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gsf(m,n,x,ifail)
     ++ takes m Hermitian sequences, each containing n data 
     ++ values, and forms the real and imaginary parts of the m 
     ++ corresponding complex sequences.
     ++ See \downlink{Manual Page}{manpageXXc06gsf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(Matrix DoubleFloat)


    c06eaf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06eaf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result


    c06ebf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ebf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06ecf(nArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ecf",_
	["n"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06ekf(jobArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ekf",_
	["job"::S,"n"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"job"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([jobArg::Any,nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fpf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fpf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fqf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fqf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06frf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06frf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"y"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["y"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,["*"::S,2$Lisp,"m"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,yArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fuf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,trigmArg:Matrix DoubleFloat,_
	trignArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fuf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"y"::S,"trigm"::S,"trign"::S,"work"::S_
	]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["y"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["trigm"::S,["*"::S,2$Lisp,"m"::S]$Lisp]$Lisp,["trign"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp_
	,["work"::S,["*"::S,["*"::S,2$Lisp,"m"::S]$Lisp,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"trigm"::S,"trign"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,yArg::Any,trigmArg::Any,trignArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gbf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gbf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gcf(nArg:Integer,yArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gcf",_
	["n"::S,"ifail"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["y"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["y"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gqf(mArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gqf",_
	["m"::S,"n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gsf(mArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gsf",_
	["m"::S,"n"::S,"ifail"::S,"x"::S,"u"::S,"v"::S]$Lisp,_
	["u"::S,"v"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["u"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["v"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["u"::S,"v"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC06.dotabb>>=
"NAGC06" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC06"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NONE1 NoneFunctions1}
\pagehead{NoneFunctions1}{NONE1}
\pagepic{ps/v104nonefunctions1.ps}{NONE1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NONE1 NoneFunctions1>>=
)abbrev package NONE1 NoneFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions: coerce
++ Related Constructors: None
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{NoneFunctions1} implements functions on \spadtype{None}.
++   It particular it includes a particulary dangerous coercion from
++   any other type to \spadtype{None}.

NoneFunctions1(S:Type): Exports == Implementation where
  Exports ==> with
    coerce: S -> None
      ++ coerce(x) changes \spad{x} into an object of type
      ++ \spadtype{None}.

  Implementation ==> add
    coerce(s:S):None == s pretend None

@
<<NONE1.dotabb>>=
"NONE1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NONE1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"NONE1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NORMMA NormInMonogenicAlgebra}
\pagehead{NormInMonogenicAlgebra}{NORMMA}
\pagepic{ps/v104norminmonogenicalgebra.ps}{NORMMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NORMMA NormInMonogenicAlgebra>>=
)abbrev package NORMMA NormInMonogenicAlgebra
++ Author: Manuel Bronstein
++ Date Created: 23 February 1995
++ Date Last Updated: 23 February 1995
++ Basic Functions: norm
++ Description:
++ This package implements the norm of a polynomial with coefficients
++ in a monogenic algebra (using resultants)

NormInMonogenicAlgebra(R, PolR, E, PolE): Exports == Implementation where
  R: GcdDomain
  PolR: UnivariatePolynomialCategory R
  E: MonogenicAlgebra(R, PolR)
  PolE: UnivariatePolynomialCategory E

  SUP ==> SparseUnivariatePolynomial

  Exports ==> with
    norm: PolE -> PolR
      ++ norm q returns the norm of q,
      ++ i.e. the product of all the conjugates of q.

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, SUP PolR)

    PolR2SUP: PolR -> SUP PolR
    PolR2SUP q == map(#1::PolR, q)

    defpol := PolR2SUP(definingPolynomial()$E)

    norm q ==
      p:SUP PolR := 0
      while q ~= 0 repeat
        p := p + monomial(1,degree q)$PolR * PolR2SUP lift leadingCoefficient q
        q := reductum q
      primitivePart resultant(p, defpol)

@
<<NORMMA.dotabb>>=
"NORMMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NORMMA"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NCNTFRAC NumericContinuedFraction}
\pagehead{NumericContinuedFraction}{NCNTFRAC}
\pagepic{ps/v104numericcontinuedfraction.ps}{NCNTFRAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NCNTFRAC NumericContinuedFraction>>=
)abbrev package NCNTFRAC NumericContinuedFraction
++ Author: Clifton J. Williamson
++ Date Created: 12 April 1990
++ Change History:
++ Basic Operations: continuedFraction
++ Related Constructors: ContinuedFraction, Float
++ Also See: Fraction
++ AMS Classifications: 11J70 11A55 11K50 11Y65 30B70 40A15
++ Keywords: continued fraction
++ References:
++ Description: \spadtype{NumericContinuedFraction} provides functions
++   for converting floating point numbers to continued fractions.

NumericContinuedFraction(F): Exports == Implementation where
  F :     FloatingPointSystem
  CFC ==> ContinuedFraction Integer
  I   ==> Integer
  ST  ==> Stream I

  Exports ==> with
    continuedFraction: F -> CFC
      ++ continuedFraction(f) converts the floating point number
      ++ \spad{f} to a reduced continued fraction.

  Implementation ==> add

    cfc: F -> ST
    cfc(a) == delay
      aa := wholePart a
      zero?(b := a - (aa :: F)) => concat(aa,empty()$ST)
      concat(aa,cfc inv b)

    continuedFraction a ==
      aa := wholePart a
      zero?(b := a - (aa :: F)) =>
        reducedContinuedFraction(aa,empty()$ST) 
      if negative? b then (aa := aa - 1; b := b + 1)
      reducedContinuedFraction(aa,cfc inv b) 

@
<<NCNTFRAC.dotabb>>=
"NCNTFRAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NCNTFRAC"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"NCNTFRAC" -> "FIELD"
"NCNTFRAC" -> "RADCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter O}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ARRAY12 OneDimensionalArrayFunctions2}
\pagehead{OneDimensionalArrayFunctions2}{ARRAY12}
\pagepic{ps/v104onedimensionalarrayfunctions2.ps}{ARRAY12}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ARRAY12 OneDimensionalArrayFunctions2>>=
)abbrev package ARRAY12 OneDimensionalArrayFunctions2
++ This package provides tools for operating on one-dimensional arrays
++ with unary and binary functions involving different underlying types
OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> OneDimensionalArray A
  VB ==> OneDimensionalArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)

  Exports ==> with
   scan   : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of one-dimensional array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1

   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ one-dimensional array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of one-dimensional array
    ++ \spad{a} resulting in a new one-dimensional array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<ARRAY12.dotabb>>=
"ARRAY12" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ARRAY12"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ONECOMP2 OnePointCompletionFunctions2}
\pagehead{OnePointCompletionFunctions2}{ONECOMP2}
\pagepic{ps/v104onepointcompletionfunctions2.ps}{ONECOMP2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ONECOMP2 OnePointCompletionFunctions2>>=
)abbrev package ONECOMP2 OnePointCompletionFunctions2
++ Lifting of maps to one-point completions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to one-point completions.
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
OnePointCompletionFunctions2(R, S): Exports == Implementation where
  R, S: SetCategory

  OPR ==> OnePointCompletion R
  OPS ==> OnePointCompletion S

  Exports ==> with
    map: (R -> S, OPR) -> OPS
      ++ map(f, r) lifts f and applies it to r, assuming that
      ++ f(infinity) = infinity.
    map: (R -> S, OPR, OPS) -> OPS
      ++ map(f, r, i) lifts f and applies it to r, assuming that
      ++ f(infinity) = i.

  Implementation ==> add
    map(f, r) == map(f, r, infinity())

    map(f, r, i) ==
      (u := retractIfCan r) case R => (f(u::R))::OPS
      i

@
<<ONECOMP2.dotabb>>=
"ONECOMP2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ONECOMP2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"ONECOMP2" -> "BASTYPE"
"ONECOMP2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ORDCOMP2 OrderedCompletionFunctions2}
\pagehead{OrderedCompletionFunctions2}{ORDCOMP2}
\pagepic{ps/v104orderedcompletionfunctions2.ps}{ORDCOMP2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ORDCOMP2 OrderedCompletionFunctions2>>=
)abbrev package ORDCOMP2 OrderedCompletionFunctions2
++ Lifting of maps to ordered completions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to ordered completions.
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
OrderedCompletionFunctions2(R, S): Exports == Implementation where
  R, S: SetCategory

  ORR ==> OrderedCompletion R
  ORS ==> OrderedCompletion S

  Exports ==> with
    map: (R -> S, ORR) -> ORS
      ++ map(f, r) lifts f and applies it to r, assuming that
      ++ f(plusInfinity) = plusInfinity and that
      ++ f(minusInfinity) = minusInfinity.
    map: (R -> S, ORR, ORS, ORS) -> ORS
      ++ map(f, r, p, m) lifts f and applies it to r, assuming that
      ++ f(plusInfinity) = p and that f(minusInfinity) = m.

  Implementation ==> add
    map(f, r) == map(f, r, plusInfinity(), minusInfinity())

    map(f, r, p, m) ==
      zero?(n := whatInfinity r) => (f retract r)::ORS
--      one? n => p
      (n = 1) => p
      m

@
<<ORDCOMP2.dotabb>>=
"ORDCOMP2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ORDCOMP2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"ORDCOMP2" -> "BASTYPE"
"ORDCOMP2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OPQUERY OperationsQuery}
\pagehead{OperationsQuery}{OPQUERY}
\pagepic{ps/v104operationsquery.ps}{OPQUERY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OPQUERY OperationsQuery>>=
)abbrev package OPQUERY OperationsQuery
++ This package exports tools to create AXIOM Library information databases.
OperationsQuery(): Exports == Implementation where
  Exports == with
    getDatabase: String -> Database(IndexCard)
      ++ getDatabase("char") returns a list of appropriate entries in the
      ++ browser database.  The legal values for "char" are "o" (operations),
      ++ "k" (constructors), "d" (domains), "c" (categories) or "p" (packages).
  Implementation == add
    getDatabase(s) == getBrowseDatabase(s)$Lisp

@
<<OPQUERY.dotabb>>=
"OPQUERY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OPQUERY"]
"ORDSET" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ORDSET"]
"OPQUERY" -> "ORDSET"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter P}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMASS PatternMatchAssertions}
\pagehead{PatternMatchAssertions}{PMASS}
\pagepic{ps/v104patternmatchassertions.ps}{PMASS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMASS PatternMatchAssertions>>=
)abbrev package PMASS PatternMatchAssertions
++ Assertions for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching assertions to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
PatternMatchAssertions(): Exports == Implementation where
  FE ==> Expression Integer

  Exports ==> with
    assert  : (Symbol, String) -> FE
      ++ assert(x, s) makes the assertion s about x.
    constant: Symbol -> FE
      ++ constant(x) tells the pattern matcher that x should
      ++ match only the symbol 'x and no other quantity.
    optional: Symbol -> FE
      ++ optional(x) tells the pattern matcher that x can match
      ++ an identity (0 in a sum, 1 in a product or exponentiation).;
    multiple: Symbol -> FE
      ++ multiple(x) tells the pattern matcher that x should
      ++ preferably match a multi-term quantity in a sum or product.
      ++ For matching on lists, multiple(x) tells the pattern matcher
      ++ that x should match a list instead of an element of a list.

  Implementation ==> add
    import FunctionSpaceAssertions(Integer, FE)

    constant x   == constant(x::FE)
    multiple x   == multiple(x::FE)
    optional x   == optional(x::FE)
    assert(x, s) == assert(x::FE, s)

@
<<PMASS.dotabb>>=
"PMASS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMASS"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"PMASS" -> "PID"
"PMASS" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PICOERCE PiCoercions}
\pagehead{PiCoercions}{PICOERCE}
\pagepic{ps/v104picoercions.ps}{PICOERCE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PICOERCE PiCoercions>>=
)abbrev package PICOERCE PiCoercions
++ Coercions from %pi to symbolic or numeric domains
++ Author: Manuel Bronstein
++ Description:
++  Provides a coercion from the symbolic fractions in %pi with
++ integer coefficients to any Expression type.
++ Date Created: 21 Feb 1990
++ Date Last Updated: 21 Feb 1990
PiCoercions(R:Join(OrderedSet, IntegralDomain)): with
  coerce: Pi -> Expression R
    ++ coerce(f) returns f as an Expression(R).
 == add
  p2e: SparseUnivariatePolynomial Integer -> Expression R

  coerce(x:Pi):Expression(R) ==
    f := convert(x)@Fraction(SparseUnivariatePolynomial Integer)
    p2e(numer f) / p2e(denom f)

  p2e p ==
    map(#1::Expression(R), p)$SparseUnivariatePolynomialFunctions2(
        Integer, Expression R) (pi()$Expression(R))

@
<<PICOERCE.dotabb>>=
"PICOERCE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PICOERCE"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PICOERCE" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PAN2EXPR PolynomialAN2Expression}
\pagehead{PolynomialAN2Expression}{PAN2EXPR}
\pagepic{ps/v104polynomialan2expression.ps}{PAN2EXPR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PAN2EXPR PolynomialAN2Expression>>=
)abbrev package PAN2EXPR PolynomialAN2Expression
++ Author: Barry Trager
++ Date Created: 8 Oct 1991
++ Description: This package provides a coerce from polynomials over
++ algebraic numbers to \spadtype{Expression AlgebraicNumber}.
PolynomialAN2Expression():Target == Implementation where
  EXPR ==> Expression(Integer)
  AN ==> AlgebraicNumber
  PAN ==> Polynomial AN
  SY ==> Symbol
  Target ==> with
      coerce: Polynomial AlgebraicNumber -> Expression(Integer)
        ++ coerce(p) converts the polynomial \spad{p} with algebraic number
        ++ coefficients to \spadtype{Expression Integer}.
      coerce: Fraction Polynomial AlgebraicNumber -> Expression(Integer)
        ++ coerce(rf) converts \spad{rf}, a fraction of polynomial 
        ++ \spad{p} with
        ++ algebraic number coefficients to \spadtype{Expression Integer}.
  Implementation ==> add
    coerce(p:PAN):EXPR ==
        map(#1::EXPR, #1::EXPR, p)$PolynomialCategoryLifting(
                                  IndexedExponents SY, SY, AN, PAN, EXPR)
    coerce(rf:Fraction PAN):EXPR ==
        numer(rf)::EXPR / denom(rf)::EXPR

@
<<PAN2EXPR.dotabb>>=
"PAN2EXPR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PAN2EXPR"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PAN2EXPR" -> "ACF"
"PAN2EXPR" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PRIMARR2 PrimitiveArrayFunctions2}
\pagehead{PrimitiveArrayFunctions2}{PRIMARR2}
\pagepic{ps/v104primitivearrayfunctions2.ps}{PRIMARR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PRIMARR2 PrimitiveArrayFunctions2>>=
)abbrev package PRIMARR2 PrimitiveArrayFunctions2
++ This package provides tools for operating on primitive arrays
++ with unary and binary functions involving different underlying types
PrimitiveArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> PrimitiveArray A
  VB ==> PrimitiveArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)
  Exports ==> with
   scan : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of primitive array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1
   
   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ primitive array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of primitive array
    ++ \spad{a} resulting in a new primitive array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<PRIMARR2.dotabb>>=
"PRIMARR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PRIMARR2"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Q}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter R}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEFINTRF RationalFunctionDefiniteIntegration}
\pagehead{RationalFunctionDefiniteIntegration}{DEFINTRF}
\pagepic{ps/v104rationalfunctiondefiniteintegration.ps}{DEFINTRF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEFINTRF RationalFunctionDefiniteIntegration>>=
)abbrev package DEFINTRF RationalFunctionDefiniteIntegration
++ Definite integration of rational functions.
++ Author: Manuel Bronstein
++ Date Created: 2 October 1989
++ Date Last Updated: 2 February 1993
++ Description:
++   \spadtype{RationalFunctionDefiniteIntegration} provides functions to
++   compute definite integrals of rational functions.


RationalFunctionDefiniteIntegration(R): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)

  SE  ==> Symbol
  RF  ==> Fraction Polynomial R
  FE  ==> Expression R
  ORF ==> OrderedCompletion RF
  OFE ==> OrderedCompletion FE
  U   ==> Union(f1:OFE, f2:List OFE, fail:"failed", pole:"potentialPole")

  Exports ==> with
    integrate: (RF, SegmentBinding OFE) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (RF, SegmentBinding OFE, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".
-- the following two are contained in the above, but they are for the
-- interpreter... DO NOT COMMENT OUT UNTIL THE INTERPRETER IS BETTER!
    integrate: (RF, SegmentBinding ORF) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (RF, SegmentBinding ORF, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".

  Implementation ==> add
    import DefiniteIntegrationTools(R, FE)
    import IntegrationResultRFToFunction(R)
    import OrderedCompletionFunctions2(RF, FE)

    int   : (RF, SE, OFE, OFE, Boolean) -> U
    nopole: (RF, SE, OFE, OFE) -> U

    integrate(f:RF, s:SegmentBinding OFE) ==
      int(f, variable s, lo segment s, hi segment s, false)

    nopole(f, x, a, b) ==
      k := kernel(x)@Kernel(FE)
      (u := integrate(f, x)) case FE =>
        (v := computeInt(k, u::FE, a, b, true)) case "failed" => ["failed"]
        [v::OFE]
      ans := empty()$List(OFE)
      for g in u::List(FE) repeat
        (v := computeInt(k, g, a, b, true)) case "failed" => return ["failed"]
        ans := concat_!(ans, [v::OFE])
      [ans]

    integrate(f:RF, s:SegmentBinding ORF) ==
      int(f, variable s, map(#1::FE, lo segment s),
                         map(#1::FE, hi segment s), false)

    integrate(f:RF, s:SegmentBinding ORF, str:String) ==
      int(f, variable s, map(#1::FE, lo segment s),
                         map(#1::FE, hi segment s), ignore? str)

    integrate(f:RF, s:SegmentBinding OFE, str:String) ==
      int(f, variable s, lo segment s, hi segment s, ignore? str)

    int(f, x, a, b, ignor?) ==
      a = b => [0::OFE]
      (z := checkForZero(denom f, x, a, b, true)) case "failed" =>
        ignor? => nopole(f, x, a, b)
        ["potentialPole"]
      z::Boolean => error "integrate: pole in path of integration"
      nopole(f, x, a, b)

@
<<DEFINTRF.dotabb>>=
"DEFINTRF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEFINTRF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DEFINTRF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACT RationalFunctionFactor}
\pagehead{RationalFunctionFactor}{RFFACT}
\pagepic{ps/v104rationalfunctionfactor.ps}{RFFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACT RationalFunctionFactor>>=
)abbrev package RFFACT RationalFunctionFactor
++ Factorisation in UP FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients which
++ are rational functions with integer coefficients.

RationalFunctionFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory Fraction Polynomial Integer
 
  SE ==> Symbol
  P  ==> Polynomial Integer
  RF ==> Fraction P
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2
 
  Exports ==> with
    factor: UP -> Factored UP
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    likuniv: (P, SE, P) -> UP
 
    dummy := new()$SE
 
    likuniv(p, x, d) ==
      map(#1 / d, univariate(p, x))$UPCF2(P,SparseUnivariatePolynomial P,
                                          RF, UP)
 
    factor p ==
      d  := denom(q := elt(p,dummy::P :: RF))
      map(likuniv(#1,dummy,d),
          factor(numer q)$MultivariateFactorize(SE,
               IndexedExponents SE,Integer,P))$FactoredFunctions2(P, UP)

@
<<RFFACT.dotabb>>=
"RFFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACTOR RationalFunctionFactorizer}
\pagehead{RationalFunctionFactorizer}{RFFACTOR}
\pagepic{ps/v104rationalfunctionfactorizer.ps}{RFFACTOR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACTOR RationalFunctionFactorizer>>=
)abbrev package RFFACTOR RationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: Fraction, Polynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype{RationalFunctionFactorizer} contains the factor function
++ (called factorFraction) which factors fractions of polynomials by factoring
++ the numerator and denominator. Since any non zero fraction is a unit
++ the usual factor operation will just return the original fraction.

RationalFunctionFactorizer(R) : C == T
 where
  R  :    EuclideanDomain  -- R with factor for R[X]
  P  ==>  Polynomial R
  FP ==>  Fraction P
  SE ==>  Symbol

  C  == with
     factorFraction    : FP  ->   Fraction Factored(P)
       ++ factorFraction(r) factors the numerator and the denominator of
       ++ the polynomial fraction r.
  T  == add

     factorFraction(p:FP) : Fraction Factored(P) ==
       R is Fraction Integer =>
         MR:=MRationalFactorize(IndexedExponents SE,SE,
                                Integer,P)
         (factor(numer p)$MR)/ (factor(denom p)$MR)

       R has FiniteFieldCategory =>
         FF:=MultFiniteFactorize(SE,IndexedExponents SE,R,P)
         (factor(numer p))$FF/(factor(denom p))$FF

       R has CharacteristicZero =>
          MFF:=MultivariateFactorize(SE,IndexedExponents SE,R,P)
          (factor(numer p))$MFF/(factor(denom p))$MFF
       error "case not handled"

@
<<RFFACTOR.dotabb>>=
"RFFACTOR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACTOR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"RFFACTOR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REALSOLV RealSolvePackage}
<<RealSolvePackage.input>>=
-- acplot.spad.pamphlet RealSolvePackage.input
)spool RealSolvePackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 13
p := 4*x^3 - 3*x^2 + 2*x - 4
--R 
--R
--R          3     2
--R   (1)  4x  - 3x  + 2x - 4
--R                                                     Type: Polynomial Integer
--E 1

--S 2 of 13
ans1 := solve(p,0.01)$REALSOLV
--R 
--R
--R   (2)  [1.11328125]
--R                                                             Type: List Float
--E 2

--S 3 of 13
ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV
--R 
--R
--R   (3)  [1.11328125]
--R                                                             Type: List Float
--E 3

--S 4 of 13
R := Integer
--R 
--R
--R   (4)  Integer
--R                                                                 Type: Domain
--E 4

--S 5 of 13
ls : List Symbol := [x,y,z,t]
--R 
--R
--R   (5)  [x,y,z,t]
--R                                                            Type: List Symbol
--E 5

--S 6 of 13
ls2 : List Symbol := [x,y,z,t,new()$Symbol]
--R 
--R
--R   (6)  [x,y,z,t,%A]
--R                                                            Type: List Symbol
--E 6

--S 7 of 13
pack := ZDSOLVE(R,ls,ls2)
--R 
--R
--R   (7)  ZeroDimensionalSolvePackage(Integer,[x,y,z,t],[x,y,z,t,%A])
--R                                                                 Type: Domain
--E 7

--S 8 of 13
p1 := x**2*y*z + y*z
--R 
--R
--R          2
--R   (8)  (x  + 1)y z
--R                                                     Type: Polynomial Integer
--E 8

--S 9 of 13
p2 := x**2*y**2*z + x + z
--R 
--R
--R          2 2
--R   (9)  (x y  + 1)z + x
--R                                                     Type: Polynomial Integer
--E 9

--S 10 of 13
p3 := x**2*y**2*z**2 +  z + 1
--R 
--R
--R          2 2 2
--R   (10)  x y z  + z + 1
--R                                                     Type: Polynomial Integer
--E 10

--S 11 of 13
lp := [p1, p2, p3]
--R 
--R
--R            2           2 2            2 2 2
--R   (11)  [(x  + 1)y z,(x y  + 1)z + x,x y z  + z + 1]
--R                                                Type: List Polynomial Integer
--E 11

--S 12 of 13
lsv:List(Symbol):=[x,y,z]
--R 
--R
--R   (12)  [x,y,z]
--R                                                            Type: List Symbol
--E 12

--S 13 of 13
ans3 := realSolve(lp,lsv,0.01)$REALSOLV
--R 
--R
--R   (13)  [[1.0,0.0,- 1.0]]
--R                                                        Type: List List Float
--E 13
)spool

@
<<RealSolvePackage.help>>=
====================================================================
RealSolvePackage examples
====================================================================

  p := 4*x^3 - 3*x^2 + 2*x - 4

  ans1 := solve(p,0.01)$REALSOLV

  ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV

  R := Integer

  ls : List Symbol := [x,y,z,t]

  ls2 : List Symbol := [x,y,z,t,new()$Symbol]

  pack := ZDSOLVE(R,ls,ls2)

  p1 := x**2*y*z + y*z

  p2 := x**2*y**2*z + x + z

  p3 := x**2*y**2*z**2 +  z + 1

  lp := [p1, p2, p3]

  ans3 := realSolve(lp,[x,y,z],0.01)

See Also:
o )show RealSolvePackage

@
\pagehead{RealSolvePackage}{REALSOLV}
\pagepic{ps/v104realsolvepackage.ps}{REALSOLV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REALSOLV RealSolvePackage>>=
)abbrev package REALSOLV RealSolvePackage

RealSolvePackage(): _
  with

    solve: (Polynomial Fraction Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a
      ++ univariate rational polynomial p with precision eps.

    solve: (Polynomial Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a univariate
      ++ integer polynomial p with precision eps.

    realSolve: (List Polynomial Integer,List Symbol,Float) -> List List Float
      ++ realSolve(lp,lv,eps) = compute the list of the real
      ++ solutions of the list lp of polynomials with integer
      ++ coefficients with respect to the variables in lv,
      ++ with precision eps.

  ==  add

    prn2rfi: Polynomial Fraction Integer -> Fraction Polynomial Integer
    prn2rfi p ==
      map(#1 :: Fraction Polynomial Integer,_
          (numer(#1) :: Fraction Polynomial Integer)_
            /(denom(#1) :: Fraction Polynomial Integer),p)_
             $PolynomialCategoryLifting(IndexedExponents Symbol, _
               Symbol, _
               Fraction Integer, _
               Polynomial Fraction Integer, _
               Fraction Polynomial Integer)

    pi2rfi: Polynomial Integer -> Fraction Polynomial Integer
    pi2rfi p == p :: Fraction Polynomial Integer

    solve(p:Polynomial Fraction Integer,eps:Float) == 
      realRoots(prn2rfi p,eps)$(FloatingRealPackage(Float))

    solve(p:Polynomial Integer,eps:Float) ==
      realRoots(p :: Fraction Polynomial Integer,eps)_
       $(FloatingRealPackage(Float))

    realSolve(lp,lv,eps) ==
      realRoots(map(pi2rfi,lp)_
       $ListFunctions2(Polynomial Integer,Fraction Polynomial Integer),lv,eps)_
        $(FloatingRealPackage(Float))



@
<<REALSOLV.dotabb>>=
"REALSOLV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REALSOLV"]
"REALSOLV" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REPDB RepeatedDoubling}
\pagehead{RepeatedDoubling}{REPDB}
\pagepic{ps/v104repeateddoubling.ps}{REPDB}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REPDB RepeatedDoubling>>=
)abbrev package REPDB RepeatedDoubling
++ Repeated Doubling
++ Integer multiplication by repeated doubling.
++ Description:
++ Implements multiplication by repeated addition
++ RelatedOperations: *
 
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains

)bo PUSH('RepeatedDoubling, $mutableDomains) 

RepeatedDoubling(S):Exports ==Implementation where
   S: SetCategory with 
	"+":(%,%)->%
		++ x+y returns the sum of x and y
   Exports == with
     double: (PositiveInteger,S) -> S 
       ++ double(i, r) multiplies r by i using repeated doubling.
   Implementation == add
     x: S
     n: PositiveInteger
     double(n,x) ==
--        one? n => x
        (n = 1) => x
        odd?(n)$Integer =>
           x + double(shift(n,-1) pretend PositiveInteger,(x+x))
        double(shift(n,-1) pretend PositiveInteger,(x+x))

@
<<REPDB.dotabb>>=
"REPDB" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REPDB"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"REPDB" -> "BASTYPE"
"REPDB" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REPSQ RepeatedSquaring}
\pagehead{RepeatedSquaring}{REPSQ}
\pagepic{ps/v104repeatedsquaring.ps}{REPSQ}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REPSQ RepeatedSquaring>>=
)abbrev package REPSQ RepeatedSquaring
++ Repeated Squaring
++ Description:
++ Implements exponentiation by repeated squaring
++ RelatedOperations: expt
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains

)bo PUSH('RepeatedSquaring, $mutableDomains) 

RepeatedSquaring(S): Exports == Implementation where
   S: SetCategory with 
	"*":(%,%)->%
	     ++ x*y returns the product of x and y
   Exports == with
     expt: (S,PositiveInteger) -> S 
       ++ expt(r, i) computes r**i  by repeated squaring
   Implementation == add
     x: S
     n: PositiveInteger
     expt(x, n) ==
--        one? n => x
        (n = 1) => x
        odd?(n)$Integer=> x * expt(x*x,shift(n,-1) pretend PositiveInteger)
        expt(x*x,shift(n,-1) pretend PositiveInteger)

@
<<REPSQ.dotabb>>=
"REPSQ" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REPSQ"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"REPSQ" -> "BASTYPE"
"REPSQ" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter S}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAEFACT SimpleAlgebraicExtensionAlgFactor}
\pagehead{SimpleAlgebraicExtensionAlgFactor}{SAEFACT}
\pagepic{ps/v104simplealgebraicextensionalgfactor.ps}{SAEFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>=
)abbrev package SAEFACT SimpleAlgebraicExtensionAlgFactor
++ Factorisation in a simple algebraic extension;
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of the rational numbers (\spadtype{Fraction Integer}).
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SimpleAlgebraicExtensionAlgFactor(UP,SAE,UPA):Exports==Implementation where
  UP : UnivariatePolynomialCategory Fraction Integer
  SAE : Join(Field, CharacteristicZero,
                         MonogenicAlgebra(Fraction Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFactorize(UP)
                       )$InnerAlgFactor(Fraction Integer, UP, SAE, UPA)

@
<<SAEFACT.dotabb>>=
"SAEFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAEFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAERFFC SAERationalFunctionAlgFactor}
\pagehead{SAERationalFunctionAlgFactor}{SAERFFC}
\pagepic{ps/v104saerationalfunctionalgfactor.ps}{SAERFFC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAERFFC SAERationalFunctionAlgFactor>>=
)abbrev package SAERFFC SAERationalFunctionAlgFactor
++ Factorisation in UP SAE FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of \spadtype{Fraction Polynomial Integer}.
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SAERationalFunctionAlgFactor(UP, SAE, UPA): Exports == Implementation where
  UP : UnivariatePolynomialCategory Fraction Polynomial Integer
  SAE : Join(Field, CharacteristicZero,
                      MonogenicAlgebra(Fraction Polynomial Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFunctionFactor(UP)
              )$InnerAlgFactor(Fraction Polynomial Integer, UP, SAE, UPA)

@
<<SAERFFC.dotabb>>=
"SAERFFC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAERFFC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUPFRACF SupFractionFactorizer}
\pagehead{SupFractionFactorizer}{SUPFRACF}
\pagepic{ps/v104supfractionfactorizer.ps}{SUPFRACF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUPFRACF SupFractionFactorizer>>=
)abbrev package SUPFRACF SupFractionFactorizer
++ Author: P. Gianni
++ Date Created: October 1993
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  SupFractionFactorize 
++ contains the factor function for univariate 
++ polynomials over the quotient field of a ring S such that the package
++ MultivariateFactorize works for S

SupFractionFactorizer(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   GcdDomain
  P   :   PolynomialCategory(R,E,OV)
  FP  ==> Fraction P
  SUP ==> SparseUnivariatePolynomial 

  C  == with
     factor      : SUP FP   ->  Factored SUP FP
       ++ factor(p) factors the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R.
     squareFree  : SUP FP   ->  Factored SUP FP
       ++ squareFree(p) returns the square-free factorization of the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R. Each factor has no repeated roots and the factors are
       ++ pairwise relatively prime.

  T  == add
     MFACT  ==> MultivariateFactorize(OV,E,R,P)
     MSQFR  ==> MultivariateSquareFree(E,OV,R,P)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     factor(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       R has CharacteristicZero and R has EuclideanDomain =>
         pden : P := lcm [denom c for c in coefficients p]
         pol  : SUP FP := (pden::FP)*p
         ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
         ffact: Factored SUP P := 0
         ffact := factor(ipol)$MFACT
         makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["prime",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])
       squareFree p

     squareFree(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       pden : P := lcm [denom c for c in coefficients p]
       pol  : SUP FP := (pden::FP)*p
       ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
       ffact: Factored SUP P := 0
       if R has CharacteristicZero and R has EuclideanDomain then
         ffact := squareFree(ipol)$MSQFR
       else ffact := squareFree(ipol)
       makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["sqfr",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])

@
<<SUPFRACF.dotabb>>=
"SUPFRACF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUPFRACF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SUPFRACF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SYMFUNC SymmetricFunctions}
\pagehead{SymmetricFunctions}{SYMFUNC}
\pagepic{ps/v104symmetricfunctions.ps}{SYMFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SYMFUNC SymmetricFunctions>>=
)abbrev package SYMFUNC SymmetricFunctions
++ The elementary symmetric functions
++ Author: Manuel Bronstein
++ Date Created: 13 Feb 1989
++ Date Last Updated: 28 Jun 1990
++ Description: Computes all the symmetric functions in n variables.
SymmetricFunctions(R:Ring): Exports == Implementation where
  UP  ==> SparseUnivariatePolynomial R

  Exports ==> with
    symFunc: List R  -> Vector R
      ++ symFunc([r1,...,rn]) returns the vector of the
      ++ elementary symmetric functions in the \spad{ri's}:
      ++ \spad{[r1 + ... + rn, r1 r2 + ... + r(n-1) rn, ..., r1 r2 ... rn]}.
    symFunc: (R, PositiveInteger) -> Vector R
      ++ symFunc(r, n) returns the vector of the elementary
      ++ symmetric functions in \spad{[r,r,...,r]} \spad{n} times.

  Implementation ==> add
    signFix: (UP, NonNegativeInteger) -> Vector R

    symFunc(x, n) == signFix((monomial(1, 1)$UP - x::UP) ** n, 1 + n)

    symFunc l ==
      signFix(*/[monomial(1, 1)$UP - a::UP for a in l], 1 + #l)

    signFix(p, n) ==
      m := minIndex(v := vectorise(p, n)) + 1
      for i in 0..((#v quo 2) - 1)::NonNegativeInteger repeat
        qsetelt_!(v, 2*i + m, - qelt(v, 2*i + m))
      reverse_! v

@
<<SYMFUNC.dotabb>>=
"SYMFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SYMFUNC"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"SYMFUNC" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TANEXP TangentExpansions}
\pagehead{TangentExpansions}{TANEXP}
\pagepic{ps/v104tangentexpansions.ps}{TANEXP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TANEXP TangentExpansions>>=
)abbrev package TANEXP TangentExpansions
++ Expansions of tangents of sums and quotients
++ Author: Manuel Bronstein
++ Date Created: 13 Feb 1989
++ Date Last Updated: 20 Apr 1990
++ Description: Expands tangents of sums and scalar products.
TangentExpansions(R:Field): Exports == Implementation where
  PI ==> PositiveInteger
  Z  ==> Integer
  UP ==> SparseUnivariatePolynomial R
  QF ==> Fraction UP

  Exports ==> with
    tanSum: List R -> R
      ++ tanSum([a1,...,an]) returns \spad{f(a1,...,an)} such that
      ++ if \spad{ai = tan(ui)} then \spad{f(a1,...,an) = tan(u1 + ... + un)}.
    tanAn : (R, PI) -> UP
      ++ tanAn(a, n) returns \spad{P(x)} such that
      ++ if \spad{a = tan(u)} then \spad{P(tan(u/n)) = 0}.
    tanNa : (R,  Z) -> R
      ++ tanNa(a, n) returns \spad{f(a)} such that
      ++ if \spad{a = tan(u)} then \spad{f(a) = tan(n * u)}.

  Implementation ==> add
    import SymmetricFunctions(R)
    import SymmetricFunctions(UP)

    m1toN : Integer -> Integer
    tanPIa: PI -> QF

    m1toN n     == (odd? n => -1; 1)
    tanAn(a, n) == a * denom(q := tanPIa n) - numer q

    tanNa(a, n) ==
      zero? n => 0
      negative? n => - tanNa(a, -n)
      (numer(t := tanPIa(n::PI)) a) / ((denom t) a)

    tanSum l ==
      m := minIndex(v := symFunc l)
      +/[m1toN(i+1) * v(2*i - 1 + m) for i in 1..(#v quo 2)]
        / +/[m1toN(i) * v(2*i + m) for i in 0..((#v - 1) quo 2)]

-- tanPIa(n) returns P(a)/Q(a) such that
-- if a = tan(u) then P(a)/Q(a) = tan(n * u);
    tanPIa n ==
      m := minIndex(v := symFunc(monomial(1, 1)$UP, n))
      +/[m1toN(i+1) * v(2*i - 1 + m) for i in 1..(#v quo 2)]
        / +/[m1toN(i) * v(2*i + m) for i in 0..((#v - 1) quo 2)]

@
<<TANEXP.dotabb>>=
"TANEXP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TANEXP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"TANEXP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAW TopLevelDrawFunctions}
\pagehead{TopLevelDrawFunctions}{DRAW}
\pagepic{ps/v104topleveldrawfunctions.ps}{DRAW}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAW TopLevelDrawFunctions>>=
)abbrev package DRAW TopLevelDrawFunctions
++ Author: Clifton J. Williamson
++ Date Created: 23 January 1990
++ Date Last Updated: October 1991 by Jon Steinbach
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctions provides top level functions for 
++ drawing graphics of expressions.
TopLevelDrawFunctions(Ex:Join(ConvertibleTo InputForm,SetCategory)):
 Exports == Implementation where
  B    ==> Boolean
  BIND ==> SegmentBinding Float
  L    ==> List
  SF   ==> DoubleFloat
  DROP ==> DrawOption

  PPC  ==> ParametricPlaneCurve Ex
  PPCF ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve Ex
  PSCF ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface Ex
  PSFF ==> ParametricSurface((SF,SF) -> SF)
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with

--% Two Dimensional Function Plots

    draw: (Ex,BIND,L DROP) -> VIEW2
      ++ draw(f(x),x = a..b,l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{f(x)} is the 
      ++ default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (Ex,BIND) -> VIEW2
      ++ draw(f(x),x = a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{f(x)} appears 
      ++ in the title bar.

--% Parametric Plane Curves

    draw: (PPC,BIND,L DROP) -> VIEW2
      ++ draw(curve(f(t),g(t)),t = a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}; \spad{(f(t),g(t))} is the default title, and the
      ++ options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (PPC,BIND) -> VIEW2
      ++ draw(curve(f(t),g(t)),t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}; \spad{(f(t),g(t))} appears in the title bar.

--% Parametric Space Curves

    draw: (PSC,BIND,L DROP) -> VIEW3
      ++ draw(curve(f(t),g(t),h(t)),t = a..b,l) draws the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (PSC,BIND) -> VIEW3
      ++ draw(curve(f(t),g(t),h(t)),t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)} as t ranges
      ++ from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)} is the default
      ++ title.
    makeObject: (PSC,BIND,L DROP) -> SPACE3
      ++ makeObject(curve(f(t),g(t),h(t)),t = a..b,l) returns a space of
      ++ the domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject: (PSC,BIND) -> SPACE3
      ++ makeObject(curve(f(t),g(t),h(t)),t = a..b) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)} is
      ++ the default title.

--% Three Dimensional Function Plots

    draw: (Ex,BIND,BIND,L DROP) -> VIEW3
      ++ draw(f(x,y),x = a..b,y = c..d,l) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} is the default
      ++ title, and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (Ex,BIND,BIND) -> VIEW3
      ++ draw(f(x,y),x = a..b,y = c..d) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} appears in the title bar.
    makeObject: (Ex,BIND,BIND,L DROP) -> SPACE3
      ++ makeObject(f(x,y),x = a..b,y = c..d,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of
      ++ \spad{z = f(x,y)} as x ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and y ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)}
      ++ is the default title, and the options contained in the list l of the
      ++ domain \spad{DrawOption} are applied.
    makeObject: (Ex,BIND,BIND) -> SPACE3
      ++ makeObject(f(x,y),x = a..b,y = c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} appears as the
      ++ default title.

--% Parametric Surfaces

    draw: (PSF,BIND,BIND,L DROP) -> VIEW3
      ++ draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (PSF,BIND,BIND) -> VIEW3
      ++ draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title.
    makeObject: (PSF,BIND,BIND,L DROP) -> SPACE3
      ++ makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the graph
      ++ of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject: (PSF,BIND,BIND) -> SPACE3
      ++ makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title.

  Implementation ==> add
    import TopLevelDrawFunctionsForCompiledFunctions
    import MakeFloatCompiledFunction(Ex)
    import ParametricPlaneCurve(SF -> SF)
    import ParametricSpaceCurve(SF -> SF)
    import ParametricSurface((SF,SF) -> SF)
    import ThreeSpace(SF)

------------------------------------------------------------------------
--                     2D - draw's  (given by formulae)
------------------------------------------------------------------------

--% Two Dimensional Function Plots
 
    draw(f:Ex,bind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM2D",l)
        else l := concat(title s,l)
      -- call 'draw'
      draw(makeFloatFunction(f,variable bind),segment bind,l)
 
    draw(f:Ex,bind:BIND) == draw(f,bind,nil())
 
--% Parametric Plane Curves

    draw(ppc:PPC,bind:BIND,l:L DROP) ==
      f := coordinate(ppc,1); g := coordinate(ppc,2)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM2D",l)
        else l := concat(title s,l)
      -- create curve with functions as coordinates
      curve : PPCF := curve(makeFloatFunction(f,variable bind),_
                            makeFloatFunction(g,variable bind))$PPCF
      -- call 'draw'
      draw(curve,segment bind,l)
 
    draw(ppc:PPC,bind:BIND) == draw(ppc,bind,nil())

------------------------------------------------------------------------
--                     3D - Curves  (given by formulas)
------------------------------------------------------------------------

    makeObject(psc:PSC,tBind:BIND,l:L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f,t),_
                            makeFloatFunction(g,t),_
                            makeFloatFunction(h,t))
      -- call 'draw'
      makeObject(curve,tSeg,l)

    makeObject(psc:PSC,tBind:BIND) ==
      makeObject(psc,tBind,nil())

    draw(psc:PSC,tBind:BIND,l:L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f,t),_
                            makeFloatFunction(g,t),_
                            makeFloatFunction(h,t))
      -- call 'draw'
      draw(curve,tSeg,l)

    draw(psc:PSC,tBind:BIND) ==
      draw(psc,tBind,nil())

------------------------------------------------------------------------
--                     3D - Surfaces  (given by formulas)
------------------------------------------------------------------------

--% Three Dimensional Function Plots

    makeObject(f:Ex,xBind:BIND,yBind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'draw'
      makeObject(makeFloatFunction(f,x,y),xSeg,ySeg,l)

    makeObject(f:Ex,xBind:BIND,yBind:BIND) ==
      makeObject(f,xBind,yBind,nil())

    draw(f:Ex,xBind:BIND,yBind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'draw'
      draw(makeFloatFunction(f,x,y),xSeg,ySeg,l)

    draw(f:Ex,xBind:BIND,yBind:BIND) ==
      draw(f,xBind,yBind,nil())

--% parametric surface

    makeObject(s:PSF,uBind:BIND,vBind:BIND,l:L DROP) ==
      f := coordinate(s,1); g := coordinate(s,2); h := coordinate(s,3)
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      surf : PSFF := surface(makeFloatFunction(f,u,v),_
                             makeFloatFunction(g,u,v),_
                             makeFloatFunction(h,u,v))
      makeObject(surf,uSeg,vSeg,l)

    makeObject(s:PSF,uBind:BIND,vBind:BIND) ==
      makeObject(s,uBind,vBind,nil())

    draw(s:PSF,uBind:BIND,vBind:BIND,l:L DROP) ==
      f := coordinate(s,1); g := coordinate(s,2); h := coordinate(s,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      -- create surface with functions as coordinates
      surf : PSFF := surface(makeFloatFunction(f,u,v),_
                             makeFloatFunction(g,u,v),_
                             makeFloatFunction(h,u,v))
      -- call 'draw'
      draw(surf,uSeg,vSeg,l)

    draw(s:PSF,uBind:BIND,vBind:BIND) ==
      draw(s,uBind,vBind,nil())

@
<<DRAW.dotabb>>=
"DRAW" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAW"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DRAW" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves}
\pagehead{TopLevelDrawFunctionsForAlgebraicCurves}{DRAWCURV}
\pagepic{ps/v104topleveldrawfunctionsforalgebraiccurves.ps}{DRAWCURV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves>>=
)abbrev package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves
++ Author: Clifton J. Williamson
++ Date Created: 26 June 1990
++ Date Last Updated:  October 1991 by Jon Steinbach
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForAlgebraicCurves provides top level 
++ functions for drawing non-singular algebraic curves.

TopLevelDrawFunctionsForAlgebraicCurves(R,Ex): Exports == Implementation where
  R  : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  Ex : FunctionSpace(R)

  ANY1  ==> AnyFunctions1
  DROP  ==> DrawOption
  EQ    ==> Equation
  F     ==> Float
  FRAC  ==> Fraction
  I     ==> Integer
  L     ==> List
  P     ==> Polynomial
  RN    ==> Fraction Integer
  SEG   ==> Segment
  SY    ==> Symbol
  VIEW2 ==> TwoDimensionalViewport

  Exports ==> with

    draw: (EQ Ex,SY,SY,L DROP) -> VIEW2
      ++ draw(f(x,y) = g(x,y),x,y,l) draws the graph of a polynomial
      ++ equation.  The list l of draw options must specify a region
      ++ in the plane in which the curve is to sketched.

  Implementation ==> add
    import ViewportPackage
    import PlaneAlgebraicCurvePlot
    import ViewDefaultsPackage
    import GraphicsDefaults
    import DrawOptionFunctions0
    import SegmentFunctions2(RN,F)
    import SegmentFunctions2(F,RN)
    import AnyFunctions1(L SEG RN)

    drawToScaleRanges: (SEG F,SEG F) -> L SEG F
    drawToScaleRanges(xVals,yVals) ==
      -- warning: assumes window is square
      xHi := hi xVals; xLo := lo xVals
      yHi := hi yVals; yLo := lo yVals
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad,xHi + pad),yVals]
      [xVals,segment(yLo - pad,yHi + pad)]

    intConvert: R -> I
    intConvert r ==
      (nn := retractIfCan(r)@Union(I,"failed")) case "failed" =>
        error "draw: polynomial must have rational coefficients"
      nn :: I

    polyEquation: EQ Ex -> P I
    polyEquation eq ==
      ff := lhs(eq) - rhs(eq)
      (r := retractIfCan(ff)@Union(FRAC P R,"failed")) case "failed" =>
        error "draw: not a polynomial equation"
      rat := r :: FRAC P R
      retractIfCan(denom rat)@Union(R,"failed") case "failed" =>
        error "draw: non-constant denominator"
      map(intConvert,numer rat)$PolynomialFunctions2(R,I)

    draw(eq,x,y,l) ==
      -- obtain polynomial equation
      p := polyEquation eq
      -- extract ranges from option list
      floatRange := option(l,"rangeFloat" :: Symbol)
      ratRange := option(l,"rangeRat" :: Symbol)
      (floatRange case "failed") and (ratRange case "failed") =>
        error "draw: you must specify ranges for an implicit plot"
      ranges : L SEG RN := nil()             -- dummy value
      floatRanges : L SEG F := nil()         -- dummy value
      xRange : SEG RN := segment(0,0)        -- dummy value
      yRange : SEG RN := segment(0,0)        -- dummy value
      xRangeFloat : SEG F := segment(0,0)    -- dummy value
      yRangeFloat : SEG F := segment(0,0)    -- dummy value
      if not ratRange case "failed" then
        ranges := retract(ratRange :: Any)$ANY1(L SEG RN)
        not size?(ranges,2) => error "draw: you must specify two ranges"
        xRange := first ranges; yRange := second ranges
        xRangeFloat := map(convert(#1)@Float,xRange)@(SEG F)
        yRangeFloat := map(convert(#1)@Float,yRange)@(SEG F)
        floatRanges := [xRangeFloat,yRangeFloat]
      else
        floatRanges := retract(floatRange :: Any)$ANY1(L SEG F)
        not size?(floatRanges,2) =>
          error "draw: you must specify two ranges"
        xRangeFloat := first floatRanges
        yRangeFloat := second floatRanges
        xRange := map(retract(#1)@RN,xRangeFloat)@(SEG RN)
        yRange := map(retract(#1)@RN,yRangeFloat)@(SEG RN)
        ranges := [xRange,yRange]
      -- create curve plot
      acplot := makeSketch(p,x,y,xRange,yRange)
      -- process scaling information
      if toScale(l,drawToScale()) then
        scaledRanges := drawToScaleRanges(xRangeFloat,yRangeFloat)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges,l)
      else
        -- add ranges to list of options
        l := concat(ranges floatRanges,l)
      -- process color information
      ptCol := pointColorPalette(l,pointColorDefault())
      crCol := curveColorPalette(l,lineColorDefault())
      -- draw
      drawCurves(listBranches acplot,ptCol,crCol,pointSizeDefault(),l)

@
<<DRAWCURV.dotabb>>=
"DRAWCURV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCURV"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"DRAWCURV" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions}
\pagehead{TopLevelDrawFunctionsForCompiledFunctions}{DRAWCFUN}
\pagepic{ps/v104topleveldrawfunctionsforcompiledfunctions.ps}{DRAWCFUN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=
)abbrev package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions
++ Author: Clifton J. Williamson
++ Date Created: 22 June 1990
++ Date Last Updated: January 1992 by Scott Morrison
++ Basic Operations: draw, recolor
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForCompiledFunctions provides top level 
++ functions for drawing graphics of expressions.
TopLevelDrawFunctionsForCompiledFunctions():
 Exports == Implementation where
  ANY1 ==> AnyFunctions1
  B    ==> Boolean
  F    ==> Float
  L    ==> List
  SEG  ==> Segment Float
  SF   ==> DoubleFloat
  DROP ==> DrawOption
  PLOT ==> Plot
  PPC  ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface((SF,SF) -> SF)
  Pt   ==> Point SF
  PSFUN ==> (SF, SF) -> Pt
  PCFUN ==> SF -> Pt
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with

--% Two Dimensional Function Plots

    draw: (SF -> SF,SEG,L DROP) -> VIEW2
      ++ draw(f,a..b,l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (SF -> SF,SEG) -> VIEW2
      ++ draw(f,a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.

--% Parametric Plane Curves

    draw: (PPC,SEG,L DROP) -> VIEW2
      ++ draw(curve(f,g),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (PPC,SEG) -> VIEW2
      ++ draw(curve(f,g),a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}.

--% Parametric Space Curves

    draw: (PSC,SEG,L DROP) -> VIEW3
      ++ draw(curve(f,g,h),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (PSC,SEG) -> VIEW3
      ++ draw(curve(f,g,h),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
    draw: (PCFUN,SEG,L DROP) -> VIEW3
      ++ draw(f,a..b,l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (PCFUN,SEG) -> VIEW3
      ++ draw(f,a..b,l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.

    makeObject: (PSC,SEG,L DROP) -> SPACE3
      ++ makeObject(curve(f,g,h),a..b,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)};
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject: (PSC,SEG) -> SPACE3
      ++ makeObject(sp,curve(f,g,h),a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.
    makeObject: (PCFUN,SEG,L DROP) -> SPACE3
      ++ makeObject(curve(f,g,h),a..b,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject: (PCFUN,SEG) -> SPACE3
      ++ makeObject(sp,curve(f,g,h),a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.

--% Three Dimensional Function Plots

    draw: ((SF,SF) -> SF,SEG,SEG,L DROP) -> VIEW3
      ++ draw(f,a..b,c..d,l) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.
      ++ and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: ((SF,SF) -> SF,SEG,SEG) -> VIEW3
      ++ draw(f,a..b,c..d) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.
    makeObject: ((SF,SF) -> SF,SEG,SEG,L DROP) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}, and the options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: ((SF,SF) -> SF,SEG,SEG) -> SPACE3
      ++ makeObject(f,a..b,c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.

--% Parametric Surfaces

    draw: (PSFUN, SEG, SEG, L DROP) -> VIEW3
      ++ draw(f,a..b,c..d) draws the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    draw: (PSFUN, SEG, SEG) -> VIEW3
      ++ draw(f,a..b,c..d) draws the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}
      ++ The options contained in the list
      ++ l of the domain \spad{DrawOption} are applied.
    makeObject: (PSFUN, SEG, SEG, L DROP) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: (PSFUN, SEG, SEG) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
    draw: (PSF,SEG,SEG,L DROP) -> VIEW3
      ++ draw(surface(f,g,h),a..b,c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    draw: (PSF,SEG,SEG) -> VIEW3
      ++ draw(surface(f,g,h),a..b,c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
    makeObject: (PSF,SEG,SEG,L DROP) -> SPACE3
      ++ makeObject(surface(f,g,h),a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: (PSF,SEG,SEG) -> SPACE3
      ++ makeObject(surface(f,g,h),a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
    recolor: ((SF,SF) -> Pt,(SF,SF,SF) -> SF) -> ((SF,SF) -> Pt)
      ++ recolor(), uninteresting to top level user; exported in order to 
      ++ compile package.

  Implementation ==> add
@
I have had to work my way around the following bug in the compiler:
When a local variable is given a mapping as a value, e.g.
\begin{verbatim}
   foo : SF -> SF := makeFloatFunction(f,t),
\end{verbatim}
the compiler cannot distinguish that local variable from a local
function defined elsewhere in the package.  Thus, when 'foo' is
passed to a function, e.g.
\begin{verbatim}
  bird := fcn(foo),
\end{verbatim}
foo will often be compiled as [[|DRAW;foo|]] rather than [[|foo|]]. This,
of course, causes a run-time error.

To avoid this problem, local variables are not given mappings as
values, but rather (singleton) lists of mappings.  The first element
of the list can always be extracted and everything goes through
as before.  There is no major loss in efficiency, as the computation
of points will always dominate the computation time.\\
\ \ \ \  - cjw,  22 June MCMXC
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    import PLOT
    import TwoDimensionalPlotClipping
    import GraphicsDefaults
    import ViewportPackage
    import ThreeDimensionalViewport
    import DrawOptionFunctions0
    import MakeFloatCompiledFunction(Ex)
    import MeshCreationRoutinesForThreeDimensions
    import SegmentFunctions2(SF,Float)
    import ViewDefaultsPackage
    import AnyFunctions1(Pt -> Pt)
    import AnyFunctions1((SF,SF,SF) -> SF)
    import DrawOptionFunctions0
    import SPACE3

    EXTOVARERROR : String := _
      "draw: when specifying function, left hand side must be a variable"
    SMALLRANGEERROR : String := _
      "draw: range is in interval with only one point"
    DEPVARERROR : String := _
      "draw: independent variable appears on lhs of function definition"

------------------------------------------------------------------------
--                     2D - draw's  
------------------------------------------------------------------------

    drawToScaleRanges: (Segment SF,Segment SF) -> L SEG
    drawToScaleRanges(xVals,yVals) ==
      -- warning: assumes window is square
      xHi := convert(hi xVals)@Float; xLo := convert(lo xVals)@Float
      yHi := convert(hi yVals)@Float; yLo := convert(lo yVals)@Float
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad,xHi + pad),map(convert(#1)@Float,yVals)]
      [map(convert(#1)@Float,xVals),segment(yLo - pad,yHi + pad)]

    drawPlot: (PLOT,L DROP) -> VIEW2
    drawPlot(plot,l) ==
      branches := listBranches plot
      xRange := xRange plot; yRange := yRange plot
      -- process clipping information
      if (cl := option(l,"clipSegment" :: Symbol)) case "failed" then
        if clipBoolean(l,clipPointsDefault()) then
          clipInfo :=
            parametric? plot => clipParametric plot
            clip plot
          branches := clipInfo.brans
          xRange := clipInfo.xValues; yRange := clipInfo.yValues
        else
          "No explicit user-specified clipping"
      else
        segList := retract(cl :: Any)$ANY1(L SEG)
        empty? segList =>
          error "draw: you may specify at least 1 segment for 2D clipping"
        more?(segList,2) =>
          error "draw: you may specify at most 2 segments for 2D clipping"
        xLo : SF := 0; xHi : SF := 0; yLo : SF := 0; yHi : SF := 0
        if empty? rest segList then
          xLo := lo xRange; xHi := hi xRange
          yRangeF := first segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        else
          xRangeF := first segList
          xLo := convert(lo xRangeF)@SF; xHi := convert(hi xRangeF)@SF
          yRangeF := second segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        clipInfo := clipWithRanges(branches,xLo,xHi,yLo,yHi)
        branches := clipInfo.brans
        xRange := clipInfo.xValues; yRange := clipInfo.yValues
      -- process scaling information
      if toScale(l,drawToScale()) then
        scaledRanges := drawToScaleRanges(xRange,yRange)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges,l)
      else
        xRangeFloat : SEG := map(convert(#1)@Float,xRange)
        yRangeFloat : SEG := map(convert(#1)@Float,yRange)
        -- add ranges to list of options
        l := concat(ranges(ll : L SEG := [xRangeFloat,yRangeFloat]),l)
      -- process color information
      ptCol := pointColorPalette(l,pointColorDefault())
      crCol := curveColorPalette(l,lineColorDefault())
      -- draw
      drawCurves(branches,ptCol,crCol,pointSizeDefault(),l)

    normalize: SEG -> Segment SF
    normalize seg ==
      -- normalize [a,b]:
      -- error if a = b, returns [a,b] if a < b, returns [b,a] if b > a
      a := convert(lo seg)@SF; b := convert(hi seg)@SF
      a = b => error SMALLRANGEERROR
      a < b => segment(a,b)
      segment(b,a)

@
The function {\tt myTrap1} is a local function for used in creating
maps SF -> Point SF (two dimensional). The range of this function
is SingleFloat. As originally coded it would return {\tt \$NaNvalue\$Lisp}
which is outside the range. Since this function is only used internallly
by the draw package we handle the ``failed'' case by returning zero.
We handle the out-of-range case by returning the maximum or minimum
SingleFloat value.
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    myTrap1: (SF-> SF, SF) -> SF
    myTrap1(ff:SF-> SF, f:SF):SF ==
      s := trapNumericErrors(ff(f))$Lisp :: Union(SF, "failed")
      s case "failed" => 0
      r:=s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    makePt2: (SF,SF) -> Point SF
    makePt2(x,y) == point(l : List SF := [x,y])

--% Two Dimensional Function Plots
 
    draw(f:SF -> SF,seg:SEG,l:L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l,oldAdaptive))$PLOT
      -- create function SF -> Point SF
      ff : L(SF -> Point SF) := [makePt2(myTrap1(f,#1),#1)]
      -- process change of coordinates
      if (c := option(l,"coordinates" :: Symbol)) case "failed" then
        -- default coordinate transformation
        ff := [makePt2(#1,myTrap1(f,#1))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        ff := [(first cc)((first ff)(#1))]
      -- create PLOT
      pl := pointPlot(first ff,normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- draw
      drawPlot(pl,l)
 
    draw(f:SF -> SF,seg:SEG) == draw(f,seg,nil())
 
--% Parametric Plane Curves

    draw(ppc:PPC,seg:SEG,l:L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l,oldAdaptive))$PLOT
      -- create function SF -> Point SF
      f := coordinate(ppc,1); g := coordinate(ppc,2)
      fcn : L(SF -> Pt) := [makePt2(myTrap1(f,#1),myTrap1(g,#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- draw
      drawPlot(pl,l)
 
    draw(ppc:PPC,seg:SEG) == draw(ppc,seg,nil())

------------------------------------------------------------------------
--                     3D - Curves  
------------------------------------------------------------------------

--% functions for creation of maps SF -> Point SF (three dimensional)

    makePt4: (SF,SF,SF,SF) -> Point SF
    makePt4(x,y,z,c) == point(l : List SF := [x,y,z,c])

--% Parametric Space Curves

    id: SF -> SF
    id x == x

    zCoord: (SF,SF,SF) -> SF
    zCoord(x,y,z) == z

    colorPoints: (List List Pt,(SF,SF,SF) -> SF) -> List List Pt
    colorPoints(llp,func) ==
      for lp in llp repeat for p in lp repeat
        p.4 := func(p.1,p.2,p.3)
      llp

    makeObject(psc:PSC,seg:SEG,l:L DROP) ==
      sp := space l
      -- obtain dependent variable and coordinate functions
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [makePt4(myTrap1(f,#1),myTrap1(g,#1),myTrap1(h,#1),_
                            myTrap1(id,#1))]
      pointsColored? : Boolean := false
      if not (c1 := option(l,"colorFunction1" :: Symbol)) case "failed" then
        pointsColored? := true
        fcn := [makePt4(myTrap1(f,#1),myTrap1(g,#1),myTrap1(h,#1),_
                retract(c1 :: Any)$ANY1(SF -> SF)(#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- draw Tube
--      print(pl::OutputForm)
      option?(l,"tubeRadius" :: Symbol) =>
        pts := tubePoints(l,8)
        rad := convert(tubeRadius(l,0.25))@DoubleFloat
        tub := tube(pl,rad,pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        if not pointsColored? then
          if (c3 := option(l,"colorFunction3" :: Symbol)) case "failed"
            then colorPoints(loops,zCoord)  -- default color function
            else colorPoints(loops,retract(c3 :: Any)$ANY1((SF,SF,SF) -> SF))
        mesh(s,loops,false,false)
        s
      -- draw curve
      br := listBranches pl
      for b in br repeat curve(s,b)
      s

    makeObject(psc:PCFUN,seg:SEG,l:L DROP) ==
      sp := space l
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [psc]
      pointsColored? : Boolean := false
      if not (c1 := option(l,"colorFunction1" :: Symbol)) case "failed" then
        pointsColored? := true
        fcn := [concat(psc(#1), retract(c1 :: Any)$ANY1(SF -> SF)(#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- draw Tube
      option?(l,"tubeRadius" :: Symbol) =>
        pts := tubePoints(l,8)
        rad := convert(tubeRadius(l,0.25))@DoubleFloat
        tub := tube(pl,rad,pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        mesh(s,loops,false,false)
        s
      -- draw curve
      br := listBranches pl
      for b in br repeat curve(s,b)
      s

    makeObject(psc:PSC,seg:SEG) ==
      makeObject(psc,seg,nil())

    makeObject(psc:PCFUN,seg:SEG) ==
      makeObject(psc,seg,nil())

    draw(psc:PSC,seg:SEG,l:L DROP) ==
      sp := makeObject(psc,seg,l)
      makeViewport3D(sp, l)

    draw(psc:PSC,seg:SEG) ==
      draw(psc,seg,nil())

    draw(psc:PCFUN,seg:SEG,l:L DROP) ==
      sp := makeObject(psc,seg,l)
      makeViewport3D(sp, l)

    draw(psc:PCFUN,seg:SEG) ==
      draw(psc,seg,nil())

------------------------------------------------------------------------
--                     3D - Surfaces  
------------------------------------------------------------------------

@
The function {\tt myTrap2} is a local function for used in creating
maps SF -> Point SF (three dimensional). The range of this function
is SingleFloat. As originally coded it would return {\tt \$NaNvalue\$Lisp}
which is outside the range. Since this function is only used internallly
by the draw package we handle the ``failed'' case by returning zero.
We handle the out-of-range case by returning the maximum or minimum
SingleFloat value.
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    myTrap2: ((SF, SF) -> SF, SF, SF) -> SF
    myTrap2(ff:(SF, SF) -> SF, u:SF, v:SF):SF ==
      s := trapNumericErrors(ff(u, v))$Lisp :: Union(SF, "failed")
      s case "failed" => 0
      r:SF := s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    recolor(ptFunc,colFunc) ==
      pt := ptFunc(#1,#2)
      pt.4 := colFunc(pt.1,pt.2,pt.3)
      pt

    xCoord: (SF,SF) -> SF
    xCoord(x,y) == x

--% Three Dimensional Function Plots

    makeObject(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG,l:L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) :=
        [makePt4(myTrap2(f,#1,#2),#1,#2,(first col2)(#1,#2))]
      -- process change of coordinates
      if (c := option(l,"coordinates" :: Symbol)) case "failed" then
        -- default coordinate transformation
        fcn := [makePt4(#1,#2,myTrap2(f,#1,#2),(first col2)(#1,#2))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        c := option(l,"colorFunction3" :: Symbol)
        fcn := 
          c case "failed" => [recolor((first fcn),zCoord)]
          [recolor((first fcn),retract(c :: Any)$ANY1((SF,SF,SF) -> SF))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize xSeg,normalize ySeg,l)
      mesh

    makeObject(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG) ==
      makeObject(f,xSeg,ySeg,nil())

    draw(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG,l:L DROP) ==
      sp := makeObject(f, xSeg, ySeg, l)
      makeViewport3D(sp, l)

    draw(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG) ==
      draw(f,xSeg,ySeg,nil())

--% parametric surface

    makeObject(s:PSF,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      sp := space l
      -- create functions from expressions
      f : L((SF,SF) -> SF) := [coordinate(s,1)]
      g : L((SF,SF) -> SF) := [coordinate(s,2)]
      h : L((SF,SF) -> SF) := [coordinate(s,3)]
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) := 
        [makePt4(myTrap2((first f),#1,#2),myTrap2((first g),#1,#2),myTrap2((first h),#1,#2),_
                 myTrap2((first col2),#1,#2))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        col3 : L((SF,SF,SF) -> SF) := [zCoord]  -- default color function
        if not (c := option(l,"colorFunction3" :: Symbol)) case "failed" then 
          col3 := [retract(c :: Any)$ANY1((SF,SF,SF) -> SF)]
        fcn := [recolor((first fcn),(first col3))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize uSeg,normalize vSeg,l)
      mesh

    makeObject(s:PSFUN,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) := 
        pointsColored? => [concat(s(#1, #2), (first col2)(#1, #2))]
        [s]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize uSeg,normalize vSeg,l)
      mesh

    makeObject(s:PSF,uSeg:SEG,vSeg:SEG) ==
      makeObject(s,uSeg,vSeg,nil())

    draw(s:PSF,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      -- draw
      mesh := makeObject(s,uSeg,vSeg,l)
      makeViewport3D(mesh,l)

    draw(s:PSF,uSeg:SEG,vSeg:SEG) ==
      draw(s,uSeg,vSeg,nil())
 
    makeObject(s:PSFUN,uSeg:SEG,vSeg:SEG) ==
      makeObject(s,uSeg,vSeg,nil())

    draw(s:PSFUN,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      -- draw
      mesh := makeObject(s,uSeg,vSeg,l)
      makeViewport3D(mesh,l)

    draw(s:PSFUN,uSeg:SEG,vSeg:SEG) ==
      draw(s,uSeg,vSeg,nil())
 
@
<<DRAWCFUN.dotabb>>=
"DRAWCFUN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCFUN"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DRAWCFUN" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWPT TopLevelDrawFunctionsForPoints}
\pagehead{TopLevelDrawFunctionsForPoints}{DRAWPT}
\pagepic{ps/v104topleveldrawfunctionsforpoints.ps}{DRAWPT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWPT TopLevelDrawFunctionsForPoints>>=
)abbrev package DRAWPT TopLevelDrawFunctionsForPoints
++ Author: Mike Dewar
++ Date Created: 24 May 1995
++ Date Last Updated: 25 November 1996
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForPoints provides top level functions 
++ for drawing curves and surfaces described by sets of points.
 
TopLevelDrawFunctionsForPoints(): Exports == Implementation where

  DROP  ==> DrawOption
  L     ==> List
  SF    ==> DoubleFloat
  Pt    ==> Point SF
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with
    draw: (L SF,L SF) -> VIEW2
      ++ draw(lx,ly) plots the curve constructed of points (x,y) for x
      ++ in \spad{lx} for y in \spad{ly}.
    draw: (L SF,L SF,L DROP) -> VIEW2
      ++ draw(lx,ly,l) plots the curve constructed of points (x,y) for x
      ++ in \spad{lx} for y in \spad{ly}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (L Pt) -> VIEW2
      ++ draw(lp) plots the curve constructed from the list of points lp.
    draw: (L Pt,L DROP) -> VIEW2
      ++ draw(lp,l) plots the curve constructed from the list of points lp.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (L SF, L SF, L SF) -> VIEW3
      ++ draw(lx,ly,lz) draws the surface constructed by projecting the values
      ++ in the \axiom{lz} list onto the rectangular grid formed by the 
      ++ \axiom{lx X ly}.
    draw: (L SF, L SF, L SF, L DROP) -> VIEW3
      ++ draw(lx,ly,lz,l) draws the surface constructed by 
      ++ projecting the values
      ++ in the \axiom{lz} list onto the rectangular grid formed by the 
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.

  Implementation ==> add

    draw(lp:L Pt,l:L DROP):VIEW2 ==
      makeViewport2D(makeGraphImage([lp])$GraphImage,l)$VIEW2

    draw(lp:L Pt):VIEW2 == draw(lp,[])

    draw(lx: L SF, ly: L SF, l:L DROP):VIEW2 ==
      draw([point([x,y])$Pt for x in lx for y in ly],l)

    draw(lx: L SF, ly: L SF):VIEW2 == draw(lx,ly,[])

    draw(x:L SF,y:L SF,z:L SF):VIEW3 == draw(x,y,z,[])

    draw(x:L SF,y:L SF,z:L SF,l:L DROP):VIEW3 ==
      m  : Integer := #x
      zero? m => error "No X values"
      n  : Integer := #y
      zero? n => error "No Y values"
      zLen : Integer := #z
      zLen ~= (m*n) => 
        zLen > (m*n) => error "Too many Z-values to fit grid"
        error "Not enough Z-values to fit grid"
      points : L L Pt := []
      for j in n..1 by -1 repeat
        row : L Pt := []
        for i in m..1 by -1 repeat
          zval := (j-1)*m+i
          row := cons(point([x.i,y.j,z.zval,z.zval]),row)
        points := cons(row,points)
      makeViewport3D(mesh points,l)

@
<<DRAWPT.dotabb>>=
"DRAWPT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWPT"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"DRAWPT" -> "FIELD"
"DRAWPT" -> "RADCAT"
"DRAWPT" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TRIGMNIP TrigonometricManipulations}
\pagehead{TrigonometricManipulations}{TRIGMNIP}
\pagepic{ps/v104trigonometricmanipulations.ps}{TRIGMNIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TRIGMNIP TrigonometricManipulations>>=
)abbrev package TRIGMNIP TrigonometricManipulations
++ Trigs to/from exps and logs
++ Author: Manuel Bronstein
++ Date Created: 4 April 1988
++ Date Last Updated: 14 February 1994
++ Description:
++   \spadtype{TrigonometricManipulations} provides transformations from
++   trigonometric functions to complex exponentials and logarithms, and back.
++ Keywords: trigonometric, function, manipulation.
TrigonometricManipulations(R, F): Exports == Implementation where
  R : Join(GcdDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  Z   ==> Integer
  SY  ==> Symbol
  K   ==> Kernel F
  FG  ==> Expression Complex R

  Exports ==> with
    complexNormalize: F -> F
      ++ complexNormalize(f) rewrites \spad{f} using the least possible number
      ++ of complex independent kernels.
    complexNormalize: (F, SY) -> F
      ++ complexNormalize(f, x) rewrites \spad{f} using the least possible
      ++ number of complex independent kernels involving \spad{x}.
    complexElementary: F -> F
      ++ complexElementary(f) rewrites \spad{f} in terms of the 2 fundamental
      ++ complex transcendental elementary functions: \spad{log, exp}.
    complexElementary: (F, SY) -> F
      ++ complexElementary(f, x) rewrites the kernels of \spad{f} involving
      ++ \spad{x} in terms of the 2 fundamental complex
      ++ transcendental elementary functions: \spad{log, exp}.
    trigs  : F -> F
      ++ trigs(f) rewrites all the complex logs and exponentials
      ++ appearing in \spad{f} in terms of trigonometric functions.
    real   : F -> F
      ++ real(f) returns the real part of \spad{f} where \spad{f} is a complex
      ++ function.
    imag   : F -> F
      ++ imag(f) returns the imaginary part of \spad{f} where \spad{f}
      ++ is a complex function.
    real?  : F -> Boolean
      ++ real?(f) returns \spad{true} if \spad{f = real f}.
    complexForm: F -> Complex F
      ++ complexForm(f) returns \spad{[real f, imag f]}.

  Implementation ==> add
    import ElementaryFunctionSign(R, F)
    import InnerTrigonometricManipulations(R,F,FG)
    import ElementaryFunctionStructurePackage(R, F)
    import ElementaryFunctionStructurePackage(Complex R, FG)

    s1  := sqrt(-1::F)
    ipi := pi()$F * s1

    K2KG          : K -> Kernel FG
    kcomplex      : K -> Union(F, "failed")
    locexplogs    : F -> FG
    localexplogs  : (F, F, List SY) -> FG
    complexKernels: F -> Record(ker: List K, val: List F)

    K2KG k           == retract(tan F2FG first argument k)@Kernel(FG)
    real? f          == empty?(complexKernels(f).ker)
    real f           == real complexForm f
    imag f           == imag complexForm f

-- returns [[k1,...,kn], [v1,...,vn]] such that ki should be replaced by vi
    complexKernels f ==
      lk:List(K) := empty()
      lv:List(F) := empty()
      for k in tower f repeat
        if (u := kcomplex k) case F then
           lk := concat(k, lk)
           lv := concat(u::F, lv)
      [lk, lv]

-- returns f if it is certain that k is not a real kernel and k = f,
-- "failed" otherwise
    kcomplex k ==
      op := operator k
      is?(k, "nthRoot"::SY) =>
        arg := argument k
        even?(retract(n := second arg)@Z) and ((u := sign(first arg)) case Z)
          and (u::Z < 0) => op(s1, n / 2::F) * op(- first arg, n)
        "failed"
      is?(k, "log"::SY) and ((u := sign(a := first argument k)) case Z)
          and (u::Z < 0) => op(- a) + ipi
      "failed"

    complexForm f ==
      empty?((l := complexKernels f).ker) => complex(f, 0)
      explogs2trigs locexplogs eval(f, l.ker, l.val)

    locexplogs f ==
      any?(has?(#1, "rtrig"),
           operators(g := realElementary f))$List(BasicOperator) =>
              localexplogs(f, g, variables g)
      F2FG g

    complexNormalize(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
               | member?(x, variables(k::F))]$List(K))$List(K) =>
                   FG2F(rischNormalize(localexplogs(f, g, [x]), x).func)
      rischNormalize(g, x).func

    complexNormalize f ==
      l := variables(g := realElementary f)
      any?(has?(#1, "rtrig"), operators g)$List(BasicOperator) =>
        h := localexplogs(f, g, l)
        for x in l repeat h := rischNormalize(h, x).func
        FG2F h
      for x in l repeat g := rischNormalize(g, x).func
      g

    complexElementary(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
                 | member?(x, variables(k::F))]$List(K))$List(K) =>
                     FG2F localexplogs(f, g, [x])
      g

    complexElementary f ==
      any?(has?(#1, "rtrig"),
        operators(g := realElementary f))$List(BasicOperator) =>
          FG2F localexplogs(f, g, variables g)
      g

    localexplogs(f, g, lx) ==
      trigs2explogs(F2FG g, [K2KG k for k in tower f
                          | is?(k, "tan"::SY) or is?(k, "cot"::SY)], lx)

    trigs f ==
      real? f => f
      g := explogs2trigs F2FG f
      real g + s1 * imag g

@
<<TRIGMNIP.dotabb>>=
"TRIGMNIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TRIGMNIP"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"TRIGMNIP" -> "ACF"
"TRIGMNIP" -> "FS"
"TRIGMNIP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CLIP TwoDimensionalPlotClipping}
\pagehead{TwoDimensionalPlotClipping}{CLIP}
\pagepic{ps/v104twodimensionalplotclipping.ps}{CLIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CLIP TwoDimensionalPlotClipping>>=
)abbrev package CLIP TwoDimensionalPlotClipping
++ Automatic clipping for 2-dimensional plots
++ Author: Clifton J. Williamson
++ Date Created: 22 December 1989
++ Date Last Updated: 10 July 1990
++ Keywords: plot, singularity
++ Examples:
++ References:
 
TwoDimensionalPlotClipping(): Exports == Implementation where
  ++ The purpose of this package is to provide reasonable plots of
  ++ functions with singularities.
  B      ==> Boolean
  L      ==> List
  SEG    ==> Segment
  RN     ==> Fraction Integer
  SF     ==> DoubleFloat
  Pt     ==> Point DoubleFloat
  PLOT   ==> Plot
  CLIPPED ==> Record(brans: L L Pt,xValues: SEG SF,yValues: SEG SF)
 
  Exports ==> with
    clip: PLOT -> CLIPPED
      ++ clip(p) performs two-dimensional clipping on a plot, p, from
      ++ the domain \spadtype{Plot} for the graph of one variable,
      ++ \spad{y = f(x)}; the default parameters \spad{1/4} for the fraction 
      ++ and \spad{5/1} for the scale are used in the \spadfun{clip} function.
    clip: (PLOT,RN,RN) -> CLIPPED
      ++ clip(p,frac,sc) performs two-dimensional clipping on a plot, p, 
      ++ from the domain \spadtype{Plot} for the graph of one variable
      ++ \spad{y = f(x)}; the fraction parameter is specified by \spad{frac} 
      ++ and the scale parameter is specified by \spad{sc} for use in the 
      ++ \spadfun{clip} function.
    clipParametric: PLOT -> CLIPPED
      ++ clipParametric(p) performs two-dimensional clipping on a plot,
      ++ p, from the domain \spadtype{Plot} for the parametric curve
      ++ \spad{x = f(t)}, \spad{y = g(t)}; the default parameters \spad{1/2} 
      ++ for the fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this
      ++ function.
    clipParametric: (PLOT,RN,RN) -> CLIPPED
      ++ clipParametric(p,frac,sc) performs two-dimensional clipping on a 
      ++ plot, p, from the domain \spadtype{Plot} for the parametric curve
      ++ \spad{x = f(t)}, \spad{y = g(t)}; the fraction parameter is 
      ++ specified by \spad{frac} and the scale parameter is specified 
      ++ by \spad{sc} for use in the \fakeAxiomFun{iClipParametric} subroutine,
      ++ which is called by this function.
    clipWithRanges: (L L Pt,SF,SF,SF,SF) -> CLIPPED
      ++ clipWithRanges(pointLists,xMin,xMax,yMin,yMax) performs clipping
      ++ on a list of lists of points, \spad{pointLists}.  Clipping is 
      ++ done within the specified ranges of \spad{xMin}, \spad{xMax} and 
      ++ \spad{yMin}, \spad{yMax}.  This function is used internally by 
      ++ the \fakeAxiomFun{iClipParametric} subroutine in this package.
    clip: L Pt -> CLIPPED
      ++ clip(l) performs two-dimensional clipping on a curve l, which is
      ++ a list of points; the default parameters \spad{1/2} for the 
      ++ fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this 
      ++ function.
    clip: L L Pt -> CLIPPED
      ++ clip(ll) performs two-dimensional clipping on a list of lists 
      ++ of points, \spad{ll}; the default parameters \spad{1/2} for
      ++ the fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this 
      ++ function.
 
  Implementation ==> add
    import PointPackage(DoubleFloat)
    import ListFunctions2(Point DoubleFloat,DoubleFloat)
 
    point:(SF,SF) -> Pt
    intersectWithHorizLine:(SF,SF,SF,SF,SF) -> Pt
    intersectWithVertLine:(SF,SF,SF,SF,SF) -> Pt
    intersectWithBdry:(SF,SF,SF,SF,Pt,Pt) -> Pt
    discardAndSplit: (L Pt,Pt -> B,SF,SF,SF,SF) -> L L Pt
    norm: Pt -> SF
    iClipParametric: (L L Pt,RN,RN) -> CLIPPED
    findPt: L L Pt -> Union(Pt,"failed")
    Fnan?: SF ->Boolean
    Pnan?:Pt ->Boolean

    Fnan? x == x~=x
    Pnan? p == any?(Fnan?,p)
   
    iClipParametric(pointLists,fraction,scale) ==
      -- error checks and special cases
      (fraction < 0) or (fraction > 1) =>
        error "clipDraw: fraction should be between 0 and 1"
      empty? pointLists => [nil(),segment(0,0),segment(0,0)]
      -- put all points together , sort them according to norm
      sortedList := sort(norm(#1) < norm(#2),select(not Pnan? #1,concat pointLists))
      empty? sortedList => [nil(),segment(0,0),segment(0,0)]
      n := # sortedList 
      num := numer fraction
      den := denom fraction
      clipNum := (n * num) quo den
      lastN := n - 1 - clipNum
      firstPt := first sortedList
      xMin : SF := xCoord firstPt
      xMax : SF := xCoord firstPt
      yMin : SF := yCoord firstPt 
      yMax : SF := yCoord firstPt
      -- calculate min/max for the first (1-fraction)*N points
      -- this contracts the range
      -- this unnecessarily clips monotonic functions (step-function, x^(high power),etc.)
      for k in 0..lastN  for pt in rest sortedList repeat
        xMin := min(xMin,xCoord pt)
        xMax := max(xMax,xCoord pt)
        yMin := min(yMin,yCoord pt)
        yMax := max(yMax,yCoord pt)
      xDiff := xMax - xMin; yDiff := yMax - yMin
      xDiff = 0 =>
        yDiff = 0 =>
          [pointLists,segment(xMin-1,xMax+1),segment(yMin-1,yMax+1)]
        [pointLists,segment(xMin-1,xMax+1),segment(yMin,yMax)]
      yDiff = 0 =>
        [pointLists,segment(xMin,xMax),segment(yMin-1,yMax+1)]
      numm := numer scale; denn := denom scale
      -- now expand the range by scale
      xMin := xMin - (numm :: SF) * xDiff / (denn :: SF)
      xMax := xMax + (numm :: SF) * xDiff / (denn :: SF)
      yMin := yMin - (numm :: SF) * yDiff / (denn :: SF)
      yMax := yMax + (numm :: SF) * yDiff / (denn :: SF)
      -- clip with the calculated range
      newclip:=clipWithRanges(pointLists,xMin,xMax,yMin,yMax)
      -- if we split the lists use the new clip
      # (newclip.brans) > # pointLists   => newclip
      -- calculate extents
      xs :L SF:= map (xCoord,sortedList)
      ys :L SF:= map (yCoord,sortedList)
      xMin :SF :=reduce (min,xs)
      yMin :SF :=reduce (min,ys)
      xMax :SF :=reduce (max,xs)
      yMax :SF :=reduce (max,ys) 
      xseg:SEG SF :=xMin..xMax
      yseg:SEG SF :=yMin..yMax
      -- return original
      [pointLists,xseg,yseg]@CLIPPED
      


 
    point(xx,yy) == point(l : L SF := [xx,yy])
 
    intersectWithHorizLine(x1,y1,x2,y2,yy) ==
      x1 = x2 => point(x1,yy)
      point(x1 + (x2 - x1)*(yy - y1)/(y2 - y1),yy)
 
    intersectWithVertLine(x1,y1,x2,y2,xx) ==
      y1 = y2 => point(xx,y1)
      point(xx,y1 + (y2 - y1)*(xx - x1)/(x2 - x1))
 
    intersectWithBdry(xMin,xMax,yMin,yMax,pt1,pt2) ==
      -- pt1 is in rectangle, pt2 is not
      x1 := xCoord pt1; y1 := yCoord pt1
      x2 := xCoord pt2; y2 := yCoord pt2
      if y2 > yMax then
        pt2 := intersectWithHorizLine(x1,y1,x2,y2,yMax)
        x2 := xCoord pt2; y2 := yCoord pt2
      if y2 < yMin then
        pt2 := intersectWithHorizLine(x1,y1,x2,y2,yMin)
        x2 := xCoord pt2; y2 := yCoord pt2
      if x2 > xMax then
        pt2 := intersectWithVertLine(x1,y1,x2,y2,xMax)
        x2 := xCoord pt2; y2 := yCoord pt2
      if x2 < xMin then
        pt2 := intersectWithVertLine(x1,y1,x2,y2,xMin)
      pt2
 
    discardAndSplit(pointList,pred,xMin,xMax,yMin,yMax) ==
      ans : L L Pt := nil()
      list : L Pt  := nil()
      lastPt? : B  := false
      lastPt : Pt  := point(0,0)
      while not empty? pointList repeat
        pt := first pointList
        pointList := rest pointList
        pred(pt) =>
          if (empty? list) and lastPt? then
            bdryPt := intersectWithBdry(xMin,xMax,yMin,yMax,pt,lastPt)
            -- print bracket [ coerce bdryPt ,coerce pt ]	
            --list := cons(bdryPt,list)
          list := cons(pt,list)
        if not empty? list then
          bdryPt := intersectWithBdry(xMin,xMax,yMin,yMax,first list,pt)
	  -- print bracket [ coerce bdryPt,coerce first list]	
          --list := cons(bdryPt,list)
          ans := cons( list,ans)
        lastPt := pt 
	lastPt? := true
	list := nil()
      empty? list => ans
      reverse_! cons(reverse_! list,ans)
 
    clip(plot,fraction,scale) ==
--      sayBrightly(["   clip: "::OutputForm]$List(OutputForm))$Lisp
      (fraction < 0) or (fraction > 1/2) =>
        error "clipDraw: fraction should be between 0 and 1/2"
      xVals := xRange plot
      empty?(pointLists := listBranches plot) =>
        [nil(),xVals,segment(0,0)]
      more?(pointLists := listBranches plot,1) =>
        error "clipDraw: plot has more than one branch"
      empty?(pointList := first pointLists) =>
        [nil(),xVals,segment(0,0)]
      sortedList := sort(yCoord(#1) < yCoord(#2),pointList)
      n := # sortedList; num := numer fraction; den := denom fraction
      clipNum := (n * num) quo den
      -- throw out points with large and small y-coordinates
      yMin := yCoord(sortedList.clipNum)
      yMax := yCoord(sortedList.(n - 1 - clipNum))
      if Fnan? yMin then yMin : SF := 0
      if Fnan? yMax then yMax : SF := 0
      (yDiff := yMax - yMin) = 0 =>
        [pointLists,xRange plot,segment(yMin - 1,yMax + 1)]
      numm := numer scale; denn := denom scale
      xMin := lo xVals; xMax := hi xVals
      yMin := yMin - (numm :: SF) * yDiff / (denn :: SF)
      yMax := yMax + (numm :: SF) * yDiff / (denn :: SF)
      lists := discardAndSplit(pointList,_
         (yCoord(#1) < yMax) and (yCoord(#1) > yMin),xMin,xMax,yMin,yMax)
      yMin := yCoord(sortedList.clipNum)
      yMax := yCoord(sortedList.(n - 1 - clipNum))
      if Fnan? yMin then yMin : SF := 0
      if Fnan? yMax then yMax : SF := 0
      for list in lists repeat
        for pt in list repeat
          if not Fnan?(yCoord pt) then
            yMin := min(yMin,yCoord pt)
            yMax := max(yMax,yCoord pt)
      [lists,xVals,segment(yMin,yMax)]
 
    clip(plot:PLOT) == clip(plot,1/4,5/1)
 
    norm(pt) == 
      x := xCoord(pt); y := yCoord(pt)
      if Fnan? x then
        if Fnan? y then
          r:SF := 0
        else
          r:SF := y**2
      else
        if Fnan? y then
          r:SF := x**2
        else
          r:SF := x**2 + y**2
      r
 
    findPt lists ==
      for list in lists repeat
        not empty? list => 
	     for p in list repeat 
               not Pnan? p => return p
      "failed"

    clipWithRanges(pointLists,xMin,xMax,yMin,yMax) ==
      lists : L L Pt := nil()
      for pointList in pointLists repeat
        lists := concat(lists,discardAndSplit(pointList,_
           (xCoord(#1) <= xMax) and (xCoord(#1) >= xMin) and _
           (yCoord(#1) <= yMax) and (yCoord(#1) >= yMin), _
           xMin,xMax,yMin,yMax))
      (pt := findPt lists) case "failed" =>
        [nil(),segment(0,0),segment(0,0)]
      firstPt := pt :: Pt
      xMin : SF := xCoord firstPt; xMax : SF := xCoord firstPt
      yMin : SF := yCoord firstPt; yMax : SF := yCoord firstPt
      for list in lists repeat
        for pt in list repeat
          if not Pnan? pt then
            xMin := min(xMin,xCoord pt)
            xMax := max(xMax,xCoord pt)
            yMin := min(yMin,yCoord pt)
            yMax := max(yMax,yCoord pt)
      [lists,segment(xMin,xMax),segment(yMin,yMax)]
 
    clipParametric(plot,fraction,scale) ==
      iClipParametric(listBranches plot,fraction,scale)
 
    clipParametric plot == clipParametric(plot,1/2,5/1)
 
    clip(l: L Pt)   == iClipParametric(list l,1/2,5/1)
    clip(l: L L Pt) == iClipParametric(l,1/2,5/1)

@
<<CLIP.dotabb>>=
"CLIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CLIP"]
"PTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PTCAT"]
"CLIP" -> "PTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter U}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package UPCDEN UnivariatePolynomialCommonDenominator}
\pagehead{UnivariatePolynomialCommonDenominator}{UPCDEN}
\pagepic{ps/v104univariatepolynomialcommondenominator.ps}{UPCDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package UPCDEN UnivariatePolynomialCommonDenominator>>=
)abbrev package UPCDEN UnivariatePolynomialCommonDenominator
--% UnivariatePolynomialCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Feb 1990
++ Description: UnivariatePolynomialCommonDenominator provides
++ functions to compute the common denominator of the coefficients of
++ univariate polynomials over the quotient field of a gcd domain.
++ Keywords: gcd, quotient, common, denominator, polynomial.
 
UnivariatePolynomialCommonDenominator(R, Q, UP): Exports == Impl where
  R : IntegralDomain
  Q : QuotientFieldCategory R
  UP: UnivariatePolynomialCategory Q
 
  Exports ==> with
    commonDenominator: UP -> R
      ++ commonDenominator(q) returns a common denominator d for
      ++ the coefficients of q.
    clearDenominator : UP -> UP
      ++ clearDenominator(q) returns p such that \spad{q = p/d} where d is
      ++ a common denominator for the coefficients of q.
    splitDenominator : UP -> Record(num: UP, den: R)
      ++ splitDenominator(q) returns \spad{[p, d]} such that \spad{q = p/d} and d
      ++ is a common denominator for the coefficients of q.
 
  Impl ==> add
    import CommonDenominator(R, Q, List Q)
 
    commonDenominator p == commonDenominator coefficients p
 
    clearDenominator p ==
      d := commonDenominator p
      map(numer(d * #1)::Q, p)
 
    splitDenominator p ==
      d := commonDenominator p
      [map(numer(d * #1)::Q, p), d]

@
<<UPCDEN.dotabb>>=
"UPCDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=UPCDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"UPCDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter V}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter W}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter X}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Y}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Z}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chunk collections}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<algebra>>=
<<package AF AlgebraicFunction>>
<<package ALGFACT AlgFactor>>
<<package INTPACK AnnaNumericalIntegrationPackage>>
<<package OPTPACK AnnaNumericalOptimizationPackage>>
<<package ODEPACK AnnaOrdinaryDifferentialEquationPackage>>
<<package PDEPACK AnnaPartialDifferentialEquationPackage>>
<<package ANY1 AnyFunctions1>>
<<package PMPRED AttachPredicates>>
<<package AXSERV AxiomServer>>

<<package BEZOUT BezoutMatrix>>
<<package BRILL BrillhartTests>>

<<package CARTEN2 CartesianTensorFunctions2>>
<<package CHVAR ChangeOfVariable>>
<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>
<<package CHARPOL CharacteristicPolynomialPackage>>
<<package COMBF CombinatorialFunction>>
<<package CDEN CommonDenominator>>
<<package CRFP ComplexRootFindingPackage>>
<<package CMPLXRT ComplexRootPackage>>
<<package CTRIGMNP ComplexTrigonometricManipulations>>
<<package COORDSYS CoordinateSystems>>
<<package CRAPACK CRApackage>>
<<package CYCLES CycleIndicators>>
<<package CYCLOTOM CyclotomicPolynomialPackage>>

<<package DFINTTLS DefiniteIntegrationTools>>
<<package DEGRED DegreeReductionPackage>>
<<package DDFACT DistinctDegreeFactorize>>
<<package DRAWCX DrawComplex>>
<<package DROPT0 DrawOptionFunctions0>>
<<package DROPT1 DrawOptionFunctions1>>
<<package D01AGNT d01AgentsPackage>>
<<package D01WGTS d01WeightsPackage>>
<<package D02AGNT d02AgentsPackage>>
<<package D03AGNT d03AgentsPackage>>

<<package EP EigenPackage>>
<<package EF ElementaryFunction>>
<<package DEFINTEF ElementaryFunctionDefiniteIntegration>>
<<package EFSTRUC ElementaryFunctionStructurePackage>>
<<package EFULS ElementaryFunctionsUnivariateLaurentSeries>>
<<package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries>>
<<package ELFUTS EllipticFunctionsUnivariateTaylorSeries>>
<<package EQ2 EquationFunctions2>>
<<package ERROR ErrorFunctions>>
<<package EVALCYC EvaluateCycleIndicators>>
<<package ESCONT ExpertSystemContinuityPackage>>
<<package ESCONT1 ExpertSystemContinuityPackage1>>
<<package EXPR2 ExpressionFunctions2>>
<<package EXPRODE ExpressionSpaceODESolver>>
<<package EXPR2UPS ExpressionToUnivariatePowerSeries>>
<<package E04AGNT e04AgentsPackage>>

<<package FDIV2 FiniteDivisorFunctions2>>
<<package FLAGG2 FiniteLinearAggregateFunctions2>>
<<package FLASORT FiniteLinearAggregateSort>>
<<package FSAGG2 FiniteSetAggregateFunctions2>>
<<package FRIDEAL2 FractionalIdealFunctions2>>
<<package FFCAT2 FunctionFieldCategoryFunctions2>>
<<package PMASSFS FunctionSpaceAssertions>>
<<package PMPREDFS FunctionSpaceAttachPredicates>>
<<package SUMFS FunctionSpaceSum>>
<<package FSPECF FunctionalSpecialFunction>>

<<package GENMFACT GeneralizedMultivariateFactorize>>

<<package INFINITY Infinity>>
<<package IALGFACT InnerAlgFactor>>
<<package ICDEN InnerCommonDenominator>>
<<package ITRIGMNP InnerTrigonometricManipulations>>
<<package COMBINAT IntegerCombinatoricFunctions>>

<<package MCDEN MatrixCommonDenominator>>
<<package MTHING MergeThing>>
<<package MHROWRED ModularHermitianRowReduction>>
<<package MPCPF MPolyCatPolyFactorizer>>
<<package MPRFF MPolyCatRationalFunctionFactorizer>>
<<package MRATFAC MRationalFactorize>>
<<package MMAP MultipleMap>>

<<package NAGE02 NagFittingPackage>>
<<package NAGD01 NagIntegrationPackage>>
<<package NAGE01 NagInterpolationPackage>>
<<package NAGE04 NagOptimisationPackage>>
<<package NAGD02 NagOrdinaryDifferentialEquationsPackage>>
<<package NAGD03 NagPartialDifferentialEquationsPackage>>
<<package NAGC02 NagPolynomialRootsPackage>>
<<package NAGC05 NagRootFindingPackage>>
<<package NAGC06 NagSeriesSummationPackage>>
<<package NONE1 NoneFunctions1>>
<<package NORMMA NormInMonogenicAlgebra>>
<<package NCNTFRAC NumericContinuedFraction>>

<<package ARRAY12 OneDimensionalArrayFunctions2>>
<<package ONECOMP2 OnePointCompletionFunctions2>>
<<package ORDCOMP2 OrderedCompletionFunctions2>>
<<package OPQUERY OperationsQuery>>

<<package PMASS PatternMatchAssertions>>
<<package PICOERCE PiCoercions>>
<<package PAN2EXPR PolynomialAN2Expression>>
<<package PRIMARR2 PrimitiveArrayFunctions2>>

<<package DEFINTRF RationalFunctionDefiniteIntegration>>
<<package RFFACT RationalFunctionFactor>>
<<package RFFACTOR RationalFunctionFactorizer>>
<<package REALSOLV RealSolvePackage>>
<<package REPDB RepeatedDoubling>>
<<package REPSQ RepeatedSquaring>>

<<package SAERFFC SAERationalFunctionAlgFactor>>
<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>
<<package SUPFRACF SupFractionFactorizer>>
<<package SYMFUNC SymmetricFunctions>>

<<package TANEXP TangentExpansions>>
<<package DRAW TopLevelDrawFunctions>>
<<package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves>>
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>
<<package DRAWPT TopLevelDrawFunctionsForPoints>>
<<package TRIGMNIP TrigonometricManipulations>>
<<package CLIP TwoDimensionalPlotClipping>>

<<package UPCDEN UnivariatePolynomialCommonDenominator>>

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex
\end{document}
