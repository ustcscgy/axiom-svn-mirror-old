\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% pagehead consolidates standard page indexing
%%
\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
\section{#1}
\label{#1}%
\label{#2}%
\index{{#1}}%
\index{{#2}}}%
%%
%% pagepic adds an image and an index entry
%%
\newcommand{\pagepic}[2]{% e.g. \pagepic{pathandfile}{abb}
\includegraphics{#1}%
\index{images!#2}}
%%
%% pageto is a forward link to a referenced page
%%
\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% pageback is a backward link to a referencing page
%%
\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
% special meanings for math characters
\providecommand{\N}{\mbox{\bbold N}}
\providecommand{\Natural}{\mbox{\bbold N}}
\providecommand{\Z}{\mbox{\bbold Z}}
\providecommand{\Integer}{\mbox{\bbold Z}}
\providecommand{\Rational}{\mbox{\bbold Q}}
\providecommand{\Q}{\mbox{\bbold Q}}
\providecommand{\Complex}{\mbox{\bbold C}}
\providecommand{\C}{{\mathcal C}}
\providecommand{\Real}{\mbox{\bbold R}}
\providecommand{\F}{{\mathcal F}}
\providecommand{\R}{{\mathcal R}}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 10: Axiom Algebra: Packages}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\chapter{Chapter Overview}
This book contains the domains in Axiom, in alphabetical order.

Each domain has an associated 'dotpic' chunk which only lists the
domains, categories, and packages that are in the layer immediately
below in the build order. For the full list see the algebra Makefile
where this information is maintained.

Each domain is preceded by a picture. The picture indicates several 
things. The colors indicate whether the name refers to a category,
domain, or package. An ellipse means that the name refers to something
in the bootstrap set. Thus,

\includegraphics[scale=0.85]{ps/v103colorchart.ps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\pagehead{Domain}{ABB}
%\pagepic{ps/v103domain.ps}{ABB}{1.00}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter A}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AF AlgebraicFunction}
\pagehead{AlgebraicFunction}{AF}
\pagepic{ps/v104algebraicfunction.ps}{AF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AF AlgebraicFunction>>=
)abbrev package AF AlgebraicFunction
++ Author: Manuel Bronstein
++ Date Created: 21 March 1988
++ Date Last Updated: 11 November 1993
++ Description:
++   This package provides algebraic functions over an integral domain.
++ Keywords: algebraic, function.

AlgebraicFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  SE  ==> Symbol
  Z   ==> Integer
  Q   ==> Fraction Z
  OP  ==> BasicOperator
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  UPR ==> SparseUnivariatePolynomial R
  ALGOP       ==> "%alg"
  SPECIALDISP ==> "%specialDisp"
  SPECIALDIFF ==> "%specialDiff"

  Exports ==> with
    rootOf  : (UP, SE) -> F
      ++ rootOf(p, y) returns y such that \spad{p(y) = 0}.
      ++ The object returned displays as \spad{'y}.
    operator: OP -> OP
      ++ operator(op) returns a copy of \spad{op} with the domain-dependent
      ++ properties appropriate for \spad{F}.
      ++ Error: if op is not an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    belong? : OP -> Boolean
      ++ belong?(op) is true if \spad{op} is an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    inrootof: (UP, F) -> F
      ++ inrootof(p, x) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    droot : List F -> OutputForm
      ++ droot(l) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    if R has RetractableTo Integer then
      "**"   : (F, Q) -> F
        ++ x ** q is \spad{x} raised to the rational power \spad{q}.
      minPoly: K  -> UP
        ++ minPoly(k) returns the defining polynomial of \spad{k}.
      definingPolynomial: F -> F
        ++ definingPolynomial(f) returns the defining polynomial of \spad{f}
        ++ as an element of \spad{F}.
        ++ Error: if f is not a kernel.
      iroot : (R, Z) -> F
        ++ iroot(p, n) should be a non-exported function.
        -- un-export when the compiler accepts conditional local functions!

  Implementation ==> add
    ialg : List F -> F
    dvalg: (List F, SE) -> F
    dalg : List F -> OutputForm

    opalg  := operator("rootOf"::Symbol)$CommonOperators
    oproot := operator("nthRoot"::Symbol)$CommonOperators

    belong? op == has?(op, ALGOP)
    dalg l     == second(l)::OutputForm

    rootOf(p, x) ==
      k := kernel(x)$K
      (r := retractIfCan(p)@Union(F, "failed")) case "failed" =>
        inrootof(p, k::F)
      n := numer(f := univariate(r::F, k))
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(n, k::F)

    dvalg(l, x) ==
      p := numer univariate(first l, retract(second l)@K)
      alpha := kernel(opalg, l)
      - (map(differentiate(#1, x), p) alpha) / ((differentiate p) alpha)

    ialg l ==
      f := univariate(p := first l, retract(x := second l)@K)
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(numer f, x)

    operator op ==
      is?(op,  "rootOf"::Symbol) => opalg
      is?(op, "nthRoot"::Symbol) => oproot
      error "Unknown operator"

    if R has AlgebraicallyClosedField then
      UP2R: UP -> Union(UPR, "failed")

      inrootof(q, x) ==
        monomial? q => 0

        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d=> - leadingCoefficient(reductum q) / leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) / leadingCoefficient q
        ((rx := retractIfCan(x)@Union(SE, "failed")) case SE) and
          ((r := UP2R q) case UPR) => rootOf(r::UPR, rx::SE)::F
        kernel(opalg, [q x, x])

      UP2R p ==
        ans:UPR := 0
        while p ^= 0 repeat
          (r := retractIfCan(leadingCoefficient p)@Union(R, "failed"))
            case "failed" => return "failed"
          ans := ans + monomial(r::R, degree p)
          p   := reductum p
        ans

    else
      inrootof(q, x) ==
        monomial? q => 0
        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d => - leadingCoefficient(reductum q) /leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) /leadingCoefficient q
        kernel(opalg, [q x, x])

    evaluate(opalg, ialg)$BasicOperatorFunctions1(F)
    setProperty(opalg, SPECIALDIFF,
                              dvalg@((List F, SE) -> F) pretend None)
    setProperty(opalg, SPECIALDISP,
                              dalg@(List F -> OutputForm) pretend None)

    if R has RetractableTo Integer then
      import PolynomialRoots(IndexedExponents K, K, R, P, F)

      dumvar := "%%var"::Symbol::F

      lzero   : List F -> F
      dvroot  : List F -> F
      inroot  : List F -> F
      hackroot: (F, Z) -> F
      inroot0 : (F, Z, Boolean, Boolean) -> F

      lzero l == 0

      droot l ==
        x := first(l)::OutputForm
        (n := retract(second l)@Z) = 2 => root x
        root(x, n::OutputForm)

      dvroot l ==
        n := retract(second l)@Z
        (first(l) ** ((1 - n) / n)) / (n::F)

      x ** q ==
        qr := divide(numer q, denom q)
        x ** qr.quotient * inroot([x, (denom q)::F]) ** qr.remainder

      hackroot(x, n) ==
        (n = 1) or (x = 1) => x
        (((dx := denom x) ^= 1) and
           ((rx := retractIfCan(dx)@Union(Integer,"failed")) case Integer) and
           positive?(rx))
           => hackroot((numer x)::F, n)/hackroot(rx::Integer::F, n)
        (x = -1) and n = 4 =>
          ((-1::F) ** (1::Q / 2::Q) + 1) / ((2::F) ** (1::Q / 2::Q))
        kernel(oproot, [x, n::F])

      inroot l ==
        zero?(n := retract(second l)@Z) => error "root: exponent = 0"
--        one?(x := first l) or one? n => x
        ((x := first l) = 1) or (n = 1) => x
        (r := retractIfCan(x)@Union(R,"failed")) case R => iroot(r::R,n)
        (u := isExpt(x, oproot)) case Record(var:K, exponent:Z) =>
          pr := u::Record(var:K, exponent:Z)
          (first argument(pr.var)) **
              (pr.exponent /$Fraction(Z)
                   (n * retract(second argument(pr.var))@Z))
        inroot0(x, n, false, false)

-- removes powers of positive integers from numer and denom
-- num? or den? is true if numer or denom already processed
      inroot0(x, n, num?, den?) ==
        rn:Union(Z, "failed") := (num? => "failed"; retractIfCan numer x)
        rd:Union(Z, "failed") := (den? => "failed"; retractIfCan denom x)
        (rn case Z) and (rd case Z) =>
          rec := qroot(rn::Z / rd::Z, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)
        rn case Z =>
          rec := qroot(rn::Z::Fraction(Z), n::NonNegativeInteger)
          rec.coef * inroot0((rec.radicand**(n exquo rec.exponent)::Z)
                                / (denom(x)::F), n, true, den?)
        rd case Z =>
          rec := qroot(rd::Z::Fraction(Z), n::NonNegativeInteger)
          inroot0((numer(x)::F) /
                  (rec.radicand ** (n exquo rec.exponent)::Z),
                   n, num?, true) / rec.coef
        hackroot(x, n)

      if R has AlgebraicallyClosedField then iroot(r, n) == nthRoot(r, n)::F
      else
        iroot0: (R, Z) -> F

        if R has RadicalCategory then
          if R has imaginary:() -> R then iroot(r, n) == nthRoot(r, n)::F
          else
            iroot(r, n) ==
              odd? n or r >= 0 => nthRoot(r, n)::F
              iroot0(r, n)

        else iroot(r, n) == iroot0(r, n)

        iroot0(r, n) ==
          rec := rroot(r, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)

      definingPolynomial x ==
        (r := retractIfCan(x)@Union(K, "failed")) case K =>
          is?(k := r::K, opalg) => first argument k
          is?(k, oproot) =>
            dumvar ** retract(second argument k)@Z - first argument k
          dumvar - x
        dumvar - x

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        is?(k, oproot) =>
           monomial(1,retract(second argument k)@Z :: NonNegativeInteger)
             - first(argument k)::UP
        monomial(1, 1) - k::F::UP

      evaluate(oproot, inroot)$BasicOperatorFunctions1(F)
      derivative(oproot, [dvroot, lzero])

    else   -- R is not retractable to Integer
      droot l ==
        x := first(l)::OutputForm
        (n := second l) = 2::F => root x
        root(x, n::OutputForm)

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        monomial(1, 1) - k::F::UP

    setProperty(oproot, SPECIALDISP,
                              droot@(List F -> OutputForm) pretend None)

@
<<AF.dotabb>>=
"AF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AF"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTHERAL AlgebraicHermiteIntegration}
\pagehead{AlgebraicHermiteIntegration}{INTHERAL}
\pagepic{ps/v104algebraichermiteintegration.ps}{INTHERAL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTHERAL AlgebraicHermiteIntegration>>=
)abbrev package INTHERAL AlgebraicHermiteIntegration
++ Hermite integration, algebraic case
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 25 July 1990
++ Description: algebraic Hermite redution.
AlgebraicHermiteIntegration(F,UP,UPUP,R):Exports == Implementation where
  F   : Field
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP
  R   : FunctionFieldCategory(F, UP, UPUP)

  N   ==> NonNegativeInteger
  RF  ==> Fraction UP

  Exports ==> with
    HermiteIntegrate: (R, UP -> UP) -> Record(answer:R, logpart:R)
      ++ HermiteIntegrate(f, ') returns \spad{[g,h]} such that
      ++ \spad{f = g' + h} and h has a only simple finite normal poles.

  Implementation ==> add
    localsolve: (Matrix UP, Vector UP, UP) -> Vector UP

-- the denominator of f should have no prime factor P s.t. P | P'
-- (which happens only for P = t in the exponential case)
    HermiteIntegrate(f, derivation) ==
      ratform:R := 0
      n    := rank()
      m    := transpose((mat:= integralDerivationMatrix derivation).num)
      inum := (cform := integralCoordinates f).num
      if ((iden := cform.den) exquo (e := mat.den)) case "failed" then
        iden := (coef := (e exquo gcd(e, iden))::UP) * iden
        inum := coef * inum
      for trm in factors squareFree iden | (j:= trm.exponent) > 1 repeat
        u':=(u:=(iden exquo (v:=trm.factor)**(j::N))::UP) * derivation v
        sys := ((u * v) exquo e)::UP * m
        nn := minRowIndex sys - minIndex inum
        while j > 1 repeat
          j := j - 1
          p := - j * u'
          sol := localsolve(sys + scalarMatrix(n, p), inum, v)
          ratform := ratform + integralRepresents(sol, v ** (j::N))
          inum    := [((qelt(inum, i) - p * qelt(sol, i) -
                        dot(row(sys, i - nn), sol))
                          exquo v)::UP - u * derivation qelt(sol, i)
                             for i in minIndex inum .. maxIndex inum]
        iden := u * v
      [ratform, integralRepresents(inum, iden)]

    localsolve(mat, vec, modulus) ==
      ans:Vector(UP) := new(nrows mat, 0)
      diagonal? mat =>
        for i in minIndex ans .. maxIndex ans
          for j in minRowIndex mat .. maxRowIndex mat
            for k in minColIndex mat .. maxColIndex mat repeat
              (bc := extendedEuclidean(qelt(mat, j, k), modulus,
                qelt(vec, i))) case "failed" => return new(0, 0)
              qsetelt_!(ans, i, bc.coef1)
        ans
      sol := particularSolution(map(#1::RF, mat)$MatrixCategoryFunctions2(UP,
                         Vector UP, Vector UP, Matrix UP, RF,
                           Vector RF, Vector RF, Matrix RF),
                             map(#1::RF, vec)$VectorFunctions2(UP,
                               RF))$LinearSystemMatrixPackage(RF,
                                        Vector RF, Vector RF, Matrix RF)
      sol case "failed" => new(0, 0)
      for i in minIndex ans .. maxIndex ans repeat
        (bc := extendedEuclidean(denom qelt(sol, i), modulus, 1))
          case "failed" => return new(0, 0)
        qsetelt_!(ans, i, (numer qelt(sol, i) * bc.coef1) rem modulus)
      ans

@
<<INTHERAL.dotabb>>=
"INTHERAL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTHERAL"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"INTHERAL" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTALG AlgebraicIntegrate}
\pagehead{AlgebraicIntegrate}{INTALG}
\pagepic{ps/v104algebraicintegrate.ps}{INTALG}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTALG AlgebraicIntegrate>>=
)abbrev package INTALG AlgebraicIntegrate
++ Integration of an algebraic function
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 19 May 1993
++ Description:
++ This package provides functions for integrating a function
++ on an algebraic curve.
AlgebraicIntegrate(R0, F, UP, UPUP, R): Exports == Implementation where
  R0   : Join(OrderedSet, IntegralDomain, RetractableTo Integer)
  F    : Join(AlgebraicallyClosedField, FunctionSpace R0)
  UP   : UnivariatePolynomialCategory F
  UPUP : UnivariatePolynomialCategory Fraction UP
  R    : FunctionFieldCategory(F, UP, UPUP)

  SE  ==> Symbol
  Z   ==> Integer
  Q   ==> Fraction Z
  SUP ==> SparseUnivariatePolynomial F
  QF  ==> Fraction UP
  GP  ==> LaurentPolynomial(F, UP)
  K   ==> Kernel F
  IR  ==> IntegrationResult R
  UPQ ==> SparseUnivariatePolynomial Q
  UPR ==> SparseUnivariatePolynomial R
  FRQ ==> Factored UPQ
  FD  ==> FiniteDivisor(F, UP, UPUP, R)
  FAC ==> Record(factor:UPQ, exponent:Z)
  LOG ==> Record(scalar:Q, coeff:UPR, logand:UPR)
  DIV ==> Record(num:R, den:UP, derivden:UP, gd:UP)
  FAIL0 ==> error "integrate: implementation incomplete (constant residues)"
  FAIL1==> error "integrate: implementation incomplete (non-algebraic residues)"
  FAIL2 ==> error "integrate: implementation incomplete (residue poly has multiple non-linear factors)"
  FAIL3 ==> error "integrate: implementation incomplete (has polynomial part)"
  NOTI  ==> error "Not integrable (provided residues have no relations)"

  Exports ==> with
    algintegrate  : (R, UP -> UP) -> IR
      ++ algintegrate(f, d) integrates f with respect to the derivation d.
    palgintegrate : (R, UP -> UP) -> IR
      ++ palgintegrate(f, d) integrates f with respect to the derivation d.
      ++ Argument f must be a pure algebraic function.
    palginfieldint: (R, UP -> UP) -> Union(R, "failed")
      ++ palginfieldint(f, d) returns an algebraic function g
      ++ such that \spad{dg = f} if such a g exists, "failed" otherwise.
      ++ Argument f must be a pure algebraic function.

  Implementation ==> add
    import FD
    import DoubleResultantPackage(F, UP, UPUP, R)
    import PointsOfFiniteOrder(R0, F, UP, UPUP, R)
    import AlgebraicHermiteIntegration(F, UP, UPUP, R)
    import InnerCommonDenominator(Z, Q, List Z, List Q)
    import FunctionSpaceUnivariatePolynomialFactor(R0, F, UP)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                         K, R0, SparseMultivariatePolynomial(R0, K), F)

    F2R        : F  -> R
    F2UPR      : F  -> UPR
    UP2SUP     : UP -> SUP
    SUP2UP     : SUP -> UP
    UPQ2F      : UPQ -> UP
    univ       : (F, K) -> QF
    pLogDeriv  : (LOG, R -> R) -> R
    nonLinear  : List FAC -> Union(FAC, "failed")
    mkLog      : (UP, Q, R, F) -> List LOG
    R2UP       : (R, K) -> UPR
    alglogint  : (R, UP -> UP) -> Union(List LOG, "failed")
    palglogint : (R, UP -> UP) -> Union(List LOG, "failed")
    trace00    : (DIV, UP, List LOG) -> Union(List LOG,"failed")
    trace0     : (DIV, UP, Q, FD)    -> Union(List LOG, "failed")
    trace1     : (DIV, UP, List Q, List FD, Q) -> Union(List LOG, "failed")
    nonQ       : (DIV, UP)           -> Union(List LOG, "failed")
    rlift      : (F, K, K) -> R
    varRoot?   : (UP, F -> F) -> Boolean
    algintexp  : (R, UP -> UP) -> IR
    algintprim : (R, UP -> UP) -> IR

    dummy:R := 0

    dumx  := kernel(new()$SE)$K
    dumy  := kernel(new()$SE)$K

    F2UPR f == F2R(f)::UPR
    F2R f   == f::UP::QF::R

    algintexp(f, derivation) ==
      d := (c := integralCoordinates f).den
      v := c.num
      vp:Vector(GP) := new(n := #v, 0)
      vf:Vector(QF) := new(n, 0)
      for i in minIndex v .. maxIndex v repeat
        r := separate(qelt(v, i) / d)$GP
        qsetelt_!(vf, i, r.fracPart)
        qsetelt_!(vp, i, r.polyPart)
      ff := represents(vf, w := integralBasis())
      h := HermiteIntegrate(ff, derivation)
      p := represents(map(convert(#1)@QF, vp)$VectorFunctions2(GP, QF), w)
      zero?(h.logpart) and zero? p => h.answer::IR
      (u := alglogint(h.logpart, derivation)) case "failed" =>
                       mkAnswer(h.answer, empty(), [[p + h.logpart, dummy]])
      zero? p => mkAnswer(h.answer, u::List(LOG), empty())
      FAIL3

    algintprim(f, derivation) ==
      h := HermiteIntegrate(f, derivation)
      zero?(h.logpart) => h.answer::IR
      (u := alglogint(h.logpart, derivation)) case "failed" =>
                       mkAnswer(h.answer, empty(), [[h.logpart, dummy]])
      mkAnswer(h.answer, u::List(LOG), empty())

    -- checks whether f = +/[ci (ui)'/(ui)]
    -- f dx must have no pole at infinity
    palglogint(f, derivation) ==
      rec := algSplitSimple(f, derivation)
      ground?(r := doubleResultant(f, derivation)) => "failed"
-- r(z) has roots which are the residues of f at all its poles
      (u  := qfactor r) case "failed" => nonQ(rec, r)
      (fc := nonLinear(lf := factors(u::FRQ))) case "failed" => FAIL2
-- at this point r(z) = fc(z) (z - b1)^e1 .. (z - bk)^ek
-- where the ri's are rational numbers, and fc(z) is arbitrary
-- (fc can be linear too)
-- la = [b1....,bk]  (all rational residues)
      la := [- coefficient(q.factor, 0) for q in remove_!(fc::FAC, lf)]
-- ld = [D1,...,Dk] where Di is the sum of places where f has residue bi
      ld  := [divisor(rec.num, rec.den, rec.derivden, rec.gd, b::F) for b in la]
      pp  := UPQ2F(fc.factor)
-- bb = - sum of all the roots of fc (i.e. the other residues)
      zero?(bb := coefficient(fc.factor,
           (degree(fc.factor) - 1)::NonNegativeInteger)) =>
              -- cd = [[a1,...,ak], d]  such that bi = ai/d
              cd  := splitDenominator la
              -- g = gcd(a1,...,ak), so bi = (g/d) ci  with ci = bi / g
              -- so [g/d] is a basis for [a1,...,ak] over the integers
              g   := gcd(cd.num)
              -- dv0 is the divisor +/[ci Di] corresponding to all the residues
              -- of f except the ones which are root of fc(z)
              dv0 := +/[(a quo g) * dv for a in cd.num for dv in ld]
              trace0(rec, pp, g / cd.den, dv0)
      trace1(rec, pp, la, ld, bb)


    UPQ2F p ==
      map(#1::F, p)$UnivariatePolynomialCategoryFunctions2(Q,UPQ,F,UP)

    UP2SUP p ==
       map(#1, p)$UnivariatePolynomialCategoryFunctions2(F, UP, F, SUP)

    SUP2UP p ==
       map(#1, p)$UnivariatePolynomialCategoryFunctions2(F, SUP, F, UP)

    varRoot?(p, derivation) ==
      for c in coefficients primitivePart p repeat
        derivation(c) ^= 0 => return true
      false

    pLogDeriv(log, derivation) ==
      map(derivation, log.coeff) ^= 0 =>
                 error "can only handle logs with constant coefficients"
--      one?(n := degree(log.coeff)) =>
      ((n := degree(log.coeff)) = 1) =>
        c := - (leadingCoefficient reductum log.coeff)
             / (leadingCoefficient log.coeff)
        ans := (log.logand) c
        (log.scalar)::R * c * derivation(ans) / ans
      numlog := map(derivation, log.logand)
      (diflog := extendedEuclidean(log.logand, log.coeff, numlog)) case
          "failed" => error "this shouldn't happen"
      algans := diflog.coef1
      ans:R := 0
      for i in 0..n-1 repeat
        algans := (algans * monomial(1, 1)) rem log.coeff
        ans    := ans + coefficient(algans, i)
      (log.scalar)::R * ans

    R2UP(f, k) ==
      x := dumx :: F
      g := (map(#1 x, lift f)$UnivariatePolynomialCategoryFunctions2(QF,
                              UPUP, F, UP)) (y := dumy::F)
      map(rlift(#1, dumx, dumy), univariate(g, k,
         minPoly k))$UnivariatePolynomialCategoryFunctions2(F,SUP,R,UPR)

    univ(f, k) ==
      g := univariate(f, k)
      (SUP2UP numer g) / (SUP2UP denom g)

    rlift(f, kx, ky) ==
      reduce map(univ(#1, kx), retract(univariate(f,
         ky))@SUP)$UnivariatePolynomialCategoryFunctions2(F,SUP,QF,UPUP)

    nonQ(rec, p) ==
      empty? rest(lf := factors ffactor primitivePart p) =>
                       trace00(rec, first(lf).factor, empty()$List(LOG))
      FAIL1

-- case when the irreducible factor p has roots which sum to 0
-- p is assumed doubly transitive for now
    trace0(rec, q, r, dv0) ==
      lg:List(LOG) :=
        zero? dv0 => empty()
        (rc0 := torsionIfCan dv0) case "failed" => NOTI
        mkLog(1, r / (rc0.order::Q), rc0.function, 1)
      trace00(rec, q, lg)

    trace00(rec, pp, lg) ==
      p0 := divisor(rec.num, rec.den, rec.derivden, rec.gd,
                    alpha0 := zeroOf UP2SUP pp)
      q  := (pp exquo (monomial(1, 1)$UP - alpha0::UP))::UP
      alpha := rootOf UP2SUP q
      dvr := divisor(rec.num, rec.den, rec.derivden, rec.gd, alpha) - p0
      (rc := torsionIfCan dvr) case "failed" =>
        degree(pp) <= 2 => "failed"
        NOTI
      concat(lg, mkLog(q, inv(rc.order::Q), rc.function, alpha))

-- case when the irreducible factor p has roots which sum <> 0
-- the residues of f are of the form [a1,...,ak] rational numbers
-- plus all the roots of q(z), which is squarefree
-- la is the list of residues la := [a1,...,ak]
-- ld is the list of divisors [D1,...Dk] where Di is the sum of all the
-- places where f has residue ai
-- q(z) is assumed doubly transitive for now.
-- let [alpha_1,...,alpha_m] be the roots of q(z)
-- in this function, b = - alpha_1 - ... - alpha_m is <> 0
-- which implies only one generic log term
    trace1(rec, q, la, ld, b) ==
-- cd = [[b1,...,bk], d]  such that ai / b = bi / d
      cd  := splitDenominator [a / b for a in la]
-- then, a basis for all the residues of f over the integers is
-- [beta_1 = - alpha_1 / d,..., beta_m = - alpha_m / d], since:
--      alpha_i = - d beta_i
--      ai = (ai / b) * b = (bi / d) * b = b1 * beta_1 + ... + bm * beta_m
-- linear independence is a consequence of the doubly transitive assumption
-- v0 is the divisor +/[bi Di] corresponding to the residues [a1,...,ak]
      v0 := +/[a * dv for a in cd.num for dv in ld]
-- alpha is a generic root of q(z)
      alpha := rootOf UP2SUP q
-- v is the divisor corresponding to all the residues
      v := v0 - cd.den * divisor(rec.num, rec.den, rec.derivden, rec.gd, alpha)
      (rc := torsionIfCan v) case "failed" =>   -- non-torsion case
        degree(q) <= 2 => "failed"       -- guaranteed doubly-transitive
        NOTI                             -- maybe doubly-transitive
      mkLog(q, inv((- rc.order * cd.den)::Q), rc.function, alpha)

    mkLog(q, scalr, lgd, alpha) ==
      degree(q) <= 1 =>
        [[scalr, monomial(1, 1)$UPR - F2UPR alpha, lgd::UPR]]
      [[scalr,
         map(F2R, q)$UnivariatePolynomialCategoryFunctions2(F,UP,R,UPR),
                                           R2UP(lgd, retract(alpha)@K)]]

-- return the non-linear factor, if unique
-- or any linear factor if they are all linear
    nonLinear l ==
      found:Boolean := false
      ans := first l
      for q in l repeat
        if degree(q.factor) > 1 then
          found => return "failed"
          found := true
          ans   := q
      ans

-- f dx must be locally integral at infinity
    palginfieldint(f, derivation) ==
      h := HermiteIntegrate(f, derivation)
      zero?(h.logpart) => h.answer
      "failed"

-- f dx must be locally integral at infinity
    palgintegrate(f, derivation) ==
      h := HermiteIntegrate(f, derivation)
      zero?(h.logpart) => h.answer::IR
      (not integralAtInfinity?(h.logpart)) or
        ((u := palglogint(h.logpart, derivation)) case "failed") =>
                      mkAnswer(h.answer, empty(), [[h.logpart, dummy]])
      zero?(difFirstKind := h.logpart - +/[pLogDeriv(lg,
            differentiate(#1, derivation)) for lg in u::List(LOG)]) =>
                mkAnswer(h.answer, u::List(LOG), empty())
      mkAnswer(h.answer, u::List(LOG), [[difFirstKind, dummy]])

-- for mixed functions. f dx not assumed locally integral at infinity
    algintegrate(f, derivation) ==
      zero? degree(x' := derivation(x := monomial(1, 1)$UP)) =>
         algintprim(f, derivation)
      ((xx := x' exquo x) case UP) and
        (retractIfCan(xx::UP)@Union(F, "failed") case F) =>
          algintexp(f, derivation)
      error "should not happen"

    alglogint(f, derivation) ==
      varRoot?(doubleResultant(f, derivation),
                         retract(derivation(#1::UP))@F) => "failed"
      FAIL0

@
<<INTALG.dotabb>>=
"INTALG" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTALG"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"INTALG" -> "ACF"
"INTALG" -> "FS"
"INTALG" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTAF AlgebraicIntegration}
\pagehead{AlgebraicIntegration}{INTAF}
\pagepic{ps/v104algebraicintegration.ps}{INTAF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTAF AlgebraicIntegration>>=
)abbrev package INTAF AlgebraicIntegration
++ Mixed algebraic integration;
++ Author: Manuel Bronstein
++ Date Created: 12 October 1988
++ Date Last Updated: 4 June 1988
++ Description:
++ This package provides functions for the integration of
++ algebraic integrands over transcendental functions;
AlgebraicIntegration(R, F): Exports == Implementation where
  R : Join(OrderedSet, IntegralDomain)
  F : Join(AlgebraicallyClosedField, FunctionSpace R)

  SY  ==> Symbol
  N   ==> NonNegativeInteger
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  UPUP==> SparseUnivariatePolynomial RF
  IR  ==> IntegrationResult F
  IR2 ==> IntegrationResultFunctions2(curve, F)
  ALG ==> AlgebraicIntegrate(R, F, UP, UPUP, curve)
  FAIL==> error "failed - cannot handle that integrand"

  Exports ==> with
    algint: (F, K, K, UP -> UP) -> IR
      ++ algint(f, x, y, d) returns the integral of \spad{f(x,y)dx}
      ++ where y is an algebraic function of x;
      ++ d is the derivation to use on \spad{k[x]}.

  Implementation ==> add
    import ChangeOfVariable(F, UP, UPUP)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                        K, R, P, F)

    rootintegrate: (F, K, K, UP -> UP) -> IR
    algintegrate : (F, K, K, UP -> UP) -> IR
    UPUP2F       : (UPUP, RF, K, K) -> F
    F2UPUP       : (F, K, K, UP) -> UPUP
    UP2UPUP      : (UP, K) -> UPUP

    F2UPUP(f, kx, k, p) == UP2UPUP(univariate(f, k, p), kx)

    rootintegrate(f, t, k, derivation) ==
      r1     := mkIntegral(modulus := UP2UPUP(p := minPoly k, t))
      f1     := F2UPUP(f, t, k, p) monomial(inv(r1.coef), 1)
      r      := radPoly(r1.poly)::Record(radicand:RF, deg:N)
      q      := retract(r.radicand)
      curve  := RadicalFunctionField(F, UP, UPUP, q::RF, r.deg)
      map(UPUP2F(lift #1, r1.coef, t, k),
                            algintegrate(reduce f1, derivation)$ALG)$IR2

    algintegrate(f, t, k, derivation) ==
      r1     := mkIntegral(modulus := UP2UPUP(p := minPoly k, t))
      f1     := F2UPUP(f, t, k, p) monomial(inv(r1.coef), 1)
      modulus:= UP2UPUP(p := minPoly k, t)
      curve  := AlgebraicFunctionField(F, UP, UPUP, r1.poly)
      map(UPUP2F(lift #1, r1.coef, t, k),
                            algintegrate(reduce f1, derivation)$ALG)$IR2

    UP2UPUP(p, k) ==
      map(univariate(#1,k),p)$SparseUnivariatePolynomialFunctions2(F,RF)

    UPUP2F(p, cf, t, k) ==
      map(multivariate(#1, t),
         p)$SparseUnivariatePolynomialFunctions2(RF, F)
                                            (multivariate(cf, t) * k::F)

    algint(f, t, y, derivation) ==
      is?(y, "nthRoot"::SY) => rootintegrate(f, t, y, derivation)
      is?(y, "rootOf"::SY)  => algintegrate(f, t, y, derivation)
      FAIL

@
<<INTAF.dotabb>>=
"INTAF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTAF"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"INTAF" -> "ACF"
"INTAF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGMANIP AlgebraicManipulations}
\pagehead{AlgebraicManipulations}{ALGMANIP}
\pagepic{ps/v104algebraicmanipulations.ps}{ALGMANIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGMANIP AlgebraicManipulations>>=
)abbrev package ALGMANIP AlgebraicManipulations
++ Author: Manuel Bronstein
++ Date Created: 28 Mar 1988
++ Date Last Updated: 5 August 1993
++ Description:
++ AlgebraicManipulations provides functions to simplify and expand
++ expressions involving algebraic operators.
++ Keywords: algebraic, manipulation.
AlgebraicManipulations(R, F): Exports == Implementation where
  R : IntegralDomain
  F : Join(Field, ExpressionSpace) with
    numer  : $ -> SparseMultivariatePolynomial(R, Kernel $)
	++ numer(x) \undocumented
    denom  : $ -> SparseMultivariatePolynomial(R, Kernel $)
	++ denom(x) \undocumented
    coerce : SparseMultivariatePolynomial(R, Kernel $) -> $
	++ coerce(x) \undocumented

  N  ==> NonNegativeInteger
  Z  ==> Integer
  OP ==> BasicOperator
  SY ==> Symbol
  K  ==> Kernel F
  P  ==> SparseMultivariatePolynomial(R, K)
  RF ==> Fraction P
  REC ==> Record(ker:List K, exponent: List Z)
  ALGOP ==> "%alg"
  NTHR  ==> "nthRoot"

  Exports ==> with
    rootSplit: F -> F
      ++ rootSplit(f) transforms every radical of the form
      ++ \spad{(a/b)**(1/n)} appearing in f into \spad{a**(1/n) / b**(1/n)}.
      ++ This transformation is not in general valid for all
      ++ complex numbers \spad{a} and b.
    ratDenom  : F -> F
      ++ ratDenom(f) rationalizes the denominators appearing in f
      ++ by moving all the algebraic quantities into the numerators.
    ratDenom  : (F, F) -> F
      ++ ratDenom(f, a) removes \spad{a} from the denominators in f
      ++ if \spad{a} is an algebraic kernel.
    ratDenom  : (F, List F) -> F
      ++ ratDenom(f, [a1,...,an]) removes the ai's which are
      ++ algebraic kernels from the denominators in f.
    ratDenom  : (F, List K) -> F
      ++ ratDenom(f, [a1,...,an]) removes the ai's which are
      ++ algebraic from the denominators in f.
    ratPoly  : F -> SparseUnivariatePolynomial F
      ++ ratPoly(f) returns a polynomial p such that p has no
      ++ algebraic coefficients, and \spad{p(f) = 0}.
    if R has Join(OrderedSet, GcdDomain, RetractableTo Integer)
      and F has FunctionSpace(R) then
        rootPower  : F -> F
          ++ rootPower(f) transforms every radical power of the form
          ++ \spad{(a**(1/n))**m} into a simpler form if \spad{m} and
          ++ \spad{n} have a common factor.
        rootProduct: F -> F
          ++ rootProduct(f) combines every product of the form
          ++ \spad{(a**(1/n))**m * (a**(1/s))**t} into a single power
          ++ of a root of \spad{a}, and transforms every radical power
          ++ of the form \spad{(a**(1/n))**m} into a simpler form.
        rootSimp   : F -> F
          ++ rootSimp(f) transforms every radical of the form
          ++ \spad{(a * b**(q*n+r))**(1/n)} appearing in f into
          ++ \spad{b**q * (a * b**r)**(1/n)}.
          ++ This transformation is not in general valid for all
          ++ complex numbers b.
        rootKerSimp: (OP, F, N) -> F
          ++ rootKerSimp(op,f,n) should be local but conditional.

  Implementation ==> add
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,K,R,P,F)

    innerRF    : (F, List K) -> F
    rootExpand : K -> F
    algkernels : List K -> List K
    rootkernels: List K -> List K

    dummy := kernel(new()$SY)$K

    ratDenom x                == innerRF(x, algkernels tower x)
    ratDenom(x:F, l:List K):F == innerRF(x, algkernels l)
    ratDenom(x:F, y:F)        == ratDenom(x, [y])
    ratDenom(x:F, l:List F)   == ratDenom(x, [retract(y)@K for y in l]$List(K))
    algkernels l              == select_!(has?(operator #1, ALGOP), l)
    rootkernels l             == select_!(is?(operator #1, NTHR::SY), l)

    ratPoly x ==
      numer univariate(denom(ratDenom inv(dummy::P::F - x))::F, dummy)

    rootSplit x ==
      lk := rootkernels tower x
      eval(x, lk, [rootExpand k for k in lk])

    rootExpand k ==
      x  := first argument k
      n  := second argument k
      op := operator k
      op(numer(x)::F, n) / op(denom(x)::F, n)

-- all the kernels in ll must be algebraic
    innerRF(x, ll) ==
      empty?(l := sort_!(#1 > #2, kernels x)$List(K)) or
        empty? setIntersection(ll, tower x) => x
      lk := empty()$List(K)
      while not member?(k := first l, ll) repeat
        lk := concat(k, lk)
        empty?(l := rest l) =>
          return eval(x, lk, [map(innerRF(#1, ll), kk) for kk in lk])
      q := univariate(eval(x, lk,
                 [map(innerRF(#1, ll), kk) for kk in lk]), k, minPoly k)
      map(innerRF(#1, ll), q) (map(innerRF(#1, ll), k))

    if R has Join(OrderedSet, GcdDomain, RetractableTo Integer)
     and F has FunctionSpace(R) then
      import PolynomialRoots(IndexedExponents K, K, R, P, F)

      sroot  : K -> F
      inroot : (OP, F, N) -> F
      radeval: (P, K) -> F
      breakup: List K -> List REC

      if R has RadicalCategory then
        rootKerSimp(op, x, n) ==
          (r := retractIfCan(x)@Union(R, "failed")) case R =>
             nthRoot(r::R, n)::F
          inroot(op, x, n)
      else
        rootKerSimp(op, x, n) == inroot(op, x, n)

-- l is a list of nth-roots, returns a list of records of the form
-- [a**(1/n1),a**(1/n2),...], [n1,n2,...]]
-- such that the whole list covers l exactly
      breakup l ==
        empty? l => empty()
        k := first l
        a := first(arg := argument(k := first l))
        n := retract(second arg)@Z
        expo := empty()$List(Z)
        others := same := empty()$List(K)
        for kk in rest l repeat
          if (a = first(arg := argument kk)) then
            same := concat(kk, same)
            expo := concat(retract(second arg)@Z, expo)
          else others := concat(kk, others)
        ll := breakup others
        concat([concat(k, same), concat(n, expo)], ll)

      rootProduct x ==
        for rec in breakup rootkernels tower x repeat
          k0 := first(l := rec.ker)
          nx := numer x; dx := denom x
          if empty? rest l then x := radeval(nx, k0) / radeval(dx, k0)
          else
            n  := lcm(rec.exponent)
            k  := kernel(operator k0, [first argument k0, n::F], height k0)$K
            lv := [monomial(1, k, (n quo m)::N) for m in rec.exponent]$List(P)
            x  := radeval(eval(nx, l, lv), k) / radeval(eval(dx, l, lv), k)
        x

      rootPower x ==
        for k in rootkernels tower x repeat
          x := radeval(numer x, k) / radeval(denom x, k)
        x

-- replaces (a**(1/n))**m in p by a power of a simpler radical of a if
-- n and m have a common factor
      radeval(p, k) ==
        a := first(arg := argument k)
        n := (retract(second arg)@Integer)::NonNegativeInteger
        ans:F := 0
        q := univariate(p, k)
        while (d := degree q) > 0 repeat
          term :=
--            one?(g := gcd(d, n)) => monomial(1, k, d)
            ((g := gcd(d, n)) = 1) => monomial(1, k, d)
            monomial(1, kernel(operator k, [a,(n quo g)::F], height k), d quo g)
          ans := ans + leadingCoefficient(q)::F * term::F
          q := reductum q
        leadingCoefficient(q)::F + ans

      inroot(op, x, n) ==
--        one? x => x
        (x = 1) => x
--        (x ^= -1) and (one?(num := numer x) or (num = -1)) =>
        (x ^= -1) and (((num := numer x) = 1) or (num = -1)) =>
          inv inroot(op, (num * denom x)::F, n)
        (u := isExpt(x, op)) case "failed" => kernel(op, [x, n::F])
        pr := u::Record(var:K, exponent:Integer)
        q := pr.exponent /$Fraction(Z)
                                (n * retract(second argument(pr.var))@Z)
        qr := divide(numer q, denom q)
        x  := first argument(pr.var)
        x ** qr.quotient * rootKerSimp(op,x,denom(q)::N) ** qr.remainder

      sroot k ==
        pr := froot(first(arg := argument k),(retract(second arg)@Z)::N)
        pr.coef * rootKerSimp(operator k, pr.radicand, pr.exponent)

      rootSimp x ==
        lk := rootkernels tower x
        eval(x, lk, [sroot k for k in lk])

@
<<ALGMANIP.dotabb>>=
"ALGMANIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGMANIP"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ALGMANIP" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGMFACT AlgebraicMultFact}
\pagehead{AlgebraicMultFact}{ALGMFACT}
\pagepic{ps/v104algebraicmultfact.ps}{ALGMFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGMFACT AlgebraicMultFact>>=
)abbrev package ALGMFACT AlgebraicMultFact
++ Author: P. Gianni
++ Date Created: 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package factors multivariate polynomials over the
++ domain of \spadtype{AlgebraicNumber} by allowing the user
++ to specify a list of algebraic numbers generating the particular
++ extension to factor over.

AlgebraicMultFact(OV,E,P) : C == T
 where
  AN         ==> AlgebraicNumber
  OV         :   OrderedSet
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(AN,E,OV)
  BP         ==> SparseUnivariatePolynomial AN
  Z            ==> Integer
  MParFact     ==> Record(irr:P,pow:Z)
  USP          ==> SparseUnivariatePolynomial P
  SUParFact    ==> Record(irr:USP,pow:Z)
  SUPFinalFact ==> Record(contp:R,factors:List SUParFact)
  MFinalFact   ==> Record(contp:R,factors:List MParFact)

                 --  contp   =  content,
                 --  factors =  List of irreducible factors with exponent
  L          ==> List

  C == with
    factor      :   (P,L AN)  ->  Factored P
      ++ factor(p,lan) factors the polynomial p over the extension
      ++ generated by the algebraic numbers given by the list lan.
    factor      :   (USP,L AN)  ->  Factored USP
      ++ factor(p,lan) factors the polynomial p over the extension
      ++ generated by the algebraic numbers given by the list lan.
      ++ p is presented as a univariate polynomial with multivariate
      ++ coefficients.
  T == add
    AF := AlgFactor(BP)

    factor(p:P,lalg:L AN) : Factored P ==
      factor(p,factor(#1,lalg)$AF)$InnerMultFact(OV,E,AN,P)

    factor(up:USP,lalg:L AN) : Factored USP ==
      factor(up,factor(#1,lalg)$AF)$InnerMultFact(OV,E,AN,P)

@
<<ALGMFACT.dotabb>>=
"ALGMFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGMFACT"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"ALGMFACT" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGPKG AlgebraPackage}
\pagehead{AlgebraPackage}{ALGPKG}
\pagepic{ps/v104algebrapackage.ps}{ALGPKG}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGPKG AlgebraPackage>>=
)abbrev package ALGPKG AlgebraPackage
++ Authors: J. Grabmeier, R. Wisbauer
++ Date Created: 04 March 1991
++ Date Last Updated: 04 April 1992
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: rank, nucleus, nucloid, structural constants
++ Reference:
++  R.S. Pierce: Associative Algebras
++  Graduate Texts in Mathematics 88
++  Springer-Verlag,  Heidelberg, 1982, ISBN 0-387-90693-2
++
++  R.D. Schafer: An Introduction to Nonassociative Algebras
++  Academic Press, New York, 1966
++
++  A. Woerz-Busekros: Algebra in Genetics
++  Lectures Notes in Biomathematics 36,
++  Springer-Verlag,  Heidelberg, 1980
++ Description:
++  AlgebraPackage assembles a variety of useful functions for
++  general algebras.
AlgebraPackage(R:IntegralDomain, A: FramedNonAssociativeAlgebra(R)): _
   public == private where

  V  ==> Vector
  M  ==> Matrix
  I  ==> Integer
  NNI  ==> NonNegativeInteger
  REC  ==> Record(particular: Union(V R,"failed"),basis: List V R)
  LSMP ==> LinearSystemMatrixPackage(R,V R,V R, M R)

  public ==>  with

      leftRank: A -> NonNegativeInteger
        ++ leftRank(x) determines the number of linearly independent elements
        ++ in \spad{x*b1},...,\spad{x*bn},
        ++ where \spad{b=[b1,...,bn]} is a basis.
      rightRank: A -> NonNegativeInteger
        ++ rightRank(x) determines the number of linearly independent elements
        ++ in \spad{b1*x},...,\spad{bn*x},
        ++ where \spad{b=[b1,...,bn]} is a basis.
      doubleRank: A -> NonNegativeInteger
        ++ doubleRank(x) determines the number of linearly
        ++ independent elements
        ++ in \spad{b1*x},...,\spad{x*bn},
        ++ where \spad{b=[b1,...,bn]} is a basis.
      weakBiRank: A -> NonNegativeInteger
        ++ weakBiRank(x) determines the number of
        ++ linearly independent elements
        ++ in the \spad{bi*x*bj}, \spad{i,j=1,...,n},
        ++ where \spad{b=[b1,...,bn]} is a basis.
      biRank: A -> NonNegativeInteger
        ++ biRank(x) determines the number of linearly independent elements
        ++ in \spad{x}, \spad{x*bi}, \spad{bi*x}, \spad{bi*x*bj},
        ++ \spad{i,j=1,...,n},
        ++ where \spad{b=[b1,...,bn]} is a basis.
        ++ Note: if \spad{A} has a unit,
        ++ then \spadfunFrom{doubleRank}{AlgebraPackage},
        ++ \spadfunFrom{weakBiRank}{AlgebraPackage}
        ++ and \spadfunFrom{biRank}{AlgebraPackage} coincide.
      basisOfCommutingElements: () -> List A
        ++ basisOfCommutingElements() returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = commutator(x,a)} for all
        ++ \spad{a} in \spad{A}.
      basisOfLeftAnnihilator: A -> List A
        ++ basisOfLeftAnnihilator(a) returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = x*a}.
      basisOfRightAnnihilator: A -> List A
        ++ basisOfRightAnnihilator(a) returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = a*x}.
      basisOfLeftNucleus: () -> List A
        ++ basisOfLeftNucleus() returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = associator(x,a,b)}
        ++ for all \spad{a},b in \spad{A}.
      basisOfRightNucleus: () -> List A
        ++ basisOfRightNucleus() returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = associator(a,b,x)}
        ++ for all \spad{a},b in \spad{A}.
      basisOfMiddleNucleus: () -> List A
        ++ basisOfMiddleNucleus() returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{0 = associator(a,x,b)}
        ++ for all \spad{a},b in \spad{A}.
      basisOfNucleus: () -> List A
        ++ basisOfNucleus() returns a basis of the space of 
        ++ all x of \spad{A} satisfying
        ++ \spad{associator(x,a,b) = associator(a,x,b) = associator(a,b,x) = 0}
        ++ for all \spad{a},b in \spad{A}.
      basisOfCenter: () -> List A
        ++ basisOfCenter() returns a basis of the space of
        ++ all x of \spad{A} satisfying \spad{commutator(x,a) = 0} and
        ++ \spad{associator(x,a,b) = associator(a,x,b) = associator(a,b,x) = 0}
        ++ for all \spad{a},b in \spad{A}.
      basisOfLeftNucloid:()-> List Matrix R
        ++ basisOfLeftNucloid() returns a basis of the space of
        ++ endomorphisms of \spad{A} as right module.
        ++ Note: left nucloid coincides with left nucleus 
        ++ if \spad{A} has a unit.
      basisOfRightNucloid:()-> List Matrix R
        ++ basisOfRightNucloid() returns a basis of the space of
        ++ endomorphisms of \spad{A} as left module.
        ++ Note: right nucloid coincides with right nucleus 
        ++ if \spad{A} has a unit.
      basisOfCentroid:()-> List Matrix R
        ++ basisOfCentroid() returns a basis of the centroid, i.e. the
        ++ endomorphism ring of \spad{A} considered as \spad{(A,A)}-bimodule.
      radicalOfLeftTraceForm: () -> List A
        ++ radicalOfLeftTraceForm() returns basis for null space of
        ++ \spad{leftTraceMatrix()}, if the algebra is
        ++ associative, alternative or a Jordan algebra, then this
        ++ space equals the radical (maximal nil ideal) of the algebra.
      if R has EuclideanDomain then
        basis : V A ->  V A
          ++ basis(va) selects a basis from the elements of va.


  private ==>  add

      -- constants

      n  : PositiveInteger := rank()$A
      n2 : PositiveInteger := n*n
      n3 : PositiveInteger := n*n2
      gamma : Vector Matrix R  := structuralConstants()$A


      -- local functions

      convVM : Vector R -> Matrix R
        -- converts n2-vector to (n,n)-matrix row by row
      convMV : Matrix R -> Vector R
        -- converts n-square matrix to  n2-vector row by row
      convVM v  ==
        cond : Matrix(R) := new(n,n,0$R)$M(R)
        z : Integer := 0
        for i in 1..n repeat
          for j in 1..n  repeat
            z := z+1
            setelt(cond,i,j,v.z)
        cond


      -- convMV m ==
      --     vec : Vector(R) := new(n*n,0$R)
      --     z : Integer := 0
      --     for i in 1..n repeat
      --       for j in 1..n  repeat
      --         z := z+1
      --         setelt(vec,z,elt(m,i,j))
      --     vec


      radicalOfLeftTraceForm() ==
        ma : M R := leftTraceMatrix()$A
        map(represents, nullSpace ma)$ListFunctions2(Vector R, A)


      basisOfLeftAnnihilator a ==
        ca : M R := transpose (coordinates(a) :: M R)
        cond : M R := reduce(vertConcat$(M R),
          [ca*transpose(gamma.i) for i in 1..#gamma])
        map(represents, nullSpace cond)$ListFunctions2(Vector R, A)

      basisOfRightAnnihilator a ==
        ca : M R := transpose (coordinates(a) :: M R)
        cond : M R := reduce(vertConcat$(M R),
          [ca*(gamma.i) for i in 1..#gamma])
        map(represents, nullSpace cond)$ListFunctions2(Vector R, A)

      basisOfLeftNucloid() ==
        cond : Matrix(R) := new(n3,n2,0$R)$M(R)
        condo: Matrix(R) := new(n3,n2,0$R)$M(R)
        z : Integer := 0
        for i in 1..n repeat
          for j in 1..n repeat
            r1  : Integer := 0
            for k in 1..n repeat
              z := z + 1
              -- z equals (i-1)*n*n+(j-1)*n+k (loop-invariant)
              r2 : Integer := i
              for r in 1..n repeat
                r1 := r1 + 1
                -- here r1 equals (k-1)*n+r (loop-invariant)
                setelt(cond,z,r1,elt(gamma.r,i,j))
                -- here r2 equals (r-1)*n+i (loop-invariant)
                setelt(condo,z,r2,-elt(gamma.k,r,j))
                r2 := r2 + n
        [convVM(sol) for sol in nullSpace(cond+condo)]

      basisOfCommutingElements() ==
        --gamma1 := first gamma
        --gamma1 := gamma1 - transpose gamma1
        --cond : Matrix(R) := gamma1 :: Matrix(R)
        --for  i in  2..n repeat
        --  gammak := gamma.i
        --  gammak := gammak - transpose gammak
        --  cond :=  vertConcat(cond, gammak :: Matrix(R))$Matrix(R)
        --map(represents, nullSpace cond)$ListFunctions2(Vector R, A)

        cond : M R := reduce(vertConcat$(M R),
          [(gam := gamma.i) - transpose gam for i in 1..#gamma])
        map(represents, nullSpace cond)$ListFunctions2(Vector R, A)

      basisOfLeftNucleus() ==
        condi: Matrix(R) := new(n3,n,0$R)$Matrix(R)
        z : Integer := 0
        for k in 1..n repeat
         for j in 1..n repeat
          for s in 1..n repeat
            z := z+1
            for i in 1..n repeat
              entry : R := 0
              for l in 1..n repeat
                entry :=  entry+elt(gamma.l,j,k)*elt(gamma.s,i,l)_
                               -elt(gamma.l,i,j)*elt(gamma.s,l,k)
              setelt(condi,z,i,entry)$Matrix(R)
        map(represents, nullSpace condi)$ListFunctions2(Vector R,A)

      basisOfRightNucleus() ==
        condo : Matrix(R) := new(n3,n,0$R)$Matrix(R)
        z : Integer := 0
        for k in 1..n repeat
         for j in 1..n repeat
          for s in 1..n repeat
            z := z+1
            for i in 1..n repeat
              entry : R := 0
              for l in 1..n repeat
                entry :=  entry+elt(gamma.l,k,i)*elt(gamma.s,j,l) _
                               -elt(gamma.l,j,k)*elt(gamma.s,l,i)
              setelt(condo,z,i,entry)$Matrix(R)
        map(represents, nullSpace condo)$ListFunctions2(Vector R,A)

      basisOfMiddleNucleus() ==
        conda : Matrix(R) := new(n3,n,0$R)$Matrix(R)
        z : Integer := 0
        for k in 1..n repeat
         for j in 1..n repeat
          for s in 1..n repeat
            z := z+1
            for i in 1..n repeat
              entry : R := 0
              for l in 1..n repeat
                entry :=  entry+elt(gamma.l,j,i)*elt(gamma.s,l,k)
                               -elt(gamma.l,i,k)*elt(gamma.s,j,l)
              setelt(conda,z,i,entry)$Matrix(R)
        map(represents, nullSpace conda)$ListFunctions2(Vector R,A)


      basisOfNucleus() ==
        condi: Matrix(R) := new(3*n3,n,0$R)$Matrix(R)
        z : Integer := 0
        u : Integer := n3
        w : Integer := 2*n3
        for k in 1..n repeat
         for j in 1..n repeat
          for s in 1..n repeat
            z := z+1
            u := u+1
            w := w+1
            for i in 1..n repeat
              entry : R := 0
              enter : R := 0
              ent   : R := 0
              for l in 1..n repeat
                entry :=  entry + elt(gamma.l,j,k)*elt(gamma.s,i,l) _
                                - elt(gamma.l,i,j)*elt(gamma.s,l,k)
                enter :=  enter + elt(gamma.l,k,i)*elt(gamma.s,j,l) _
                                - elt(gamma.l,j,k)*elt(gamma.s,l,i)
                ent :=  ent  +  elt(gamma.l,j,k)*elt(gamma.s,i,l) _
                             -  elt(gamma.l,j,i)*elt(gamma.s,l,k)
              setelt(condi,z,i,entry)$Matrix(R)
              setelt(condi,u,i,enter)$Matrix(R)
              setelt(condi,w,i,ent)$Matrix(R)
        map(represents, nullSpace condi)$ListFunctions2(Vector R,A)

      basisOfCenter() ==
        gamma1 := first gamma
        gamma1 := gamma1 - transpose gamma1
        cond : Matrix(R) := gamma1 :: Matrix(R)
        for  i in  2..n repeat
          gammak := gamma.i
          gammak := gammak - transpose gammak
          cond :=  vertConcat(cond, gammak :: Matrix(R))$Matrix(R)
        B := cond :: Matrix(R)
        condi: Matrix(R) := new(2*n3,n,0$R)$Matrix(R)
        z : Integer := 0
        u : Integer := n3
        for k in 1..n repeat
         for j in 1..n repeat
          for s in 1..n repeat
            z := z+1
            u := u+1
            for i in 1..n repeat
              entry : R := 0
              enter : R := 0
              for l in 1..n repeat
                entry :=  entry + elt(gamma.l,j,k)*elt(gamma.s,i,l) _
                                - elt(gamma.l,i,j)*elt(gamma.s,l,k)
                enter :=  enter + elt(gamma.l,k,i)*elt(gamma.s,j,l) _
                                - elt(gamma.l,j,k)*elt(gamma.s,l,i)
              setelt(condi,z,i,entry)$Matrix(R)
              setelt(condi,u,i,enter)$Matrix(R)
        D := vertConcat(condi,B)$Matrix(R)
        map(represents, nullSpace D)$ListFunctions2(Vector R, A)

      basisOfRightNucloid() ==
        cond : Matrix(R) := new(n3,n2,0$R)$M(R)
        condo: Matrix(R) := new(n3,n2,0$R)$M(R)
        z : Integer := 0
        for i in 1..n repeat
          for j in 1..n repeat
            r1  : Integer := 0
            for k in 1..n repeat
              z := z + 1
              -- z equals (i-1)*n*n+(j-1)*n+k (loop-invariant)
              r2 : Integer := i
              for r in 1..n repeat
                r1 := r1 + 1
                -- here r1 equals (k-1)*n+r (loop-invariant)
                setelt(cond,z,r1,elt(gamma.r,j,i))
                -- here r2 equals (r-1)*n+i (loop-invariant)
                setelt(condo,z,r2,-elt(gamma.k,j,r))
                r2 := r2 + n
        [convVM(sol) for sol in nullSpace(cond+condo)]

      basisOfCentroid() ==
        cond : Matrix(R) := new(2*n3,n2,0$R)$M(R)
        condo: Matrix(R) := new(2*n3,n2,0$R)$M(R)
        z : Integer := 0
        u : Integer := n3
        for i in 1..n repeat
          for j in 1..n repeat
            r1  : Integer := 0
            for k in 1..n repeat
              z := z + 1
              u := u + 1
              -- z equals (i-1)*n*n+(j-1)*n+k (loop-invariant)
              -- u equals n**3 + (i-1)*n*n+(j-1)*n+k (loop-invariant)
              r2 : Integer := i
              for r in 1..n repeat
                r1 := r1 + 1
                -- here r1 equals (k-1)*n+r (loop-invariant)
                setelt(cond,z,r1,elt(gamma.r,i,j))
                setelt(cond,u,r1,elt(gamma.r,j,i))
                -- here r2 equals (r-1)*n+i (loop-invariant)
                setelt(condo,z,r2,-elt(gamma.k,r,j))
                setelt(condo,u,r2,-elt(gamma.k,j,r))
                r2 := r2 + n
        [convVM(sol) for sol in nullSpace(cond+condo)]


      doubleRank x ==
        cond : Matrix(R) := new(2*n,n,0$R)
        for k in 1..n repeat
         z : Integer := 0
         u : Integer := n
         for j in 1..n repeat
           z := z+1
           u := u+1
           entry : R := 0
           enter : R := 0
           for i in 1..n repeat
             entry := entry + elt(x,i)*elt(gamma.k,j,i)
             enter := enter + elt(x,i)*elt(gamma.k,i,j)
           setelt(cond,z,k,entry)$Matrix(R)
           setelt(cond,u,k,enter)$Matrix(R)
        rank(cond)$(M R)

      weakBiRank(x) ==
        cond : Matrix(R) := new(n2,n,0$R)$Matrix(R)
        z : Integer := 0
        for i in 1..n repeat
          for j in 1..n repeat
            z := z+1
            for k in 1..n repeat
              entry : R := 0
              for l in 1..n repeat
               for s in 1..n repeat
                entry:=entry+elt(x,l)*elt(gamma.s,i,l)*elt(gamma.k,s,j)
              setelt(cond,z,k,entry)$Matrix(R)
        rank(cond)$(M R)

      biRank(x) ==
        cond : Matrix(R) := new(n2+2*n+1,n,0$R)$Matrix(R)
        z : Integer := 0
        for j in 1..n repeat
          for i in 1..n repeat
            z := z+1
            for k in 1..n repeat
              entry : R := 0
              for l in 1..n repeat
               for s in 1..n repeat
                entry:=entry+elt(x,l)*elt(gamma.s,i,l)*elt(gamma.k,s,j)
              setelt(cond,z,k,entry)$Matrix(R)
        u : Integer := n*n
        w : Integer := n*(n+1)
        c := n2 + 2*n + 1
        for j in 1..n repeat
           u := u+1
           w := w+1
           for k in 1..n repeat
             entry : R := 0
             enter : R := 0
             for i in 1..n repeat
               entry := entry + elt(x,i)*elt(gamma.k,j,i)
               enter := enter + elt(x,i)*elt(gamma.k,i,j)
             setelt(cond,u,k,entry)$Matrix(R)
             setelt(cond,w,k,enter)$Matrix(R)
           setelt(cond,c,j, elt(x,j))
        rank(cond)$(M R)

      leftRank x ==
        cond : Matrix(R) := new(n,n,0$R)
        for k in 1..n repeat
         for j in 1..n repeat
           entry : R := 0
           for i in 1..n repeat
             entry := entry + elt(x,i)*elt(gamma.k,i,j)
           setelt(cond,j,k,entry)$Matrix(R)
        rank(cond)$(M R)

      rightRank x ==
        cond : Matrix(R) := new(n,n,0$R)
        for k in 1..n repeat
         for j in 1..n repeat
           entry : R := 0
           for i in 1..n repeat
             entry := entry + elt(x,i)*elt(gamma.k,j,i)
           setelt(cond,j,k,entry)$Matrix(R)
        rank(cond)$(M R)


      if R has EuclideanDomain then
        basis va ==
          v : V A := remove(zero?, va)$(V A)
          v : V A := removeDuplicates v
          empty? v =>  [0$A]
          m : Matrix R := coerce(coordinates(v.1))$(Matrix R)
          for i in 2..maxIndex v repeat
            m := horizConcat(m,coerce(coordinates(v.i))$(Matrix R) )
          m := rowEchelon m
          lj : List Integer := []
          h : Integer := 1
          mRI : Integer := maxRowIndex m
          mCI : Integer := maxColIndex m
          finished? : Boolean := false
          j : Integer := 1
          while not finished? repeat
            not zero? m(h,j) =>  -- corner found
              lj := cons(j,lj)
              h := mRI
              while zero? m(h,j) repeat h := h-1
              finished? := (h = mRI)
              if not finished? then h := h+1
            if j < mCI then
              j := j + 1
            else
              finished? := true
          [v.j for j in reverse lj]

@
<<ALGPKG.dotabb>>=
"ALGPKG" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGPKG"]
"FRNAALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRNAALG"]
"ALGPKG" -> "FRNAALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGFACT AlgFactor}
\pagehead{AlgFactor}{ALGFACT}
\pagepic{ps/v104algfactor.ps}{ALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGFACT AlgFactor>>=
)abbrev package ALGFACT AlgFactor
++ Factorization of UP AN;
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in 
++ \spadtype{AlgebraicNumber}.
 
AlgFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory AlgebraicNumber
 
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Integer
  AN  ==> AlgebraicNumber
  K   ==> Kernel AN
  UPQ ==> SparseUnivariatePolynomial Q
  SUP ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
 
  Exports ==> with
    factor: (UP, List AN) -> FR
      ++ factor(p, [a1,...,an]) returns a prime factorisation of p
      ++ over the field generated by its coefficients and a1,...,an.
    factor: UP            -> FR
      ++ factor(p) returns a prime factorisation of p
      ++ over the field generated by its coefficients.
    split : UP            -> FR
      ++ split(p) returns a prime factorisation of p
      ++ over its splitting field.
    doublyTransitive?: UP -> Boolean
      ++ doublyTransitive?(p) is true if p is irreducible over
      ++ over the field K generated by its coefficients, and
      ++ if \spad{p(X) / (X - a)} is irreducible over 
      ++ \spad{K(a)} where \spad{p(a) = 0}.
 
  Implementation ==> add
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                           K, Z, SparseMultivariatePolynomial(Z, K), AN)

    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

    fact    : (UP,  List K) -> FR
    ifactor : (SUP, List K) -> Factored SUP
    extend  : (UP, Z) -> FR
    allk    : List AN -> List K
    downpoly: UP  -> UPQ
    liftpoly: UPQ -> UP
    irred?  : UP  -> Boolean
 
    allk l       == removeDuplicates concat [kernels x for x in l]
    liftpoly p   == map(#1::AN,  p)$UPCF2(Q, UPQ, AN, UP)
    downpoly p   == map(retract(#1)@Q, p)$UPCF2(AN, UP ,Q, UPQ)
    ifactor(p,l) == (fact(p pretend UP, l)) pretend Factored(SUP)
    factor p     == fact(p, allk coefficients p)
 
    factor(p, l) ==
      fact(p, allk removeDuplicates concat(l, coefficients p))
 
    split p ==
      fp := factor p
      unit(fp) *
            _*/[extend(fc.factor, fc.exponent) for fc in factors fp]
 
    extend(p, n) ==
--      one? degree p => primeFactor(p, n)
      (degree p = 1) => primeFactor(p, n)
      q := monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP
      primeFactor(q, n) * split((p exquo q)::UP) ** (n::N)
 
    doublyTransitive? p ==
      irred? p and irred?((p exquo
        (monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP))::UP)
 
    irred? p ==
      fp := factor p
--      one? numberOfFactors fp and one? nthExponent(fp, 1)
      (numberOfFactors fp = 1) and  (nthExponent(fp, 1) = 1)
 
    fact(p, l) ==
--      one? degree p => primeFactor(p, 1)
      (degree p = 1) => primeFactor(p, 1)
      empty? l =>
        dr := factor(downpoly p)$RationalFactorize(UPQ)
        (liftpoly unit dr) *
          _*/[primeFactor(liftpoly dc.factor,dc.exponent)
            for dc in factors dr]
      q   := minPoly(alpha := "max"/l)$AN
      newl  := remove(alpha = #1, l)
      sae := SimpleAlgebraicExtension(AN, SUP, q)
      ups := SparseUnivariatePolynomial sae
      fr  := factor(map(reduce univariate(#1, alpha, q),
                     p)$UPCF2(AN, UP, sae, ups),
                      ifactor(#1, newl))$InnerAlgFactor(AN, SUP, sae, ups)
      newalpha := alpha::AN
      map((lift(#1)$sae) newalpha, unit fr)$UPCF2(sae, ups, AN, UP) *
            _*/[primeFactor(map((lift(#1)$sae) newalpha,
                      fc.factor)$UPCF2(sae, ups, AN, UP),
                                 fc.exponent) for fc in factors fr]

@
<<ALGFACT.dotabb>>=
"ALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTPACK AnnaNumericalIntegrationPackage}
\pagehead{AnnaNumericalIntegrationPackage}{INTPACK}
\pagepic{ps/v104annanumericalintegrationpackage.ps}{INTPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTPACK AnnaNumericalIntegrationPackage>>=
)abbrev package INTPACK AnnaNumericalIntegrationPackage
++ Author: Brian Dupee
++ Date Created: August 1994
++ Date Last Updated: December 1997
++ Basic Operations: integrate, measure 
++ Related Constructors: Result, RoutinesTable
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \axiomType{AnnaNumericalIntegrationPackage} is a \axiom{package}
++ of functions for the \axiom{category} 
++ \axiomType{NumericalIntegrationCategory} 
++ with \axiom{measure}, and \axiom{integrate}.
EDF	==> Expression DoubleFloat
DF	==> DoubleFloat
EF	==> Expression Float
F	==> Float
INT	==> Integer
SOCDF	==> Segment OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
SBOCF	==> SegmentBinding OrderedCompletion Float
LSOCF	==> List Segment OrderedCompletion Float
SOCF	==> Segment OrderedCompletion Float
OCF	==> OrderedCompletion Float
LS	==> List Symbol
S	==> Symbol
LST	==> List String
ST	==> String
RT	==> RoutinesTable
NIA	==> Record(var:S, fn:EDF, range:SOCDF, abserr:DF, relerr:DF)
MDNIA	==> Record(fn:EDF,range:List SOCDF,abserr:DF,relerr:DF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                   defaultMin:F, measure:F, failList:IFL, explList:List String)
Measure	==> Record(measure:F, name:ST, explanations:LST, extra:Result)


AnnaNumericalIntegrationPackage(): with

  integrate: (EF,SOCF,F,F,RT) -> Result
    ++ integrate(exp, a..b, epsrel, routines) is a top level ANNA function 
    ++ to integrate an expression, {\tt exp}, over a given range {\tt a} 
    ++ to {\tt b} to the required absolute and relative accuracy using 
    ++ the routines available in the RoutinesTable provided.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} 
    ++ to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
  integrate: NumericalIntegrationProblem -> Result
    ++ integrate(IntegrationProblem) is a top level ANNA function 
    ++ to integrate an expression over a given range or ranges 
    ++ to the required absolute and relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  

  integrate: (EF,SOCF,F,F) -> Result
    ++ integrate(exp, a..b, epsabs, epsrel) is a top level ANNA function 
    ++ to integrate an expression, {\tt exp}, over a given range {\tt a} 
    ++ to {\tt b} to the required absolute and relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  

  integrate: (EF,SOCF,F) -> Result
    ++ integrate(exp, a..b, epsrel) is a top level ANNA 
    ++ function to integrate an expression, {\tt exp}, over a given
    ++ range {\tt a} to {\tt b} to the required relative accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ If epsrel = 0, a default absolute accuracy is used.
 
  integrate: (EF,SOCF) -> Result
    ++ integrate(exp, a..b) is a top 
    ++ level ANNA function to integrate an expression, {\tt exp},
    ++ over a given range {\tt a} to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ Default values for the absolute and relative error are used.

  integrate:(EF,LSOCF) -> Result
    ++ integrate(exp, [a..b,c..d,...]) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ Default values for the absolute and relative error are used.

  integrate:(EF,LSOCF,F) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsrel) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required relative
    ++ accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.  
    ++
    ++ If epsrel = 0, a default absolute accuracy is used.

  integrate:(EF,LSOCF,F,F) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsabs, epsrel) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required absolute and relative
    ++ accuracy.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.

  integrate:(EF,LSOCF,F,F,RT) -> Result
    ++ integrate(exp, [a..b,c..d,...], epsabs, epsrel, routines) is a top 
    ++ level ANNA function to integrate a multivariate expression, {\tt exp},
    ++ over a given set of ranges to the required absolute and relative
    ++ accuracy, using the routines available in the RoutinesTable provided.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.

  measure:NumericalIntegrationProblem -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine for solving the numerical integration
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{NumericalIntegrationCategory} in turn to calculate all measures
    ++ and returns the best 
    ++ i.e. the name of the most appropriate domain and any other relevant
    ++ information.
  measure:(NumericalIntegrationProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical integration
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{NumericalIntegrationCategory} in turn to calculate all measures
    ++ and returns the best 
    ++ i.e. the name of the most appropriate domain and any other relevant
    ++ information.
  integrate:(EF,SBOCF,ST) -> Union(Result,"failed")
    ++ integrate(exp, x = a..b, "numerical") is a top level ANNA function to 
    ++ integrate an expression, {\tt exp}, over a given range, {\tt a}
    ++ to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.\newline
    ++ 
    ++ Default values for the absolute and relative error are used.
    ++
    ++ It is an error of the last argument is not {\tt "numerical"}.
  integrate:(EF,SBOCF,S) -> Union(Result,"failed")
    ++ integrate(exp, x = a..b, numerical) is a top level ANNA function to 
    ++ integrate an expression, {\tt exp}, over a given range, {\tt a}
    ++ to {\tt b}.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalIntegrationCategory} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ It then performs the integration of the given expression 
    ++ on that \axiom{domain}.\newline
    ++ 
    ++ Default values for the absolute and relative error are used.
    ++
    ++ It is an error if the last argument is not {\tt numerical}.

 ==  add

  zeroMeasure: Measure -> Result
  scriptedVariables?: MDNIA -> Boolean
  preAnalysis:(Union(nia:NIA,mdnia:MDNIA),RT) -> RT
  measureSpecific:(ST,RT,Union(nia:NIA,mdnia:MDNIA)) -> Record(measure:F,explanations:LST,extra:Result)
  changeName:(Result,ST) -> Result
  recoverAfterFail:(Union(nia:NIA,mdnia:MDNIA),RT,Measure,INT,Result) -> Record(a:Result,b:Measure)
  better?:(Result,Result) -> Boolean
  integrateConstant:(EF,SOCF) -> Result
  integrateConstantList: (EF,LSOCF) -> Result
  integrateArgs:(NumericalIntegrationProblem,RT) -> Result
  integrateSpecific:(Union(nia:NIA,mdnia:MDNIA),ST,Result) -> Result

  import ExpertSystemToolsPackage

  integrateConstantList(exp:EF,ras:LSOCF):Result ==
    c:OCF := ((retract(exp)@F)$EF)::OCF
    b := [hi(j)-lo(j) for j in ras]
    c := c*reduce((#1)*(#2),b)
    a := coerce(c)$AnyFunctions1(OCF)
    text := coerce("Constant Function")$AnyFunctions1(ST)
    construct([[result@S,a],[method@S,text]])$Result
    
  integrateConstant(exp:EF,ra:SOCF):Result ==
    c := (retract(exp)@F)$EF
    r:OCF := (c::OCF)*(hi(ra)-lo(ra))
    a := coerce(r)$AnyFunctions1(OCF)
    text := coerce("Constant Function")$AnyFunctions1(ST)
    construct([[result@S,a],[method@S,text]])$Result
    
  zeroMeasure(m:Measure):Result ==
    a := coerce(0$DF)$AnyFunctions1(DF)
    text := coerce("Constant Function")$AnyFunctions1(String)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  scriptedVariables?(mdnia:MDNIA):Boolean ==
    vars:List Symbol := variables(mdnia.fn)$EDF
    var1 := first(vars)$(List Symbol)
    not scripted?(var1) => false
    name1 := name(var1)$Symbol
    for i in 2..# vars repeat
      not ((scripted?(vars.i)$Symbol) and (name1 = name(vars.i)$Symbol)) => 
         return false
    true

  preAnalysis(args:Union(nia:NIA,mdnia:MDNIA),t:RT):RT ==
    import RT
    r:RT := selectIntegrationRoutines t
    args case nia => 
      arg:NIA := args.nia
      rangeIsFinite(arg)$d01AgentsPackage case finite => 
        selectFiniteRoutines r
      selectNonFiniteRoutines r
    selectMultiDimensionalRoutines r
    
  changeName(ans:Result,name:ST):Result ==
    sy:S := coerce(name "Answer")$S
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  measureSpecific(name:ST,R:RT,args:Union(nia:NIA,mdnia:MDNIA)):
      Record(measure:F,explanations:ST,extra:Result) ==
    args case nia => 
      arg:NIA := args.nia
      name = "d01ajfAnnaType" => measure(R,arg)$d01ajfAnnaType
      name = "d01akfAnnaType" => measure(R,arg)$d01akfAnnaType
      name = "d01alfAnnaType" => measure(R,arg)$d01alfAnnaType
      name = "d01amfAnnaType" => measure(R,arg)$d01amfAnnaType
      name = "d01anfAnnaType" => measure(R,arg)$d01anfAnnaType
      name = "d01apfAnnaType" => measure(R,arg)$d01apfAnnaType
      name = "d01aqfAnnaType" => measure(R,arg)$d01aqfAnnaType
      name = "d01asfAnnaType" => measure(R,arg)$d01asfAnnaType
      name = "d01TransformFunctionType" => 
                     measure(R,arg)$d01TransformFunctionType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    args case mdnia => 
      arg2:MDNIA := args.mdnia
      name = "d01gbfAnnaType" => measure(R,arg2)$d01gbfAnnaType
      name = "d01fcfAnnaType" => measure(R,arg2)$d01fcfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    error("measureSpecific","invalid type name")$ErrorFunctions

  measure(a:NumericalIntegrationProblem,R:RT):Measure ==
    args:Union(nia:NIA,mdnia:MDNIA) := retract(a)$NumericalIntegrationProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := preAnalysis(args,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth:LST := ["Trying " e.type " integration routines"]
    ext := empty()$Result
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,args)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        ext := concat(m.extra,ext)$ExpertSystemToolsPackage
        str:LST := [string(rout.key)$S "measure: " outputMeasure(m.measure) 
                     " - " m.explanations]
      else
        str:LST :=  [string(rout.key)$S " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth,ext]

  measure(a:NumericalIntegrationProblem):Measure ==
    measure(a,routines()$RT)

  integrateSpecific(args:Union(nia:NIA,mdnia:MDNIA),n:ST,ex:Result):Result ==
    args case nia => 
      arg:NIA := args.nia
      n = "d01ajfAnnaType" => numericalIntegration(arg,ex)$d01ajfAnnaType
      n = "d01TransformFunctionType" =>
        numericalIntegration(arg,ex)$d01TransformFunctionType
      n = "d01amfAnnaType" => numericalIntegration(arg,ex)$d01amfAnnaType
      n = "d01apfAnnaType" => numericalIntegration(arg,ex)$d01apfAnnaType
      n = "d01aqfAnnaType" => numericalIntegration(arg,ex)$d01aqfAnnaType
      n = "d01alfAnnaType" => numericalIntegration(arg,ex)$d01alfAnnaType
      n = "d01akfAnnaType" => numericalIntegration(arg,ex)$d01akfAnnaType
      n = "d01anfAnnaType" => numericalIntegration(arg,ex)$d01anfAnnaType
      n = "d01asfAnnaType" => numericalIntegration(arg,ex)$d01asfAnnaType
      error("integrateSpecific","invalid type name: " n)$ErrorFunctions
    args case mdnia => 
      arg2:MDNIA := args.mdnia
      n = "d01gbfAnnaType" => numericalIntegration(arg2,ex)$d01gbfAnnaType
      n = "d01fcfAnnaType" => numericalIntegration(arg2,ex)$d01fcfAnnaType
      error("integrateSpecific","invalid type name: " n)$ErrorFunctions
    error("integrateSpecific","invalid type name: " n)$ErrorFunctions

  better?(r:Result,s:Result):Boolean ==
    a1 := search("abserr"::S,r)$Result
    a1 case "failed" => false
    abserr1 := retract(a1)$AnyFunctions1(DF)
    negative?(abserr1) => false
    a2 := search("abserr"::S,s)$Result
    a2 case "failed" => true
    abserr2 := retract(a2)$AnyFunctions1(DF)
    negative?(abserr2) => true
    (abserr1 < abserr2) -- true if r.abserr better than s.abserr

  recoverAfterFail(n:Union(nia:NIA,mdnia:MDNIA),routs:RT,m:Measure,iint:INT,
                         r:Result):Record(a:Result,b:Measure) ==
    bestName := m.name
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RoutinesTable
      s case "failed" => iint := 0
      if s = "changeEps" then
        nn := n.nia
        zero?(nn.abserr) =>
          nn.abserr := 1.0e-8 :: DF
          m := measure(n::NumericalIntegrationProblem,routs)
          zero?(m.measure) => iint := 0
          r := integrateSpecific(n,m.name,m.extra)
          iint := 0
      rn := routineName(1..6)
      buttVal := getButtonValue(rn,"functionEvaluations")$AttributeButtons
      if (s = "incrFunEvals") and (buttVal < 0.8) then
        increase(rn,"functionEvaluations")$AttributeButtons
      if s = "increase tolerance" then
        (n.nia).relerr := (n.nia).relerr*(10.0::DF)
      if s = "decrease tolerance" then
        (n.nia).relerr := (n.nia).relerr/(10.0::DF)
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:S,entry:Any):=[failure@S,fl]
      m2 := measure(n::NumericalIntegrationProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := integrateSpecific(n,m2.name,m2.extra)
      better?(r,r2) => 
        m.name := m2.name
        insert!(flrec,r)$Result
      bestName := m2.name
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@S,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(INT)
    m.name := bestName
    [r,m]

  integrateArgs(prob:NumericalIntegrationProblem,t:RT):Result ==
    args:Union(nia:NIA,mdnia:MDNIA) := retract(prob)$NumericalIntegrationProblem
    routs := copy(t)$RT
    if args case mdnia then
      arg := args.mdnia
      v := (# variables(arg.fn))
      not scriptedVariables?(arg) => 
        error("MultiDimensionalNumericalIntegrationPackage",
                "invalid variable names")$ErrorFunctions
      (v ~= # arg.range)@Boolean =>
        error("MultiDimensionalNumericalIntegrationPackage",
          "number of variables do not match number of ranges")$ErrorFunctions
    m := measure(prob,routs)
    zero?(m.measure) => zeroMeasure m
    r := integrateSpecific(args,m.name,m.extra)
    iany := search(ifail@S,r)$Result
    iint := 0$INT
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(INT)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(args,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)$ExpertSystemToolsPackage
    n := m.name
    nn:ST := 
      (# n > 14) => "d01transform"
      n(1..6)
    expl := getExplanations(routs,nn)$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    args case nia =>
      att := showAttributes(args.nia)$IntegrationFunctionsTable
      att case "failed" => r
      concat(att2Result att,r)$ExpertSystemToolsPackage
    r

  integrate(args:NumericalIntegrationProblem):Result ==
    integrateArgs(args,routines()$RT)

  integrate(exp:EF,ra:SOCF,epsabs:F,epsrel:F,r:RT):Result ==
    Var:LS := variables(exp)$EF
    empty?(Var)$LS => integrateConstant(exp,ra)
    args:NIA := [first(Var)$LS,ef2edf exp,socf2socdf ra,f2df epsabs,f2df epsrel]
    integrateArgs(args::NumericalIntegrationProblem,r)

  integrate(exp:EF,ra:SOCF,epsabs:F,epsrel:F):Result ==
    integrate(exp,ra,epsabs,epsrel,routines()$RT)

  integrate(exp:EF,ra:SOCF,err:F):Result ==
    positive?(err)$F => integrate(exp,ra,0$F,err)
    integrate(exp,ra,1.0E-5,err)

  integrate(exp:EF,ra:SOCF):Result == integrate(exp,ra,0$F,1.0E-5)

  integrate(exp:EF,sb:SBOCF, st:ST) ==
    st = "numerical" => integrate(exp,segment sb)
    "failed"

  integrate(exp:EF,sb:SBOCF, s:S) ==
    s = (numerical::Symbol) => integrate(exp,segment sb)
    "failed"

  integrate(exp:EF,ra:LSOCF,epsabs:F,epsrel:F,r:RT):Result ==
    vars := variables(exp)$EF
    empty?(vars)$LS => integrateConstantList(exp,ra)
    args:MDNIA := [ef2edf exp,convert ra,f2df epsabs,f2df epsrel]
    integrateArgs(args::NumericalIntegrationProblem,r)

  integrate(exp:EF,ra:LSOCF,epsabs:F,epsrel:F):Result ==
    integrate(exp,ra,epsabs,epsrel,routines()$RT)

  integrate(exp:EF,ra:LSOCF,epsrel:F):Result ==
    zero? epsrel => integrate(exp,ra,1.0e-6,epsrel)
    integrate(exp,ra,0$F,epsrel)

  integrate(exp:EF,ra:LSOCF):Result == integrate(exp,ra,1.0e-4)

@
<<INTPACK.dotabb>>=
"INTPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTPACK"]
"TBAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TBAGG"]
"INTPACK" -> "TBAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OPTPACK AnnaNumericalOptimizationPackage}
\pagehead{AnnaNumericalOptimizationPackage}{OPTPACK}
\pagepic{ps/v104annanumericaloptimizationpackage.ps}{OPTPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OPTPACK AnnaNumericalOptimizationPackage>>=
)abbrev package OPTPACK AnnaNumericalOptimizationPackage
++ Author: Brian Dupee
++ Date Created: February 1995
++ Date Last Updated: December 1997
++ Basic Operations: measure, optimize, goodnessOfFit.
++ Description:
++ \axiomType{AnnaNumericalOptimizationPackage} is a \axiom{package} of 
++ functions for the \axiomType{NumericalOptimizationCategory} 
++ with \axiom{measure} and \axiom{optimize}.
EDF	==> Expression DoubleFloat
LEDF	==> List Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LOCF	==> List OrderedCompletion Float
OCF	==> OrderedCompletion Float
LEF	==> List Expression Float
EF	==> Expression Float
LF	==> List Float
F	==> Float
LS	==> List Symbol
LST	==> List String
INT	==> Integer
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
LSA	==> Record(lfn:LEDF, init:LDF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:String, explanations:List String)
Measure2	==> Record(measure:F,explanations:String)
RT	==> RoutinesTable
UNOALSA	==> Union(noa:NOA,lsa:LSA)

AnnaNumericalOptimizationPackage(): with
  measure:NumericalOptimizationProblem -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical optimization problem defined by 
    ++ \axiom{prob} by checking various attributes of the functions and 
    ++ calculating a measure of compatibility of each routine to these 
    ++ attributes.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{NumericalOptimizationCategory} in turn to calculate all 
    ++ measures and returns the best i.e. the name of the most 
    ++ appropriate domain and any other relevant information.

  measure:(NumericalOptimizationProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical optimization problem defined by 
    ++ \axiom{prob} by checking various attributes of the functions and 
    ++ calculating a measure of compatibility of each routine to these 
    ++ attributes.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{NumericalOptimizationCategory} in turn to calculate all 
    ++ measures and returns the best i.e. the name of the most 
    ++ appropriate domain and any other relevant information.

  optimize:(NumericalOptimizationProblem,RT) -> Result
    ++ optimize(prob,routines) is a top level ANNA function to 
    ++ minimize a function or a set of functions with any constraints
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} listed in \axiom{routines} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:NumericalOptimizationProblem -> Result
    ++ optimize(prob) is a top level ANNA function to 
    ++ minimize a function or a set of functions with any constraints
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  goodnessOfFit:NumericalOptimizationProblem -> Result
    ++ goodnessOfFit(prob) is a top level ANNA function to 
    ++ check to goodness of fit of a least squares model 
    ++ as defined within \axiom{prob}.
    ++
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then calls the numerical routine \axiomType{E04YCF} to get estimates
    ++ of the variance-covariance matrix of the regression coefficients of 
    ++ the least-squares problem.
    ++ 
    ++ It thus returns both the results of the optimization and the
    ++ variance-covariance calculation.

  optimize:(EF,LF,LOCF,LEF,LOCF) -> Result 
    ++ optimize(f,start,lower,cons,upper) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables with the 
    ++ given constraints.
    ++
    ++ These constraints may be simple constraints on the variables
    ++ in which case \axiom{cons} would be an empty list and the bounds on
    ++ those variables defined in \axiom{lower} and \axiom{upper}, or a 
    ++ mixture of simple, linear and non-linear constraints, where
    ++ \axiom{cons} contains the linear and non-linear constraints and
    ++ the bounds on these are added to \axiom{upper} and \axiom{lower}.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(EF,LF,LOCF,LOCF) -> Result 
    ++ optimize(f,start,lower,upper) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables with 
    ++ simple constraints.  The bounds on
    ++ the variables are defined in \axiom{lower} and \axiom{upper}.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(EF,LF) -> Result 
    ++ optimize(f,start) is a top level ANNA function to 
    ++ minimize a function, \axiom{f}, of one or more variables without
    ++ constraints. 
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  optimize:(LEF,LF) -> Result 
    ++ optimize(lf,start) is a top level ANNA function to 
    ++ minimize a set of functions, \axiom{lf}, of one or more variables 
    ++ without constraints i.e. a least-squares problem. 
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.

  goodnessOfFit:(LEF,LF) -> Result 
    ++ goodnessOfFit(lf,start) is a top level ANNA function to 
    ++ check to goodness of fit of a least squares model i.e. the minimization
    ++ of a set of functions, \axiom{lf}, of one or more variables without 
    ++ constraints.
    ++
    ++ The parameter \axiom{start} is a list of the initial guesses of the
    ++ values of the variables.
    ++ 
    ++ It iterates over the \axiom{domains} of 
    ++ \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then calls the numerical routine \axiomType{E04YCF} to get estimates
    ++ of the variance-covariance matrix of the regression coefficients of 
    ++ the least-squares problem.
    ++ 
    ++ It thus returns both the results of the optimization and the
    ++ variance-covariance calculation.

    ++ goodnessOfFit(lf,start) is a top level function to iterate over 
    ++ the \axiom{domains} of \axiomType{NumericalOptimizationCategory} 
    ++ to get the name and other relevant information of the best
    ++ \axiom{measure} and then optimize the function on that \axiom{domain}.
    ++ It then checks the goodness of fit of the least squares model.

 == add

  preAnalysis:RT -> RT
  zeroMeasure:Measure -> Result
  optimizeSpecific:(UNOALSA,String) -> Result
  measureSpecific:(String,RT,UNOALSA) -> Measure2
  changeName:(Result,String) -> Result
  recoverAfterFail:(UNOALSA,RT,Measure,INT,Result) -> Record(a:Result,b:Measure)
  constant:UNOALSA -> Union(DF, "failed")
  optimizeConstant:DF -> Result

  import ExpertSystemToolsPackage,e04AgentsPackage,NumericalOptimizationProblem

  constant(args:UNOALSA):Union(DF,"failed") ==
    args case noa =>
      Args := args.noa
      f := Args.fn
      retractIfCan(f)@Union(DoubleFloat,"failed")
    "failed"

  optimizeConstant(c:DF): Result ==
    a := coerce(c)$AnyFunctions1(DF)
    text := coerce("Constant Function")$AnyFunctions1(String)
    construct([[objf@Symbol,a],[method@Symbol,text]])$Result

  preAnalysis(args:UNOALSA,t:RT):RT == 
    r := selectOptimizationRoutines(t)$RT
    args case lsa =>
      selectSumOfSquaresRoutines(r)$RT
    r

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("Zero Measure")$AnyFunctions1(String)
    r := construct([[objf@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)

  measureSpecific(name:String,R:RT,args:UNOALSA): Measure2 ==
    args case noa =>
      arg:NOA := args.noa
      name = "e04dgfAnnaType" => measure(R,arg)$e04dgfAnnaType
      name = "e04fdfAnnaType" => measure(R,arg)$e04fdfAnnaType
      name = "e04gcfAnnaType" => measure(R,arg)$e04gcfAnnaType
      name = "e04jafAnnaType" => measure(R,arg)$e04jafAnnaType
      name = "e04mbfAnnaType" => measure(R,arg)$e04mbfAnnaType
      name = "e04nafAnnaType" => measure(R,arg)$e04nafAnnaType
      name = "e04ucfAnnaType" => measure(R,arg)$e04ucfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    args case lsa =>
      arg2:LSA := args.lsa
      name = "e04fdfAnnaType" => measure(R,arg2)$e04fdfAnnaType
      name = "e04gcfAnnaType" => measure(R,arg2)$e04gcfAnnaType
      error("measureSpecific","invalid type name: " name)$ErrorFunctions
    error("measureSpecific","invalid argument type")$ErrorFunctions

  measure(Args:NumericalOptimizationProblem,R:RT):Measure ==
    args:UNOALSA := retract(Args)$NumericalOptimizationProblem
    sofar := 0$F
    best := "none" :: String
    routs := copy R
    routs := preAnalysis(args,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$(List String)
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,args)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str := [concat(concat([string(rout.key)$Symbol,"measure: ",
                 outputMeasure(m.measure)," - "],
                   m.explanations)$(List String))$String]
      else 
        str := [concat([string(rout.key)$Symbol
                         ," is no better than other routines"])$String]
      meth := append(meth,str)$(List String)
    [sofar,best,meth]

  measure(args:NumericalOptimizationProblem):Measure == measure(args,routines()$RT)

  optimizeSpecific(args:UNOALSA,name:String):Result ==
    args case noa =>
      arg:NOA := args.noa
      name = "e04dgfAnnaType" => numericalOptimization(arg)$e04dgfAnnaType
      name = "e04fdfAnnaType" => numericalOptimization(arg)$e04fdfAnnaType
      name = "e04gcfAnnaType" => numericalOptimization(arg)$e04gcfAnnaType
      name = "e04jafAnnaType" => numericalOptimization(arg)$e04jafAnnaType
      name = "e04mbfAnnaType" => numericalOptimization(arg)$e04mbfAnnaType
      name = "e04nafAnnaType" => numericalOptimization(arg)$e04nafAnnaType
      name = "e04ucfAnnaType" => numericalOptimization(arg)$e04ucfAnnaType
      error("optimizeSpecific","invalid type name: " name)$ErrorFunctions
    args case lsa =>
      arg2:LSA := args.lsa
      name = "e04fdfAnnaType" => numericalOptimization(arg2)$e04fdfAnnaType
      name = "e04gcfAnnaType" => numericalOptimization(arg2)$e04gcfAnnaType
      error("optimizeSpecific","invalid type name: " name)$ErrorFunctions
    error("optimizeSpecific","invalid type name: " name)$ErrorFunctions

  changeName(ans:Result,name:String):Result ==
    st:String := concat([name,"Answer"])$String
    sy:Symbol := coerce(st)$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(args:UNOALSA,routs:RT,m:Measure,
                     iint:INT,r:Result):Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(String)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(args::NumericalOptimizationProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := optimizeSpecific(args,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(INT)
    [r,m]

  optimize(Args:NumericalOptimizationProblem,t:RT):Result ==
    args:UNOALSA := retract(Args)$NumericalOptimizationProblem
    routs := copy(t)$RT
    c:Union(DF,"failed") := constant(args)
    c case DF => optimizeConstant(c)
    m := measure(Args,routs)
    zero?(m.measure) => zeroMeasure m
    r := optimizeSpecific(args,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$INT
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(INT)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(args,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    att:List String := optAttributes(args)
    atta := coerce(att)$AnyFunctions1(List String)
    attr:Record(key:Symbol,entry:Any) := [attributes@Symbol,atta]
    insert!(attr,r)$Result

  optimize(args:NumericalOptimizationProblem):Result == optimize(args,routines()$RT)

  goodnessOfFit(Args:NumericalOptimizationProblem):Result ==
    r := optimize(Args)
    args1:UNOALSA := retract(Args)$NumericalOptimizationProblem
    args1 case noa => error("goodnessOfFit","Not an appropriate problem")
    args:LSA := args1.lsa
    lf := args.lfn
    n:INT := #(variables(args))
    m:INT := # lf
    me := search(method,r)$Result
    me case "failed" => r
    meth := retract(me)$AnyFunctions1(Result)
    na := search(nameOfRoutine,meth)$Result
    na case "failed" => r
    name := retract(na)$AnyFunctions1(String)
    temp:INT := (n*(n-1)) quo 2
    ns:INT :=
      name = "e04fdfAnnaType" => 6*n+(2+n)*m+1+max(1,temp)
      8*n+(n+2)*m+temp+1+max(1,temp)
    nv:INT := ns+n
    ww := search(w,r)$Result
    ww case "failed" => r
    ws:MDF := retract(ww)$AnyFunctions1(MDF)
    fr := search(objf,r)$Result
    fr case "failed" => r
    f := retract(fr)$AnyFunctions1(DF)
    s := subMatrix(ws,1,1,ns,nv-1)$MDF
    v := subMatrix(ws,1,1,nv,nv+n*n-1)$MDF
    r2 := e04ycf(0,m,n,f,s,n,v,-1)$NagOptimisationPackage
    concat(r,r2)

  optimize(f:EF,start:LF,lower:LOCF,cons:LEF,upper:LOCF):Result ==
    args:NOA := [ef2edf(f),[f2df i for i in start],[ocf2ocdf j for j in lower],
                 [ef2edf k for k in cons], [ocf2ocdf l for l in upper]]
    optimize(args::NumericalOptimizationProblem)

  optimize(f:EF,start:LF,lower:LOCF,upper:LOCF):Result ==
    optimize(f,start,lower,empty()$LEF,upper)

  optimize(f:EF,start:LF):Result ==
    optimize(f,start,empty()$LOCF,empty()$LOCF)

  optimize(lf:LEF,start:LF):Result ==
    args:LSA := [[ef2edf i for i in lf],[f2df j for j in start]]
    optimize(args::NumericalOptimizationProblem)

  goodnessOfFit(lf:LEF,start:LF):Result ==
    args:LSA := [[ef2edf i for i in lf],[f2df j for j in start]]
    goodnessOfFit(args::NumericalOptimizationProblem)

@
<<OPTPACK.dotabb>>=
"OPTPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OPTPACK"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"OPTPACK" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEPACK AnnaOrdinaryDifferentialEquationPackage}
\pagehead{AnnaOrdinaryDifferentialEquationPackage}{ODEPACK}
\pagepic{ps/v104annaordinarydifferentialequationpackage.ps}{ODEPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEPACK AnnaOrdinaryDifferentialEquationPackage>>=
)abbrev package ODEPACK AnnaOrdinaryDifferentialEquationPackage
++ Author: Brian Dupee
++ Date Created: February 1995
++ Date Last Updated: December 1997
++ Basic Operations: solve, measure
++ Description:
++ \axiomType{AnnaOrdinaryDifferentialEquationPackage} is a \axiom{package}
++ of functions for the \axiom{category} \axiomType{OrdinaryDifferentialEquationsSolverCategory} 
++ with \axiom{measure}, and \axiom{solve}.
++
EDF	==> Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
FI	==> Fraction Integer
EFI	==> Expression Fraction Integer
SOCDF	==> Segment OrderedCompletion DoubleFloat
VEDF	==> Vector Expression DoubleFloat
VEF	==> Vector Expression Float
EF	==> Expression Float
LF	==> List Float
F	==> Float
VDF	==> Vector DoubleFloat
VMF	==> Vector MachineFloat
MF	==> MachineFloat
LS	==> List Symbol
ST	==> String
LST	==> List String
INT	==> Integer
RT	==> RoutinesTable
ODEA	==> Record(xinit:DF,xend:DF,fn:VEDF,yinit:LDF,intvals:LDF,_
                    g:EDF,abserr:DF,relerr:DF)
IFL	==> List(Record(ifail:Integer,instruction:String))
Entry	==> Record(chapter:String, type:String, domainName: String, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:String, explanations:List String)

AnnaOrdinaryDifferentialEquationPackage(): with
  solve:(NumericalODEProblem) -> Result
    ++ solve(odeProblem) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with starting values for X and Y[1]..Y[n] (called the initial
    ++ conditions), a final value of X, an accuracy requirement and any
    ++ intermediate points at which the result is required. 
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} 
    ++ to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(NumericalODEProblem,RT) -> Result
    ++ solve(odeProblem,R) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with starting values for X and Y[1]..Y[n] (called the initial
    ++ conditions), a final value of X, an accuracy requirement and any
    ++ intermediate points at which the result is required. 
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF) -> Result
    ++ solve(f,xStart,xEnd,yInitial) is a top level ANNA function to solve numerically a 
    ++ system of ordinary differential equations i.e. equations for the 
    ++ derivatives Y[1]'..Y[n]' defined in terms of X,Y[1]..Y[n], together
    ++ with a starting value for X and Y[1]..Y[n] (called the initial
    ++ conditions) and a final value of X.  A default value
    ++ is used for the accuracy requirement.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}.  
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The calculation will stop if the function G(X,Y[1],..,Y[n]) evaluates to zero before
    ++ X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,intVals,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,LF,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,intVals,tol) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to a tolerance \axiom{tol}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.  The calculation will stop if the function 
    ++ G(X,Y[1],..,Y[n]) evaluates to zero before X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  solve:(VEF,F,F,LF,EF,LF,F,F) -> Result
    ++ solve(f,xStart,xEnd,yInitial,G,intVals,epsabs,epsrel) is a top level ANNA function to solve 
    ++ numerically a system of ordinary differential equations, \axiom{f}, i.e. 
    ++ equations for the derivatives Y[1]'..Y[n]' defined in terms 
    ++ of X,Y[1]..Y[n] from \axiom{xStart} to \axiom{xEnd} with the initial
    ++ values for Y[1]..Y[n] (\axiom{yInitial}) to an absolute error
    ++ requirement \axiom{epsabs} and relative error \axiom{epsrel}. 
    ++ The values of Y[1]..Y[n] will be output for the values of X in
    ++ \axiom{intVals}.  The calculation will stop if the function 
    ++ G(X,Y[1],..,Y[n]) evaluates to zero before X = xEnd.
    ++
    ++ It iterates over the \axiom{domains} of
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} contained in
    ++ the table of routines \axiom{R} to get the name and other 
    ++ relevant information of the the (domain of the) numerical 
    ++ routine likely to be the most appropriate, 
    ++ i.e. have the best \axiom{measure}.
    ++ 
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of ODE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
  measure:(NumericalODEProblem) -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical ODE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of ODEs
    ++ by checking various attributes of the system of ODEs and calculating
    ++ a measure of compatibility of each routine to these attributes.
  measure:(NumericalODEProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical ODE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{OrdinaryDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of ODEs
    ++ by checking various attributes of the system of ODEs and calculating
    ++ a measure of compatibility of each routine to these attributes.

 == add

  import ODEA,NumericalODEProblem

  f2df:F -> DF
  ef2edf:EF -> EDF
  preAnalysis:(ODEA,RT) -> RT
  zeroMeasure:Measure -> Result
  measureSpecific:(ST,RT,ODEA) -> Record(measure:F,explanations:ST)
  solveSpecific:(ODEA,ST) -> Result
  changeName:(Result,ST) -> Result 
  recoverAfterFail:(ODEA,RT,Measure,Integer,Result) -> Record(a:Result,b:Measure)

  f2df(f:F):DF == (convert(f)@DF)$F

  ef2edf(f:EF):EDF == map(f2df,f)$ExpressionFunctions2(F,DF)

  preAnalysis(args:ODEA,t:RT):RT ==
    rt := selectODEIVPRoutines(t)$RT
    if positive?(# variables(args.g)) then 
      changeMeasure(rt,d02bbf@Symbol,getMeasure(rt,d02bbf@Symbol)*0.8)
    if positive?(# args.intvals) then 
      changeMeasure(rt,d02bhf@Symbol,getMeasure(rt,d02bhf@Symbol)*0.8)
    rt

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("Zero Measure")$AnyFunctions1(ST)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  measureSpecific(name:ST,R:RT,ode:ODEA):Record(measure:F,explanations:ST) ==
    name = "d02bbfAnnaType" => measure(R,ode)$d02bbfAnnaType
    name = "d02bhfAnnaType" => measure(R,ode)$d02bhfAnnaType
    name = "d02cjfAnnaType" => measure(R,ode)$d02cjfAnnaType
    name = "d02ejfAnnaType" => measure(R,ode)$d02ejfAnnaType
    error("measureSpecific","invalid type name: " name)$ErrorFunctions

  measure(Ode:NumericalODEProblem,R:RT):Measure ==
    ode:ODEA := retract(Ode)$NumericalODEProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := preAnalysis(ode,routs)
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$LST
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,ode)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str:LST := [string(rout.key)$Symbol "measure: " 
                    outputMeasure(m.measure)$ExpertSystemToolsPackage " - " 
                     m.explanations]
      else 
        str := [string(rout.key)$Symbol " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth]

  measure(ode:NumericalODEProblem):Measure == measure(ode,routines()$RT)

  solveSpecific(ode:ODEA,n:ST):Result ==
    n = "d02bbfAnnaType" => ODESolve(ode)$d02bbfAnnaType
    n = "d02bhfAnnaType" => ODESolve(ode)$d02bhfAnnaType
    n = "d02cjfAnnaType" => ODESolve(ode)$d02cjfAnnaType
    n = "d02ejfAnnaType" => ODESolve(ode)$d02ejfAnnaType
    error("solveSpecific","invalid type name: " n)$ErrorFunctions

  changeName(ans:Result,name:ST):Result ==
    sy:Symbol := coerce(name "Answer")$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(ode:ODEA,routs:RT,m:Measure,iint:Integer,r:Result):
                                            Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      if s = "increase tolerance" then
        ode.relerr := ode.relerr*(10.0::DF)
        ode.abserr := ode.abserr*(10.0::DF)
      if s = "decrease tolerance" then
        ode.relerr := ode.relerr/(10.0::DF)
        ode.abserr := ode.abserr/(10.0::DF)
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(ode::NumericalODEProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := solveSpecific(ode,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(Integer)
    [r,m]

  solve(Ode:NumericalODEProblem,t:RT):Result ==
    ode:ODEA := retract(Ode)$NumericalODEProblem
    routs := copy(t)$RT
    m := measure(Ode,routs)
    zero?(m.measure) => zeroMeasure m
    r := solveSpecific(ode,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$Integer
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(Integer)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(ode,routs,m,iint,r)
      r := tu.a
      m := tu.b
    r := concat(measure2Result m,r)$ExpertSystemToolsPackage
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    iflist := showIntensityFunctions(ode)$ODEIntensityFunctionsTable
    iflist case "failed" => r
    concat(iflist2Result iflist, r)$ExpertSystemToolsPackage

  solve(ode:NumericalODEProblem):Result == solve(ode,routines()$RT)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,G:EF,intVals:LF,epsabs:F,epsrel:F):Result ==
    d:ODEA := [f2df xStart,f2df xEnd,vector([ef2edf e for e in members f])$VEDF,
               [f2df i for i in yInitial], [f2df j for j in intVals],
                ef2edf G,f2df epsabs,f2df epsrel]
    solve(d::NumericalODEProblem,routines()$RT)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,G:EF,intVals:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,G,intVals,tol,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,intVals:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,1$EF,intVals,tol)

  solve(f:VEF,xStart:F,xEnd:F,y:LF,G:EF,tol:F):Result ==
    solve(f,xStart,xEnd,y,G,empty()$LF,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF,tol:F):Result ==
    solve(f,xStart,xEnd,yInitial,1$EF,empty()$LF,tol)

  solve(f:VEF,xStart:F,xEnd:F,yInitial:LF):Result == solve(f,xStart,xEnd,yInitial,1.0e-4)

@
<<ODEPACK.dotabb>>=
"ODEPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEPACK"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"ODEPACK" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PDEPACK AnnaPartialDifferentialEquationPackage}
\pagehead{AnnaPartialDifferentialEquationPackage}{PDEPACK}
\pagepic{ps/v104annapartialdifferentialequationpackage.ps}{PDEPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PDEPACK AnnaPartialDifferentialEquationPackage>>=
)abbrev package PDEPACK AnnaPartialDifferentialEquationPackage
++ Author: Brian Dupee
++ Date Created: June 1996
++ Date Last Updated: December 1997
++ Basic Operations: 
++ Description: AnnaPartialDifferentialEquationPackage is an uncompleted
++ package for the interface to NAG PDE routines.  It has been realised that
++ a new approach to solving PDEs will need to be created.
++
LEDF	==> List Expression DoubleFloat
EDF	==> Expression DoubleFloat
LDF	==> List DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
LEF	==> List Expression Float
EF	==> Expression Float
MEF	==> Matrix Expression Float
LF	==> List Float
F	==> Float
LS	==> List Symbol
ST	==> String
LST	==> List String
INT	==> Integer
NNI	==> NonNegativeInteger
RT	==> RoutinesTable
PDEC	==> Record(start:DF, finish:DF, grid:NNI, boundaryType:INT, 
                    dStart:MDF, dFinish:MDF)
PDEB	==> Record(pde:LEDF, constraints:List PDEC,
                    f:List LEDF, st:ST, tol:DF)
IFL	==> List(Record(ifail:INT,instruction:ST))
Entry	==> Record(chapter:ST, type:ST, domainName: ST, 
                     defaultMin:F, measure:F, failList:IFL, explList:LST)
Measure	==> Record(measure:F,name:ST, explanations:LST)

AnnaPartialDifferentialEquationPackage(): with
  solve:(NumericalPDEProblem) -> Result
    ++ solve(PDEProblem) is a top level ANNA function to solve numerically a system
    ++ of partial differential equations.  
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(NumericalPDEProblem,RT) -> Result
    ++ solve(PDEProblem,routines) is a top level ANNA function to solve numerically a system
    ++ of partial differential equations.  
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(F,F,F,F,NNI,NNI,LEF,List LEF,ST,DF) -> Result
    ++ solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st,tol) is a top level 
    ++ ANNA function to solve numerically a system of partial differential 
    ++ equations.  This is defined as a list of coefficients (\axiom{pde}),
    ++ a grid (\axiom{xmin}, \axiom{ymin}, \axiom{xmax}, \axiom{ymax}, 
    ++ \axiom{ngx}, \axiom{ngy}), the boundary values (\axiom{bounds}) and a
    ++ tolerance requirement (\axiom{tol}).  There is also a parameter 
    ++ (\axiom{st}) which should contain the value "elliptic" if the PDE is
    ++ known to be elliptic, or "unknown" if it is uncertain.  This causes the
    ++ routine to check whether the PDE is elliptic.
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  solve:(F,F,F,F,NNI,NNI,LEF,List LEF,ST) -> Result
    ++ solve(xmin,ymin,xmax,ymax,ngx,ngy,pde,bounds,st) is a top level 
    ++ ANNA function to solve numerically a system of partial differential 
    ++ equations.  This is defined as a list of coefficients (\axiom{pde}),
    ++ a grid (\axiom{xmin}, \axiom{ymin}, \axiom{xmax}, \axiom{ymax}, 
    ++ \axiom{ngx}, \axiom{ngy}) and the boundary values (\axiom{bounds}).  
    ++ A default value for tolerance is used.  There is also a parameter 
    ++ (\axiom{st}) which should contain the value "elliptic" if the PDE is
    ++ known to be elliptic, or "unknown" if it is uncertain.  This causes the
    ++ routine to check whether the PDE is elliptic.
    ++
    ++ The method used to perform the numerical
    ++ process will be one of the routines contained in the NAG numerical
    ++ Library.  The function predicts the likely most effective routine
    ++ by checking various attributes of the system of PDE's and calculating
    ++ a measure of compatibility of each routine to these attributes.
    ++
    ++ It then calls the resulting `best' routine.
    ++
    ++ ** At the moment, only Second Order Elliptic Partial Differential
    ++ Equations are solved **
  measure:(NumericalPDEProblem) -> Measure
    ++ measure(prob) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical PDE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} of \axiom{category}
    ++ \axiomType{PartialDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of PDEs
    ++ by checking various attributes of the system of PDEs and calculating
    ++ a measure of compatibility of each routine to these attributes.
  measure:(NumericalPDEProblem,RT) -> Measure
    ++ measure(prob,R) is a top level ANNA function for identifying the most
    ++ appropriate numerical routine from those in the routines table
    ++ provided for solving the numerical PDE
    ++ problem defined by \axiom{prob}.
    ++
    ++ It calls each \axiom{domain} listed in \axiom{R} of \axiom{category}
    ++ \axiomType{PartialDifferentialEquationsSolverCategory} in turn to 
    ++ calculate all measures and returns the best i.e. the name of 
    ++ the most appropriate domain and any other relevant information.
    ++ It predicts the likely most effective NAG numerical
    ++ Library routine to solve the input set of PDEs
    ++ by checking various attributes of the system of PDEs and calculating
    ++ a measure of compatibility of each routine to these attributes.


 == add

  import PDEB, d03AgentsPackage, ExpertSystemToolsPackage, NumericalPDEProblem

  zeroMeasure:Measure -> Result
  measureSpecific:(ST,RT,PDEB) -> Record(measure:F,explanations:ST)
  solveSpecific:(PDEB,ST) -> Result
  changeName:(Result,ST) -> Result
  recoverAfterFail:(PDEB,RT,Measure,Integer,Result) -> Record(a:Result,b:Measure)

  zeroMeasure(m:Measure):Result ==
    a := coerce(0$F)$AnyFunctions1(F)
    text := coerce("No available routine appears appropriate")$AnyFunctions1(ST)
    r := construct([[result@Symbol,a],[method@Symbol,text]])$Result
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  measureSpecific(name:ST,R:RT,p:PDEB):Record(measure:F,explanations:ST) ==
    name = "d03eefAnnaType" => measure(R,p)$d03eefAnnaType
    --name = "d03fafAnnaType" => measure(R,p)$d03fafAnnaType
    error("measureSpecific","invalid type name: " name)$ErrorFunctions

  measure(P:NumericalPDEProblem,R:RT):Measure ==
    p:PDEB := retract(P)$NumericalPDEProblem
    sofar := 0$F
    best := "none" :: ST
    routs := copy R
    routs := selectPDERoutines(routs)$RT
    empty?(routs)$RT => 
      error("measure", "no routines found")$ErrorFunctions
    rout := inspect(routs)$RT
    e := retract(rout.entry)$AnyFunctions1(Entry)
    meth := empty()$LST
    for i in 1..# routs repeat
      rout := extract!(routs)$RT
      e := retract(rout.entry)$AnyFunctions1(Entry)
      n := e.domainName
      if e.defaultMin > sofar then
        m := measureSpecific(n,R,p)
        if m.measure > sofar then
          sofar := m.measure
          best := n
        str:LST := [string(rout.key)$Symbol "measure: " 
                    outputMeasure(m.measure)$ExpertSystemToolsPackage " - " 
                     m.explanations]
      else 
        str := [string(rout.key)$Symbol " is no better than other routines"]
      meth := append(meth,str)$LST
    [sofar,best,meth]

  measure(P:NumericalPDEProblem):Measure == measure(P,routines()$RT)

  solveSpecific(p:PDEB,n:ST):Result ==
    n = "d03eefAnnaType" => PDESolve(p)$d03eefAnnaType
    --n = "d03fafAnnaType" => PDESolve(p)$d03fafAnnaType
    error("solveSpecific","invalid type name: " n)$ErrorFunctions

  changeName(ans:Result,name:ST):Result ==
    sy:Symbol := coerce(name "Answer")$Symbol
    anyAns:Any := coerce(ans)$AnyFunctions1(Result)
    construct([[sy,anyAns]])$Result

  recoverAfterFail(p:PDEB,routs:RT,m:Measure,iint:Integer,r:Result):
                                            Record(a:Result,b:Measure) ==
    while positive?(iint) repeat
      routineName := m.name
      s := recoverAfterFail(routs,routineName(1..6),iint)$RT
      s case "failed" => iint := 0
      (s = "no action")@Boolean => iint := 0
      fl := coerce(s)$AnyFunctions1(ST)
      flrec:Record(key:Symbol,entry:Any):=[failure@Symbol,fl]
      m2 := measure(p::NumericalPDEProblem,routs)
      zero?(m2.measure) => iint := 0
      r2:Result := solveSpecific(p,m2.name)
      m := m2
      insert!(flrec,r2)$Result
      r := concat(r2,changeName(r,routineName))$ExpertSystemToolsPackage
      iany := search(ifail@Symbol,r2)$Result
      iany case "failed" => iint := 0
      iint := retract(iany)$AnyFunctions1(Integer)
    [r,m]

  solve(P:NumericalPDEProblem,t:RT):Result ==
    routs := copy(t)$RT
    m := measure(P,routs)
    p:PDEB := retract(P)$NumericalPDEProblem
    zero?(m.measure) => zeroMeasure m
    r := solveSpecific(p,n := m.name)
    iany := search(ifail@Symbol,r)$Result
    iint := 0$Integer
    if (iany case Any) then
      iint := retract(iany)$AnyFunctions1(Integer)
    if positive?(iint) then
      tu:Record(a:Result,b:Measure) := recoverAfterFail(p,routs,m,iint,r)
      r := tu.a
      m := tu.b
    expl := getExplanations(routs,n(1..6))$RoutinesTable
    expla := coerce(expl)$AnyFunctions1(LST)
    explaa:Record(key:Symbol,entry:Any) := ["explanations"::Symbol,expla]
    r := concat(construct([explaa]),r)
    concat(measure2Result m,r)$ExpertSystemToolsPackage

  solve(P:NumericalPDEProblem):Result == solve(P,routines()$RT)

  solve(xmi:F,xma:F,ymi:F,yma:F,nx:NNI,ny:NNI,pe:LEF,bo:List
                LEF,s:ST,to:DF):Result ==
    cx:PDEC := [f2df xmi, f2df xma, nx, 1, empty()$MDF, empty()$MDF]
    cy:PDEC := [f2df ymi, f2df yma, ny, 1, empty()$MDF, empty()$MDF]
    p:PDEB := [[ef2edf e for e in pe],[cx,cy],
                [[ef2edf u for u in w] for w in bo],s,to]
    solve(p::NumericalPDEProblem,routines()$RT)

  solve(xmi:F,xma:F,ymi:F,yma:F,nx:NNI,ny:NNI,pe:LEF,bo:List
                LEF,s:ST):Result ==
    solve(xmi,xma,ymi,yma,nx,ny,pe,bo,s,0.0001::DF)

@
<<PDEPACK.dotabb>>=
"PDEPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PDEPACK"]
"TBAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TBAGG"]
"PDEPACK" -> "TBAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ANY1 AnyFunctions1}
\pagehead{AnyFunctions1}{ANY1}
\pagepic{ps/v104anyfunctions1.ps}{ANY1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ANY1 AnyFunctions1>>=
)abbrev package ANY1 AnyFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions:  coerce, retractIfCan, retractable?, retract
++ Related Constructors: Any
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{AnyFunctions1} implements several utility functions for
++   working with \spadtype{Any}. These functions are used to go back
++   and forth between objects of \spadtype{Any} and objects of other
++   types.

AnyFunctions1(S:Type): with
        coerce      : S -> Any
          ++ coerce(s) creates an object of \spadtype{Any} from the
          ++ object \spad{s} of type \spad{S}.
        retractIfCan: Any -> Union(S, "failed")
          ++ retractIfCan(a) tries change \spad{a} into an object
          ++ of type \spad{S}. If it can, then such an object is
          ++ returned. Otherwise, "failed" is returned.
        retractable?: Any -> Boolean
          ++ retractable?(a) tests if \spad{a} can be converted
          ++ into an object of type \spad{S}.
        retract     : Any -> S
          ++ retract(a) tries to convert \spad{a} into an object of
          ++ type \spad{S}. If possible, it returns the object.
          ++ Error: if no such retraction is possible.

    == add
        import NoneFunctions1(S)

        Sexpr:SExpression := devaluate(S)$Lisp

        retractable? a  == dom(a) = Sexpr
        coerce(s:S):Any == any(Sexpr, s::None)

        retractIfCan a ==
            retractable? a => obj(a) pretend S
            "failed"

        retract a ==
            retractable? a => obj(a) pretend S
            error "Cannot retract value."

@
<<ANY1.dotabb>>=
"ANY1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ANY1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"ANY1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package APPLYORE ApplyUnivariateSkewPolynomial}
\pagehead{ApplyUnivariateSkewPolynomial}{APPLYORE}
\pagepic{ps/v104applyunivariateskewpolynomial.ps}{APPLYORE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package APPLYORE ApplyUnivariateSkewPolynomial>>=
)abbrev package APPLYORE ApplyUnivariateSkewPolynomial
++ Author: Manuel Bronstein
++ Date Created: 7 December 1993
++ Date Last Updated: 1 February 1994
++ Description:
++   \spad{ApplyUnivariateSkewPolynomial} (internal) allows univariate
++   skew polynomials to be applied to appropriate modules.
ApplyUnivariateSkewPolynomial(R:Ring, M: LeftModule R,
    P: UnivariateSkewPolynomialCategory R): with
      apply: (P, M -> M, M) -> M
        ++ apply(p, f, m) returns \spad{p(m)} where the action is given
        ++ by \spad{x m = f(m)}.
        ++ \spad{f} must be an R-pseudo linear map on M.
   == add
      apply(p, f, m) ==
        w:M  := 0
        mn:M := m
        for i in 0..degree p repeat
          w  := w + coefficient(p, i) * mn
          mn := f mn
        w

@
<<APPLYORE.dotabb>>=
"APPLYORE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=APPLYORE"]
"OREPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OREPCAT"]
"APPLYORE" -> "OREPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ASSOCEQ AssociatedEquations}
\pagehead{AssociatedEquations}{ASSOCEQ}
\pagepic{ps/v104associatedequations.ps}{ASSOCEQ}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ASSOCEQ AssociatedEquations>>=
)abbrev package ASSOCEQ AssociatedEquations
++ Author: Manuel Bronstein
++ Date Created: 10 January 1994
++ Date Last Updated: 3 February 1994
++ Description:
++ \spadtype{AssociatedEquations} provides functions to compute the
++ associated equations needed for factoring operators
AssociatedEquations(R, L):Exports == Implementation where
  R: IntegralDomain
  L: LinearOrdinaryDifferentialOperatorCategory R
 
  PI  ==> PositiveInteger
  N   ==> NonNegativeInteger
  MAT ==> Matrix R
  REC ==> Record(minor: List PI, eq: L, minors: List List PI, ops: List L)
 
  Exports ==> with
    associatedSystem: (L, PI) -> Record(mat: MAT, vec:Vector List PI)
      ++ associatedSystem(op, m) returns \spad{[M,w]} such that the
      ++ m-th associated equation system to L is \spad{w' = M w}.
    uncouplingMatrices: MAT -> Vector MAT
      ++ uncouplingMatrices(M) returns \spad{[A_1,...,A_n]} such that if
      ++ \spad{y = [y_1,...,y_n]} is a solution of \spad{y' = M y}, then
      ++ \spad{[$y_j',y_j'',...,y_j^{(n)}$] = $A_j y$} for all j's.
    if R has Field then
        associatedEquations: (L, PI) -> REC
          ++ associatedEquations(op, m) returns \spad{[w, eq, lw, lop]}
          ++ such that \spad{eq(w) = 0} where w is the given minor, and
          ++ \spad{lw_i = lop_i(w)} for all the other minors.
 
  Implementation ==> add
    makeMatrix: (Vector MAT, N) -> MAT
 
    diff:L := D()
 
    makeMatrix(v, n) == matrix [parts row(v.i, n) for i in 1..#v]
 
    associatedSystem(op, m) ==
      eq: Vector R
      S := SetOfMIntegersInOneToN(m, n := degree(op)::PI)
      w := enumerate()$S
      s := size()$S
      ww:Vector List PI := new(s, empty())
      M:MAT := new(s, s, 0)
      m1 := (m::Integer - 1)::PI
      an := leadingCoefficient op
      a:Vector(R) := [- (coefficient(op, j) exquo an)::R for j in 0..n - 1]
      for i in 1..s repeat
          eq := new(s, 0)
          wi := w.i
          ww.i := elements wi
          for k in 1..m1 repeat
              u := incrementKthElement(wi, k::PI)$S
              if u case S then eq(lookup(u::S)) := 1
          if member?(n, wi) then
              for j in 1..n | a.j ^= 0 repeat
                  u := replaceKthElement(wi, m, j::PI)
                  if u case S then
                    eq(lookup(u::S)) := (odd? delta(wi, m, j::PI) => -a.j; a.j)
          else
              u := incrementKthElement(wi, m)$S
              if u case S then eq(lookup(u::S)) := 1
          setRow_!(M, i, eq)
      [M, ww]
 
    uncouplingMatrices m ==
      n := nrows m
      v:Vector MAT := new(n, zero(1, 0)$MAT)
      v.1 := mi := m
      for i in 2..n repeat v.i := mi := map(diff #1, mi) + mi * m
      [makeMatrix(v, i) for i in 1..n]
 
    if R has Field then
        import PrecomputedAssociatedEquations(R, L)
 
        makeop:    Vector R -> L
        makeeq:    (Vector List PI, MAT, N, N) -> REC
        computeIt: (L, PI, N) -> REC
 
        makeeq(v, m, i, n) ==
          [v.i, makeop row(m, i) - 1, [v.j for j in 1..n | j ^= i],
                                    [makeop row(m, j) for j in 1..n | j ^= i]]
 
        associatedEquations(op, m) ==
          (u := firstUncouplingMatrix(op, m)) case "failed" => computeIt(op,m,1)
          (v := inverse(u::MAT)) case "failed" => computeIt(op, m, 2)
          S := SetOfMIntegersInOneToN(m, degree(op)::PI)
          w := enumerate()$S
          s := size()$S
          ww:Vector List PI := new(s, empty())
          for i in 1..s repeat ww.i := elements(w.i)
          makeeq(ww, v::MAT, 1, s)
 
        computeIt(op, m, k) ==
          rec := associatedSystem(op, m)
          a := uncouplingMatrices(rec.mat)
          n := #a
          for i in k..n repeat
            (u := inverse(a.i)) case MAT => return makeeq(rec.vec,u::MAT,i,n)
          error "associatedEquations: full degenerate case"
 
        makeop v ==
          op:L := 0
          for i in 1..#v repeat op := op + monomial(v i, i)
          op

@
<<ASSOCEQ.dotabb>>=
"ASSOCEQ" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ASSOCEQ"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"ASSOCEQ" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMPRED AttachPredicates}
\pagehead{AttachPredicates}{PMPRED}
\pagepic{ps/v104attachpredicates.ps}{PMPRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMPRED AttachPredicates>>=
)abbrev package PMPRED AttachPredicates
++ Predicates for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching predicates to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
AttachPredicates(D:Type): Exports == Implementation where
  FE ==> Expression Integer

  Exports ==> with
    suchThat: (Symbol, D -> Boolean) -> FE
      ++ suchThat(x, foo) attaches the predicate foo to x.
    suchThat: (Symbol, List(D -> Boolean)) -> FE
      ++ suchThat(x, [f1, f2, ..., fn]) attaches the predicate
      ++ f1 and f2 and ... and fn to x.

  Implementation ==> add
    import FunctionSpaceAttachPredicates(Integer, FE, D)

    suchThat(p:Symbol, f:D -> Boolean)       == suchThat(p::FE, f)
    suchThat(p:Symbol, l:List(D -> Boolean)) == suchThat(p::FE, l)

@
<<PMPRED.dotabb>>=
"PMPRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMPRED"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"PMPRED" -> "PID"
"PMPRED" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AXSERV AxiomServer}
\pagehead{AxiomServer}{AXSERV}
\pagepic{ps/v104axiomserver.ps}{AXSERV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AXSERV AxiomServer>>=

)abbrev package AXSERV AxiomServer
AxiomServer: public == private where

 public == with

   axServer: (Integer, SExpression->Void) -> Void
   multiServ: SExpression -> Void
   getDatabase: (String,String) -> String

 private == add

   getFile: (SExpression,String) -> Void
   getCommand: (SExpression,String) -> Void
   getDescription: String -> String
   getInterp: (SExpression,String) -> Void
   getLisp:   (SExpression,String) -> Void
   getShow:   (SExpression,String) -> Void
   lastStep: () -> String
   lastType: () -> String
   formatMessages: String -> String
   makeErrorPage: String -> String
   getSourceFile: (String,String,String) -> String
   makeDBPage: String -> String
   getContentType: String -> String
   readTheFile: SExpression -> String 
   outputToSocket: (SExpression,String,String) -> Void 

   getDatabase(constructor:String, key:String):String ==
     answer:=string GETDATABASE(INTERN$Lisp constructor,INTERN$Lisp key)$Lisp
--     WriteLine$Lisp concat ["getDatabase: ",constructor," ",key," ",answer]
     answer

@
The axServer function handles the socket connection on the given port.
When it gets a input on the socket it calls the server
function on the socket input.
<<package AXSERV AxiomServer>>=
   axServer(port:Integer,serverfunc:SExpression->Void):Void ==
     WriteLine$Lisp "listening on port 8085"
     s := SiSock(port,serverfunc)$Lisp
     -- To listen for just one connection and then close the socket
     -- uncomment i := 0.
     i:Integer := 1
     while (i > 0) repeat
       if not null?(SiListen(s)$Lisp)$SExpression then
         w := SiAccept(s)$Lisp
         serverfunc(w)
--        i := 0

@
The multiServ function parses the socket input.
It expects either a GET or POST request.

A GET request fetches a new page, calling ``getFile''.
A POST request starts with 
\begin{itemize}
\item ``command='' which expects axiom interpreter commands. 
       When this is recognized we call the ``getCommand'' function.
\item ``lispcall='' which expects lisp interpreter input
       When this is recognized we call the ``getLisp'' function.
\end{itemize}
<<package AXSERV AxiomServer>>=

   multiServ(s:SExpression):Void ==
--     WriteLine("multiServ begin")$Lisp
     headers:String := ""
     char:String
     -- read in the http headers
     while (char := _
       STRING(READ_-CHAR_-NO_-HANG(s,NIL$Lisp,'EOF)$Lisp)$Lisp) ^= "EOF"_
        repeat
         headers := concat [headers,char]
--     sayTeX$Lisp headers
     StringMatch("([^ ]*)", headers)$Lisp
     u:UniversalSegment(Integer)
     u := segment(MatchBeginning(1)$Lisp+1,_
                  MatchEnd(1)$Lisp)$UniversalSegment(Integer)
     reqtype:String := headers.u
--     sayTeX$Lisp  concat ["request type: ",reqtype]
     if  reqtype = "GET" then
         StringMatch("GET ([^ ]*)",headers)$Lisp
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getFile(s,headers.u)
     if reqtype = "POST" and StringMatch("command=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getCommand(s,headers.u)
     if reqtype = "POST" and StringMatch("interpcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getInterp(s,headers.u)
     if reqtype = "POST" and StringMatch("lispcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getLisp(s,headers.u)
     if reqtype = "POST" and StringMatch("showcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getShow(s,headers.u)
--     WriteLine("multiServ end")$Lisp
--     WriteLine("")$Lisp

@
\subsubsection{getFile}
Given a socket and the URL of the file we create an input stream 
that contains the file. If the filename contains a question mark
then we need to parse the parameters and dynamically construct the
file contents.
<<package AXSERV AxiomServer>>=
   getFile(s:SExpression,pathvar:String):Void ==
--     WriteLine("")$Lisp
     WriteLine$Lisp concat ["getFile: ",pathvar]
     params:=split(pathvar,char "?")
     if #params = 1 
      then if not null? PATHNAME_-NAME(PATHNAME(pathvar)$Lisp)$Lisp 
       then
         contentType:String := getContentType(pathvar)
         q:=Open(pathvar)$Lisp
         if null? q 
           then
             q := MAKE_-STRING_-INPUT_-STREAM(_
                   makeErrorPage("File doesn't exist"))$Lisp
       else
         q:=MAKE_-STRING_-INPUT_-STREAM(_
             makeErrorPage("Problem with file path"))$Lisp
      else
       q:=MAKE_-STRING_-INPUT_-STREAM(makeDBPage(pathvar))$Lisp
     outputToSocket(s,readTheFile(q),contentType)     

@
\subsubsection{makeErrorPage}
<<package AXSERV AxiomServer>>=
   makeErrorPage(msg:String):String ==
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head><title>Error</title></head><body>" msg "</body></html>"
--     WriteLine(page)$Lisp
     page
@
\subsubsection{getDescription}
We need to fish around in the data structure to return the piece of 
documentation for the domain. We have to call the lisp version of
GETDATABASE because the version above returns a string object. The
string object is missing quotes and cannot be properly read. So we
need to get the lisp object and work with it in native form first.

The doc string also contains spad markup which we need to replace with html.
<<package AXSERV AxiomServer>>=
   getDescription(dom:String):String ==
    d:=CADR(CADAR(GETDATABASE(INTERN(dom)$Lisp,'DOCUMENTATION)$Lisp)$Lisp)$Lisp
    string d
@
\subsubsection{getSourceFile}
During build we construct a hash table that takes the chunk name as
the key and returns the filename. We reconstruct the chunk name here
and do a lookup for the source file.
<<package AXSERV AxiomServer>>=
   getSourceFile(constructorkind:String,_
                 abbreviation:String,_
                 dom:String):String ==
     sourcekey:="@<<" constructorkind " " abbreviation " " dom ">>"
--     WriteLine(sourcekey)$Lisp
     sourcefile:=lowerCase last split(getDatabase(dom,"SOURCEFILE"),char "/") 
     sourcefile:=sourcefile ".pamphlet"

@
\subsubsection{makeDBPage}
<<package AXSERV AxiomServer>>=
   makeDBPage(pathvar:String):String ==
     params:List(String):=split(pathvar,char "?")
     for i in 1..#params repeat WriteLine$Lisp concat ["params: ",params.i]
     pathparts:List(String):=split(params.1,char "/")
     for i in 1..#pathparts repeat 
       WriteLine$Lisp concat ["pathparts: ",pathparts.i]
     pagename:=last pathparts
     WriteLine$Lisp concat ["pagename: ",pagename]
     cmd:=first split(pagename,char ".")
     WriteLine$Lisp concat ["cmd: ",cmd]
     args:List(String):=split(params.2, char "&")
     for i in 1..#args repeat WriteLine$Lisp concat ["args: ",args.i]
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head>"
     page:=page "<meta http-equiv=_"Content-Type_" content=_"text/html_"" 
     page:=page " charset=_"us-ascii_"/>"
     page:=page "<title>" cmd " " args.1 "</title></head>"
     page:=page "<style> html { background-color: #FFFF66; } </style>"
     page:=page "<body>"
     cmd = "db" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
     cmd = "op" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
--     WriteLine(page)$Lisp
     page:=page "</body></html>"
     page
@
\subsubsection{readTheFile}
We have q which is a stream which contains the file. We read the file
into a string-stream to get it all into one string. We return the string.
<<package AXSERV AxiomServer>>=
   readTheFile(q:SExpression):String ==
--     WriteLine("begin reading file")$Lisp
     r := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
     SiCopyStream(q,r)$Lisp
     filestream:String := GET_-OUTPUT_-STREAM_-STRING(r)$Lisp
     CLOSE(r)$Lisp
     CLOSE(q)$Lisp
--     WriteLine("end reading file")$Lisp
     filestream

@
\subsubsection{outputToSocket}
We have ``s'' which is the socket, ``filestream'' which is the text of
the file to output, and ``contentType'' which is the HTML Content-Type.
We construct the HTML header information according to the standard and
prepend it to the file. The resulting string is output to the socket.
<<package AXSERV AxiomServer>>=
   outputToSocket(s:SExpression,filestream:String,contentType:String):Void ==
     filelength:String := string(#filestream)
     file:String := ""
     nl:String:=STRING(NewLine$Lisp)$Lisp
     file := concat ["Content-Length: ",filelength,nl,nl,file]
     file := concat ["Connection: close",nl,file]
     file := concat ["Content-Type: ",contentType,nl,file]
     file := concat ["HTTP/1.1 200 OK",nl,file]
     file := concat [file,filestream]
--     WriteLine(file)$Lisp
     f:=MAKE_-STRING_-INPUT_-STREAM(file)$Lisp
     SiCopyStream(f,s)$Lisp
     CLOSE(f)$Lisp
     CLOSE(s)$Lisp

@
\subsubsection{getCommand}
The getCommand function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getCommand(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getCommand: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getInterp}
The getInterp function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getInterp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getInterp: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getLisp}
The getLisp function is invoked when the HTTP request is a POST
and contains the string "lispcall".
<<package AXSERV AxiomServer>>=
   getLisp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getLisp: ",command]
       evalresult:=EVAL(READ_-FROM_-STRING(command)$Lisp)$Lisp
       mathml:String:=string(evalresult)
--       WriteLine$Lisp concat ["getLisp: after ",mathml]
--       WriteLine$Lisp concat ["getLisp output: ",mathml]
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", command, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{getShow}
The getShow function is invoked when the HTTP request is a POST
and contains the string "showcall". The )show command generates
output to lisp's *standard-output* so we wrap that stream to capture it.
The resulting string needs to be transformed into html-friendly form.
This is done in the call to replace-entitites (see http.lisp)
<<package AXSERV AxiomServer>>=
   getShow(s:SExpression,showarg:String):Void ==
       WriteLine$Lisp concat ["getShow: ",showarg]
       realarg:=SUBSEQ(showarg,6)$Lisp
       show:=_
        "(progn (setq |$options| '((|operations|))) (|show| '|" realarg "|))"
--       WriteLine$Lisp concat ["getShow: ",show]
       SETQ(SAVESTREAM$Lisp,_*STANDARD_-OUTPUT_*$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,_
             MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       evalresult:=EVAL(READ_-FROM_-STRING(show)$Lisp)$Lisp
       SETQ(evalresult,_
             GET_-OUTPUT_-STREAM_-STRING(_*STANDARD_-OUTPUT_*$Lisp)$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,SAVESTREAM$Lisp)$Lisp
       mathml:String:=string(REPLACE_-ENTITIES(evalresult)$Lisp)
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", showarg, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{lastType}
To examine the \$internalHistoryTable use the following line
\begin{verbatim}
  )lisp |$internalHistoryTable|
\end{verbatim}
We need to pick out first member of internalHistoryTable and then pick out
the element with \% as first element. Here is an example showing just
the first element of the list, which correponds to the last command.

Note that the last command does not necessarily correspond to the last
element of the first element of \$internalHistoryTable as it is in this
example.
\begin{verbatim}
   (
    (4 NIL
    (x (value (BasicOperator) WRAPPED . #<vector 09a93bd0>))
    (y (value (BasicOperator) WRAPPED . #<vector 09a93bb4>))
    (% (value (Matrix (Polynomial (Integer))) WRAPPED . #<vector 0982e0e0>))
    )
   ...
   )
\end{verbatim}

We also need to check for input error in which case the \$internalHistoryTable
is not changed and the type retrieved would be that for the last correct
input.
<<package AXSERV AxiomServer>>=
   lastType():String ==
     SETQ(first$Lisp,FIRST(_$internalHistoryTable$Lisp)$Lisp)$Lisp
     count:Integer := 0
     hisLength:Integer := LIST_-LENGTH(_$internalHistoryTable$Lisp)$Lisp
     length:Integer := LIST_-LENGTH(first$Lisp)$Lisp
     -- This initializes stepSav.  The test is a bit of a hack, maybe I'll
     -- figure out the right way to do it later.
     if string stepSav$Lisp = "#<OBJNULL>" then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     -- If hisLength = 0 then the history table has been reset to NIL
     -- and we're starting numbering over
     if hisLength = 0 then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     if hisLength > 0 and 
       car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp ^= stepSav$Lisp then
        SETQ(stepSav$Lisp,car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp)$Lisp
        while count < length  repeat
         position(char "%",string FIRST(first$Lisp)$Lisp) = 2 => 
           count := length+1
         count := count +1
         SETQ(first$Lisp,REST(first$Lisp)$Lisp)$Lisp
     count = length + 1 => 
         string SECOND(SECOND(FIRST(first$Lisp)$Lisp)$Lisp)$Lisp
     ""


   lastStep():String ==
       string car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp

   formatMessages(str:String):String ==
--       WriteLine("formatMessages")$Lisp
       -- I need to replace any ampersands with &amp; and may also need to
       -- replace < and > with &lt; and &gt;
       strlist:List String
--       WriteLine(str)$Lisp
       strlist := split(str,char "&")
       str := ""
       -- oops, if & is the last character in the string this method
       -- will eliminate it.  Need to redo this.
       for s in strlist repeat
           str := concat [str,s,"&amp;"]
       strlen:Integer := #str
       str := str.(1..(#str - 5))
--       WriteLine(str)$Lisp
       -- Here I split the string into lines and put each line in a "div".
       strlist := split(str, char string NewlineChar$Lisp)
       str := ""
--       WriteLine("formatMessages1")$Lisp
--       WriteLine(concat strlist)$Lisp
       for s in strlist repeat
--           WriteLine(s)$Lisp
           str := concat [str,"<div>",s,"</div>"]
       str

   getContentType(pathvar:String):String ==
--       WriteLine("getContentType begin")$Lisp
       -- set default content type
       contentType:String := "text/plain"
       -- need to test for successful match?
       StringMatch(".*\.(.*)$", pathvar)$Lisp
       u:UniversalSegment(Integer)
       u := segment(MatchBeginning(1)$Lisp+1,_
                    MatchEnd(1)$Lisp)$UniversalSegment(Integer)
       extension:String := pathvar.u
--       WriteLine$Lisp concat ["file extension: ",extension]
       -- test for extensions: html, htm, xml, xhtml, js, css
       if extension = "html" then
           contentType:String := "text/html"
       else if extension = "htm" then
           contentType:String := "text/html"
       else if extension = "xml" then
           contentType:String := "text/xml"
       else if extension = "xhtml" then
           contentType:String := "application/xhtml+xml"
       else if extension = "js" then
           contentType:String := "text/javascript"
       else if extension = "css" then
           contentType:String := "text/css"
       else if extension = "png" then
           contentType:String := "image/png"
       else if extension = "jpg" then
           contentType:String := "image/jpeg"
       else if extension = "jpeg" then
           contentType:String := "image/jpeg"
--       WriteLine$Lisp concat ["Content-Type: ",contentType]
--       WriteLine("getContentType end")$Lisp
       contentType

@
<<AXSERV.dotabb>>=
"AXSERV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AXSERV"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"AXSERV" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter B}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BALFACT BalancedFactorisation}
\pagehead{BalancedFactorisation}{BALFACT}
\pagepic{ps/v104balancedfactorisation.ps}{BALFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BALFACT BalancedFactorisation>>=
)abbrev package BALFACT BalancedFactorisation
++ Author: Manuel Bronstein
++ Date Created: 1 March 1991
++ Date Last Updated: 11 October 1991
++ Description: This package provides balanced factorisations of polynomials.
BalancedFactorisation(R, UP): Exports == Implementation where
  R  : Join(GcdDomain, CharacteristicZero)
  UP : UnivariatePolynomialCategory R

  Exports ==> with
    balancedFactorisation: (UP, UP) -> Factored UP
      ++ balancedFactorisation(a, b) returns
      ++ a factorisation \spad{a = p1^e1 ... pm^em} such that each
      ++ \spad{pi} is balanced with respect to b.
    balancedFactorisation: (UP, List UP) -> Factored UP
      ++ balancedFactorisation(a, [b1,...,bn]) returns
      ++ a factorisation \spad{a = p1^e1 ... pm^em} such that each
      ++ pi is balanced with respect to \spad{[b1,...,bm]}.

  Implementation ==> add
    balSqfr : (UP, Integer, List UP) -> Factored UP
    balSqfr1: (UP, Integer,      UP) -> Factored UP

    balancedFactorisation(a:UP, b:UP) == balancedFactorisation(a, [b])

    balSqfr1(a, n, b) ==
      g := gcd(a, b)
      fa := sqfrFactor((a exquo g)::UP, n)
      ground? g => fa
      fa * balSqfr1(g, n, (b exquo (g ** order(b, g)))::UP)

    balSqfr(a, n, l) ==
      b := first l
      empty? rest l => balSqfr1(a, n, b)
      */[balSqfr1(f.factor, n, b) for f in factors balSqfr(a,n,rest l)]

    balancedFactorisation(a:UP, l:List UP) ==
      empty?(ll := select(#1 ^= 0, l)) =>
        error "balancedFactorisation: 2nd argument is empty or all 0"
      sa := squareFree a
      unit(sa) * */[balSqfr(f.factor,f.exponent,ll) for f in factors sa])

@
<<BALFACT.dotabb>>=
"BALFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BALFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BALFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BOP1 BasicOperatorFunctions1}
\pagehead{BasicOperatorFunctions1}{BOP1}
\pagepic{ps/v104basicoperatorfunctions1.ps}{BOP1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BOP1 BasicOperatorFunctions1>>=
)abbrev package BOP1 BasicOperatorFunctions1
++ Tools to set/get common properties of operators
++ Author: Manuel Bronstein
++ Date Created: 28 Mar 1988
++ Date Last Updated: 15 May 1990
++ Description:
++   This package exports functions to set some commonly used properties
++   of operators, including properties which contain functions.
++ Keywords: operator.
BasicOperatorFunctions1(A:SetCategory): Exports == Implementation where
  OP   ==> BasicOperator
  EVAL    ==> "%eval"
  CONST   ==> "%constant"
  DIFF    ==> "%diff"

  Exports ==> with
    evaluate        : (OP, List A)      -> Union(A, "failed")
      ++ evaluate(op, [a1,...,an]) checks if op has an "%eval"
      ++ property f. If it has, then \spad{f(a1,...,an)} is returned, and
      ++ "failed" otherwise.
    evaluate        : (OP, List A -> A) -> OP
      ++ evaluate(op, foo) attaches foo as the "%eval" property
      ++ of op. If op has an "%eval" property f, then applying op
      ++ to \spad{(a1,...,an)} returns the result of \spad{f(a1,...,an)}.
    evaluate        : (OP, A -> A)      -> OP
      ++ evaluate(op, foo) attaches foo as the "%eval" property
      ++ of op. If op has an "%eval" property f, then applying op
      ++ to a returns the result of \spad{f(a)}. Argument op must be unary.
    evaluate        : OP                -> Union(List A -> A, "failed")
      ++ evaluate(op) returns the value of the "%eval" property of
      ++ op if it has one, and "failed" otherwise.
    derivative      : (OP, List (List A -> A)) -> OP
      ++ derivative(op, [foo1,...,foon]) attaches [foo1,...,foon] as
      ++ the "%diff" property of op. If op has an "%diff" property
      ++ \spad{[f1,...,fn]} then applying a derivation D 
      ++ to \spad{op(a1,...,an)}
      ++ returns \spad{f1(a1,...,an) * D(a1) + ... + fn(a1,...,an) * D(an)}.
    derivative      : (OP, A -> A) -> OP
      ++ derivative(op, foo) attaches foo as the "%diff" property
      ++ of op. If op has an "%diff" property f, then applying a
      ++ derivation D to op(a) returns \spad{f(a) * D(a)}. 
      ++ Argument op must be unary.
    derivative      : OP -> Union(List(List A -> A), "failed")
      ++ derivative(op) returns the value of the "%diff" property of
      ++ op if it has one, and "failed" otherwise.
    if A has OrderedSet then
      constantOperator: A -> OP
        ++ constantOperator(a) returns a nullary operator op
        ++ such that \spad{op()} always evaluate to \spad{a}.
      constantOpIfCan : OP -> Union(A, "failed")
        ++ constantOpIfCan(op) returns \spad{a} if op is the constant
        ++ nullary operator always returning \spad{a}, "failed" otherwise.

  Implementation ==> add
    evaluate(op:OP, func:A -> A) == evaluate(op, func first #1)

    evaluate op ==
      (func := property(op, EVAL)) case "failed" => "failed"
      (func::None) pretend (List A -> A)

    evaluate(op:OP, args:List A) ==
      (func := property(op, EVAL)) case "failed" => "failed"
      ((func::None) pretend (List A -> A)) args

    evaluate(op:OP, func:List A -> A) ==
      setProperty(op, EVAL, func pretend None)

    derivative op ==
      (func := property(op, DIFF)) case "failed" => "failed"
      ((func::None) pretend List(List A -> A))

    derivative(op:OP, grad:List(List A -> A)) ==
      setProperty(op, DIFF, grad pretend None)

    derivative(op:OP, f:A -> A) ==
      unary? op or nary? op =>
        derivative(op, [f first #1]$List(List A -> A))
      error "Operator is not unary"

    if A has OrderedSet then
      cdisp   : (OutputForm, List OutputForm) -> OutputForm
      csex    : (InputForm,  List InputForm) -> InputForm
      eqconst?: (OP, OP) -> Boolean
      ltconst?: (OP, OP) -> Boolean
      constOp : A -> OP

      opconst:OP :=
        comparison(equality(operator("constant"::Symbol, 0), eqconst?),
                                                               ltconst?)

      cdisp(a, l) == a
      csex(a, l)  == a

      eqconst?(a, b) ==
        (va := property(a, CONST)) case "failed" => not has?(b, CONST)
        ((vb := property(b, CONST)) case None) and
           ((va::None) pretend A) = ((vb::None) pretend A)

      ltconst?(a, b) ==
        (va := property(a, CONST)) case "failed" => has?(b, CONST)
        ((vb := property(b, CONST)) case None) and
           ((va::None) pretend A) < ((vb::None) pretend A)

      constOp a ==
        setProperty(display(copy opconst, cdisp(a::OutputForm, #1)),
                                                  CONST, a pretend None)

      constantOpIfCan op ==
        is?(op, "constant"::Symbol) and
          ((u := property(op, CONST)) case None) => (u::None) pretend A
        "failed"

      if A has ConvertibleTo InputForm then
        constantOperator a == input(constOp a, csex(convert a, #1))
      else
        constantOperator a == constOp a

@
<<BOP1.dotabb>>=
"BOP1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BOP1"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"BOP1" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BEZOUT BezoutMatrix}
\pagehead{BezoutMatrix}{BEZOUT}
\pagepic{ps/v104bezoutmatrix.ps}{BEZOUT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BEZOUT BezoutMatrix>>=
)abbrev package BEZOUT BezoutMatrix
++ Author: Clifton J. Williamson
++ Date Created: 2 August 1988
++ Date Last Updated: 3 November 1993
++ Basic Operations: bezoutMatrix, bezoutResultant, bezoutDiscriminant
++ Related Domains
++ Also See:
++ AMS Classifiactions:
++ Keywords: Bezout matrix, resultant, discriminant
++ Examples:
++ Reference: Knuth, The Art of Computer Programming, 2nd edition,
++            Vol. 2, p. 619, problem 12.
++ Description:
++   \spadtype{BezoutMatrix} contains functions for computing resultants and
++   discriminants using Bezout matrices.

BezoutMatrix(R,UP,M,Row,Col): Exports == Implementation where
  R    : Ring
  UP   : UnivariatePolynomialCategory R
  Row  : FiniteLinearAggregate R
  Col  : FiniteLinearAggregate R
  M    : MatrixCategory(R,Row,Col)
  I  ==> Integer
  lc ==> leadingCoefficient

  Exports ==> with
    sylvesterMatrix: (UP,UP) -> M
      ++ sylvesterMatrix(p,q) returns the Sylvester matrix for the two
      ++ polynomials p and q.
    bezoutMatrix: (UP,UP) -> M
      ++ bezoutMatrix(p,q) returns the Bezout matrix for the two
      ++ polynomials p and q.

    if R has commutative("*") then
      bezoutResultant: (UP,UP) -> R
       ++ bezoutResultant(p,q) computes the resultant of the two
       ++ polynomials p and q by computing the determinant of a Bezout matrix.

      bezoutDiscriminant: UP -> R
       ++ bezoutDiscriminant(p) computes the discriminant of a polynomial p
       ++ by computing the determinant of a Bezout matrix.

  Implementation ==> add

    sylvesterMatrix(p,q) ==
      n1 := degree p; n2 := degree q; n := n1 + n2
      sylmat : M := new(n,n,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not zero? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        for i in 0..n2 - 1 repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        for i in 0..n1-1 repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      sylmat

    bezoutMatrix(p,q) ==
    -- This function computes the Bezout matrix for 'p' and 'q'.
    -- See Knuth, The Art of Computer Programming, Vol. 2, p. 619, # 12.
    -- One must have deg(p) >= deg(q), so the arguments are reversed
    -- if this is not the case.
      n1 := degree p; n2 := degree q; n := n1 + n2
      n1 < n2 => bezoutMatrix(q,p)
      m1 : I := n1 - 1; m2 : I := n2 - 1; m : I := n - 1
      -- 'sylmat' will be a matrix consisting of the first n1 columns
      -- of the standard Sylvester matrix for 'p' and 'q'
      sylmat : M := new(n,n1,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not ground? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        -- for i = 0...
        -- quit when i > m2 or when i + (n1 - k) > m1, whichever happens first
        for i in 0..min(m2,deg - 1) repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        -- put ak = coef(q,k) in sylmat(minR + n1 + i,minC + i + (n2 - k))
        -- for i = 0...
        -- quit when i > m1 or when i + (n2 - k) > m1, whichever happens first
        -- since n2 - k >= 0, we quit when i + (n2 - k) > m1
        for i in 0..(deg + n1 - n2 - 1) repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      -- 'bezmat' will be the 'Bezout matrix' as described in Knuth
      bezmat : M := new(n1,n1,0)
      for i in 0..m2 repeat
        -- replace A_i by (b_0 A_i + ... + b_{n_2-1-i} A_{n_2 - 1}) -
        -- (a_0 B_i + ... + a_{n_2-1-i} B_{n_2-1}), as in Knuth
        bound : I := n2 - i; q0 := q
        while not zero? q0 repeat
          deg := degree q0
          if (deg < bound) then
            -- add b_deg A_{n_2 - deg} to the new A_i
            coef := lc q0
            for k in minC..maxC repeat
              c := coef * qelt(sylmat,minR + m2 - i - deg,k) +
                          qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          q0 := reductum q0
        p0 := p
        while not zero? p0 repeat
          deg := degree p0
          if deg < bound then
            coef := lc p0
            -- subtract a_deg B_{n_2 - deg} from the new A_i
            for k in minC..maxC repeat
              c := -coef * qelt(sylmat,minR + m - i - deg,k) +
                           qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          p0 := reductum p0
      for i in n2..m1 repeat for k in minC..maxC repeat
        qsetelt_!(bezmat,minR + i,k,qelt(sylmat,minR + i,k))
      bezmat

    if R has commutative("*") then

      bezoutResultant(f,g) == determinant bezoutMatrix(f,g)

      if R has IntegralDomain then

        bezoutDiscriminant f ==
          degMod4 := (degree f) rem 4
          (degMod4 = 0) or (degMod4 = 1) =>
            (bezoutResultant(f,differentiate f) exquo (lc f)) :: R
          -((bezoutResultant(f,differentiate f) exquo (lc f)) :: R)

        else

          bezoutDiscriminant f ==
            lc f = 1 =>
              degMod4 := (degree f) rem 4
              (degMod4 = 0) or (degMod4 = 1) =>
                bezoutResultant(f,differentiate f)
              -bezoutResultant(f,differentiate f)
            error "bezoutDiscriminant: leading coefficient must be 1"

@
<<BEZOUT.dotabb>>=
"BEZOUT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BEZOUT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BEZOUT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BOUNDZRO BoundIntegerRoots}
\pagehead{BoundIntegerRoots}{BOUNDZRO}
\pagepic{ps/v104boundintegerroots.ps}{BOUNDZRO}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BOUNDZRO BoundIntegerRoots>>=
)abbrev package BOUNDZRO BoundIntegerRoots
++ Author: Manuel Bronstein
++ Date Created: 11 March 1991
++ Date Last Updated: 18 November 1991
++ Description:
++   \spadtype{BoundIntegerRoots} provides functions to
++   find lower bounds on the integer roots of a polynomial.
BoundIntegerRoots(F, UP): Exports == Implementation where
  F  : Join(Field, RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F

  Z   ==> Integer
  Q   ==> Fraction Z
  K   ==> Kernel F
  UPQ ==> SparseUnivariatePolynomial Q
  ALGOP ==> "%alg"

  Exports ==> with
    integerBound: UP -> Z
      ++ integerBound(p) returns a lower bound on the negative integer
      ++ roots of p, and 0 if p has no negative integer roots.

  Implementation ==> add
    import RationalFactorize(UPQ)
    import UnivariatePolynomialCategoryFunctions2(F, UP, Q, UPQ)

    qbound : (UP, UPQ) -> Z
    zroot1 : UP -> Z
    qzroot1: UPQ -> Z
    negint : Q -> Z

-- returns 0 if p has no integer root < 0, its negative integer root otherwise
    qzroot1 p == negint(- leadingCoefficient(reductum p) / leadingCoefficient p)

-- returns 0 if p has no integer root < 0, its negative integer root otherwise
    zroot1 p ==
      z := - leadingCoefficient(reductum p) / leadingCoefficient p
      (r := retractIfCan(z)@Union(Q, "failed")) case Q => negint(r::Q)
      0

-- returns 0 if r is not a negative integer, r otherwise
    negint r ==
      ((u := retractIfCan(r)@Union(Z, "failed")) case Z) and (u::Z < 0) => u::Z
      0

    if F has ExpressionSpace then
      bringDown: F -> Q

-- the random substitution used by bringDown is NOT always a ring-homorphism
-- (because of potential algebraic kernels), but is ALWAYS a Z-linear map.
-- this guarantees that bringing down the coefficients of (x + n) q(x) for an
-- integer n yields a polynomial h(x) which is divisible by x + n
-- the only problem is that evaluating with random numbers can cause a
-- division by 0. We should really be able to trap this error later and
-- reevaluate with a new set of random numbers    MB 11/91
      bringDown f ==
        t := tower f
        retract eval(f, t, [random()$Q :: F for k in t])

      integerBound p ==
--        one? degree p => zroot1 p
        (degree p) = 1 => zroot1 p
        q1 := map(bringDown, p)
        q2 := map(bringDown, p)
        qbound(p, gcd(q1, q2))

    else
      integerBound p ==
--        one? degree p => zroot1 p
        (degree p) = 1 => zroot1 p
        qbound(p, map(retract(#1)@Q, p))

-- we can probably do better here (i.e. without factoring)
    qbound(p, q) ==
      bound:Z := 0
      for rec in factors factor q repeat
--        if one?(degree(rec.factor)) and ((r := qzroot1(rec.factor)) < bound)
        if ((degree(rec.factor)) = 1) and ((r := qzroot1(rec.factor)) < bound)
           and zero? p(r::Q::F) then bound := r
      bound

@
<<BOUNDZRO.dotabb>>=
"BOUNDZRO" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BOUNDZRO"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BOUNDZRO" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BRILL BrillhartTests}
\pagehead{BrillhartTests}{BRILL}
\pagepic{ps/v104brillharttests.ps}{BRILL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BRILL BrillhartTests>>=
)abbrev package BRILL BrillhartTests
++ Author: Frederic Lehobey, James H. Davenport
++ Date Created: 28 June 1994
++ Date Last Updated: 11 July 1997
++ Basic Operations: brillhartIrreducible?
++ Related Domains: 
++ Also See:
++ AMS Classifications:
++ Keywords: factorization
++ Examples:
++ References:
++ [1] John Brillhart, Note on Irreducibility Testing,
++ Mathematics of Computation, vol. 35, num. 35, Oct. 1980, 1379-1381
++ [2] James Davenport, On Brillhart Irreducibility. To appear.
++ [3] John Brillhart, On the Euler and Bernoulli polynomials,
++ J. Reine Angew. Math., v. 234, (1969), pp. 45-64

BrillhartTests(UP): Exports == Implementation where
  N ==> NonNegativeInteger
  Z ==> Integer
  UP: UnivariatePolynomialCategory Z

  Exports ==> with
    brillhartIrreducible?: UP -> Boolean -- See [1]
      ++ brillhartIrreducible?(p) returns \spad{true} if p can be shown to be
      ++ irreducible by a remark of Brillhart, \spad{false} is inconclusive.
    brillhartIrreducible?: (UP,Boolean) -> Boolean -- See [1]
      ++ brillhartIrreducible?(p,noLinears) returns \spad{true} if p can be 
      ++ shown to be irreducible by a remark of Brillhart, \spad{false} else.
      ++ If noLinears is \spad{true}, we are being told p has no linear factors
      ++ \spad{false} does not mean that p is reducible.
    brillhartTrials: () -> N
      ++ brillhartTrials() returns the number of tests in
      ++ \spadfun{brillhartIrreducible?}.
    brillhartTrials: N -> N
      ++ brillhartTrials(n) sets to n the number of tests in 
      ++ \spadfun{brillhartIrreducible?} and returns the previous value.
    noLinearFactor?: UP -> Boolean -- See [3] p. 47
      ++ noLinearFactor?(p) returns \spad{true} if p can be shown to have no
      ++ linear factor by a theorem of Lehmer, \spad{false} else. I insist on
      ++ the fact that \spad{false} does not mean that p has a linear factor.

  Implementation ==> add

    import GaloisGroupFactorizationUtilities(Z,UP,Float)

    squaredPolynomial(p:UP):Boolean ==
      d := degree p
      d = 0 => true
      odd? d => false
      squaredPolynomial reductum p

    primeEnough?(n:Z,b:Z):Boolean ==
       -- checks if n is prime, with the possible exception of 
       -- factors whose product is at most b
       import Float
       bb: Float := b::Float
       for i in 2..b repeat
           while (d:= n exquo i) case Integer repeat
                 n:=d::Integer
                 bb:=bb / i::Float
                 bb < 1$Float => return false
                 --- we over-divided, so it can't be prime
       prime? n

    brillharttrials: N := 6
    brillhartTrials():N == brillharttrials

    brillhartTrials(n:N):N ==
      (brillharttrials,n) := (n,brillharttrials)
      n

    brillhartIrreducible?(p:UP):Boolean ==
      brillhartIrreducible?(p,noLinearFactor? p)

    brillhartIrreducible?(p:UP,noLinears:Boolean):Boolean == -- See [1]
      zero? brillharttrials => false
      origBound := (largeEnough := rootBound(p)+1)
      -- see remarks 2 and 4
      even0 := even? coefficient(p,0)
      even1 := even? p(1)
      polyx2 := squaredPolynomial(p)
      prime? p(largeEnough) => true
      not polyx2 and prime? p(-largeEnough) => true
--      one? brillharttrials => false
      (brillharttrials = 1) => false
      largeEnough := largeEnough+1
      primeEnough?(p(largeEnough),if noLinears then 4 else 2) => true
      not polyx2 and
       primeEnough?(p(-largeEnough),if noLinears then 4 else 2) => true
      if odd? largeEnough then 
        if even0 then largeEnough := largeEnough+1
      else 
        if even1 then largeEnough := largeEnough+1
      count :=(if polyx2 then 2 else 1)*(brillharttrials-2)+largeEnough
      for i in (largeEnough+1)..count repeat
        small := if noLinears then (i-origBound)**2 else (i-origBound)
        primeEnough?(p(i),small) => return true
        not polyx2 and primeEnough?(p(-i),small) => return true
      false

    noLinearFactor?(p:UP):Boolean ==
      (odd? leadingCoefficient p) and (odd? coefficient(p,0)) and (odd? p(1)) 

@
<<BRILL.dotabb>>=
"BRILL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BRILL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BRILL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter C}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CARTEN2 CartesianTensorFunctions2}
\pagehead{CartesianTensorFunctions2}{CARTEN2}
\pagepic{ps/v104cartesiantensorfunctions2.ps}{CARTEN2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CARTEN2 CartesianTensorFunctions2>>=
)abbrev package CARTEN2 CartesianTensorFunctions2
++ Author: Stephen M. Watt
++ Date Created: December 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations:  reshape, map
++ Related Domains: CartesianTensor
++ Also See:
++ AMS Classifications:
++ Keywords: tensor
++ Examples:
++ References:
++ Description:
++   This package provides functions to enable conversion of tensors
++   given conversion of the components.

CartesianTensorFunctions2(minix, dim, S, T): CTPcat == CTPdef where
    minix:  Integer
    dim:    NonNegativeInteger
    S, T:   CommutativeRing
    CS  ==> CartesianTensor(minix, dim, S)
    CT  ==> CartesianTensor(minix, dim, T)

    CTPcat == with
        reshape: (List T, CS) -> CT
            ++ reshape(lt,ts) organizes the list of components lt into
            ++ a tensor with the same shape as ts.
        map: (S->T,   CS) -> CT
            ++ map(f,ts) does a componentwise conversion of the tensor ts
            ++ to a tensor with components of type T.
    CTPdef == add
        reshape(l, s) == unravel l
        map(f, s)     == unravel [f e for e in ravel s]

@
<<CARTEN2.dotabb>>=
"CARTEN2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CARTEN2"]
"BMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BMODULE"]
"CARTEN2" -> "BMODULE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CHVAR ChangeOfVariable}
\pagehead{ChangeOfVariable}{CHVAR}
\pagepic{ps/v104changeofvariable.ps}{CHVAR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CHVAR ChangeOfVariable>>=
)abbrev package CHVAR ChangeOfVariable
++ Sends a point to infinity
++ Author: Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 22 Feb 1990
++ Description:
++  Tools to send a point to infinity on an algebraic curve.
ChangeOfVariable(F, UP, UPUP): Exports == Implementation where
  F   : UniqueFactorizationDomain
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP

  N  ==> NonNegativeInteger
  Z  ==> Integer
  Q  ==> Fraction Z
  RF ==> Fraction UP

  Exports ==> with
    mkIntegral: UPUP -> Record(coef:RF, poly:UPUP)
          ++ mkIntegral(p(x,y)) returns \spad{[c(x), q(x,z)]} such that
          ++ \spad{z = c * y} is integral.
          ++ The algebraic relation between x and y is \spad{p(x, y) = 0}.
          ++ The algebraic relation between x and z is \spad{q(x, z) = 0}.
    radPoly   : UPUP -> Union(Record(radicand:RF, deg:N), "failed")
          ++ radPoly(p(x, y)) returns \spad{[c(x), n]} if p is of the form
          ++ \spad{y**n - c(x)}, "failed" otherwise.
    rootPoly  : (RF, N) -> Record(exponent: N, coef:RF, radicand:UP)
          ++ rootPoly(g, n) returns \spad{[m, c, P]} such that
          ++ \spad{c * g ** (1/n) = P ** (1/m)}
          ++ thus if \spad{y**n = g}, then \spad{z**m = P}
          ++ where \spad{z = c * y}.
    goodPoint : (UPUP,UPUP) -> F
          ++ goodPoint(p, q) returns an integer a such that a is neither
          ++ a pole of \spad{p(x,y)} nor a branch point of \spad{q(x,y) = 0}.
    eval      : (UPUP, RF, RF) -> UPUP
          ++ eval(p(x,y), f(x), g(x)) returns \spad{p(f(x), y * g(x))}.
    chvar : (UPUP,UPUP) -> Record(func:UPUP,poly:UPUP,c1:RF,c2:RF,deg:N)
          ++ chvar(f(x,y), p(x,y)) returns
          ++ \spad{[g(z,t), q(z,t), c1(z), c2(z), n]}
          ++ such that under the change of variable
          ++ \spad{x = c1(z)}, \spad{y = t * c2(z)},
          ++ one gets \spad{f(x,y) = g(z,t)}.
          ++ The algebraic relation between x and y is \spad{p(x, y) = 0}.
          ++ The algebraic relation between z and t is \spad{q(z, t) = 0}.

  Implementation ==> add
    import UnivariatePolynomialCommonDenominator(UP, RF, UPUP)

    algPoly     : UPUP           -> Record(coef:RF, poly:UPUP)
    RPrim       : (UP, UP, UPUP) -> Record(coef:RF, poly:UPUP)
    good?       : (F, UP, UP)    -> Boolean
    infIntegral?: (UPUP, UPUP)   -> Boolean

    eval(p, x, y)  == map(#1 x, p)  monomial(y, 1)
    good?(a, p, q) == p(a) ^= 0 and q(a) ^= 0

    algPoly p ==
      ground?(a:= retract(leadingCoefficient(q:=clearDenominator p))@UP)
        => RPrim(1, a, q)
      c := d := squareFreePart a
      q := clearDenominator q monomial(inv(d::RF), 1)
      while not ground?(a := retract(leadingCoefficient q)@UP) repeat
        c := c * (d := gcd(a, d))
        q := clearDenominator q monomial(inv(d::RF), 1)
      RPrim(c, a, q)

    RPrim(c, a, q) ==
--      one? a => [c::RF, q]
      (a = 1) => [c::RF, q]
      [(a * c)::RF, clearDenominator q monomial(inv(a::RF), 1)]

-- always makes the algebraic integral, but does not send a point to infinity
-- if the integrand does not have a pole there (in the case of an nth-root)
    chvar(f, modulus) ==
      r1 := mkIntegral modulus
      f1 := f monomial(r1inv := inv(r1.coef), 1)
      infIntegral?(f1, r1.poly) =>
        [f1, r1.poly, monomial(1,1)$UP :: RF,r1inv,degree(retract(r1.coef)@UP)]
      x  := (a:= goodPoint(f1,r1.poly))::UP::RF + inv(monomial(1,1)::RF)
      r2c:= retract((r2 := mkIntegral map(#1 x, r1.poly)).coef)@UP
      t  := inv((monomial(1, 1)$UP - a::UP)::RF)
      [- inv(monomial(1, 2)$UP :: RF) * eval(f1, x, inv(r2.coef)),
                                r2.poly, t, r1.coef * r2c t, degree r2c]

-- returns true if y is an n-th root, and it can be guaranteed that p(x,y)dx
-- is integral at infinity
-- expects y to be integral.
    infIntegral?(p, modulus) ==
      (r := radPoly modulus) case "failed" => false
      ninv := inv(r.deg::Q)
      degy:Q := degree(retract(r.radicand)@UP) * ninv
      degp:Q := 0
      while p ^= 0 repeat
        c := leadingCoefficient p
        degp := max(degp,
            (2 + degree(numer c)::Z - degree(denom c)::Z)::Q + degree(p) * degy)
        p := reductum p
      degp <= ninv

    mkIntegral p ==
      (r := radPoly p) case "failed" => algPoly p
      rp := rootPoly(r.radicand, r.deg)
      [rp.coef, monomial(1, rp.exponent)$UPUP - rp.radicand::RF::UPUP]

    goodPoint(p, modulus) ==
      q :=
        (r := radPoly modulus) case "failed" =>
                   retract(resultant(modulus, differentiate modulus))@UP
        retract(r.radicand)@UP
      d := commonDenominator p
      for i in 0.. repeat
        good?(a := i::F, q, d) => return a
        good?(-a, q, d)        => return -a

    radPoly p ==
      (r := retractIfCan(reductum p)@Union(RF, "failed")) case "failed"
        => "failed"
      [- (r::RF), degree p]

-- we have y**m = g(x) = n(x)/d(x), so if we can write
-- (n(x) * d(x)**(m-1)) ** (1/m)  =  c(x) * P(x) ** (1/n)
-- then z**q = P(x) where z = (d(x) / c(x)) * y
    rootPoly(g, m) ==
      zero? g => error "Should not happen"
      pr := nthRoot(squareFree((numer g) * (d := denom g) ** (m-1)::N),
                                                m)$FactoredFunctions(UP)
      [pr.exponent, d / pr.coef, */(pr.radicand)]

@
<<CHVAR.dotabb>>=
"CHVAR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CHVAR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CHVAR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CPIMA CharacteristicPolynomialInMonogenicalAlgebra}
\pagehead{CharacteristicPolynomialInMonogenicalAlgebra}{CPIMA}
\pagepic{ps/v104characteristicpolynomialinmonogenicalalgebra.ps}{CPIMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>=
)abbrev package CPIMA CharacteristicPolynomialInMonogenicalAlgebra
++ Author: Claude Quitte
++ Date Created: 10/12/93
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package implements characteristicPolynomials for monogenic algebras
++ using resultants
CharacteristicPolynomialInMonogenicalAlgebra(R : CommutativeRing,
    PolR : UnivariatePolynomialCategory(R),
    E : MonogenicAlgebra(R, PolR)): with
     characteristicPolynomial : E -> PolR
	++ characteristicPolynomial(e) returns the characteristic polynomial 
	++ of e using resultants

  == add
    Pol ==> SparseUnivariatePolynomial

    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, Pol(PolR))
    XtoY(Q : PolR) : Pol(PolR) == map(monomial(#1, 0), Q)

    P : Pol(PolR) := XtoY(definingPolynomial()$E)
    X : Pol(PolR) := monomial(monomial(1, 1)$PolR, 0)

    characteristicPolynomial(x : E) : PolR ==
       Qx : PolR := lift(x)
       -- on utilise le fait que resultant_Y (P(Y), X - Qx(Y))
       return resultant(P, X - XtoY(Qx))

@
<<CPIMA.dotabb>>=
"CPIMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CPIMA"]
"MONOGEN" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MONOGEN"]
"CPIMA" -> "MONOGEN"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CHARPOL CharacteristicPolynomialPackage}
\pagehead{CharacteristicPolynomialPackage}{CHARPOL}
\pagepic{ps/v104characteristicpolynomialpackage.ps}{CHARPOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CHARPOL CharacteristicPolynomialPackage>>=
)abbrev package CHARPOL CharacteristicPolynomialPackage
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides a characteristicPolynomial function
++ for any matrix over a commutative ring.

CharacteristicPolynomialPackage(R:CommutativeRing):C == T where
   PI ==> PositiveInteger
   M ==> Matrix R
   C == with
      characteristicPolynomial: (M, R) -> R
        ++ characteristicPolynomial(m,r) computes the characteristic
        ++ polynomial of the matrix m evaluated at the point r.
        ++ In particular, if r is the polynomial 'x, then it returns
        ++ the characteristic polynomial expressed as a polynomial in 'x.
   T == add

           ---- characteristic polynomial  ----
     characteristicPolynomial(A:M,v:R) : R ==
       dimA :PI := (nrows A):PI
       dimA ^= ncols A => error " The matrix is not square"
       B:M:=zero(dimA,dimA)
       for i in 1..dimA repeat
         for j in 1..dimA repeat  B(i,j):=A(i,j)
         B(i,i) := B(i,i) - v
       determinant B

@
<<CHARPOL.dotabb>>=
"CHARPOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CHARPOL"]
"BMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BMODULE"]
"CHARPOL" -> "BMODULE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CVMP CoerceVectorMatrixPackage}
\pagehead{CoerceVectorMatrixPackage}{CVMP}
\pagepic{ps/v104coercevectormatrixpackage.ps}{CVMP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CVMP CoerceVectorMatrixPackage>>=
)abbrev package CVMP CoerceVectorMatrixPackage
++ Authors: J. Grabmeier
++ Date Created: 26 June 1991
++ Date Last Updated: 26 June 1991
++ Basic Operations: coerceP, coerce
++ Related Constructors: GenericNonAssociativeAlgebra
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Reference:
++ Description:
++  CoerceVectorMatrixPackage: an unexposed, technical package
++  for data conversions
CoerceVectorMatrixPackage(R : CommutativeRing): public == private where
  M2P ==> MatrixCategoryFunctions2(R, Vector R, Vector R, Matrix R, _
    Polynomial R, Vector Polynomial R, Vector Polynomial R, Matrix Polynomial R)
  M2FP ==> MatrixCategoryFunctions2(R, Vector R, Vector R, Matrix R, _
    Fraction Polynomial R, Vector Fraction Polynomial R, _
    Vector Fraction Polynomial R, Matrix Fraction Polynomial R)
  public ==> with
    coerceP: Vector Matrix R -> Vector Matrix Polynomial R
      ++ coerceP(v) coerces a vector v with entries in \spadtype{Matrix R}
      ++ as vector over \spadtype{Matrix Polynomial R}
    coerce: Vector Matrix R -> Vector Matrix Fraction Polynomial R
      ++ coerce(v) coerces a vector v with entries in \spadtype{Matrix R}
      ++ as vector over \spadtype{Matrix Fraction Polynomial R}
  private ==> add

    imbedFP : R -> Fraction Polynomial R
    imbedFP r == (r:: Polynomial R) :: Fraction Polynomial R

    imbedP : R -> Polynomial R
    imbedP r == (r:: Polynomial R)

    coerceP(g:Vector Matrix R) : Vector Matrix Polynomial R ==
      m2 : Matrix Polynomial R
      lim : List Matrix R := entries g
      l: List Matrix Polynomial R :=  []
      for m in lim repeat
        m2 :=  map(imbedP,m)$M2P
        l := cons(m2,l)
      vector reverse l

    coerce(g:Vector Matrix R) : Vector Matrix Fraction Polynomial R ==
      m3 : Matrix Fraction Polynomial R
      lim : List Matrix R := entries g
      l: List Matrix Fraction Polynomial R :=  []
      for m in lim repeat
        m3 :=  map(imbedFP,m)$M2FP
        l := cons(m3,l)
      vector reverse l

@
<<CVMP.dotabb>>=
"CVMP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CVMP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CVMP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMBF CombinatorialFunction}
\pagehead{CombinatorialFunction}{COMBF}
\pagepic{ps/v104combinatorialfunction.ps}{COMBF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMBF CombinatorialFunction>>=
)abbrev package COMBF CombinatorialFunction
++ Provides the usual combinatorial functions
++ Author: Manuel Bronstein, Martin Rubey
++ Date Created: 2 Aug 1988
++ Date Last Updated: 30 October 2005
++ Description:
++   Provides combinatorial functions over an integral domain.
++ Keywords: combinatorial, function, factorial.
++ Examples:  )r COMBF INPUT

CombinatorialFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  OP  ==> BasicOperator
  K   ==> Kernel F
  SE  ==> Symbol
  O   ==> OutputForm
  SMP ==> SparseMultivariatePolynomial(R, K)
  Z   ==> Integer

  POWER        ==> "%power"::Symbol
  OPEXP        ==> "exp"::Symbol
  SPECIALDIFF  ==> "%specialDiff"
  SPECIALDISP  ==> "%specialDisp"
  SPECIALEQUAL ==> "%specialEqual"

  Exports ==> with
    belong?    : OP -> Boolean
      ++ belong?(op) is true if op is a combinatorial operator;
    operator   : OP -> OP
      ++ operator(op) returns a copy of op with the domain-dependent
      ++ properties appropriate for F;
      ++ error if op is not a combinatorial operator;
    "**"       : (F, F) -> F
      ++ a ** b is the formal exponential a**b;
    binomial   : (F, F) -> F
      ++ binomial(n, r) returns the number of subsets of r objects
      ++ taken among n objects, i.e. n!/(r! * (n-r)!);
@

We currently simplify binomial coefficients only for non-negative integral
second argument, using the formula
$$ \binom{n}{k}=\frac{1}{k!}\prod_{i=0..k-1} (n-i),$$
except if the second argument is symbolic: in this case [[binomial(n,n)]] is
simplified to one.
 
Note that there are at least two different ways to define binomial coefficients
for negative integral second argument. One way, particular suitable for
combinatorics, is to set the binomial coefficient equal to zero for negative
second argument. This is, partially, also the approach taken in
[[combinat.spad]], where we find

\begin{verbatim}
   binomial(n, m) ==
      n < 0 or m < 0 or m > n => 0
      m = 0 => 1
\end{verbatim}

Of course, here [[n]] and [[m]] are integers. This definition agrees with the
recurrence

$$\binom{n}{k}+\binom{n}{k+1}=\binom{n+1}{k+1}.$$

Alternatively, one can use the formula
$$ \binom{n}{k}=\frac{\Gamma(n+1)}{\Gamma(k+1)\Gamma(n-k+1)}, $$
and leave the case where $k\in {\bf Z}$, $n\in {\bf Z}$ and $k \leq n < 0$
undefined, since the limit does not exist in this case:

Since we then have that $n-k+1\geq 1$, $\Gamma(n-k+1)$ is finite. So it is
sufficient to consider $\frac{\Gamma(n+1)}{\Gamma(k+1)}$. On the one hand, we
have
$$\lim_{n_0\to n} \lim_{k_0\to k}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)} = 0,$$
since for any non-integral $n_0$, $\Gamma(n_0+1)$ is finite. On the other
hand,
$$\lim_{k_0\to k} \lim_{n_0\to n}\frac{\Gamma(n_0+1)}{\Gamma(k_0+1)}$$
does not exist, since for non-integral $k_0$, $\Gamma(k_0+1)$ is finite while
$\Gamma(n_0+1)$ is unbounded.

However, since for $k\in {\bf Z}$, $n\in {\bf Z}$ and $0 < k < n$ both
definitions agree, one could also combine them. This is what, for example,
Mathematica does. It seems that MuPAD sets [[binomial(n,n)=1]] for all
arguments [[n]], and returns [[binomial(-2, n)]] unevaluated. Provisos may help
here.

<<package COMBF CombinatorialFunction>>=
    permutation: (F, F) -> F
      ++ permutation(n, r) returns the number of permutations of
      ++ n objects taken r at a time, i.e. n!/(n-r)!;
    factorial  : F -> F
      ++ factorial(n) returns the factorial of n, i.e. n!;
    factorials : F -> F
      ++ factorials(f) rewrites the permutations and binomials in f
      ++ in terms of factorials;
    factorials : (F, SE) -> F
      ++ factorials(f, x) rewrites the permutations and binomials in f
      ++ involving x in terms of factorials;
    summation  : (F, SE) -> F
      ++ summation(f(n), n) returns the formal sum S(n) which verifies
      ++ S(n+1) - S(n) = f(n);
    summation  : (F, SegmentBinding F)  -> F
      ++ summation(f(n), n = a..b) returns f(a) + ... + f(b) as a
      ++ formal sum;
    product    : (F, SE) -> F
      ++ product(f(n), n) returns the formal product P(n) which verifies
      ++ P(n+1)/P(n) = f(n);
    product    : (F, SegmentBinding  F) -> F
      ++ product(f(n), n = a..b) returns f(a) * ... * f(b) as a
      ++ formal product;
    iifact     : F -> F
      ++ iifact(x) should be local but conditional;
    iibinom    : List F -> F
      ++ iibinom(l) should be local but conditional;
    iiperm     : List F -> F
      ++ iiperm(l) should be local but conditional;
    iipow      : List F -> F
      ++ iipow(l) should be local but conditional;
    iidsum     : List F -> F
      ++ iidsum(l) should be local but conditional;
    iidprod    : List F -> F
      ++ iidprod(l) should be local but conditional;
    ipow       : List F -> F
      ++ ipow(l) should be local but conditional;

  Implementation ==> add
    ifact     : F -> F
    iiipow    : List F -> F
    iperm     : List F -> F
    ibinom    : List F -> F
    isum      : List F -> F
    idsum     : List F -> F
    iprod     : List F -> F
    idprod    : List F -> F
    dsum      : List F -> O
    ddsum     : List F -> O
    dprod     : List F -> O
    ddprod    : List F -> O
    equalsumprod  : (K, K) -> Boolean 
    equaldsumprod : (K, K) -> Boolean 
    fourth    : List F -> F
    dvpow1    : List F -> F
    dvpow2    : List F -> F
    summand   : List F -> F
    dvsum     : (List F, SE) -> F
    dvdsum    : (List F, SE) -> F
    dvprod    : (List F, SE) -> F
    dvdprod   : (List F, SE) -> F
    facts     : (F, List SE) -> F
    K2fact    : (K, List SE) -> F
    smpfact   : (SMP, List SE) -> F

    dummy == new()$SE :: F
@
This macro will be used in [[product]] and [[summation]], both the $5$ and $3$
argument forms. It is used to introduce a dummy variable in place of the
summation index within the summands. This in turn is necessary to keep the
indexing variable local, circumventing problems, for example, with
differentiation.

This works if we don't accidently use such a symbol as a bound of summation or
product.

Note that up to [[patch--25]] this used to read
\begin{verbatim}
    dummy := new()$SE :: F
\end{verbatim}
thus introducing the same dummy variable for all products and summations, which
caused nested products and summations to fail. (Issue~\#72)

<<package COMBF CombinatorialFunction>>=
    opfact  := operator("factorial"::Symbol)$CommonOperators
    opperm  := operator("permutation"::Symbol)$CommonOperators
    opbinom := operator("binomial"::Symbol)$CommonOperators
    opsum   := operator("summation"::Symbol)$CommonOperators
    opdsum  := operator("%defsum"::Symbol)$CommonOperators
    opprod  := operator("product"::Symbol)$CommonOperators
    opdprod := operator("%defprod"::Symbol)$CommonOperators
    oppow   := operator(POWER::Symbol)$CommonOperators

    factorial x          == opfact x
    binomial(x, y)       == opbinom [x, y]
    permutation(x, y)    == opperm [x, y]

    import F
    import Kernel F

    number?(x:F):Boolean ==
      if R has RetractableTo(Z) then
        ground?(x) or
         ((retractIfCan(x)@Union(Fraction(Z),"failed")) case Fraction(Z))
      else
        ground?(x)

    x ** y               == 
      -- Do some basic simplifications
      is?(x,POWER) =>
        args : List F := argument first kernels x
        not(#args = 2) => error "Too many arguments to **"
        number?(first args) and number?(y) =>
          oppow [first(args)**y, second args]
        oppow [first args, (second args)* y]
      -- Generic case
      exp : Union(Record(val:F,exponent:Z),"failed") := isPower x
      exp case Record(val:F,exponent:Z) =>
        expr := exp::Record(val:F,exponent:Z)
        oppow [expr.val, (expr.exponent)*y]
      oppow [x, y]

    belong? op           == has?(op, "comb")
    fourth l             == third rest l
    dvpow1 l             == second(l) * first(l) ** (second l - 1)
    factorials x         == facts(x, variables x)
    factorials(x, v)     == facts(x, [v])
    facts(x, l)          == smpfact(numer x, l) / smpfact(denom x, l)
    summand l            == eval(first l, retract(second l)@K, third l)

    product(x:F, i:SE) ==
      dm := dummy
      opprod [eval(x, k := kernel(i)$K, dm), dm, k::F]

    summation(x:F, i:SE) ==
      dm := dummy
      opsum [eval(x, k := kernel(i)$K, dm), dm, k::F]

@
These two operations return the product or the sum as unevaluated operators. A
dummy variable is introduced to make the indexing variable \lq local\rq.

<<package COMBF CombinatorialFunction>>=
    dvsum(l, x) ==
      opsum [differentiate(first l, x), second l, third l]

    dvdsum(l, x) ==
      x = retract(y := third l)@SE => 0
      if member?(x, variables(h := third rest rest l)) or 
         member?(x, variables(g := third rest l)) then
        error "a sum cannot be differentiated with respect to a bound"
      else
        opdsum [differentiate(first l, x), second l, y, g, h]

@
The above two operations implement differentiation of sums with and without
bounds. Note that the function
$$n\mapsto\sum_{k=1}^n f(k,n)$$
is well defined only for integral values of $n$ greater than or equal to zero.
There is not even consensus how to define this function for $n<0$. Thus, it is
not differentiable. Therefore, we need to check whether we erroneously are
differentiating with respect to the upper bound or the lower bound, where the
same reasoning holds.

Differentiating a sum with respect to its indexing variable correctly gives
zero. This is due to the introduction of dummy variables in the internal
representation of a sum: the operator [[%defsum]] takes 5 arguments, namely

\begin{enumerate}
\item the summands, where each occurrence of the indexing variable is replaced
  by 
\item the dummy variable,
\item the indexing variable,
\item the lower bound, and
\item the upper bound.
\end{enumerate}

Note that up to [[patch--40]] the following incorrect code was used, which 
tried to parallel the known rules for integration: (Issue~\#180)

\begin{verbatim}
    dvdsum(l, x) ==
      x = retract(y := third l)@SE => 0
      k := retract(d := second l)@K
      differentiate(h := third rest rest l,x) * eval(f := first l, k, h)
        - differentiate(g := third rest l, x) * eval(f, k, g)
             + opdsum [differentiate(f, x), d, y, g, h]
\end{verbatim}

Up to [[patch--45]] a similar mistake could be found in the code for
differentiation of formal sums, which read
\begin{verbatim}
    dvsum(l, x) ==
      k  := retract(second l)@K
      differentiate(third l, x) * summand l
          + opsum [differentiate(first l, x), second l, third l]
\end{verbatim}

<<package COMBF CombinatorialFunction>>=
    dvprod(l, x) ==
      dm := retract(dummy)@SE
      f := eval(first l, retract(second l)@K, dm::F)
      p := product(f, dm)

      opsum [differentiate(first l, x)/first l * p, second l, third l]


    dvdprod(l, x) ==
      x = retract(y := third l)@SE => 0
      if member?(x, variables(h := third rest rest l)) or 
         member?(x, variables(g := third rest l)) then
        error "a product cannot be differentiated with respect to a bound"
      else
        opdsum cons(differentiate(first l, x)/first l, rest l) * opdprod l 

@ 
The above two operations implement differentiation of products with and without
bounds. Note again, that we cannot even properly define products with bounds
that are not integral.

To differentiate the product, we use Leibniz rule:
$$\frac{d}{dx}\prod_{i=a}^b f(i,x) = 
  \sum_{i=a}^b \frac{\frac{d}{dx} f(i,x)}{f(i,x)}\prod_{i=a}^b f(i,x)
$$

There is one situation where this definition might produce wrong results,
namely when the product is zero, but axiom failed to recognize it: in this
case,
$$
  \frac{d}{dx} f(i,x)/f(i,x)  
$$
is undefined for some $i$. However, I was not able to come up with an
example. The alternative definition
$$
  \frac{d}{dx}\prod_{i=a}^b f(i,x) = 
  \sum_{i=a}^b \left(\frac{d}{dx} f(i,x)\right)\prod_{j=a,j\neq i}^b f(j,x)
$$
has the slight (display) problem that we would have to come up with a new index
variable, which looks very ugly. Furthermore, it seems to me that more
simplifications will occur with the first definition.

<<TEST COMBF>>=
  f := operator 'f
  D(product(f(i,x),i=1..m),x)
@

Note that up to [[patch--45]] these functions did not exist and products were
differentiated according to the usual chain rule, which gave incorrect
results. (Issue~\#211)

<<package COMBF CombinatorialFunction>>=
    dprod l ==
      prod(summand(l)::O, third(l)::O)

    ddprod l ==
      prod(summand(l)::O, third(l)::O = fourth(l)::O, fourth(rest l)::O)

    dsum l ==
      sum(summand(l)::O, third(l)::O)

    ddsum l ==
      sum(summand(l)::O, third(l)::O = fourth(l)::O, fourth(rest l)::O)

@ 
These four operations handle the conversion of sums and products to
[[OutputForm]]. Note that up to [[patch--45]] the definitions for sums and
products without bounds were missing and output was illegible.

<<package COMBF CombinatorialFunction>>=
    equalsumprod(s1, s2) ==
      l1 := argument s1
      l2 := argument s2

      (eval(first l1, retract(second l1)@K, second l2) = first l2)

    equaldsumprod(s1, s2) ==
      l1 := argument s1
      l2 := argument s2

      ((third rest l1 = third rest l2) and
       (third rest rest l1 = third rest rest l2) and
       (eval(first l1, retract(second l1)@K, second l2) = first l2))

@ 
The preceding two operations handle the testing for equality of sums and
products. This functionality was missing up to [[patch--45]]. (Issue~\#213) The
corresponding property [[%specialEqual]] set below is checked in
[[Kernel]]. Note that we can assume that the operators are equal, since this is
checked in [[Kernel]] itself.
<<package COMBF CombinatorialFunction>>=
    product(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)$K
      dm := dummy
      opdprod [eval(x,k,dm), dm, k::F, lo segment s, hi segment s]

    summation(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)$K
      dm := dummy
      opdsum [eval(x,k,dm), dm, k::F, lo segment s, hi segment s]

@
These two operations return the product or the sum as unevaluated operators. A
dummy variable is introduced to make the indexing variable \lq local\rq.

<<package COMBF CombinatorialFunction>>=
    smpfact(p, l) ==
      map(K2fact(#1, l), #1::F, p)$PolynomialCategoryLifting(
        IndexedExponents K, K, R, SMP, F)

    K2fact(k, l) ==
      empty? [v for v in variables(kf := k::F) | member?(v, l)] => kf
      empty?(args:List F := [facts(a, l) for a in argument k]) => kf
      is?(k, opperm) =>
        factorial(n := first args) / factorial(n - second args)
      is?(k, opbinom) =>
        n := first args
        p := second args
        factorial(n) / (factorial(p) * factorial(n-p))
      (operator k) args

    operator op ==
      is?(op, "factorial"::Symbol)   => opfact
      is?(op, "permutation"::Symbol) => opperm
      is?(op, "binomial"::Symbol)    => opbinom
      is?(op, "summation"::Symbol)   => opsum
      is?(op, "%defsum"::Symbol)     => opdsum
      is?(op, "product"::Symbol)     => opprod
      is?(op, "%defprod"::Symbol)    => opdprod
      is?(op, POWER)                 => oppow
      error "Not a combinatorial operator"

    iprod l ==
      zero? first l => 0
--      one? first l => 1
      (first l = 1) => 1
      kernel(opprod, l)

    isum l ==
      zero? first l => 0
      kernel(opsum, l)

    idprod l ==
      member?(retract(second l)@SE, variables first l) =>
        kernel(opdprod, l)
      first(l) ** (fourth rest l - fourth l + 1)

    idsum l ==
      member?(retract(second l)@SE, variables first l) =>
        kernel(opdsum, l)
      first(l) * (fourth rest l - fourth l + 1)

    ifact x ==
--      zero? x or one? x => 1
      zero? x or (x = 1) => 1
      kernel(opfact, x)

    ibinom l ==
      n := first l
      ((p := second l) = 0) or (p = n) => 1
--      one? p or (p = n - 1) => n
      (p = 1) or (p = n - 1) => n
      kernel(opbinom, l)

    iperm l ==
      zero? second l => 1
      kernel(opperm, l)

    if R has RetractableTo Z then
      iidsum l ==
        (r1:=retractIfCan(fourth l)@Union(Z,"failed"))
         case "failed" or
          (r2:=retractIfCan(fourth rest l)@Union(Z,"failed"))
            case "failed" or
             (k:=retractIfCan(second l)@Union(K,"failed")) case "failed"
               => idsum l
        +/[eval(first l,k::K,i::F) for i in r1::Z .. r2::Z]

      iidprod l ==
        (r1:=retractIfCan(fourth l)@Union(Z,"failed"))
         case "failed" or
          (r2:=retractIfCan(fourth rest l)@Union(Z,"failed"))
            case "failed" or
             (k:=retractIfCan(second l)@Union(K,"failed")) case "failed"
               => idprod l
        */[eval(first l,k::K,i::F) for i in r1::Z .. r2::Z]

      iiipow l ==
          (u := isExpt(x := first l, OPEXP)) case "failed" => kernel(oppow, l)
          rec := u::Record(var: K, exponent: Z)
          y := first argument(rec.var)
          (r := retractIfCan(y)@Union(Fraction Z, "failed")) case
              "failed" => kernel(oppow, l)
          (operator(rec.var)) (rec.exponent * y * second l)

      if F has RadicalCategory then
        ipow l ==
          (r := retractIfCan(second l)@Union(Fraction Z,"failed"))
            case "failed" => iiipow l
          first(l) ** (r::Fraction(Z))
      else
        ipow l ==
          (r := retractIfCan(second l)@Union(Z, "failed"))
            case "failed" => iiipow l
          first(l) ** (r::Z)

    else
      ipow l ==
        zero?(x := first l) =>
          zero? second l => error "0 ** 0"
          0
--        one? x or zero?(n := second l) => 1
        (x = 1) or zero?(n: F := second l) => 1
--        one? n => x
        (n = 1) => x
        (u := isExpt(x, OPEXP)) case "failed" => kernel(oppow, l)
        rec := u::Record(var: K, exponent: Z)
--        one?(y := first argument(rec.var)) or y = -1 =>
        ((y := first argument(rec.var))=1) or y = -1 =>
            (operator(rec.var)) (rec.exponent * y * n)
        kernel(oppow, l)

    if R has CombinatorialFunctionCategory then
      iifact x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => ifact x
        factorial(r::R)::F

      iiperm l ==
        (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
          (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
            => iperm l
        permutation(r1::R, r2::R)::F

      if R has RetractableTo(Z) and F has Algebra(Fraction(Z)) then
         iibinom l ==
           (s:=retractIfCan(second l)@Union(R,"failed")) case R and
              (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
                ans:=1::F
                for i in 0..t-1 repeat
                    ans:=ans*(first l - i::R::F)
                (1/factorial t) * ans
           (s:=retractIfCan(first l-second l)@Union(R,"failed")) case R and
             (t:=retractIfCan(s)@Union(Z,"failed")) case Z and t>0 =>
                ans:=1::F
                for i in 1..t repeat
                    ans:=ans*(second l+i::R::F)
                (1/factorial t) * ans
           (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
             (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
               => ibinom l
           binomial(r1::R, r2::R)::F

@

[[iibinom]] checks those cases in which the binomial coefficient may be
evaluated explicitly. Note that up to [[patch--51]], the case where the second
argument is a positive integer was not checked.(Issue~\#336) Currently, the
naive iterative algorithm is used to calculate the coefficient, there is room
for improvement here.

<<package COMBF CombinatorialFunction>>=

      else
         iibinom l ==
           (r1 := retractIfCan(first l)@Union(R,"failed")) case "failed" or
             (r2 := retractIfCan(second l)@Union(R,"failed")) case "failed"
               => ibinom l
           binomial(r1::R, r2::R)::F

    else
      iifact x  == ifact x
      iibinom l == ibinom l
      iiperm l  == iperm l

    if R has ElementaryFunctionCategory then
      iipow l ==
        (r1:=retractIfCan(first l)@Union(R,"failed")) case "failed" or
          (r2:=retractIfCan(second l)@Union(R,"failed")) case "failed"
            => ipow l
        (r1::R ** r2::R)::F
    else
      iipow l == ipow l

    if F has ElementaryFunctionCategory then
      dvpow2 l == if zero?(first l) then
                    0
                  else
                    log(first l) * first(l) ** second(l)

@
This operation implements the differentiation of the power operator [[%power]]
with respect to its second argument, i.e., the exponent. It uses the formula
$$\frac{d}{dx} g(y)^x = \frac{d}{dx} e^{x\log g(y)} = \log g(y) g(y)^x.$$

If $g(y)$ equals zero, this formula is not valid, since the logarithm is not
defined there. Although strictly speaking $0^x$ is not differentiable at zero,
we return zero for convenience. 

Note that up to [[patch--25]] this used to read
\begin{verbatim}
    if F has ElementaryFunctionCategory then
      dvpow2 l == log(first l) * first(l) ** second(l)
\end{verbatim}
which caused differentiating $0^x$ to fail. (Issue~\#19)

<<package COMBF CombinatorialFunction>>=
    evaluate(opfact, iifact)$BasicOperatorFunctions1(F)
    evaluate(oppow, iipow)
    evaluate(opperm, iiperm)
    evaluate(opbinom, iibinom)
    evaluate(opsum, isum)
    evaluate(opdsum, iidsum)
    evaluate(opprod, iprod)
    evaluate(opdprod, iidprod)
    derivative(oppow, [dvpow1, dvpow2])
    setProperty(opsum,   SPECIALDIFF, dvsum@((List F, SE) -> F) pretend None)
    setProperty(opdsum,  SPECIALDIFF, dvdsum@((List F, SE)->F) pretend None)
    setProperty(opprod,  SPECIALDIFF, dvprod@((List F, SE)->F) pretend None)
    setProperty(opdprod, SPECIALDIFF, dvdprod@((List F, SE)->F) pretend None)
@
The last four properties define special differentiation rules for sums and
products. Note that up to [[patch--45]] the rules for products were missing.
Thus products were differentiated according the usual chain-rule, which gave
incorrect results.

<<package COMBF CombinatorialFunction>>=
    setProperty(opsum,   SPECIALDISP, dsum@(List F -> O) pretend None)
    setProperty(opdsum,  SPECIALDISP, ddsum@(List F -> O) pretend None)
    setProperty(opprod,  SPECIALDISP, dprod@(List F -> O) pretend None)
    setProperty(opdprod, SPECIALDISP, ddprod@(List F -> O) pretend None)
    setProperty(opsum,   SPECIALEQUAL, equalsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opdsum,  SPECIALEQUAL, equaldsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opprod,  SPECIALEQUAL, equalsumprod@((K,K) -> Boolean) pretend None)
    setProperty(opdprod, SPECIALEQUAL, equaldsumprod@((K,K) -> Boolean) pretend None)

@ 
Finally, we set the properties for displaying sums and products and testing for
equality.


<<COMBF.dotabb>>=
"COMBF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMBF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMBF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CDEN CommonDenominator}
\pagehead{CommonDenominator}{CDEN}
\pagepic{ps/v104commondenominator.ps}{CDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CDEN CommonDenominator>>=
)abbrev package CDEN CommonDenominator
--% CommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Nov 1989
++ Description: CommonDenominator provides functions to compute the
++ common denominator of a finite linear aggregate of elements of
++ the quotient field of an integral domain.
++ Keywords: gcd, quotient, common, denominator.
CommonDenominator(R, Q, A): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
  A: FiniteLinearAggregate Q
 
  Exports ==> with
    commonDenominator: A -> R
      ++ commonDenominator([q1,...,qn]) returns a common denominator
      ++ d for q1,...,qn.
    clearDenominator : A -> A
      ++ clearDenominator([q1,...,qn]) returns \spad{[p1,...,pn]} such that
      ++ \spad{qi = pi/d} where d is a common denominator for the qi's.
    splitDenominator : A -> Record(num: A, den: R)
      ++ splitDenominator([q1,...,qn]) returns
      ++ \spad{[[p1,...,pn], d]} such that
      ++ \spad{qi = pi/d} and d is a common denominator for the qi's.
 
  Implementation ==> add
    clearDenominator l ==
      d := commonDenominator l
      map(numer(d * #1)::Q, l)
 
    splitDenominator l ==
      d := commonDenominator l
      [map(numer(d * #1)::Q, l), d]
 
    if R has GcdDomain then
      qlcm: (Q, Q) -> Q
 
      qlcm(a, b)          == lcm(numer a, numer b)::Q
      commonDenominator l == numer reduce(qlcm, map(denom(#1)::Q, l), 1)
    else
      commonDenominator l == numer reduce("*", map(denom(#1)::Q, l), 1)

@
<<CDEN.dotabb>>=
"CDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMMONOP CommonOperators}
\pagehead{CommonOperators}{COMMONOP}
\pagepic{ps/v104commonoperators.ps}{COMMONOP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMMONOP CommonOperators>>=
)abbrev package COMMONOP CommonOperators
++ Provides commonly used operators
++ Author: Manuel Bronstein
++ Date Created: 25 Mar 1988
++ Date Last Updated: 2 December 1994
++ Description:
++ This package exports the elementary operators, with some semantics
++ already attached to them. The semantics that is attached here is not
++ dependent on the set in which the operators will be applied.
++ Keywords: operator.
CommonOperators(): Exports == Implementation where
  OP  ==> BasicOperator
  O   ==> OutputForm
  POWER ==> "%power"::Symbol
  ALGOP ==> "%alg"
  EVEN  ==> "even"
  ODD   ==> "odd"
  DUMMYVAR ==> "%dummyVar"

  Exports ==> with
    operator: Symbol -> OP
        ++ operator(s) returns an operator with name s, with the
        ++ appropriate semantics if s is known. If s is not known,
        ++ the result has no semantics.

  Implementation ==> add
    dpi        : List O -> O
    dgamma     : List O -> O
    dquote     : List O -> O
    dexp       : O -> O
    dfact      : O -> O
    startUp    : Boolean -> Void
    setDummyVar: (OP, NonNegativeInteger) -> OP

    brandNew?:Reference(Boolean) := ref true

    opalg   := operator("rootOf"::Symbol, 2)$OP
    oproot  := operator("nthRoot"::Symbol, 2)
    oppi    := operator("pi"::Symbol, 0)
    oplog   := operator("log"::Symbol, 1)
    opexp   := operator("exp"::Symbol, 1)
    opabs   := operator("abs"::Symbol, 1)
    opsin   := operator("sin"::Symbol, 1)
    opcos   := operator("cos"::Symbol, 1)
    optan   := operator("tan"::Symbol, 1)
    opcot   := operator("cot"::Symbol, 1)
    opsec   := operator("sec"::Symbol, 1)
    opcsc   := operator("csc"::Symbol, 1)
    opasin  := operator("asin"::Symbol, 1)
    opacos  := operator("acos"::Symbol, 1)
    opatan  := operator("atan"::Symbol, 1)
    opacot  := operator("acot"::Symbol, 1)
    opasec  := operator("asec"::Symbol, 1)
    opacsc  := operator("acsc"::Symbol, 1)
    opsinh  := operator("sinh"::Symbol, 1)
    opcosh  := operator("cosh"::Symbol, 1)
    optanh  := operator("tanh"::Symbol, 1)
    opcoth  := operator("coth"::Symbol, 1)
    opsech  := operator("sech"::Symbol, 1)
    opcsch  := operator("csch"::Symbol, 1)
    opasinh := operator("asinh"::Symbol, 1)
    opacosh := operator("acosh"::Symbol, 1)
    opatanh := operator("atanh"::Symbol, 1)
    opacoth := operator("acoth"::Symbol, 1)
    opasech := operator("asech"::Symbol, 1)
    opacsch := operator("acsch"::Symbol, 1)
    opbox   := operator("%box"::Symbol)$OP
    oppren  := operator("%paren"::Symbol)$OP
    opquote := operator("applyQuote"::Symbol)$OP
    opdiff  := operator("%diff"::Symbol, 3)
    opsi    := operator("Si"::Symbol, 1)
    opci    := operator("Ci"::Symbol, 1)
    opei    := operator("Ei"::Symbol, 1)
    opli    := operator("li"::Symbol, 1)
    operf   := operator("erf"::Symbol, 1)
    opli2   := operator("dilog"::Symbol, 1)
    opGamma     := operator("Gamma"::Symbol, 1)
    opGamma2    := operator("Gamma2"::Symbol, 2)
    opBeta      := operator("Beta"::Symbol, 2)
    opdigamma   := operator("digamma"::Symbol, 1)
    oppolygamma := operator("polygamma"::Symbol, 2)
    opBesselJ   := operator("besselJ"::Symbol, 2)
    opBesselY   := operator("besselY"::Symbol, 2)
    opBesselI   := operator("besselI"::Symbol, 2)
    opBesselK   := operator("besselK"::Symbol, 2)
    opAiryAi    := operator("airyAi"::Symbol,  1)
    opAiryBi    := operator("airyBi"::Symbol , 1)
    opint   := operator("integral"::Symbol, 3)
    opdint  := operator("%defint"::Symbol, 5)
    opfact  := operator("factorial"::Symbol, 1)
    opperm  := operator("permutation"::Symbol, 2)
    opbinom := operator("binomial"::Symbol, 2)
    oppow   := operator(POWER, 2)
    opsum   := operator("summation"::Symbol, 3)
    opdsum  := operator("%defsum"::Symbol, 5)
    opprod  := operator("product"::Symbol, 3)
    opdprod := operator("%defprod"::Symbol, 5)

    algop   := [oproot, opalg]$List(OP)
    rtrigop := [opsin, opcos, optan, opcot, opsec, opcsc,
                         opasin, opacos, opatan, opacot, opasec, opacsc]
    htrigop := [opsinh, opcosh, optanh, opcoth, opsech, opcsch,
                   opasinh, opacosh, opatanh, opacoth, opasech, opacsch]
    trigop  := concat(rtrigop, htrigop)
    elemop  := concat(trigop, [oppi, oplog, opexp])
    primop  := [opei, opli, opsi, opci, operf, opli2, opint, opdint]
    combop  := [opfact, opperm, opbinom, oppow,
                                         opsum, opdsum, opprod, opdprod]
    specop  := [opGamma, opGamma2, opBeta, opdigamma, oppolygamma, opabs,
                opBesselJ, opBesselY, opBesselI, opBesselK, opAiryAi,
                 opAiryBi]
    anyop   := [oppren, opdiff, opbox, opquote]
    allop   := concat(concat(concat(concat(concat(
                            algop,elemop),primop),combop),specop),anyop)

-- odd and even operators, must be maintained current!
    evenop := [opcos, opsec, opcosh, opsech, opabs]
    oddop  := [opsin, opcsc, optan, opcot, opasin, opacsc, opatan,
               opsinh, opcsch, optanh, opcoth, opasinh, opacsch,opatanh,opacoth,
                opsi, operf]

-- operators whose second argument is a dummy variable
    dummyvarop1 := [opdiff,opalg, opint, opsum, opprod]
-- operators whose second and third arguments are dummy variables
    dummyvarop2 := [opdint, opdsum, opdprod]

    operator s ==
      if (deref brandNew?) then startUp false
      for op in allop repeat
        is?(op, s) => return copy op
      operator(s)$OP

    dpi l    == "%pi"::Symbol::O
    dfact x  == postfix("!"::Symbol::O, (ATOM(x)$Lisp => x; paren x))
    dquote l == prefix(quote(first(l)::O), rest l)
    dgamma l == prefix(hconcat("|"::Symbol::O, overbar(" "::Symbol::O)), l)
    setDummyVar(op, n) == setProperty(op, DUMMYVAR, n pretend None)

    dexp x ==
      e := "%e"::Symbol::O
      x = 1::O => e
      e ** x

    startUp b ==
      brandNew?() := b
      display(oppren, paren)
      display(opbox, commaSeparate)
      display(oppi, dpi)
      display(opexp, dexp)
      display(opGamma, dgamma)
      display(opGamma2, dgamma)
      display(opfact, dfact)
      display(opquote, dquote)
      display(opperm, supersub("A"::Symbol::O, #1))
      display(opbinom, binomial(first #1, second #1))
      display(oppow, first(#1) ** second(#1))
      display(opsum,   sum(first #1, second #1, third #1))
      display(opprod, prod(first #1, second #1, third #1))
      display(opint, int(first #1 * hconcat("d"::Symbol::O, second #1),
                                                   empty(), third #1))
      input(oppren, convert concat(convert("("::Symbol)@InputForm,
                            concat(#1, convert(")"::Symbol)@InputForm)))
      input(oppow, convert concat(convert("**"::Symbol)@InputForm, #1))
      input(oproot,
            convert [convert("**"::Symbol)@InputForm, first #1, 1 / second #1])
      for op in algop   repeat assert(op, ALGOP)
      for op in rtrigop repeat assert(op, "rtrig")
      for op in htrigop repeat assert(op, "htrig")
      for op in trigop  repeat assert(op, "trig")
      for op in elemop  repeat assert(op, "elem")
      for op in primop  repeat assert(op, "prim")
      for op in combop  repeat assert(op, "comb")
      for op in specop  repeat assert(op, "special")
      for op in anyop   repeat assert(op, "any")
      for op in evenop  repeat assert(op, EVEN)
      for op in oddop   repeat assert(op, ODD)
      for op in dummyvarop1 repeat setDummyVar(op, 1)
      for op in dummyvarop2 repeat setDummyVar(op, 2)
      assert(oppren, "linear")
      void

@
<<COMMONOP.dotabb>>=
"COMMONOP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMMONOP"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"COMMONOP" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMPFACT ComplexFactorization}
\pagehead{ComplexFactorization}{COMPFACT}
\pagepic{ps/v104complexfactorization.ps}{COMPFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMPFACT ComplexFactorization>>=
)abbrev package COMPFACT ComplexFactorization
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: Complex, UnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords: complex, polynomial factorization, factor
++ References:
ComplexFactorization(RR,PR) : C == T where
  RR   :    EuclideanDomain   -- R is Z or Q
  PR   :    UnivariatePolynomialCategory Complex RR
  R    ==>  Complex RR
  I    ==>  Integer
  RN   ==>  Fraction I
  GI   ==>  Complex I
  GRN  ==>  Complex RN


  C  == with

     factor        :   PR   ->  Factored PR
       ++ factor(p) factorizes the polynomial p with complex coefficients.

  T  == add
     SUP    ==> SparseUnivariatePolynomial
     fUnion ==> Union("nil", "sqfr", "irred", "prime")
     FF     ==> Record(flg:fUnion, fctr:PR, xpnt:Integer)
     SAEF   :=  SimpleAlgebraicExtensionAlgFactor(SUP RN,GRN,SUP GRN)
     UPCF2  :=  UnivariatePolynomialCategoryFunctions2(R,PR,GRN,SUP GRN)
     UPCFB  :=  UnivariatePolynomialCategoryFunctions2(GRN,SUP GRN,R,PR)

     myMap(r:R) : GRN ==
       R is GI   =>
         cr :GI := r pretend GI
         complex((real cr)::RN,(imag cr)::RN)
       R is GRN  => r pretend GRN

     compND(cc:GRN):Record(cnum:GI,cden:Integer) ==
       ccr:=real cc
       cci:=imag cc
       dccr:=denom ccr
       dcci:=denom cci
       ccd:=lcm(dccr,dcci)
       [complex(((ccd exquo dccr)::Integer)*numer ccr,
                ((ccd exquo dcci)::Integer)*numer cci),ccd]

     conv(f:SUP GRN) :Record(convP:SUP GI, convD:RN) ==
       pris:SUP GI :=0
       dris:Integer:=1
       dris1:Integer:=1
       pdris:Integer:=1
       for i in 0..(degree f) repeat
         (cf:= coefficient(f,i)) = 0 => "next i"
         cdf:=compND cf
         dris:=lcm(cdf.cden,dris1)
         pris:=((dris exquo dris1)::Integer)*pris +
               ((dris exquo cdf.cden)::Integer)*
                 monomial(cdf.cnum,i)$(SUP GI)
         dris1:=dris
       [pris,dris::RN]

     backConv(ffr:Factored SUP GRN) : Factored PR ==
       R is GRN =>
         makeFR((unit ffr) pretend PR,[[f.flg,(f.fctr) pretend PR,f.xpnt]
                                        for f in factorList ffr])
       R is GI  =>
         const:=unit ffr
         ris: List FF :=[]
         for ff in factorList ffr repeat
           fact:=primitivePart(conv(ff.fctr).convP)
           expf:=ff.xpnt
           ris:=cons([ff.flg,fact pretend PR,expf],ris)
           lc:GRN := myMap leadingCoefficient(fact pretend PR)
           const:= const*(leadingCoefficient(ff.fctr)/lc)**expf
         uconst:GI:= compND(coefficient(const,0)).cnum
         makeFR((uconst pretend R)::PR,ris)


     factor(pol : PR)  : Factored PR ==
       ratPol:SUP GRN := 0
       ratPol:=map(myMap,pol)$UPCF2
       ffr:=factor ratPol
       backConv ffr

@
<<COMPFACT.dotabb>>=
"COMPFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMPFACT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"COMPFACT" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMPLEX2 ComplexFunctions2}
\pagehead{ComplexFunctions2}{COMPLEX2}
\pagepic{ps/v104complexfunctions2.ps}{COMPLEX2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMPLEX2 ComplexFunctions2>>=
)abbrev package COMPLEX2 ComplexFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package extends maps from underlying rings to maps between
++   complex over those rings.
ComplexFunctions2(R:CommutativeRing, S:CommutativeRing): with
    map:     (R -> S, Complex R) -> Complex S
      ++ map(f,u) maps f onto real and imaginary parts of u.
 == add
    map(fn, gr) == complex(fn real gr, fn imag gr)

@
<<COMPLEX2.dotabb>>=
"COMPLEX2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMPLEX2"]
"BMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BMODULE"]
"COMPLEX2" -> "BMODULE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation}
\pagehead{ComplexIntegerSolveLinearPolynomialEquation}{CINTSLPE}
\pagepic{ps/v104complexintegersolvelinearpolynomialequation.ps}{CINTSLPE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation>>=
)abbrev package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation
++ Author: James Davenport
++ Date Created: 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides the generalized euclidean algorithm which is
++ needed as the basic step for factoring polynomials.
ComplexIntegerSolveLinearPolynomialEquation(R,CR): C == T
 where
  CP ==> SparseUnivariatePolynomial CR
  R:IntegerNumberSystem
  CR:ComplexCategory(R)
  C == with
      solveLinearPolynomialEquation: (List CP,CP) -> Union(List CP,"failed")
                   ++ solveLinearPolynomialEquation([f1, ..., fn], g)
                   ++ where (fi relatively prime to each other)
                   ++ returns a list of ai such that
                   ++ g = sum ai prod fj (j \= i) or
                   ++ equivalently g/prod fj = sum (ai/fi)
                   ++ or returns "failed" if no such list exists
  T == add
      oldlp:List CP := []
      slpePrime:R:=(2::R)
      oldtable:Vector List CP := empty()
      solveLinearPolynomialEquation(lp,p) ==
         if (oldlp ^= lp) then
            -- we have to generate a new table
            deg:= _+/[degree u for u in lp]
            ans:Union(Vector List CP,"failed"):="failed"
            slpePrime:=67108859::R   -- 2**26 -5 : a prime
                 -- a good test case for this package is
                 --  (good question?)
            while (ans case "failed") repeat
              ans:=tablePow(deg,complex(slpePrime,0),lp)$GenExEuclid(CR,CP)
              if (ans case "failed") then
                 slpePrime:=  slpePrime-4::R
                 while not prime?(slpePrime)$IntegerPrimesPackage(R) repeat
                   slpePrime:= slpePrime-4::R
            oldtable:=(ans:: Vector List CP)
         answer:=solveid(p,complex(slpePrime,0),oldtable)
         answer

@
<<CINTSLPE.dotabb>>=
"CINTSLPE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CINTSLPE"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CINTSLPE" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMPLPAT ComplexPattern}
\pagehead{ComplexPattern}{COMPLPAT}
\pagepic{ps/v104complexpattern.ps}{COMPLPAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMPLPAT ComplexPattern>>=
)abbrev package COMPLPAT ComplexPattern
++ Author: Barry Trager
++ Date Created: 30 Nov 1995
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex, patterns
++ References:
++ Description:
++ This package supports converting complex expressions to patterns
ComplexPattern(R, S, CS) : C == T where
    R: SetCategory
    S: Join(ConvertibleTo Pattern R, CommutativeRing)
    CS: ComplexCategory S
    C == with
       convert: CS -> Pattern R
	  ++ convert(cs) converts the complex expression cs to a pattern

    T == add

       ipat : Pattern R := patternVariable("%i"::Symbol, true, false, false)

       convert(cs) ==
          zero? imag cs => convert real cs
          convert real cs + ipat * convert imag cs

@
<<COMPLPAT.dotabb>>=
"COMPLPAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMPLPAT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"COMPLPAT" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CPMATCH ComplexPatternMatch}
\pagehead{ComplexPatternMatch}{CPMATCH}
\pagepic{ps/v104complexpatternmatch.ps}{CPMATCH}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CPMATCH ComplexPatternMatch>>=
)abbrev package CPMATCH ComplexPatternMatch
++ Author: Barry Trager
++ Date Created: 30 Nov 1995
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex, pattern matching
++ References:
++ Description:
++ This package supports matching patterns involving complex expressions
ComplexPatternMatch(R, S, CS) : C == T where
    R: SetCategory
    S: Join(PatternMatchable R, CommutativeRing)
    CS: ComplexCategory S
    PMRS ==> PatternMatchResult(R, CS)
    PS   ==> Polynomial S
    C == with
       if PS has PatternMatchable(R) then
           patternMatch: (CS, Pattern R, PMRS) -> PMRS
             ++ patternMatch(cexpr, pat, res) matches the pattern pat to the
             ++ complex expression cexpr. res contains the variables of pat
             ++ which are already matched and their matches.

    T == add

       import PatternMatchPushDown(R, S, CS)
       import PatternMatchResultFunctions2(R, PS, CS)
       import PatternMatchResultFunctions2(R, CS, PS)

       ivar : PS := "%i"::Symbol::PS

       makeComplex(p:PS):CS ==
          up := univariate p
	  degree up > 1 => error "not linear in %i"
	  icoef:=leadingCoefficient(up)
          rcoef:=leadingCoefficient(reductum p)
	  complex(rcoef,icoef)

       makePoly(cs:CS):PS == real(cs)*ivar + imag(cs)::PS

       if PS has PatternMatchable(R) then
          patternMatch(cs, pat, result) ==
	     zero? imag cs =>
                patternMatch(real cs, pat, result)
             map(makeComplex,
                patternMatch(makePoly cs, pat, map(makePoly, result)))

@
<<CPMATCH.dotabb>>=
"CPMATCH" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CPMATCH"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CPMATCH" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CRFP ComplexRootFindingPackage}
\pagehead{ComplexRootFindingPackage}{CRFP}
\pagepic{ps/v104complexrootfindingpackage.ps}{CRFP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CRFP ComplexRootFindingPackage>>=
)abbrev package CRFP ComplexRootFindingPackage
++ Author: J. Grabmeier
++ Date Created: 31 January 1991
++ Date Last Updated: 12 April 1991
++ Basic Operations: factor, pleskenSplit
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: complex zeros, roots
++ References: J. Grabmeier: On Plesken's root finding algorithm,
++  in preparation
++  A. Schoenhage: The fundamental theorem of algebra in terms of computational
++  complexity, preliminary report, Univ. Tuebingen, 1982
++ Description:
++  \spadtype{ComplexRootFindingPackage} provides functions to
++  find all roots of a polynomial p over the complex number by
++  using Plesken's idea to calculate in the polynomial ring
++  modulo f and employing the Chinese Remainder Theorem.
++  In this first version, the precision (see \spadfunFrom{digits}{Float})
++  is not increased when this is necessary to
++  avoid rounding errors. Hence it is the user's responsibility to
++  increase the precision if necessary.
++  Note also, if this package is called with e.g. \spadtype{Fraction Integer},
++  the precise calculations could require a lot of time.
++  Also note that evaluating the zeros is not necessarily a good check
++  whether the result is correct: already evaluation can cause
++  rounding errors.
ComplexRootFindingPackage(R, UP): public == private where
   -- R   : Join(Field, OrderedRing, CharacteristicZero)
   -- Float not in CharacteristicZero !|
   R   : Join(Field, OrderedRing)
   UP  : UnivariatePolynomialCategory Complex R

   C      ==> Complex R
   FR     ==> Factored
   I      ==> Integer
   L      ==> List
   FAE    ==> Record(factors : L UP, error : R)
   NNI    ==> NonNegativeInteger
   OF     ==> OutputForm
   ICF    ==> IntegerCombinatoricFunctions(I)

   public ==> with
     complexZeros : UP -> L C
       ++ complexZeros(p) tries to determine all complex zeros
       ++ of the polynomial p with accuracy given by the package
       ++ constant {\em globalEps} which you may change by
       ++ {\em setErrorBound}.
     complexZeros : (UP, R) -> L C
       ++ complexZeros(p, eps) tries to determine all complex zeros
       ++ of the polynomial p with accuracy given by {\em eps}.
     divisorCascade : (UP,UP, Boolean) -> L FAE
       ++ divisorCascade(p,tp) assumes that degree of polynomial {\em tp}
       ++ is smaller than degree of polynomial p, both monic.
       ++ A sequence of divisions are calculated
       ++ using the remainder, made monic, as divisor
       ++ for the the next division. The result contains also the error of the
       ++ factorizations, i.e. the norm of the remainder polynomial.
       ++ If {\em info} is {\em true}, then information messages are issued.
     divisorCascade : (UP,UP) -> L FAE
       ++ divisorCascade(p,tp) assumes that degree of polynomial {\em tp}
       ++ is smaller than degree of polynomial p, both monic.
       ++ A sequence of divisions is calculated
       ++ using the remainder, made monic, as divisor
       ++ for the  the next division. The result contains also the error of the
       ++ factorizations, i.e. the norm of the remainder polynomial.
     factor: (UP,R,Boolean)  ->  FR UP
       ++ factor(p, eps, info) tries to factor p into linear factors
       ++ with error atmost {\em eps}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
       ++ If {\em info} is {\em true}, then information messages are given.
     factor: (UP,R)  ->  FR UP
       ++ factor(p, eps) tries to factor p into linear factors
       ++ with error atmost {\em eps}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
     factor: UP  ->  FR UP
       ++ factor(p) tries to factor p into linear factors
       ++ with error atmost {\em globalEps}, the internal error bound,
       ++ which can be set by {\em setErrorBound}. An overall error bound
       ++ {\em eps0} is determined and iterated tree-like calls
       ++ to {\em pleskenSplit} are used to get the factorization.
     graeffe : UP -> UP
       ++ graeffe p determines q such that \spad{q(-z**2) = p(z)*p(-z)}.
       ++ Note that the roots of q are the squares of the roots of p.
     norm : UP -> R
       ++ norm(p) determines sum of absolute values of coefficients
       ++ Note: this function depends on \spadfunFrom{abs}{Complex}.
     pleskenSplit: (UP, R, Boolean)  ->  FR UP
       ++ pleskenSplit(poly,eps,info) determines a start polynomial {\em start}
       ++ by using "startPolynomial then it increases the exponent
       ++ n of {\em start ** n mod poly} to get an approximate factor of
       ++ {\em poly}, in general of degree "degree poly -1". Then a divisor
       ++ cascade is calculated and the best splitting is chosen, as soon
       ++ as the error is small enough.
       --++ In a later version we plan
       --++ to use the whole information to get a split into more than 2
       --++ factors.
       ++ If {\em info} is {\em true}, then information messages are issued.
     pleskenSplit: (UP, R)  ->  FR UP
       ++ pleskenSplit(poly, eps)  determines a start polynomial {\em start}\
       ++ by using "startPolynomial then it increases the exponent
       ++ n of {\em start ** n mod poly} to get an approximate factor of
       ++ {\em poly}, in general of degree "degree poly -1". Then a divisor
       ++ cascade is calculated and the best splitting is chosen, as soon
       ++ as the error is small enough.
       --++ In a later version we plan
       --++ to use the whole information to get a split into more than 2
       --++ factors.
     reciprocalPolynomial: UP  -> UP
       ++ reciprocalPolynomial(p) calulates a polynomial which has exactly
       ++ the inverses of the non-zero roots of p as roots, and the same
       ++ number of 0-roots.
     rootRadius: (UP,R) -> R
       ++ rootRadius(p,errQuot) calculates the root radius of p with a
       ++ maximal error quotient of {\em errQuot}.
     rootRadius: UP -> R
       ++ rootRadius(p) calculates the root radius of p with a
       ++ maximal error quotient of {\em 1+globalEps}, where
       ++ {\em globalEps} is the internal error bound, which can be
       ++ set by {\em setErrorBound}.
     schwerpunkt: UP ->  C
       ++ schwerpunkt(p) determines the 'Schwerpunkt' of the roots of the
       ++ polynomial p of degree n, i.e. the center of gravity, which is
       ++ {\em coeffient of \spad{x**(n-1)}} divided by
       ++ {\em n times coefficient of \spad{x**n}}.
     setErrorBound : R -> R
       ++ setErrorBound(eps) changes the internal error bound,
       -- by default being {\em 10 ** (-20)} to eps, if R is
       ++ by default being {\em 10 ** (-3)} to eps, if R is
       ++ a member in the category \spadtype{QuotientFieldCategory Integer}.
       ++ The internal {\em globalDigits} is set to
       -- {\em ceiling(1/r)**2*10} being {\em 10**41} by default.
       ++ {\em ceiling(1/r)**2*10} being {\em 10**7} by default.
     startPolynomial: UP  -> Record(start: UP, factors: FR UP)
       ++ startPolynomial(p) uses the ideas of Schoenhage's
       ++ variant of Graeffe's method to construct circles which separate
       ++ roots to get a good start polynomial, i.e. one whose
       ++ image under the Chinese Remainder Isomorphism has both entries
       ++ of norm smaller and greater or equal to 1. In case the
       ++ roots are found during internal calculations.
       ++ The corresponding factors
       ++ are in {\em factors} which are otherwise 1.

   private ==> add


     Rep := ModMonic(C, UP)

     -- constants
     c : C
     r : R
     --globalDigits : I := 10 ** 41
     globalDigits : I := 10 ** 7
     globalEps : R :=
       --a : R := (1000000000000000000000 :: I) :: R
       a : R := (1000 :: I) :: R
       1/a
     emptyLine : OF := "  "
     dashes : OF := center "---------------------------------------------------"
     dots : OF :=   center "..................................................."
     one : R := 1$R
     two : R := 2 * one
     ten : R := 10 * one
     eleven : R := 11 * one
     weakEps := eleven/ten
     --invLog2 : R := 1/log10 (2*one)

     -- signatures of local functions

     absC : C -> R
       --
     absR : R -> R
       --
     calculateScale : UP -> R
       --
     makeMonic : UP -> UP
       -- 'makeMonic p' divides 'p' by the leading coefficient,
       -- to guarantee new leading coefficient to be 1$R  we cannot
       -- simply divide the leading monomial by the leading coefficient
       -- because of possible rounding errors
     min: (FAE, FAE) -> FAE
       -- takes factorization with smaller error
     nthRoot : (R, NNI) -> R
       -- nthRoot(r,n) determines an approximation to the n-th
       -- root of r, if \spadtype{R} has {\em ?**?: (R,Fraction Integer)->R}
       -- we use this, otherwise we use {\em approxNthRoot} via
       -- \spadtype{Integer}
     shift: (UP,C) ->  UP
       -- shift(p,c) changes p(x) into p(x+c), thereby modifying the
       -- roots u_j of p to the roots (u_j - c)  of shift(p,c)
     scale: (UP,C) -> UP
       -- scale(p,c) changes p(x) into p(cx), thereby modifying the
       -- roots u_j of p to the roots ((1/c) u_j)  of scale(p,c)


     -- implementation of exported functions


     complexZeros(p,eps) ==
       --r1 : R := rootRadius(p,weakEps)
       --eps0 : R = r1 * nthRoot(eps, degree p)
       -- right now we are content with
       eps0 : R := eps/(ten ** degree p)
       facs : FR UP := factor(p,eps0)
       [-coefficient(linfac.factor,0) for linfac in factors facs]

     complexZeros p == complexZeros(p,globalEps)
     setErrorBound r ==
       r <= 0 => error "setErrorBound: need error bound greater 0"
       globalEps := r
       if R has QuotientFieldCategory Integer then
         rd : Integer := ceiling(1/r)
         globalDigits := rd * rd * 10
         lof : List OF := _
           ["setErrorBound: internal digits set to",globalDigits::OF]
         print hconcat lof
       messagePrint  "setErrorBound: internal error bound set to"
       globalEps

     pleskenSplit(poly,eps,info) ==
       p := makeMonic poly
       fp : FR UP
       if not zero? (md := minimumDegree p) then
         fp : FR UP := irreducibleFactor(monomial(1,1)$UP,md)$(FR UP)
         p := p quo monomial(1,md)$UP
       sP : Record(start: UP, factors: FR UP) := startPolynomial p
       fp : FR UP := sP.factors
--       if not one? fp then
       if not (fp = 1) then
         qr: Record(quotient: UP, remainder: UP):= divide(p,makeMonic expand fp)
         p := qr.quotient
       st := sP.start
       zero? degree st => fp
         -- we calculate in ModMonic(C, UP),
         -- next line defines the polynomial, which is used for reducing
       setPoly p
       nm : R := eps
       split : FAE
       sR : Rep := st :: Rep
       psR : Rep := sR ** (degree poly)

       notFoundSplit : Boolean := true
       while notFoundSplit repeat
       --  if info then
       --    lof : L OF := ["not successfull, new exponent:", nn::OF]
       --    print hconcat lof
         psR := psR * psR * sR   -- exponent (2*d +1)
         -- be careful, too large exponent results in rounding errors
         -- tp is the first approximation of a divisor of poly:
         tp : UP  := lift psR
         zero? degree tp  =>
           if info then print "we leave as we got constant factor"
           nilFactor(poly,1)$(FR UP)
         -- this was the case where we don't find a non-trivial factorization
         -- we refine tp by repeated polynomial division and hope that
         -- the norm of the remainder gets small  from time to time
         splits : L FAE :=  divisorCascade(p, makeMonic tp, info)
         split := reduce(min,splits)
         notFoundSplit := (eps <=  split.error)

       for fac in split.factors repeat
         fp :=
--           one? degree fac => fp * nilFactor(fac,1)$(FR UP)
           (degree fac = 1) => fp * nilFactor(fac,1)$(FR UP)
           fp * irreducibleFactor(fac,1)$(FR UP)
       fp

     startPolynomial p == -- assume minimumDegree is 0
       --print (p :: OF)
       fp : FR UP := 1
--       one? degree p =>
       (degree p = 1) =>
         p := makeMonic p
         [p,irreducibleFactor(p,1)]
       startPoly : UP := monomial(1,1)$UP
       eps : R := weakEps   -- 10 per cent errors allowed
       r1 : R := rootRadius(p, eps)
       rd : R := 1/rootRadius(reciprocalPolynomial p, eps)
       (r1 > (2::R)) and (rd < 1/(2::R)) => [startPoly,fp] -- unit circle splitting!
       -- otherwise the norms of the roots are too closed so we
       -- take the center of gravity as new origin:
       u  : C := schwerpunkt p
       startPoly := startPoly-monomial(u,0)
       p := shift(p,-u)
       -- determine new rootRadius:
       r1 : R := rootRadius(p, eps)
       startPoly := startPoly/(r1::C)
       -- use one of the 4 points r1*zeta, where zeta is a 4th root of unity
       -- as new origin, this could be changed to an arbitrary list
       -- of elements of norm 1.
       listOfCenters : L C := [complex(r1,0), complex(0,r1), _
         complex(-r1,0), complex(0,-r1)]
       lp   : L UP := [shift(p,v) for v in listOfCenters]
       -- next we check if one of these centers is a root
       centerIsRoot : Boolean := false
       for i in 1..maxIndex lp repeat
         if (mD := minimumDegree lp.i) > 0 then
           pp : UP := monomial(1,1)-monomial(listOfCenters.i-u,0)
           centerIsRoot := true
           fp := fp * irreducibleFactor(pp,mD)
       centerIsRoot =>
         p := shift(p,u) quo expand fp
         --print (p::OF)
         zero? degree p => [p,fp]
         sP:= startPolynomial(p)
         [sP.start,fp]
       -- choose the best one w.r.t. maximal quotient of norm of largest
       -- root and norm of smallest root
       lpr1 : L R := [rootRadius(q,eps) for  q in lp]
       lprd : L R := [1/rootRadius(reciprocalPolynomial q,eps) for  q in lp]
       -- later we should check here of an rd is smaller than globalEps
       lq : L R := []
       for i in 1..maxIndex lpr1 repeat
         lq := cons(lpr1.i/lprd.i, lq)
       --lq : L R := [(l/s)::R for l in lpr1 for s in lprd])
       lq := reverse lq
       po := position(reduce(max,lq),lq)
       --p := lp.po
       --lrr : L R := [rootRadius(p,i,1+eps) for i in 2..(degree(p)-1)]
       --lrr := concat(concat(lpr1.po,lrr),lprd.po)
       --lu : L R := [(lrr.i + lrr.(i+1))/2 for i in 1..(maxIndex(lrr)-1)]
       [startPoly - monomial(listOfCenters.po,0),fp]

     norm p ==
      -- reduce(_+$R,map(absC,coefficients p))
      nm : R := 0
      for c in  coefficients p repeat
        nm := nm + absC c
      nm

     pleskenSplit(poly,eps) == pleskenSplit(poly,eps,false)

     graeffe p ==
       -- If  p = ao x**n + a1 x**(n-1) + ... + a<n-1> x + an
       -- and q = bo x**n + b1 x**(n-1) + ... + b<n-1> x + bn
       -- are such that q(-x**2) = p(x)p(-x), then
       -- bk := ak**2 + 2 * ((-1) * a<k-1>*a<k+1> + ... +
       --                    (-1)**l * a<l>*a<l>) where l = min(k, n-k).
       -- graeffe(p) constructs q using these identities.
       n   : NNI  := degree p
       aForth : L C := []
       for k in 0..n repeat  --  aForth = [a0, a1, ..., a<n-1>, an]
         aForth := cons(coefficient(p, k::NNI), aForth)
       aBack  : L C := [] --  after k steps
                             --  aBack = [ak, a<k-1>, ..., a1, a0]
       gp : UP := 0$UP
       for k in 0..n repeat
         ak : C := first aForth
         aForth := rest aForth
         aForthCopy : L C := aForth  -- we iterate over aForth and
         aBackCopy  : L C := aBack   -- aBack but do not want to
                                      -- destroy them
         sum        :   C := 0
         const : I  := -1  --  after i steps const = (-1)**i
         for aminus in aBack for aplus in aForth repeat
           -- after i steps aminus = a<k-i> and aplus = a<k+i>
           sum := sum + const * aminus * aplus
           aForthCopy := rest aForthCopy
           aBackCopy  := rest aBackCopy
           const := -const
         gp := gp + monomial(ak*ak + 2 * sum, (n-k)::NNI)
         aBack := cons(ak, aBack)
       gp



     rootRadius(p,errorQuotient) ==
       errorQuotient <= 1$R =>
         error "rootRadius: second Parameter must be greater than 1"
       pp   : UP  := p
       rho  : R   := calculateScale makeMonic pp
       rR   : R   := rho
       pp := makeMonic scale(pp,complex(rho,0$R))
       expo : NNI := 1
       d    : NNI := degree p
       currentError:  R   := nthRoot(2::R, 2)
       currentError     := d*20*currentError
       while nthRoot(currentError, expo) >= errorQuotient repeat
         -- if info then print (expo :: OF)
         pp := graeffe pp
         rho := calculateScale pp
         expo := 2 * expo
         rR := nthRoot(rho, expo) * rR
         pp :=  makeMonic scale(pp,complex(rho,0$R))
       rR

     rootRadius(p) == rootRadius(p, 1+globalEps)

     schwerpunkt p ==
       zero? p => 0$C
       zero? (d := degree p) => error _
       "schwerpunkt: non-zero const. polynomial has no roots and no schwerpunkt"
       -- coeffient of x**d and x**(d-1)
       lC : C :=  coefficient(p,d)  -- ^= 0
       nC : C :=  coefficient(p,(d-1) pretend NNI)
       (denom := recip ((d::I::C)*lC)) case "failed" => error  "schwerpunkt: _
         degree * leadingCoefficient not invertible in ring of coefficients"
       - (nC*(denom::C))

     reciprocalPolynomial p ==
       zero? p => 0
       d : NNI := degree p
       md : NNI := d+minimumDegree p
       lm : L UP := [monomial(coefficient(p,i),(md-i) :: NNI) for i in 0..d]
       sol := reduce(_+, lm)

     divisorCascade(p, tp, info) ==
       lfae : L FAE :=  nil()
       for i in 1..degree tp while (degree tp > 0)  repeat
         -- USE monicDivide !!!
         qr  : Record(quotient: UP, remainder: UP)  :=  divide(p,tp)
         factor1 : UP := tp
         factor2 : UP := makeMonic qr.quotient
         -- refinement of tp:
         tp := qr.remainder
         nm : R := norm tp
         listOfFactors  : L UP := cons(factor2,nil()$(L UP))
         listOfFactors := cons(factor1,listOfFactors)
         lfae := cons( [listOfFactors,nm], lfae)
         if info then
           --lof : L OF :=  [i :: OF,"-th division:"::OF]
           --print center box hconcat lof
           print emptyLine
           lof : L OF :=  ["error polynomial has degree " ::OF,_
             (degree tp)::OF, " and norm " :: OF, nm :: OF]
           print center hconcat lof
           lof : L OF := ["degrees of factors:" ::OF,_
             (degree factor1)::OF,"  ", (degree factor2)::OF]
           print center hconcat lof
       if info then print emptyLine
       reverse lfae

     divisorCascade(p, tp) == divisorCascade(p, tp, false)

     factor(poly,eps) == factor(poly,eps,false)
     factor(p) == factor(p, globalEps)

     factor(poly,eps,info) ==
       result : FR  UP := coerce monomial(leadingCoefficient poly,0)
       d : NNI := degree poly
       --should be
       --den : R := (d::I)::R * two**(d::Integer) * norm poly
       --eps0 : R := eps / den
       -- for now only
       eps0 : R := eps / (ten*ten)
--       one? d  => irreducibleFactor(poly,1)$(FR UP)
       (d = 1) => irreducibleFactor(poly,1)$(FR UP)
       listOfFactors : L Record(factor: UP,exponent: I) :=_
         list [makeMonic poly,1]
       if info then
         lof : L OF := [dashes,dots,"list of Factors:",dots,listOfFactors::OF, _
           dashes, "list of Linear Factors:", dots, result::OF, _
           dots,dashes]
         print vconcat lof
       while not null listOfFactors  repeat
         p : UP := (first listOfFactors).factor
         exponentOfp : I := (first listOfFactors).exponent
         listOfFactors := rest listOfFactors
         if info then
           lof : L OF := ["just now we try to split the polynomial:",p::OF]
           print vconcat lof
         split : FR UP  := pleskenSplit(p, eps0, info)
--         one? numberOfFactors split =>
         (numberOfFactors split = 1) =>
           -- in a later version we will change error bound and
           -- accuracy here to deal this case as well
           lof : L OF := ["factor: couldn't split factor",_
             center(p :: OF), "with required error bound"]
           print vconcat lof
           result := result * nilFactor(p, exponentOfp)
         -- now we got 2 good factors of p, we drop p and continue
         -- with the factors, if they are not linear, or put a
         -- linear factor to the result
         for rec in factors(split)$(FR UP) repeat
           newFactor : UP := rec.factor
           expOfFactor := exponentOfp * rec.exponent
--           one? degree newFactor =>
           (degree newFactor = 1) =>
             result := result * nilFactor(newFactor,expOfFactor)
           listOfFactors:=cons([newFactor,expOfFactor],_
             listOfFactors)
       result

     -- implementation of local functions

     absC c == nthRoot(norm(c)$C,2)
     absR r ==
       r < 0 => -r
       r
     min(fae1,fae2) ==
       fae2.error <  fae1.error => fae2
       fae1
     calculateScale p ==
       d  := degree p
       maxi :R := 0
       for j in 1..d for cof in rest coefficients p repeat
         -- here we need abs: R -> R
         rc :  R := absR real cof
         ic :  R := absR imag cof
         locmax: R := max(rc,ic)
         maxi := max( nthRoot( locmax/(binomial(d,j)$ICF::R), j), maxi)
       -- Maybe I should use some type of logarithm for the following:
       maxi = 0$R => error("Internal Error: scale cannot be 0")
       rho  :R := one
       rho < maxi =>
         while rho < maxi repeat rho := ten * rho
         rho / ten
       while maxi < rho repeat rho := rho / ten
       rho = 0 => one
       rho
     makeMonic p  ==
       p = 0 => p
       monomial(1,degree p)$UP + (reductum p)/(leadingCoefficient p)

     scale(p, c) ==
       -- eval(p,cx) is missing !!
       eq : Equation UP := equation(monomial(1,1), monomial(c,1))
       eval(p,eq)
       -- improvement?: direct calculation of the new coefficients

     shift(p,c) ==
       rhs : UP := monomial(1,1) + monomial(c,0)
       eq : Equation UP := equation(monomial(1,1), rhs)
       eval(p,eq)
       -- improvement?: direct calculation of the new coefficients

     nthRoot(r,n) ==
       R has RealNumberSystem =>  r ** (1/n)
       R has QuotientFieldCategory Integer =>
         den : I := approxNthRoot(globalDigits * denom r ,n)$IntegerRoots(I)
         num : I := approxNthRoot(globalDigits * numer r ,n)$IntegerRoots(I)
         num/den
       -- the following doesn't compile
       --R has coerce: % -> Fraction Integer =>
       --  q : Fraction Integer := coerce(r)@Fraction(Integer)
       --  den : I := approxNthRoot(globalDigits * denom q ,n)$IntegerRoots(I)
       --  num : I := approxNthRoot(globalDigits * numer q ,n)$IntegerRoots(I)
       --  num/den
       r -- this is nonsense, perhaps a Newton iteration for x**n-r here

)fin
     -- for late use:

     graeffe2 p ==
       -- substitute x by -x :
       eq : Equation UP := equation(monomial(1,1), monomial(-1$C,1))
       pp : UP := p*eval(p,eq)
       gp : UP :=  0$UP
       while pp ^= 0 repeat
          i:NNI := (degree pp) quo (2::NNI)
          coef:C:=
            even? i => leadingCoefficient pp
            - leadingCoefficient pp
          gp    := gp + monomial(coef,i)
          pp    := reductum pp
       gp
     shift2(p,c) ==
       d := degree p
       cc : C := 1
       coef := List C := [cc := c * cc for i in 1..d]
       coef := cons(1,coef)
       coef := [coefficient(p,i)*coef.(1+i) for i in 0..d]
       res : UP := 0
       for j in 0..d repeat
         cc := 0
         for i in j..d repeat
           cc := cc + coef.i * (binomial(i,j)$ICF :: R)
         res := res + monomial(cc,j)$UP
       res
     scale2(p,c) ==
       d := degree p
       cc : C := 1
       coef := List C := [cc := c * cc for i in 1..d]
       coef := cons(1,coef)
       coef := [coefficient(p,i)*coef.(i+1) for i in 0..d]
       res : UP := 0
       for i in 0..d repeat  res := res + monomial(coef.(i+1),i)$UP
       res
     scale2: (UP,C) -> UP
     shift2: (UP,C) ->  UP
     graeffe2 : UP -> UP
       ++ graeffe2 p determines q such that \spad{q(-z**2) = p(z)*p(-z)}.
       ++ Note that the roots of q are the squares of the roots of p.

@
<<CRFP.dotabb>>=
"CRFP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CRFP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CRFP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CMPLXRT ComplexRootPackage}
\pagehead{ComplexRootPackage}{CMPLXRT}
\pagepic{ps/v104complexrootpackage.ps}{CMPLXRT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CMPLXRT ComplexRootPackage>>=
)abbrev package CMPLXRT ComplexRootPackage
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: Complex, Float, Fraction, UnivariatePolynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package provides functions complexZeros
++ for finding the complex zeros
++ of univariate polynomials with complex rational number coefficients.
++ The results are to any user specified precision and are returned
++ as either complex rational number or complex floating point numbers
++ depending on the type of the second argument which specifies the
++ precision.

-- Packages for the computation of complex roots of
-- univariate polynomials with rational or gaussian coefficients.

-- Simplified version, the old original based on Gebauer's solver is
-- in ocmplxrt spad
RN     ==> Fraction Integer
I      ==> Integer
NF     ==> Float

ComplexRootPackage(UP,Par) : T == C where
   UP   :   UnivariatePolynomialCategory Complex Integer
   Par  :   Join(Field, OrderedRing) -- will be Float or RN
   CP   ==> Complex Par
   PCI  ==> Polynomial Complex Integer

   T == with
        complexZeros:(UP,Par)  -> List CP
          ++ complexZeros(poly, eps) finds the complex zeros of the
          ++ univariate polynomial poly to precision eps with
          ++ solutions returned as complex floats or rationals
          ++ depending on the type of eps.

   C == add
    complexZeros(p:UP,eps:Par):List CP ==
      x1:Symbol():=new()
      x2:Symbol():=new()
      vv:Symbol():=new()
      lpf:=factors factor(p)$ComplexFactorization(I,UP)
      ris:List CP:=empty()
      for pf in lpf repeat
          pp:=pf.factor pretend SparseUnivariatePolynomial Complex Integer
          q:PCI :=multivariate(pp,vv)
          q:=eval(q,vv,x1::PCI+complex(0,1)*(x2::PCI))
          p1:=map(real,q)$PolynomialFunctions2(Complex I,I)
          p2:=map(imag,q)$PolynomialFunctions2(Complex I,I)
          lz:=innerSolve([p1,p2],[],[x1,x2],
                          eps)$InnerNumericFloatSolvePackage(I,Par,Par)
          ris:=append([complex(first z,second z) for z in lz],ris)
      ris

@
<<CMPLXRT.dotabb>>=
"CMPLXRT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CMPLXRT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CMPLXRT" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CTRIGMNP ComplexTrigonometricManipulations}
\pagehead{ComplexTrigonometricManipulations}{CTRIGMNP}
\pagepic{ps/v104complextrigonometricmanipulations.ps}{CTRIGMNP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CTRIGMNP ComplexTrigonometricManipulations>>=
)abbrev package CTRIGMNP ComplexTrigonometricManipulations
++ Real and Imaginary parts of complex functions
++ Author: Manuel Bronstein
++ Date Created: 11 June 1993
++ Date Last Updated: 14 June 1993
++ Description:
++   \spadtype{ComplexTrigonometricManipulations} provides function that
++   compute the real and imaginary parts of complex functions.
++ Keywords: complex, function, manipulation.
ComplexTrigonometricManipulations(R, F): Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace Complex R)


  SY  ==> Symbol
  FR  ==> Expression R
  K   ==> Kernel F


  Exports ==> with
    complexNormalize: F -> F
      ++ complexNormalize(f) rewrites \spad{f} using the least possible number
      ++ of complex independent kernels.
    complexNormalize: (F, SY) -> F
      ++ complexNormalize(f, x) rewrites \spad{f} using the least possible
      ++ number of complex independent kernels involving \spad{x}.
    complexElementary: F -> F
      ++ complexElementary(f) rewrites \spad{f} in terms of the 2 fundamental
      ++ complex transcendental elementary functions: \spad{log, exp}.
    complexElementary: (F, SY) -> F
      ++ complexElementary(f, x) rewrites the kernels of \spad{f} involving
      ++ \spad{x} in terms of the 2 fundamental complex
      ++ transcendental elementary functions: \spad{log, exp}.
    real   : F -> FR
      ++ real(f) returns the real part of \spad{f} where \spad{f} is a complex
      ++ function.
    imag   : F -> FR
      ++ imag(f) returns the imaginary part of \spad{f} where \spad{f}
      ++ is a complex function.
    real?  : F -> Boolean
      ++ real?(f) returns \spad{true} if \spad{f = real f}.
    trigs  : F -> F
      ++ trigs(f) rewrites all the complex logs and exponentials
      ++ appearing in \spad{f} in terms of trigonometric functions.
    complexForm: F -> Complex FR
      ++ complexForm(f) returns \spad{[real f, imag f]}.

  Implementation ==> add
    import InnerTrigonometricManipulations(R, FR, F)
    import ElementaryFunctionStructurePackage(Complex R, F)

    rreal?: Complex R -> Boolean
    kreal?: Kernel F -> Boolean
    localexplogs  : (F, F, List SY) -> F

    real f        == real complexForm f
    imag f        == imag complexForm f
    rreal? r      == zero? imag r
    kreal? k      == every?(real?, argument k)$List(F)
    complexForm f == explogs2trigs f

    trigs f ==
      GF2FG explogs2trigs f

    real? f ==
      every?(rreal?, coefficients numer f)
        and every?(rreal?, coefficients denom f) and every?(kreal?, kernels f)

    localexplogs(f, g, lx) ==
      trigs2explogs(g, [k for k in tower f
                          | is?(k, "tan"::SY) or is?(k, "cot"::SY)], lx)

    complexElementary f ==
      any?(has?(#1, "rtrig"),
        operators(g := realElementary f))$List(BasicOperator) =>
          localexplogs(f, g, variables g)
      g

    complexElementary(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
                 | member?(x, variables(k::F))]$List(K))$List(K) =>
                     localexplogs(f, g, [x])
      g

    complexNormalize(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
               | member?(x, variables(k::F))]$List(K))$List(K) =>
                   (rischNormalize(localexplogs(f, g, [x]), x).func)
      rischNormalize(g, x).func

    complexNormalize f ==
      l := variables(g := realElementary f)
      any?(has?(#1, "rtrig"), operators g)$List(BasicOperator) =>
        h := localexplogs(f, g, l)
        for x in l repeat h := rischNormalize(h, x).func
        h
      for x in l repeat g := rischNormalize(g, x).func
      g

@
<<CTRIGMNP.dotabb>>=
"CTRIGMNP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CTRIGMNP"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"CTRIGMNP" -> "ACF"
"CTRIGMNP" -> "FS"
"CTRIGMNP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODECONST ConstantLODE}
\pagehead{ConstantLODE}{ODECONST}
\pagepic{ps/v104constantlode.ps}{ODECONST}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODECONST ConstantLODE>>=
)abbrev package ODECONST ConstantLODE
++ Author: Manuel Bronstein
++ Date Created: 18 March 1991
++ Date Last Updated: 3 February 1994
++ Description: Solution of linear ordinary differential equations, constant coefficient case.
ConstantLODE(R, F, L): Exports == Implementation where
  R: Join(OrderedSet, EuclideanDomain, RetractableTo Integer,
          LinearlyExplicitRingOver Integer, CharacteristicZero)
  F: Join(AlgebraicallyClosedFunctionSpace R,
          TranscendentalFunctionCategory, PrimitiveFunctionCategory)
  L: LinearOrdinaryDifferentialOperatorCategory F

  Z   ==> Integer
  SY  ==> Symbol
  K   ==> Kernel F
  V   ==> Vector F
  M   ==> Matrix F
  SUP ==> SparseUnivariatePolynomial F

  Exports ==> with
    constDsolve: (L, F, SY) -> Record(particular:F, basis:List F)
      ++ constDsolve(op, g, x) returns \spad{[f, [y1,...,ym]]}
      ++ where f is a particular solution of the equation \spad{op y = g},
      ++ and the \spad{yi}'s form a basis for the solutions of \spad{op y = 0}.

  Implementation ==> add
    import ODETools(F, L)
    import ODEIntegration(R, F)
    import ElementaryFunctionSign(R, F)
    import AlgebraicManipulations(R, F)
    import FunctionSpaceIntegration(R, F)
    import FunctionSpaceUnivariatePolynomialFactor(R, F, SUP)

    homoBasis: (L, F) -> List F
    quadSol  : (SUP, F) -> List F
    basisSqfr: (SUP, F) -> List F
    basisSol : (SUP, Z, F) -> List F

    constDsolve(op, g, x) ==
      b := homoBasis(op, x::F)
      [particularSolution(op, g, b, int(#1, x))::F, b]

    homoBasis(op, x) ==
      p:SUP := 0
      while op ^= 0 repeat
          p  := p + monomial(leadingCoefficient op, degree op)
          op := reductum op
      b:List(F) := empty()
      for ff in factors ffactor p repeat
        b := concat_!(b, basisSol(ff.factor, dec(ff.exponent), x))
      b

    basisSol(p, n, x) ==
      l := basisSqfr(p, x)
      zero? n => l
      ll := copy l
      xn := x::F
      for i in 1..n repeat
        l := concat_!(l, [xn * f for f in ll])
        xn := x * xn
      l

    basisSqfr(p, x) ==
--      one?(d := degree p) =>
      ((d := degree p) = 1) =>
        [exp(- coefficient(p, 0) * x / leadingCoefficient p)]
      d = 2 => quadSol(p, x)
      [exp(a * x) for a in rootsOf p]

    quadSol(p, x) ==
      (u := sign(delta := (b := coefficient(p, 1))**2 - 4 *
        (a := leadingCoefficient p) * (c := coefficient(p, 0))))
          case Z and negative?(u::Z) =>
            y := x / (2 * a)
            r := - b * y
            i := rootSimp(sqrt(-delta)) * y
            [exp(r) * cos(i), exp(r) * sin(i)]
      [exp(a * x) for a in zerosOf p]

@
<<ODECONST.dotabb>>=
"ODECONST" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODECONST"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"ODECONST" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COORDSYS CoordinateSystems}
\pagehead{CoordinateSystems}{COORDSYS}
\pagepic{ps/v104coordinatesystems.ps}{COORDSYS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COORDSYS CoordinateSystems>>=
)abbrev package COORDSYS CoordinateSystems
++ Author: Jim Wen
++ Date Created: 12 March 1990
++ Date Last Updated: 19 June 1990, Clifton J. Williamson
++ Basic Operations: cartesian, polar, cylindrical, spherical, parabolic, elliptic, 
++ parabolicCylindrical, paraboloidal, ellipticCylindrical, prolateSpheroidal,
++ oblateSpheroidal, bipolar, bipolarCylindrical, toroidal, conical
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: CoordinateSystems provides coordinate transformation functions 
++ for plotting.  Functions in this package return conversion functions 
++ which take points expressed in other coordinate systems and return points 
++ with the corresponding Cartesian coordinates.
 
CoordinateSystems(R): Exports == Implementation where

  R : Join(Field,TranscendentalFunctionCategory,RadicalCategory)
  Pt ==> Point R

  Exports ==> with
    cartesian : Pt -> Pt
      ++ cartesian(pt) returns the Cartesian coordinates of point pt.
    polar: Pt -> Pt
      ++ polar(pt) transforms pt from polar coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta)}
      ++ to \spad{x = r * cos(theta)} , \spad{y = r * sin(theta)}.
    cylindrical: Pt -> Pt
      ++ cylindrical(pt) transforms pt from polar coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta,z)}
      ++ to \spad{x = r * cos(theta)}, \spad{y = r * sin(theta)}, \spad{z}.
    spherical: Pt -> Pt
      ++ spherical(pt) transforms pt from spherical coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(r,theta,phi)}
      ++ to \spad{x = r*sin(phi)*cos(theta)}, \spad{y = r*sin(phi)*sin(theta)},
      ++ \spad{z = r*cos(phi)}.
    parabolic: Pt -> Pt
      ++ parabolic(pt) transforms pt from parabolic coordinates to Cartesian 
      ++ coordinates: the function produced will map the point \spad{(u,v)} to
      ++ \spad{x = 1/2*(u**2 - v**2)}, \spad{y = u*v}.
    parabolicCylindrical: Pt -> Pt
      ++ parabolicCylindrical(pt) transforms pt from parabolic cylindrical 
      ++ coordinates to Cartesian coordinates: the function produced will 
      ++ map the point \spad{(u,v,z)} to \spad{x = 1/2*(u**2 - v**2)}, 
      ++ \spad{y = u*v}, \spad{z}.
    paraboloidal: Pt -> Pt
      ++ paraboloidal(pt) transforms pt from paraboloidal coordinates to 
      ++ Cartesian coordinates: the function produced will map the point 
      ++ \spad{(u,v,phi)} to \spad{x = u*v*cos(phi)}, \spad{y = u*v*sin(phi)},
      ++ \spad{z = 1/2 * (u**2 - v**2)}.
    elliptic: R -> (Pt -> Pt)
      ++ elliptic(a) transforms from elliptic coordinates to Cartesian 
      ++ coordinates: \spad{elliptic(a)} is a function which will map the 
      ++ point \spad{(u,v)} to \spad{x = a*cosh(u)*cos(v)}, \spad{y = a*sinh(u)*sin(v)}.
    ellipticCylindrical: R -> (Pt -> Pt)
      ++ ellipticCylindrical(a) transforms from elliptic cylindrical coordinates 
      ++ to Cartesian coordinates: \spad{ellipticCylindrical(a)} is a function
      ++ which will map the point \spad{(u,v,z)} to \spad{x = a*cosh(u)*cos(v)},
      ++ \spad{y = a*sinh(u)*sin(v)}, \spad{z}.
    prolateSpheroidal: R -> (Pt -> Pt)
      ++ prolateSpheroidal(a) transforms from prolate spheroidal coordinates to 
      ++ Cartesian coordinates: \spad{prolateSpheroidal(a)} is a function 
      ++ which will map the point \spad{(xi,eta,phi)} to 
      ++ \spad{x = a*sinh(xi)*sin(eta)*cos(phi)}, \spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, 
      ++ \spad{z = a*cosh(xi)*cos(eta)}.
    oblateSpheroidal: R -> (Pt -> Pt)
      ++ oblateSpheroidal(a) transforms from oblate spheroidal coordinates to 
      ++ Cartesian coordinates: \spad{oblateSpheroidal(a)} is a function which
      ++ will map the point \spad{(xi,eta,phi)} to \spad{x = a*sinh(xi)*sin(eta)*cos(phi)},
      ++ \spad{y = a*sinh(xi)*sin(eta)*sin(phi)}, \spad{z = a*cosh(xi)*cos(eta)}.
    bipolar: R -> (Pt -> Pt)
      ++ bipolar(a) transforms from bipolar coordinates to Cartesian coordinates:
      ++ \spad{bipolar(a)} is a function which will map the point \spad{(u,v)} to
      ++ \spad{x = a*sinh(v)/(cosh(v)-cos(u))}, \spad{y = a*sin(u)/(cosh(v)-cos(u))}.
    bipolarCylindrical: R -> (Pt -> Pt)
      ++ bipolarCylindrical(a) transforms from bipolar cylindrical coordinates 
      ++ to Cartesian coordinates: \spad{bipolarCylindrical(a)} is a function which 
      ++ will map the point \spad{(u,v,z)} to \spad{x = a*sinh(v)/(cosh(v)-cos(u))},
      ++ \spad{y = a*sin(u)/(cosh(v)-cos(u))}, \spad{z}.
    toroidal: R -> (Pt -> Pt)
      ++ toroidal(a) transforms from toroidal coordinates to Cartesian 
      ++ coordinates: \spad{toroidal(a)} is a function which will map the point 
      ++ \spad{(u,v,phi)} to \spad{x = a*sinh(v)*cos(phi)/(cosh(v)-cos(u))},
      ++ \spad{y = a*sinh(v)*sin(phi)/(cosh(v)-cos(u))}, \spad{z = a*sin(u)/(cosh(v)-cos(u))}.
    conical: (R,R) -> (Pt -> Pt)
      ++ conical(a,b) transforms from conical coordinates to Cartesian coordinates:
      ++ \spad{conical(a,b)} is a function which will map the point \spad{(lambda,mu,nu)} to
      ++ \spad{x = lambda*mu*nu/(a*b)},
      ++ \spad{y = lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))},
      ++ \spad{z = lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))}.

  Implementation ==> add

    cartesian pt ==
      -- we just want to interpret the cartesian coordinates
      -- from the first N elements of the point - so the
      -- identity function will do
      pt

    polar pt0 ==
      pt := copy pt0
      r := elt(pt0,1); theta := elt(pt0,2)
      pt.1 := r * cos(theta); pt.2 := r * sin(theta)
      pt

    cylindrical pt0 == polar pt0 
    -- apply polar transformation to first 2 coordinates

    spherical pt0 ==
      pt := copy pt0
      r := elt(pt0,1); theta := elt(pt0,2); phi := elt(pt0,3)
      pt.1 := r * sin(phi) * cos(theta); pt.2 := r * sin(phi) * sin(theta)
      pt.3 := r * cos(phi)
      pt

    parabolic pt0 ==
      pt := copy pt0
      u := elt(pt0,1); v := elt(pt0,2)
      pt.1 := (u*u - v*v)/(2::R) ; pt.2 := u*v
      pt

    parabolicCylindrical pt0 == parabolic pt0
    -- apply parabolic transformation to first 2 coordinates

    paraboloidal pt0 ==
      pt := copy pt0
      u := elt(pt0,1); v := elt(pt0,2); phi := elt(pt0,3)
      pt.1 := u*v*cos(phi); pt.2 := u*v*sin(phi); pt.3 := (u*u - v*v)/(2::R)
      pt

    elliptic a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2)
      pt.1 := a*cosh(u)*cos(v); pt.2 := a*sinh(u)*sin(v)
      pt

    ellipticCylindrical a == elliptic a
    -- apply elliptic transformation to first 2 coordinates

    prolateSpheroidal a ==
      pt := copy(#1)
      xi := elt(#1,1); eta := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(xi)*sin(eta)*cos(phi)
      pt.2 := a*sinh(xi)*sin(eta)*sin(phi)
      pt.3 := a*cosh(xi)*cos(eta)
      pt

    oblateSpheroidal a ==
      pt := copy(#1)
      xi := elt(#1,1); eta := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(xi)*sin(eta)*cos(phi)
      pt.2 := a*cosh(xi)*cos(eta)*sin(phi)
      pt.3 := a*sinh(xi)*sin(eta)
      pt

    bipolar a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2)
      pt.1 := a*sinh(v)/(cosh(v)-cos(u))
      pt.2 := a*sin(u)/(cosh(v)-cos(u))
      pt

    bipolarCylindrical a == bipolar a
    -- apply bipolar transformation to first 2 coordinates

    toroidal a ==
      pt := copy(#1)
      u := elt(#1,1); v := elt(#1,2); phi := elt(#1,3)
      pt.1 := a*sinh(v)*cos(phi)/(cosh(v)-cos(u))
      pt.2 := a*sinh(v)*sin(phi)/(cosh(v)-cos(u))
      pt.3 := a*sin(u)/(cosh(v)-cos(u))
      pt

    conical(a,b) ==
      pt := copy(#1)
      lambda := elt(#1,1); mu := elt(#1,2); nu := elt(#1,3)
      pt.1 := lambda*mu*nu/(a*b)
      pt.2 := lambda/a*sqrt((mu**2-a**2)*(nu**2-a**2)/(a**2-b**2))
      pt.3 := lambda/b*sqrt((mu**2-b**2)*(nu**2-b**2)/(b**2-a**2))
      pt

@
<<COORDSYS.dotabb>>=
"COORDSYS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COORDSYS"]
"PTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PTCAT"]
"COORDSYS" -> "PTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CRAPACK CRApackage}
\pagehead{CRApackage}{CRAPACK}
\pagepic{ps/v104crapackage.ps}{CRAPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CRAPACK CRApackage>>=
)abbrev package CRAPACK CRApackage
 
++ This package \undocumented{}
CRApackage(R:EuclideanDomain): Exports == Implementation where
  Exports == with
    modTree: (R,List R) -> List R
	++ modTree(r,l) \undocumented{}
    chineseRemainder: (List R, List R) -> R
    ++ chineseRemainder(lv,lm) returns a value \axiom{v} such that, if
    ++ x is \axiom{lv.i} modulo \axiom{lm.i} for all \axiom{i}, then
    ++ x is \axiom{v} modulo \axiom{lm(1)*lm(2)*...*lm(n)}.
    chineseRemainder: (List List R, List R) -> List R
    ++ chineseRemainder(llv,lm) returns a list of values, each of which
    ++ corresponds to the Chinese remainder of the associated element of
    ++ \axiom{llv} and axiom{lm}.  This is more efficient than applying
    ++ chineseRemainder several times.
    multiEuclideanTree: (List R, R) -> List R
	++ multiEuclideanTree(l,r) \undocumented{}
  Implementation == add

    BB:=BalancedBinaryTree(R)
    x:BB

    -- Definition for modular reduction mapping with several moduli
    modTree(a,lm) ==
      t := balancedBinaryTree(#lm, 0$R)
      setleaves_!(t,lm)
      mapUp_!(t,"*")
      leaves mapDown_!(t, a, "rem")

    chineseRemainder(lv:List(R), lm:List(R)):R ==
      #lm ^= #lv => error "lists of moduli and values not of same length"
      x := balancedBinaryTree(#lm, 0$R)
      x := setleaves_!(x, lm)
      mapUp_!(x,"*")
      y := balancedBinaryTree(#lm, 1$R)
      y := mapUp_!(copy y,x,#1 * #4 + #2 * #3)
      (u := extendedEuclidean(value y, value x,1)) case "failed" =>
        error "moduli not relatively prime"
      inv := u . coef1
      linv := modTree(inv, lm)
      l := [(u*v) rem m for v in lv for u in linv for m in lm]
      y := setleaves_!(y,l)
      value(mapUp_!(y, x, #1 * #4 + #2 * #3)) rem value(x)

    chineseRemainder(llv:List List(R), lm:List(R)):List(R) ==
      x := balancedBinaryTree(#lm, 0$R)
      x := setleaves_!(x, lm)
      mapUp_!(x,"*")
      y := balancedBinaryTree(#lm, 1$R)
      y := mapUp_!(copy y,x,#1 * #4 + #2 * #3)
      (u := extendedEuclidean(value y, value x,1)) case "failed" =>
        error "moduli not relatively prime"
      inv := u . coef1
      linv := modTree(inv, lm)
      retVal:List(R) := []
      for lv in llv repeat
        l := [(u3*v) rem m for v in lv for u3 in linv for m in lm]
        y := setleaves!(y,l)
        retVal := cons(value(mapUp!(y, x, #1*#4+#2*#3)) rem value(x),retVal)
      reverse retVal

    extEuclidean: (R, R, R) -> List R
    extEuclidean(a, b, c) ==
      u := extendedEuclidean(a, b, c)
      u case "failed" => error [c, " not spanned by ", a, " and ",b]
      [u.coef2, u.coef1]

    multiEuclideanTree(fl, rhs) ==
      x := balancedBinaryTree(#fl, rhs)
      x := setleaves_!(x, fl)
      mapUp_!(x,"*")
      leaves mapDown_!(x, rhs, extEuclidean)

@
<<CRAPACK.dotabb>>=
"CRAPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CRAPACK"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"CRAPACK" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CYCLES CycleIndicators}
<<CycleIndicators.input>>=
-- cycles.spad.pamphlet CycleIndicators.input
)sys rm CycleIndicators.output
)spool CycleIndicators.output
)set message test on
)set message auto off
)clear all
--S 1 of 47
complete 1
--R 
--R
--R   (1)  (1)
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 1

--S 2 of 47
complete 2
--R 
--R
--R        1       1   2
--R   (2)  - (2) + - (1 )
--R        2       2
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 2

--S 3 of 47
complete 3
--R 
--R
--R        1       1         1   3
--R   (3)  - (3) + - (2 1) + - (1 )
--R        3       2         6
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 3

--S 4 of 47
complete 7
--R 
--R
--R   (4)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R      1      5      1    7
--R     --- (2 1 ) + ---- (1 )
--R     240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 4

--S 5 of 47
elementary 7
--R 
--R
--R   (5)
--R     1       1          1          1     2     1         1            1     3
--R     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
--R     7       6         10         10          12         8           24
--R   + 
--R      1   2      1     2     1       2     1     4     1   3      1   2 3
--R     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
--R     18         24          12            72          48         48
--R   + 
--R        1      5      1    7
--R     - --- (2 1 ) + ---- (1 )
--R       240          5040
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 5

--S 6 of 47
alternating 7
--R 
--R
--R   (6)
--R     2       1     2    1           1   2      1     2     1     4     1   2 3
--R     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
--R     7       5          4           9         12          36          24
--R   + 
--R       1    7
--R     ---- (1 )
--R     2520
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 6

--S 7 of 47
cyclic 7
--R 
--R
--R        6       1   7
--R   (7)  - (7) + - (1 )
--R        7       7
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 7

--S 8 of 47
dihedral 7
--R 
--R
--R        3       1   3      1   7
--R   (8)  - (7) + - (2 1) + -- (1 )
--R        7       2         14
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 8

--S 9 of 47
graphs 5
--R 
--R
--R   (9)
--R   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
--R   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
--R   6           5        4         6         8          12          120
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 9

--S 10 of 47
cap(complete 2**2, complete 2*complete 1**2)
--R 
--R
--R   (10)  4
--R                                                       Type: Fraction Integer
--E 10

--S 11 of 47
cap(elementary 2**2, complete 2*complete 1**2)
--R 
--R
--R   (11)  2
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 47
cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
--R 
--R
--R   (12)  24
--R                                                       Type: Fraction Integer
--E 12

--S 13 of 47
cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
--R 
--R
--R   (13)  8
--R                                                       Type: Fraction Integer
--E 13

--S 14 of 47
cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
--R 
--R
--R   (14)  8
--R                                                       Type: Fraction Integer
--E 14

--S 15 of 47
eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
--R 
--R
--R   (15)  1500
--R                                                       Type: Fraction Integer
--E 15

--S 16 of 47
square:=dihedral 4
--R 
--R
--R         1       3   2    1     2    1   4
--R   (16)  - (4) + - (2 ) + - (2 1 ) + - (1 )
--R         4       8        4          8
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 16

--S 17 of 47
cap(complete 2**2,square)
--R 
--R
--R   (17)  2
--R                                                       Type: Fraction Integer
--E 17

--S 18 of 47
cap(complete 3*complete 2**2,dihedral 7)
--R 
--R
--R   (18)  18
--R                                                       Type: Fraction Integer
--E 18

--S 19 of 47
cap(graphs 5,complete 7*complete 3)
--R 
--R
--R   (19)  4
--R                                                       Type: Fraction Integer
--E 19

--S 20 of 47
s(x) == powerSum(x)
--R 
--R                                                                   Type: Void
--E 20

--S 21 of 47
cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
--R 
--R   Compiling function s with type PositiveInteger -> 
--R      SymmetricPolynomial Fraction Integer 
--R
--R         1   2    1   2 2    3   4     1   8
--R   (21)  - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
--R         4        3          8        24
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 21

--S 22 of 47
cap(complete 4**2,cube)
--R 
--R
--R   (22)  7
--R                                                       Type: Fraction Integer
--E 22

--S 23 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
--R 
--R
--R   (23)  7
--R                                                       Type: Fraction Integer
--E 23

--S 24 of 47
cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
--R 
--R
--R   (24)  17
--R                                                       Type: Fraction Integer
--E 24

--S 25 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
--R 
--R
--R   (25)  10
--R                                                       Type: Fraction Integer
--E 25

--S 26 of 47
cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
--R 
--R
--R   (26)  23
--R                                                       Type: Fraction Integer
--E 26

--S 27 of 47
x: ULS(FRAC INT,'x,0) := 'x 
--R 
--R
--R   (27)  x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 27

--S 28 of 47
ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 28

--S 29 of 47
Integers: INT -> ULS(FRAC INT, 'x, 0) 
--R 
--R                                                                   Type: Void
--E 29

--S 30 of 47
ZeroOrOne n == 1+x**n
--R 
--R                                                                   Type: Void
--E 30

--S 31 of 47
ZeroOrOne 5 
--R 
--R   Compiling function ZeroOrOne with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5
--R   (31)  1 + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 31

--S 32 of 47
Integers n == 1/(1-x**n) 
--R 
--R                                                                   Type: Void
--E 32

--S 33 of 47
Integers 5 
--R 
--R   Compiling function Integers with type Integer -> 
--R      UnivariateLaurentSeries(Fraction Integer,x,0) 
--R
--R              5    10      11
--R   (33)  1 + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 33

--S 34 of 47
)expose EVALCYC
--R 
--I   EvaluateCycleIndicators is now explicitly exposed in frame frame0 
--E 34

--S 35 of 47
eval(ZeroOrOne, graphs 5) 
--R 
--R
--R                   2     3     4     5     6     7     8    9    10      11
--R   (34)  1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 35

--S 36 of 47
eval(ZeroOrOne,dihedral 8) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (35)  1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 36

--S 37 of 47
eval(Integers,complete 4) 
--R 
--R
--R   (36)
--R             2     3     4     5     6      7      8      9      10      11
--R   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 37

--S 38 of 47
eval(Integers,elementary 4)
--R 
--R
--R   (37)
--R      6    7     8     9     10     11     12      13      14      15      16
--R     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
--R   + 
--R        17
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 38

--S 39 of 47
eval(ZeroOrOne,cube) 
--R 
--R
--R                   2     3     4     5     6    7    8
--R   (38)  1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 39

--S 40 of 47
eval(Integers,cube) 
--R 
--R
--R   (39)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 40

--S 41 of 47
eval(Integers,graphs 5) 
--R 
--R
--R   (40)
--R               2     3      4      5      6       7       8       9       10
--R     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 41

--S 42 of 47
eval(ZeroOrOne ,graphs 15) 
--R 
--R
--R   (41)
--R               2     3      4      5      6       7       8        9        10
--R     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
--R   + 
--R        11
--R     O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 42

--S 43 of 47
cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
--R 
--R
--R   (42)  49958972383320
--R                                                       Type: Fraction Integer
--E 43

--S 44 of 47
sf3221:= SFunction [3,2,2,1] 
--R 
--R
--R   (43)
--R      1          1     2     1   2     1            1     4     1   2
--R     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
--R     12         12          16        12           24          36
--R   + 
--R      1   2 2     1     2      1       3     1     5     1    4     1   3 2
--R     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
--R     36          24           36            72          192        48
--R   + 
--R      1   2 4     1      6     1    8
--R     -- (2 1 ) - --- (2 1 ) + --- (1 )
--R     96          144          576
--R                                   Type: SymmetricPolynomial Fraction Integer
--E 44

--S 45 of 47
cap(sf3221,complete 2**4) 
--R 
--R
--R   (44)  3
--R                                                       Type: Fraction Integer
--E 45

--S 46 of 47
cap(sf3221, powerSum 1**8)
--R 
--R
--R   (45)  70
--R                                                       Type: Fraction Integer
--E 46

--S 47 of 47
eval(Integers, sf3221)
--R 
--R
--R   (46)
--R      9     10     11      12      13      14      15       16       17       18
--R     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x   + 294x
--R   + 
--R         19      20
--R     432x   + O(x  )
--R                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)
--E 47
)spool
)lisp (bye)
@
<<CycleIndicators.help>>=
====================================================================
CycleIndicators examples
====================================================================

This section is based upon the paper J. H. Redfield, ``The Theory of
Group-Reduced Distributions'', American J. Math.,49 (1927) 433-455,
and is an application of group theory to enumeration problems.  It is
a development of the work by P. A. MacMahon on the application of
symmetric functions and Hammond operators to combinatorial theory.

The theory is based upon the power sum symmetric functions s(i) which
are the sum of the i-th powers of the variables.  The cycle index of a
permutation is an expression that specifies the sizes of the cycles of
a permutation, and may be represented as a partition.  A partition of
a non-negative integer n is a collection of positive integers called
its parts whose sum is n.  For example, the partition (3^2 2 1^2) will
be used to represent s^2_3 s_2 s^2_1 and will indicate that the
permutation has two cycles of length 3, one of length 2 and two of
length 1.  The cycle index of a permutation group is the sum of the
cycle indices of its permutations divided by the number of
permutations.  The cycle indices of certain groups are provided.

The operation complete returns the cycle index of the symmetric group
of order n for argument n.  Alternatively, it is the n-th complete
homogeneous symmetric function expressed in terms of power sum
symmetric functions.

  complete 1
   (1)
                      Type: SymmetricPolynomial Fraction Integer

  complete 2
   1       1   2
   - (2) + - (1 )
   2       2
                      Type: SymmetricPolynomial Fraction Integer

  complete 3
   1       1         1   3
   - (3) + - (2 1) + - (1 )
   3       2         6
                      Type: SymmetricPolynomial Fraction Integer

  complete 7
     1       1          1          1     2     1         1            1     3
     - (7) + - (6 1) + -- (5 2) + -- (5 1 ) + -- (4 3) + - (4 2 1) + -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) + -- (3 2 1 ) + -- (3 1 ) + -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
      1      5      1    7
     --- (2 1 ) + ---- (1 )
     240          5040
                   Type: SymmetricPolynomial Fraction Integer

The operation elementary computes the n-th elementary symmetric
function for argument n.

  elementary 7
     1       1          1          1     2     1         1            1     3
     - (7) - - (6 1) - -- (5 2) + -- (5 1 ) - -- (4 3) + - (4 2 1) - -- (4 1 )
     7       6         10         10          12         8           24
   + 
      1   2      1     2     1       2     1     4     1   3      1   2 3
     -- (3 1) + -- (3 2 ) - -- (3 2 1 ) + -- (3 1 ) - -- (2 1) + -- (2 1 )
     18         24          12            72          48         48
   + 
        1      5      1    7
     - --- (2 1 ) + ---- (1 )
       240          5040
                  Type: SymmetricPolynomial Fraction Integer

The operation alternating returns the cycle index of the alternating 
group having an even number of even parts in each cycle partition.

  alternating 7
     2       1     2    1           1   2      1     2     1     4     1   2 3
     - (7) + - (5 1 ) + - (4 2 1) + - (3 1) + -- (3 2 ) + -- (3 1 ) + -- (2 1 )
     7       5          4           9         12          36          24
   + 
       1    7
     ---- (1 )
     2520
                  Type: SymmetricPolynomial Fraction Integer

The operation cyclic returns the cycle index of the cyclic group.

  cyclic 7
   6       1   7
   - (7) + - (1 )
   7       7
                  Type: SymmetricPolynomial Fraction Integer

The operation dihedral is the cycle index of the dihedral group.

  dihedral 7
   3       1   3      1   7
   - (7) + - (2 1) + -- (1 )
   7       2         14
                  Type: SymmetricPolynomial Fraction Integer

The operation graphs for argument n returns the cycle index of the
group of permutations on the edges of the complete graph with n nodes
induced by applying the symmetric group to the nodes.

  graphs 5
   1           1   2    1   2     1   3     1   4 2     1   3 4     1    10
   - (6 3 1) + - (5 ) + - (4 2) + - (3 1) + - (2 1 ) + -- (2 1 ) + --- (1  )
   6           5        4         6         8          12          120
                  Type: SymmetricPolynomial Fraction Integer

The cycle index of a direct product of two groups is the product of
the cycle indices of the groups.  Redfield provided two operations on
two cycle indices which will be called "cup" and "cap" here.  The cup
of two cycle indices is a kind of scalar product that combines
monomials for permutations with the same cycles.  The cap operation
provides the sum of the coefficients of the result of the cup
operation which will be an integer that enumerates what Redfield
called group-reduced distributions.

We can, for example, represent complete 2 * complete 2 as the set of
objects a a b b and complete 2 * complete 1 * complete 1 as c c d e.

This integer is the number of different sets of four pairs.

  cap(complete 2**2, complete 2*complete 1**2)
    4
                  Type: Fraction Integer

For example,
  a a b b     a a b b    a a b b   a a b b
  c c d e     c d c e    c e c d   d e c c

This integer is the number of different sets of four pairs no two
pairs being equal.

  cap(elementary 2**2, complete 2*complete 1**2)
    2
                  Type: Fraction Integer

For example,

  a a b b    a a b b
  c d c e    c e c d

In this case the configurations enumerated are easily constructed,
however the theory merely enumerates them providing little help in
actually constructing them.

Here are the number of 6-pairs, first from a a a b b c, second
from d d e e f g.

  cap(complete 3*complete 2*complete 1,complete 2**2*complete 1**2)
    24
                     Type: Fraction Integer

Here it is again, but with no equal pairs.

  cap(elementary 3*elementary 2*elementary 1,complete 2**2*complete 1**2)
    8
                     Type: Fraction Integer

  cap(complete 3*complete 2*complete 1,elementary 2**2*elementary 1**2)
    8
                     Type: Fraction Integer

The number of 6-triples, first from a a a b b c, second from
d d e e f g, third from h h i i j j.

  eval(cup(complete 3*complete 2*complete 1, cup(complete 2**2*complete 1**2,complete 2**3)))
    1500
                     Type: Fraction Integer

The cycle index of vertices of a square is dihedral 4.

  square:=dihedral 4
   1       3   2    1     2    1   4
   - (4) + - (2 ) + - (2 1 ) + - (1 )
   4       8        4          8
                     Type: SymmetricPolynomial Fraction Integer

The number of different squares with 2 red vertices and 2 blue vertices.

  cap(complete 2**2,square)
    2
                     Type: Fraction Integer

The number of necklaces with 3 red beads, 2 blue beads and 2 green beads.

  cap(complete 3*complete 2**2,dihedral 7)
    18
                     Type: Fraction Integer

The number of graphs with 5 nodes and 7 edges.

  cap(graphs 5,complete 7*complete 3)
    4
                     Type: Fraction Integer

The cycle index of rotations of vertices of a cube.

  s(x) == powerSum(x)
                     Type: Void

  cube:=(1/24)*(s 1**8+9*s 2**4 + 8*s 3**2*s 1**2+6*s 4**2)
   1   2    1   2 2    3   4     1   8
   - (4 ) + - (3 1 ) + - (2 ) + -- (1 )
   4        3          8        24
                     Type: SymmetricPolynomial Fraction Integer

The number of cubes with 4 red vertices and 4 blue vertices.

  cap(complete 4**2,cube)
    7
                     Type: Fraction Integer

The number of labeled graphs with degree sequence 2 2 2 1 1 with no 
loops or multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,elementary 2))
    7
                     Type: Fraction Integer

Again, but with loops allowed but not multiple edges.

  cap(complete 2**3*complete 1**2,wreath(elementary 4,complete 2))
    17
                     Type: Fraction Integer

Again, but with multiple edges allowed, but not loops

  cap(complete 2**3*complete 1**2,wreath(complete 4,elementary 2))
    10
                     Type: Fraction Integer

Again, but with both multiple edges and loops allowed

  cap(complete 2**3*complete 1**2,wreath(complete 4,complete 2))
    23
                     Type: Fraction Integer

Having constructed a cycle index for a configuration we are at liberty
to evaluate the s_i components any way we please.  For example we can
produce enumerating generating functions.  This is done by providing a
function f on an integer i to the value required of s_i, and then
evaluating eval(f, cycleindex).

  x: ULS(FRAC INT,'x,0) := 'x 
   x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

  ZeroOrOne: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

  Integers: INT -> ULS(FRAC INT, 'x, 0) 
                     Type: Void

For the integers 0 and 1, or two colors.

  ZeroOrOne n == 1+x**n
                     Type: Void

  ZeroOrOne 5 
         5
    1 + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

For the integers 0, 1, 2, ... we have this.

  Integers n == 1/(1-x**n) 
                     Type: Void

  Integers 5 
         5    10      11
    1 + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and n edges. 

Note that there is an eval function that takes two arguments. It has the 
signature:

  ((Integer -> D1),SymmetricPolynomial Fraction Integer) -> D1
    from EvaluateCycleIndicators D1 if D1 has ALGEBRA FRAC INT

This function is not normally exposed (it will not normally be considered
in the list of eval functions) as it is only useful for this particular
domain. To use it we ask that it be considered thus:

  )expose EVALCYC

and now we can use it:

  eval(ZeroOrOne, graphs 5) 
              2     3     4     5     6     7     8    9    10      11
    1 + x + 2x  + 4x  + 6x  + 6x  + 6x  + 4x  + 2x  + x  + x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of necklaces with n red beads 
and n-8 green beads.

  eval(ZeroOrOne,dihedral 8) 
              2     3     4     5     6    7    8
    1 + x + 4x  + 5x  + 8x  + 5x  + 4x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 or fewer parts.

  eval(Integers,complete 4) 
             2     3     4     5     6      7      8      9      10      11
   1 + x + 2x  + 3x  + 5x  + 6x  + 9x  + 11x  + 15x  + 18x  + 23x   + O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of partitions of n into 4 boxes
containing ordered distinct parts.

  eval(Integers,elementary 4)
      6    7     8     9     10     11     12      13      14      15      16
     x  + x  + 2x  + 3x  + 5x   + 6x   + 9x   + 11x   + 15x   + 18x   + 23x
   + 
        17
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with n red
vertices and 8-n green ones.

  eval(ZeroOrOne,cube) 
              2     3     4     5     6    7    8
    1 + x + 3x  + 3x  + 7x  + 3x  + 3x  + x  + x
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of different cubes with integers
on the vertices whose sum is n.

  eval(Integers,cube) 
               2     3      4      5      6       7       8       9       10
     1 + x + 4x  + 7x  + 21x  + 37x  + 85x  + 151x  + 292x  + 490x  + 848x
   + 
        11
     O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The coefficient of x^n is the number of graphs with 5 nodes and with
integers on the edges whose sum is n.  In other words, the enumeration
is of multigraphs with 5 nodes and n edges.

  eval(Integers,graphs 5) 
               2     3      4      5      6       7       8       9       10
     1 + x + 3x  + 7x  + 17x  + 35x  + 76x  + 149x  + 291x  + 539x  + 974x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Graphs with 15 nodes enumerated with respect to number of edges.

  eval(ZeroOrOne ,graphs 15) 
               2     3      4      5      6       7       8        9        10
     1 + x + 2x  + 5x  + 11x  + 26x  + 68x  + 177x  + 496x  + 1471x  + 4583x
   + 
        11
     O(x  )
                     Type: UnivariateLaurentSeries(Fraction Integer,x,0)

Necklaces with 7 green beads, 8 white beads, 5 yellow beads and 10
red beads.

  cap(dihedral 30,complete 7*complete 8*complete 5*complete 10)
    49958972383320
                     Type: Fraction Integer

The operation SFunction is the S-function or Schur function of a
partition written as a descending list of integers expressed in terms
of power sum symmetric functions.

In this case the argument partition represents a tableau shape.  For
example 3,2,2,1 represents a tableau with three boxes in the first
row, two boxes in the second and third rows, and one box in the fourth
row.  SFunction [3,2,2,1] counts the number of different tableaux of
shape 3, 2, 2, 1 filled with objects with an ascending order in the
columns and a non-descending order in the rows.

  sf3221:= SFunction [3,2,2,1] 
      1          1     2     1   2     1            1     4     1   2
     -- (6 2) - -- (6 1 ) - -- (4 ) + -- (4 3 1) + -- (4 1 ) - -- (3 2)
     12         12          16        12           24          36
   + 
      1   2 2     1     2      1       3     1     5     1    4     1   3 2
     -- (3 1 ) - -- (3 2 1) - -- (3 2 1 ) - -- (3 1 ) - --- (2 ) + -- (2 1 )
     36          24           36            72          192        48
   + 
      1   2 4     1      6     1    8
     -- (2 1 ) - --- (2 1 ) + --- (1 )
     96          144          576
                     Type: SymmetricPolynomial Fraction Integer

This is the number filled with a a b b c c d d.

  cap(sf3221,complete 2**4) 
    3
                     Type: Fraction Integer

The configurations enumerated above are:

  a a b    a a c    a a d
  b c      b b      b b
  c d      c d      c c
  d        d        d

This is the number of tableaux filled with 1..8.

  cap(sf3221, powerSum 1**8)
    70
                     Type: Fraction Integer

The coefficient of x^n is the number of column strict reverse plane
partitions of n of shape 3 2 2 1.

  eval(Integers, sf3221)
      9     10     11      12      13      14      15       16       17
     x  + 3x   + 7x   + 14x   + 27x   + 47x   + 79x   + 126x   + 196x  
   + 
        18      19      20
    294x  + 432x   + O(x  )
                          Type: UnivariateLaurentSeries(Fraction Integer,x,0)

The smallest is

  0 0 0
  1 1
  2 2
  3

See Also:
o )show CycleIndicators
o $AXIOM/doc/src/algebra/cycles.spad.dvi

@
\pagehead{CycleIndicators}{CYCLES}
\pagepic{ps/v104cycleindicators.ps}{CYCLES}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CYCLES CycleIndicators>>=
)abbrev package CYCLES CycleIndicators
++ Polya-Redfield enumeration by cycle indices.
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: 11 Feb 1992
++ Keywords:Polya, Redfield, enumeration
++ Examples:
++ References: J.H.Redfield, 'The Theory of Group-Reduced Distributions',
++             American J. Math., 49 (1927) 433-455.
++             G.Polya, 'Kombinatorische Anzahlbestimmungen fur Gruppen,
++               Graphen und chemische Verbindungen', Acta Math. 68
++                (1937) 145-254.
++ Description: Enumeration by cycle indices. 
CycleIndicators: Exports == Implementation where
  I    ==> Integer
  L    ==> List
  B    ==> Boolean
  SPOL ==> SymmetricPolynomial
  PTN  ==> Partition
  RN   ==> Fraction Integer
  FR   ==> Factored Integer
  h ==> complete
  s ==> powerSum
  --a ==> elementary
  alt ==> alternating
  cyc ==> cyclic
  dih ==> dihedral
  ev == eval
  Exports ==> with
 
    complete: I -> SPOL RN
      ++\spad{complete n} is the \spad{n} th complete homogeneous
      ++ symmetric function expressed in terms of power sums.
      ++ Alternatively it is the cycle index of the symmetric
      ++ group of degree n.
 
    powerSum: I -> SPOL RN
      ++\spad{powerSum n} is the \spad{n} th power sum symmetric
      ++ function.
 
    elementary: I -> SPOL RN
      ++\spad{elementary n} is the \spad{n} th elementary symmetric
      ++ function expressed in terms of power sums.
 
 -- s2h: I -> SPOL RN--s to h
 
    alternating: I -> SPOL RN
      ++\spad{alternating n} is the cycle index of the
      ++ alternating group of degree n.
 
    cyclic: I -> SPOL RN    --cyclic group
      ++\spad{cyclic n} is the cycle index of the
      ++ cyclic group of degree n.
 
    dihedral: I -> SPOL RN    --dihedral group
      ++\spad{dihedral n} is the cycle index of the
      ++ dihedral group of degree n.
 
    graphs: I -> SPOL RN
      ++\spad{graphs n} is the cycle index of the group induced on
      ++ the edges of a graph by applying the symmetric function to the
      ++ n nodes.
 
    cap: (SPOL RN,SPOL RN) -> RN
      ++\spad{cap(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices.
 
    cup: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{cup(s1,s2)}, introduced by Redfield,
      ++ is the scalar product of two cycle indices, in which the
      ++ power sums are retained to produce a cycle index.
 
    eval: SPOL RN -> RN
      ++\spad{eval s} is the sum of the coefficients of a cycle index.
 
    wreath: (SPOL RN,SPOL RN) -> SPOL RN
      ++\spad{wreath(s1,s2)} is the cycle index of the wreath product
      ++ of the two groups whose cycle indices are \spad{s1} and
      ++ \spad{s2}.
 
    SFunction:L I -> SPOL RN
      ++\spad{SFunction(li)} is the S-function of the partition \spad{li}
      ++ expressed in terms of power sum symmetric functions.
 
    skewSFunction:(L I,L I) -> SPOL RN
      ++\spad{skewSFunction(li1,li2)} is the S-function
      ++ of the partition difference \spad{li1 - li2}
      ++ expressed in terms of power sum symmetric functions.
 
  Implementation ==> add
    import PartitionsAndPermutations
    import IntegerNumberTheoryFunctions
 
    trm: PTN -> SPOL RN
    trm pt == monomial(inv(pdct(pt) :: RN),pt)
 
    list: Stream L I -> L L I
    list st == entries complete st
 
    complete i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                   _+/[trm(partition pt) for pt in list(partitions i)]
 
 
    even?: L I -> B
    even? li == even?( #([i for i in li | even? i]))
 
    alt i ==
      2 * _+/[trm(partition li) for li in list(partitions i) | even? li]
    elementary i ==
           if i=0
           then 1
           else if i<0
                then 0
                else
                  _+/[(spol := trm(partition pt); even? pt => spol; -spol)
                          for pt in list(partitions i)]
 
    divisors: I -> L I
    divisors n ==
      b := factors(n :: FR)
      c := concat(1,"append"/
                 [[a.factor**j for j in 1..a.exponent] for a in b]);
      if #(b) = 1 then c else concat(n,c)
 
    ss: (I,I) -> SPOL RN
    ss(n,m) ==
      li : L I := [n for j in 1..m]
      monomial(1,partition li)
 
    s n == ss(n,1)
 
    cyc n ==
      n = 1 => s 1
      _+/[(eulerPhi(i) / n) * ss(i,numer(n/i)) for i in divisors n]
 
    dih n ==
      k := n quo 2
      odd? n => (1/2) * cyc n + (1/2) * ss(2,k) * s 1
      (1/2) * cyc n + (1/4) * ss(2,k) + (1/4) * ss(2,k-1) * ss(1,2)
 
    trm2: L I -> SPOL RN
    trm2 li ==
      lli := powers(li)$PTN
      xx := 1/(pdct partition li)
      prod : SPOL RN := 1
      for ll in lli repeat
        ll0 := first ll; ll1 := second ll
        k := ll0 quo 2
        c :=
          odd? ll0 => ss(ll0,ll1 * k)
          ss(k,ll1) * ss(ll0,ll1 * (k - 1))
        c := c * ss(ll0,ll0 * ((ll1*(ll1 - 1)) quo 2))
        prod2 : SPOL RN := 1
        for r in lli | first(r) < ll0 repeat
          r0 := first r; r1 := second r
          prod2 := ss(lcm(r0,ll0),gcd(r0,ll0) * r1 * ll1) * prod2
        prod := c * prod2 * prod
      xx * prod
 
    graphs n == _+/[trm2 li for li in list(partitions n)]
 
    cupp: (PTN,SPOL RN) -> SPOL RN
    cupp(pt,spol) ==
      zero? spol => 0
      (dg := degree spol) < pt => 0
      dg = pt => (pdct pt) * monomial(leadingCoefficient spol,dg)
      cupp(pt,reductum spol)
 
    cup(spol1,spol2) ==
      zero? spol1 => 0
      p := leadingCoefficient(spol1) * cupp(degree spol1,spol2)
      p + cup(reductum spol1,spol2)
 
    ev spol ==
      zero? spol => 0
      leadingCoefficient(spol) + ev(reductum spol)
 
    cap(spol1,spol2) == ev cup(spol1,spol2)
 
    mtpol: (I,SPOL RN) -> SPOL RN
    mtpol(n,spol)==
      zero? spol => 0
      deg := partition [n*k for k in (degree spol)::L(I)]
      monomial(leadingCoefficient spol,deg) + mtpol(n,reductum spol)
 
    fn2: I -> SPOL RN
    evspol: ((I -> SPOL RN),SPOL RN) -> SPOL RN
    evspol(fn2,spol) ==
      zero? spol => 0
      lc := leadingCoefficient spol
      prod := _*/[fn2 i for i in (degree spol)::L(I)]
      lc * prod + evspol(fn2,reductum spol)
 
    wreath(spol1,spol2) == evspol(mtpol(#1,spol2),spol1)
 
    hh: I -> SPOL RN      --symmetric group
    hh n == if n=0 then 1 else if n<0 then 0 else h n
    SFunction li==
      a:Matrix SPOL RN:=matrix [[hh(k -j+i) for k in li for j in 1..#li]
                    for i in 1..#li]
      determinant a
 
    roundup:(L I,L I)-> L I
    roundup(li1,li2)==
              #li1 > #li2 => roundup(li1,concat(li2,0))
              li2
 
    skewSFunction(li1,li2)==
      #li1 < #li2 =>
        error "skewSFunction: partition1 does not include partition2"
      li2:=roundup (li1,li2)
      a:Matrix SPOL RN:=matrix [[hh(k-li2.i-j+i)
               for k in li1 for j in 1..#li1]  for i in 1..#li1]
      determinant a

@
<<CYCLES.dotabb>>=
"CYCLES" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CYCLES"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CYCLES" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CYCLOTOM CyclotomicPolynomialPackage}
\pagehead{CyclotomicPolynomialPackage}{CYCLOTOM}
\pagepic{ps/v104cyclotomicpolynomialpackage.ps}{CYCLOTOM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CYCLOTOM CyclotomicPolynomialPackage>>=
)abbrev package CYCLOTOM CyclotomicPolynomialPackage
++ This package \undocumented{} 
CyclotomicPolynomialPackage: public == private where
  SUP  ==> SparseUnivariatePolynomial(Integer)
  LSUP ==> List(SUP)
  NNI  ==> NonNegativeInteger
  FR   ==> Factored SUP
  IFP  ==> IntegerFactorizationPackage Integer
 
  public == with
    cyclotomicDecomposition: Integer -> LSUP
	++ cyclotomicDecomposition(n) \undocumented{}
    cyclotomic:              Integer -> SUP
	++ cyclotomic(n) \undocumented{}
    cyclotomicFactorization: Integer -> FR
	++ cyclotomicFactorization(n) \undocumented{}
 
  private == add
    cyclotomic(n:Integer): SUP ==
      x,y,z,l: SUP
      g := factors factor(n)$IFP
      --Now, for each prime in the factorization apply recursion
      l := monomial(1,1) - monomial(1,0)
      for u in g repeat
         l := (monicDivide(multiplyExponents(l,u.factor::NNI),l)).quotient
         if u.exponent>1 then
            l := multiplyExponents(l,((u.factor)**((u.exponent-1)::NNI))::NNI)
      l
 
    cyclotomicDecomposition(n:Integer):LSUP ==
      x,y,z: SUP
      l,ll,m: LSUP
      rr: Integer
      g := factors factor(n)$IFP
      l := [monomial(1,1) - monomial(1,0)]
      --Now, for each prime in the factorization apply recursion
      for u in g repeat
         m := [(monicDivide(
            multiplyExponents(z,u.factor::NNI),z)).quotient for z in l]
         for rr in 1..(u.exponent-1) repeat
            l := append(l,m)
            m := [multiplyExponents(z,u.factor::NNI) for z in m]
         l := append(l,m)
      l
 
    cyclotomicFactorization(n:Integer):FR ==
      f :  SUP
      fr : FR := 1$FR
      for f in cyclotomicDecomposition(n) repeat
        fr := fr * primeFactor(f,1$Integer)
      fr

@
<<CYCLOTOM.dotabb>>=
"CYCLOTOM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CYCLOTOM"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"CYCLOTOM" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DFINTTLS DefiniteIntegrationTools}
\pagehead{DefiniteIntegrationTools}{DFINTTLS}
\pagepic{ps/v104definiteintegrationtools.ps}{DFINTTLS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DFINTTLS DefiniteIntegrationTools>>=
)abbrev package DFINTTLS DefiniteIntegrationTools
++ Tools for definite integration
++ Author: Manuel Bronstein
++ Date Created: 15 April 1992
++ Date Last Updated: 24 February 1993
++ Description:
++   \spadtype{DefiniteIntegrationTools} provides common tools used
++   by the definite integration of both rational and elementary functions.
DefiniteIntegrationTools(R, F): Exports == Implementation where
  R : Join(GcdDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)

  B   ==> Boolean
  Z   ==> Integer
  Q   ==> Fraction Z
  SE  ==> Symbol
  P   ==> Polynomial R
  RF  ==> Fraction P
  UP  ==> SparseUnivariatePolynomial F
  K   ==> Kernel F
  OFE ==> OrderedCompletion F
  UPZ ==> SparseUnivariatePolynomial Z
  UPQ ==> SparseUnivariatePolynomial Q
  REC ==> Record(left:Q, right:Q)
  REC2==> Record(endpoint:Q, dir:Z)
  U   ==> Union(fin:REC, halfinf:REC2, all:"all", failed:"failed")
  IGNOR ==> "noPole"

  Exports ==> with
    ignore?: String -> B
      ++ ignore?(s) is true if s is the string that tells the integrator
      ++ to assume that the function has no pole in the integration interval.
    computeInt: (K, F, OFE, OFE, B) -> Union(OFE, "failed")
      ++ computeInt(x, g, a, b, eval?) returns the integral of \spad{f} for x
      ++ between a and b, assuming that g is an indefinite integral of
      ++ \spad{f} and \spad{f} has no pole between a and b.
      ++ If \spad{eval?} is true, then \spad{g} can be evaluated safely
      ++ at \spad{a} and \spad{b}, provided that they are finite values.
      ++ Otherwise, limits must be computed.
    checkForZero: (P,  SE, OFE, OFE, B) -> Union(B, "failed")
      ++ checkForZero(p, x, a, b, incl?) is true if p has a zero for x between
      ++ a and b, false otherwise, "failed" if this cannot be determined.
      ++ Check for a and b inclusive if incl? is true, exclusive otherwise.
    checkForZero: (UP, OFE, OFE, B) -> Union(B, "failed")
      ++ checkForZero(p, a, b, incl?) is true if p has a zero between
      ++ a and b, false otherwise, "failed" if this cannot be determined.
      ++ Check for a and b inclusive if incl? is true, exclusive otherwise.

  Implementation ==> add
    import RealZeroPackage UPZ
    import InnerPolySign(F, UP)
    import ElementaryFunctionSign(R, F)
    import PowerSeriesLimitPackage(R, F)
    import UnivariatePolynomialCommonDenominator(Z, Q, UPQ)

    mkLogPos    : F -> F
    keeprec?    : (Q, REC) -> B
    negative    : F -> Union(B, "failed")
    mkKerPos    : K -> Union(F, "positive")
    posRoot     : (UP, B) -> Union(B, "failed")
    realRoot    : UP -> Union(B, "failed")
    var         : UP -> Union(Z, "failed")
    maprat      : UP -> Union(UPZ, "failed")
    variation   : (UP, F) -> Union(Z, "failed")
    infeval     : (UP, OFE) -> Union(F, "failed")
    checkHalfAx : (UP, F, Z, B) -> Union(B, "failed")
    findLimit   : (F, K, OFE, String, B) -> Union(OFE, "failed")
    checkBudan  : (UP, OFE, OFE, B) -> Union(B, "failed")
    checkDeriv  : (UP, OFE, OFE) -> Union(B, "failed")
    sameSign    : (UP, OFE, OFE) -> Union(B, "failed")
    intrat      : (OFE, OFE) -> U
    findRealZero: (UPZ, U, B) -> List REC

    variation(p, a)      == var p(monomial(1, 1)$UP - a::UP)
    keeprec?(a, rec)     == (a > rec.right) or (a < rec.left)

    checkHalfAx(p, a, d, incl?) ==
      posRoot(p(d * (monomial(1, 1)$UP - a::UP)), incl?)

    ignore? str ==
      str = IGNOR => true
      error "integrate: last argument must be 'noPole'"

    computeInt(k, f, a, b, eval?) ==
      is?(f, "integral"::SE) => "failed"
      if not eval? then f := mkLogPos f
      ((ib := findLimit(f, k, b, "left", eval?)) case "failed") or
          ((ia := findLimit(f, k, a, "right", eval?)) case "failed") => "failed"
      infinite?(ia::OFE) and (ia::OFE = ib::OFE) => "failed"
      ib::OFE - ia::OFE

    findLimit(f, k, a, dir, eval?) ==
      r := retractIfCan(a)@Union(F, "failed")
      r case F =>
        eval? => mkLogPos(eval(f, k, r::F))::OFE
        (u := limit(f, equation(k::F, r::F), dir)) case OFE => u::OFE
        "failed"
      (u := limit(f, equation(k::F::OFE, a))) case OFE => u::OFE
      "failed"

    mkLogPos f ==
      lk := empty()$List(K)
      lv := empty()$List(F)
      for k in kernels f | is?(k, "log"::SE) repeat
        if (v := mkKerPos k) case F then
          lk := concat(k, lk)
          lv := concat(v::F, lv)
      eval(f, lk, lv)

    mkKerPos k ==
      (u := negative(f := first argument k)) case "failed" =>
                                                     log(f**2) / (2::F)
      u::B => log(-f)
      "positive"

    negative f ==
      (u := sign f) case "failed" => "failed"
      u::Z < 0

    checkForZero(p, x, a, b, incl?) ==
      checkForZero(
        map(#1::F, univariate(p, x))$SparseUnivariatePolynomialFunctions2(P, F),
            a, b, incl?)

    checkForZero(q, a, b, incl?) ==
      ground? q => false
      (d := maprat q) case UPZ and not((i := intrat(a, b)) case failed) =>
          not empty? findRealZero(d::UPZ, i, incl?)
      (u := checkBudan(q, a, b, incl?)) case "failed" =>
         incl? => checkDeriv(q, a, b)
         "failed"
      u::B

    maprat p ==
      ans:UPQ := 0
      while p ^= 0 repeat
        (r := retractIfCan(c := leadingCoefficient p)@Union(Q,"failed"))
          case "failed"  => return "failed"
        ans := ans + monomial(r::Q, degree p)
        p   := reductum p
      map(numer,(splitDenominator ans).num
         )$SparseUnivariatePolynomialFunctions2(Q, Z)

    intrat(a, b) ==
      (n := whatInfinity a) ^= 0 =>
        (r := retractIfCan(b)@Union(F,"failed")) case "failed" => ["all"]
        (q := retractIfCan(r::F)@Union(Q, "failed")) case "failed" =>
          ["failed"]
        [[q::Q, n]]
      (q := retractIfCan(retract(a)@F)@Union(Q,"failed")) case "failed"
        => ["failed"]
      (n := whatInfinity b) ^= 0 => [[q::Q, n]]
      (t := retractIfCan(retract(b)@F)@Union(Q,"failed")) case "failed"
        => ["failed"]
      [[q::Q, t::Q]]

    findRealZero(p, i, incl?) ==
      i case fin =>
        l := realZeros(p, r := i.fin)
        incl? => l
        select_!(keeprec?(r.left, #1) and keeprec?(r.right, #1), l)
      i case all => realZeros p
      i case halfinf =>
        empty?(l := realZeros p) => empty()
        bounds:REC :=
          i.halfinf.dir > 0 => [i.halfinf.endpoint, "max"/[t.right for t in l]]
          ["min"/[t.left for t in l], i.halfinf.endpoint]
        l := [u::REC for t in l | (u := refine(p, t, bounds)) case REC]
        incl? => l
        select_!(keeprec?(i.halfinf.endpoint, #1), l)
      error "findRealZero: should not happpen"

    checkBudan(p, a, b, incl?) ==
      r := retractIfCan(b)@Union(F, "failed")
      (n := whatInfinity a) ^= 0 =>
        r case "failed" => realRoot p
        checkHalfAx(p, r::F, n, incl?)
      (za? := zero? p(aa := retract(a)@F)) and incl? => true
      (n := whatInfinity b) ^= 0 => checkHalfAx(p, aa, n, incl?)
      (zb? := zero? p(bb := r::F)) and incl? => true
      (va := variation(p, aa)) case "failed" or
                   (vb := variation(p, bb)) case "failed" => "failed"
      m:Z := 0
      if za? then m := inc m
      if zb? then m := inc m
      odd?(v := va::Z - vb::Z) =>          -- p has an odd number of roots
        incl? or even? m => true
--        one? v => false
        (v = 1) => false
        "failed"
      zero? v => false                     -- p has no roots
--      one? m => true                    -- p has an even number > 0 of roots
      (m = 1) => true                     -- p has an even number > 0 of roots
      "failed"

    checkDeriv(p, a, b) ==
      (r := retractIfCan(p)@Union(F, "failed")) case F => zero?(r::F)
      (s := sameSign(p, a, b)) case "failed" => "failed"
      s::B =>                  -- p has the same nonzero sign at a and b
        (u := checkDeriv(differentiate p,a,b)) case "failed" => "failed"
        u::B => "failed"
        false
      true

    realRoot p ==
      (b := posRoot(p, true)) case "failed" => "failed"
      b::B => true
      posRoot(p(p - monomial(1, 1)$UP), true)

    sameSign(p, a, b) ==
      (ea := infeval(p, a)) case "failed" => "failed"
      (eb := infeval(p, b)) case "failed" => "failed"
      (s := sign(ea::F * eb::F)) case "failed" => "failed"
      s::Z > 0

-- returns true if p has a positive root. Include 0 is incl0? is true
    posRoot(p, incl0?) ==
      (z0? := zero?(coefficient(p, 0))) and incl0? => true
      (v := var p) case "failed" => "failed"
      odd?(v::Z) =>            -- p has an odd number of positive roots
        incl0? or not(z0?) => true
--        one?(v::Z) => false
        (v::Z) = 1 => false
        "failed"
      zero?(v::Z) => false     -- p has no positive roots
      z0? => true              -- p has an even number > 0 of positive roots
      "failed"

    infeval(p, a) ==
      zero?(n := whatInfinity a) => p(retract(a)@F)
      (u := signAround(p, n, sign)) case "failed" => "failed"
      u::Z::F

    var q ==
      i:Z := 0
      (lastCoef := negative leadingCoefficient q) case "failed" =>
        "failed"
      while ((q := reductum q) ^= 0) repeat
        (next := negative leadingCoefficient q) case "failed" =>
          return "failed"
        if ((not(lastCoef::B)) and next::B) or
                        ((not(next::B)) and lastCoef::B) then i := i + 1
        lastCoef := next
      i

@
<<DFINTTLS.dotabb>>=
"DFINTTLS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DFINTTLS"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DFINTTLS" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEGRED DegreeReductionPackage}
\pagehead{DegreeReductionPackage}{DEGRED}
\pagepic{ps/v104degreereductionpackage.ps}{DEGRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEGRED DegreeReductionPackage>>=
)abbrev package DEGRED DegreeReductionPackage
++ This package \undocumented{}
DegreeReductionPackage(R1, R2): Cat == Capsule where
    R1: Ring
    R2: Join(IntegralDomain,OrderedSet)
 
    I    ==> Integer
    PI   ==> PositiveInteger
    UP   ==> SparseUnivariatePolynomial
    RE   ==> Expression R2
 
    Cat == with
        reduce:  UP R1    ->  Record(pol: UP R1, deg: PI)
	 	++ reduce(p) \undocumented{}
        expand:  (RE, PI) ->  List RE
		++ expand(f,n) \undocumented{}
 
    Capsule == add
 
 
        degrees(u: UP R1): List Integer ==
            l: List Integer := []
            while u ^= 0 repeat
              l := concat(degree u,l)
              u := reductum u
            l
        reduce(u: UP R1) ==
            g := "gcd"/[d for d in degrees u]
            u := divideExponents(u, g:PI)::(UP R1)
            [u, g:PI]
 
        import Fraction Integer
 
        rootOfUnity(j:I,n:I):RE ==
            j = 0 => 1
            arg:RE := 2*j*pi()/(n::RE)
            cos arg + (-1)**(1/2) * sin arg
 
        expand(s, g) ==
            g = 1 => [s]
            [rootOfUnity(i,g)*s**(1/g) for i in 0..g-1]

@
<<DEGRED.dotabb>>=
"DEGRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEGRED"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"DEGRED" -> "PID"
"DEGRED" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DLP DiscreteLogarithmPackage}
\pagehead{DiscreteLogarithmPackage}{DLP}
\pagepic{ps/v104discretelogarithmpackage.ps}{DLP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DLP DiscreteLogarithmPackage>>=
)abbrev package DLP DiscreteLogarithmPackage
++ Author: J. Grabmeier, A. Scheerhorn
++ Date Created: 12 March 1991
++ Date Last Updated: 31 March 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: discrete logarithm
++ References:
++  J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
++  AXIOM Technical Report Series, ATR/5 NP2522.
++ Description:
++  DiscreteLogarithmPackage implements help functions for discrete logarithms
++  in monoids using small cyclic groups.

DiscreteLogarithmPackage(M): public == private where
  M : Join(Monoid,Finite) with
   "**": (M,Integer) -> M
	++ x ** n returns x raised to the integer power n
  public ==> with
    shanksDiscLogAlgorithm:(M,M,NonNegativeInteger)->  _
        Union(NonNegativeInteger,"failed")
      ++ shanksDiscLogAlgorithm(b,a,p) computes s with \spad{b**s = a} for
      ++ assuming that \spad{a} and b are elements in a 'small' cyclic group of
      ++ order p by Shank's algorithm.
      ++ Note: this is a subroutine of the function \spadfun{discreteLog}.
  I   ==> Integer
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  SUP ==> SparseUnivariatePolynomial
  DLP ==> DiscreteLogarithmPackage

  private ==> add
    shanksDiscLogAlgorithm(logbase,c,p) ==
      limit:Integer:= 30
      -- for logarithms up to cyclic groups of order limit a full
      -- logarithm table is computed
      p < limit =>
        a:M:=1
        disclog:Integer:=0
        found:Boolean:=false
        for i in 0..p-1 while not found repeat
          a = c =>
            disclog:=i
            found:=true
          a:=a*logbase
        not found =>
          messagePrint("discreteLog: second argument not in cyclic group_
 generated by first argument")$OutputForm
          "failed"
        disclog pretend NonNegativeInteger
      l:Integer:=length(p)$Integer
      if odd?(l)$Integer then n:Integer:= shift(p,-(l quo 2))
                         else n:Integer:= shift(1,(l quo 2))
      a:M:=1
      exptable : Table(PI,NNI) :=table()$Table(PI,NNI)
      for i in (0::NNI)..(n-1)::NNI repeat
        insert_!([lookup(a),i::NNI]$Record(key:PI,entry:NNI),_
                  exptable)$Table(PI,NNI)
        a:=a*logbase
      found := false
      end := (p-1) quo n
      disclog:Integer:=0
      a := c
      b := logbase ** (-n)
      for i in 0..end while not found repeat
        rho:= search(lookup(a),exptable)_
              $Table(PositiveInteger,NNI)
        rho case NNI =>
          found := true
          disclog:= n * i + rho pretend Integer
        a := a * b
      not found =>
        messagePrint("discreteLog: second argument not in cyclic group_
 generated by first argument")$OutputForm
        "failed"
      disclog pretend NonNegativeInteger

@
<<DLP.dotabb>>=
"DLP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DLP"]
"OAMONS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAMONS"]
"DLP" -> "OAMONS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DISPLAY DisplayPackage}
\pagehead{DisplayPackage}{DISPLAY}
\pagepic{ps/v104displaypackage.ps}{DISPLAY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DISPLAY DisplayPackage>>=
)abbrev package DISPLAY DisplayPackage
++ Author: Robert S. Sutor
++ Date Created: September 1986
++ Date Last Updated:
++ Basic Operations: bright, newLine, copies, center, say, sayLength
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: DisplayPackage allows one to print strings in a nice manner,
++ including highlighting substrings.

DisplayPackage: public == private where
  I       ==> Integer
  L       ==> List
  S       ==> String
  RECLR   ==> Record(lhs : S, rhs : S)

  public  == with
    bright:       S           -> L S
      ++ bright(s) sets the font property of the string s to bold-face type.
    bright:       L S         -> L S
      ++ bright(l) sets the font property of a list of strings, l, to
      ++ bold-face type.
    newLine:      ()          -> S
      ++ newLine() sends a new line command to output.

    copies:       (I,S)       -> S
      ++ copies(i,s) will take a string s and create a new string composed of
      ++ i copies of s.
    center:       (S,I,S)     -> S
      ++ center(s,i,s) takes the first string s, and centers it within a string
      ++ of length i, in which the other elements of the string are composed
      ++ of as many replications as possible of the second indicated string, s
      ++ which must have a length greater than that of an empty string.
    center:       (L S,I,S)   -> L S
      ++ center(l,i,s) takes a list of strings l, and centers them within a
      ++ list of strings which is i characters long, in which the remaining
      ++ spaces are filled with strings composed of as many repetitions as
      ++ possible of the last string parameter s.

    say:          S           -> Void
      ++ say(s) sends a string s to output.
    say:          L S         -> Void
      ++ say(l) sends a list of strings l to output.
    sayLength:    S           -> I
      ++ sayLength(s) returns the length of a string s as an integer.
    sayLength:    L S         -> I
      ++ sayLength(l) returns the length of a list of strings l as an integer.

  private == add
    --StringManipulations()

    center0:  (I,I,S) -> RECLR

    s : S
    l : L S

    HION    : S := "%b"
    HIOFF   : S := "%d"
    NEWLINE : S := "%l"

    bright s == [HION,s,HIOFF]$(L S)
    bright l == cons(HION,append(l,list HIOFF))
    newLine() == NEWLINE

    copies(n : I, s : S) ==
      n < 1 => ""
      n = 1 => s
      t : S := copies(n quo 2, s)
      odd? n => concat [s,t,t]
      concat [t,t]

    center0(len : I, wid : I, fill : S) : RECLR ==
      (wid < 1) or (len >= wid) => ["",""]$RECLR
      m : I := (wid - len) quo 2
      t : S := copies(1 + (m quo (sayLength fill)),fill)
      [t(1..m),t(1..wid-len-m)]$RECLR

    center(s, wid, fill) ==
      wid < 1 => ""
      len : I := sayLength s
      len = wid => s
      len > wid => s(1..wid)
      rec : RECLR := center0(len,wid,fill)
      concat [rec.lhs,s,rec.rhs]

    center(l, wid, fill) ==
      wid < 1 => [""]$(L S)
      len : I := sayLength l
      len = wid => l
--    len > wid => s(1..wid)
      rec : RECLR := center0(len,wid,fill)
      cons(rec.lhs,append(l,list rec.rhs))

    say s ==
      sayBrightly$Lisp s
      void()$Void

    say l ==
      sayBrightly$Lisp l
      void()$Void

    sayLength s == #s

    sayLength l ==
      sum : I := 0
      for s in l repeat
        s = HION      => sum := sum + 1
        s = HIOFF     => sum := sum + 1
        s = NEWLINE   => sum
        sum := sum + sayLength s
      sum

@
<<DISPLAY.dotabb>>=
"DISPLAY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DISPLAY"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"DISPLAY" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DDFACT DistinctDegreeFactorize}
\pagehead{DistinctDegreeFactorize}{DDFACT}
\pagepic{ps/v104distinctdegreefactorize.ps}{DDFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DDFACT DistinctDegreeFactorize>>=
)abbrev package DDFACT DistinctDegreeFactorize
++ Author: P. Gianni, B.Trager
++ Date Created: 1983
++ Date Last Updated: 22 November 1993
++ Basic Functions: factor, irreducible?
++ Related Constructors: PrimeField, FiniteField
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   Package for the factorization of a univariate polynomial with
++   coefficients in a finite field. The algorithm used is the
++   "distinct degree" algorithm of Cantor-Zassenhaus, modified
++   to use trace instead of the norm and a table for computing
++   Frobenius as suggested by Naudin and Quitte .
    
DistinctDegreeFactorize(F,FP): C == T
  where
   F  : FiniteFieldCategory
   FP : UnivariatePolynomialCategory(F)
 
   fUnion ==> Union("nil", "sqfr", "irred", "prime")
   FFE    ==> Record(flg:fUnion, fctr:FP, xpnt:Integer)
   NNI       == NonNegativeInteger
   Z         == Integer
   fact      == Record(deg : NNI,prod : FP)
   ParFact   == Record(irr:FP,pow:Z)
   FinalFact == Record(cont:F,factors:List(ParFact))
 
   C == with
      factor        :         FP      -> Factored FP
        ++ factor(p) produces the complete factorization of the polynomial p.
      factorSquareFree :         FP      -> Factored FP
        ++ factorSquareFree(p) produces the complete factorization of the 
        ++ square free polynomial p.
      distdfact       :   (FP,Boolean)  -> FinalFact
        ++ distdfact(p,sqfrflag) produces the complete factorization
        ++ of the polynomial p returning an internal data structure.
        ++ If argument sqfrflag is true, the polynomial is assumed square free.
      separateDegrees :         FP      -> List fact
        ++ separateDegrees(p) splits the square free polynomial p into 
        ++ factors each of which is a product of irreducibles of the same degree.
      separateFactors :  List fact  -> List FP
        ++ separateFactors(lfact) takes the list produced by 
        ++ \spadfunFrom{separateDegrees}{DistinctDegreeFactorization}
        ++ and produces the complete list of factors.
      exptMod         :   (FP,NNI,FP)   -> FP
        ++ exptMod(u,k,v) raises the polynomial u to the kth power
        ++ modulo the polynomial v.
      trace2PowMod     :   (FP,NNI,FP)   -> FP
        ++ trace2PowMod(u,k,v) produces the sum of \spad{u**(2**i)} for i running
        ++ from 1 to k all computed modulo the polynomial v.
      tracePowMod     :   (FP,NNI,FP)   -> FP
        ++ tracePowMod(u,k,v) produces the sum of \spad{u**(q**i)} 
        ++ for i running and q= size F
      irreducible?    :         FP      -> Boolean
        ++ irreducible?(p) tests whether the polynomial p is irreducible.
 
 
   T == add
      --declarations
      D:=ModMonic(F,FP)
      import UnivariatePolynomialSquareFree(F,FP)
 
      --local functions
      notSqFr : (FP,FP -> List(FP)) -> List(ParFact)
      ddffact : FP -> List(FP)
      ddffact1 : (FP,Boolean) -> List fact
      ranpol :         NNI       -> FP
      
      charF : Boolean := characteristic()$F = 2

      --construct a random polynomial of random degree < d
      ranpol(d:NNI):FP ==
        k1: NNI := 0
        while k1 = 0 repeat k1 := random d
        -- characteristic F = 2
        charF =>
           u:=0$FP
           for j in 1..k1 repeat u:=u+monomial(random()$F,j)
           u
        u := monomial(1,k1)
        for j in 0..k1-1 repeat u:=u+monomial(random()$F,j)
        u
 
      notSqFr(m:FP,appl: FP->List(FP)):List(ParFact) ==
        factlist : List(ParFact) :=empty()
        llf : List FFE
        fln :List(FP) := empty()
        if (lcm:=leadingCoefficient m)^=1 then m:=(inv lcm)*m
        llf:= factorList(squareFree(m))
        for lf in llf repeat
          d1:= lf.xpnt
          pol := lf.fctr
          if (lcp:=leadingCoefficient pol)^=1 then pol := (inv lcp)*pol
          degree pol=1 => factlist:=cons([pol,d1]$ParFact,factlist)
          fln := appl(pol)
          factlist :=append([[pf,d1]$ParFact for pf in fln],factlist)
        factlist
 
      -- compute u**k mod v (requires call to setPoly of multiple of v)
      -- characteristic not equal 2
      exptMod(u:FP,k:NNI,v:FP):FP == (reduce(u)$D**k):FP rem v
 
      -- compute u**k mod v (requires call to setPoly of multiple of v)
      -- characteristic equal 2
      trace2PowMod(u:FP,k:NNI,v:FP):FP ==
        uu:=u
        for i in 1..k repeat uu:=(u+uu*uu) rem v
        uu

      -- compute u+u**q+..+u**(q**k) mod v 
      -- (requires call to setPoly of multiple of v) where q=size< F
      tracePowMod(u:FP,k:NNI,v:FP):FP ==
        u1 :D :=reduce(u)$D
        uu : D := u1
        for i in 1..k repeat uu:=(u1+frobenius uu) 
        (lift uu) rem v

      -- compute u**(1+q+..+q**k) rem v where q=#F 
      -- (requires call to setPoly of multiple of v)
      -- frobenius map is used
      normPowMod(u:FP,k:NNI,v:FP):FP ==
        u1 :D :=reduce(u)$D
        uu : D := u1
        for i in 1..k repeat uu:=(u1*frobenius uu) 
        (lift uu) rem v
 
      --find the factorization of m as product of factors each containing
      --terms of equal degree .
      -- if testirr=true the function returns the first factor found
      ddffact1(m:FP,testirr:Boolean):List(fact) ==
        p:=size$F
        dg:NNI :=0
        ddfact:List(fact):=empty()
        --evaluation of x**p mod m
        k1:NNI
        u:= m
        du := degree u
        setPoly u
        mon: FP := monomial(1,1)
        v := mon
        for k1 in 1.. while k1 <= (du quo 2) repeat
            v := lift frobenius reduce(v)$D
            g := gcd(v-mon,u)
            dg := degree g
            dg =0  => "next k1"
            if leadingCoefficient g ^=1 then g := (inv leadingCoefficient g)*g
            ddfact := cons([k1,g]$fact,ddfact)
            testirr => return ddfact
            u := u quo g
            du := degree u
            du = 0 => return ddfact
            setPoly u
        cons([du,u]$fact,ddfact)
 
      -- test irreducibility
      irreducible?(m:FP):Boolean ==
        mf:fact:=first ddffact1(m,true)
        degree m = mf.deg
 
      --export ddfact1
      separateDegrees(m:FP):List(fact) == ddffact1(m,false)
 
      --find the complete factorization of m, using the result of ddfact1
      separateFactors(distf : List fact) :List FP ==
        ddfact := distf
        n1:Integer
        p1:=size()$F
        if charF then n1:=length(p1)-1
        newaux,aux,ris : List FP
        ris := empty()
        t,fprod : FP
        for ffprod in ddfact repeat
          fprod := ffprod.prod
          d := ffprod.deg
          degree fprod = d => ris := cons(fprod,ris)
          aux:=[fprod]
          setPoly fprod
          while ^(empty? aux) repeat
            t := ranpol(2*d)
            if charF then t:=trace2PowMod(t,(n1*d-1)::NNI,fprod)
            else t:=exptMod(tracePowMod(t,(d-1)::NNI,fprod),
                                     (p1 quo 2)::NNI,fprod)-1$FP
            newaux:=empty()
            for u in aux repeat
                g := gcd(u,t)
                dg:= degree g
                dg=0 or dg = degree u => newaux:=cons(u,newaux)
                v := u quo g
                if dg=d then ris := cons(inv(leadingCoefficient g)*g,ris)
                        else newaux := cons(g,newaux)
                if degree v=d then ris := cons(inv(leadingCoefficient v)*v,ris)
                              else newaux := cons(v,newaux)
            aux:=newaux
        ris
 
      --distinct degree algorithm for monic ,square-free polynomial
      ddffact(m:FP):List(FP)==
        ddfact:=ddffact1(m,false)
        empty? ddfact => [m]
        separateFactors ddfact
 
      --factorize a general polynomial with distinct degree algorithm
      --if test=true no check is executed on square-free
      distdfact(m:FP,test:Boolean):FinalFact ==
        factlist: List(ParFact):= empty()
        fln : List(FP) :=empty()
 
        --make m monic
        if (lcm := leadingCoefficient m) ^=1 then m := (inv lcm)*m
 
        --is x**d factor of m?
        if (d := minimumDegree m)>0 then
          m := (monicDivide (m,monomial(1,d))).quotient
          factlist := [[monomial(1,1),d]$ParFact]
        d:=degree m
 
        --is m constant?
        d=0 => [lcm,factlist]$FinalFact
 
        --is m linear?
        d=1 => [lcm,cons([m,d]$ParFact,factlist)]$FinalFact
 
        --m is square-free
        test =>
          fln := ddffact m
          factlist := append([[pol,1]$ParFact for pol in fln],factlist)
          [lcm,factlist]$FinalFact
 
        --factorize the monic,square-free terms
        factlist:= append(notSqFr(m,ddffact),factlist)
        [lcm,factlist]$FinalFact
 
      --factorize the polynomial m
      factor(m:FP) ==
        m = 0 => 0
        flist := distdfact(m,false)
        makeFR(flist.cont::FP,[["prime",u.irr,u.pow]$FFE 
                                 for u in flist.factors])


      --factorize the square free polynomial m
      factorSquareFree(m:FP) ==
        m = 0 => 0
        flist := distdfact(m,true)
        makeFR(flist.cont::FP,[["prime",u.irr,u.pow]$FFE 
                                 for u in flist.factors])

@
<<DDFACT.dotabb>>=
"DDFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DDFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"DDFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DBLRESP DoubleResultantPackage}
\pagehead{DoubleResultantPackage}{DBLRESP}
\pagepic{ps/v104doubleresultantpackage.ps}{DBLRESP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DBLRESP DoubleResultantPackage>>=
)abbrev package DBLRESP DoubleResultantPackage
++ Residue resultant
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 12 July 1990
++ Description:
++ This package provides functions for computing the residues
++ of a function on an algebraic curve.
DoubleResultantPackage(F, UP, UPUP, R): Exports == Implementation where
  F   : Field
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP
  R   : FunctionFieldCategory(F, UP, UPUP)

  RF  ==> Fraction UP
  UP2 ==> SparseUnivariatePolynomial UP
  UP3 ==> SparseUnivariatePolynomial UP2

  Exports ==> with
    doubleResultant: (R, UP -> UP) -> UP
      ++ doubleResultant(f, ') returns p(x) whose roots are
      ++ rational multiples of the residues of f at all its
      ++ finite poles. Argument ' is the derivation to use.

  Implementation ==> add
    import CommuteUnivariatePolynomialCategory(F, UP, UP2)
    import UnivariatePolynomialCommonDenominator(UP, RF, UPUP)

    UP22   : UP   -> UP2
    UP23   : UPUP -> UP3
    remove0: UP   -> UP             -- removes the power of x dividing p

    remove0 p ==
      primitivePart((p exquo monomial(1, minimumDegree p))::UP)

    UP22 p ==
      map(#1::UP, p)$UnivariatePolynomialCategoryFunctions2(F,UP,UP,UP2)

    UP23 p ==
      map(UP22(retract(#1)@UP),
          p)$UnivariatePolynomialCategoryFunctions2(RF, UPUP, UP2, UP3)

    doubleResultant(h, derivation) ==
      cd := splitDenominator lift h
      d  := (cd.den exquo (g := gcd(cd.den, derivation(cd.den))))::UP
      r  := swap primitivePart swap resultant(UP23(cd.num)
          - ((monomial(1, 1)$UP :: UP2) * UP22(g * derivation d))::UP3,
                                              UP23 definingPolynomial())
      remove0 resultant(r, UP22 d)

@
<<DBLRESP.dotabb>>=
"DBLRESP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DBLRESP"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"DBLRESP" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCX DrawComplex}
\pagehead{DrawComplex}{DRAWCX}
\pagepic{ps/v104drawcomplex.ps}{DRAWCX}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCX DrawComplex>>=
)abbrev package DRAWCX DrawComplex
++ Description: \axiomType{DrawComplex} provides some facilities
++ for drawing complex functions.
C ==> Complex DoubleFloat
S ==> Segment DoubleFloat
PC ==> Record(rr:SF, th:SF)
INT ==> Integer
SF ==> DoubleFloat
NNI ==> NonNegativeInteger
VIEW3D ==> ThreeDimensionalViewport
ARRAY2 ==> TwoDimensionalArray
 
DrawComplex(): Exports == Implementation where
  Exports == with
    drawComplex: (C -> C,S,S,Boolean) -> VIEW3D
      ++ drawComplex(f,rRange,iRange,arrows?)
      ++ draws a complex function as a height field.
      ++ It uses the complex norm as the height and the complex 
      ++ argument as the color.
      ++ It will optionally draw arrows on the surface indicating the direction
      ++ of the complex value.\newline
      ++ Sample call:
      ++   \spad{f z == exp(1/z)}
      ++   \spad{drawComplex(f, 0.3..3, 0..2*%pi, false)}
      ++ Parameter descriptions:
      ++   f:  the function to draw
      ++   rRange : the range of the real values
      ++   iRange : the range of imaginary values
      ++   arrows? : a flag indicating whether to draw the phase arrows for f
      ++ Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and 
      ++ \axiomFunFrom{setImagSteps}{DrawComplex} to change the
      ++ number of steps used in each direction.
    drawComplexVectorField: (C -> C,S,S) -> VIEW3D
      ++ drawComplexVectorField(f,rRange,iRange)
      ++ draws a complex vector field using arrows on the \spad{x--y} plane.
      ++ These vector fields should be viewed from the top by pressing the
      ++ "XY" translate button on the 3-d viewport control panel.\newline
      ++ Sample call:
      ++    \spad{f z == sin z}
      ++    \spad{drawComplexVectorField(f, -2..2, -2..2)}
      ++ Parameter descriptions:
      ++   f : the function to draw
      ++   rRange : the range of the real values
      ++   iRange : the range of the imaginary values
      ++ Call the functions \axiomFunFrom{setRealSteps}{DrawComplex} and 
      ++ \axiomFunFrom{setImagSteps}{DrawComplex} to change the
      ++ number of steps used in each direction.
    setRealSteps: INT -> INT
      ++ setRealSteps(i)
      ++ sets to i the number of steps to use in the real direction 
      ++ when drawing complex functions. Returns i.
    setImagSteps: INT -> INT
      ++ setImagSteps(i)
      ++ sets to i  the number of steps to use in the imaginary direction
      ++ when drawing complex functions. Returns i.
    setClipValue: SF-> SF
      ++ setClipValue(x)
      ++ sets to x the maximum value to plot when drawing complex functions. Returns x.
  Implementation == add
    -- relative size of the arrow head compared to the length of the arrow
    arrowScale : SF := (0.125)::SF
    arrowAngle: SF := pi()-pi()/(20::SF)    -- angle of the arrow head
    realSteps: INT  := 11     -- the number of steps in the real direction
    imagSteps: INT  := 11     -- the number of steps in the imaginary direction
    clipValue: SF  := 10::SF -- the maximum length of a vector to draw
 
 
    -- Add an arrow head to a line segment, which starts at 'p1', ends at 'p2',
    -- has length 'len', and and angle 'arg'.  We pass 'len' and 'arg' as
    -- arguments since thet were already computed by the calling program
    makeArrow(p1:Point SF, p2:Point SF, len: SF, arg:SF):List List Point SF ==
      c1 := cos(arg + arrowAngle) 
      s1 := sin(arg + arrowAngle)
      c2 := cos(arg - arrowAngle) 
      s2 := sin(arg - arrowAngle)
      p3 := point [p2.1 + c1*arrowScale*len, p2.2 + s1*arrowScale*len, 
                   p2.3, p2.4]
      p4 := point [p2.1 + c2*arrowScale*len, p2.2 + s2*arrowScale*len, 
                   p2.3, p2.4]
      [[p1, p2, p3], [p2, p4]]
     
    -- clip a value in the interval (-clip...clip)
    clipFun(x:SF):SF == 
      min(max(x, -clipValue), clipValue)
 
    drawComplex(f, realRange, imagRange, arrows?) ==
      delReal := (hi(realRange) - lo(realRange))/realSteps::SF
      delImag := (hi(imagRange) - lo(imagRange))/imagSteps::SF
      funTable: ARRAY2(PC) := 
         new((realSteps::NNI)+1, (imagSteps::NNI)+1, [0,0]$PC)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        for j in 1..imagSteps+1 repeat
          z := f complex(real, imag)
          funTable(i,j) := [clipFun(sqrt norm z), argument(z)]$PC
          imag := imag + delImag
        real := real + delReal
      llp := empty()$(List List Point SF)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        lp := empty()$(List Point SF)
        for j in 1..imagSteps+1 repeat
          p := point [real, imag, funTable(i,j).rr, funTable(i,j).th]
          lp := cons(p, lp)
          imag := imag + delImag
        real := real + delReal
        llp := cons(lp, llp)
      space := mesh(llp)$(ThreeSpace SF)
      if arrows? then 
        real := lo(realRange)
        for i in 1..realSteps+1 repeat
          imag := lo(imagRange)
          for j in 1..imagSteps+1 repeat
            arg := funTable(i,j).th
            p1 := point [real,imag, funTable(i,j).rr, arg]
            len := delReal*2.0::SF
            p2 := point [p1.1 + len*cos(arg), p1.2 + len*sin(arg), 
                         p1.3, p1.4]
            arrow := makeArrow(p1, p2, len, arg)
            for a in arrow repeat curve(space, a)$(ThreeSpace SF)
            imag := imag + delImag
          real := real + delReal
      makeViewport3D(space, "Complex Function")$VIEW3D
 
    drawComplexVectorField(f, realRange, imagRange): VIEW3D ==
      -- compute the steps size of the grid
      delReal := (hi(realRange) - lo(realRange))/realSteps::SF
      delImag := (hi(imagRange) - lo(imagRange))/imagSteps::SF
      -- create the space to hold the arrows
      space := create3Space()$(ThreeSpace SF)
      real := lo(realRange)
      for i in 1..realSteps+1 repeat
        imag := lo(imagRange)
        for j in 1..imagSteps+1 repeat
          -- compute the function
          z := f complex(real, imag)
          -- get the direction of the arrow
          arg := argument z
          -- get the length of the arrow
          len := clipFun(sqrt norm z)
          -- create point at the base of the arrow
          p1 :=  point [real, imag, 0::SF, arg]
          -- scale the arrow length so it isn't too long
          scaleLen := delReal * len
          -- create the point at the top of the arrow
          p2 := point [p1.1 + scaleLen*cos(arg), p1.2 + scaleLen*sin(arg), 
                       0::SF, arg]
          -- make the pointer at the top of the arrow
          arrow := makeArrow(p1, p2, scaleLen, arg)
          -- add the line segments in the arrow to the space
          for a in arrow repeat curve(space, a)$(ThreeSpace SF)
          imag := imag + delImag
        real := real + delReal
      -- draw the vector feild
      makeViewport3D(space, "Complex Vector Field")$VIEW3D
 
    -- set the number of steps to use in the real direction
    setRealSteps(n) ==
      realSteps := n
     
    -- set the number of steps to use in the imaginary direction
    setImagSteps(n) ==
      imagSteps := n
     
    -- set the maximum value to plot 
    setClipValue clip ==
      clipValue := clip

@
<<DRAWCX.dotabb>>=
"DRAWCX" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCX"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"DRAWCX" -> "FIELD"
"DRAWCX" -> "RADCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWHACK DrawNumericHack}
\pagehead{DrawNumericHack}{DRAWHACK}
\pagepic{ps/v104drawnumerichack.ps}{DRAWHACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWHACK DrawNumericHack>>=
)abbrev package DRAWHACK DrawNumericHack
++ Author: Manuel Bronstein
++ Date Created: 21 Feb 1990
++ Date Last Updated: 21 Feb 1990
++ Basic Operations: coerce
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ References:
++ Description: Hack for the draw interface. DrawNumericHack provides
++ a "coercion" from something of the form \spad{x = a..b} where \spad{a} 
++ and b are
++ formal expressions to a binding of the form \spad{x = c..d} where c and d
++ are the numerical values of \spad{a} and b. This "coercion" fails if
++ \spad{a} and b contains symbolic variables, but is meant for expressions
++ involving %pi.  
++ NOTE:  This is meant for internal use only.
 
DrawNumericHack(R:Join(OrderedSet,IntegralDomain,ConvertibleTo Float)):
 with coerce: SegmentBinding Expression R -> SegmentBinding Float
        ++ coerce(x = a..b) returns \spad{x = c..d} where c and d are the
        ++ numerical values of \spad{a} and b.
  == add
   coerce s ==
     map(numeric$Numeric(R),s)$SegmentBindingFunctions2(Expression R, Float)

@
<<DRAWHACK.dotabb>>=
"DRAWHACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWHACK"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"DRAWHACK" -> "ALGEBRA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DROPT0 DrawOptionFunctions0}
\pagehead{DrawOptionFunctions0}{DROPT0}
\pagepic{ps/v104drawoptionfunctions0.ps}{DROPT0}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DROPT0 DrawOptionFunctions0>>=
)abbrev package DROPT0 DrawOptionFunctions0
-- The functions here are not in DrawOptions since they are not
-- visible to the interpreter.
++ This package \undocumented{}
DrawOptionFunctions0(): Exports == Implementation where
 RANGE ==> List Segment Float
 UNIT  ==> List Float
 PAL   ==> Palette
 POINT ==> Point(DoubleFloat)
 SEG   ==> Segment Float
 SF     ==> DoubleFloat
 SPACE3 ==> ThreeSpace(DoubleFloat)
 VIEWPT ==> Record( theta:SF, phi:SF, scale:SF, scaleX:SF, scaleY:SF, scaleZ:SF, deltaX:SF, deltaY:SF )

 Exports ==> with
  adaptive: (List DrawOption, Boolean) -> Boolean
    ++ adaptive(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{adaptive}.
    ++ If the option does not exist the value, b is returned.
  clipBoolean: (List DrawOption, Boolean) -> Boolean
    ++ clipBoolean(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{clipBoolean}.
    ++ If the option does not exist the value, b is returned.
  viewpoint: (List DrawOption, VIEWPT) -> VIEWPT
    ++ viewpoint(l,ls) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{viewpoint}.
    ++ IF the option does not exist, the value ls is returned.
  title: (List DrawOption, String) -> String
    ++ title(l,s) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{title}.
    ++ If the option does not exist the value, s is returned.
  style: (List DrawOption, String) -> String
    ++ style(l,s) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{style}.
    ++ If the option does not exist the value, s is returned.
  toScale: (List DrawOption, Boolean) -> Boolean
    ++ toScale(l,b) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{toScale}.
    ++ If the option does not exist the value, b is returned.

  pointColorPalette: (List DrawOption,PAL) -> PAL
    ++ pointColorPalette(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{pointColorPalette}.
    ++ If the option does not exist the value, p is returned.
  curveColorPalette: (List DrawOption,PAL) -> PAL
    ++ curveColorPalette(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{curveColorPalette}.
    ++ If the option does not exist the value, p is returned.

  ranges: (List DrawOption, RANGE) -> RANGE
    ++ ranges(l,r) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{ranges}.
    ++ If the option does not exist the value, r is returned.
  var1Steps: (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ var1Steps(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{var1Steps}.
    ++ If the option does not exist the value, n is returned.
  var2Steps: (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ var2Steps(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{var2Steps}.
    ++ If the option does not exist the value, n is returned.
  space: (List DrawOption) -> SPACE3
    ++ space(l) takes a list of draw options, l, and checks to see
    ++ if it contains the option \spad{space}.  If the the option
    ++ doesn't exist, then an empty space is returned.
  tubePoints : (List DrawOption, PositiveInteger) -> PositiveInteger
    ++ tubePoints(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{tubePoints}.
    ++ If the option does not exist the value, n is returned.
  tubeRadius : (List DrawOption, Float) -> Float
    ++ tubeRadius(l,n) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{tubeRadius}.
    ++ If the option does not exist the value, n is returned.
  coord: (List DrawOption, (POINT->POINT)) -> (POINT->POINT)
    ++ coord(l,p) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{coord}.
    ++ If the option does not exist the value, p is returned.
  units: (List DrawOption, UNIT) -> UNIT
    ++ units(l,u) takes the list of draw options, l, and checks
    ++ the list to see if it contains the option \spad{unit}.
    ++ If the option does not exist the value, u is returned.

 Implementation ==> add
  adaptive(l,s) ==
    (u := option(l, "adaptive"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  clipBoolean(l,s) ==
    (u := option(l, "clipBoolean"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  title(l, s) ==
    (u := option(l, "title"::Symbol)$DrawOptionFunctions1(String))
      case "failed" => s
    u::String

  viewpoint(l, vp) ==
    (u := option(l, "viewpoint"::Symbol)$DrawOptionFunctions1(VIEWPT))
      case "failed" => vp
    u::VIEWPT

  style(l, s) ==
    (u := option(l, "style"::Symbol)$DrawOptionFunctions1(String))
      case "failed" => s
    u::String

  toScale(l,s) ==
    (u := option(l, "toScale"::Symbol)$DrawOptionFunctions1(Boolean))
      case "failed" => s
    u::Boolean

  pointColorPalette(l,s) ==
    (u := option(l, "pointColorPalette"::Symbol)$DrawOptionFunctions1(PAL))
      case "failed" => s
    u::PAL

  curveColorPalette(l,s) ==
    (u := option(l, "curveColorPalette"::Symbol)$DrawOptionFunctions1(PAL))
      case "failed" => s
    u::PAL



  ranges(l, s) ==
    (u := option(l, "ranges"::Symbol)$DrawOptionFunctions1(RANGE))
      case "failed" => s
    u::RANGE

  space(l) ==
    (u := option(l, "space"::Symbol)$DrawOptionFunctions1(SPACE3))
      case "failed" => create3Space()$SPACE3
    u::SPACE3

  var1Steps(l,s) ==
    (u := option(l, "var1Steps"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  var2Steps(l,s) ==
    (u := option(l, "var2Steps"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  tubePoints(l,s) ==
    (u := option(l, "tubePoints"::Symbol)$DrawOptionFunctions1(PositiveInteger))
      case "failed" => s
    u::PositiveInteger

  tubeRadius(l,s) ==
    (u := option(l, "tubeRadius"::Symbol)$DrawOptionFunctions1(Float))
      case "failed" => s
    u::Float

  coord(l,s) ==
    (u := option(l, "coord"::Symbol)$DrawOptionFunctions1(POINT->POINT))
      case "failed" => s
    u::(POINT->POINT)

  units(l,s) ==
    (u := option(l, "unit"::Symbol)$DrawOptionFunctions1(UNIT))
      case "failed" => s
    u::UNIT

@
<<DROPT0.dotabb>>=
"DROPT0" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DROPT0"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DROPT0" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DROPT1 DrawOptionFunctions1}
\pagehead{DrawOptionFunctions1}{DROPT1}
\pagepic{ps/v104drawoptionfunctions1.ps}{DROPT1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DROPT1 DrawOptionFunctions1>>=
)abbrev package DROPT1 DrawOptionFunctions1
++ This package \undocumented{}
DrawOptionFunctions1(S:Type): Exports == Implementation where
 RANGE ==> List Segment Float
 UNIT  ==> List Float
 PAL   ==> Palette
 POINT ==> Point(DoubleFloat)
 SEG   ==> Segment Float
 SF     ==> DoubleFloat
 SPACE3 ==> ThreeSpace(DoubleFloat)
 VIEWPT ==> Record( theta:SF, phi:SF, scale:SF, scaleX:SF, scaleY:SF, scaleZ:SF, deltaX:SF, deltaY:SF )
 
 Exports ==> with
  option: (List DrawOption, Symbol) -> Union(S, "failed")
    ++ option(l,s) determines whether the indicated drawing option, s,
    ++ is contained in the list of drawing options, l, which is defined
    ++ by the draw command.
 Implementation ==> add
  option(l, s) ==
    (u := option(l, s)@Union(Any, "failed")) case "failed" => "failed"
    retract(u::Any)$AnyFunctions1(S)

@
<<DROPT1.dotabb>>=
"DROPT1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DROPT1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"DROPT1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D01AGNT d01AgentsPackage}
\pagehead{d01AgentsPackage}{D01AGNT}
\pagepic{ps/v104d01agentspackage.ps}{D01AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D01AGNT d01AgentsPackage>>=
)abbrev package D01AGNT d01AgentsPackage
++ Author: Brian Dupee
++ Date Created: March 1994
++ Date Last Updated: December 1997
++ Basic Operations: rangeIsFinite, functionIsContinuousAtEndPoints,
++ functionIsOscillatory
++ Description:
++ \axiomType{d01AgentsPackage} is a package of numerical agents to be used
++ to investigate attributes of an input function so as to decide the
++ \axiomFun{measure} of an appropriate numerical integration routine.
++ It contains functions \axiomFun{rangeIsFinite} to test the input range and
++ \axiomFun{functionIsContinuousAtEndPoints} to check for continuity at 
++ the end points of the range.


d01AgentsPackage(): E == I where
  EF2	==> ExpressionFunctions2
  EFI	==> Expression Fraction Integer
  FI	==> Fraction Integer
  LEDF	==> List Expression DoubleFloat
  KEDF	==> Kernel Expression DoubleFloat
  EEDF	==> Equation Expression DoubleFloat
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  LDF	==> List DoubleFloat
  SDF	==> Stream DoubleFloat
  DF	==> DoubleFloat
  F	==> Float
  ST	==> String
  LST	==> List String
  SI	==> SingleInteger
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat
  OCEDF	==> OrderedCompletion Expression DoubleFloat
  EOCEFI  ==> Equation OrderedCompletion Expression Fraction Integer
  OCEFI   ==> OrderedCompletion Expression Fraction Integer
  OCFI    ==> OrderedCompletion Fraction Integer
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  CTYPE	==> Union(continuous: "Continuous at the end points",
             lowerSingular: "There is a singularity at the lower end point",
              upperSingular: "There is a singularity at the upper end point",
               bothSingular: "There are singularities at both end points",
                notEvaluated: "End point continuity not yet evaluated")
  RTYPE	==> Union(finite: "The range is finite",
              lowerInfinite: "The bottom of range is infinite",
                upperInfinite: "The top of range is infinite",
                  bothInfinite: "Both top and bottom points are infinite",
                    notEvaluated: "Range not yet evaluated")
  STYPE	==> Union(str:SDF,
                   notEvaluated:"Internal singularities not yet evaluated")
  ATT	==> Record(endPointContinuity:CTYPE,
                    singularitiesStream:STYPE,range:RTYPE)
  ROA	==> Record(key:NIA,entry:ATT)

  E ==> with
    
    rangeIsFinite : NIA -> RTYPE
      ++ rangeIsFinite(args) tests the endpoints of \spad{args.range} for 
      ++ infinite end points. 
    functionIsContinuousAtEndPoints: NIA -> CTYPE
      ++ functionIsContinuousAtEndPoints(args) uses power series limits
      ++ to check for problems at the end points of the range of \spad{args}.
    getlo : SOCDF -> DF
      ++ getlo(x) gets the \axiomType{DoubleFloat} equivalent of
      ++ the first endpoint of the range \axiom{x}
    gethi : SOCDF -> DF
      ++ gethi(x) gets the \axiomType{DoubleFloat} equivalent of
      ++ the second endpoint of the range \axiom{x}
    functionIsOscillatory:NIA -> F
      ++ functionIsOscillatory(a) tests whether the function \spad{a.fn}
      ++ has many zeros of its derivative.
    problemPoints: (EDF, Symbol, SOCDF) -> List DF
      ++ problemPoints(f,var,range) returns a list of possible problem points
      ++ by looking at the zeros of the denominator of the function if it
      ++ can be retracted to \axiomType{Polynomial DoubleFloat}.
    singularitiesOf:NIA -> SDF
      ++ singularitiesOf(args) returns a list of potential 
      ++ singularities of the function within the given range
    df2st:DF -> String 
      ++ df2st(n) coerces a \axiomType{DoubleFloat} to \axiomType{String}
    ldf2lst:LDF -> LST
      ++ ldf2lst(ln) coerces a List of \axiomType{DoubleFloat} to 
      ++ \axiomType{List String}
    sdf2lst:SDF -> LST
      ++ sdf2lst(ln) coerces a Stream of \axiomType{DoubleFloat} to 
      ++ \axiomType{List String}
    commaSeparate:LST -> ST
      ++ commaSeparate(l) produces a comma separated string from a 
      ++ list of strings.
    changeName:(Symbol,Symbol,Result) -> Result
      ++ changeName(s,t,r) changes the name of item \axiom{s} in \axiom{r}
      ++ to \axiom{t}.

  I ==> ExpertSystemContinuityPackage add

    import ExpertSystemToolsPackage
    import ExpertSystemContinuityPackage

    -- local functions
    ocdf2ocefi : OCDF -> OCEFI
    rangeOfArgument : (KEDF, NIA) -> DF
    continuousAtPoint? : (EFI,EOCEFI) -> Boolean
    rand:(SOCDF,INT) -> LDF 
    eval:(EDF,Symbol,LDF) -> LDF
    numberOfSignChanges:LDF -> INT
    rangeIsFiniteFunction:NIA -> RTYPE
    functionIsContinuousAtEndPointsFunction:NIA -> CTYPE
 
    changeName(s:Symbol,t:Symbol,r:Result):Result ==
      a := remove!(s,r)$Result
      a case Any =>
        insert!([t,a],r)$Result
        r
      r

    commaSeparate(l:LST):ST ==
      empty?(l)$LST => ""
--      one?(#(l)) => concat(l)$ST
      (#(l) = 1) => concat(l)$ST
      f := first(l)$LST
      t := [concat([", ",l.i])$ST for i in 2..#(l)]
      concat(f,concat(t)$ST)$ST

    rand(seg:SOCDF,n:INT):LDF ==
      -- produced a sorted list of random numbers in the given range
      l:DF := getlo seg
      s:DF := (gethi seg) - l
      seed:INT := random()$INT
      dseed:DF := seed :: DF
      r:LDF := [(((random(seed)$INT) :: DF)*s/dseed + l) for i in 1..n]
      sort(r)$LDF

    eval(f:EDF,var:Symbol,l:LDF):LDF ==
      empty?(l)$LDF => [0$DF]
      ve := var::EDF
      [retract(eval(f,equation(ve,u::EDF)$EEDF)$EDF)@DF for u in l]

    numberOfSignChanges(l:LDF):INT ==
      -- calculates the number of sign changes in a list
      a := 0$INT
      empty?(l)$LDF => 0
      for i in 2..# l repeat
        if negative?(l.i*l.(i-1))  then
          a := a + 1
      a

    rangeOfArgument(k: KEDF, args:NIA): DF ==
      Args := copy args
      Args.fn := arg := first(argument(k)$KEDF)$LEDF
      functionIsContinuousAtEndPoints(Args) case continuous =>
        r:SOCDF := args.range
        low:EDF := (getlo r) :: EDF
        high:EDF := (gethi r) :: EDF
        eql := equation(a := args.var :: EDF, low)$EEDF
        eqh := equation(a, high)$EEDF
        e1 := (numeric(eval(arg,eql)$EDF)$Numeric(DF)) :: DF
        e2 := (numeric(eval(arg,eqh)$EDF)$Numeric(DF)) :: DF
        e2-e1
      0$DF

    ocdf2ocefi(r:OCDF):OCEFI ==
      finite?(r)$OCDF => (edf2efi(((retract(r)@DF)$OCDF)::EDF))::OCEFI
      r pretend OCEFI

    continuousAtPoint?(f:EFI,e:EOCEFI):Boolean ==
      (l := limit(f,e)$PowerSeriesLimitPackage(FI,EFI)) case OCEFI =>
                       finite?(l :: OCEFI)
      -- if the left hand limit equals the right hand limit, or if neither
      -- side has a limit at this point, the return type of  limit() is
      -- Union(Ordered Completion Expression Fraction Integer,"failed")
      false

    -- exported functions
    
    rangeIsFiniteFunction(args:NIA): RTYPE ==
      -- rangeIsFinite(x) tests the endpoints of x.range for infinite
      -- end points. 
      --             [-inf,  inf]  =>  4
      --             [ x  ,  inf]  =>  3
      --             [-inf,  x  ]  =>  1
      --             [ x  ,  y  ]  =>  0
      fr:SI := (3::SI * whatInfinity(hi(args.range))$OCDF 
                      - whatInfinity(lo(args.range))$OCDF)
      fr = 0 => ["The range is finite"]
      fr = 1 => ["The bottom of range is infinite"]
      fr = 3 => ["The top of range is infinite"]
      fr = 4 => ["Both top and bottom points are infinite"]
      error("rangeIsFinite",["this is not a valid range"])$ErrorFunctions

    rangeIsFinite(args:NIA): RTYPE ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        s.range case notEvaluated => 
          s.range := rangeIsFiniteFunction(nia)
          r:ROA := [nia,s]
          insert!(r)$IntegrationFunctionsTable
          s.range
        s.range
      a:ATT := [["End point continuity not yet evaluated"],
                  ["Internal singularities not yet evaluated"],
                      e:=rangeIsFiniteFunction(nia)]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

    functionIsContinuousAtEndPointsFunction(args:NIA):CTYPE ==

      v := args.var :: EFI :: OCEFI
      high:OCEFI := ocdf2ocefi(hi(args.range))
      low:OCEFI := ocdf2ocefi(lo(args.range))
      f := edf2efi(args.fn)
      l:Boolean := continuousAtPoint?(f,equation(v,low)$EOCEFI)
      h:Boolean := continuousAtPoint?(f,equation(v,high)$EOCEFI)
      l and h => ["Continuous at the end points"]
      l => ["There is a singularity at the upper end point"]
      h => ["There is a singularity at the lower end point"]
      ["There are singularities at both end points"]

    functionIsContinuousAtEndPoints(args:NIA): CTYPE ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        s.endPointContinuity case notEvaluated => 
          s.endPointContinuity := functionIsContinuousAtEndPointsFunction(nia)
          r:ROA := [nia,s]
          insert!(r)$IntegrationFunctionsTable
          s.endPointContinuity
        s.endPointContinuity
      a:ATT := [e:=functionIsContinuousAtEndPointsFunction(nia),
                 ["Internal singularities not yet evaluated"],
                   ["Range not yet evaluated"]]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

    functionIsOscillatory(a:NIA):F ==

      args := copy a
      k := tower(numerator args.fn)$EDF
      p:F := pi()$F
      for i in 1..# k repeat
        is?(ker := k.i, sin :: Symbol) => 
          ra := convert(rangeOfArgument(ker,args))@F
          ra > 2*p => return (ra/p)
        is?(ker, cos :: Symbol) => 
          ra := convert(rangeOfArgument(ker,args))@F
          ra > 2*p => return (ra/p)
      l:LDF := rand(args.range,30)
      l := eval(args.fn,args.var,l)
      numberOfSignChanges(l) :: F   

    singularitiesOf(args:NIA):SDF ==
      nia := copy args
      (t := showAttributes(nia)$IntegrationFunctionsTable) case ATT =>
        s:ATT := coerce(t)@ATT
        p:STYPE := s.singularitiesStream
        p case str => p.str
        e:SDF := singularitiesOf(nia.fn,[nia.var],nia.range)
        if not empty?(e) then
          if less?(e,10)$SDF then extend(e,10)$SDF
        s.singularitiesStream := [e]
        r:ROA := [nia,s]
        insert!(r)$IntegrationFunctionsTable
        e
      e:=singularitiesOf(nia.fn,[nia.var],nia.range)
      if not empty?(e) then
        if less?(e,10)$SDF then extend(e,10)$SDF
      a:ATT := [["End point continuity not yet evaluated"],[e],
                          ["Range not yet evaluated"]]
      r:ROA := [nia,a]
      insert!(r)$IntegrationFunctionsTable
      e

@
<<D01AGNT.dotabb>>=
"D01AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D01AGNT"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D01AGNT" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D01WGTS d01WeightsPackage}
\pagehead{d01WeightsPackage}{D01WGTS}
\pagepic{ps/v104d01weightspackage.ps}{D01WGTS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D01WGTS d01WeightsPackage>>=
)abbrev package D01WGTS d01WeightsPackage
++ Author: Brian Dupee
++ Date Created: July 1994
++ Date Last Updated: January 1998 (Bug fix - exprHasListOfWeightsCosWXorSinWX)
++ Basic Operations: exprHasWeightCosWXorSinWX, exprHasAlgebraicWeight, 
++ exprHasLogarithmicWeights
++ Description:
++ \axiom{d01WeightsPackage} is a package for functions used to investigate
++ whether a function can be divided into a simpler function and a weight
++ function.  The types of weights investigated are those giving rise to
++ end-point singularities of the algebraico-logarithmic type, and 
++ trigonometric weights.
d01WeightsPackage(): E == I where
  LEDF	==> List Expression DoubleFloat
  KEDF	==> Kernel Expression DoubleFloat
  LKEDF	==> List Kernel Expression DoubleFloat
  EDF	==> Expression DoubleFloat
  PDF	==> Polynomial DoubleFloat
  FI	==> Fraction Integer
  LDF	==> List DoubleFloat
  DF	==> DoubleFloat
  SOCDF	==> Segment OrderedCompletion DoubleFloat
  OCDF	==> OrderedCompletion DoubleFloat
  NIA	==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  INT	==> Integer
  BOP	==> BasicOperator
  URBODF	==> Union(Record(op:BasicOperator,w:DF),"failed")
  LURBODF	==> List(Union(Record(op:BasicOperator,w:DF), "failed"))
 
  E ==> with
    exprHasWeightCosWXorSinWX:NIA -> URBODF 
      ++ \axiom{exprHasWeightCosWXorSinWX} looks for trigonometric
      ++ weights in an expression of the form \axiom{cos \omega x} or
      ++ \axiom{sin \omega x}, returning the value of \omega 
      ++ (\notequal 1) and the operator. 
    exprHasAlgebraicWeight:NIA -> Union(LDF,"failed")
      ++ \axiom{exprHasAlgebraicWeight} looks for algebraic weights
      ++ giving rise to singularities of the function at the end-points.
    exprHasLogarithmicWeights:NIA -> INT
      ++ \axiom{exprHasLogarithmicWeights} looks for logarithmic weights
      ++ giving rise to singularities of the function at the end-points.
 
 
    
  I ==> add
    score:(EDF,EDF) -> FI
    kernelIsLog:KEDF -> Boolean 
    functionIsPolynomial?:EDF -> Boolean
    functionIsNthRoot?:(EDF,EDF) -> Boolean 
    functionIsQuotient:EDF -> Union(EDF,"failed")
    findCommonFactor:LEDF -> Union(LEDF,"failed")
    findAlgebraicWeight:(NIA,EDF) -> Union(DF,"failed")
    exprHasListOfWeightsCosWXorSinWX:(EDF,Symbol) -> LURBODF
    exprOfFormCosWXorSinWX:(EDF,Symbol) -> URBODF
    bestWeight:LURBODF -> URBODF
    weightIn?:(URBODF,LURBODF) -> Boolean
    inRest?:(EDF,LEDF)->Boolean
    factorIn?:(EDF,LEDF)->Boolean
    voo?:(EDF,EDF)->Boolean
   
    kernelIsLog(k:KEDF):Boolean ==
      (name k = (log :: Symbol))@Boolean
 
    factorIn?(a:EDF,l:LEDF):Boolean ==
      for i in 1..# l repeat
        (a = l.i)@Boolean => return true
      false
 
    voo?(b:EDF,a:EDF):Boolean ==
       (voo:=isTimes(b)) case LEDF and factorIn?(a,voo)
 
    inRest?(a:EDF,l:LEDF):Boolean ==
      every?( voo?(#1,a) ,l)
 
    findCommonFactor(l:LEDF):Union(LEDF,"failed") ==
      empty?(l)$LEDF => "failed"
      f := first(l)$LEDF
      r := rest(l)$LEDF
      (t := isTimes(f)$EDF) case LEDF =>
        pos:=select(inRest?(#1,r),t)
        empty?(pos) => "failed"
        pos
      "failed"
 
    exprIsLogarithmicWeight(f:EDF,Var:EDF,a:EDF,b:EDF):INT ==
      ans := 0$INT
      k := tower(f)$EDF
      lf := select(kernelIsLog,k)$LKEDF
      empty?(lf)$LKEDF => ans
      for i in 1..# lf repeat
        arg := argument lf.i
        if (arg.1 = (Var - a)) then
          ans := ans + 1
        else if (arg.1 = (b - Var)) then
          ans := ans + 2
      ans      
 
    exprHasLogarithmicWeights(args:NIA):INT ==
      ans := 1$INT
      a := getlo(args.range)$d01AgentsPackage :: EDF
      b := gethi(args.range)$d01AgentsPackage :: EDF
      Var := args.var :: EDF
      (l := isPlus numerator args.fn) case LEDF =>
        (cf := findCommonFactor l) case LEDF =>
          for j in 1..# cf repeat
            ans := ans + exprIsLogarithmicWeight(cf.j,Var,a,b)
          ans
        ans
      ans := ans + exprIsLogarithmicWeight(args.fn,Var,a,b)
 
    functionIsQuotient(expr:EDF):Union(EDF,"failed") ==
      (k := mainKernel expr) case KEDF =>
        expr = inv(f := k :: KEDF :: EDF)$EDF => f
--        one?(numerator expr) => denominator expr
        (numerator expr = 1) => denominator expr
        "failed"
      "failed"
 
    functionIsPolynomial?(f:EDF):Boolean ==
      (retractIfCan(f)@Union(PDF,"failed"))$EDF case PDF
 
    functionIsNthRoot?(f:EDF,e:EDF):Boolean ==
      (m := mainKernel f) case "failed" => false
--      (one?(# (kernels f))) 
      ((# (kernels f)) = 1) 
        and (name operator m = (nthRoot :: Symbol))@Boolean
          and (((argument m).1 = e)@Boolean)
 
    score(f:EDF,e:EDF):FI ==
      ans := 0$FI
      (t := isTimes f) case LEDF =>
        for i in 1..# t repeat
          ans := ans + score(t.i,e)
        ans
      (q := functionIsQuotient f) case EDF =>
        ans := ans - score(q,e)
      functionIsPolynomial? f =>
        g:EDF := f/e
        if functionIsPolynomial? g then
          ans := 1+score(g,e)
        else
          ans 
      (l := isPlus f) case LEDF =>
        (cf := findCommonFactor l) case LEDF =>
          factor := 1$EDF
          for i in 1..# cf repeat
            factor := factor*cf.i
          ans := ans + score(f/factor,e) + score(factor,e)
        ans
      functionIsNthRoot?(f,e) =>
        (p := isPower f) case "failed" => ans
        exp := p.exponent
        m := mainKernel f
        m case KEDF => 
          arg := argument m
          a:INT := (retract(arg.2)@INT)$EDF
          exp / a
        ans
      ans
 
    findAlgebraicWeight(args:NIA,e:EDF):Union(DF,"failed") == 
      zero?(s := score(args.fn,e)) => "failed"
      s :: DF
 
    exprHasAlgebraicWeight(args:NIA):Union(LDF,"failed") ==
      (f := functionIsContinuousAtEndPoints(args)$d01AgentsPackage) 
                                          case continuous =>"failed"
      Var := args.var :: EDF
      a := getlo(args.range)$d01AgentsPackage :: EDF
      b := gethi(args.range)$d01AgentsPackage :: EDF
      A := Var - a
      B := b - Var
      f case lowerSingular => 
        (h := findAlgebraicWeight(args,A)) case "failed" => "failed"
        [h,0] 
      f case upperSingular => 
        (g := findAlgebraicWeight(args,B)) case "failed" => "failed"
        [0,g] 
      h := findAlgebraicWeight(args,A) 
      g := findAlgebraicWeight(args,B)
      r := (h case "failed")
      s := (g case "failed")
      (r) and (s) => "failed"
      r => [0,coerce(g)@DF]
      s => [coerce(h)@DF,0]  
      [coerce(h)@DF,coerce(g)@DF]
 
    exprOfFormCosWXorSinWX(f:EDF,var:Symbol): URBODF ==
      l:LKEDF := kernels(f)$EDF
--      one?((# l)$LKEDF)$INT => 
      # l = 1 => 
        a:LEDF := argument(e:KEDF := first(l)$LKEDF)$KEDF
        empty?(a) => "failed"
        m:Union(LEDF,"failed") := isTimes(first(a)$LEDF)$EDF 
        m case LEDF => -- if it is a list, it will have at least two elements
          is?(second(m)$LEDF,var)$EDF =>
            omega:DF := retract(first(m)$LEDF)@DF
            o:BOP := operator(n:Symbol:=name(e)$KEDF)$BOP
            (n = cos@Symbol)@Boolean => [o,omega]
            (n = sin@Symbol)@Boolean => [o,omega]
            "failed"
          "failed"
        "failed"
      "failed"
 
    exprHasListOfWeightsCosWXorSinWX(f:EDF,var:Symbol): LURBODF ==
      (e := isTimes(f)$EDF) case LEDF => 
        [exprOfFormCosWXorSinWX(u,var) for u in e]
      empty?(k := kernels f) => ["failed"]
      ((first(k)::EDF) = f) => 
        [exprOfFormCosWXorSinWX(f,var)]
      ["failed"]
 
    bestWeight(l:LURBODF): URBODF ==
      empty?(l)$LURBODF => "failed"
      best := first(l)$LURBODF        --  best is first in list
      empty?(rest(l)$LURBODF) => best
      for i in 2..# l repeat          --  unless next is better
        r:URBODF := l.i
        if r case "failed" then leave
        else if best case "failed" then
          best := r
        else if r.w > best.w then
          best := r
      best
 
    weightIn?(weight:URBODF,listOfWeights:LURBODF):Boolean ==
      n := # listOfWeights
      for i in 1..n repeat                               -- cycle through list
        (weight = listOfWeights.i)@Boolean => return true -- return when found
      false
 
    exprHasWeightCosWXorSinWX(args:NIA):URBODF ==
      ans := empty()$LURBODF
      f:EDF := numerator(args.fn)$EDF
      (t:Union(LEDF,"failed") := isPlus(f)) case "failed" => 
        bestWeight(exprHasListOfWeightsCosWXorSinWX(f,args.var))
      if t case LEDF then
        e1 := first(t)$LEDF
        le1:LURBODF := exprHasListOfWeightsCosWXorSinWX(e1,args.var)
        le1 := [u for u in le1 | (not (u case "failed"))]
        empty?(le1)$LURBODF => "failed"
        test := true
        for i in 1..# le1 repeat
          le1i:URBODF := le1.i
          for j in 2..# t repeat
            if test then
              tj:LURBODF := exprHasListOfWeightsCosWXorSinWX(t.j,args.var)
              test := weightIn?(le1i,tj)
          if test then
            ans := concat([le1i],ans)
        bestWeight ans
      else "failed"

@
<<D01WGTS.dotabb>>=
"D01WGTS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D01WGTS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D01WGTS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D02AGNT d02AgentsPackage}
\pagehead{d02AgentsPackage}{D02AGNT}
\pagepic{ps/v104d02agentspackage.ps}{D02AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D02AGNT d02AgentsPackage>>=
)abbrev package D02AGNT d02AgentsPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: January 1997
++ Basic Operations: stiffnessFactor, jacobian
++ Description:
++ \axiom{d02AgentsPackage} contains a set of computational agents 
++ for use with Ordinary Differential Equation solvers.
d02AgentsPackage(): E == I where
  LEDF	==> List Expression DoubleFloat
  LEEDF	==> List Equation Expression DoubleFloat
  EEDF	==> Equation Expression DoubleFloat
  VEDF	==> Vector Expression DoubleFloat
  MEDF	==> Matrix Expression DoubleFloat
  MDF	==> Matrix DoubleFloat
  EDF	==> Expression DoubleFloat
  DF	==> DoubleFloat
  F	==> Float
  INT	==> Integer
  CDF	==> Complex DoubleFloat
  LDF	==> List DoubleFloat
  LF	==> List Float
  S	==> Symbol
  LS	==> List Symbol
  MFI	==> Matrix Fraction Integer
  LFI	==> List Fraction Integer
  FI	==> Fraction Integer
  ODEA	==> Record(xinit:DF,xend:DF,fn:VEDF,yinit:LDF,intvals:LDF,g:EDF,abserr:DF,relerr:DF)
  ON	==> Record(additions:INT,multiplications:INT,exponentiations:INT,functionCalls:INT)
  RVE 	==> Record(val:EDF,exponent:INT)
  RSS	==> Record(stiffnessFactor:F,stabilityFactor:F)
  ATT	==> Record(stiffness:F,stability:F,expense:F,accuracy:F,intermediateResults:F)
  ROA	==> Record(key:ODEA,entry:ATT)

  E ==>  with
    combineFeatureCompatibility: (F,F) -> F
      ++ combineFeatureCompatibility(C1,C2) is for interacting attributes
    combineFeatureCompatibility: (F,LF) -> F
      ++ combineFeatureCompatibility(C1,L) is for interacting attributes
    sparsityIF: MEDF -> F
      ++ sparsityIF(m) calculates the sparsity of a jacobian matrix
    jacobian: (VEDF,LS) -> MEDF
      ++ jacobian(v,w) is a local function to make a jacobian matrix
    eval: (MEDF,LS,VEDF) -> MEDF
      ++ eval(mat,symbols,values) evaluates a multivariable matrix at given values
      ++ for each of a list of variables
    stiffnessAndStabilityFactor: MEDF -> RSS
      ++ stiffnessAndStabilityFactor(me) calculates the stability and
      ++ stiffness factor of a system of first-order differential equations
      ++ (by evaluating the maximum difference in the real parts of the
      ++ negative eigenvalues of the jacobian of the system for which O(10)
      ++ equates to mildly stiff wheras stiffness ratios of O(10^6) are not
      ++ uncommon) and whether the system is likely to show any oscillations
      ++ (identified by the closeness to the imaginary axis of the complex
      ++ eigenvalues of the jacobian).
    stiffnessAndStabilityOfODEIF:ODEA -> RSS
      ++ stiffnessAndStabilityOfODEIF(ode) calculates the intensity values
      ++ of stiffness of a system of first-order differential equations
      ++ (by evaluating the maximum difference in the real parts of the
      ++ negative eigenvalues of the jacobian of the system for which O(10)
      ++ equates to mildly stiff wheras stiffness ratios of O(10^6) are not
      ++ uncommon) and whether the system is likely to show any oscillations
      ++ (identified by the closeness to the imaginary axis of the complex
      ++ eigenvalues of the jacobian).
      ++
      ++ It returns two values in the range [0,1].
    systemSizeIF:ODEA -> F
      ++ systemSizeIF(ode) returns the intensity value of the size of
      ++ the system of ODEs.  20 equations corresponds to the neutral
      ++ value.  It returns a value in the range [0,1].
    expenseOfEvaluationIF:ODEA -> F
      ++ expenseOfEvaluationIF(o) returns the intensity value of the 
      ++ cost of evaluating the input ODE.  This is in terms of the number
      ++ of ``operational units''.  It returns a value in the range
      ++ [0,1].\newline\indent{20}
      ++ 400 ``operation units'' -> 0.75 \newline
      ++ 200 ``operation units'' -> 0.5 \newline
      ++ 83 ``operation units'' -> 0.25 \newline\indent{15}
      ++ exponentiation = 4 units , function calls = 10 units.
    accuracyIF:ODEA -> F
      ++ accuracyIF(o) returns the intensity value of the accuracy
      ++ requirements of the input ODE.  A request of accuracy of 10^-6 
      ++ corresponds to the neutral intensity.  It returns a value
      ++ in the range [0,1].
    intermediateResultsIF:ODEA -> F
      ++ intermediateResultsIF(o) returns a value corresponding to the 
      ++ required number of intermediate results required and, therefore, 
      ++ an indication of how much this would affect the step-length of the 
      ++ calculation.  It returns a value in the range [0,1].

  I ==> add

    import ExpertSystemToolsPackage

    accuracyFactor:ODEA -> F
    expenseOfEvaluation:ODEA -> F
    eval1:(LEDF,LEEDF) -> LEDF
    stiffnessAndStabilityOfODE:ODEA -> RSS
    intermediateResultsFactor:ODEA -> F
    leastStabilityAngle:(LDF,LDF) -> F

    intermediateResultsFactor(ode:ODEA):F ==
      resultsRequirement := #(ode.intvals)
      (1.0-exp(-(resultsRequirement::F)/50.0)$F)

    intermediateResultsIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.intermediateResults)$F => 
          s.intermediateResults := intermediateResultsFactor(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.intermediateResults
        s.intermediateResults
      a:ATT := [-1.0,-1.0,-1.0,-1.0,e:=intermediateResultsFactor(ode)]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    accuracyFactor(ode:ODEA):F ==
      accuracyRequirements := convert(ode.abserr)@F
      if zero?(accuracyRequirements) then
        accuracyRequirements := convert(ode.relerr)@F
      val := inv(accuracyRequirements)$F
      n := log10(val)$F
      (1.0-exp(-(n/(2.0))**2/(15.0))$F)

    accuracyIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.accuracy)$F => 
          s.accuracy := accuracyFactor(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.accuracy
        s.accuracy
      a:ATT := [-1.0,-1.0,-1.0,e:=accuracyFactor(ode),-1.0]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    systemSizeIF(ode:ODEA):F ==
      n := #(ode.fn)
      (1.0-exp((-n::F/75.0))$F)

    expenseOfEvaluation(o:ODEA):F ==
      -- expense of evaluation of an ODE -- <0.3 inexpensive - 0.5 neutral - >0.7 very expensive
      -- 400 `operation units' -> 0.75 
      -- 200 `operation units' -> 0.5 
      -- 83 `operation units' -> 0.25
      -- ** = 4 units , function calls = 10 units.
      ode := copy o.fn
      expenseOfEvaluation(ode)

    expenseOfEvaluationIF(o:ODEA):F ==
      ode := copy o
      (t := showIntensityFunctions(ode)$ODEIntensityFunctionsTable) case ATT =>
        s := coerce(t)@ATT
        negative?(s.expense)$F => 
          s.expense := expenseOfEvaluation(ode)
          r:ROA := [ode,s]
          insert!(r)$ODEIntensityFunctionsTable
          s.expense
        s.expense
      a:ATT := [-1.0,-1.0,e:=expenseOfEvaluation(ode),-1.0,-1.0]
      r:ROA := [ode,a]
      insert!(r)$ODEIntensityFunctionsTable
      e

    leastStabilityAngle(realPartsList:LDF,imagPartsList:LDF):F ==
      complexList := [complex(u,v)$CDF for u in realPartsList for v in imagPartsList]
      argumentList := [abs((abs(argument(u)$CDF)$DF)-(pi()$DF)/2)$DF for u in complexList]
      sortedArgumentList := sort(argumentList)$LDF
      list := [u for u in sortedArgumentList | not zero?(u) ]
      empty?(list)$LDF => 0$F
      convert(first(list)$LDF)@F

    stiffnessAndStabilityFactor(me:MEDF):RSS ==

      -- search first for real eigenvalues of the jacobian (symbolically)
      -- if the system isn't too big
      r:INT := ncols(me)$MEDF  
      b:Boolean := ((# me) < 150)
      if b then
        mc:MFI := map(edf2fi,me)$ExpertSystemToolsPackage2(EDF,FI)
        e:LFI := realEigenvalues(mc,1/100)$NumericRealEigenPackage(FI)
        b := ((# e) >= r-1)@Boolean       
      b =>
        -- if all the eigenvalues are real, find negative ones
        e := sort(neglist(e)$ExpertSystemToolsPackage1(FI))
        -- if there are two or more, calculate stiffness ratio
        ((n:=#e)>1)@Boolean => [coerce(e.1/e.n)@F,0$F] 
        -- otherwise stiffness not present
        [0$F,0$F]

      md:MDF := map(edf2df,me)$ExpertSystemToolsPackage2(EDF,DF)

      -- otherwise calculate numerically the complex eigenvalues
      -- using NAG routine f02aff.

      res:Result := f02aff(r,r,md,-1)$NagEigenPackage
      realParts:Union(Any,"failed") := search(rr::Symbol,res)$Result
      realParts case "failed" => [0$F,0$F]
      realPartsMatrix:MDF := retract(realParts)$AnyFunctions1(MDF) -- array === matrix
      imagParts:Union(Any,"failed") := search(ri::Symbol,res)$Result
      imagParts case "failed" => [0$F,0$F]
      imagPartsMatrix:MDF := retract(imagParts)$AnyFunctions1(MDF) -- array === matrix
      imagPartsList:LDF := members(imagPartsMatrix)$MDF
      realPartsList:LDF := members(realPartsMatrix)$MDF
      stabilityAngle := leastStabilityAngle(realPartsList,imagPartsList)
      negRealPartsList := sort(neglist(realPartsList)$ExpertSystemToolsPackage1(DF))
      empty?(negRealPartsList)$LDF => [0$F,stabilityAngle]
      ((n:=#negRealPartsList)>1)@Boolean => 
        out := convert(negRealPartsList.1/negRealPartsList.n)@F
        [out,stabilityAngle]    -- calculate stiffness ratio
      [-convert(negRealPartsList.1)@F,stabilityAngle]
      
    eval1(l:LEDF,e:LEEDF):LEDF ==
      [eval(u,e)$EDF for u in l]

    eval(mat:MEDF,symbols:LS,values:VEDF):MEDF ==
      l := listOfLists(mat)
      ledf := entries(values)$VEDF
      e := [equation(u::EDF,v)$EEDF for u in symbols for v in ledf]
      l := [eval1(w,e) for w in l]
      matrix l

    combineFeatureCompatibility(C1:F,C2:F):F ==

      --                        C1 C2
      --    s(C1,C2) = -----------------------
      --               C1 C2 + (1 - C1)(1 - C2)

      C1*C2/((C1*C2)+(1$F-C1)*(1$F-C2))

    combineFeatureCompatibility(C1:F,L:LF):F ==

      empty?(L)$LF => C1
      C2 := combineFeatureCompatibility(C1,first(L)$LF)
      combineFeatureCompatibility(C2,rest(L)$LF)

    jacobian(v:VEDF,w:LS):Matrix EDF ==
      jacobian(v,w)$MultiVariableCalculusFunctions(S,EDF,VEDF,LS)

    sparsityIF(m:Matrix EDF):F ==
      l:LEDF :=parts m
      z:LEDF := [u for u in l | zero?(u)$EDF]
      ((#z)::F/(#l)::F)

    sum(a:EDF,b:EDF):EDF == a+b

    stiffnessAndStabilityOfODE(ode:ODEA):RSS ==
      odefns := copy ode.fn
      ls:LS := [subscript(Y,[coerce(n)])$Symbol for n in 1..# odefns]
      yvals := copy ode.yinit
      for i in 1..#yvals repeat
        zero?(yvals.i) => yvals.i := 0.1::DF
      yexpr := [coerce(v)@EDF for v in yvals]
      yv:VEDF := vector(yexpr)
      j1:MEDF := jacobian(odefns,ls)
      ej1:MEDF := eval(j1,ls,yv)
      ej1 := eval(ej1,variables(reduce(sum,members(ej1)$MEDF)),vector([(ode.xinit)::EDF]))
      ssf := stiffnessAndStabilityFactor(ej1)
      stability := 1.0-sqrt((ssf.stabilityFactor)*(2.0)/(pi()$F))
      stiffness := (1.0)-exp(-(ssf.stiffnessFactor)/(500.0))
      [stiffness,stability]

    stiffnessAndStabilityOfODEIF(ode:ODEA):RSS ==
      odefn := copy ode
      (t := showIntensityFunctions(odefn)$ODEIntensityFunctionsTable) case ATT =>
        s:ATT := coerce(t)@ATT
        negative?(s.stiffness)$F => 
          ssf:RSS := stiffnessAndStabilityOfODE(odefn)
          s := [ssf.stiffnessFactor,ssf.stabilityFactor,s.expense,
                  s.accuracy,s.intermediateResults]
          r:ROA := [odefn,s]
          insert!(r)$ODEIntensityFunctionsTable
          ssf
        [s.stiffness,s.stability]
      ssf:RSS := stiffnessAndStabilityOfODE(odefn)
      s:ATT := [ssf.stiffnessFactor,ssf.stabilityFactor,-1.0,-1.0,-1.0]
      r:ROA := [odefn,s]
      insert!(r)$ODEIntensityFunctionsTable
      ssf

@
<<D02AGNT.dotabb>>=
"D02AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D02AGNT"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"D02AGNT" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package D03AGNT d03AgentsPackage}
\pagehead{d03AgentsPackage}{D03AGNT}
\pagepic{ps/v104d03agentspackage.ps}{D03AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package D03AGNT d03AgentsPackage>>=
)abbrev package D03AGNT d03AgentsPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: December 1997
++ Basic Operations: 
++ Description:
++ \axiom{d03AgentsPackage} contains a set of computational agents 
++ for use with Partial Differential Equation solvers.
LEDF	==> List Expression DoubleFloat
EDF	==> Expression DoubleFloat
MDF	==> Matrix DoubleFloat
DF	==> DoubleFloat
F	==> Float
INT	==> Integer
NNI	==> NonNegativeInteger
EEDF	==> Equation Expression DoubleFloat
LEEDF	==> List Equation Expression DoubleFloat
LDF	==> List DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LS	==> List Symbol
PDEC	==> Record(start:DF, finish:DF, grid:NNI, boundaryType:INT,
                    dStart:MDF, dFinish:MDF)
PDEB	==> Record(pde:LEDF, constraints:List PDEC,
                    f:List LEDF, st:String, tol:DF)
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)

d03AgentsPackage(): E == I where
  E ==>  with
    varList:(Symbol,NonNegativeInteger) -> LS
      ++ varList(s,n) \undocumented{}
    subscriptedVariables:EDF -> EDF
      ++ subscriptedVariables(e) \undocumented{}
    central?:(DF,DF,LEDF) -> Boolean
      ++ central?(f,g,l) \undocumented{}
    elliptic?:PDEB -> Boolean    
      ++ elliptic?(r) \undocumented{}

  I ==> add

    import ExpertSystemToolsPackage

    sum(a:EDF,b:EDF):EDF == a+b

    varList(s:Symbol,n:NonNegativeInteger):LS ==
      [subscript(s,[t::OutputForm]) for t in expand([1..n])$Segment(Integer)]

    subscriptedVariables(e:EDF):EDF ==
      oldVars:List Symbol := variables(e)
      o := [a :: EDF for a in oldVars]
      newVars := varList(X::Symbol,# oldVars)
      n := [b :: EDF for b in newVars]
      subst(e,[a=b for a in o for b in n])

    central?(x:DF,y:DF,p:LEDF):Boolean ==
      ls := variables(reduce(sum,p))
      le := [equation(u::EDF,v)$EEDF for u in ls for v in [x::EDF,y::EDF]]
      l := [eval(u,le)$EDF for u in p]
      max(l.4,l.5) < 20 * max(l.1,max(l.2,l.3))

    elliptic?(args:PDEB):Boolean ==
      (args.st)="elliptic" => true
      p := args.pde
      xcon:PDEC := first(args.constraints)
      ycon:PDEC := second(args.constraints)
      xs := xcon.start
      ys := ycon.start
      xf := xcon.finish
      yf := ycon.finish
      xstart:DF := ((xf-xs)/2)$DF
      ystart:DF := ((yf-ys)/2)$DF
      optStart:LDF := [xstart,ystart]
      lower:LOCDF := [xs::OCDF,ys::OCDF]
      upper:LOCDF := [xf::OCDF,yf::OCDF]
      v := variables(e := 4*first(p)*third(p)-(second(p))**2)
      eq := subscriptedVariables(e)
      noa:NOA := 
--        one?(# v) =>
        (# v) = 1 =>
          ((first v) = X@Symbol) => 
            [eq,[xstart],[xs::OCDF],empty()$LEDF,[xf::OCDF]]
          [eq,[ystart],[ys::OCDF],empty()$LEDF,[yf::OCDF]]
        [eq,optStart,lower,empty()$LEDF,upper]
      ell := optimize(noa::NumericalOptimizationProblem)$AnnaNumericalOptimizationPackage
      o:Union(Any,"failed") := search(objf::Symbol,ell)$Result
      o case "failed" => false
      ob := o :: Any
      obj:DF := retract(ob)$AnyFunctions1(DF)
      positive?(obj)

@
<<D03AGNT.dotabb>>=
"D03AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=D03AGNT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"D03AGNT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EP EigenPackage}
\pagehead{EigenPackage}{EP}
\pagepic{ps/v104eigenpackage.ps}{EP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EP EigenPackage>>=
)abbrev package EP EigenPackage
++ Author: P. Gianni
++ Date Created: summer 1986
++ Date Last Updated: October 1992
++ Basic Functions:
++ Related Constructors: NumericRealEigenPackage,  NumericComplexEigenPackage,
++ RadicalEigenPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This is a package for the exact computation of eigenvalues and eigenvectors.
++ This package can be made to work for matrices with coefficients which are
++ rational functions over a ring where we can factor polynomials.
++ Rational eigenvalues are always explicitly computed while the
++ non-rational ones are expressed in terms of their minimal
++ polynomial.
-- Functions for the numeric computation of eigenvalues and eigenvectors
-- are in numeigen spad.
EigenPackage(R) : C == T
 where
   R     : GcdDomain
   P     ==> Polynomial R
   F     ==> Fraction P
   SE    ==> Symbol()
   SUP   ==> SparseUnivariatePolynomial(P)
   SUF   ==> SparseUnivariatePolynomial(F)
   M     ==> Matrix(F)
   NNI   ==> NonNegativeInteger
   ST    ==> SuchThat(SE,P)

   Eigenvalue  ==> Union(F,ST)
   EigenForm   ==> Record(eigval:Eigenvalue,eigmult:NNI,eigvec : List M)
   GenEigen    ==> Record(eigval:Eigenvalue,geneigvec:List M)

   C == with
     characteristicPolynomial :  (M,Symbol)  ->  P
       ++ characteristicPolynomial(m,var) returns the
       ++ characteristicPolynomial of the matrix m using
       ++ the symbol var as the main variable.

     characteristicPolynomial :      M       ->  P
       ++ characteristicPolynomial(m) returns the
       ++ characteristicPolynomial of the matrix m using
       ++ a new generated symbol symbol as the main variable.

     eigenvalues       :    M        ->  List Eigenvalue
       ++ eigenvalues(m) returns the
       ++ eigenvalues of the matrix m which are expressible
       ++ as rational functions over the rational numbers.

     eigenvector       :   (Eigenvalue,M)  ->  List M
       ++ eigenvector(eigval,m) returns the
       ++ eigenvectors belonging to the eigenvalue eigval
       ++ for the matrix m.

     generalizedEigenvector  : (Eigenvalue,M,NNI,NNI) -> List M
       ++ generalizedEigenvector(alpha,m,k,g)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue alpha.
       ++ The integers k and g are respectively the algebraic and the
       ++ geometric multiplicity of tye eigenvalue alpha.
       ++ alpha can be either rational or not.
       ++ In the seconda case apha is the minimal polynomial of the
       ++ eigenvalue.

     generalizedEigenvector  : (EigenForm,M) -> List M
       ++ generalizedEigenvector(eigen,m)
       ++ returns the generalized eigenvectors
       ++ of the matrix relative to the eigenvalue eigen, as 
       ++ returned by the function eigenvectors.

     generalizedEigenvectors  : M -> List GenEigen
       ++ generalizedEigenvectors(m)
       ++ returns the generalized eigenvectors
       ++ of the matrix m.

     eigenvectors      :    M        ->  List(EigenForm)
       ++ eigenvectors(m) returns the eigenvalues and eigenvectors
       ++ for the matrix m.
       ++ The rational eigenvalues and the correspondent eigenvectors
       ++ are explicitely computed, while the non rational ones
       ++ are given via their minimal polynomial and the corresponding
       ++ eigenvectors are expressed in terms of a "generic" root of
       ++ such a polynomial.

   T == add
     PI       ==> PositiveInteger


     MF  := GeneralizedMultivariateFactorize(SE,IndexedExponents SE,R,R,P)
     UPCF2:= UnivariatePolynomialCategoryFunctions2(P,SUP,F,SUF)
    

                 ----  Local  Functions  ----
     tff              :  (SUF,SE)      ->  F
     fft              :  (SUF,SE)      ->  F
     charpol          :   (M,SE)       ->   F
     intRatEig        :  (F,M,NNI)    ->   List M
     intAlgEig        :  (ST,M,NNI)    ->   List M 
     genEigForm       : (EigenForm,M)  ->   GenEigen

    ---- next functions needed for defining  ModularField ----
     reduction(u:SUF,p:SUF):SUF == u rem p

     merge(p:SUF,q:SUF):Union(SUF,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

     exactquo(u:SUF,v:SUF,p:SUF):Union(SUF,"failed") ==
        val:=extendedEuclidean(v,p,u)
        val case "failed" => "failed"
        val.coef1

               ----  functions for conversions  ----
     fft(t:SUF,x:SE):F ==
       n:=degree(t)
       cf:=monomial(1,x,n)$P :: F
       cf * leadingCoefficient t

     tff(p:SUF,x:SE) : F ==
       degree p=0 => leadingCoefficient p
       r:F:=0$F
       while p^=0 repeat
         r:=r+fft(p,x)
         p := reductum p
       r

      ---- generalized eigenvectors associated to a given eigenvalue ---       
     genEigForm(eigen : EigenForm,A:M) : GenEigen ==
       alpha:=eigen.eigval
       k:=eigen.eigmult
       g:=#(eigen.eigvec)
       k = g  => [alpha,eigen.eigvec]
       [alpha,generalizedEigenvector(alpha,A,k,g)]

           ---- characteristic polynomial  ----
     charpol(A:M,x:SE) : F ==
       dimA :PI := (nrows A):PI
       dimA ^= ncols A => error " The matrix is not square"
       B:M:=zero(dimA,dimA)
       for i in 1..dimA repeat
         for j in 1..dimA repeat  B(i,j):=A(i,j)
         B(i,i) := B(i,i) - monomial(1$P,x,1)::F
       determinant B

          --------  EXPORTED  FUNCTIONS  --------
   
            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:M):P ==
       x:SE:=new()$SE
       numer charpol(A,x)

            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:M,x:SE) : P == numer charpol(A,x)
     
                ----  Eigenvalues of the matrix A  ----
     eigenvalues(A:M): List Eigenvalue  ==
       x:=new()$SE
       pol:= charpol(A,x)
       lrat:List F :=empty()
       lsym:List ST :=empty()
       for eq in solve(pol,x)$SystemSolvePackage(R) repeat
         alg:=numer lhs eq
         degree(alg, x)=1 => lrat:=cons(rhs eq,lrat)
         lsym:=cons([x,alg],lsym)
       append([lr::Eigenvalue for lr in lrat],
              [ls::Eigenvalue for ls in lsym])

          ----  Eigenvectors belonging to a given eigenvalue  ----
                ----  the eigenvalue must be exact  ----
     eigenvector(alpha:Eigenvalue,A:M) : List M  ==
       alpha case F => intRatEig(alpha::F,A,1$NNI)
       intAlgEig(alpha::ST,A,1$NNI)

   ----  Eigenvectors belonging to a given rational eigenvalue  ----
                ---- Internal function -----
     intRatEig(alpha:F,A:M,m:NNI) : List M  ==
       n:=nrows A
       B:M := zero(n,n)$M
       for i in 1..n repeat
         for j in 1..n repeat B(i,j):=A(i,j)
         B(i,i):= B(i,i) - alpha
       [v::M for v in nullSpace(B**m)]
   
   ----  Eigenvectors belonging to a given algebraic eigenvalue  ----
         ------   Internal  Function  -----
     intAlgEig(alpha:ST,A:M,m:NNI) : List M  ==
       n:=nrows A
       MM := ModularField(SUF,SUF,reduction,merge,exactquo)
       AM:=Matrix MM
       x:SE:=lhs alpha
       pol:SUF:=unitCanonical map(coerce,univariate(rhs alpha,x))$UPCF2
       alg:MM:=reduce(monomial(1,1),pol)
       B:AM := zero(n,n)
       for i in 1..n repeat
         for j in 1..n repeat B(i,j):=reduce(A(i,j)::SUF,pol)
         B(i,i):= B(i,i) - alg
       sol: List M :=empty()
       for vec in nullSpace(B**m) repeat
         w:M:=zero(n,1)
         for i in 1..n repeat w(i,1):=tff((vec.i)::SUF,x)
         sol:=cons(w,sol)
       sol

     ----  Generalized Eigenvectors belonging to a given eigenvalue  ----
     generalizedEigenvector(alpha:Eigenvalue,A:M,k:NNI,g:NNI) : List M  ==
       alpha case F => intRatEig(alpha::F,A,(1+k-g)::NNI)
       intAlgEig(alpha::ST,A,(1+k-g)::NNI)

     ----  Generalized Eigenvectors belonging to a given eigenvalue  ----
     generalizedEigenvector(eigen :EigenForm,A:M) : List M  ==
       generalizedEigenvector(eigen.eigval,A,eigen.eigmult,# eigen.eigvec)

          ----  Generalized Eigenvectors -----
     generalizedEigenvectors(A:M) : List GenEigen  ==
       n:= nrows A
       leig:=eigenvectors A
       [genEigForm(leg,A) for leg in leig]
         
                 ----  eigenvectors and eigenvalues  ----
     eigenvectors(A:M):List(EigenForm) ==
       n:=nrows A
       x:=new()$SE
       p:=numer charpol(A,x)
       MM := ModularField(SUF,SUF,reduction,merge,exactquo)
       AM:=Matrix(MM)
       ratSol : List EigenForm := empty()
       algSol : List EigenForm := empty()
       lff:=factors factor  p
       for fact in lff repeat
         pol:=fact.factor   
         degree(pol,x)=1 =>
           vec:F :=-coefficient(pol,x,0)/coefficient(pol,x,degree(pol,x))
           ratSol:=cons([vec,fact.exponent :: NNI,
                         intRatEig(vec,A,1$NNI)]$EigenForm,ratSol)
         alpha:ST:=[x,pol]     
         algSol:=cons([alpha,fact.exponent :: NNI,
                       intAlgEig(alpha,A,1$NNI)]$EigenForm,algSol)
       append(ratSol,algSol)

@
<<EP.dotabb>>=
"EP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EP"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"EP" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EF ElementaryFunction}
\pagehead{ElementaryFunction}{EF}
\pagepic{ps/v104elementaryfunction.ps}{EF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EF ElementaryFunction>>=
)abbrev package EF ElementaryFunction
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 10 April 1995
++ Keywords: elementary, function, logarithm, exponential.
++ Examples:  )r EF INPUT
++ Description: Provides elementary functions over an integral domain.
ElementaryFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: Join(FunctionSpace R, RadicalCategory)

  B   ==> Boolean
  L   ==> List
  Z   ==> Integer
  OP  ==> BasicOperator
  K   ==> Kernel F
  INV ==> error "Invalid argument"

  Exports ==> with
    exp     : F -> F
	++ exp(x) applies the exponential operator to x
    log     : F -> F
	++ log(x) applies the logarithm operator to x
    sin     : F -> F
	++ sin(x) applies the sine operator to x
    cos     : F -> F
	++ cos(x) applies the cosine operator to x 
    tan     : F -> F
	++ tan(x) applies the tangent operator to x
    cot     : F -> F
	++ cot(x) applies the cotangent operator to x
    sec     : F -> F
	++ sec(x) applies the secant operator to x
    csc     : F -> F
	++ csc(x) applies the cosecant operator to x
    asin    : F -> F
	++ asin(x) applies the inverse sine operator to x 
    acos    : F -> F
	++ acos(x) applies the inverse cosine operator to x
    atan    : F -> F
	++ atan(x) applies the inverse tangent operator to x
    acot    : F -> F
	++ acot(x) applies the inverse cotangent operator to x
    asec    : F -> F
	++ asec(x) applies the inverse secant operator to x
    acsc    : F -> F
	++ acsc(x) applies the inverse cosecant operator to x
    sinh    : F -> F
	++ sinh(x) applies the hyperbolic sine operator to x 
    cosh    : F -> F
	++ cosh(x) applies the hyperbolic cosine operator to x
    tanh    : F -> F
	++ tanh(x) applies the hyperbolic tangent operator to x
    coth    : F -> F
	++ coth(x) applies the hyperbolic cotangent operator to x
    sech    : F -> F
	++ sech(x) applies the hyperbolic secant operator to x
    csch    : F -> F
	++ csch(x) applies the hyperbolic cosecant operator to x
    asinh   : F -> F
	++ asinh(x) applies the inverse hyperbolic sine operator to x
    acosh   : F -> F
	++ acosh(x) applies the inverse hyperbolic cosine operator to x
    atanh   : F -> F
	++ atanh(x) applies the inverse hyperbolic tangent operator to x
    acoth   : F -> F
	++ acoth(x) applies the inverse hyperbolic cotangent operator to x
    asech   : F -> F
	++ asech(x) applies the	inverse hyperbolic secant operator to x
    acsch   : F -> F
	++ acsch(x) applies the inverse hyperbolic cosecant operator to x
    pi      : () -> F
	++ pi() returns the pi operator
    belong? : OP -> Boolean
	++ belong?(p) returns true if operator p is elementary
    operator: OP -> OP
	++ operator(p) returns an elementary operator with the same symbol as p
    -- the following should be local, but are conditional
    iisqrt2   : () -> F
	++ iisqrt2() should be local but conditional
    iisqrt3   : () -> F
	++ iisqrt3() should be local but conditional
    iiexp     : F -> F
	++ iiexp(x) should be local but conditional
    iilog     : F -> F
	++ iilog(x) should be local but conditional
    iisin     : F -> F
	++ iisin(x) should be local but conditional
    iicos     : F -> F
	++ iicos(x) should be local but conditional
    iitan     : F -> F
	++ iitan(x) should be local but conditional
    iicot     : F -> F
	++ iicot(x) should be local but conditional
    iisec     : F -> F
	++ iisec(x) should be local but conditional
    iicsc     : F -> F
	++ iicsc(x) should be local but conditional
    iiasin    : F -> F
	++ iiasin(x) should be local but conditional
    iiacos    : F -> F
	++ iiacos(x) should be local but conditional
    iiatan    : F -> F
	++ iiatan(x) should be local but conditional
    iiacot    : F -> F
	++ iiacot(x) should be local but conditional
    iiasec    : F -> F
	++ iiasec(x) should be local but conditional
    iiacsc    : F -> F
	++ iiacsc(x) should be local but conditional
    iisinh    : F -> F
	++ iisinh(x) should be local but conditional
    iicosh    : F -> F
	++ iicosh(x) should be local but conditional
    iitanh    : F -> F
	++ iitanh(x) should be local but conditional
    iicoth    : F -> F
	++ iicoth(x) should be local but conditional
    iisech    : F -> F
	++ iisech(x) should be local but conditional
    iicsch    : F -> F
	++ iicsch(x) should be local but conditional
    iiasinh   : F -> F
	++ iiasinh(x) should be local but conditional
    iiacosh   : F -> F
	++ iiacosh(x) should be local but conditional
    iiatanh   : F -> F
	++ iiatanh(x) should be local but conditional
    iiacoth   : F -> F
	++ iiacoth(x) should be local but conditional
    iiasech   : F -> F
	++ iiasech(x) should be local but conditional
    iiacsch   : F -> F
	++ iiacsch(x) should be local but conditional
    specialTrigs:(F, L Record(func:F,pole:B)) -> Union(F, "failed")
	++ specialTrigs(x,l) should be local but conditional
    localReal?: F -> Boolean
	++ localReal?(x) should be local but conditional

  Implementation ==> add
    ipi      : List F -> F
    iexp     : F -> F
    ilog     : F -> F
    iiilog   : F -> F
    isin     : F -> F
    icos     : F -> F
    itan     : F -> F
    icot     : F -> F
    isec     : F -> F
    icsc     : F -> F
    iasin    : F -> F
    iacos    : F -> F
    iatan    : F -> F
    iacot    : F -> F
    iasec    : F -> F
    iacsc    : F -> F
    isinh    : F -> F
    icosh    : F -> F
    itanh    : F -> F
    icoth    : F -> F
    isech    : F -> F
    icsch    : F -> F
    iasinh   : F -> F
    iacosh   : F -> F
    iatanh   : F -> F
    iacoth   : F -> F
    iasech   : F -> F
    iacsch   : F -> F
    dropfun  : F -> F
    kernel   : F -> K
    posrem   :(Z, Z) -> Z
    iisqrt1  : () -> F
    valueOrPole : Record(func:F, pole:B) -> F

    oppi  := operator("pi"::Symbol)$CommonOperators
    oplog := operator("log"::Symbol)$CommonOperators
    opexp := operator("exp"::Symbol)$CommonOperators
    opsin := operator("sin"::Symbol)$CommonOperators
    opcos := operator("cos"::Symbol)$CommonOperators
    optan := operator("tan"::Symbol)$CommonOperators
    opcot := operator("cot"::Symbol)$CommonOperators
    opsec := operator("sec"::Symbol)$CommonOperators
    opcsc := operator("csc"::Symbol)$CommonOperators
    opasin := operator("asin"::Symbol)$CommonOperators
    opacos := operator("acos"::Symbol)$CommonOperators
    opatan := operator("atan"::Symbol)$CommonOperators
    opacot := operator("acot"::Symbol)$CommonOperators
    opasec := operator("asec"::Symbol)$CommonOperators
    opacsc := operator("acsc"::Symbol)$CommonOperators
    opsinh := operator("sinh"::Symbol)$CommonOperators
    opcosh := operator("cosh"::Symbol)$CommonOperators
    optanh := operator("tanh"::Symbol)$CommonOperators
    opcoth := operator("coth"::Symbol)$CommonOperators
    opsech := operator("sech"::Symbol)$CommonOperators
    opcsch := operator("csch"::Symbol)$CommonOperators
    opasinh := operator("asinh"::Symbol)$CommonOperators
    opacosh := operator("acosh"::Symbol)$CommonOperators
    opatanh := operator("atanh"::Symbol)$CommonOperators
    opacoth := operator("acoth"::Symbol)$CommonOperators
    opasech := operator("asech"::Symbol)$CommonOperators
    opacsch := operator("acsch"::Symbol)$CommonOperators

    -- Pi is a domain...
    Pie, isqrt1, isqrt2, isqrt3: F

    -- following code is conditionalized on arbitraryPrecesion to recompute in
    -- case user changes the precision

    if R has TranscendentalFunctionCategory then
      Pie := pi()$R :: F
    else
      Pie := kernel(oppi, nil()$List(F))

    if R has TranscendentalFunctionCategory and R has arbitraryPrecision then
      pi() == pi()$R :: F
    else
      pi() == Pie

    if R has imaginary: () -> R then
      isqrt1 := imaginary()$R :: F
    else isqrt1 := sqrt(-1::F)

    if R has RadicalCategory then
      isqrt2 := sqrt(2::R)::F
      isqrt3 := sqrt(3::R)::F
    else
      isqrt2 := sqrt(2::F)
      isqrt3 := sqrt(3::F)

    iisqrt1() == isqrt1
    if R has RadicalCategory and R has arbitraryPrecision then
      iisqrt2() == sqrt(2::R)::F
      iisqrt3() == sqrt(3::R)::F
    else
      iisqrt2() == isqrt2
      iisqrt3() == isqrt3

    ipi l == pi()
    log x == oplog x
    exp x == opexp x
    sin x == opsin x
    cos x == opcos x
    tan x == optan x
    cot x == opcot x
    sec x == opsec x
    csc x == opcsc x
    asin x == opasin x
    acos x == opacos x
    atan x == opatan x
    acot x == opacot x
    asec x == opasec x
    acsc x == opacsc x
    sinh x == opsinh x
    cosh x == opcosh x
    tanh x == optanh x
    coth x == opcoth x
    sech x == opsech x
    csch x == opcsch x
    asinh x == opasinh x
    acosh x == opacosh x
    atanh x == opatanh x
    acoth x == opacoth x
    asech x == opasech x
    acsch x == opacsch x
    kernel x == retract(x)@K

    posrem(n, m)    == ((r := n rem m) < 0 => r + m; r)
    valueOrPole rec == (rec.pole => INV; rec.func)
    belong? op      == has?(op, "elem")

    operator op ==
      is?(op, "pi"::Symbol)    => oppi
      is?(op, "log"::Symbol)   => oplog
      is?(op, "exp"::Symbol)   => opexp
      is?(op, "sin"::Symbol)   => opsin
      is?(op, "cos"::Symbol)   => opcos
      is?(op, "tan"::Symbol)   => optan
      is?(op, "cot"::Symbol)   => opcot
      is?(op, "sec"::Symbol)   => opsec
      is?(op, "csc"::Symbol)   => opcsc
      is?(op, "asin"::Symbol)  => opasin
      is?(op, "acos"::Symbol)  => opacos
      is?(op, "atan"::Symbol)  => opatan
      is?(op, "acot"::Symbol)  => opacot
      is?(op, "asec"::Symbol)  => opasec
      is?(op, "acsc"::Symbol)  => opacsc
      is?(op, "sinh"::Symbol)  => opsinh
      is?(op, "cosh"::Symbol)  => opcosh
      is?(op, "tanh"::Symbol)  => optanh
      is?(op, "coth"::Symbol)  => opcoth
      is?(op, "sech"::Symbol)  => opsech
      is?(op, "csch"::Symbol)  => opcsch
      is?(op, "asinh"::Symbol) => opasinh
      is?(op, "acosh"::Symbol) => opacosh
      is?(op, "atanh"::Symbol) => opatanh
      is?(op, "acoth"::Symbol) => opacoth
      is?(op, "asech"::Symbol) => opasech
      is?(op, "acsch"::Symbol) => opacsch
      error "Not an elementary operator"

    dropfun x ==
      ((k := retractIfCan(x)@Union(K, "failed")) case "failed") or
        empty?(argument(k::K)) => 0
      first argument(k::K)

    if R has RetractableTo Z then
      specialTrigs(x, values) ==
        (r := retractIfCan(y := x/pi())@Union(Fraction Z, "failed"))
          case "failed" => "failed"
        q := r::Fraction(Integer)
        m := minIndex values
        (n := retractIfCan(q)@Union(Z, "failed")) case Z =>
          even?(n::Z) => valueOrPole(values.m)
          valueOrPole(values.(m+1))
        (n := retractIfCan(2*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 4)) => valueOrPole(values.(m+2))
          (s := posrem(n::Z, 4)) = 1 => valueOrPole(values.(m+2))
          valueOrPole(values.(m+3))
        (n := retractIfCan(3*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 6)) => valueOrPole(values.(m+4))
          (s := posrem(n::Z, 6)) = 1 => valueOrPole(values.(m+4))
          s = 2 => valueOrPole(values.(m+5))
          s = 4 => valueOrPole(values.(m+6))
          valueOrPole(values.(m+7))
        (n := retractIfCan(4*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 8)) => valueOrPole(values.(m+8))
          (s := posrem(n::Z, 8)) = 1 => valueOrPole(values.(m+8))
          s = 3 => valueOrPole(values.(m+9))
          s = 5 => valueOrPole(values.(m+10))
          valueOrPole(values.(m+11))
        (n := retractIfCan(6*q)@Union(Z, "failed")) case Z =>
--          one?(s := posrem(n::Z, 12)) => valueOrPole(values.(m+12))
          (s := posrem(n::Z, 12)) = 1 => valueOrPole(values.(m+12))
          s = 5 => valueOrPole(values.(m+13))
          s = 7 => valueOrPole(values.(m+14))
          valueOrPole(values.(m+15))
        "failed"

    else specialTrigs(x, values) == "failed"

    isin x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasin) => y
      is?(x, opacos) => sqrt(1 - y**2)
      is?(x, opatan) => y / sqrt(1 + y**2)
      is?(x, opacot) => inv sqrt(1 + y**2)
      is?(x, opasec) => sqrt(y**2 - 1) / y
      is?(x, opacsc) => inv y
      h  := inv(2::F)
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x, [[0,false], [0,false], [1,false], [-1,false],
                         [s3,false], [s3,false], [-s3,false], [-s3,false],
                          [s2,false], [s2,false], [-s2,false], [-s2,false],
                           [h,false], [h,false], [-h,false], [-h,false]])
      u case F => u :: F
      kernel(opsin, x)

    icos x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasin) => sqrt(1 - y**2)
      is?(x, opacos) => y
      is?(x, opatan) => inv sqrt(1 + y**2)
      is?(x, opacot) => y / sqrt(1 + y**2)
      is?(x, opasec) => inv y
      is?(x, opacsc) => sqrt(y**2 - 1) / y
      h  := inv(2::F)
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x, [[1,false],[-1,false], [0,false], [0,false],
                             [h,false],[-h,false],[-h,false],[h,false],
                              [s2,false],[-s2,false],[-s2,false],[s2,false],
                               [s3,false], [-s3,false],[-s3,false],[s3,false]])
      u case F => u :: F
      kernel(opcos, x)

    itan x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasin) => y / sqrt(1 - y**2)
      is?(x, opacos) => sqrt(1 - y**2) / y
      is?(x, opatan) => y
      is?(x, opacot) => inv y
      is?(x, opasec) => sqrt(y**2 - 1)
      is?(x, opacsc) => inv sqrt(y**2 - 1)
      s33 := (s3 := iisqrt3()) / (3::F)
      u := specialTrigs(x, [[0,false], [0,false], [0,true], [0,true],
                      [s3,false], [-s3,false], [s3,false], [-s3,false],
                       [1,false], [-1,false], [1,false], [-1,false],
                        [s33,false], [-s33, false], [s33,false], [-s33, false]])
      u case F => u :: F
      kernel(optan, x)

    icot x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasin) => sqrt(1 - y**2) / y
      is?(x, opacos) => y / sqrt(1 - y**2)
      is?(x, opatan) => inv y
      is?(x, opacot) => y
      is?(x, opasec) => inv sqrt(y**2 - 1)
      is?(x, opacsc) => sqrt(y**2 - 1)
      s33 := (s3 := iisqrt3()) / (3::F)
      u := specialTrigs(x, [[0,true], [0,true], [0,false], [0,false],
                         [s33,false], [-s33,false], [s33,false], [-s33,false],
                          [1,false], [-1,false], [1,false], [-1,false],
                           [s3,false], [-s3, false], [s3,false], [-s3, false]])
      u case F => u :: F
      kernel(opcot, x)

    isec x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasin) => inv sqrt(1 - y**2)
      is?(x, opacos) => inv y
      is?(x, opatan) => sqrt(1 + y**2)
      is?(x, opacot) => sqrt(1 + y**2) / y
      is?(x, opasec) => y
      is?(x, opacsc) => y / sqrt(y**2 - 1)
      s2 := iisqrt2()
      s3 := 2 * iisqrt3() / (3::F)
      h  := 2::F
      u  := specialTrigs(x, [[1,false],[-1,false],[0,true],[0,true],
                           [h,false], [-h,false], [-h,false], [h,false],
                            [s2,false], [-s2,false], [-s2,false], [s2,false],
                             [s3,false], [-s3,false], [-s3,false], [s3,false]])
      u case F => u :: F
      kernel(opsec, x)

    icsc x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasin) => inv y
      is?(x, opacos) => inv sqrt(1 - y**2)
      is?(x, opatan) => sqrt(1 + y**2) / y
      is?(x, opacot) => sqrt(1 + y**2)
      is?(x, opasec) => y / sqrt(y**2 - 1)
      is?(x, opacsc) => y
      s2 := iisqrt2()
      s3 := 2 * iisqrt3() / (3::F)
      h  := 2::F
      u  := specialTrigs(x, [[0,true], [0,true], [1,false], [-1,false],
                            [s3,false], [s3,false], [-s3,false], [-s3,false],
                              [s2,false], [s2,false], [-s2,false], [-s2,false],
                                 [h,false], [h,false], [-h,false], [-h,false]])
      u case F => u :: F
      kernel(opcsc, x)

    iasin x ==
      zero? x => 0
--      one? x =>   pi() / (2::F)
      (x = 1) =>   pi() / (2::F)
      x = -1 => - pi() / (2::F)
      y := dropfun x
      is?(x, opsin) => y
      is?(x, opcos) => pi() / (2::F) - y
      kernel(opasin, x)

    iacos x ==
      zero? x => pi() / (2::F)
--      one? x => 0
      (x = 1) => 0
      x = -1 => pi()
      y := dropfun x
      is?(x, opsin) => pi() / (2::F) - y
      is?(x, opcos) => y
      kernel(opacos, x)

    iatan x ==
      zero? x => 0
--      one? x =>   pi() / (4::F)
      (x = 1) =>   pi() / (4::F)
      x = -1 => - pi() / (4::F)
      x = (r3:=iisqrt3()) => pi() / (3::F)
--      one?(x*r3)          => pi() / (6::F)
      (x*r3) = 1          => pi() / (6::F)
      y := dropfun x
      is?(x, optan) => y
      is?(x, opcot) => pi() / (2::F) - y
      kernel(opatan, x)

    iacot x ==
      zero? x =>   pi() / (2::F)
--      one? x  =>   pi() / (4::F)
      (x = 1)  =>   pi() / (4::F)
      x = -1  =>   3 * pi() / (4::F)
      x = (r3:=iisqrt3())  =>  pi() / (6::F)
      x = -r3              =>  5 * pi() / (6::F)
--      one?(xx:=x*r3)       =>  pi() / (3::F)
      (xx:=x*r3) = 1      =>  pi() / (3::F)
      xx = -1           =>     2* pi() / (3::F)
      y := dropfun x
      is?(x, optan) => pi() / (2::F) - y
      is?(x, opcot) => y
      kernel(opacot, x)

    iasec x ==
      zero? x => INV
--      one? x => 0
      (x = 1) => 0
      x = -1 => pi()
      y := dropfun x
      is?(x, opsec) => y
      is?(x, opcsc) => pi() / (2::F) - y
      kernel(opasec, x)

    iacsc x ==
      zero? x => INV
--      one? x =>   pi() / (2::F)
      (x = 1) =>   pi() / (2::F)
      x = -1 => - pi() / (2::F)
      y := dropfun x
      is?(x, opsec) => pi() / (2::F) - y
      is?(x, opcsc) => y
      kernel(opacsc, x)

    isinh x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasinh) => y
      is?(x, opacosh) => sqrt(y**2 - 1)
      is?(x, opatanh) => y / sqrt(1 - y**2)
      is?(x, opacoth) => - inv sqrt(y**2 - 1)
      is?(x, opasech) => sqrt(1 - y**2) / y
      is?(x, opacsch) => inv y
      kernel(opsinh, x)

    icosh x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasinh) => sqrt(y**2 + 1)
      is?(x, opacosh) => y
      is?(x, opatanh) => inv sqrt(1 - y**2)
      is?(x, opacoth) => y / sqrt(y**2 - 1)
      is?(x, opasech) => inv y
      is?(x, opacsch) => sqrt(y**2 + 1) / y
      kernel(opcosh, x)

    itanh x ==
      zero? x => 0
      y := dropfun x
      is?(x, opasinh) => y / sqrt(y**2 + 1)
      is?(x, opacosh) => sqrt(y**2 - 1) / y
      is?(x, opatanh) => y
      is?(x, opacoth) => inv y
      is?(x, opasech) => sqrt(1 - y**2)
      is?(x, opacsch) => inv sqrt(y**2 + 1)
      kernel(optanh, x)

    icoth x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasinh) => sqrt(y**2 + 1) / y
      is?(x, opacosh) => y / sqrt(y**2 - 1)
      is?(x, opatanh) => inv y
      is?(x, opacoth) => y
      is?(x, opasech) => inv sqrt(1 - y**2)
      is?(x, opacsch) => sqrt(y**2 + 1)
      kernel(opcoth, x)

    isech x ==
      zero? x => 1
      y := dropfun x
      is?(x, opasinh) => inv sqrt(y**2 + 1)
      is?(x, opacosh) => inv y
      is?(x, opatanh) => sqrt(1 - y**2)
      is?(x, opacoth) => sqrt(y**2 - 1) / y
      is?(x, opasech) => y
      is?(x, opacsch) => y / sqrt(y**2 + 1)
      kernel(opsech, x)

    icsch x ==
      zero? x => INV
      y := dropfun x
      is?(x, opasinh) => inv y
      is?(x, opacosh) => inv sqrt(y**2 - 1)
      is?(x, opatanh) => sqrt(1 - y**2) / y
      is?(x, opacoth) => - sqrt(y**2 - 1)
      is?(x, opasech) => y / sqrt(1 - y**2)
      is?(x, opacsch) => y
      kernel(opcsch, x)

    iasinh x ==
      is?(x, opsinh) => first argument kernel x
      kernel(opasinh, x)

    iacosh x ==
      is?(x, opcosh) => first argument kernel x
      kernel(opacosh, x)

    iatanh x ==
      is?(x, optanh) => first argument kernel x
      kernel(opatanh, x)

    iacoth x ==
      is?(x, opcoth) => first argument kernel x
      kernel(opacoth, x)

    iasech x ==
      is?(x, opsech) => first argument kernel x
      kernel(opasech, x)

    iacsch x ==
      is?(x, opcsch) => first argument kernel x
      kernel(opacsch, x)

    iexp x ==
      zero? x => 1
      is?(x, oplog) => first argument kernel x
      x < 0 and empty? variables x => inv iexp(-x)
      h  := inv(2::F)
      i  := iisqrt1()
      s2 := h * iisqrt2()
      s3 := h * iisqrt3()
      u  := specialTrigs(x / i, [[1,false],[-1,false], [i,false], [-i,false],
            [h + i * s3,false], [-h + i * s3, false], [-h - i * s3, false],
             [h - i * s3, false], [s2 + i * s2, false], [-s2 + i * s2, false],
              [-s2 - i * s2, false], [s2 - i * s2, false], [s3 + i * h, false],
               [-s3 + i * h, false], [-s3 - i * h, false], [s3 - i * h, false]])
      u case F => u :: F
      kernel(opexp, x)

-- THIS DETERMINES WHEN TO PERFORM THE log exp f -> f SIMPLIFICATION
-- CURRENT BEHAVIOR:
--     IF R IS COMPLEX(S) THEN ONLY ELEMENTS WHICH ARE RETRACTABLE TO R
--     AND EQUAL TO THEIR CONJUGATES ARE DEEMED REAL (OVERRESTRICTIVE FOR NOW)
--     OTHERWISE (e.g. R = INT OR FRAC INT), ALL THE ELEMENTS ARE DEEMED REAL

    if (R has imaginary:() -> R) and (R has conjugate: R -> R) then
         localReal? x ==
            (u := retractIfCan(x)@Union(R, "failed")) case R
               and (u::R) = conjugate(u::R)

    else localReal? x == true

    iiilog x ==
      zero? x => INV
--      one? x => 0
      (x = 1) => 0
      (u := isExpt(x, opexp)) case Record(var:K, exponent:Integer) =>
           rec := u::Record(var:K, exponent:Integer)
           arg := first argument(rec.var);
           localReal? arg => rec.exponent * first argument(rec.var);
           ilog x
      ilog x

    ilog x ==
--      ((num1 := one?(num := numer x)) or num = -1) and (den := denom x) ^= 1
      ((num1 := ((num := numer x) = 1)) or num = -1) and (den := denom x) ^= 1
        and empty? variables x => - kernel(oplog, (num1 => den; -den)::F)
      kernel(oplog, x)

    if R has ElementaryFunctionCategory then
      iilog x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iiilog x
        log(r::R)::F

      iiexp x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iexp x
        exp(r::R)::F

    else
      iilog x == iiilog x
      iiexp x == iexp x

    if R has TrigonometricFunctionCategory then
      iisin x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isin x
        sin(r::R)::F

      iicos x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icos x
        cos(r::R)::F

      iitan x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => itan x
        tan(r::R)::F

      iicot x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icot x
        cot(r::R)::F

      iisec x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isec x
        sec(r::R)::F

      iicsc x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icsc x
        csc(r::R)::F

    else
      iisin x == isin x
      iicos x == icos x
      iitan x == itan x
      iicot x == icot x
      iisec x == isec x
      iicsc x == icsc x

    if R has ArcTrigonometricFunctionCategory then
      iiasin x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasin x
        asin(r::R)::F

      iiacos x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacos x
        acos(r::R)::F

      iiatan x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iatan x
        atan(r::R)::F

      iiacot x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacot x
        acot(r::R)::F

      iiasec x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasec x
        asec(r::R)::F

      iiacsc x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacsc x
        acsc(r::R)::F

    else
      iiasin x == iasin x
      iiacos x == iacos x
      iiatan x == iatan x
      iiacot x == iacot x
      iiasec x == iasec x
      iiacsc x == iacsc x

    if R has HyperbolicFunctionCategory then
      iisinh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isinh x
        sinh(r::R)::F

      iicosh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icosh x
        cosh(r::R)::F

      iitanh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => itanh x
        tanh(r::R)::F

      iicoth x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icoth x
        coth(r::R)::F

      iisech x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => isech x
        sech(r::R)::F

      iicsch x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => icsch x
        csch(r::R)::F

    else
      iisinh x == isinh x
      iicosh x == icosh x
      iitanh x == itanh x
      iicoth x == icoth x
      iisech x == isech x
      iicsch x == icsch x

    if R has ArcHyperbolicFunctionCategory then
      iiasinh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasinh x
        asinh(r::R)::F

      iiacosh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacosh x
        acosh(r::R)::F

      iiatanh x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iatanh x
        atanh(r::R)::F

      iiacoth x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacoth x
        acoth(r::R)::F

      iiasech x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iasech x
        asech(r::R)::F

      iiacsch x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iacsch x
        acsch(r::R)::F

    else
      iiasinh x == iasinh x
      iiacosh x == iacosh x
      iiatanh x == iatanh x
      iiacoth x == iacoth x
      iiasech x == iasech x
      iiacsch x == iacsch x

    evaluate(oppi, ipi)$BasicOperatorFunctions1(F)
    evaluate(oplog, iilog)
    evaluate(opexp, iiexp)
    evaluate(opsin, iisin)
    evaluate(opcos, iicos)
    evaluate(optan, iitan)
    evaluate(opcot, iicot)
    evaluate(opsec, iisec)
    evaluate(opcsc, iicsc)
    evaluate(opasin, iiasin)
    evaluate(opacos, iiacos)
    evaluate(opatan, iiatan)
    evaluate(opacot, iiacot)
    evaluate(opasec, iiasec)
    evaluate(opacsc, iiacsc)
    evaluate(opsinh, iisinh)
    evaluate(opcosh, iicosh)
    evaluate(optanh, iitanh)
    evaluate(opcoth, iicoth)
    evaluate(opsech, iisech)
    evaluate(opcsch, iicsch)
    evaluate(opasinh, iiasinh)
    evaluate(opacosh, iiacosh)
    evaluate(opatanh, iiatanh)
    evaluate(opacoth, iiacoth)
    evaluate(opasech, iiasech)
    evaluate(opacsch, iiacsch)
    derivative(opexp, exp)
    derivative(oplog, inv)
    derivative(opsin, cos)
    derivative(opcos, - sin #1)
    derivative(optan, 1 + tan(#1)**2)
    derivative(opcot, - 1 - cot(#1)**2)
    derivative(opsec, tan(#1) * sec(#1))
    derivative(opcsc, - cot(#1) * csc(#1))
    derivative(opasin, inv sqrt(1 - #1**2))
    derivative(opacos, - inv sqrt(1 - #1**2))
    derivative(opatan, inv(1 + #1**2))
    derivative(opacot, - inv(1 + #1**2))
    derivative(opasec, inv(#1 * sqrt(#1**2 - 1)))
    derivative(opacsc, - inv(#1 * sqrt(#1**2 - 1)))
    derivative(opsinh, cosh)
    derivative(opcosh, sinh)
    derivative(optanh, 1 - tanh(#1)**2)
    derivative(opcoth, 1 - coth(#1)**2)
    derivative(opsech, - tanh(#1) * sech(#1))
    derivative(opcsch, - coth(#1) * csch(#1))
    derivative(opasinh, inv sqrt(1 + #1**2))
    derivative(opacosh, inv sqrt(#1**2 - 1))
    derivative(opatanh, inv(1 - #1**2))
    derivative(opacoth, inv(1 - #1**2))
    derivative(opasech, - inv(#1 * sqrt(1 - #1**2)))
    derivative(opacsch, - inv(#1 * sqrt(1 + #1**2)))

@
<<EF.dotabb>>=
"EF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEFINTEF ElementaryFunctionDefiniteIntegration}
\pagehead{ElementaryFunctionDefiniteIntegration}{DEFINTEF}
\pagepic{ps/v104elementaryfunctiondefiniteintegration.ps}{DEFINTEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEFINTEF ElementaryFunctionDefiniteIntegration>>=
)abbrev package DEFINTEF ElementaryFunctionDefiniteIntegration
++ Definite integration of elementary functions.
++ Author: Manuel Bronstein
++ Date Created: 14 April 1992
++ Date Last Updated: 2 February 1993
++ Description:
++   \spadtype{ElementaryFunctionDefiniteIntegration}
++   provides functions to compute definite
++   integrals of elementary functions.
ElementaryFunctionDefiniteIntegration(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory, PrimitiveFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)

  B   ==> Boolean
  SE  ==> Symbol
  Z   ==> Integer
  P   ==> SparseMultivariatePolynomial(R, K)
  K   ==> Kernel F
  UP  ==> SparseUnivariatePolynomial F
  OFE ==> OrderedCompletion F
  U   ==> Union(f1:OFE, f2:List OFE, fail:"failed", pole:"potentialPole")

  Exports ==> with
    integrate: (F, SegmentBinding OFE) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (F, SegmentBinding OFE, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".
    innerint: (F, SE, OFE, OFE, B) -> U
      ++ innerint(f, x, a, b, ignore?) should be local but conditional

  Implementation ==> add
    import ElementaryFunctionSign(R, F)
    import DefiniteIntegrationTools(R, F)
    import FunctionSpaceIntegration(R, F)

    polyIfCan   : (P, K) -> Union(UP, "failed")
    int         : (F, SE, OFE, OFE, B) -> U
    nopole      : (F, SE, K, OFE, OFE) -> U
    checkFor0   : (P, K, OFE, OFE) -> Union(B, "failed")
    checkSMP    : (P, SE, K, OFE, OFE) -> Union(B, "failed")
    checkForPole: (F, SE, K, OFE, OFE) -> Union(B, "failed")
    posit       : (F, SE, K, OFE, OFE) -> Union(B, "failed")
    negat       : (F, SE, K, OFE, OFE) -> Union(B, "failed")
    moreThan    : (OFE, Fraction Z) -> Union(B, "failed")

    if R has Join(ConvertibleTo Pattern Integer, PatternMatchable Integer)
      and F has SpecialFunctionCategory then
        import PatternMatchIntegration(R, F)

        innerint(f, x, a, b, ignor?) ==
          ((u := int(f, x, a, b, ignor?)) case f1) or (u case f2)
            or ((v := pmintegrate(f, x, a, b)) case "failed") => u
          [v::F::OFE]

    else
      innerint(f, x, a, b, ignor?) == int(f, x, a, b, ignor?)

    integrate(f:F, s:SegmentBinding OFE) ==
      innerint(f, variable s, lo segment s, hi segment s, false)

    integrate(f:F, s:SegmentBinding OFE, str:String) ==
      innerint(f, variable s, lo segment s, hi segment s, ignore? str)

    int(f, x, a, b, ignor?) ==
      a = b => [0::OFE]
      k := kernel(x)@Kernel(F)
      (z := checkForPole(f, x, k, a, b)) case "failed" =>
        ignor? => nopole(f, x, k, a, b)
        ["potentialPole"]
      z::B => error "integrate: pole in path of integration"
      nopole(f, x, k, a, b)

    checkForPole(f, x, k, a, b) ==
      ((u := checkFor0(d := denom f, k, a, b)) case "failed") or (u::B) => u
      ((u := checkSMP(d, x, k, a, b)) case "failed") or (u::B) => u
      checkSMP(numer f, x, k, a, b)

-- true if p has a zero between a and b exclusive
    checkFor0(p, x, a, b) ==
      (u := polyIfCan(p, x)) case UP => checkForZero(u::UP, a, b, false)
      (v := isTimes p) case List(P) =>
         for t in v::List(P) repeat
           ((w := checkFor0(t, x, a, b)) case "failed") or (w::B) => return w
         false
      (r := retractIfCan(p)@Union(K, "failed")) case "failed" => "failed"
      k := r::K
-- functions with no real zeros
      is?(k, "exp"::SE) or is?(k, "acot"::SE) or is?(k, "cosh"::SE) => false
-- special case for log
      is?(k, "log"::SE) =>
        (w := moreThan(b, 1)) case "failed" or not(w::B) => w
        moreThan(-a, -1)
      "failed"

-- returns true if a > b, false if a < b, "failed" if can't decide
    moreThan(a, b) ==
      (r := retractIfCan(a)@Union(F, "failed")) case "failed" =>  -- infinite
        whatInfinity(a) > 0
      (u := retractIfCan(r::F)@Union(Fraction Z, "failed")) case "failed" =>
        "failed"
      u::Fraction(Z) > b

-- true if p has a pole between a and b
    checkSMP(p, x, k, a, b) ==
      (u := polyIfCan(p, k)) case UP => false
      (v := isTimes p) case List(P) =>
         for t in v::List(P) repeat
           ((w := checkSMP(t, x, k, a, b)) case "failed") or (w::B) => return w
         false
      (v := isPlus p) case List(P) =>
         n := 0              -- number of summand having a pole
         for t in v::List(P) repeat
           (w := checkSMP(t, x, k, a, b)) case "failed" => return w
           if w::B then n := n + 1
         zero? n => false    -- no summand has a pole
--         one? n => true      -- only one summand has a pole
         (n = 1) => true      -- only one summand has a pole
         "failed"            -- at least 2 summands have a pole
      (r := retractIfCan(p)@Union(K, "failed")) case "failed" => "failed"
      kk := r::K
      -- nullary operators have no poles
      nullary? operator kk => false
      f := first argument kk
      -- functions which are defined over all the reals:
      is?(kk, "exp"::SE) or is?(kk, "sin"::SE) or is?(kk, "cos"::SE)
        or is?(kk, "sinh"::SE) or is?(kk, "cosh"::SE) or is?(kk, "tanh"::SE)
          or is?(kk, "sech"::SE) or is?(kk, "atan"::SE) or is?(kk, "acot"::SE)
            or is?(kk, "asinh"::SE) => checkForPole(f, x, k, a, b)
      -- functions which are defined on (-1,+1):
      is?(kk, "asin"::SE) or is?(kk, "acos"::SE) or is?(kk, "atanh"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        ((w := posit(f - 1, x, k, a, b)) case "failed") or (w::B) => w
        negat(f + 1, x, k, a, b)
      -- functions which are defined on (+1, +infty):
      is?(kk, "acosh"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        negat(f - 1, x, k, a, b)
      -- functions which are defined on (0, +infty):
      is?(kk, "log"::SE) =>
        ((w := checkForPole(f, x, k, a, b)) case "failed") or (w::B) => w
        negat(f, x, k, a, b)
      "failed"

-- returns true if it is certain that f takes at least one strictly positive
-- value for x in (a,b), false if it is certain that f takes no strictly
-- positive value in (a,b), "failed" otherwise
-- f must be known to have no poles in (a,b)
    posit(f, x, k, a, b) ==
      z :=
        (r := retractIfCan(a)@Union(F, "failed")) case "failed" => sign(f, x, a)
        sign(f, x, r::F, "right")
      (b1 := z case Z) and z::Z > 0 => true
      z :=
        (r := retractIfCan(b)@Union(F, "failed")) case "failed" => sign(f, x, b)
        sign(f, x, r::F, "left")
      (b2 := z case Z) and z::Z > 0 => true
      b1 and b2 =>
        ((w := checkFor0(numer f, k, a, b)) case "failed") or (w::B) => "failed"
        false
      "failed"

-- returns true if it is certain that f takes at least one strictly negative
-- value for x in (a,b), false if it is certain that f takes no strictly
-- negative value in (a,b), "failed" otherwise
-- f must be known to have no poles in (a,b)
    negat(f, x, k, a, b) ==
      z :=
        (r := retractIfCan(a)@Union(F, "failed")) case "failed" => sign(f, x, a)
        sign(f, x, r::F, "right")
      (b1 := z case Z) and z::Z < 0 => true
      z :=
        (r := retractIfCan(b)@Union(F, "failed")) case "failed" => sign(f, x, b)
        sign(f, x, r::F, "left")
      (b2 := z case Z) and z::Z < 0 => true
      b1 and b2 =>
        ((w := checkFor0(numer f, k, a, b)) case "failed") or (w::B) => "failed"
        false
      "failed"

-- returns a UP if p is only a poly w.r.t. the kernel x
    polyIfCan(p, x) ==
      q := univariate(p, x)
      ans:UP := 0
      while q ^= 0 repeat
        member?(x, tower(c := leadingCoefficient(q)::F)) => return "failed"
        ans := ans + monomial(c, degree q)
        q := reductum q
      ans

-- integrate f for x between a and b assuming that f has no pole in between
    nopole(f, x, k, a, b) ==
      (u := integrate(f, x)) case F =>
        (v := computeInt(k, u::F, a, b, false)) case "failed" => ["failed"]
        [v::OFE]
      ans := empty()$List(OFE)
      for g in u::List(F) repeat
        (v := computeInt(k, g, a, b, false)) case "failed" => return ["failed"]
        ans := concat_!(ans, [v::OFE])
      [ans]

@
<<DEFINTEF.dotabb>>=
"DEFINTEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEFINTEF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DEFINTEF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LODEEF ElementaryFunctionLODESolver}
\pagehead{ElementaryFunctionLODESolver}{LODEEF}
\pagepic{ps/v104elementaryfunctionlodesolver.ps}{LODEEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LODEEF ElementaryFunctionLODESolver>>=
)abbrev package LODEEF ElementaryFunctionLODESolver
++ Author: Manuel Bronstein
++ Date Created: 3 February 1994
++ Date Last Updated: 9 March 1994
++ Description:
++ \spad{ElementaryFunctionLODESolver} provides the top-level
++ functions for finding closed form solutions of linear ordinary
++ differential equations and initial value problems.
++ Keywords: differential equation, ODE
ElementaryFunctionLODESolver(R, F, L): Exports == Implementation where
  R: Join(OrderedSet, EuclideanDomain, RetractableTo Integer,
          LinearlyExplicitRingOver Integer, CharacteristicZero)
  F: Join(AlgebraicallyClosedFunctionSpace R, TranscendentalFunctionCategory,
          PrimitiveFunctionCategory)
  L: LinearOrdinaryDifferentialOperatorCategory F

  SY  ==> Symbol
  N   ==> NonNegativeInteger
  K   ==> Kernel F
  V   ==> Vector F
  M   ==> Matrix F
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  UPUP==> SparseUnivariatePolynomial RF
  P   ==> SparseMultivariatePolynomial(R, K)
  P2  ==> SparseMultivariatePolynomial(P, K)
  LQ  ==> LinearOrdinaryDifferentialOperator1 RF
  REC ==> Record(particular: F, basis: List F)
  U   ==> Union(REC, "failed")
  ALGOP  ==> "%alg"

  Exports ==> with
    solve: (L, F, SY) -> U
      ++ solve(op, g, x) returns either a solution of the ordinary differential
      ++ equation \spad{op y = g} or "failed" if no non-trivial solution can be
      ++ found; When found, the solution is returned in the form
      ++ \spad{[h, [b1,...,bm]]} where \spad{h} is a particular solution and
      ++ and \spad{[b1,...bm]} are linearly independent solutions of the
      ++ associated homogenuous equation \spad{op y = 0}.
      ++ A full basis for the solutions of the homogenuous equation
      ++ is not always returned, only the solutions which were found;
      ++ \spad{x} is the dependent variable.
    solve: (L, F, SY, F, List F) -> Union(F, "failed")
      ++ solve(op, g, x, a, [y0,...,ym]) returns either the solution
      ++ of the initial value problem \spad{op y = g, y(a) = y0, y'(a) = y1,...}
      ++ or "failed" if the solution cannot be found;
      ++ \spad{x} is the dependent variable.

  Implementation ==> add
    import Kovacic(F, UP)
    import ODETools(F, L)
    import RationalLODE(F, UP)
    import RationalRicDE(F, UP)
    import ODEIntegration(R, F)
    import ConstantLODE(R, F, L)
    import IntegrationTools(R, F)
    import ReductionOfOrder(F, L)
    import ReductionOfOrder(RF, LQ)
    import PureAlgebraicIntegration(R, F, L)
    import FunctionSpacePrimitiveElement(R, F)
    import LinearSystemMatrixPackage(F, V, V, M)
    import SparseUnivariatePolynomialFunctions2(RF, F)
    import FunctionSpaceUnivariatePolynomialFactor(R, F, UP)
    import LinearOrdinaryDifferentialOperatorFactorizer(F, UP)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                             K, R, P, F)

    upmp       : (P, List K) -> P2
    downmp     : (P2, List K, List P) -> P
    xpart      : (F, SY) -> F
    smpxpart   : (P, SY, List K, List P) -> P
    multint    : (F, List F, SY) -> F
    ulodo      : (L, K) -> LQ
    firstOrder : (F, F, F, SY) -> REC
    rfSolve    : (L, F, K, SY) -> U
    ratlogsol  : (LQ, List RF, K, SY) -> List F
    expsols    : (LQ, K, SY) -> List F
    homosolve  : (L, LQ, List RF, K, SY) -> List F
    homosolve1 : (L, List F, K, SY) -> List F
    norf1      : (L, K, SY, N) -> List F
    kovode     : (LQ, K, SY) -> List F
    doVarParams: (L, F, List F, SY) -> U
    localmap   : (F -> F, L) -> L
    algSolve   : (L, F, K, List K, SY) -> U
    palgSolve  : (L, F, K, K, SY) -> U
    lastChance : (L, F, SY) -> U

    diff := D()$L

    smpxpart(p, x, l, lp) == downmp(primitivePart upmp(p, l), l, lp)
    downmp(p, l, lp)      == ground eval(p, l, lp)
    homosolve(lf, op, sols, k, x) == homosolve1(lf, ratlogsol(op,sols,k,x),k,x)

-- left hand side has algebraic (not necessarily pure) coefficients
    algSolve(op, g, k, l, x) ==
      symbolIfCan(kx := ksec(k, l, x)) case SY => palgSolve(op, g, kx, k, x)
      has?(operator kx, ALGOP) =>
        rec := primitiveElement(kx::F, k::F)
        z   := rootOf(rec.prim)
        lk:List K := [kx, k]
        lv:List F := [(rec.pol1) z, (rec.pol2) z]
        (u := solve(localmap(eval(#1, lk, lv), op), eval(g, lk, lv), x))
            case "failed" => "failed"
        rc := u::REC
        kz := retract(z)@K
        [eval(rc.particular, kz, rec.primelt),
            [eval(f, kz, rec.primelt) for f in rc.basis]]
      lastChance(op, g, x)

    doVarParams(eq, g, bas, x) ==
      (u := particularSolution(eq, g, bas, int(#1, x))) case "failed" =>
         lastChance(eq, g, x)
      [u::F, bas]

    lastChance(op, g, x) ==
--      one? degree op => firstOrder(coefficient(op,0), leadingCoefficient op,g,x)
      (degree op) = 1 => firstOrder(coefficient(op,0), leadingCoefficient op,g,x)
      "failed"

-- solves a0 y + a1 y' = g
-- does not check whether there is a solution in the field generated by
-- a0, a1 and g
    firstOrder(a0, a1, g, x) ==
      h := xpart(expint(- a0 / a1, x), x)
      [h * int((g / h) / a1, x), [h]]

-- xpart(f,x) removes any constant not involving x from f
    xpart(f, x) ==
      l  := reverse_! varselect(tower f, x)
      lp := [k::P for k in l]
      smpxpart(numer f, x, l, lp) / smpxpart(denom f, x, l, lp)

    upmp(p, l) ==
      empty? l => p::P2
      up := univariate(p, k := first l)
      l := rest l
      ans:P2 := 0
      while up ^= 0 repeat
        ans := ans + monomial(upmp(leadingCoefficient up, l), k, degree up)
        up  := reductum up
      ans

-- multint(a, [g1,...,gk], x) returns gk \int(g(k-1) \int(....g1 \int(a))...)
    multint(a, l, x) ==
       for g in l repeat a := g * xpart(int(a, x), x)
       a

    expsols(op, k, x) ==
--      one? degree op =>
      (degree op) = 1 =>
          firstOrder(multivariate(coefficient(op, 0), k),
                     multivariate(leadingCoefficient op, k), 0, x).basis
      [xpart(expint(multivariate(h, k), x), x) for h in ricDsolve(op, ffactor)]

-- Finds solutions with rational logarithmic derivative
    ratlogsol(oper, sols, k, x) ==
      bas := [xpart(multivariate(h, k), x) for h in sols]
      degree(oper) = #bas => bas            -- all solutions are found already
      rec := ReduceOrder(oper, sols)
      le := expsols(rec.eq, k, x)
      int:List(F) := [xpart(multivariate(h, k), x) for h in rec.op]
      concat_!([xpart(multivariate(h, k), x) for h in sols],
               [multint(e, int, x) for e in le])

    homosolve1(oper, sols, k, x) ==
      zero?(n := (degree(oper) - #sols)::N) => sols   -- all solutions found
      rec := ReduceOrder(oper, sols)
      int:List(F) := [xpart(h, x) for h in rec.op]
      concat_!(sols, [multint(e, int, x) for e in norf1(rec.eq, k, x, n::N)])

-- if the coefficients are rational functions, then the equation does not
-- not have a proper 1st-order right factor over the rational functions
    norf1(op, k, x, n) ==
--      one? n => firstOrder(coefficient(op, 0), leadingCoefficient op,0,x).basis
      (n = 1) => firstOrder(coefficient(op, 0), leadingCoefficient op,0,x).basis
-- for order > 2, we check that the coeffs are still rational functions
      symbolIfCan(kmax vark(coefficients op, x)) case SY =>
        eq := ulodo(op, k)
        n = 2 => kovode(eq, k, x)
        eq := last factor1 eq        -- eq cannot have order 1
        degree(eq) = 2 =>
          empty?(bas := kovode(eq, k, x)) => empty()
          homosolve1(op, bas, k, x)
        empty()
      empty()

    kovode(op, k, x) ==
      b := coefficient(op, 1)
      a := coefficient(op, 2)
      (u := kovacic(coefficient(op, 0), b, a, ffactor)) case "failed" => empty()
      p := map(multivariate(#1, k), u::UPUP)
      ba := multivariate(- b / a, k)
-- if p has degree 2 (case 2), then it must be squarefree since the
-- ode is irreducible over the rational functions, so the 2 roots of p
-- are distinct and must yield 2 independent solutions.
      degree(p) = 2 => [xpart(expint(ba/(2::F) + e, x), x) for e in zerosOf p]
-- otherwise take 1 root of p and find the 2nd solution by reduction of order
      y1 := xpart(expint(ba / (2::F) + zeroOf p, x), x)
      [y1, y1 * xpart(int(expint(ba, x) / y1**2, x), x)]

    solve(op:L, g:F, x:SY) ==
      empty?(l := vark(coefficients op, x)) => constDsolve(op, g, x)
      symbolIfCan(k := kmax l) case SY => rfSolve(op, g, k, x)
      has?(operator k, ALGOP) => algSolve(op, g, k, l, x)
      lastChance(op, g, x)

    ulodo(eq, k) ==
        op:LQ := 0
        while eq ^= 0 repeat
            op := op + monomial(univariate(leadingCoefficient eq, k), degree eq)
            eq := reductum eq
        op

-- left hand side has rational coefficients
    rfSolve(eq, g, k, x) ==
      op := ulodo(eq, k)
      empty? remove_!(k, varselect(kernels g, x)) =>  -- i.e. rhs is rational
        rc := ratDsolve(op, univariate(g, k))
        rc.particular case "failed" =>                -- this implies g ^= 0
          doVarParams(eq, g, homosolve(eq, op, rc.basis, k, x), x)
        [multivariate(rc.particular::RF, k), homosolve(eq, op, rc.basis, k, x)]
      doVarParams(eq, g, homosolve(eq, op, ratDsolve(op, 0).basis, k, x), x)

    solve(op, g, x, a, y0) ==
      (u := solve(op, g, x)) case "failed" => "failed"
      hp := h := (u::REC).particular
      b := (u::REC).basis
      v:V := new(n := #y0, 0)
      kx:K := kernel x
      for i in minIndex v .. maxIndex v for yy in y0 repeat
        v.i := yy - eval(h, kx, a)
        h := diff h
      (sol := particularSolution(map_!(eval(#1,kx,a),wronskianMatrix(b,n)), v))
         case "failed" => "failed"
      for f in b for i in minIndex(s := sol::V) .. repeat
        hp := hp + s.i * f
      hp

    localmap(f, op) ==
        ans:L := 0
        while op ^= 0 repeat
            ans := ans + monomial(f leadingCoefficient op, degree op)
            op  := reductum op
        ans

-- left hand side has pure algebraic coefficients
    palgSolve(op, g, kx, k, x) ==
      rec := palgLODE(op, g, kx, k, x)   -- finds solutions in the coef. field
      rec.particular case "failed" =>
        doVarParams(op, g, homosolve1(op, rec.basis, k, x), x)
      [(rec.particular)::F, homosolve1(op, rec.basis, k, x)]

@
<<LODEEF.dotabb>>=
"LODEEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LODEEF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"LODEEF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEEF ElementaryFunctionODESolver}
\pagehead{ElementaryFunctionODESolver}{ODEEF}
\pagepic{ps/v104elementaryfunctionodesolver.ps}{ODEEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEEF ElementaryFunctionODESolver>>=
)abbrev package ODEEF ElementaryFunctionODESolver
++ Author: Manuel Bronstein
++ Date Created: 18 March 1991
++ Date Last Updated: 8 March 1994
++ Description:
++ \spad{ElementaryFunctionODESolver} provides the top-level
++ functions for finding closed form solutions of ordinary
++ differential equations and initial value problems.
++ Keywords: differential equation, ODE
ElementaryFunctionODESolver(R, F): Exports == Implementation where
  R: Join(OrderedSet, EuclideanDomain, RetractableTo Integer,
          LinearlyExplicitRingOver Integer, CharacteristicZero)
  F: Join(AlgebraicallyClosedFunctionSpace R, TranscendentalFunctionCategory,
          PrimitiveFunctionCategory)

  N   ==> NonNegativeInteger
  OP  ==> BasicOperator
  SY  ==> Symbol
  K   ==> Kernel F
  EQ  ==> Equation F
  V   ==> Vector F
  M   ==> Matrix F
  UP  ==> SparseUnivariatePolynomial F
  P   ==> SparseMultivariatePolynomial(R, K)
  LEQ ==> Record(left:UP, right:F)
  NLQ ==> Record(dx:F, dy:F)
  REC ==> Record(particular: F, basis: List F)
  VEC ==> Record(particular: V, basis: List V)
  ROW ==> Record(index: Integer, row: V, rh: F)
  SYS ==> Record(mat:M, vec: V)
  U   ==> Union(REC, F, "failed")
  UU  ==> Union(F, "failed")
  OPDIFF ==> "%diff"::SY

  Exports ==> with
    solve: (M, V, SY) -> Union(VEC, "failed")
      ++ solve(m, v, x) returns \spad{[v_p, [v_1,...,v_m]]} such that
      ++ the solutions of the system \spad{D y = m y + v} are
      ++ \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are
      ++ constants, and the \spad{v_i's} form a basis for the solutions of
      ++ \spad{D y = m y}.
      ++ \spad{x} is the dependent variable.
    solve: (M, SY) -> Union(List V, "failed")
      ++ solve(m, x) returns a basis for the solutions of \spad{D y = m y}.
      ++ \spad{x} is the dependent variable.
    solve: (List EQ, List OP, SY) -> Union(VEC, "failed")
      ++ solve([eq_1,...,eq_n], [y_1,...,y_n], x) returns either "failed"
      ++ or, if the equations form a fist order linear system, a solution
      ++ of the form \spad{[y_p, [b_1,...,b_n]]} where \spad{h_p} is a
      ++ particular solution and \spad{[b_1,...b_m]} are linearly independent
      ++ solutions of the associated homogenuous system.
      ++ error if the equations do not form a first order linear system
    solve: (List F, List OP, SY) -> Union(VEC, "failed")
      ++ solve([eq_1,...,eq_n], [y_1,...,y_n], x) returns either "failed"
      ++ or, if the equations form a fist order linear system, a solution
      ++ of the form \spad{[y_p, [b_1,...,b_n]]} where \spad{h_p} is a
      ++ particular solution and \spad{[b_1,...b_m]} are linearly independent
      ++ solutions of the associated homogenuous system.
      ++ error if the equations do not form a first order linear system
    solve: (EQ, OP, SY) -> U
      ++ solve(eq, y, x) returns either a solution of the ordinary differential
      ++ equation \spad{eq} or "failed" if no non-trivial solution can be found;
      ++ If the equation is linear ordinary, a solution is of the form
      ++ \spad{[h, [b1,...,bm]]} where \spad{h} is a particular solution
      ++ and \spad{[b1,...bm]} are linearly independent solutions of the
      ++ associated homogenuous equation \spad{f(x,y) = 0};
      ++ A full basis for the solutions of the homogenuous equation
      ++ is not always returned, only the solutions which were found;
      ++ If the equation is of the form {dy/dx = f(x,y)}, a solution is of
      ++ the form \spad{h(x,y)} where \spad{h(x,y) = c} is a first integral
      ++ of the equation for any constant \spad{c};
      ++ error if the equation is not one of those 2 forms;
    solve: (F, OP, SY) -> U
      ++ solve(eq, y, x) returns either a solution of the ordinary differential
      ++ equation \spad{eq} or "failed" if no non-trivial solution can be found;
      ++ If the equation is linear ordinary, a solution is of the form
      ++ \spad{[h, [b1,...,bm]]} where \spad{h} is a particular solution and
      ++ and \spad{[b1,...bm]} are linearly independent solutions of the
      ++ associated homogenuous equation \spad{f(x,y) = 0};
      ++ A full basis for the solutions of the homogenuous equation
      ++ is not always returned, only the solutions which were found;
      ++ If the equation is of the form {dy/dx = f(x,y)}, a solution is of
      ++ the form \spad{h(x,y)} where \spad{h(x,y) = c} is a first integral
      ++ of the equation for any constant \spad{c};
    solve: (EQ, OP, EQ, List F) -> UU
      ++ solve(eq, y, x = a, [y0,...,ym]) returns either the solution
      ++ of the initial value problem \spad{eq, y(a) = y0, y'(a) = y1,...}
      ++ or "failed" if the solution cannot be found;
      ++ error if the equation is not one linear ordinary or of the form
      ++ \spad{dy/dx = f(x,y)};
    solve: (F, OP, EQ, List F) -> UU
      ++ solve(eq, y, x = a, [y0,...,ym]) returns either the solution
      ++ of the initial value problem \spad{eq, y(a) = y0, y'(a) = y1,...}
      ++ or "failed" if the solution cannot be found;
      ++ error if the equation is not one linear ordinary or of the form
      ++ \spad{dy/dx = f(x,y)};

  Implementation ==> add
    import ODEIntegration(R, F)
    import IntegrationTools(R, F)
    import NonLinearFirstOrderODESolver(R, F)

    getfreelincoeff : (F, K, SY) -> F
    getfreelincoeff1: (F, K, List F) -> F
    getlincoeff     : (F, K) -> F
    getcoeff        : (F, K) -> UU
    parseODE        : (F, OP, SY) -> Union(LEQ, NLQ)
    parseLODE       : (F, List K, UP, SY) -> LEQ
    parseSYS        : (List F, List OP, SY) -> Union(SYS, "failed")
    parseSYSeq      : (F, List K, List K, List F, SY) -> Union(ROW, "failed")

    solve(diffeq:EQ, y:OP, x:SY) == solve(lhs diffeq - rhs diffeq, y, x)

    solve(leq: List EQ, lop: List OP, x:SY) ==
        solve([lhs eq - rhs eq for eq in leq], lop, x)

    solve(diffeq:EQ, y:OP, center:EQ, y0:List F) ==
      solve(lhs diffeq - rhs diffeq, y, center, y0)

    solve(m:M, x:SY) ==
        (u := solve(m, new(nrows m, 0), x)) case "failed" => "failed"
        u.basis

    solve(m:M, v:V, x:SY) ==
        Lx := LinearOrdinaryDifferentialOperator(F, diff x)
        uu := solve(m, v, solve(#1, #2,
               x)$ElementaryFunctionLODESolver(R, F, Lx))$SystemODESolver(F, Lx)
        uu case "failed" => "failed"
        rec := uu::Record(particular: V, basis: M)
        [rec.particular, [column(rec.basis, i) for i in 1..ncols(rec.basis)]]

    solve(diffeq:F, y:OP, center:EQ, y0:List F) ==
      a := rhs center
      kx:K := kernel(x := retract(lhs(center))@SY)
      (ur := parseODE(diffeq, y, x)) case NLQ =>
--        not one?(#y0) => error "solve: more than one initial condition!"
        not ((#y0) = 1) => error "solve: more than one initial condition!"
        rc := ur::NLQ
        (u := solve(rc.dx, rc.dy, y, x)) case "failed" => "failed"
        u::F - eval(u::F,  [kx, retract(y(x::F))@K], [a, first y0])
      rec := ur::LEQ
      p := rec.left
      Lx := LinearOrdinaryDifferentialOperator(F, diff x)
      op:Lx := 0
      while p ^= 0 repeat
        op := op + monomial(leadingCoefficient p, degree p)
        p  := reductum p
      solve(op, rec.right, x, a, y0)$ElementaryFunctionLODESolver(R, F, Lx)

    solve(leq: List F, lop: List OP, x:SY) ==
        (u := parseSYS(leq, lop, x)) case SYS =>
            rec := u::SYS
            solve(rec.mat, rec.vec, x)
        error "solve: not a first order linear system"

    solve(diffeq:F, y:OP, x:SY) ==
      (u := parseODE(diffeq, y, x)) case NLQ =>
        rc := u::NLQ
        (uu := solve(rc.dx, rc.dy, y, x)) case "failed" => "failed"
        uu::F
      rec := u::LEQ
      p := rec.left
      Lx := LinearOrdinaryDifferentialOperator(F, diff x)
      op:Lx := 0
      while p ^= 0 repeat
        op := op + monomial(leadingCoefficient p, degree p)
        p  := reductum p
      (uuu := solve(op, rec.right, x)$ElementaryFunctionLODESolver(R, F, Lx))
         case "failed" => "failed"
      uuu::REC

-- returns [M, v] s.t. the equations are D x = M x + v
    parseSYS(eqs, ly, x) ==
      (n := #eqs) ^= #ly => "failed"
      m:M := new(n, n, 0)
      v:V := new(n, 0)
      xx := x::F
      lf := [y xx for y in ly]
      lk0:List(K) := [retract(f)@K for f in lf]
      lk1:List(K) := [retract(differentiate(f, x))@K for f in lf]
      for eq in eqs repeat
          (u := parseSYSeq(eq,lk0,lk1,lf,x)) case "failed" => return "failed"
          rec := u::ROW
          setRow_!(m, rec.index, rec.row)
          v(rec.index) := rec.rh
      [m, v]

    parseSYSeq(eq, l0, l1, lf, x) ==
      l := [k for k in varselect(kernels eq, x) | is?(k, OPDIFF)]
      empty? l or not empty? rest l or zero?(n := position(k := first l,l1)) =>
         "failed"
      c := getfreelincoeff1(eq, k, lf)
      eq := eq - c * k::F
      v:V := new(#l0, 0)
      for y in l0 for i in 1.. repeat
          ci := getfreelincoeff1(eq, y, lf)
          v.i := - ci / c
          eq := eq - ci * y::F
      [n, v, -eq]

-- returns either [p, g] where the equation (diffeq) is of the form p(D)(y) = g
-- or [p, q] such that the equation (diffeq) is of the form p dx + q dy = 0
    parseODE(diffeq, y, x) ==
      f := y(x::F)
      l:List(K) := [retract(f)@K]
      n:N := 2
      for k in varselect(kernels diffeq, x) | is?(k, OPDIFF) repeat
        if (m := height k) > n then n := m
      n := (n - 2)::N
-- build a list of kernels in the order [y^(n)(x),...,y''(x),y'(x),y(x)]
      for i in 1..n repeat
        l := concat(retract(f := differentiate(f, x))@K, l)
      k:K   -- #$^#& compiler requires this line and the next one too...
      c:F
      while not(empty? l) and zero?(c := getlincoeff(diffeq, k := first l))
        repeat l := rest l
      empty? l or empty? rest l => error "parseODE: equation has order 0"
      diffeq := diffeq - c * (k::F)
      ny := name y
      l := rest l
      height(k) > 3 => parseLODE(diffeq, l, monomial(c, #l), ny)
      (u := getcoeff(diffeq, k := first l)) case "failed" => [diffeq, c]
      eqrhs := (d := u::F) * (k::F) - diffeq
      freeOf?(eqrhs, ny) and freeOf?(c, ny) and freeOf?(d, ny) =>
        [monomial(c, 1) + d::UP, eqrhs]
      [diffeq, c]

-- returns [p, g] where the equation (diffeq) is of the form p(D)(y) = g
    parseLODE(diffeq, l, p, y) ==
      not freeOf?(leadingCoefficient p, y) =>
        error "parseLODE: not a linear ordinary differential equation"
      d := degree(p)::Integer - 1
      for k in l repeat
        p := p + monomial(c := getfreelincoeff(diffeq, k, y), d::N)
        d := d - 1
        diffeq := diffeq - c * (k::F)
      freeOf?(diffeq, y) => [p, - diffeq]
      error "parseLODE: not a linear ordinary differential equation"

    getfreelincoeff(f, k, y) ==
      freeOf?(c := getlincoeff(f, k), y) => c
      error "getfreelincoeff: not a linear ordinary differential equation"

    getfreelincoeff1(f, k, ly) ==
      c := getlincoeff(f, k)
      for y in ly repeat
         not freeOf?(c, y) =>
            error "getfreelincoeff: not a linear ordinary differential equation"
      c

    getlincoeff(f, k) ==
      (u := getcoeff(f, k)) case "failed" =>
        error "getlincoeff: not an appropriate ordinary differential equation"
      u::F

    getcoeff(f, k) ==
      (r := retractIfCan(univariate(denom f, k))@Union(P, "failed"))
        case "failed" or degree(p := univariate(numer f, k)) > 1 => "failed"
      coefficient(p, 1) / (r::P)

@
<<ODEEF.dotabb>>=
"ODEEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEEF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"ODEEF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SIGNEF ElementaryFunctionSign}
\pagehead{ElementaryFunctionSign}{SIGNEF}
\pagepic{ps/v104elementaryfunctionsign.ps}{SIGNEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SIGNEF ElementaryFunctionSign>>=
)abbrev package SIGNEF ElementaryFunctionSign
++ Author: Manuel Bronstein
++ Date Created: 25 Aug 1989
++ Date Last Updated: 4 May 1992
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: elementary function, sign
++ Examples:
++ References:
++ Description:
++   This package provides functions to determine the sign of an
++   elementary function around a point or infinity.
ElementaryFunctionSign(R,F): Exports == Implementation where
  R : Join(IntegralDomain,OrderedSet,RetractableTo Integer,_
           LinearlyExplicitRingOver Integer,GcdDomain)
  F : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
            FunctionSpace R)

  N  ==> NonNegativeInteger
  Z  ==> Integer
  SY ==> Symbol
  RF ==> Fraction Polynomial R
  ORF ==> OrderedCompletion RF
  OFE ==> OrderedCompletion F
  K  ==> Kernel F
  P  ==> SparseMultivariatePolynomial(R, K)
  U  ==> Union(Z, "failed")
  FS2 ==> FunctionSpaceFunctions2
  POSIT ==> "positive"
  NEGAT ==> "negative"

  Exports ==> with
    sign: F -> U
      ++ sign(f) returns the sign of f if it is constant everywhere.
    sign: (F, SY, OFE) -> U
      ++ sign(f, x, a) returns the sign of f as x nears \spad{a}, from both
      ++ sides if \spad{a} is finite.
    sign: (F, SY, F, String) -> U
      ++ sign(f, x, a, s) returns the sign of f as x nears \spad{a} from below
      ++ if s is "left", or above if s is "right".

  Implementation ==> add
    import ToolsForSign R
    import RationalFunctionSign(R)
    import PowerSeriesLimitPackage(R, F)
    import TrigonometricManipulations(R, F)

    smpsign : P -> U
    sqfrSign: P -> U
    termSign: P -> U
    kerSign : K -> U
    listSign: (List P,Z) -> U
    insign  : (F,SY,OFE, N) -> U
    psign   : (F,SY,F,String, N) -> U
    ofesign : OFE -> U
    overRF  : OFE -> Union(ORF, "failed")

    sign(f, x, a) ==
      not real? f => "failed"
      insign(f, x, a, 0)

    sign(f, x, a, st) ==
      not real? f => "failed"
      psign(f, x, a, st, 0)

    sign f ==
      not real? f => "failed"
      (u := retractIfCan(f)@Union(RF,"failed")) case RF => sign(u::RF)
      (un := smpsign numer f) case Z and (ud := smpsign denom f) case Z =>
        un::Z * ud::Z
      --abort if there are any variables
      not empty? variables f => "failed"
      -- abort in the presence of algebraic numbers
      member?(coerce("rootOf")::Symbol,map(name,operators f)$ListFunctions2(BasicOperator,Symbol)) => "failed"
      -- In the last resort try interval evaluation where feasible.
      if R has ConvertibleTo Float then
        import Interval(Float)
        import Expression(Interval Float)
        mapfun : (R -> Interval(Float)) := interval(convert(#1)$R)
        f2 : Expression(Interval Float) := map(mapfun,f)$FS2(R,F,Interval(Float),Expression(Interval Float))
        r : Union(Interval(Float),"failed") := retractIfCan f2
        if r case "failed" then  return "failed"
        negative? r => return(-1)
        positive? r => return 1
        zero? r => return 0
        "failed"
      "failed"

    overRF a ==
      (n := whatInfinity a) = 0 =>
        (u := retractIfCan(retract(a)@F)@Union(RF,"failed")) _
               case "failed" => "failed"
        u::RF::ORF
      n * plusInfinity()$ORF

    ofesign a ==
      (n := whatInfinity a) ^= 0 => convert(n)@Z
      sign(retract(a)@F)

    insign(f, x, a, m) ==
      m > 10 => "failed"                 -- avoid infinite loops for now
      (uf := retractIfCan(f)@Union(RF,"failed")) case RF and
                   (ua := overRF a) case ORF => sign(uf::RF, x, ua::ORF)
      eq : Equation OFE := equation(x :: F :: OFE,a)
      (u := limit(f,eq)) case "failed" => "failed"
      u case OFE =>
        (n := whatInfinity(u::OFE)) ^= 0 => convert(n)@Z
        (v := retract(u::OFE)@F) = 0 =>
          (s := insign(differentiate(f, x), x, a, m + 1)) case "failed"
                                                             => "failed"
          - s::Z * n
        sign v
      (u.leftHandLimit case "failed") or
         (u.rightHandLimit case "failed") => "failed"
      (ul := ofesign(u.leftHandLimit::OFE))  case "failed" => "failed"
      (ur := ofesign(u.rightHandLimit::OFE)) case "failed" => "failed"
      (ul::Z) = (ur::Z) => ul
      "failed"

    psign(f, x, a, st, m) ==
      m > 10 => "failed"                 -- avoid infinite loops for now
      f = 0 => 0
      (uf := retractIfCan(f)@Union(RF,"failed")) case RF and
           (ua := retractIfCan(a)@Union(RF,"failed")) case RF =>
            sign(uf::RF, x, ua::RF, st)
      eq : Equation F := equation(x :: F,a)
      (u := limit(f,eq,st)) case "failed" => "failed"
      u case OFE =>
        (n := whatInfinity(u::OFE)) ^= 0 => convert(n)@Z
        (v := retract(u::OFE)@F) = 0 =>
          (s := psign(differentiate(f,x),x,a,st,m + 1)) case "failed"=>
            "failed"
          direction(st) * s::Z
        sign v

    smpsign p ==
      (r := retractIfCan(p)@Union(R,"failed")) case R => sign(r::R)
      (u := sign(retract(unit(s := squareFree p))@R)) case "failed" =>
        "failed"
      ans := u::Z
      for term in factorList s | odd?(term.xpnt) repeat
        (u := sqfrSign(term.fctr)) case "failed" => return "failed"
        ans := ans * u::Z
      ans

    sqfrSign p ==
      (u := termSign first(l := monomials p)) case "failed" => "failed"
      listSign(rest l, u::Z)

    listSign(l, s) ==
      for term in l repeat
        (u := termSign term) case "failed" => return "failed"
        not(s = u::Z) => return "failed"
      s

    termSign term ==
      (us := sign leadingCoefficient term) case "failed" => "failed"
      for var in (lv := variables term) repeat
        odd? degree(term, var) =>
          empty? rest lv and (vs := kerSign first lv) case Z =>
                                                   return(us::Z * vs::Z)
          return "failed"
      us::Z

    kerSign k ==
      has?(op := operator k, "NEGAT") => -1
      has?(op, "POSIT") or is?(op,  "pi"::SY) or is?(op,"exp"::SY) or
                           is?(op,"cosh"::SY) or is?(op,"sech"::SY) => 1
      empty?(arg := argument k) => "failed"
      (s := sign first arg) case "failed" =>
        is?(op,"nthRoot" :: SY) =>
          even?(retract(second arg)@Z) => 1
          "failed"
        "failed"
      is?(op,"log" :: SY) =>
        s::Z < 0 => "failed"
        sign(first arg - 1)
      is?(op,"tanh" :: SY) or is?(op,"sinh" :: SY) or
                     is?(op,"csch" :: SY) or is?(op,"coth" :: SY) => s
      is?(op,"nthRoot" :: SY) =>
        even?(retract(second arg)@Z) =>
          s::Z < 0 => "failed"
          s
        s
      "failed"

@
<<SIGNEF.dotabb>>=
"SIGNEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SIGNEF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SIGNRF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFSTRUC ElementaryFunctionStructurePackage}
\pagehead{ElementaryFunctionStructurePackage}{EFSTRUC}
\pagepic{ps/v104elementaryfunctionstructurepackage.ps}{EFSTRUC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EFSTRUC ElementaryFunctionStructurePackage>>=
)abbrev package EFSTRUC ElementaryFunctionStructurePackage
++ Risch structure theorem
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 16 August 1995
++ Description:
++   ElementaryFunctionStructurePackage provides functions to test the
++   algebraic independence of various elementary functions, using the
++   Risch structure theorem (real and complex versions).
++   It also provides transformations on elementary functions
++   which are not considered simplifications.
++ Keywords: elementary, function, structure.
ElementaryFunctionStructurePackage(R,F): Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  B   ==> Boolean
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Z
  SY  ==> Symbol
  K   ==> Kernel F
  UP  ==> SparseUnivariatePolynomial F
  SMP ==> SparseMultivariatePolynomial(R, K)
  REC ==> Record(func:F, kers: List K, vals:List F)
  U   ==> Union(vec:Vector Q, func:F, fail: Boolean)
  POWER ==> "%power"::SY
  NTHR  ==> "nthRoot"::SY

  Exports ==> with
    normalize: F -> F
      ++ normalize(f) rewrites \spad{f} using the least possible number of
      ++ real algebraically independent kernels.
    normalize: (F, SY) -> F
      ++ normalize(f, x) rewrites \spad{f} using the least possible number of
      ++ real algebraically independent kernels involving \spad{x}.
    rischNormalize: (F, SY) -> REC
      ++ rischNormalize(f, x) returns \spad{[g, [k1,...,kn], [h1,...,hn]]}
      ++ such that \spad{g = normalize(f, x)} and each \spad{ki} was
      ++ rewritten as \spad{hi} during the normalization.
    realElementary: F -> F
      ++ realElementary(f) rewrites \spad{f} in terms of the 4 fundamental real
      ++ transcendental elementary functions: \spad{log, exp, tan, atan}.
    realElementary: (F, SY) -> F
      ++ realElementary(f,x) rewrites the kernels of \spad{f} involving \spad{x}
      ++ in terms of the 4 fundamental real
      ++ transcendental elementary functions: \spad{log, exp, tan, atan}.
    validExponential: (List K, F, SY) -> Union(F, "failed")
      ++ validExponential([k1,...,kn],f,x) returns \spad{g} if \spad{exp(f)=g}
      ++ and \spad{g} involves only \spad{k1...kn}, and "failed" otherwise.
    rootNormalize: (F, K) -> F
      ++ rootNormalize(f, k) returns \spad{f} rewriting either \spad{k} which
      ++ must be an nth-root in terms of radicals already in \spad{f}, or some
      ++ radicals in \spad{f} in terms of \spad{k}.
    tanQ: (Q, F) -> F
      ++ tanQ(q,a) is a local function with a conditional implementation.

  Implementation ==> add
    import TangentExpansions F
    import IntegrationTools(R, F)
    import IntegerLinearDependence F
    import AlgebraicManipulations(R, F)
    import InnerCommonDenominator(Z, Q, Vector Z, Vector Q)

    k2Elem             : (K, List SY) -> F
    realElem           : (F, List SY) -> F
    smpElem            : (SMP, List SY) -> F
    deprel             : (List K, K, SY) -> U
    rootDep            : (List K, K)     -> U
    qdeprel            : (List F, F)     -> U
    factdeprel         : (List K, K)     -> U
    toR                : (List K, F) -> List K
    toY                : List K -> List F
    toZ                : List K -> List F
    toU                : List K -> List F
    toV                : List K -> List F
    ktoY               : K  -> F
    ktoZ               : K  -> F
    ktoU               : K  -> F
    ktoV               : K  -> F
    gdCoef?            : (Q, Vector Q) -> Boolean
    goodCoef           : (Vector Q, List K, SY) ->
                                 Union(Record(index:Z, ker:K), "failed")
    tanRN              : (Q, K) -> F
    localnorm          : F -> F
    rooteval           : (F, List K, K, Q) -> REC
    logeval            : (F, List K, K, Vector Q) -> REC
    expeval            : (F, List K, K, Vector Q) -> REC
    taneval            : (F, List K, K, Vector Q) -> REC
    ataneval           : (F, List K, K, Vector Q) -> REC
    depeval            : (F, List K, K, Vector Q) -> REC
    expnosimp          : (F, List K, K, Vector Q, List F, F) -> REC
    tannosimp          : (F, List K, K, Vector Q, List F, F) -> REC
    rtNormalize        : F -> F
    rootNormalize0     : F -> REC
    rootKernelNormalize: (F, List K, K) -> Union(REC, "failed")
    tanSum             : (F, List F) -> F

    comb?     := F has CombinatorialOpsCategory
    mpiover2:F := pi()$F / (-2::F)

    realElem(f, l)       == smpElem(numer f, l) / smpElem(denom f, l)
    realElementary(f, x) == realElem(f, [x])
    realElementary f     == realElem(f, variables f)
    toY ker              == [func for k in ker | (func := ktoY k) ^= 0]
    toZ ker              == [func for k in ker | (func := ktoZ k) ^= 0]
    toU ker              == [func for k in ker | (func := ktoU k) ^= 0]
    toV ker              == [func for k in ker | (func := ktoV k) ^= 0]
    rtNormalize f        == rootNormalize0(f).func
    toR(ker, x) == select(is?(#1, NTHR) and first argument(#1) = x, ker)

    if R has GcdDomain then
      tanQ(c, x) ==
        tanNa(rootSimp zeroOf tanAn(x, denom(c)::PositiveInteger), numer c)
    else
      tanQ(c, x) ==
        tanNa(zeroOf tanAn(x, denom(c)::PositiveInteger), numer c)

    -- tanSum(c, [a1,...,an]) returns f(c, a1,...,an) such that
    -- if ai = tan(ui) then f(c, a1,...,an) = tan(c + u1 + ... + un).
    -- MUST BE CAREFUL FOR WHEN c IS AN ODD MULTIPLE of pi/2
    tanSum(c, l) ==
      k := c / mpiover2        -- k = - 2 c / pi, check for odd integer
                               -- tan((2n+1) pi/2 x) = - 1 / tan x
      (r := retractIfCan(k)@Union(Z, "failed")) case Z and odd?(r::Z) =>
           - inv tanSum l
      tanSum concat(tan c, l)

    rootNormalize0 f ==
      ker := select_!(is?(#1, NTHR) and empty? variables first argument #1,
                      tower f)$List(K)
      empty? ker => [f, empty(), empty()]
      (n := (#ker)::Z - 1) < 1 => [f, empty(), empty()]
      for i in 1..n for kk in rest ker repeat
        (u := rootKernelNormalize(f, first(ker, i), kk)) case REC =>
          rec := u::REC
          rn  := rootNormalize0(rec.func)
          return [rn.func, concat(rec.kers, rn.kers), concat(rec.vals, rn.vals)]
      [f, empty(), empty()]

    deprel(ker, k, x) ==
      is?(k, "log"::SY) or is?(k, "exp"::SY) =>
        qdeprel([differentiate(g, x) for g in toY ker],
                 differentiate(ktoY k, x))
      is?(k, "atan"::SY) or is?(k, "tan"::SY) =>
        qdeprel([differentiate(g, x) for g in toU ker],
                 differentiate(ktoU k, x))
      is?(k, NTHR) => rootDep(ker, k)
      comb? and is?(k, "factorial"::SY) =>
        factdeprel([x for x in ker | is?(x,"factorial"::SY) and x^=k],k)
      [true]

    ktoY k ==
      is?(k, "log"::SY) => k::F
      is?(k, "exp"::SY) => first argument k
      0

    ktoZ k ==
      is?(k, "log"::SY) => first argument k
      is?(k, "exp"::SY) => k::F
      0

    ktoU k ==
      is?(k, "atan"::SY) => k::F
      is?(k,  "tan"::SY) => first argument k
      0

    ktoV k ==
      is?(k,  "tan"::SY) => k::F
      is?(k, "atan"::SY) => first argument k
      0

    smpElem(p, l) ==
      map(k2Elem(#1, l), #1::F, p)$PolynomialCategoryLifting(
                                       IndexedExponents K, K, R, SMP, F)

    k2Elem(k, l) ==
      ez, iez, tz2: F
      kf := k::F
      not(empty? l) and empty? [v for v in variables kf | member?(v, l)] => kf
      empty?(args :List F := [realElem(a, l) for a in argument k]) => kf
      z := first args
      is?(k, POWER)       => (zero? z => 0; exp(last(args) * log z))
      is?(k, "cot"::SY)   => inv tan z
      is?(k, "acot"::SY)  => atan inv z
      is?(k, "asin"::SY)  => atan(z / sqrt(1 - z**2))
      is?(k, "acos"::SY)  => atan(sqrt(1 - z**2) / z)
      is?(k, "asec"::SY)  => atan sqrt(1 - z**2)
      is?(k, "acsc"::SY)  => atan inv sqrt(1 - z**2)
      is?(k, "asinh"::SY) => log(sqrt(1 + z**2) + z)
      is?(k, "acosh"::SY) => log(sqrt(z**2 - 1) + z)
      is?(k, "atanh"::SY) => log((z + 1) / (1 - z)) / (2::F)
      is?(k, "acoth"::SY) => log((z + 1) / (z - 1)) / (2::F)
      is?(k, "asech"::SY) => log((inv z) + sqrt(inv(z**2) - 1))
      is?(k, "acsch"::SY) => log((inv z) + sqrt(1 + inv(z**2)))
      is?(k, "%paren"::SY) or is?(k, "%box"::SY) =>
        empty? rest args => z
        kf
      if has?(op := operator k, "htrig") then iez  := inv(ez  := exp z)
      is?(k, "sinh"::SY)  => (ez - iez) / (2::F)
      is?(k, "cosh"::SY)  => (ez + iez) / (2::F)
      is?(k, "tanh"::SY)  => (ez - iez) / (ez + iez)
      is?(k, "coth"::SY)  => (ez + iez) / (ez - iez)
      is?(k, "sech"::SY)  => 2 * inv(ez + iez)
      is?(k, "csch"::SY)  => 2 * inv(ez - iez)
      if has?(op, "trig") then tz2  := tan(z / (2::F))
      is?(k, "sin"::SY)   => 2 * tz2 / (1 + tz2**2)
      is?(k, "cos"::SY)   => (1 - tz2**2) / (1 + tz2**2)
      is?(k, "sec"::SY)   => (1 + tz2**2) / (1 - tz2**2)
      is?(k, "csc"::SY)   => (1 + tz2**2) / (2 * tz2)
      op args

--The next 5 functions are used by normalize, once a relation is found
    depeval(f, lk, k, v) ==
      is?(k, "log"::SY)  => logeval(f, lk, k, v)
      is?(k, "exp"::SY)  => expeval(f, lk, k, v)
      is?(k, "tan"::SY)  => taneval(f, lk, k, v)
      is?(k, "atan"::SY) => ataneval(f, lk, k, v)
      is?(k, NTHR) => rooteval(f, lk, k, v(minIndex v))
      [f, empty(), empty()]

    rooteval(f, lk, k, n) ==
      nv := nthRoot(x := first argument k, m := retract(n)@Z)
      l  := [r for r in concat(k, toR(lk, x)) |
             retract(second argument r)@Z ^= m]
      lv := [nv ** (n / (retract(second argument r)@Z::Q)) for r in l]
      [eval(f, l, lv), l, lv]

    ataneval(f, lk, k, v) ==
      w := first argument k
      s := tanSum [tanQ(qelt(v,i), x)
                   for i in minIndex v .. maxIndex v for x in toV lk]
      g := +/[qelt(v, i) * x for i in minIndex v .. maxIndex v for x in toU lk]
      h:F :=
        zero?(d := 1 + s * w) => mpiover2
        atan((w - s) / d)
      g := g + h
      [eval(f, [k], [g]), [k], [g]]

    gdCoef?(c, v) ==
      for i in minIndex v .. maxIndex v repeat
        retractIfCan(qelt(v, i) / c)@Union(Z, "failed") case "failed" =>
          return false
      true

    goodCoef(v, l, s) ==
      for i in minIndex v .. maxIndex v for k in l repeat
        is?(k, s) and
           ((r:=recip(qelt(v,i))) case Q) and
            (retractIfCan(r::Q)@Union(Z, "failed") case Z)
              and gdCoef?(qelt(v, i), v) => return([i, k])
      "failed"

    taneval(f, lk, k, v) ==
      u := first argument k
      fns := toU lk
      c := u - +/[qelt(v, i) * x for i in minIndex v .. maxIndex v for x in fns]
      (rec := goodCoef(v, lk, "tan"::SY)) case "failed" =>
          tannosimp(f, lk, k, v, fns, c)
      v0 := retract(inv qelt(v, rec.index))@Z
      lv := [qelt(v, i) for i in minIndex v .. maxIndex v |
                                                 i ^= rec.index]$List(Q)
      l  := [kk for kk in lk | kk ^= rec.ker]
      g := tanSum(-v0 * c, concat(tanNa(k::F, v0),
           [tanNa(x, - retract(a * v0)@Z) for a in lv for x in toV l]))
      [eval(f, [rec.ker], [g]), [rec.ker], [g]]

    tannosimp(f, lk, k, v, fns, c) ==
      every?(is?(#1, "tan"::SY), lk) =>
        dd := (d := (cd := splitDenominator v).den)::F
        newt := [tan(u / dd) for u in fns]$List(F)
        newtan := [tanNa(t, d) for t in newt]$List(F)
        h := tanSum(c, [tanNa(t, qelt(cd.num, i))
                        for i in minIndex v .. maxIndex v for t in newt])
        lk := concat(k, lk)
        newtan := concat(h, newtan)
        [eval(f, lk, newtan), lk, newtan]
      h := tanSum(c, [tanQ(qelt(v, i), x)
                      for i in minIndex v .. maxIndex v for x in toV lk])
      [eval(f, [k], [h]), [k], [h]]

    expnosimp(f, lk, k, v, fns, g) ==
      every?(is?(#1, "exp"::SY), lk) =>
        dd := (d := (cd := splitDenominator v).den)::F
        newe := [exp(y / dd) for y in fns]$List(F)
        newexp := [e ** d for e in newe]$List(F)
        h := */[e ** qelt(cd.num, i)
                for i in minIndex v .. maxIndex v for e in newe] * g
        lk := concat(k, lk)
        newexp := concat(h, newexp)
        [eval(f, lk, newexp), lk, newexp]
      h := */[exp(y) ** qelt(v, i)
                for i in minIndex v .. maxIndex v for y in fns] * g
      [eval(f, [k], [h]), [k], [h]]

    logeval(f, lk, k, v) ==
      z := first argument k
      c := z / (*/[x**qelt(v, i)
                   for x in toZ lk for i in minIndex v .. maxIndex v])
-- CHANGED log ktoZ x TO ktoY x SINCE WE WANT log exp f TO BE REPLACED BY f.
      g := +/[qelt(v, i) * x
              for i in minIndex v .. maxIndex v for x in toY lk] + log c
      [eval(f, [k], [g]), [k], [g]]

    rischNormalize(f, v) ==
      empty?(ker := varselect(tower f, v)) => [f, empty(), empty()]
      first(ker) ^= kernel(v)@K => error "Cannot happen"
      ker := rest ker
      (n := (#ker)::Z - 1) < 1 => [f, empty(), empty()]
      for i in 1..n for kk in rest ker repeat
        klist := first(ker, i)
        -- NO EVALUATION ON AN EMPTY VECTOR, WILL CAUSE INFINITE LOOP
        (c := deprel(klist, kk, v)) case vec and not empty?(c.vec) =>
          rec := depeval(f, klist, kk, c.vec)
          rn  := rischNormalize(rec.func, v)
          return [rn.func,
                   concat(rec.kers, rn.kers), concat(rec.vals, rn.vals)]
        c case func =>
          rn := rischNormalize(eval(f, [kk], [c.func]), v)
          return [rn.func, concat(kk, rn.kers), concat(c.func, rn.vals)]
      [f, empty(), empty()]

    rootNormalize(f, k) ==
      (u := rootKernelNormalize(f, toR(tower f, first argument k), k))
         case "failed" => f
      (u::REC).func

    rootKernelNormalize(f, l, k) ==
      (c := rootDep(l, k)) case vec =>
        rooteval(f, l, k, (c.vec)(minIndex(c.vec)))
      "failed"

    localnorm f ==
      for x in variables f repeat
        f := rischNormalize(f, x).func
      f

    validExponential(twr, eta, x) ==
      (c := solveLinearlyOverQ(construct([differentiate(g, x)
         for g in (fns := toY twr)]$List(F))@Vector(F),
           differentiate(eta, x))) case "failed" => "failed"
      v := c::Vector(Q)
      g := eta - +/[qelt(v, i) * yy
                        for i in minIndex v .. maxIndex v for yy in fns]
      */[exp(yy) ** qelt(v, i)
                for i in minIndex v .. maxIndex v for yy in fns] * exp g

    rootDep(ker, k) ==
      empty?(ker := toR(ker, first argument k)) => [true]
      [new(1,lcm(retract(second argument k)@Z,
       "lcm"/[retract(second argument r)@Z for r in ker])::Q)$Vector(Q)]

    qdeprel(l, v) ==
      (u := solveLinearlyOverQ(construct(l)@Vector(F), v))
        case Vector(Q) => [u::Vector(Q)]
      [true]

    expeval(f, lk, k, v) ==
      y   := first argument k
      fns := toY lk
      g := y - +/[qelt(v, i) * z for i in minIndex v .. maxIndex v for z in fns]
      (rec := goodCoef(v, lk, "exp"::SY)) case "failed" =>
        expnosimp(f, lk, k, v, fns, exp g)
      v0 := retract(inv qelt(v, rec.index))@Z
      lv := [qelt(v, i) for i in minIndex v .. maxIndex v |
                                                 i ^= rec.index]$List(Q)
      l  := [kk for kk in lk | kk ^= rec.ker]
      h :F := */[exp(z) ** (- retract(a * v0)@Z) for a in lv for z in toY l]
      h := h * exp(-v0 * g) * (k::F) ** v0
      [eval(f, [rec.ker], [h]), [rec.ker], [h]]

    if F has CombinatorialOpsCategory then
      normalize f == rtNormalize localnorm factorials realElementary f

      normalize(f, x) ==
        rtNormalize(rischNormalize(factorials(realElementary(f,x),x),x).func)

      factdeprel(l, k) ==
        ((r := retractIfCan(n := first argument k)@Union(Z, "failed"))
          case Z) and (r::Z > 0) => [factorial(r::Z)::F]
        for x in l repeat
          m := first argument x
          ((r := retractIfCan(n - m)@Union(Z, "failed")) case Z) and
            (r::Z > 0) => return([*/[(m + i::F) for i in 1..r] * x::F])
        [true]

    else
      normalize f     == rtNormalize localnorm realElementary f
      normalize(f, x) == rtNormalize(rischNormalize(realElementary(f,x),x).func)

@
<<EFSTRUC.dotabb>>=
"EFSTRUC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EFSTRUC"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EFSTRUC" -> "ACF"
"EFSTRUC" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFULS ElementaryFunctionsUnivariateLaurentSeries}
\pagehead{ElementaryFunctionsUnivariateLaurentSeries}{EFULS}
\pagepic{ps/v104elementaryfunctionsunivariatelaurentseries.ps}{EFULS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EFULS ElementaryFunctionsUnivariateLaurentSeries>>=
)abbrev package EFULS ElementaryFunctionsUnivariateLaurentSeries
++ This package provides elementary functions on Laurent series.
++ Author: Clifton J. Williamson
++ Date Created: 6 February 1990
++ Date Last Updated: 25 February 1990
++ Keywords: elementary function, Laurent series
++ Examples:
++ References:
ElementaryFunctionsUnivariateLaurentSeries(Coef,UTS,ULS):_
 Exports == Implementation where
  ++ This package provides elementary functions on any Laurent series
  ++ domain over a field which was constructed from a Taylor series
  ++ domain.  These functions are implemented by calling the
  ++ corresponding functions on the Taylor series domain.  We also
  ++ provide 'partial functions' which compute transcendental
  ++ functions of Laurent series when possible and return "failed"
  ++ when this is not possible.
  Coef   : Algebra Fraction Integer
  UTS    : UnivariateTaylorSeriesCategory Coef
  ULS    : UnivariateLaurentSeriesConstructorCategory(Coef,UTS)
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  RN   ==> Fraction Integer
  S    ==> String
  STTF ==> StreamTranscendentalFunctions(Coef)
 
  Exports ==> PartialTranscendentalFunctions(ULS) with
 
    if Coef has Field then
      "**": (ULS,RN) -> ULS
        ++ s ** r raises a Laurent series s to a rational power r
 
--% Exponentials and Logarithms
 
    exp: ULS -> ULS
      ++ exp(z) returns the exponential of Laurent series z.
    log: ULS -> ULS
      ++ log(z) returns the logarithm of Laurent series z.
 
--% TrigonometricFunctionCategory
 
    sin: ULS -> ULS
      ++ sin(z) returns the sine of Laurent series z.
    cos: ULS -> ULS
      ++ cos(z) returns the cosine of Laurent series z.
    tan: ULS -> ULS
      ++ tan(z) returns the tangent of Laurent series z.
    cot: ULS -> ULS
      ++ cot(z) returns the cotangent of Laurent series z.
    sec: ULS -> ULS
      ++ sec(z) returns the secant of Laurent series z.
    csc: ULS -> ULS
      ++ csc(z) returns the cosecant of Laurent series z.
 
--% ArcTrigonometricFunctionCategory
 
    asin: ULS -> ULS
      ++ asin(z) returns the arc-sine of Laurent series z.
    acos: ULS -> ULS
      ++ acos(z) returns the arc-cosine of Laurent series z.
    atan: ULS -> ULS
      ++ atan(z) returns the arc-tangent of Laurent series z.
    acot: ULS -> ULS
      ++ acot(z) returns the arc-cotangent of Laurent series z.
    asec: ULS -> ULS
      ++ asec(z) returns the arc-secant of Laurent series z.
    acsc: ULS -> ULS
      ++ acsc(z) returns the arc-cosecant of Laurent series z.
 
--% HyperbolicFunctionCategory
 
    sinh: ULS -> ULS
      ++ sinh(z) returns the hyperbolic sine of Laurent series z.
    cosh: ULS -> ULS
      ++ cosh(z) returns the hyperbolic cosine of Laurent series z.
    tanh: ULS -> ULS
      ++ tanh(z) returns the hyperbolic tangent of Laurent series z.
    coth: ULS -> ULS
      ++ coth(z) returns the hyperbolic cotangent of Laurent series z.
    sech: ULS -> ULS
      ++ sech(z) returns the hyperbolic secant of Laurent series z.
    csch: ULS -> ULS
      ++ csch(z) returns the hyperbolic cosecant of Laurent series z.
 
--% ArcHyperbolicFunctionCategory
 
    asinh: ULS -> ULS
      ++ asinh(z) returns the inverse hyperbolic sine of Laurent series z.
    acosh: ULS -> ULS
      ++ acosh(z) returns the inverse hyperbolic cosine of Laurent series z.
    atanh: ULS -> ULS
      ++ atanh(z) returns the inverse hyperbolic tangent of Laurent series z.
    acoth: ULS -> ULS
      ++ acoth(z) returns the inverse hyperbolic cotangent of Laurent series z.
    asech: ULS -> ULS
      ++ asech(z) returns the inverse hyperbolic secant of Laurent series z.
    acsch: ULS -> ULS
      ++ acsch(z) returns the inverse hyperbolic cosecant of Laurent series z.
 
  Implementation ==> add
 
--% roots
 
    RATPOWERS : Boolean := Coef has "**":(Coef,RN) -> Coef
    TRANSFCN  : Boolean := Coef has TranscendentalFunctionCategory
    RATS      : Boolean := Coef has retractIfCan: Coef -> Union(RN,"failed")
 
    nthRootUTS:(UTS,I) -> Union(UTS,"failed")
    nthRootUTS(uts,n) ==
      -- assumed: n > 1, uts has non-zero constant term
--      one? coefficient(uts,0) => uts ** inv(n::RN)
      coefficient(uts,0) = 1 => uts ** inv(n::RN)
      RATPOWERS => uts ** inv(n::RN)
      "failed"
 
    nthRootIfCan(uls,nn) ==
      (n := nn :: I) < 1 => error "nthRootIfCan: n must be positive"
      n = 1 => uls
      deg := degree uls
      if zero? (coef := coefficient(uls,deg)) then
        uls := removeZeroes(1000,uls); deg := degree uls
        zero? (coef := coefficient(uls,deg)) =>
          error "root of series with many leading zero coefficients"
      (k := deg exquo n) case "failed" => "failed"
      uts := taylor(uls * monomial(1,-deg))
      (root := nthRootUTS(uts,n)) case "failed" => "failed"
      monomial(1,k :: I) * (root :: UTS :: ULS)
 
    if Coef has Field then
       (uls:ULS) ** (r:RN) ==
         num := numer r; den := denom r
--         one? den => uls ** num
         den = 1 => uls ** num
         deg := degree uls
         if zero? (coef := coefficient(uls,deg)) then
           uls := removeZeroes(1000,uls); deg := degree uls
           zero? (coef := coefficient(uls,deg)) =>
             error "power of series with many leading zero coefficients"
         (k := deg exquo den) case "failed" =>
           error "**: rational power does not exist"
         uts := taylor(uls * monomial(1,-deg)) ** r
         monomial(1,(k :: I) * num) * (uts :: ULS)
 
--% transcendental functions
 
    applyIfCan: (UTS -> UTS,ULS) -> Union(ULS,"failed")
    applyIfCan(fcn,uls) ==
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      fcn(uts :: UTS) :: ULS
 
    expIfCan   uls == applyIfCan(exp,uls)
    sinIfCan   uls == applyIfCan(sin,uls)
    cosIfCan   uls == applyIfCan(cos,uls)
    asinIfCan  uls == applyIfCan(asin,uls)
    acosIfCan  uls == applyIfCan(acos,uls)
    asecIfCan  uls == applyIfCan(asec,uls)
    acscIfCan  uls == applyIfCan(acsc,uls)
    sinhIfCan  uls == applyIfCan(sinh,uls)
    coshIfCan  uls == applyIfCan(cosh,uls)
    asinhIfCan uls == applyIfCan(asinh,uls)
    acoshIfCan uls == applyIfCan(acosh,uls)
    atanhIfCan uls == applyIfCan(atanh,uls)
    acothIfCan uls == applyIfCan(acoth,uls)
    asechIfCan uls == applyIfCan(asech,uls)
    acschIfCan uls == applyIfCan(acsch,uls)
 
    logIfCan uls ==
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      zero? coefficient(ts := uts :: UTS,0) => "failed"
      log(ts) :: ULS
 
    tanIfCan uls ==
      -- don't call 'tan' on a UTS (tan(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sincos(coefficients(uts :: UTS))$STTF
      (cosInv := recip(series(sc.cos) :: ULS)) case "failed" => "failed"
      (series(sc.sin) :: ULS) * (cosInv :: ULS)
 
    cotIfCan uls ==
      -- don't call 'cot' on a UTS (cot(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sincos(coefficients(uts :: UTS))$STTF
      (sinInv := recip(series(sc.sin) :: ULS)) case "failed" => "failed"
      (series(sc.cos) :: ULS) * (sinInv :: ULS)
 
    secIfCan uls ==
      cos := cosIfCan uls
      cos case "failed" => "failed"
      (cosInv := recip(cos :: ULS)) case "failed" => "failed"
      cosInv :: ULS
 
    cscIfCan uls ==
      sin := sinIfCan uls
      sin case "failed" => "failed"
      (sinInv := recip(sin :: ULS)) case "failed" => "failed"
      sinInv :: ULS

    atanIfCan uls ==
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 => "failed"
      cc : Coef := 
        ord < 0 =>
          TRANSFCN =>
            RATS =>
              lc := coefficient(uls,ord)
              (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" =>
                (1/2) * pi()
              (rat :: RN) > 0 => (1/2) * pi()
              (-1/2) * pi()
            (1/2) * pi()
          return "failed"
        coef = 0 => 0
        TRANSFCN => atan coef
        return "failed"
      (z := recip(1 + uls*uls)) case "failed" => "failed"
      (cc :: ULS) + integrate(differentiate(uls) * (z :: ULS))

    acotIfCan uls ==
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 => "failed"
      cc : Coef := 
        ord < 0 =>
          RATS =>
            lc := coefficient(uls,ord)
            (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" => 0
            (rat :: RN) > 0 => 0
            TRANSFCN => pi()
            return "failed"
          0
        TRANSFCN => acot coef
        return "failed"
      (z := recip(1 + uls*uls)) case "failed" => "failed"
      (cc :: ULS) - integrate(differentiate(uls) * (z :: ULS))
 
    tanhIfCan uls ==
      -- don't call 'tanh' on a UTS (tanh(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sinhcosh(coefficients(uts :: UTS))$STTF
      (coshInv := recip(series(sc.cosh) :: ULS)) case "failed" =>
        "failed"
      (series(sc.sinh) :: ULS) * (coshInv :: ULS)
 
    cothIfCan uls ==
      -- don't call 'coth' on a UTS (coth(uls) may have a singularity)
      uts := taylorIfCan uls
      uts case "failed" => "failed"
      sc := sinhcosh(coefficients(uts :: UTS))$STTF
      (sinhInv := recip(series(sc.sinh) :: ULS)) case "failed" =>
        "failed"
      (series(sc.cosh) :: ULS) * (sinhInv :: ULS)
 
    sechIfCan uls ==
      cosh := coshIfCan uls
      cosh case "failed" => "failed"
      (coshInv := recip(cosh :: ULS)) case "failed" => "failed"
      coshInv :: ULS
 
    cschIfCan uls ==
      sinh := sinhIfCan uls
      sinh case "failed" => "failed"
      (sinhInv := recip(sinh :: ULS)) case "failed" => "failed"
      sinhInv :: ULS
 
    applyOrError:(ULS -> Union(ULS,"failed"),S,ULS) -> ULS
    applyOrError(fcn,name,uls) ==
      ans := fcn uls
      ans case "failed" =>
        error concat(name," of function with singularity")
      ans :: ULS
 
    exp uls   == applyOrError(expIfCan,"exp",uls)
    log uls   == applyOrError(logIfCan,"log",uls)
    sin uls   == applyOrError(sinIfCan,"sin",uls)
    cos uls   == applyOrError(cosIfCan,"cos",uls)
    tan uls   == applyOrError(tanIfCan,"tan",uls)
    cot uls   == applyOrError(cotIfCan,"cot",uls)
    sec uls   == applyOrError(secIfCan,"sec",uls)
    csc uls   == applyOrError(cscIfCan,"csc",uls)
    asin uls  == applyOrError(asinIfCan,"asin",uls)
    acos uls  == applyOrError(acosIfCan,"acos",uls)
    asec uls  == applyOrError(asecIfCan,"asec",uls)
    acsc uls  == applyOrError(acscIfCan,"acsc",uls)
    sinh uls  == applyOrError(sinhIfCan,"sinh",uls)
    cosh uls  == applyOrError(coshIfCan,"cosh",uls)
    tanh uls  == applyOrError(tanhIfCan,"tanh",uls)
    coth uls  == applyOrError(cothIfCan,"coth",uls)
    sech uls  == applyOrError(sechIfCan,"sech",uls)
    csch uls  == applyOrError(cschIfCan,"csch",uls)
    asinh uls == applyOrError(asinhIfCan,"asinh",uls)
    acosh uls == applyOrError(acoshIfCan,"acosh",uls)
    atanh uls == applyOrError(atanhIfCan,"atanh",uls)
    acoth uls == applyOrError(acothIfCan,"acoth",uls)
    asech uls == applyOrError(asechIfCan,"asech",uls)
    acsch uls == applyOrError(acschIfCan,"acsch",uls)

    atan uls ==
    -- code is duplicated so that correct error messages will be returned
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 =>
        error "atan: series expansion has logarithmic term"
      cc : Coef := 
        ord < 0 =>
          TRANSFCN =>
            RATS =>
              lc := coefficient(uls,ord)
              (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" =>
                (1/2) * pi()
              (rat :: RN) > 0 => (1/2) * pi()
              (-1/2) * pi()
            (1/2) * pi()
          error "atan: series expansion involves transcendental constants"
        coef = 0 => 0
        TRANSFCN => atan coef
        error "atan: series expansion involves transcendental constants"
      (z := recip(1 + uls*uls)) case "failed" =>
        error "atan: leading coefficient not invertible"
      (cc :: ULS) + integrate(differentiate(uls) * (z :: ULS))

    acot uls ==
    -- code is duplicated so that correct error messages will be returned
      coef := coefficient(uls,0)
      (ord := order(uls,0)) = 0 and coef * coef = -1 =>
        error "acot: series expansion has logarithmic term"
      cc : Coef := 
        ord < 0 =>
          RATS =>
            lc := coefficient(uls,ord)
            (rat := retractIfCan(lc)@Union(RN,"failed")) case "failed" => 0
            (rat :: RN) > 0 => 0
            TRANSFCN => pi()
            error "acot: series expansion involves transcendental constants"
          0
        TRANSFCN => acot coef
        error "acot: series expansion involves transcendental constants"
      (z := recip(1 + uls*uls)) case "failed" =>
        error "acot: leading coefficient not invertible"
      (cc :: ULS) - integrate(differentiate(uls) * (z :: ULS))

@
<<EFULS.dotabb>>=
"EFULS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EFULS"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"EFULS" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries}
\pagehead{ElementaryFunctionsUnivariatePuiseuxSeries}{EFUPXS}
\pagepic{ps/v104elementaryfunctionsunivariatepuiseuxseries.ps}{EFUPXS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries>>=
)abbrev package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries
++ This package provides elementary functions on Puiseux series.
++ Author: Clifton J. Williamson
++ Date Created: 20 February 1990
++ Date Last Updated: 20 February 1990
++ Keywords: elementary function, Laurent series
++ Examples:
++ References:
ElementaryFunctionsUnivariatePuiseuxSeries(Coef,ULS,UPXS,EFULS):_
 Exports == Implementation where
  ++ This package provides elementary functions on any Laurent series
  ++ domain over a field which was constructed from a Taylor series
  ++ domain.  These functions are implemented by calling the
  ++ corresponding functions on the Taylor series domain.  We also
  ++ provide 'partial functions' which compute transcendental
  ++ functions of Laurent series when possible and return "failed"
  ++ when this is not possible.
  Coef   : Algebra Fraction Integer
  ULS    : UnivariateLaurentSeriesCategory Coef
  UPXS   : UnivariatePuiseuxSeriesConstructorCategory(Coef,ULS)
  EFULS  : PartialTranscendentalFunctions(ULS)
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  RN   ==> Fraction Integer
 
  Exports ==> PartialTranscendentalFunctions(UPXS) with
 
    if Coef has Field then
      "**": (UPXS,RN) -> UPXS
        ++ z ** r raises a Puiseaux series z to a rational power r
 
--% Exponentials and Logarithms
 
    exp: UPXS -> UPXS
      ++ exp(z) returns the exponential of a Puiseux series z.
    log: UPXS -> UPXS
      ++ log(z) returns the logarithm of a Puiseux series z.
 
--% TrigonometricFunctionCategory
 
    sin: UPXS -> UPXS
      ++ sin(z) returns the sine of a Puiseux series z.
    cos: UPXS -> UPXS
      ++ cos(z) returns the cosine of a Puiseux series z.
    tan: UPXS -> UPXS
      ++ tan(z) returns the tangent of a Puiseux series z.
    cot: UPXS -> UPXS
      ++ cot(z) returns the cotangent of a Puiseux series z.
    sec: UPXS -> UPXS
      ++ sec(z) returns the secant of a Puiseux series z.
    csc: UPXS -> UPXS
      ++ csc(z) returns the cosecant of a Puiseux series z.
 
--% ArcTrigonometricFunctionCategory
 
    asin: UPXS -> UPXS
      ++ asin(z) returns the arc-sine of a Puiseux series z.
    acos: UPXS -> UPXS
      ++ acos(z) returns the arc-cosine of a Puiseux series z.
    atan: UPXS -> UPXS
      ++ atan(z) returns the arc-tangent of a Puiseux series z.
    acot: UPXS -> UPXS
      ++ acot(z) returns the arc-cotangent of a Puiseux series z.
    asec: UPXS -> UPXS
      ++ asec(z) returns the arc-secant of a Puiseux series z.
    acsc: UPXS -> UPXS
      ++ acsc(z) returns the arc-cosecant of a Puiseux series z.
 
--% HyperbolicFunctionCategory
 
    sinh: UPXS -> UPXS
      ++ sinh(z) returns the hyperbolic sine of a Puiseux series z.
    cosh: UPXS -> UPXS
      ++ cosh(z) returns the hyperbolic cosine of a Puiseux series z.
    tanh: UPXS -> UPXS
      ++ tanh(z) returns the hyperbolic tangent of a Puiseux series z.
    coth: UPXS -> UPXS
      ++ coth(z) returns the hyperbolic cotangent of a Puiseux series z.
    sech: UPXS -> UPXS
      ++ sech(z) returns the hyperbolic secant of a Puiseux series z.
    csch: UPXS -> UPXS
      ++ csch(z) returns the hyperbolic cosecant of a Puiseux series z.
 
--% ArcHyperbolicFunctionCategory
 
    asinh: UPXS -> UPXS
      ++ asinh(z) returns the inverse hyperbolic sine of a Puiseux series z.
    acosh: UPXS -> UPXS
      ++ acosh(z) returns the inverse hyperbolic cosine of a Puiseux series z.
    atanh: UPXS -> UPXS
      ++ atanh(z) returns the inverse hyperbolic tangent of a Puiseux series z.
    acoth: UPXS -> UPXS
      ++ acoth(z) returns the inverse hyperbolic cotangent 
      ++ of a Puiseux series z.
    asech: UPXS -> UPXS
      ++ asech(z) returns the inverse hyperbolic secant of a Puiseux series z.
    acsch: UPXS -> UPXS
      ++ acsch(z) returns the inverse hyperbolic cosecant 
      ++ of a Puiseux series z.
 
  Implementation ==> add

    TRANSFCN : Boolean := Coef has TranscendentalFunctionCategory
 
--% roots
 
    nthRootIfCan(upxs,n) ==
--      one? n => upxs
      n = 1 => upxs
      r := rationalPower upxs; uls := laurentRep upxs
      deg := degree uls
      if zero?(coef := coefficient(uls,deg)) then
        deg := order(uls,deg + 1000)
        zero?(coef := coefficient(uls,deg)) =>
          error "root of series with many leading zero coefficients"
      uls := uls * monomial(1,-deg)$ULS
      (ulsRoot := nthRootIfCan(uls,n)) case "failed" => "failed"
      puiseux(r,ulsRoot :: ULS) * monomial(1,deg * r * inv(n :: RN))
 
    if Coef has Field then
       (upxs:UPXS) ** (q:RN) ==
         num := numer q; den := denom q
--         one? den => upxs ** num
         den = 1 => upxs ** num
         r := rationalPower upxs; uls := laurentRep upxs
         deg := degree uls
         if zero?(coef := coefficient(uls,deg)) then
           deg := order(uls,deg + 1000)
           zero?(coef := coefficient(uls,deg)) =>
             error "power of series with many leading zero coefficients"
         ulsPow := (uls * monomial(1,-deg)$ULS) ** q
         puiseux(r,ulsPow) * monomial(1,deg*q*r)
 
--% transcendental functions
 
    applyIfCan: (ULS -> Union(ULS,"failed"),UPXS) -> Union(UPXS,"failed")
    applyIfCan(fcn,upxs) ==
      uls := fcn laurentRep upxs
      uls case "failed" => "failed"
      puiseux(rationalPower upxs,uls :: ULS)
 
    expIfCan   upxs == applyIfCan(expIfCan,upxs)
    logIfCan   upxs == applyIfCan(logIfCan,upxs)
    sinIfCan   upxs == applyIfCan(sinIfCan,upxs)
    cosIfCan   upxs == applyIfCan(cosIfCan,upxs)
    tanIfCan   upxs == applyIfCan(tanIfCan,upxs)
    cotIfCan   upxs == applyIfCan(cotIfCan,upxs)
    secIfCan   upxs == applyIfCan(secIfCan,upxs)
    cscIfCan   upxs == applyIfCan(cscIfCan,upxs)
    atanIfCan  upxs == applyIfCan(atanIfCan,upxs)
    acotIfCan  upxs == applyIfCan(acotIfCan,upxs)
    sinhIfCan  upxs == applyIfCan(sinhIfCan,upxs)
    coshIfCan  upxs == applyIfCan(coshIfCan,upxs)
    tanhIfCan  upxs == applyIfCan(tanhIfCan,upxs)
    cothIfCan  upxs == applyIfCan(cothIfCan,upxs)
    sechIfCan  upxs == applyIfCan(sechIfCan,upxs)
    cschIfCan  upxs == applyIfCan(cschIfCan,upxs)
    asinhIfCan upxs == applyIfCan(asinhIfCan,upxs)
    acoshIfCan upxs == applyIfCan(acoshIfCan,upxs)
    atanhIfCan upxs == applyIfCan(atanhIfCan,upxs)
    acothIfCan upxs == applyIfCan(acothIfCan,upxs)
    asechIfCan upxs == applyIfCan(asechIfCan,upxs)
    acschIfCan upxs == applyIfCan(acschIfCan,upxs)

    asinIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      (coef := coefficient(upxs,0)) = 0 =>
        integrate((1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      TRANSFCN =>
        cc := asin(coef) :: UPXS
        cc + integrate((1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      "failed"

    acosIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := acos(coefficient(upxs,0)) :: UPXS
        cc + integrate(-(1 - upxs*upxs)**(-1/2) * (differentiate upxs))
      "failed"

    asecIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := asec(coefficient(upxs,0)) :: UPXS
        f := (upxs*upxs - 1)**(-1/2) * (differentiate upxs)
        (rec := recip upxs) case "failed" => "failed"
        cc + integrate(f * (rec :: UPXS))
      "failed"

    acscIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN =>
        cc := acsc(coefficient(upxs,0)) :: UPXS
        f := -(upxs*upxs - 1)**(-1/2) * (differentiate upxs)
        (rec := recip upxs) case "failed" => "failed"
        cc + integrate(f * (rec :: UPXS))
      "failed"

    asinhIfCan upxs ==
      order(upxs,0) < 0 => "failed"
      TRANSFCN or (coefficient(upxs,0) = 0) =>
        log(upxs + (1 + upxs*upxs)**(1/2))
      "failed"

    acoshIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        log(upxs + (upxs*upxs - 1)**(1/2))
      "failed"

    asechIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        (rec := recip upxs) case "failed" => "failed"
        log((1 + (1 - upxs*upxs)*(1/2)) * (rec :: UPXS))
      "failed"

    acschIfCan upxs ==
      TRANSFCN =>
        order(upxs,0) < 0 => "failed"
        (rec := recip upxs) case "failed" => "failed"
        log((1 + (1 + upxs*upxs)*(1/2)) * (rec :: UPXS))
      "failed"
 
    applyOrError:(UPXS -> Union(UPXS,"failed"),String,UPXS) -> UPXS
    applyOrError(fcn,name,upxs) ==
      ans := fcn upxs
      ans case "failed" =>
        error concat(name," of function with singularity")
      ans :: UPXS
 
    exp upxs   == applyOrError(expIfCan,"exp",upxs)
    log upxs   == applyOrError(logIfCan,"log",upxs)
    sin upxs   == applyOrError(sinIfCan,"sin",upxs)
    cos upxs   == applyOrError(cosIfCan,"cos",upxs)
    tan upxs   == applyOrError(tanIfCan,"tan",upxs)
    cot upxs   == applyOrError(cotIfCan,"cot",upxs)
    sec upxs   == applyOrError(secIfCan,"sec",upxs)
    csc upxs   == applyOrError(cscIfCan,"csc",upxs)
    asin upxs  == applyOrError(asinIfCan,"asin",upxs)
    acos upxs  == applyOrError(acosIfCan,"acos",upxs)
    atan upxs  == applyOrError(atanIfCan,"atan",upxs)
    acot upxs  == applyOrError(acotIfCan,"acot",upxs)
    asec upxs  == applyOrError(asecIfCan,"asec",upxs)
    acsc upxs  == applyOrError(acscIfCan,"acsc",upxs)
    sinh upxs  == applyOrError(sinhIfCan,"sinh",upxs)
    cosh upxs  == applyOrError(coshIfCan,"cosh",upxs)
    tanh upxs  == applyOrError(tanhIfCan,"tanh",upxs)
    coth upxs  == applyOrError(cothIfCan,"coth",upxs)
    sech upxs  == applyOrError(sechIfCan,"sech",upxs)
    csch upxs  == applyOrError(cschIfCan,"csch",upxs)
    asinh upxs == applyOrError(asinhIfCan,"asinh",upxs)
    acosh upxs == applyOrError(acoshIfCan,"acosh",upxs)
    atanh upxs == applyOrError(atanhIfCan,"atanh",upxs)
    acoth upxs == applyOrError(acothIfCan,"acoth",upxs)
    asech upxs == applyOrError(asechIfCan,"asech",upxs)
    acsch upxs == applyOrError(acschIfCan,"acsch",upxs)

@
<<EFUPXS.dotabb>>=
"EFUPXS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EFUPXS"]
"UPXSCCA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UPXSCCA"]
"EFUPXS" -> "UPXSCCA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTEF ElementaryIntegration}
\pagehead{ElementaryIntegration}{INTEF}
\pagepic{ps/v104elementaryintegration.ps}{INTEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTEF ElementaryIntegration>>=
)abbrev package INTEF ElementaryIntegration
++ Integration of elementary functions
++ Author: Manuel Bronstein
++ Date Created: 1 February 1988
++ Date Last Updated: 24 October 1995
++ Description:
++ This package provides functions for integration, limited integration,
++ extended integration and the risch differential equation for
++ elemntary functions.
++ Keywords: elementary, function, integration.
++ Examples: )r INTEF INPUT
ElementaryIntegration(R, F): Exports == Implementation where
  R : Join(GcdDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  SE  ==> Symbol
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  IR  ==> IntegrationResult F
  FF  ==> Record(ratpart:RF, coeff:RF)
  LLG ==> List Record(coeff:F, logand:F)
  U2  ==> Union(Record(ratpart:F, coeff:F), "failed")
  U3  ==> Union(Record(mainpart:F, limitedlogs:LLG), "failed")
  ANS ==> Record(special:F, integrand:F)
  FAIL==> error "failed - cannot handle that integrand"
  ALGOP  ==> "%alg"
  OPDIFF ==> "%diff"::SE

  Exports ==> with
    lfextendedint: (F, SE, F) -> U2
       ++ lfextendedint(f, x, g) returns functions \spad{[h, c]} such that
       ++ \spad{dh/dx = f - cg}, if (h, c) exist, "failed" otherwise.
    lflimitedint : (F, SE, List F) -> U3
       ++ lflimitedint(f,x,[g1,...,gn]) returns functions \spad{[h,[[ci, gi]]]}
       ++ such that the gi's are among \spad{[g1,...,gn]}, and
       ++ \spad{d(h+sum(ci log(gi)))/dx = f}, if possible, "failed" otherwise.
    lfinfieldint : (F, SE) -> Union(F, "failed")
       ++ lfinfieldint(f, x) returns a function g such that \spad{dg/dx = f}
       ++ if g exists, "failed" otherwise.
    lfintegrate  : (F, SE) -> IR
       ++ lfintegrate(f, x) = g such that \spad{dg/dx = f}.
    lfextlimint  : (F, SE, K, List K) -> U2
       ++ lfextlimint(f,x,k,[k1,...,kn]) returns functions \spad{[h, c]}
       ++ such that \spad{dh/dx = f - c dk/dx}. Value h is looked for in a field
       ++ containing f and k1,...,kn (the ki's must be logs).

  Implementation ==> add
    import IntegrationTools(R, F)
    import ElementaryRischDE(R, F)
    import RationalIntegration(F, UP)
    import AlgebraicIntegration(R, F)
    import AlgebraicManipulations(R, F)
    import ElementaryRischDESystem(R, F)
    import TranscendentalIntegration(F, UP)
    import PureAlgebraicIntegration(R, F, F)
    import IntegrationResultFunctions2(F, F)
    import IntegrationResultFunctions2(RF, F)
    import FunctionSpacePrimitiveElement(R, F)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                             K, R, P, F)

    alglfint    : (F, K, List K, SE) -> IR
    alglfextint : (F, K, List K, SE, F) -> U2
    alglflimint : (F, K, List K, SE, List F) -> U3
    primextint  : (F, SE, K, F) -> U2
    expextint   : (F, SE, K, F) -> U2
    primlimint  : (F, SE, K, List F) -> U3
    explimint   : (F, SE, K, List F) -> U3
    algprimint  : (F, K, K, SE) -> IR
    algexpint   : (F, K, K, SE) -> IR
    primint     : (F, SE, K) -> IR
    expint      : (F, SE, K) -> IR
    tanint      : (F, SE, K) -> IR
    prim?       : (K, SE)  -> Boolean
    isx?        : (F, SE)  -> Boolean
    addx        : (IR, F) -> IR
    cfind       : (F, LLG) -> F
    lfintegrate0: (F, SE) -> IR
    unknownint  : (F, SE) -> IR
    unkextint   : (F, SE, F) -> U2
    unklimint   : (F, SE, List F) -> U3
    tryChangeVar: (F, K, SE) -> Union(IR, "failed")
    droponex    : (F, F, K, F) -> Union(F, "failed")

    prim?(k, x)      == is?(k, "log"::SE) or has?(operator k, "prim")

    tanint(f, x, k) ==
      eta' := differentiate(eta := first argument k, x)
      r1  := tanintegrate(univariate(f, k), differentiate(#1,
              differentiate(#1, x), monomial(eta', 2) + eta'::UP),
                rischDEsys(#1, 2 * eta, #2, #3, x, lflimitedint(#1, x, #2),
                   lfextendedint(#1, x, #2)))
      map(multivariate(#1, k), r1.answer) + lfintegrate(r1.a0, x)

-- tries various tricks since the integrand contains something not elementary
    unknownint(f, x) ==
      ((r := retractIfCan(f)@Union(K, "failed")) case K) and
        is?(k := r::K, OPDIFF) and
          ((ka:=retractIfCan(a:=second(l:=argument k))@Union(K,"failed"))case K)
            and ((z := retractIfCan(zz := third l)@Union(SE, "failed")) case SE)
              and (z::SE = x)
                and ((u := droponex(first l, a, ka, zz)) case F) => u::F::IR
      (da := differentiate(a := denom(f)::F, x)) ^= 0 and
        zero? differentiate(c := numer(f)::F / da, x) => (c * log a)::IR
      mkAnswer(0, empty(), [[f, x::F]])

    droponex(f, a, ka, x) ==
      (r := retractIfCan(f)@Union(K, "failed")) case "failed" => "failed"
      is?(op := operator(k := r::K), OPDIFF) =>
        (z := third(arg := argument k)) = a => op [first arg, second arg, x]
        (u := droponex(first arg, a, ka, x)) case "failed" => "failed"
        op [u::F, second arg, z]
      eval(f, [ka], [x])

    unklimint(f, x, lu) ==
      for u in lu | u ^= 0 repeat
        zero? differentiate(c := f * u / differentiate(u, x), x) => [0,[[c,u]]]
      "failed"

    unkextint(f, x, g) ==
      zero?(g' := differentiate(g, x)) => "failed"
      zero? differentiate(c := f / g', x) => [0, c]
      "failed"

    isx?(f, x) ==
      (k := retractIfCan(f)@Union(K, "failed")) case "failed" => false
      (r := symbolIfCan(k::K)) case "failed" => false
      r::SE = x

    alglfint(f, k, l, x) ==
      xf := x::F
      symbolIfCan(kx := ksec(k,l,x)) case SE => addx(palgint(f, kx, k), xf)
      is?(kx, "exp"::SE) => addx(algexpint(f, kx, k, x), xf)
      prim?(kx, x)       => addx(algprimint(f, kx, k, x), xf)
      has?(operator kx, ALGOP) =>
        rec := primitiveElement(kx::F, k::F)
        y   := rootOf(rec.prim)
        map(eval(#1, retract(y)@K, rec.primelt),
          lfintegrate(eval(f, [kx,k], [(rec.pol1) y, (rec.pol2) y]), x))
      unknownint(f, x)

    alglfextint(f, k, l, x, g) ==
      symbolIfCan(kx := ksec(k,l,x)) case SE => palgextint(f, kx, k, g)
      has?(operator kx, ALGOP) =>
        rec := primitiveElement(kx::F, k::F)
        y   := rootOf(rec.prim)
        lrhs := [(rec.pol1) y, (rec.pol2) y]$List(F)
        (u := lfextendedint(eval(f, [kx, k], lrhs), x,
                    eval(g, [kx, k], lrhs))) case "failed" => "failed"
        ky := retract(y)@K
        r := u::Record(ratpart:F, coeff:F)
        [eval(r.ratpart,ky,rec.primelt), eval(r.coeff,ky,rec.primelt)]
      is?(kx, "exp"::SE) or is?(kx, "log"::SE) => FAIL
      unkextint(f, x, g)

    alglflimint(f, k, l, x, lu) ==
      symbolIfCan(kx := ksec(k,l,x)) case SE => palglimint(f, kx, k, lu)
      has?(operator kx, ALGOP) =>
        rec := primitiveElement(kx::F, k::F)
        y   := rootOf(rec.prim)
        lrhs := [(rec.pol1) y, (rec.pol2) y]$List(F)
        (u := lflimitedint(eval(f, [kx, k], lrhs), x,
           map(eval(#1, [kx, k], lrhs), lu))) case "failed" => "failed"
        ky := retract(y)@K
        r := u::Record(mainpart:F, limitedlogs:LLG)
        [eval(r.mainpart, ky, rec.primelt),
          [[eval(rc.coeff, ky, rec.primelt),
            eval(rc.logand,ky, rec.primelt)] for rc in r.limitedlogs]]
      is?(kx, "exp"::SE) or is?(kx, "log"::SE) => FAIL
      unklimint(f, x, lu)

    if R has Join(ConvertibleTo Pattern Integer, PatternMatchable Integer)
      and F has Join(LiouvillianFunctionCategory, RetractableTo SE) then
        import PatternMatchIntegration(R, F)
        lfintegrate(f, x) == intPatternMatch(f, x, lfintegrate0, pmintegrate)

    else lfintegrate(f, x) == lfintegrate0(f, x)

    lfintegrate0(f, x) ==
      zero? f => 0
      xf := x::F
      empty?(l := varselect(kernels f, x)) => (xf * f)::IR
      symbolIfCan(k := kmax l) case SE =>
        map(multivariate(#1, k), integrate univariate(f, k))
      is?(k, "tan"::SE)  => addx(tanint(f, x, k), xf)
      is?(k, "exp"::SE)  => addx(expint(f, x, k), xf)
      prim?(k, x)        => addx(primint(f, x, k), xf)
      has?(operator k, ALGOP) => alglfint(f, k, l, x)
      unknownint(f, x)

    addx(i, x) ==
      elem? i => i
      mkAnswer(ratpart i, logpart i,
                                [[ne.integrand, x] for ne in notelem i])

    tryChangeVar(f, t, x) ==
        z := new()$Symbol
        g := subst(f / differentiate(t::F, x), [t], [z::F])
        freeOf?(g, x) =>               -- can we do change of variables?
            map(eval(#1, kernel z, t::F), lfintegrate(g, z))
        "failed"

    algexpint(f, t, y, x) ==
        (u := tryChangeVar(f, t, x)) case IR => u::IR
        algint(f, t, y,  differentiate(#1, differentiate(#1, x),
                       monomial(differentiate(first argument t, x), 1)))

    algprimint(f, t, y, x) ==
        (u := tryChangeVar(f, t, x)) case IR => u::IR
        algint(f, t, y, differentiate(#1, differentiate(#1, x),
                                            differentiate(t::F, x)::UP))

@
Bug \#100 is an infinite loop that eventually kills Axiom 
from the input
\begin{verbatim}
  integrate((z^a+1)^b,z)
\end{verbatim}

Line 2 of this function used to read:
\begin{verbatim}
      symbolIfCan(k := kmax(l := union(l, varselect(kernels g, x))))
\end{verbatim}

The loop occurs when the call to union causes 
\begin{verbatim}
                     a log(z)
                   %e        
\end{verbatim}
to get added to the list every time. This gives the argument to kmax 
\begin{verbatim}
                 a log(z)
      arg1= [z,%e        ]
\end{verbatim}
and the result being
\begin{verbatim}
        a log(z)
      %e
\end{verbatim}
We keep coming back to process this term, which ends up 
putting the same term back on the list and we loop.
Waldek's solution is to remove the union call. 

The original patch fixed the infinite regression mentioned above
but caused Axiom to return a closed form of the integral:
\[integrate(asech(x)/x,x)\]
which should not have a closed form. This is referenced in 
the FriCAS SVN revision 279.

Essentially this new patch uses only logarithms of rational functions
when integrating rational functions.  It is unclear whether this is
the correct fix.

<<package INTEF ElementaryIntegration>>=
    lfextendedint(f, x, g) ==
      empty?(l := varselect(kernels f, x)) => [x::F * f, 0]
      symbolIfCan(k := kmax(l))
        case SE =>
         g1 :=
           empty?(l1 := varselect(kernels g,x)) => 0::F
           kmax(l1) = k => g
           0::F
         map(multivariate(#1, k), extendedint(univariate(f, k),
                                              univariate(g1, k)))
      is?(k, "exp"::SE) => expextint(f, x, k, g)
      prim?(k, x)       => primextint(f, x, k, g)
      has?(operator k, ALGOP) => alglfextint(f, k, l, x, g)
      unkextint(f, x, g)

@
This is part of the fix for bug 100. Line 2 of this function used to read:
\begin{verbatim}
      symbolIfCan(k := kmax(l := union(l, vark(lu, x)))) case SE =>
\end{verbatim}
See the above discussion for why this causes an infinite loop.
<<package INTEF ElementaryIntegration>>=
    lflimitedint(f, x, lu) ==
      empty?(l := varselect(kernels f, x)) => [x::F * f, empty()]
      symbolIfCan(k := kmax(l)) case SE =>
       map(multivariate(#1, k), limitedint(univariate(f, k),
                                        [univariate(u, k) for u in lu]))
      is?(k, "exp"::SE) => explimint(f, x, k, lu)
      prim?(k, x)       => primlimint(f, x, k, lu)
      has?(operator k, ALGOP) => alglflimint(f, k, l, x, lu)
      unklimint(f, x, lu)

    lfinfieldint(f, x) ==
      (u := lfextendedint(f, x, 0)) case "failed" => "failed"
      u.ratpart

    primextint(f, x, k, g) ==
      lk := varselect([a for a in tower f
                                     | k ^= a and is?(a, "log"::SE)], x)
      (u1 := primextendedint(univariate(f, k), differentiate(#1,
           differentiate(#1, x), differentiate(k::F, x)::UP),
             lfextlimint(#1, x, k, lk), univariate(g, k))) case "failed"
                => "failed"
      u1 case FF =>
        [multivariate(u1.ratpart, k), multivariate(u1.coeff, k)]
      (u2 := lfextendedint(u1.a0, x, g)) case "failed" => "failed"
      [multivariate(u1.answer, k) + u2.ratpart, u2.coeff]

    expextint(f, x, k, g) ==
      (u1 := expextendedint(univariate(f, k), differentiate(#1,
         differentiate(#1, x),
          monomial(differentiate(first argument k, x), 1)),
           rischDE(#1, first argument k, #2, x, lflimitedint(#1, x, #2),
            lfextendedint(#1, x, #2)), univariate(g, k)))
               case "failed" => "failed"
      u1 case FF =>
        [multivariate(u1.ratpart, k), multivariate(u1.coeff, k)]
      (u2 := lfextendedint(u1.a0, x, g)) case "failed" => "failed"
      [multivariate(u1.answer, k) + u2.ratpart, u2.coeff]

    primint(f, x, k) ==
      lk := varselect([a for a in tower f
                                     | k ^= a and is?(a, "log"::SE)], x)
      r1 := primintegrate(univariate(f, k), differentiate(#1,
                      differentiate(#1, x), differentiate(k::F, x)::UP),
                                              lfextlimint(#1, x, k, lk))
      map(multivariate(#1, k), r1.answer) + lfintegrate(r1.a0, x)

    lfextlimint(f, x, k, lk) ==
      not((u1 := lfextendedint(f, x, differentiate(k::F, x)))
        case "failed") => u1
      twr := tower f
      empty?(lg := [kk for kk in lk | not member?(kk, twr)]) => "failed"
      is?(k, "log"::SE) =>
        (u2 := lflimitedint(f, x,
          [first argument u for u in union(lg, [k])])) case "failed"
                                                             => "failed"
        cf := cfind(first argument k, u2.limitedlogs)
        [u2.mainpart - cf * k::F +
                +/[c.coeff * log(c.logand) for c in u2.limitedlogs], cf]
      "failed"

    cfind(f, l) ==
      for u in l repeat
        f = u.logand => return u.coeff
      0

    expint(f, x, k) ==
      eta := first argument k
      r1  := expintegrate(univariate(f, k), differentiate(#1,
              differentiate(#1, x), monomial(differentiate(eta, x), 1)),
                 rischDE(#1, eta, #2, x, lflimitedint(#1, x, #2),
                   lfextendedint(#1, x, #2)))
      map(multivariate(#1, k), r1.answer) + lfintegrate(r1.a0, x)

    primlimint(f, x, k, lu) ==
      lk := varselect([a for a in tower f
                                     | k ^= a and is?(a, "log"::SE)], x)
      (u1 := primlimitedint(univariate(f, k), differentiate(#1,
          differentiate(#1, x), differentiate(k::F, x)::UP),
             lfextlimint(#1, x, k, lk), [univariate(u, k) for u in lu]))
                                               case "failed" => "failed"
      l := [[multivariate(lg.coeff, k),multivariate(lg.logand, k)]
                                    for lg in u1.answer.limitedlogs]$LLG
      (u2 := lflimitedint(u1.a0, x, lu)) case "failed" => "failed"
      [multivariate(u1.answer.mainpart, k) + u2.mainpart,
                                              concat(u2.limitedlogs, l)]

    explimint(f, x, k, lu) ==
      eta := first argument k
      (u1 := explimitedint(univariate(f, k), differentiate(#1,
        differentiate(#1, x), monomial(differentiate(eta, x), 1)),
          rischDE(#1, eta, #2, x,
            lflimitedint(#1, x, #2), lfextendedint(#1, x, #2)),
              [univariate(u, k) for u in lu])) case "failed" => "failed"
      l := [[multivariate(lg.coeff, k),multivariate(lg.logand, k)]
                                    for lg in u1.answer.limitedlogs]$LLG
      (u2 := lflimitedint(u1.a0, x, lu)) case "failed" => "failed"
      [multivariate(u1.answer.mainpart, k) + u2.mainpart,
                                              concat(u2.limitedlogs, l)]

@
<<INTEF.dotabb>>=
"INTEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTEF"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"INTEF" -> "ACF"
"INTEF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ELFUTS EllipticFunctionsUnivariateTaylorSeries}
\pagehead{EllipticFunctionsUnivariateTaylorSeries}{ELFUTS}
\pagepic{ps/v104ellipticfunctionsunivariatetaylorseries.ps}{ELFUTS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ELFUTS EllipticFunctionsUnivariateTaylorSeries>>=
)abbrev package ELFUTS EllipticFunctionsUnivariateTaylorSeries
++ Elliptic functions expanded as Taylor series
++ Author: Bill Burge, Clifton J. Williamson
++ Date Created: 1986
++ Date Last Updated: 17 February 1992
++ Keywords: elliptic function, Taylor series
++ Examples:
++ References:
++ Description: The elliptic functions sn, sc and dn are expanded as
++ Taylor series.
EllipticFunctionsUnivariateTaylorSeries(Coef,UTS):
 Exports == Implementation where
  Coef : Field
  UTS  : UnivariateTaylorSeriesCategory Coef
 
  L   ==> List
  I   ==> Integer
  RN  ==> Fraction Integer
  ST  ==> Stream Coef
  STT ==> StreamTaylorSeriesOperations Coef
  YS  ==> Y$ParadoxicalCombinatorsForStreams(Coef)
 
  Exports ==> with
    sn     : (UTS,Coef) -> UTS
      ++\spad{sn(x,k)} expands the elliptic function sn as a Taylor
      ++ series.
    cn     : (UTS,Coef) -> UTS
      ++\spad{cn(x,k)} expands the elliptic function cn as a Taylor
      ++ series.
    dn     : (UTS,Coef) -> UTS
      ++\spad{dn(x,k)} expands the elliptic function dn as a Taylor
      ++ series.
    sncndn: (ST,Coef) -> L ST
       ++\spad{sncndn(s,c)} is used internally.
 
  Implementation ==> add
    import StreamTaylorSeriesOperations Coef
    UPS==> StreamTaylorSeriesOperations Coef
    integrate ==> lazyIntegrate
    sncndnre:(Coef,L ST,ST,Coef) -> L ST
    sncndnre(k,scd,dx,sign) ==
            [integrate(0,      scd.2*$UPS scd.3*$UPS dx),  _
             integrate(1,  sign*scd.1*$UPS scd.3*$UPS dx),  _
             integrate(1,sign*k**2*$UPS scd.1*$UPS scd.2*$UPS dx)]
 
    sncndn(z,k) ==
      empty? z => [0 :: ST,1 :: ST,1::ST]
      frst z = 0 => YS(sncndnre(k,#1,deriv z,-1),3)
      error "ELFUTS:sncndn: constant coefficient should be 0"
    sn(x,k)  == series sncndn.(coefficients x,k).1
    cn(x,k)  == series sncndn.(coefficients x,k).2
    dn(x,k)  == series sncndn.(coefficients x,k).3

@
<<ELFUTS.dotabb>>=
"ELFUTS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ELFUTS"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"ELFUTS" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EQ2 EquationFunctions2}
\pagehead{EquationFunctions2}{EQ2}
\pagepic{ps/v104equationfunctions2.ps}{EQ2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EQ2 EquationFunctions2>>=
)abbrev package EQ2 EquationFunctions2
++ Author:
++ Date Created:
++ Date Last Updated: June 3, 1991
++ Basic Operations:
++ Related Domains: Equation
++ Also See:
++ AMS Classifications:
++ Keywords: equation
++ Examples:
++ References:
++ Description:
++   This package provides operations for mapping the sides of equations.
EquationFunctions2(S: Type, R: Type): with
    map: (S ->R ,Equation S) -> Equation R
	++ map(f,eq) returns an equation where f is applied to the sides of eq
 == add
    map(fn, eqn) == equation(fn lhs eqn, fn rhs eqn)

@
<<EQ2.dotabb>>=
"EQ2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EQ2"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"EQ2" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ERROR ErrorFunctions}
\pagehead{ErrorFunctions}{ERROR}
\pagepic{ps/v104errorfunctions.ps}{ERROR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ERROR ErrorFunctions>>=
)abbrev package ERROR ErrorFunctions
++ Author: Robert S. Sutor
++ Date Created: 29 May 1990
++ Date Last Updated: 29 May 1990
++ Description:
++ ErrorFunctions implements error functions callable from the system
++ interpreter.  Typically, these functions would be called in user
++ functions.  The simple forms of the functions take one argument
++ which is either a string (an error message) or a list of strings
++ which all together make up a message.  The list can contain
++ formatting codes (see below).  The more sophisticated versions takes
++ two arguments where the first argument is the name of the function
++ from which the error was invoked and the second argument is either a
++ string or a list of strings, as above.  When you use the one
++ argument version in an interpreter function, the system will
++ automatically insert the name of the function as the new first
++ argument.  Thus in the user interpreter function
++   \spad{f x == if x < 0 then error "negative argument" else x}
++ the call to error will actually be of the form
++   \spad{error("f","negative argument")}
++ because the interpreter will have created a new first argument.
++
++ Formatting codes:  error messages may contain the following
++ formatting codes (they should either start or end a string or
++ else have blanks around them):
++    \spad{%l}      start a new line
++    \spad{%b}      start printing in a bold font (where available)
++    \spad{%d}      stop  printing in a bold font (where available)
++    \spad{ %ceon}  start centering message lines
++    \spad{%ceoff}  stop  centering message lines
++    \spad{%rjon}   start displaying lines "ragged left"
++    \spad{%rjoff}  stop  displaying lines "ragged left"
++    \spad{%i}      indent   following lines 3 additional spaces
++    \spad{%u}      unindent following lines 3 additional spaces
++    \spad{%xN}     insert N blanks (eg, \spad{%x10} inserts 10 blanks)
++
++ Examples:
++   1.  \spad{error "Whoops, you made a %l %ceon %b big %d %ceoff %l mistake!"}
++   2.  \spad{error ["Whoops, you made a","%l %ceon %b","big",
++              "%d %ceoff %l","mistake!"]}
 
ErrorFunctions() : Exports == Implementation where
  Exports ==> with
    error: String -> Exit 
      ++ error(msg) displays error message msg and terminates.
    error: List String -> Exit            
      ++ error(lmsg) displays error message lmsg and terminates.
    error: (String,String) -> Exit        
      ++ error(nam,msg) displays error message msg preceded by a
      ++ message containing the name nam of the function in which
      ++ the error is contained.
    error: (String,List String) -> Exit   
      ++ error(nam,lmsg) displays error messages lmsg preceded by a
      ++ message containing the name nam of the function in which
      ++ the error is contained.
  Implementation ==> add
 
    prefix1 : String := "Error signalled from user code: %l "
    prefix2 : String := "Error signalled from user code in function %b "
 
    doit(s : String) : Exit ==
      throwPatternMsg(s,nil$(List String))$Lisp
      -- there are no objects of type Exit, so we'll fake one,
      -- knowing we will never get to this step anyway.
      "exit" pretend Exit
 
    error(s : String) : Exit ==
      doit concat [prefix1,s]
 
    error(l : List String) : Exit ==
      s : String := prefix1
      for x in l repeat s := concat [s," ",x]
      doit s
 
    error(fn : String,s : String) : Exit ==
      doit concat [prefix2,fn,": %d %l ",s]
 
    error(fn : String, l : List String) : Exit ==
      s : String := concat [prefix2,fn,": %d %l"]
      for x in l repeat s := concat [s," ",x]
      doit s

@
<<ERROR.dotabb>>=
"ERROR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ERROR"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"ERROR" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GBEUCLID EuclideanGroebnerBasisPackage}
<<EuclideanGroebnerBasisPackage.input>>=
)sys rm EuclideanGroebnerBasisPackage.output
)spool EuclideanGroebnerBasisPackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 24
a1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
--R
--R            2                2
--R   (1)  3y x  + 2y x + y + 9x  + 5x - 3
--R                       Type: DistributedMultivariatePolynomial([y,x],Integer)
--E 1

--S 2 of 24
a2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
--R
--R            3               3     2
--R   (2)  2y x  - y x - y + 6x  - 2x  - 3x + 3
--R                       Type: DistributedMultivariatePolynomial([y,x],Integer)
--E 2

--S 3 of 24
a3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
--R
--R           3      2     3     2
--R   (3)  y x  + y x  + 3x  + 2x
--R                       Type: DistributedMultivariatePolynomial([y,x],Integer)
--E 3

--S 4 of 24
an:=[a1,a2,a3]
--R
--R   (4)
--R        2                2               3               3     2
--R   [3y x  + 2y x + y + 9x  + 5x - 3, 2y x  - y x - y + 6x  - 2x  - 3x + 3,
--R       3      2     3     2
--R    y x  + y x  + 3x  + 2x ]
--R                  Type: List DistributedMultivariatePolynomial([y,x],Integer)
--E 4

--S 5 of 24
euclideanGroebner(an)
--R
--R                                2            3     2
--R   (5)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--R                  Type: List DistributedMultivariatePolynomial([y,x],Integer)
--E 5

--S 6 of 24
euclideanGroebner(an,"redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2               2
--R   - 2y x  - y x - y - 6x  - 3x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   4y + 4x  - 6x - 12
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3      2
--R   - 4x  + 10x  + 10x
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   2y + 2x  - 3x - 6
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3     2
--R   - 2x  + 5x  + 5x
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                2            3     2
--R   (6)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--R                  Type: List DistributedMultivariatePolynomial([y,x],Integer)
--E 6

--S 7 of 24
euclideanGroebner(an,"info")
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 2,tD= 3]]
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 3,tD= 4]]
--R
--R
--R   [[ci= y,tci= 4,cj= y,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 3]]
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R          3             3
--R   [[ci= x ,tci= 3,cj= x ,tcj= 3,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 2]]
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R                       3              2
--R   [[ci= y,tci= 4,cj= x ,tcj= 3,c= y x ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                2            3     2
--R   (7)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--R                  Type: List DistributedMultivariatePolynomial([y,x],Integer)
--E 7

--S 8 of 24
euclideanGroebner(an,"info","redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2               2
--R   - 2y x  - y x - y - 6x  - 3x + 3
--R
--R
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   4y + 4x  - 6x - 12
--R
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 2,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3      2
--R   - 4x  + 10x  + 10x
--R
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   2y + 2x  - 3x - 6
--R
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 3,tD= 4]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= y,tci= 4,cj= y,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3     2
--R   - 2x  + 5x  + 5x
--R
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          3             3
--R   [[ci= x ,tci= 3,cj= x ,tcj= 3,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                       3              2
--R   [[ci= y,tci= 4,cj= x ,tcj= 3,c= y x ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                2            3     2
--R   (8)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--R                  Type: List DistributedMultivariatePolynomial([y,x],Integer)
--E 8

--S 9 of 24
b1:HDMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
--R
--R            2            2
--R   (9)  3y x  + 2y x + 9x  + y + 5x - 3
--R            Type: HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 9

--S 10 of 24
b2:HDMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
--R
--R             3     3           2
--R   (10)  2y x  + 6x  - y x - 2x  - y - 3x + 3
--R            Type: HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 10

--S 11 of 24
b3:HDMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
--R
--R            3      2     3     2
--R   (11)  y x  + y x  + 3x  + 2x
--R            Type: HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 11

--S 12 of 24
bn:=[b1,b2,b3]
--R
--R   (12)
--R        2            2                   3     3           2
--R   [3y x  + 2y x + 9x  + y + 5x - 3, 2y x  + 6x  - y x - 2x  - y - 3x + 3,
--R       3      2     3     2
--R    y x  + y x  + 3x  + 2x ]
--R       Type: List HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 12

--S 13 of 24
euclideanGroebner(bn)
--R
--R            2                                 2
--R   (13)  [2y  - 5y - 8x - 3,y x - y + x + 3,2x  + 2y - 3x - 6]
--R       Type: List HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 13

--S 14 of 24
euclideanGroebner(bn,"redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2           2
--R   - 2y x  - y x - 6x  - y - 3x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R     2
--R   4x  + 4y - 6x - 12
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R     2
--R   2x  + 2y - 3x - 6
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       2
--R   - 2y  + 5y + 8x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R            2                                 2
--R   (14)  [2y  - 5y - 8x - 3,y x - y + x + 3,2x  + 2y - 3x - 6]
--R       Type: List HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 14

--S 15 of 24
euclideanGroebner(bn,"info")
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R            2                                         2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= x ,trc= 4,tH= 2,tD= 3]]
--R
--R
--R            2                                         2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= x ,trc= 4,tH= 2,tD= 3]]
--R
--R
--R          2             2
--R   [[ci= x ,tci= 4,cj= x ,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 2,tD= 2]]
--R
--R
--R                         2            2            2
--R   [[ci= y x,tci= 4,cj= x ,tcj= 4,c= y ,tc= 5,rc= y ,trc= 4,tH= 3,tD= 2]]
--R
--R
--R                         2            2
--R   [[ci= y x,tci= 4,cj= y ,tcj= 4,c= y ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R            2                                 2
--R   (15)  [2y  - 5y - 8x - 3,y x - y + x + 3,2x  + 2y - 3x - 6]
--R       Type: List HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 15

--S 16 of 24
euclideanGroebner(bn,"info","redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2           2
--R   - 2y x  - y x - 6x  - y - 3x + 3
--R
--R
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R     2
--R   4x  + 4y - 6x - 12
--R
--R
--R
--R            2                                         2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= x ,trc= 4,tH= 2,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R     2
--R   2x  + 2y - 3x - 6
--R
--R
--R
--R            2                                         2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= x ,trc= 4,tH= 2,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2             2
--R   [[ci= x ,tci= 4,cj= x ,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 2,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       2
--R   - 2y  + 5y + 8x + 3
--R
--R
--R
--R                         2            2            2
--R   [[ci= y x,tci= 4,cj= x ,tcj= 4,c= y ,tc= 5,rc= y ,trc= 4,tH= 3,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                         2            2
--R   [[ci= y x,tci= 4,cj= y ,tcj= 4,c= y ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R            2                                 2
--R   (16)  [2y  - 5y - 8x - 3,y x - y + x + 3,2x  + 2y - 3x - 6]
--R       Type: List HomogeneousDistributedMultivariatePolynomial([y,x],Integer)
--E 16

--S 17 of 24
c1:GDMP([y,x],INT,DIRPROD(2,NNI)):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
--R
--R             2                2
--R   (17)  3y x  + 2y x + y + 9x  + 5x - 3
--RType: GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 17

--S 18 of 24
c2:GDMP([y,x],INT,DIRPROD(2,NNI)):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
--R
--R             3               3     2
--R   (18)  2y x  - y x - y + 6x  - 2x  - 3x + 3
--RType: GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 18

--S 19 of 24
c3:GDMP([y,x],INT,DIRPROD(2,NNI)):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
--R
--R            3      2     3     2
--R   (19)  y x  + y x  + 3x  + 2x
--RType: GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 19

--S 20 of 24
cn:=[c1,c2,c3]
--R
--R   (20)
--R        2                2               3               3     2
--R   [3y x  + 2y x + y + 9x  + 5x - 3, 2y x  - y x - y + 6x  - 2x  - 3x + 3,
--R       3      2     3     2
--R    y x  + y x  + 3x  + 2x ]
--RType: List GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 20

--S 21 of 24
euclideanGroebner(cn)
--R
--R                                 2            3     2
--R   (21)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--RType: List GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 21

--S 22 of 24
euclideanGroebner(cn,"redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2               2
--R   - 2y x  - y x - y - 6x  - 3x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   4y + 4x  - 6x - 12
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3      2
--R   - 4x  + 10x  + 10x
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   2y + 2x  - 3x - 6
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3     2
--R   - 2x  + 5x  + 5x
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                 2            3     2
--R   (22)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--RType: List GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 22

--S 23 of 24
euclideanGroebner(cn,"info")
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 2,tD= 3]]
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 3,tD= 4]]
--R
--R
--R   [[ci= y,tci= 4,cj= y,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 3]]
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R          3             3
--R   [[ci= x ,tci= 3,cj= x ,tcj= 3,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 2]]
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R                       3              2
--R   [[ci= y,tci= 4,cj= x ,tcj= 3,c= y x ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                 2            3     2
--R   (23)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--RType: List GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 23

--S 24 of 24
euclideanGroebner(cn,"info","redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2               2
--R   - 2y x  - y x - y - 6x  - 3x + 3
--R
--R
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R            3               3              2              2
--R   [[ci= y x ,tci= 7,cj= y x ,tcj= 4,c= y x ,tc= 6,rc= y x ,trc= 6,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   y x - y + x + 3
--R
--R
--R
--R            2               2
--R   [[ci= y x ,tci= 6,cj= y x ,tcj= 6,c= y x,tc= 4,rc= y x,trc= 4,tH= 1,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   4y + 4x  - 6x - 12
--R
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 2,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3      2
--R   - 4x  + 10x  + 10x
--R
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          2
--R   2y + 2x  - 3x - 6
--R
--R
--R
--R            2
--R   [[ci= y x ,tci= 6,cj= y x,tcj= 4,c= y x,tc= 5,rc= y,trc= 4,tH= 3,tD= 4]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= y,tci= 4,cj= y,tcj= 4,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       3     2
--R   - 2x  + 5x  + 5x
--R
--R
--R
--R                                                 3
--R   [[ci= y x,tci= 4,cj= y,tcj= 4,c= y,tc= 5,rc= x ,trc= 3,tH= 3,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          3             3
--R   [[ci= x ,tci= 3,cj= x ,tcj= 3,c= 0,tc= 0,rc= 0,trc= 0,tH= 3,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R            3                             2
--R   [[ci= y x ,tci= 4,cj= y x,tcj= 4,c= y x ,tc= 3,rc= 0,trc= 0,tH= 3,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                       3              2
--R   [[ci= y,tci= 4,cj= x ,tcj= 3,c= y x ,tc= 5,rc= 0,trc= 0,tH= 3,tD= 0]]
--R
--R
--R     There are
--R
--R   3
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS over EUCLIDEAN DOMAIN
--R
--R                                 2            3     2
--R   (24)  [y x - y + x + 3,2y + 2x  - 3x - 6,2x  - 5x  - 5x]
--RType: List GeneralDistributedMultivariatePolynomial([y,x],Integer,DirectProduct(2,NonNegativeInteger))
--E 24

)spool
)lisp (bye)
@
<<EuclideanGroebnerBasisPackage.help>>=
====================================================================
euclideanGroebner examples
====================================================================

Example to call euclideanGroebner:

  a1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
  a2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
  a3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
  an:=[a1,a2,a3]
  euclideanGroebner(an)

This will return the weak euclidean Groebner basis set.
All reductions are total reductions.

You can get more information by providing a second argument.
To get the reduced critical pairs do:

  euclideanGroebner(an,"redcrit")

You can get other information by calling:

  euclideanGroebner(an,"info")

which returns:
   ci  =>  Leading monomial  for critpair calculation
   tci =>  Number of terms of polynomial i
   cj  =>  Leading monomial  for critpair calculation
   tcj =>  Number of terms of polynomial j
   c   =>  Leading monomial of critpair polynomial
   tc  =>  Number of terms of critpair polynomial
   rc  =>  Leading monomial of redcritpair polynomial
   trc =>  Number of terms of redcritpair polynomial
   tH  =>  Number of polynomials in reduction list H
   tD  =>  Number of critpairs still to do

The three argument form returns all of the information:

  euclideanGroebner(an,"info","redcrit")


The term ordering is determined by the polynomial type used. 
Suggested types include
   DistributedMultivariatePolynomial
   HomogeneousDistributedMultivariatePolynomial
   GeneralDistributedMultivariatePolynomial
 
See Also:
o )display operations euclideanGroebner
o )show EuclideanGroebnerBasisPackage
o )show DistributedMultivariatePolynomial
o )show HomogeneousDistributedMultivariatePolynomial
o )show GeneralDistributedMultivariatePolynomial
o )show GroebnerPackage

@
\pagehead{EuclideanGroebnerBasisPackage}{GBEUCLID}
\pagepic{ps/v104euclideangroebnerbasispackage.ps}{GBEUCLID}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GBEUCLID EuclideanGroebnerBasisPackage>>=
)abbrev package GBEUCLID EuclideanGroebnerBasisPackage
++ Authors: Gebauer, Moeller
++ Date Created: 12-1-86
++ Date Last Updated: 2-28-91
++ Basic Functions:
++ Related Constructors: Ideal, IdealDecompositionPackage, GroebnerPackage
++ Also See:
++ AMS Classifications:
++ Keywords: groebner basis, polynomial ideal, euclidean domain
++ References:
++ Description: \spadtype{EuclideanGroebnerBasisPackage} computes groebner
++ bases for polynomial ideals over euclidean domains.
++ The basic computation provides
++ a distinguished set of generators for these ideals.
++ This basis allows an easy test for membership: the operation
++ \spadfun{euclideanNormalForm} returns zero on ideal members. The string 
++ "info" and "redcrit" can be given as additional args to provide 
++ incremental information during the computation. If "info" is given,
++  a computational summary is given for each s-polynomial. If "redcrit" 
++ is given, the reduced critical pairs are printed. The term ordering
++ is determined by the polynomial type used. Suggested types include
++ \spadtype{DistributedMultivariatePolynomial},
++ \spadtype{HomogeneousDistributedMultivariatePolynomial},
++ \spadtype{GeneralDistributedMultivariatePolynomial}.
 
EuclideanGroebnerBasisPackage(Dom, Expon, VarSet, Dpol): T == C where
 
 Dom: EuclideanDomain
 Expon: OrderedAbelianMonoidSup
 VarSet: OrderedSet
 Dpol: PolynomialCategory(Dom, Expon, VarSet)
 
 T== with
 
     euclideanNormalForm: (Dpol, List(Dpol) )  ->  Dpol
       ++ euclideanNormalForm(poly,gb) reduces the polynomial poly modulo the
       ++ precomputed groebner basis gb giving a canonical representative
       ++ of the residue class.
     euclideanGroebner: List(Dpol) -> List(Dpol)
       ++ euclideanGroebner(lp) computes a groebner basis for a polynomial 
       ++ ideal over a euclidean domain generated by the list of polys lp.
       ++
       ++X a1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
       ++X a2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
       ++X a3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
       ++X an:=[a1,a2,a3]
       ++X euclideanGroebner(an)

     euclideanGroebner: (List(Dpol), String) -> List(Dpol)
       ++ euclideanGroebner(lp, infoflag) computes a groebner basis 
       ++ for a polynomial ideal over a euclidean domain
       ++ generated by the list of polynomials lp.
       ++ During computation, additional information is printed out
       ++ if infoflag is given as 
       ++ either "info" (for summary information) or
       ++ "redcrit" (for reduced critical pairs)
       ++
       ++X a1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
       ++X a2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
       ++X a3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
       ++X an:=[a1,a2,a3]
       ++X euclideanGroebner(an,"redcrit")
       ++X euclideanGroebner(an,"info")

     euclideanGroebner: (List(Dpol), String, String ) -> List(Dpol)
       ++ euclideanGroebner(lp, "info", "redcrit") computes a groebner basis
       ++ for a polynomial ideal generated by the list of polynomials lp.
       ++ If the second argument is "info", 
       ++ a summary is given of the critical pairs.
       ++ If the third argument is "redcrit", critical pairs are printed.
       ++
       ++X a1:DMP([y,x],INT):= (9*x**2 + 5*x - 3)+ y*(3*x**2 + 2*x + 1)
       ++X a2:DMP([y,x],INT):= (6*x**3 - 2*x**2 - 3*x +3) + y*(2*x**3 - x - 1)
       ++X a3:DMP([y,x],INT):= (3*x**3 + 2*x**2) + y*(x**3 + x**2)
       ++X an:=[a1,a2,a3]
       ++X euclideanGroebner(an,"info","redcrit")

 C== add
   Ex ==> OutputForm
   lc ==> leadingCoefficient
   red ==> reductum

   import OutputForm
 
   ------  Definition list of critPair
   ------  lcmfij is now lcm of headterm of poli and polj
   ------  lcmcij is now lcm of of lc poli and lc polj
 
   critPair ==>Record(lcmfij: Expon, lcmcij: Dom, poli:Dpol, polj: Dpol )
   Prinp    ==> Record( ci:Dpol,tci:Integer,cj:Dpol,tcj:Integer,c:Dpol,
                tc:Integer,rc:Dpol,trc:Integer,tH:Integer,tD:Integer)
 
   ------  Definition of intermediate functions
 
   strongGbasis: (List(Dpol), Integer, Integer) -> List(Dpol)
   eminGbasis: List(Dpol) -> List(Dpol)
   ecritT: (critPair ) -> Boolean
   ecritM: (Expon, Dom, Expon, Dom) -> Boolean
   ecritB: (Expon, Dom, Expon, Dom, Expon, Dom) -> Boolean
   ecrithinH: (Dpol, List(Dpol)) -> Boolean
   ecritBonD: (Dpol, List(critPair)) -> List(critPair)
   ecritMTondd1:(List(critPair)) -> List(critPair)
   ecritMondd1:(Expon, Dom, List(critPair)) -> List(critPair)
   crithdelH: (Dpol, List(Dpol)) -> List(Dpol)
   eupdatF: (Dpol, List(Dpol) ) -> List(Dpol)
   updatH: (Dpol, List(Dpol), List(Dpol), List(Dpol) ) -> List(Dpol)
   sortin: (Dpol, List(Dpol) ) -> List(Dpol)
   eRed: (Dpol, List(Dpol), List(Dpol) )  ->  Dpol
   ecredPol: (Dpol, List(Dpol) ) -> Dpol
   esPol: (critPair) -> Dpol
   updatD: (List(critPair), List(critPair)) -> List(critPair)
   lepol: Dpol -> Integer
   prinshINFO : Dpol -> Void
   prindINFO: (critPair, Dpol, Dpol,Integer,Integer,Integer) -> Integer
   prinpolINFO: List(Dpol) -> Void
   prinb: Integer -> Void
 
   ------    MAIN ALGORITHM GROEBNER ------------------------
   euclideanGroebner( Pol: List(Dpol) ) ==
     eminGbasis(strongGbasis(Pol,0,0))
 
   euclideanGroebner( Pol: List(Dpol), xx1: String) ==
     xx1 = "redcrit" =>
       eminGbasis(strongGbasis(Pol,1,0))
     xx1 = "info" =>
       eminGbasis(strongGbasis(Pol,2,1))
     print("   "::Ex)
     print("WARNING: options are - redcrit and/or info - "::Ex)
     print("         you didn't type them correct"::Ex)
     print("         please try again"::Ex)
     print("   "::Ex)
     []
 
   euclideanGroebner( Pol: List(Dpol), xx1: String, xx2: String) ==
     (xx1 = "redcrit" and xx2 = "info") or
      (xx1 = "info" and xx2 = "redcrit")   =>
       eminGbasis(strongGbasis(Pol,1,1))
     xx1 = "redcrit" and xx2 = "redcrit" =>
       eminGbasis(strongGbasis(Pol,1,0))
     xx1 = "info" and xx2 = "info" =>
       eminGbasis(strongGbasis(Pol,2,1))
     print("   "::Ex)
     print("WARNING:  options are - redcrit and/or info - "::Ex)
     print("          you didn't type them correct"::Ex)
     print("          please try again "::Ex)
     print("   "::Ex)
     []
 
   ------    calculate basis
 
   strongGbasis(Pol: List(Dpol),xx1: Integer, xx2: Integer ) ==
     dd1, D : List(critPair)
 
     ---------   create D and Pol
 
     Pol1:= sort( (degree #1 > degree #2) or
                    ((degree #1 = degree #2 ) and
                       sizeLess?(leadingCoefficient #2,leadingCoefficient #1)),
                 Pol)
     Pol:= [first(Pol1)]
     H:= Pol
     Pol1:= rest(Pol1)
     D:= nil
     while ^null Pol1 repeat
        h:= first(Pol1)
        Pol1:= rest(Pol1)
        en:= degree(h)
        lch:= lc h
        dd1:= [[sup(degree(x), en), lcm(leadingCoefficient x, lch), x, h]$critPair
            for x in Pol]
        D:= updatD(ecritMTondd1(sort((#1.lcmfij < #2.lcmfij) or
                                      (( #1.lcmfij = #2.lcmfij ) and
                                        ( sizeLess?(#1.lcmcij,#2.lcmcij)) ),
                                     dd1)), ecritBonD(h,D))
        Pol:= cons(h, eupdatF(h, Pol))
        ((en = degree(first(H))) and (leadingCoefficient(h) = leadingCoefficient(first(H)) ) ) =>
              " go to top of while "
        H:= updatH(h,H,crithdelH(h,H),[h])
        H:= sort((degree #1 > degree #2) or
                ((degree #1 = degree #2 ) and
                  sizeLess?(leadingCoefficient #2,leadingCoefficient #1)), H)
     D:= sort((#1.lcmfij < #2.lcmfij) or
             (( #1.lcmfij = #2.lcmfij ) and
               ( sizeLess?(#1.lcmcij,#2.lcmcij)) ) ,D)
     xx:= xx2
 
     --------  loop
 
     while ^null D repeat
         D0:= first D
         ep:=esPol(D0)
         D:= rest(D)
         eh:= ecredPol(eRed(ep,H,H),H)
         if xx1 = 1 then
               prinshINFO(eh)
         eh = 0 =>
              if xx2 = 1 then
                  ala:= prindINFO(D0,ep,eh,#H, #D, xx)
                  xx:= 2
              " go to top of while "
         eh := unitCanonical eh
         e:= degree(eh)
         leh:= lc eh
         dd1:= [[sup(degree(x), e), lcm(leadingCoefficient x, leh), x, eh]$critPair
            for x in Pol]
         D:= updatD(ecritMTondd1(sort( (#1.lcmfij <
              #2.lcmfij) or (( #1.lcmfij = #2.lcmfij ) and
               ( sizeLess?(#1.lcmcij,#2.lcmcij)) ), dd1)), ecritBonD(eh,D))
         Pol:= cons(eh,eupdatF(eh,Pol))
         ^ecrithinH(eh,H) or
           ((e = degree(first(H))) and (leadingCoefficient(eh) = leadingCoefficient(first(H)) ) ) =>
              if xx2 = 1 then
                  ala:= prindINFO(D0,ep,eh,#H, #D, xx)
                  xx:= 2
              " go to top of while "
         H:= updatH(eh,H,crithdelH(eh,H),[eh])
         H:= sort( (degree #1 > degree #2) or
             ((degree #1 = degree #2 ) and
                 sizeLess?(leadingCoefficient #2,leadingCoefficient #1)), H)
         if xx2 = 1 then
           ala:= prindINFO(D0,ep,eh,#H, #D, xx)
           xx:= 2
           " go to top of while "
     if xx2 = 1 then
       prinpolINFO(Pol)
       print("    THE GROEBNER BASIS over EUCLIDEAN DOMAIN"::Ex)
     if xx1 = 1 and xx2 ^= 1 then
       print("    THE GROEBNER BASIS over EUCLIDEAN DOMAIN"::Ex)
     H
 
             --------------------------------------
 
             --- erase multiple of e in D2 using crit M
 
   ecritMondd1(e: Expon, c: Dom, D2: List(critPair))==
      null D2 => nil
      x:= first(D2)
      ecritM(e,c, x.lcmfij, lcm(leadingCoefficient(x.poli), leadingCoefficient(x.polj)))
         => ecritMondd1(e, c, rest(D2))
      cons(x, ecritMondd1(e, c, rest(D2)))
 
            -------------------------------
 
   ecredPol(h: Dpol, F: List(Dpol) ) ==
        h0:Dpol:= 0
        null F => h
        while h ^= 0 repeat
           h0:= h0 + monomial(leadingCoefficient(h),degree(h))
           h:= eRed(red(h), F, F)
        h0
             ----------------------------
 
             --- reduce dd1 using crit T and crit M
 
   ecritMTondd1(dd1: List(critPair))==
           null dd1 => nil
           f1:= first(dd1)
           s1:= #(dd1)
           cT1:= ecritT(f1)
           s1= 1 and cT1 => nil
           s1= 1 => dd1
           e1:= f1.lcmfij
           r1:= rest(dd1)
           f2:= first(r1)
           e1 = f2.lcmfij and f1.lcmcij = f2.lcmcij =>
              cT1 =>   ecritMTondd1(cons(f1, rest(r1)))
              ecritMTondd1(r1)
           dd1 := ecritMondd1(e1, f1.lcmcij, r1)
           cT1 => ecritMTondd1(dd1)
           cons(f1, ecritMTondd1(dd1))
 
             -----------------------------
 
             --- erase elements in D fullfilling crit B
 
   ecritBonD(h:Dpol, D: List(critPair))==
         null D => nil
         x:= first(D)
         x1:= x.poli
         x2:= x.polj
         ecritB(degree(h), leadingCoefficient(h), degree(x1),leadingCoefficient(x1),degree(x2),leadingCoefficient(x2)) =>
           ecritBonD(h, rest(D))
         cons(x, ecritBonD(h, rest(D)))
 
             -----------------------------
 
             --- concat F and h and erase multiples of h in F
 
   eupdatF(h: Dpol, F: List(Dpol)) ==
       null F => nil
       f1:= first(F)
       ecritM(degree h, leadingCoefficient(h), degree f1, leadingCoefficient(f1))
           => eupdatF(h, rest(F))
       cons(f1, eupdatF(h, rest(F)))
 
             -----------------------------
             --- concat H and h and erase multiples of h in H
 
   updatH(h: Dpol, H: List(Dpol), Hh: List(Dpol), Hhh: List(Dpol)) ==
       null H => append(Hh,Hhh)
       h1:= first(H)
       hlcm:= sup(degree(h1), degree(h))
       plc:= extendedEuclidean(leadingCoefficient(h), leadingCoefficient(h1))
       hp:= monomial(plc.coef1,subtractIfCan(hlcm, degree(h))::Expon)*h +
            monomial(plc.coef2,subtractIfCan(hlcm, degree(h1))::Expon)*h1
       (ecrithinH(hp, Hh) and ecrithinH(hp, Hhh)) =>
         hpp:= append(rest(H),Hh)
         hp:= ecredPol(eRed(hp,hpp,hpp),hpp)
         updatH(h, rest(H), crithdelH(hp,Hh),cons(hp,crithdelH(hp,Hhh)))
       updatH(h, rest(H), Hh,Hhh)
 
             --------------------------------------------------
             ---- delete elements in cons(h,H)
 
   crithdelH(h: Dpol, H: List(Dpol))==
        null H => nil
        h1:= first(H)
        dh1:= degree h1
        dh:= degree h
        ecritM(dh, lc h, dh1, lc h1) => crithdelH(h, rest(H))
        dh1 = sup(dh,dh1) =>
           plc:= extendedEuclidean( lc h1, lc h)
           cons(plc.coef1*h1 + monomial(plc.coef2,subtractIfCan(dh1,dh)::Expon)*h,
               crithdelH(h,rest(H)))
        cons(h1, crithdelH(h,rest(H)))
 
   eminGbasis(F: List(Dpol)) ==
        null F => nil
        newbas := eminGbasis rest F
        cons(ecredPol( first(F), newbas),newbas)
 
             ------------------------------------------------
             --- does h belong to H
 
   ecrithinH(h: Dpol, H: List(Dpol))==
        null H  => true
        h1:= first(H)
        ecritM(degree h1, lc h1, degree h, lc h) => false
        ecrithinH(h, rest(H))
 
            -----------------------------
            --- calculate  euclidean S-polynomial of a critical pair
 
   esPol(p:critPair)==
      Tij := p.lcmfij
      fi := p.poli
      fj := p.polj
      lij:= lcm(leadingCoefficient(fi), leadingCoefficient(fj))
      red(fi)*monomial((lij exquo leadingCoefficient(fi))::Dom,
                        subtractIfCan(Tij, degree fi)::Expon) -
        red(fj)*monomial((lij exquo leadingCoefficient(fj))::Dom,
                         subtractIfCan(Tij, degree fj)::Expon)
 
            ----------------------------
 
            --- euclidean reduction mod F
 
   eRed(s: Dpol, H: List(Dpol), Hh: List(Dpol)) ==
     ( s = 0 or null H ) => s
     f1:= first(H)
     ds:= degree s
     lf1:= leadingCoefficient(f1)
     ls:= leadingCoefficient(s)
     e: Union(Expon, "failed")
     (((e:= subtractIfCan(ds, degree f1))  case "failed" ) or sizeLess?(ls, lf1) ) =>
        eRed(s, rest(H), Hh)
     sdf1:= divide(ls, lf1)
     q1:= sdf1.quotient
     sdf1.remainder = 0 =>
        eRed(red(s) - monomial(q1,e)*reductum(f1), Hh, Hh)
     eRed(s -(monomial(q1, e)*f1), rest(H), Hh)
 
            ----------------------------
 
            --- crit T  true, if e1 and e2 are disjoint
 
   ecritT(p: critPair) ==
          pi:= p.poli
          pj:= p.polj
          ci:= lc pi
          cj:= lc pj
          (p.lcmfij = degree pi + degree pj) and  (p.lcmcij = ci*cj)
 
            ----------------------------
 
            --- crit M - true, if lcm#2 multiple of lcm#1
 
   ecritM(e1: Expon, c1: Dom, e2: Expon, c2: Dom) ==
     en: Union(Expon, "failed")
     ((en:=subtractIfCan(e2, e1)) case "failed") or
       ((c2 exquo c1) case "failed") => false
     true
            ----------------------------
 
            --- crit B - true, if eik is a multiple of eh and eik ^equal
            ---          lcm(eh,ei) and eik ^equal lcm(eh,ek)
 
   ecritB(eh:Expon, ch: Dom, ei:Expon, ci: Dom, ek:Expon, ck: Dom) ==
       eik:= sup(ei, ek)
       cik:= lcm(ci, ck)
       ecritM(eh, ch, eik, cik) and
             ^ecritM(eik, cik, sup(ei, eh), lcm(ci, ch)) and
                ^ecritM(eik, cik, sup(ek, eh), lcm(ck, ch))
 
            -------------------------------
 
            --- reduce p1 mod lp
 
   euclideanNormalForm(p1: Dpol, lp: List(Dpol))==
       eRed(p1, lp, lp)
 
            ---------------------------------
 
            ---  insert element in sorted list
 
   sortin(p1: Dpol, lp: List(Dpol))==
      null lp => [p1]
      f1:= first(lp)
      elf1:= degree(f1)
      ep1:= degree(p1)
      ((elf1 < ep1) or ((elf1 = ep1) and
        sizeLess?(leadingCoefficient(f1),leadingCoefficient(p1)))) =>
         cons(f1,sortin(p1, rest(lp)))
      cons(p1,lp)
 
   updatD(D1: List(critPair), D2: List(critPair)) ==
      null D1 => D2
      null D2 => D1
      dl1:= first(D1)
      dl2:= first(D2)
      (dl1.lcmfij  <  dl2.lcmfij) => cons(dl1, updatD(D1.rest, D2))
      cons(dl2, updatD(D1, D2.rest))
 
            ----  calculate number of terms of polynomial
 
   lepol(p1:Dpol)==
      n: Integer
      n:= 0
      while p1 ^= 0 repeat
         n:= n + 1
         p1:= red(p1)
      n
 
            ----  print blanc lines
 
   prinb(n: Integer)==
        for i in 1..n repeat messagePrint("    ")
 
            ----  print reduced critpair polynom
 
   prinshINFO(h: Dpol)==
           prinb(2)
           messagePrint(" reduced Critpair - Polynom :")
           prinb(2)
           print(h::Ex)
           prinb(2)
 
            -------------------------------
 
            ----  print info string
 
   prindINFO(cp: critPair, ps: Dpol, ph: Dpol, i1:Integer,
             i2:Integer, n:Integer) ==
       ll: List Prinp
       a: Dom
       cpi:= cp.poli
       cpj:= cp.polj
       if n = 1 then
        prinb(1)
        messagePrint("you choose option  -info-  ")
        messagePrint("abbrev. for the following information strings are")
        messagePrint("  ci  =>  Leading monomial  for critpair calculation")
        messagePrint("  tci =>  Number of terms of polynomial i")
        messagePrint("  cj  =>  Leading monomial  for critpair calculation")
        messagePrint("  tcj =>  Number of terms of polynomial j")
        messagePrint("  c   =>  Leading monomial of critpair polynomial")
        messagePrint("  tc  =>  Number of terms of critpair polynomial")
        messagePrint("  rc  =>  Leading monomial of redcritpair polynomial")
        messagePrint("  trc =>  Number of terms of redcritpair polynomial")
        messagePrint("  tF  =>  Number of polynomials in reduction list F")
        messagePrint("  tD  =>  Number of critpairs still to do")
        prinb(4)
        n:= 2
       prinb(1)
       a:= 1
       ph = 0  =>
          ps = 0 =>
            ll:= [[monomial(a,degree(cpi)),lepol(cpi),monomial(a,degree(cpj)),
             lepol(cpj),ps,0,ph,0,i1,i2]$Prinp]
            print(ll::Ex)
            prinb(1)
            n
          ll:= [[monomial(a,degree(cpi)),lepol(cpi),
            monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
             lepol(ps), ph,0,i1,i2]$Prinp]
          print(ll::Ex)
          prinb(1)
          n
       ll:= [[monomial(a,degree(cpi)),lepol(cpi),
            monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
             lepol(ps),monomial(a,degree(ph)),lepol(ph),i1,i2]$Prinp]
       print(ll::Ex)
       prinb(1)
       n
 
            -------------------------------
 
            ----  print the groebner basis polynomials
 
   prinpolINFO(pl: List(Dpol))==
       n:Integer
       n:= #pl
       prinb(1)
       n = 1 =>
         print("  There is 1  Groebner Basis Polynomial "::Ex)
         prinb(2)
       print("  There are "::Ex)
       prinb(1)
       print(n::Ex)
       prinb(1)
       print("  Groebner Basis Polynomials. "::Ex)
       prinb(2)
 

@
<<GBEUCLID.dotabb>>=
"GBEUCLID" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GBEUCLID"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"GBEUCLID" -> "PFECAT"
"GBEUCLID" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EVALCYC EvaluateCycleIndicators}
\pagehead{EvaluateCycleIndicators}{EVALCYC}
\pagepic{ps/v104evaluatecycleindicators.ps}{EVALCYC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EVALCYC EvaluateCycleIndicators>>=
)abbrev package EVALCYC EvaluateCycleIndicators
++ Author: William H. Burge
++ Date Created: 1986
++ Date Last Updated: Feb 1992
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: This package is to be used in conjuction with
++             the CycleIndicators package. It provides an evaluation
++             function for SymmetricPolynomials.
EvaluateCycleIndicators(F):T==C where
    F:Algebra Fraction Integer
    I==>Integer
    L==>List
    SPOL==SymmetricPolynomial
    RN==>Fraction Integer
    PR==>Polynomial(RN)
    PTN==>Partition()
    lc ==> leadingCoefficient
    red ==> reductum
    T== with
       eval:((I->F),SPOL RN)->F
         ++\spad{eval(f,s)} evaluates the cycle index s by applying
         ++ the function f to each integer in a monomial partition,
         ++ forms their product and sums the results over all monomials.
    C== add
       evp:((I->F),PTN)->F
       fn:I->F
       pt:PTN
       spol:SPOL RN
       i:I
       evp(fn, pt)== _*/[fn i for i in pt::(L I)]
 
       eval(fn,spol)==
        if spol=0
        then 0
        else ((lc spol)* evp(fn,degree spol)) + eval(fn,red spol)

@
<<EVALCYC.dotabb>>=
"EVALCYC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EVALCYC"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"EVALCYC" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ESCONT ExpertSystemContinuityPackage}
\pagehead{ExpertSystemContinuityPackage}{ESCONT}
\pagepic{ps/v104expertsystemcontinuitypackage.ps}{ESCONT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<ESCONT.dotabb>>=
"ESCONT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT"]

@
<<package ESCONT ExpertSystemContinuityPackage>>=
)abbrev package ESCONT ExpertSystemContinuityPackage
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: June 1995
++ Basic Operations: problemPoints, singularitiesOf, zerosOf
++ Related Constructors:
++ Description:
++ ExpertSystemContinuityPackage is a package of functions for the use of domains
++ belonging to the category \axiomType{NumericalIntegration}.

ExpertSystemContinuityPackage(): E == I where
  EF2   ==> ExpressionFunctions2
  FI    ==> Fraction Integer
  EFI   ==> Expression Fraction Integer
  PFI   ==> Polynomial Fraction Integer
  DF    ==> DoubleFloat
  LDF   ==> List DoubleFloat
  EDF   ==> Expression DoubleFloat
  VEDF  ==> Vector Expression DoubleFloat
  SDF   ==> Stream DoubleFloat
  SS    ==> Stream String
  EEDF  ==> Equation Expression DoubleFloat
  LEDF  ==> List Expression DoubleFloat
  KEDF  ==> Kernel Expression DoubleFloat
  LKEDF ==> List Kernel Expression DoubleFloat
  PDF   ==> Polynomial DoubleFloat
  FPDF  ==> Fraction Polynomial DoubleFloat
  OCDF  ==> OrderedCompletion DoubleFloat
  SOCDF ==> Segment OrderedCompletion DoubleFloat
  NIA   ==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  UP    ==> UnivariatePolynomial
  BO    ==> BasicOperator
  RS    ==> Record(zeros: SDF,ones: SDF,singularities: SDF)

  E ==> with

    getlo : SOCDF -> DF
      ++ getlo(u) gets the \axiomType{DoubleFloat} equivalent of
      ++ the first endpoint of the range \axiom{u}
    gethi : SOCDF -> DF
      ++ gethi(u) gets the \axiomType{DoubleFloat} equivalent of
      ++ the second endpoint of the range \axiom{u}
    functionIsFracPolynomial?: NIA -> Boolean
      ++ functionIsFracPolynomial?(args) tests whether the function
      ++ can be retracted to \axiomType{Fraction(Polynomial(DoubleFloat))}
    problemPoints:(EDF,Symbol,SOCDF) -> List DF
      ++ problemPoints(f,var,range) returns a list of possible problem points
      ++ by looking at the zeros of the denominator of the function \spad{f}
      ++ if it can be retracted to \axiomType{Polynomial(DoubleFloat)}.
    zerosOf:(EDF,List Symbol,SOCDF) -> SDF
      ++ zerosOf(e,vars,range) returns a list of points  
      ++ (\axiomType{Doublefloat}) at which a NAG fortran version of \spad{e}
      ++ will most likely produce an error.
    singularitiesOf: (EDF,List Symbol,SOCDF) -> SDF
      ++ singularitiesOf(e,vars,range) returns a list of points 
      ++ (\axiomType{Doublefloat}) at which a NAG fortran 
      ++ version of \spad{e} will most likely produce
      ++ an error.  This includes those points which evaluate to 0/0.
    singularitiesOf: (Vector EDF,List Symbol,SOCDF) -> SDF
      ++ singularitiesOf(v,vars,range) returns a list of points 
      ++ (\axiomType{Doublefloat}) at which a NAG fortran 
      ++ version of \spad{v} will most likely produce
      ++ an error.  This includes those points which evaluate to 0/0.
    polynomialZeros:(PFI,Symbol,SOCDF) -> LDF
      ++ polynomialZeros(fn,var,range) calculates the real zeros of the 
      ++ polynomial which are contained in the given interval. It returns 
      ++ a list of points (\axiomType{Doublefloat}) for which the univariate 
      ++ polynomial \spad{fn} is zero.
    df2st:DF -> String 
      ++ df2st(n) coerces a \axiomType{DoubleFloat} to \axiomType{String}
    ldf2lst:LDF -> List String
      ++ ldf2lst(ln) coerces a List of \axiomType{DoubleFloat} to 
      ++ \axiomType{List}(\axiomType{String})
    sdf2lst:SDF -> List String
      ++ sdf2lst(ln) coerces a Stream of \axiomType{DoubleFloat} to 
      ++ \axiomType{List}(\axiomType{String})

  I ==> ExpertSystemToolsPackage add

    import ExpertSystemToolsPackage

    functionIsPolynomial?(args:NIA):Boolean ==
      -- tests whether the function can be retracted to a polynomial
      (retractIfCan(args.fn)@Union(PDF,"failed"))$EDF case PDF

    isPolynomial?(f:EDF):Boolean ==
      -- tests whether the function can be retracted to a polynomial
      (retractIfCan(f)@Union(PDF,"failed"))$EDF case PDF

    isConstant?(f:EDF):Boolean ==
      -- tests whether the function can be retracted to a constant (DoubleFloat)
      (retractIfCan(f)@Union(DF,"failed"))$EDF case DF

    denominatorIsPolynomial?(args:NIA):Boolean ==
      -- tests if the denominator can be retracted to polynomial
      a:= copy args
      a.fn:=denominator(args.fn)
      (functionIsPolynomial?(a))@Boolean

    denIsPolynomial?(f:EDF):Boolean ==
      -- tests if the denominator can be retracted to polynomial
      (isPolynomial?(denominator f))@Boolean

    listInRange(l:LDF,range:SOCDF):LDF ==
      -- returns a list with only those elements internal to the range range
      [t for t in l | in?(t,range)]

    loseUntil(l:SDF,a:DF):SDF ==
      empty?(l)$SDF => l
      f := first(l)$SDF
      (abs(f) <= abs(a)) => loseUntil(rest(l)$SDF,a)
      l

    retainUntil(l:SDF,a:DF,b:DF,flag:Boolean):SDF ==
      empty?(l)$SDF => l
      f := first(l)$SDF
      (in?(f)$ExpertSystemContinuityPackage1(a,b)) =>
        concat(f,retainUntil(rest(l),a,b,false)) 
      flag => empty()$SDF
      retainUntil(rest(l),a,b,true)

    streamInRange(l:SDF,range:SOCDF):SDF ==
      -- returns a stream with only those elements internal to the range range
      a := getlo(range := dfRange(range))
      b := gethi(range)
      explicitlyFinite?(l) =>
        select(in?$ExpertSystemContinuityPackage1(a,b),l)$SDF
      negative?(a*b) => retainUntil(l,a,b,false)                
      negative?(a) => 
        l := loseUntil(l,b)
        retainUntil(l,a,b,false)
      l := loseUntil(l,a)
      retainUntil(l,a,b,false)

    getStream(n:Symbol,s:String):SDF ==
      import RS
      entry?(n,bfKeys()$BasicFunctions)$(List(Symbol)) =>
        c := bfEntry(n)$BasicFunctions
        (s = "zeros")@Boolean => c.zeros
        (s = "singularities")@Boolean => c.singularities
        (s = "ones")@Boolean => c.ones
      empty()$SDF

    polynomialZeros(fn:PFI,var:Symbol,range:SOCDF):LDF ==
      up := unmakeSUP(univariate(fn)$PFI)$UP(var,FI)
      range := dfRange(range)
      r:Record(left:FI,right:FI) := [df2fi(getlo(range)), df2fi(gethi(range))]
      ans:List(Record(left:FI,right:FI)) := 
          realZeros(up,r,1/1000000000000000000)$RealZeroPackageQ(UP(var,FI))
      listInRange(dflist(ans),range)

    functionIsFracPolynomial?(args:NIA):Boolean ==
      -- tests whether the function can be retracted to a fraction
      -- where both numerator and denominator are polynomial
      (retractIfCan(args.fn)@Union(FPDF,"failed"))$EDF case FPDF

    problemPoints(f:EDF,var:Symbol,range:SOCDF):LDF ==
      (denIsPolynomial?(f))@Boolean =>
        c := retract(edf2efi(denominator(f)))@PFI
        polynomialZeros(c,var,range)
      empty()$LDF

    zerosOf(e:EDF,vars:List Symbol,range:SOCDF):SDF ==
      (u := isQuotient(e)) case EDF =>
        singularitiesOf(u,vars,range)
      k := kernels(e)$EDF
      ((nk := # k) = 0)@Boolean => empty()$SDF -- constant found.
      (nk = 1)@Boolean =>                      -- single expression found.
        ker := first(k)$LKEDF
        n := name(operator(ker)$KEDF)$BO
        entry?(n,vars) =>                   -- polynomial found.
          c := retract(edf2efi(e))@PFI
          coerce(polynomialZeros(c,n,range))$SDF
        a := first(argument(ker)$KEDF)$LEDF
        (not (n = log :: Symbol)@Boolean) and ((w := isPlus a) case LEDF) =>
          var:Symbol := first(variables(a))
          c:EDF := w.2
          c1:EDF := w.1
--          entry?(c1,[b::EDF for b in vars]) and (one?(# vars)) =>
          entry?(c1,[b::EDF for b in vars]) and ((# vars) = 1) =>
            c2:DF := edf2df c
            c3 := c2 :: OCDF
            varEdf := var :: EDF
            varEqn := equation(varEdf,c1-c)$EEDF
            range2 := (lo(range)+c3)..(hi(range)+c3)
            s := zerosOf(subst(e,varEqn)$EDF,vars,range2)
            st := map(#1-c2,s)$StreamFunctions2(DF,DF)
            streamInRange(st,range)
          zerosOf(a,vars,range)
        (t := isPlus(e)$EDF) case LEDF =>    -- constant + expression
          # t > 2 => empty()$SDF
          entry?(a,[b::EDF for b in vars]) =>   -- finds entries like sqrt(x)
            st := getStream(n,"ones")
            o := edf2df(second(t)$LEDF)
--            one?(o) or one?(-o) =>           -- is it like (f(x) -/+ 1)
            (o = 1) or (-o = 1) =>           -- is it like (f(x) -/+ 1)
              st := map(-#1/o,st)$StreamFunctions2(DF,DF)
              streamInRange(st,range)
            empty()$SDF
          empty()$SDF
        entry?(a,[b::EDF for b in vars]) =>     -- finds entries like sqrt(x)
          st := getStream(n,"zeros")
          streamInRange(st,range)
        (n = tan :: Symbol)@Boolean => 
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        (n = sin :: Symbol)@Boolean => 
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        empty()$SDF
      (t := isPlus(e)$EDF) case LEDF => empty()$SDF  -- INCOMPLETE!!!
      (v := isTimes(e)$EDF) case LEDF =>
        concat([zerosOf(u,vars,range) for u in v])
      empty()$SDF

    singularitiesOf(e:EDF,vars:List Symbol,range:SOCDF):SDF ==
      (u := isQuotient(e)) case EDF =>
        zerosOf(u,vars,range)
      (t := isPlus e) case LEDF =>
        concat([singularitiesOf(u,vars,range) for u in t])
      (v := isTimes e) case LEDF =>
        concat([singularitiesOf(u,vars,range) for u in v])
      (k := mainKernel e) case KEDF => 
        n := name(operator k)
        entry?(n,vars) => coerce(problemPoints(e,n,range))$SDF
        a:EDF := (argument k).1
        (not (n = log :: Symbol)@Boolean) and ((w := isPlus a) case LEDF) =>
          var:Symbol := first(variables(a))
          c:EDF := w.2
          c1:EDF := w.1
--          entry?(c1,[b::EDF for b in vars]) and (one?(# vars)) =>
          entry?(c1,[b::EDF for b in vars]) and ((# vars) = 1) =>
            c2:DF := edf2df c
            c3 := c2 :: OCDF
            varEdf := var :: EDF
            varEqn := equation(varEdf,c1-c)$EEDF
            range2 := (lo(range)+c3)..(hi(range)+c3)
            s := singularitiesOf(subst(e,varEqn)$EDF,vars,range2)
            st := map(#1-c2,s)$StreamFunctions2(DF,DF)
            streamInRange(st,range)
          singularitiesOf(a,vars,range)
        entry?(a,[b::EDF for b in vars]) =>
          st := getStream(n,"singularities")
          streamInRange(st,range)
        (n = log :: Symbol)@Boolean =>
          concat([zerosOf(a,vars,range),singularitiesOf(a,vars,range)])
        singularitiesOf(a,vars,range)
      empty()$SDF

    singularitiesOf(v:VEDF,vars:List Symbol,range:SOCDF):SDF ==
      ls := [singularitiesOf(u,vars,range) for u in entries(v)$VEDF]
      concat(ls)$SDF

@
<<ESCONT.dotabb>>=
"ESCONT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ESCONT1 ExpertSystemContinuityPackage1}
\pagehead{ExpertSystemContinuityPackage1}{ESCONT1}
\pagepic{ps/v104expertsystemcontinuitypackage1.ps}{ESCONT1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ESCONT1 ExpertSystemContinuityPackage1>>=
)abbrev package ESCONT1 ExpertSystemContinuityPackage1
++ Author: Brian Dupee
++ Date Created: May 1994
++ Date Last Updated: June 1995
++ Basic Operations: problemPoints, singularitiesOf, zerosOf
++ Related Constructors:
++ Description:
++ ExpertSystemContinuityPackage1 exports a function to check range inclusion

ExpertSystemContinuityPackage1(A:DF,B:DF): E == I where
  EF2   ==> ExpressionFunctions2
  FI    ==> Fraction Integer
  EFI   ==> Expression Fraction Integer
  PFI   ==> Polynomial Fraction Integer
  DF    ==> DoubleFloat
  LDF   ==> List DoubleFloat
  EDF   ==> Expression DoubleFloat
  VEDF  ==> Vector Expression DoubleFloat
  SDF   ==> Stream DoubleFloat
  SS    ==> Stream String
  EEDF  ==> Equation Expression DoubleFloat
  LEDF  ==> List Expression DoubleFloat
  KEDF  ==> Kernel Expression DoubleFloat
  LKEDF ==> List Kernel Expression DoubleFloat
  PDF   ==> Polynomial DoubleFloat
  FPDF  ==> Fraction Polynomial DoubleFloat
  OCDF  ==> OrderedCompletion DoubleFloat
  SOCDF ==> Segment OrderedCompletion DoubleFloat
  NIA   ==> Record(var:Symbol,fn:EDF,range:SOCDF,abserr:DF,relerr:DF)
  UP    ==> UnivariatePolynomial
  BO    ==> BasicOperator
  RS    ==> Record(zeros: SDF,ones: SDF,singularities: SDF)

  E ==> with

    in?:DF -> Boolean
      ++ in?(p) tests whether point p is internal to the range [\spad{A..B}]

  I ==> add 

    in?(p:DF):Boolean ==
      a:Boolean := (p < B)$DF
      b:Boolean := (A < p)$DF
      (a and b)@Boolean

@
<<ESCONT1.dotabb>>=
"ESCONT1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ESCONT1"]
"ESCONT1" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPR2 ExpressionFunctions2}
\pagehead{ExpressionFunctions2}{EXPR2}
\pagepic{ps/v104ExpressionFunctions2.ps}{EXPR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPR2 ExpressionFunctions2>>=
)abbrev package EXPR2 ExpressionFunctions2
++ Lifting of maps to Expressions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to Expressions.
++ Date Created: 16 Jan 1989
++ Date Last Updated: 22 Jan 1990
ExpressionFunctions2(R:OrderedSet, S:OrderedSet):
 Exports == Implementation where
  K   ==> Kernel R
  F2  ==> FunctionSpaceFunctions2(R, Expression R, S, Expression S)
  E2  ==> ExpressionSpaceFunctions2(Expression R, Expression S)

  Exports ==> with
    map: (R -> S, Expression R) -> Expression S
      ++ map(f, e) applies f to all the constants appearing in e.

  Implementation == add
    if S has Ring and R has Ring then
      map(f, r) == map(f, r)$F2
    else
      map(f, r) == map(map(f, #1), retract r)$E2

@
<<EXPR2.dotabb>>=
"EXPR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPR2"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EXPR2" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ES1 ExpressionSpaceFunctions1}
\pagehead{ExpressionSpaceFunctions1}{ES1}
\pagepic{ps/v104expressionspacefunctions1.ps}{ES1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ES1 ExpressionSpaceFunctions1>>=
)abbrev package ES1 ExpressionSpaceFunctions1
++ Lifting of maps from expression spaces to kernels over them
++ Author: Manuel Bronstein
++ Date Created: 23 March 1988
++ Date Last Updated: 19 April 1991
++ Description:
++   This package allows a map from any expression space into any object
++   to be lifted to a kernel over the expression set, using a given
++   property of the operator of the kernel.
-- should not be exposed
ExpressionSpaceFunctions1(F:ExpressionSpace, S:Type): with
    map: (F -> S, String, Kernel F) -> S
      ++ map(f, p, k) uses the property p of the operator
      ++ of k, in order to lift f and apply it to k.

  == add
    --  prop  contains an evaluation function List S -> S
    map(F2S, prop, k) ==
      args := [F2S x for x in argument k]$List(S)
      (p := property(operator k, prop)) case None =>
                                  ((p::None) pretend (List S -> S)) args
      error "Operator does not have required property"

@
<<ES1.dotabb>>=
"ES1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ES1"]
"EVALAB" [color="#4488FF",href="bookvol10.2.pdf#nameddest=EVALAB"]
"ES1" -> "EVALAB"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ES2 ExpressionSpaceFunctions2}
\pagehead{ExpressionSpaceFunctions2}{ES2}
\pagepic{ps/v104expressionspacefunctions2.ps}{ES2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ES2 ExpressionSpaceFunctions2>>=
)abbrev package ES2 ExpressionSpaceFunctions2
++ Lifting of maps from expression spaces to kernels over them
++ Author: Manuel Bronstein
++ Date Created: 23 March 1988
++ Date Last Updated: 19 April 1991
++ Description:
++ This package allows a mapping E -> F to be lifted to a kernel over E;
++ This lifting can fail if the operator of the kernel cannot be applied
++ in F; Do not use this package with E = F, since this may
++ drop some properties of the operators.
ExpressionSpaceFunctions2(E:ExpressionSpace, F:ExpressionSpace): with
    map: (E -> F, Kernel E) -> F
      ++ map(f, k) returns \spad{g = op(f(a1),...,f(an))} where
      ++ \spad{k = op(a1,...,an)}.
  == add
    map(f, k) ==
      (operator(operator k)$F) [f x for x in argument k]$List(F)

@
<<ES2.dotabb>>=
"ES2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ES2"]
"EVALAB" [color="#4488FF",href="bookvol10.2.pdf#nameddest=EVALAB"]
"ES2" -> "EVALAB"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPRODE ExpressionSpaceODESolver}
\pagehead{ExpressionSpaceODESolver}{EXPRODE}
\pagepic{ps/v104expressionspaceodesolver.ps}{EXPRODE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPRODE ExpressionSpaceODESolver>>=
)abbrev package EXPRODE ExpressionSpaceODESolver
++ Taylor series solutions of ODE's
++ Author: Manuel Bronstein
++ Date Created: 5 Mar 1990
++ Date Last Updated: 30 September 1993
++ Description: Taylor series solutions of explicit ODE's;
++ Keywords: differential equation, ODE, Taylor series
ExpressionSpaceODESolver(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain, ConvertibleTo InputForm)
  F: FunctionSpace R

  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  OP  ==> BasicOperator
  SY  ==> Symbol
  UTS ==> UnivariateTaylorSeries(F, x, center)
  MKF ==> MakeUnaryCompiledFunction(F, UTS, UTS)
  MKL ==> MakeUnaryCompiledFunction(F, List UTS, UTS)
  A1  ==> AnyFunctions1(UTS)
  AL1 ==> AnyFunctions1(List UTS)
  EQ  ==> Equation F
  ODE ==> UnivariateTaylorSeriesODESolver(F, UTS)

  Exports ==> with
    seriesSolve: (EQ, OP, EQ, EQ) -> Any
      ++ seriesSolve(eq,y,x=a, y a = b) returns a Taylor series solution
      ++ of eq around x = a with initial condition \spad{y(a) = b}.
      ++ Note: eq must be of the form
      ++ \spad{f(x, y x) y'(x) + g(x, y x) = h(x, y x)}.
    seriesSolve: (EQ, OP, EQ, List F) -> Any
      ++ seriesSolve(eq,y,x=a,[b0,...,b(n-1)]) returns a Taylor series
      ++ solution of eq around \spad{x = a} with initial conditions
      ++ \spad{y(a) = b0}, \spad{y'(a) = b1},
      ++ \spad{y''(a) = b2}, ...,\spad{y(n-1)(a) = b(n-1)}
      ++ eq must be of the form
      ++ \spad{f(x, y x, y'(x),..., y(n-1)(x)) y(n)(x) +
      ++ g(x,y x,y'(x),...,y(n-1)(x)) = h(x,y x, y'(x),..., y(n-1)(x))}.
    seriesSolve: (List EQ, List OP, EQ, List EQ) -> Any
      ++ seriesSolve([eq1,...,eqn],[y1,...,yn],x = a,[y1 a = b1,...,yn a = bn])
      ++ returns a taylor series solution of \spad{[eq1,...,eqn]} around
      ++ \spad{x = a} with initial conditions \spad{yi(a) = bi}.
      ++ Note: eqi must be of the form
      ++ \spad{fi(x, y1 x, y2 x,..., yn x) y1'(x) +
      ++ gi(x, y1 x, y2 x,..., yn x) = h(x, y1 x, y2 x,..., yn x)}.
    seriesSolve: (List EQ, List OP, EQ, List F) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1,...,eqn], [y1,...,yn], x = a,
      ++ [y1 a = b1,..., yn a = bn])}.
    seriesSolve: (List F, List OP, EQ, List F) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x=a, [b1,...,bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], x=a, [b1,...,bn])}.
    seriesSolve: (List F, List OP, EQ, List EQ) -> Any
      ++ seriesSolve([eq1,...,eqn], [y1,...,yn], x = a,[y1 a = b1,..., yn a = bn])
      ++ is equivalent to
      ++ \spad{seriesSolve([eq1=0,...,eqn=0], [y1,...,yn], x = a,
      ++ [y1 a = b1,..., yn a = bn])}.
    seriesSolve: (EQ, OP, EQ, F) -> Any
      ++ seriesSolve(eq,y, x=a, b) is equivalent to
      ++ \spad{seriesSolve(eq, y, x=a, y a = b)}.
    seriesSolve: (F, OP, EQ, F) -> Any
      ++ seriesSolve(eq, y, x = a, b) is equivalent to
      ++ \spad{seriesSolve(eq = 0, y, x = a, y a = b)}.
    seriesSolve: (F, OP, EQ, EQ) -> Any
      ++ seriesSolve(eq, y, x = a, y a = b) is equivalent to
      ++ \spad{seriesSolve(eq=0, y, x=a, y a = b)}.
    seriesSolve: (F, OP, EQ, List F) -> Any
      ++ seriesSolve(eq, y, x = a, [b0,...,bn]) is equivalent to
      ++ \spad{seriesSolve(eq = 0, y, x = a, [b0,...,b(n-1)])}.

  Implementation ==> add
    checkCompat: (OP, EQ, EQ) -> F
    checkOrder1: (F, OP, K, SY, F) -> F
    checkOrderN: (F, OP, K, SY, F, NonNegativeInteger) -> F
    checkSystem: (F, List K, List F) -> F
    div2exquo  : F -> F
    smp2exquo  : P -> F
    k2exquo    : K -> F
    diffRhs    : (F, F) -> F
    diffRhsK   : (K, F) -> F
    findCompat : (F, List EQ) -> F
    findEq     : (K, SY, List F) -> F
    localInteger: F -> F

    opelt := operator("elt"::Symbol)$OP
    --opex  := operator("exquo"::Symbol)$OP
    opex  := operator("fixedPointExquo"::Symbol)$OP
    opint := operator("integer"::Symbol)$OP

    Rint? := R has IntegerNumberSystem

    localInteger n == (Rint? => n; opint n)
    diffRhs(f, g) == diffRhsK(retract(f)@K, g)

    k2exquo k ==
      is?(op := operator k, "%diff"::Symbol) =>
        error "Improper differential equation"
      kernel(op, [div2exquo f for f in argument k]$List(F))

    smp2exquo p ==
      map(k2exquo,#1::F,p)$PolynomialCategoryLifting(IndexedExponents K,
                                                             K, R, P, F)

    div2exquo f ==
--      one?(d := denom f) => f
      ((d := denom f) = 1) => f
      opex(smp2exquo numer f, smp2exquo d)

-- if g is of the form a * k + b, then return -b/a
    diffRhsK(k, g) ==
      h := univariate(g, k)
      (degree(numer h) <= 1) and ground? denom h =>
        - coefficient(numer h, 0) / coefficient(numer h, 1)
      error "Improper differential equation"

    checkCompat(y, eqx, eqy) ==
      lhs(eqy) =$F y(rhs eqx) => rhs eqy
      error "Improper initial value"

    findCompat(yx, l) ==
      for eq in l repeat
        yx =$F lhs eq => return rhs eq
      error "Improper initial value"

    findEq(k, x, sys) ==
      k := retract(differentiate(k::F, x))@K
      for eq in sys repeat
        member?(k, kernels eq) => return eq
      error "Improper differential equation"

    checkOrder1(diffeq, y, yx, x, sy) ==
      div2exquo subst(diffRhs(differentiate(yx::F,x),diffeq),[yx],[sy])

    checkOrderN(diffeq, y, yx, x, sy, n) ==
      zero? n => error "No initial value(s) given"
      m     := (minIndex(l := [retract(f := yx::F)@K]$List(K)))::F
      lv    := [opelt(sy, localInteger m)]$List(F)
      for i in 2..n repeat
        l  := concat(retract(f := differentiate(f, x))@K, l)
        lv := concat(opelt(sy, localInteger(m := m + 1)), lv)
      div2exquo subst(diffRhs(differentiate(f, x), diffeq), l, lv)

    checkSystem(diffeq, yx, lv) ==
      for k in kernels diffeq repeat
        is?(k, "%diff"::SY) =>
          return div2exquo subst(diffRhsK(k, diffeq), yx, lv)
      0

    seriesSolve(l:List EQ, y:List OP, eqx:EQ, eqy:List EQ) ==
      seriesSolve([lhs deq - rhs deq for deq in l]$List(F), y, eqx, eqy)

    seriesSolve(l:List EQ, y:List OP, eqx:EQ, y0:List F) ==
      seriesSolve([lhs deq - rhs deq for deq in l]$List(F), y, eqx, y0)

    seriesSolve(l:List F, ly:List OP, eqx:EQ, eqy:List EQ) ==
      seriesSolve(l, ly, eqx,
                  [findCompat(y rhs eqx, eqy) for y in ly]$List(F))

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, eqy:EQ) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, eqy)

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, y0:F) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, y0)

    seriesSolve(diffeq:EQ, y:OP, eqx:EQ, y0:List F) ==
      seriesSolve(lhs diffeq - rhs diffeq, y, eqx, y0)

    seriesSolve(diffeq:F, y:OP, eqx:EQ, eqy:EQ) ==
      seriesSolve(diffeq, y, eqx, checkCompat(y, eqx, eqy))

    seriesSolve(diffeq:F, y:OP, eqx:EQ, y0:F) ==
      x      := symbolIfCan(retract(lhs eqx)@K)::SY
      sy     := name y
      yx     := retract(y lhs eqx)@K
      f      := checkOrder1(diffeq, y, yx, x, sy::F)
      center := rhs eqx
      coerce(ode1(compiledFunction(f, sy)$MKF, y0)$ODE)$A1

    seriesSolve(diffeq:F, y:OP, eqx:EQ, y0:List F) ==
      x      := symbolIfCan(retract(lhs eqx)@K)::SY
      sy     := new()$SY
      yx     := retract(y lhs eqx)@K
      f      := checkOrderN(diffeq, y, yx, x, sy::F, #y0)
      center := rhs eqx
      coerce(ode(compiledFunction(f, sy)$MKL, y0)$ODE)$A1

    seriesSolve(sys:List F, ly:List OP, eqx:EQ, l0:List F) ==
      x      := symbolIfCan(kx := retract(lhs eqx)@K)::SY
      fsy    := (sy := new()$SY)::F
      m      := (minIndex(l0) - 1)::F
      yx     := concat(kx, [retract(y lhs eqx)@K for y in ly]$List(K))
      lelt   := [opelt(fsy, localInteger(m := m+1)) for k in yx]$List(F)
      sys    := [findEq(k, x, sys) for k in rest yx]
      l      := [checkSystem(eq, yx, lelt) for eq in sys]$List(F)
      center := rhs eqx
      coerce(mpsode(l0,[compiledFunction(f,sy)$MKL for f in l])$ODE)$AL1

@
<<EXPRODE.dotabb>>=
"EXPRODE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPRODE"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"EXPRODE" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OMEXPR ExpressionToOpenMath}
\pagehead{ExpressionToOpenMath}{OMEXPR}
\pagepic{ps/v104expressiontoopenmath.ps}{OMEXPR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OMEXPR ExpressionToOpenMath>>=
)abbrev package OMEXPR ExpressionToOpenMath
++ Author: Mike Dewar & Vilya Harvey
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: \spadtype{ExpressionToOpenMath} provides support for
++ converting objects of type \spadtype{Expression} into OpenMath.
ExpressionToOpenMath(R: Join(OpenMath, OrderedSet, Ring)): with
  OMwrite  : Expression R -> String
  OMwrite  : (Expression R, Boolean) -> String
  OMwrite  : (OpenMathDevice, Expression R) -> Void
  OMwrite  : (OpenMathDevice, Expression R, Boolean) -> Void
 == add
  import Expression R
  SymInfo ==> Record(cd:String, name:String)
  import SymInfo
  import Record(key: Symbol, entry: SymInfo)
  import AssociationList(Symbol, SymInfo)
  import OMENC

  ----------------------------
  -- Local translation tables.
  ----------------------------

  nullaryFunctionAList : AssociationList(Symbol, SymInfo) := construct [_
    [pi, ["nums1", "pi"]] ]

  unaryFunctionAList : AssociationList(Symbol, SymInfo) := construct [_
    [exp,  ["transc1", "exp"]],_
    [log,  ["transc1", "ln"]],_
    [sin,  ["transc1", "sin"]],_
    [cos,  ["transc1", "cos"]],_
    [tan,  ["transc1", "tan"]],_
    [cot,  ["transc1", "cot"]],_
    [sec,  ["transc1", "sec"]],_
    [csc,  ["transc1", "csc"]],_
    [asin, ["transc1", "arcsin"]],_
    [acos, ["transc1", "arccos"]],_
    [atan, ["transc1", "arctan"]],_
    [acot, ["transc1", "arccot"]],_
    [asec, ["transc1", "arcsec"]],_
    [acsc, ["transc1", "arccsc"]],_
    [sinh, ["transc1", "sinh"]],_
    [cosh, ["transc1", "cosh"]],_
    [tanh, ["transc1", "tanh"]],_
    [coth, ["transc1", "coth"]],_
    [sech, ["transc1", "sech"]],_
    [csch, ["transc1", "csch"]],_
    [asinh, ["transc1", "arcsinh"]],_
    [acosh, ["transc1", "arccosh"]],_
    [atanh, ["transc1", "arctanh"]],_
    [acoth, ["transc1", "arccoth"]],_
    [asech, ["transc1", "arcsech"]],_
    [acsch, ["transc1", "arccsch"]],_
    [factorial, ["integer1", "factorial"]],_
    [abs, ["arith1", "abs"]] ]

    -- Still need the following unary functions:
    --  digamma
    --  Gamma
    --  airyAi
    --  airyBi
    --  erf
    --  Ei
    --  Si
    --  Ci
    --  li
    --  dilog

    -- Still need the following binary functions:
    --      Gamma(a, x)
    --      Beta(x,y) 
    --      polygamma(k,x)
    --      besselJ(v,x)
    --      besselY(v,x)
    --      besselI(v,x)
    --      besselK(v,x)
    --      permutation(n, m)
    --      summation(x:%, n:Symbol) : as opposed to "definite" sum
    --      product(x:%, n:Symbol)   : ditto

  ------------------------
  -- Forward declarations.
  ------------------------

  outputOMExpr  : (OpenMathDevice, Expression R) -> Void

  -------------------------
  -- Local helper functions
  -------------------------

  outputOMArith1(dev: OpenMathDevice, sym: String, args: List Expression R): Void ==
    OMputApp(dev)
    OMputSymbol(dev, "arith1", sym)
    for arg in args repeat
      OMwrite(dev, arg, false)
    OMputEndApp(dev)

  outputOMLambda(dev: OpenMathDevice, ex: Expression R, var: Expression R): Void ==
    OMputBind(dev)
    OMputSymbol(dev, "fns1", "lambda")
    OMputBVar(dev)
    OMwrite(dev, var, false)
    OMputEndBVar(dev)
    OMwrite(dev, ex, false)
    OMputEndBind(dev)

  outputOMInterval(dev: OpenMathDevice, lo: Expression R, hi: Expression R): Void ==
    OMputApp(dev)
    OMputSymbol(dev, "interval1", "interval")
    OMwrite(dev, lo, false)
    OMwrite(dev, hi, false)
    OMputEndApp(dev)

  outputOMIntInterval(dev: OpenMathDevice, lo: Expression R, hi: Expression R): Void ==
    OMputApp(dev)
    OMputSymbol(dev, "interval1", "integer__interval")
    OMwrite(dev, lo, false)
    OMwrite(dev, hi, false)
    OMputEndApp(dev)

  outputOMBinomial(dev: OpenMathDevice, args: List Expression R): Void ==
    not #args=2 => error "Wrong number of arguments to binomial"
    OMputApp(dev)
    OMputSymbol(dev, "combinat1", "binomial")
    for arg in args repeat
      OMwrite(dev, arg, false)
    OMputEndApp(dev)

  outputOMPower(dev: OpenMathDevice, args: List Expression R): Void ==
    not #args=2 => error "Wrong number of arguments to power"
    outputOMArith1(dev, "power", args)

  outputOMDefsum(dev: OpenMathDevice, args: List Expression R): Void ==
    #args ^= 5 => error "Unexpected number of arguments to a defsum"
    OMputApp(dev)
    OMputSymbol(dev, "arith1", "sum")
    outputOMIntInterval(dev, args.4, args.5)
    outputOMLambda(dev, eval(args.1, args.2, args.3), args.3)
    OMputEndApp(dev)

  outputOMDefprod(dev: OpenMathDevice, args: List Expression R): Void ==
    #args ^= 5 => error "Unexpected number of arguments to a defprod"
    OMputApp(dev)
    OMputSymbol(dev, "arith1", "product")
    outputOMIntInterval(dev, args.4, args.5)
    outputOMLambda(dev, eval(args.1, args.2, args.3), args.3)
    OMputEndApp(dev)

  outputOMDefint(dev: OpenMathDevice, args: List Expression R): Void ==
    #args ^= 5 => error "Unexpected number of arguments to a defint"
    OMputApp(dev)
    OMputSymbol(dev, "calculus1", "defint")
    outputOMInterval(dev, args.4, args.5)
    outputOMLambda(dev, eval(args.1, args.2, args.3), args.3)
    OMputEndApp(dev)

  outputOMInt(dev: OpenMathDevice, args: List Expression R): Void ==
    #args ^= 3 => error "Unexpected number of arguments to a defint"
    OMputApp(dev)
    OMputSymbol(dev, "calculus1", "int")
    outputOMLambda(dev, eval(args.1, args.2, args.3), args.3)
    OMputEndApp(dev)

  outputOMFunction(dev: OpenMathDevice, op: Symbol, args: List Expression R): Void ==
    nargs := #args
    zero? nargs =>
      omOp: Union(SymInfo, "failed") := search(op, nullaryFunctionAList)
      omOp case "failed" =>
        error concat ["No OpenMath definition for nullary function ", coerce op]
      OMputSymbol(dev, omOp.cd, omOp.name)
--    one? nargs =>
    (nargs = 1) =>
      omOp: Union(SymInfo, "failed") := search(op, unaryFunctionAList)
      omOp case "failed" =>
        error concat ["No OpenMath definition for unary function ", coerce op]
      OMputApp(dev)
      OMputSymbol(dev, omOp.cd, omOp.name)
      for arg in args repeat
        OMwrite(dev, arg, false)
      OMputEndApp(dev)
    -- Most of the binary operators cannot be handled trivialy like the
    -- unary ones since they have bound variables of one kind or another.
    -- The special functions should be straightforward, but we don't have
    -- a CD for them yet :-)
    op = %defint  => outputOMDefint(dev, args)
    op = integral => outputOMInt(dev, args)
    op = %defsum  => outputOMDefsum(dev, args)
    op = %defprod => outputOMDefprod(dev, args)
    op = %power   => outputOMPower(dev, args)
    op = binomial => outputOMBinomial(dev, args)
    error concat ["No OpenMath definition for function ", string op]
 
  outputOMExpr(dev: OpenMathDevice, ex: Expression R): Void ==
    ground? ex => OMwrite(dev, ground ex, false)
    not((v := retractIfCan(ex)@Union(Symbol,"failed")) case "failed") =>
      OMputVariable(dev, v)
    not((w := isPlus ex) case "failed") => outputOMArith1(dev, "plus", w)
    not((w := isTimes ex) case "failed") => outputOMArith1(dev, "times", w)
    --not((y := isMult ex) case "failed") =>
    --  outputOMArith("times", [OMwrite(y.coef)$Integer,
    --          OMwrite(coerce y.var)])
    -- At the time of writing we don't need both isExpt and isPower
    -- here but they may be relevent when we integrate this stuff into
    -- the main Expression code.  Note that if we don't check that
    -- the exponent is non-trivial we get thrown into an infinite recursion.
--    not (((x := isExpt ex) case "failed") or one? x.exponent) =>
    not (((x := isExpt ex) case "failed") or (x.exponent = 1)) =>
      not((s := symbolIfCan(x.var)@Union(Symbol,"failed")) case "failed") =>
        --outputOMPower(dev, [s::Expression(R), (x.exponent)::Expression(R)])
        OMputApp(dev)
        OMputSymbol(dev, "arith1", "power")
        OMputVariable(dev, s)
        OMputInteger(dev, x.exponent)
        OMputEndApp(dev)
      -- TODO: add error handling code here...
--    not (((z := isPower ex) case "failed") or one? z.exponent) =>
    not (((z := isPower ex) case "failed") or (z.exponent = 1)) =>
      outputOMPower(dev, [ z.val, z.exponent::Expression R ])
      --OMputApp(dev)
      --OMputSymbol(dev, "arith1", "power")
      --outputOMExpr(dev, z.val)
      --OMputInteger(dev, z.exponent)
      --OMputEndApp(dev)
    -- Must only be one top-level Kernel by this point
    k : Kernel Expression R := first kernels ex
    outputOMFunction(dev, name operator k, argument k)


  ----------
  -- Exports
  ----------

  OMwrite(ex: Expression R): String ==
    s: String := ""
    sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
    dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML())
    OMputObject(dev)
    outputOMExpr(dev, ex)
    OMputEndObject(dev)
    OMclose(dev)
    s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
    s

  OMwrite(ex: Expression R, wholeObj: Boolean): String ==
    s: String := ""
    sp := OM_-STRINGTOSTRINGPTR(s)$Lisp
    dev: OpenMathDevice := OMopenString(sp pretend String, OMencodingXML())
    if wholeObj then
      OMputObject(dev)
    outputOMExpr(dev, ex)
    if wholeObj then
      OMputEndObject(dev)
    OMclose(dev)
    s := OM_-STRINGPTRTOSTRING(sp)$Lisp pretend String
    s

  OMwrite(dev: OpenMathDevice, ex: Expression R): Void ==
    OMputObject(dev)
    outputOMExpr(dev, ex)
    OMputEndObject(dev)

  OMwrite(dev: OpenMathDevice, ex: Expression R, wholeObj: Boolean): Void ==
    if wholeObj then
      OMputObject(dev)
    outputOMExpr(dev, ex)
    if wholeObj then
      OMputEndObject(dev)

@
<<OMEXPR.dotabb>>=
"OMEXPR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OMEXPR"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"OMEXPR" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package EXPR2UPS ExpressionToUnivariatePowerSeries}
\pagehead{ExpressionToUnivariatePowerSeries}{EXPR2UPS}
\pagepic{ps/v104expressiontounivariatepowerseries.ps}{EXPR2UPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package EXPR2UPS ExpressionToUnivariatePowerSeries>>=
)abbrev package EXPR2UPS ExpressionToUnivariatePowerSeries
++ Author: Clifton J. Williamson
++ Date Created: 9 May 1989
++ Date Last Updated: 20 September 1993
++ Basic Operations: taylor, laurent, puiseux, series
++ Related Domains: UnivariateTaylorSeries, UnivariateLaurentSeries,
++   UnivariatePuiseuxSeries, Expression
++ Also See: FunctionSpaceToUnivariatePowerSeries
++ AMS Classifications:
++ Keywords: Taylor series, Laurent series, Puiseux series
++ Examples:
++ References:
++ Description:
++   This package provides functions to convert functional expressions
++   to power series.
ExpressionToUnivariatePowerSeries(R,FE): Exports == Implementation where
  R  : Join(GcdDomain,OrderedSet,RetractableTo Integer,_
            LinearlyExplicitRingOver Integer)
  FE : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
            FunctionSpace R)

  EQ     ==> Equation
  I      ==> Integer
  NNI    ==> NonNegativeInteger
  RN     ==> Fraction Integer
  SY     ==> Symbol
  UTS    ==> UnivariateTaylorSeries
  ULS    ==> UnivariateLaurentSeries
  UPXS   ==> UnivariatePuiseuxSeries
  GSER   ==> GeneralUnivariatePowerSeries
  EFULS  ==> ElementaryFunctionsUnivariateLaurentSeries
  EFUPXS ==> ElementaryFunctionsUnivariatePuiseuxSeries
  FS2UPS ==> FunctionSpaceToUnivariatePowerSeries
  Prob   ==> Record(func:String,prob:String)
  ANY1   ==> AnyFunctions1

  Exports ==> with
    taylor: SY -> Any
      ++ \spad{taylor(x)} returns x viewed as a Taylor series.
    taylor: FE -> Any
      ++ \spad{taylor(f)} returns a Taylor expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    taylor: (FE,NNI) -> Any
      ++ \spad{taylor(f,n)} returns a Taylor expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    taylor: (FE,EQ FE) -> Any
      ++ \spad{taylor(f,x = a)} expands the expression f as a Taylor series
      ++ in powers of \spad{(x - a)}.
    taylor: (FE,EQ FE,NNI) -> Any
      ++ \spad{taylor(f,x = a)} expands the expression f as a Taylor series
      ++ in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.

    laurent: SY -> Any
      ++ \spad{laurent(x)} returns x viewed as a Laurent series.
    laurent: FE -> Any
      ++ \spad{laurent(f)} returns a Laurent expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    laurent: (FE,I) -> Any
      ++ \spad{laurent(f,n)} returns a Laurent expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    laurent: (FE,EQ FE) -> Any
      ++ \spad{laurent(f,x = a)} expands the expression f as a Laurent series
      ++ in powers of \spad{(x - a)}.
    laurent: (FE,EQ FE,I) -> Any
      ++ \spad{laurent(f,x = a,n)} expands the expression f as a Laurent
      ++ series in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.
    puiseux: SY -> Any
      ++ \spad{puiseux(x)} returns x viewed as a Puiseux series.
    puiseux: FE -> Any
      ++ \spad{puiseux(f)} returns a Puiseux expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    puiseux: (FE,RN) -> Any
      ++ \spad{puiseux(f,n)} returns a Puiseux expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    puiseux: (FE,EQ FE) -> Any
      ++ \spad{puiseux(f,x = a)} expands the expression f as a Puiseux series
      ++ in powers of \spad{(x - a)}.
    puiseux: (FE,EQ FE,RN) -> Any
      ++ \spad{puiseux(f,x = a,n)} expands the expression f as a Puiseux
      ++ series in powers of \spad{(x - a)}; terms will be computed up to order
      ++ at least n.

    series: SY -> Any
      ++ \spad{series(x)} returns x viewed as a series.
    series: FE -> Any
      ++ \spad{series(f)} returns a series expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable.
    series: (FE,RN) -> Any
      ++ \spad{series(f,n)} returns a series expansion of the expression f.
      ++ Note: f should have only one variable; the series will be
      ++ expanded in powers of that variable and terms will be computed
      ++ up to order at least n.
    series: (FE,EQ FE) -> Any
      ++ \spad{series(f,x = a)} expands the expression f as a series
      ++ in powers of (x - a).
    series: (FE,EQ FE,RN) -> Any
      ++ \spad{series(f,x = a,n)} expands the expression f as a series
      ++ in powers of (x - a); terms will be computed up to order
      ++ at least n.

  Implementation ==> add
    performSubstitution: (FE,SY,FE) -> FE
    performSubstitution(fcn,x,a) ==
      zero? a => fcn
      xFE := x :: FE
      eval(fcn,xFE = xFE + a)

    iTaylor: (FE,SY,FE) -> Any
    iTaylor(fcn,x,a) ==
      pack := FS2UPS(R,FE,I,ULS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a)),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Taylor expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Taylor expansion: logarithmic singularity"
        ans.%problem.func = "nth root" =>
          error "No Taylor expansion: fractional powers in expansion"
        error "No Taylor expansion"
      uls := ans.%series
      (uts := taylorIfCan uls) case "failed" =>
        error "No Taylor expansion: pole"
      any1 := ANY1(UTS(FE,x,a))
      coerce(uts :: UTS(FE,x,a))$any1

    taylor(x:SY) ==
      uts := UTS(FE,x,0$FE); any1 := ANY1(uts)
      coerce(monomial(1,1)$uts)$any1

    taylor(fcn:FE) ==
      null(vars := variables fcn) =>
        error "taylor: expression has no variables"
      not null rest vars =>
        error "taylor: expression has more than one variable"
      taylor(fcn,(first(vars) :: FE) = 0)

    taylor(fcn:FE,n:NNI) ==
      null(vars := variables fcn) =>
        error "taylor: expression has no variables"
      not null rest vars =>
        error "taylor: expression has more than one variable"
      x := first vars
      uts := UTS(FE,x,0$FE); any1 := ANY1(uts)
      series := retract(taylor(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    taylor(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iTaylor(performSubstitution(fcn,x,a),x,a)

    taylor(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UTS(FE,x,a))
      series := retract(iTaylor(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iLaurent: (FE,SY,FE) -> Any
    iLaurent(fcn,x,a) ==
      pack := FS2UPS(R,FE,I,ULS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a)),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Laurent expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Laurent expansion: logarithmic singularity"
        ans.%problem.func = "nth root" =>
          error "No Laurent expansion: fractional powers in expansion"
        error "No Laurent expansion"
      any1 := ANY1(ULS(FE,x,a))
      coerce(ans.%series)$any1

    laurent(x:SY) ==
      uls := ULS(FE,x,0$FE); any1 := ANY1(uls)
      coerce(monomial(1,1)$uls)$any1

    laurent(fcn:FE) ==
      null(vars := variables fcn) =>
        error "laurent: expression has no variables"
      not null rest vars =>
        error "laurent: expression has more than one variable"
      laurent(fcn,(first(vars) :: FE) = 0)

    laurent(fcn:FE,n:I) ==
      null(vars := variables fcn) =>
        error "laurent: expression has no variables"
      not null rest vars =>
        error "laurent: expression has more than one variable"
      x := first vars
      uls := ULS(FE,x,0$FE); any1 := ANY1(uls)
      series := retract(laurent(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    laurent(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iLaurent(performSubstitution(fcn,x,a),x,a)

    laurent(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(ULS(FE,x,a))
      series := retract(iLaurent(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iPuiseux: (FE,SY,FE) -> Any
    iPuiseux(fcn,x,a) ==
      pack := FS2UPS(R,FE,RN,UPXS(FE,x,a),_
                     EFUPXS(FE,ULS(FE,x,a),UPXS(FE,x,a),_
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a))),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ans.%problem.prob = "essential singularity" =>
          error "No Puiseux expansion: essential singularity"
        ans.%problem.func = "log" =>
          error "No Puiseux expansion: logarithmic singularity"
        error "No Puiseux expansion"
      any1 := ANY1(UPXS(FE,x,a))
      coerce(ans.%series)$any1

    puiseux(x:SY) ==
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      coerce(monomial(1,1)$upxs)$any1

    puiseux(fcn:FE) ==
      null(vars := variables fcn) =>
        error "puiseux: expression has no variables"
      not null rest vars =>
        error "puiseux: expression has more than one variable"
      puiseux(fcn,(first(vars) :: FE) = 0)

    puiseux(fcn:FE,n:RN) ==
      null(vars := variables fcn) =>
        error "puiseux: expression has no variables"
      not null rest vars =>
        error "puiseux: expression has more than one variable"
      x := first vars
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      series := retract(puiseux(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    puiseux(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iPuiseux(performSubstitution(fcn,x,a),x,a)

    puiseux(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UPXS(FE,x,a))
      series := retract(iPuiseux(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

    iSeries: (FE,SY,FE) -> Any
    iSeries(fcn,x,a) ==
      pack := FS2UPS(R,FE,RN,UPXS(FE,x,a), _
                     EFUPXS(FE,ULS(FE,x,a),UPXS(FE,x,a), _
                     EFULS(FE,UTS(FE,x,a),ULS(FE,x,a))),x)
      ans := exprToUPS(fcn,false,"just do it")$pack
      ans case %problem =>
        ansG := exprToGenUPS(fcn,false,"just do it")$pack
        ansG case %problem =>
          ansG.%problem.prob = "essential singularity" =>
            error "No series expansion: essential singularity"
          error "No series expansion"
        anyone := ANY1(GSER(FE,x,a))
        coerce((ansG.%series) :: GSER(FE,x,a))$anyone
      any1 := ANY1(UPXS(FE,x,a))
      coerce(ans.%series)$any1

    series(x:SY) ==
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      coerce(monomial(1,1)$upxs)$any1

    series(fcn:FE) ==
      null(vars := variables fcn) =>
        error "series: expression has no variables"
      not null rest vars =>
        error "series: expression has more than one variable"
      series(fcn,(first(vars) :: FE) = 0)

    series(fcn:FE,n:RN) ==
      null(vars := variables fcn) =>
        error "series: expression has no variables"
      not null rest vars =>
        error "series: expression has more than one variable"
      x := first vars
      upxs := UPXS(FE,x,0$FE); any1 := ANY1(upxs)
      series := retract(series(fcn,(x :: FE) = 0))$any1
      coerce(extend(series,n))$any1

    series(fcn:FE,eq:EQ FE) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      iSeries(performSubstitution(fcn,x,a),x,a)

    series(fcn,eq,n) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      any1 := ANY1(UPXS(FE,x,a))
      series := retract(iSeries(performSubstitution(fcn,x,a),x,a))$any1
      coerce(extend(series,n))$any1

@
<<EXPR2UPS.dotabb>>=
"EXPR2UPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=EXPR2UPS"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"EXPR2UPS" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package E04AGNT e04AgentsPackage}
\pagehead{e04AgentsPackage}{E04AGNT}
\pagepic{ps/v104e04agentspackage.ps}{E04AGNT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package E04AGNT e04AgentsPackage>>=
)abbrev package E04AGNT e04AgentsPackage
++ Author: Brian Dupee
++ Date Created: February 1996
++ Date Last Updated: June 1996
++ Basic Operations: simple? linear?, quadratic?, nonLinear?
++ Description:
++ \axiomType{e04AgentsPackage} is a package of numerical agents to be used
++ to investigate attributes of an input function so as to decide the
++ \axiomFun{measure} of an appropriate numerical optimization routine.
MDF	==> Matrix DoubleFloat
VEDF	==> Vector Expression DoubleFloat
EDF	==> Expression DoubleFloat
EFI	==> Expression Fraction Integer
PFI	==> Polynomial Fraction Integer
FI	==> Fraction Integer
F	==> Float
DF	==> DoubleFloat
OCDF	==> OrderedCompletion DoubleFloat
LOCDF	==> List OrderedCompletion DoubleFloat
LEDF	==> List Expression DoubleFloat
PDF	==> Polynomial DoubleFloat
LDF	==> List DoubleFloat
INT	==> Integer
NNI	==> NonNegativeInteger
LS	==> List Symbol
EF2	==> ExpressionFunctions2
NOA	==> Record(fn:EDF, init:LDF, lb:LOCDF, cf:LEDF, ub:LOCDF)
LSA	==> Record(lfn:LEDF, init:LDF)

e04AgentsPackage(): E == I where
  E ==> with
    finiteBound:(LOCDF,DF) -> LDF 
      ++ finiteBound(l,b) repaces all instances of an infinite entry in
      ++ \axiom{l} by a finite entry \axiom{b} or \axiom{-b}.
    sortConstraints:NOA -> NOA
      ++ sortConstraints(args) uses a simple bubblesort on the list of
      ++ constraints using the degree of the expression on which to sort.
      ++ Of course, it must match the bounds to the constraints.
    sumOfSquares:EDF -> Union(EDF,"failed")
      ++ sumOfSquares(f) returns either an expression for which the square is
      ++ the original function of "failed".
    splitLinear:EDF -> EDF 
      ++ splitLinear(f) splits the linear part from an expression which it
      ++ returns.
    simpleBounds?:LEDF -> Boolean
      ++ simpleBounds?(l) returns true if the list of expressions l are
      ++ simple.
    linear?:LEDF -> Boolean
      ++ linear?(l) returns true if all the bounds l are either linear or
      ++ simple.
    linear?:EDF -> Boolean
      ++ linear?(e) tests if \axiom{e} is a linear function.
    linearMatrix:(LEDF, NNI) -> MDF
      ++ linearMatrix(l,n) returns a matrix of coefficients of the linear
      ++ functions in \axiom{l}.  If l is empty, the matrix has at least one
      ++ row.
    linearPart:LEDF -> LEDF
      ++ linearPart(l) returns the list of linear functions of \axiom{l}.
    nonLinearPart:LEDF -> LEDF
      ++ nonLinearPart(l) returns the list of non-linear functions of \axiom{l}.
    quadratic?:EDF -> Boolean
      ++ quadratic?(e) tests if \axiom{e} is a quadratic function.
    variables:LSA -> LS
      ++ variables(args) returns the list of variables in \axiom{args.lfn}
    varList:(EDF,NNI) -> LS
      ++ varList(e,n) returns a list of \axiom{n} indexed variables with name
      ++ as in \axiom{e}.
    changeNameToObjf:(Symbol,Result) -> Result
      ++ changeNameToObjf(s,r) changes the name of item \axiom{s} in \axiom{r}
      ++ to objf.
    expenseOfEvaluation:LSA -> F
      ++ expenseOfEvaluation(o) returns the intensity value of the 
      ++ cost of evaluating the input set of functions.  This is in terms 
      ++ of the number of ``operational units''.  It returns a value 
      ++ in the range [0,1].
    optAttributes:Union(noa:NOA,lsa:LSA) -> List String
      ++ optAttributes(o) is a function for supplying a list of attributes
      ++ of an optimization problem.

  I ==> add

    import ExpertSystemToolsPackage, ExpertSystemContinuityPackage

    sumOfSquares2:EFI -> Union(EFI,"failed")
    nonLinear?:EDF -> Boolean
    finiteBound2:(OCDF,DF) -> DF 
    functionType:EDF -> String

    finiteBound2(a:OCDF,b:DF):DF ==
      not finite?(a) =>
        positive?(a) => b
        -b
      retract(a)@DF

    finiteBound(l:LOCDF,b:DF):LDF == [finiteBound2(i,b) for i in l]

    sortConstraints(args:NOA):NOA ==
      Args := copy args
      c:LEDF := Args.cf
      l:LOCDF := Args.lb
      u:LOCDF := Args.ub
      m:INT := (# c) - 1      
      n:INT := (# l) - m
      for j in m..1 by -1 repeat
        for i in 1..j repeat
          s:EDF := c.i
          t:EDF := c.(i+1)
          if linear?(t) and (nonLinear?(s) or quadratic?(s)) then
            swap!(c,i,i+1)$LEDF
            swap!(l,n+i-1,n+i)$LOCDF
            swap!(u,n+i-1,n+i)$LOCDF
      Args
        
    changeNameToObjf(s:Symbol,r:Result):Result ==
      a := remove!(s,r)$Result
      a case Any =>
        insert!([objf@Symbol,a],r)$Result
        r
      r

    sum(a:EDF,b:EDF):EDF == a+b

    variables(args:LSA): LS == variables(reduce(sum,(args.lfn)))

    sumOfSquares(f:EDF):Union(EDF,"failed") ==
      e := edf2efi(f)
      s:Union(EFI,"failed") := sumOfSquares2(e)
      s case EFI =>
        map(fi2df,s)$EF2(FI,DF)
      "failed"

    sumOfSquares2(f:EFI):Union(EFI,"failed") ==
      p := retractIfCan(f)@Union(PFI,"failed")
      p case PFI => 
        r := squareFreePart(p)$PFI
        (p=r)@Boolean => "failed"
        tp := totalDegree(p)$PFI
        tr := totalDegree(r)$PFI
        t := tp quo tr
        found := false
        q := r
        for i in 2..t by 2 repeat
          s := q**2
          (s=p)@Boolean => 
            found := true
            leave
          q := r**i
        if found then 
          q :: EFI
        else
          "failed"
      "failed"

    splitLinear(f:EDF):EDF ==
      out := 0$EDF
      (l := isPlus(f)$EDF) case LEDF =>
        for i in l repeat
          if not quadratic? i then
            out := out + i
        out
      out

    edf2pdf(f:EDF):PDF == (retract(f)@PDF)$EDF

    varList(e:EDF,n:NNI):LS ==
      s := name(first(variables(edf2pdf(e))$PDF)$LS)$Symbol
      [subscript(s,[t::OutputForm]) for t in expand([1..n])$Segment(Integer)]

    functionType(f:EDF):String ==
      n := #(variables(f))$EDF
      p := (retractIfCan(f)@Union(PDF,"failed"))$EDF
      p case PDF =>
        d := totalDegree(p)$PDF
--        one?(n*d) => "simple"
        (n*d) = 1 => "simple"
--        one?(d) => "linear"
        (d = 1) => "linear"
        (d=2)@Boolean => "quadratic"
        "non-linear"
      "non-linear"
     
    simpleBounds?(l: LEDF):Boolean ==
      a := true
      for e in l repeat
        not (functionType(e) = "simple")@Boolean => 
          a := false
          leave
      a

    simple?(e:EDF):Boolean == (functionType(e) = "simple")@Boolean

    linear?(e:EDF):Boolean == (functionType(e) = "linear")@Boolean

    quadratic?(e:EDF):Boolean == (functionType(e) = "quadratic")@Boolean

    nonLinear?(e:EDF):Boolean == (functionType(e) = "non-linear")@Boolean

    linear?(l: LEDF):Boolean ==
      a := true
      for e in l repeat
        s := functionType(e)
        (s = "quadratic")@Boolean or (s = "non-linear")@Boolean => 
          a := false
          leave
      a

    simplePart(l:LEDF):LEDF == [i for i in l | simple?(i)]

    linearPart(l:LEDF):LEDF == [i for i in l | linear?(i)]

    nonLinearPart(l:LEDF):LEDF ==
      [i for i in l | not linear?(i) and not simple?(i)]

    linearMatrix(l:LEDF, n:NNI):MDF ==
      empty?(l) => mat([],n)
      L := linearPart l
      M := zero(max(1,# L)$NNI,n)$MDF
      vars := varList(first(l)$LEDF,n)
      row:INT := 1
      for a in L repeat
        for j in monomials(edf2pdf(a))$PDF repeat
          col:INT := 1
          for c in vars repeat
            if ((first(variables(j)$PDF)$LS)=c)@Boolean then
              M(row,col):= first(coefficients(j)$PDF)$LDF
            col := col+1
        row := row + 1
      M

    expenseOfEvaluation(o:LSA):F ==
      expenseOfEvaluation(vector(copy o.lfn)$VEDF)

    optAttributes(o:Union(noa:NOA,lsa:LSA)):List String ==
      o case noa =>
        n := o.noa
        s1:String := "The object function is " functionType(n.fn)
        if empty?(n.lb) then
          s2:String := "There are no bounds on the variables" 
        else
          s2:String := "There are simple bounds on the variables"
        c := n.cf
        if empty?(c) then
          s3:String := "There are no constraint functions"
        else
          t := #(c)
          lin := #(linearPart(c))
          nonlin := #(nonLinearPart(c))
          s3:String := "There are " string(lin)$String " linear and "_
                          string(nonlin)$String " non-linear constraints"
        [s1,s2,s3]
      l := o.lsa
      s:String := "non-linear"
      if linear?(l.lfn) then
        s := "linear"
      ["The object functions are " s]

@
<<E04AGNT.dotabb>>=
"E04AGNT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=E04AGNT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"E04AGNT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter F}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FACTFUNC FactoredFunctions}
\pagehead{FactoredFunctions}{FACTFUNC}
\pagepic{ps/v104factoredfunctions.ps}{FACTFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FACTFUNC FactoredFunctions>>=
)abbrev package FACTFUNC FactoredFunctions
++ Author: Manuel Bronstein
++ Date Created: 2 Feb 1988
++ Date Last Updated: 25 Jun 1990
++ Description: computes various functions on factored arguments.
-- not visible to the user
FactoredFunctions(M:IntegralDomain): Exports == Implementation where
  N ==> NonNegativeInteger

  Exports ==> with
    nthRoot: (Factored M,N) -> Record(exponent:N,coef:M,radicand:List M)
      ++ nthRoot(f, n) returns \spad{(p, r, [r1,...,rm])} such that
      ++ the nth-root of f is equal to \spad{r * pth-root(r1 * ... * rm)},
      ++ where r1,...,rm are distinct factors of f,
      ++ each of which has an exponent smaller than p in f.
    log : Factored M -> List Record(coef:N, logand:M)
      ++ log(f) returns \spad{[(a1,b1),...,(am,bm)]} such that
      ++ the logarithm of f is equal to \spad{a1*log(b1) + ... + am*log(bm)}.

  Implementation ==> add
    nthRoot(ff, n) ==
      coeff:M       := 1
--      radi:List(M)  := (one? unit ff => empty(); [unit ff])
      radi:List(M)  := (((unit ff) = 1) => empty(); [unit ff])
      lf            := factors ff
      d:N :=
        empty? radi => gcd(concat(n, [t.exponent::N for t in lf]))::N
        1
      n             := n quo d
      for term in lf repeat
        qr    := divide(term.exponent::N quo d, n)
        coeff := coeff * term.factor ** qr.quotient
        not zero?(qr.remainder) =>
          radi := concat_!(radi, term.factor ** qr.remainder)
      [n, coeff, radi]

    log ff ==
      ans := unit ff
      concat([1, unit ff],
             [[term.exponent::N, term.factor] for term in factors ff])

@
<<FACTFUNC.dotabb>>=
"FACTFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FACTFUNC"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"FACTFUNC" -> "ALGEBRA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FR2 FactoredFunctions2}
<<FactoredFunctions2.input>>=
-- fr.spad.pamphlet FactoredFunctions2.input
)sys rm FactoredFunctions2.output
)spool FactoredFunctions2.output
)set message test on
)set message auto off
)clear all
--S 1 of 6
double(x) == x + x
--R 
--R                                                                   Type: Void
--E 1

--S 2 of 6
f := factor(720) 
--R 
--R
--R         4 2
--R   (2)  2 3 5
--R                                                       Type: Factored Integer
--E 2

--S 3 of 6
map(double,f) 
--R 
--R   Compiling function double with type Integer -> Integer 
--R
--R           4 2
--R   (3)  2 4 6 10
--R                                                       Type: Factored Integer
--E 3

--S 4 of 6
makePoly(b) == x + b 
--R 
--R                                                                   Type: Void
--E 4

--S 5 of 6
g := map(makePoly,f) 
--R 
--R   Compiling function makePoly with type Integer -> Polynomial Integer 
--R
--R                      4       2
--R   (5)  (x + 1)(x + 2) (x + 3) (x + 5)
--R                                            Type: Factored Polynomial Integer
--E 5

--S 6 of 6
nthFlag(g,1) 
--R 
--R
--R   (6)  "nil"
--R                                                       Type: Union("nil",...)
--E 6
)spool
)lisp (bye)
@

<<FactoredFunctions2.help>>=
====================================================================
FactoredFunctions2 examples
====================================================================

The FactoredFunctions2 package implements one operation, map, for
applying an operation to every base in a factored object and to the unit.

  double(x) == x + x
                         Type: Void

  f := factor(720) 
     4 2
    2 3 5
                         Type: Factored Integer

Actually, the map operation used in this example comes from Factored
itself, since double takes an integer argument and returns an integer
result.

  map(double,f) 
       4 2
    2 4 6 10
                         Type: Factored Integer

If we want to use an operation that returns an object that has a type
different from the operation's argument, the map in Factored cannot be
used and we use the one in FactoredFunctions2.

  makePoly(b) == x + b 
                  4       2
    (x + 1)(x + 2) (x + 3) (x + 5)
                         Type: Factored Polynomial Integer

In fact, the "2" in the name of the package means that we might
be using factored objects of two different types.

  g := map(makePoly,f) 

It is important to note that both versions of map destroy any information 
known about the bases (the fact that they are prime, for instance).

The flags for each base are set to "nil" in the object returned by map.

  nthFlag(g,1) 
    "nil"
                        Type: Union("nil",...)

See Also:
o )help Factored
o )show FactoredFunctions2
o $AXIOM/doc/src/algebra/fr.spad.dvi

@
\pagehead{FactoredFunctions2}{FR2}
\pagepic{ps/v104FactoredFunctions2.ps}{FR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FR2 FactoredFunctions2>>=
)abbrev package FR2 FactoredFunctions2
++ Author: Robert S. Sutor
++ Date Created: 1987
++ Change History:
++ Basic Operations: map
++ Related Constructors: Factored
++ Also See:
++ AMS Classifications: 11A51, 11Y05
++ Keywords: map, factor
++ References:
++ Description:
++   \spadtype{FactoredFunctions2} contains functions that involve
++   factored objects whose underlying domains may not be the same.
++   For example, \spadfun{map} might be used to coerce an object of
++   type \spadtype{Factored(Integer)} to
++   \spadtype{Factored(Complex(Integer))}.
FactoredFunctions2(R, S): Exports == Implementation where
  R: IntegralDomain
  S: IntegralDomain

  Exports ==> with
    map: (R -> S, Factored R) -> Factored S
      ++ map(fn,u) is used to apply the function \userfun{fn} to every
      ++ factor of \spadvar{u}. The new factored object will have all its
      ++ information flags set to "nil". This function is used, for
      ++ example, to coerce every factor base to another type.

  Implementation ==> add
    map(func, f) ==
      func(unit f) *
             _*/[nilFactor(func(g.factor), g.exponent) for g in factors f]

@
<<FR2.dotabb>>=
"FR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FR2"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"FR2" -> "ALGEBRA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FRUTIL FactoredFunctionUtilities}
\pagehead{FactoredFunctionUtilities}{FRUTIL}
\pagepic{ps/v104factoredfunctionutilities.ps}{FRUTIL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FRUTIL FactoredFunctionUtilities>>=
)abbrev package FRUTIL FactoredFunctionUtilities
++ Author:
++ Date Created:
++ Change History:
++ Basic Operations: refine, mergeFactors
++ Related Constructors: Factored
++ Also See:
++ AMS Classifications: 11A51, 11Y05
++ Keywords: factor
++ References:
++ Description:
++   \spadtype{FactoredFunctionUtilities} implements some utility
++   functions for manipulating factored objects.
FactoredFunctionUtilities(R): Exports == Implementation where
  R: IntegralDomain
  FR ==> Factored R

  Exports ==> with
    refine: (FR, R-> FR) -> FR
      ++ refine(u,fn) is used to apply the function \userfun{fn} to
      ++ each factor of \spadvar{u} and then build a new factored
      ++ object from the results.  For example, if \spadvar{u} were
      ++ created by calling \spad{nilFactor(10,2)} then
      ++ \spad{refine(u,factor)} would create a factored object equal
      ++ to that created by \spad{factor(100)} or
      ++ \spad{primeFactor(2,2) * primeFactor(5,2)}.

    mergeFactors: (FR,FR) -> FR
      ++ mergeFactors(u,v) is used when the factorizations of \spadvar{u}
      ++ and \spadvar{v} are known to be disjoint, e.g. resulting from a
      ++ content/primitive part split. Essentially, it creates a new
      ++ factored object by multiplying the units together and appending
      ++ the lists of factors.

  Implementation ==> add
    fg: FR
    func: R -> FR
    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FF     ==> Record(flg: fUnion, fctr: R, xpnt: Integer)

    mergeFactors(f,g) ==
      makeFR(unit(f)*unit(g),append(factorList f,factorList g))

    refine(f, func) ==
       u := unit(f)
       l: List FF := empty()
       for item in factorList f repeat
         fitem := func item.fctr
         u := u*unit(fitem) ** (item.xpnt :: NonNegativeInteger)
         if item.xpnt = 1 then
            l := concat(factorList fitem,l)
         else l := concat([[v.flg,v.fctr,v.xpnt*item.xpnt]
                          for v in factorList fitem],l)
       makeFR(u,l)

@
<<FRUTIL.dotabb>>=
"FRUTIL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FRUTIL"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"FRUTIL" -> "ALGEBRA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FACUTIL FactoringUtilities}
\pagehead{FactoringUtilities}{FACUTIL}
\pagepic{ps/v104factoringutilities.ps}{FACUTIL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FACUTIL FactoringUtilities>>=
)abbrev package FACUTIL FactoringUtilities
++ Author: Barry Trager
++ Date Created: March 12, 1992
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides utilities used by the factorizers
++ which operate on polynomials represented as univariate polynomials
++ with multivariate coefficients.

FactoringUtilities(E,OV,R,P) : C == T where
   E : OrderedAbelianMonoidSup
   OV : OrderedSet
   R : Ring
   P : PolynomialCategory(R,E,OV)

   SUP ==> SparseUnivariatePolynomial
   NNI ==> NonNegativeInteger
   Z   ==> Integer

   C == with
        completeEval   :      (SUP P,List OV,List R)        -> SUP R
          ++ completeEval(upoly, lvar, lval) evaluates the polynomial upoly
          ++ with each variable in lvar replaced by the corresponding value
          ++ in lval. Substitutions are done for all variables in upoly
          ++ producing a univariate polynomial over R.
        degree         :       (SUP P,List OV)              -> List NNI
          ++ degree(upoly, lvar) returns a list containing the maximum
          ++ degree for each variable in lvar.
        variables      :           SUP P                    -> List OV
          ++ variables(upoly) returns the list of variables for the coefficients
          ++ of upoly.
        lowerPolynomial:           SUP P                    -> SUP R
          ++ lowerPolynomial(upoly) converts upoly to be a univariate polynomial
          ++ over R. An error if the coefficients contain variables.
        raisePolynomial:           SUP R                    -> SUP P
          ++ raisePolynomial(rpoly) converts rpoly from a univariate polynomial
          ++ over r to be a univariate polynomial with polynomial coefficients.
        normalDeriv     :        (SUP P,Z)                  -> SUP P
          ++ normalDeriv(poly,i) computes the ith derivative of poly divided
          ++ by i!.
        ran        :                Z                       -> R
          ++ ran(k) computes a random integer between -k and k as a member of R.

   T == add

     lowerPolynomial(f:SUP P) : SUP R ==
       zero? f => 0$SUP(R)
       monomial(ground leadingCoefficient f, degree f)$SUP(R) +
           lowerPolynomial(reductum f)

     raisePolynomial(u:SUP R) : SUP P ==
       zero? u => 0$SUP(P)
       monomial(leadingCoefficient(u)::P, degree u)$SUP(P) +
           raisePolynomial(reductum u)

     completeEval(f:SUP P,lvar:List OV,lval:List R) : SUP R ==
       zero? f => 0$SUP(R)
       monomial(ground eval(leadingCoefficient f,lvar,lval),degree f)$SUP(R) +
              completeEval(reductum f,lvar,lval)

     degree(f:SUP P,lvar:List OV) : List NNI ==
       coefs := coefficients f
       ldeg:= ["max"/[degree(fc,xx) for fc in coefs] for xx in lvar]

     variables(f:SUP P) : List OV ==
       "setUnion"/[variables cf for cf in coefficients f]

     if R has FiniteFieldCategory then
        ran(k:Z):R == random()$R
     else
	ran(k:Z):R == (random(2*k+1)$Z -k)::R

  -- Compute the normalized m derivative
     normalDeriv(f:SUP P,m:Z) : SUP P==
       (n1:Z:=degree f) < m => 0$SUP(P)
       n1=m => (leadingCoefficient f)::SUP(P)
       k:=binomial(n1,m)
       ris:SUP:=0$SUP(P)
       n:Z:=n1
       while n>= m repeat
         while n1>n repeat
           k:=(k*(n1-m)) quo n1
           n1:=n1-1
         ris:=ris+monomial(k*leadingCoefficient f,(n-m)::NNI)
         f:=reductum f
         n:=degree f
       ris

@
<<FACUTIL.dotabb>>=
"FACUTIL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FACUTIL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FACUTIL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FAMR2 FiniteAbelianMonoidRingFunctions2}
\pagehead{FiniteAbelianMonoidRingFunctions2}{FAMR2}
\pagepic{ps/v104finiteabelianmonoidringfunctions2.ps}{FAMR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FAMR2 FiniteAbelianMonoidRingFunctions2>>=
)abbrev package FAMR2 FiniteAbelianMonoidRingFunctions2
++ Author: Martin Rubey
++ Description:
++ This package provides a mapping function for 
++ \spadtype{FiniteAbelianMonoidRing}
++ The packages defined in this file provide fast fraction free rational
++ interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)
FiniteAbelianMonoidRingFunctions2(E: OrderedAbelianMonoid, 
                                  R1: Ring,
                                  A1: FiniteAbelianMonoidRing(R1, E),
                                  R2: Ring,
                                  A2: FiniteAbelianMonoidRing(R2, E)) _
                                 : Exports == Implementation where
  Exports == with

    map: (R1 -> R2, A1) -> A2
      ++ \spad{map}(f, a) applies the map f to each coefficient in a. It is
      ++ assumed that f maps 0 to 0

  Implementation == add

    map(f: R1 -> R2, a: A1): A2 ==
      if zero? a then 0$A2
      else
        monomial(f leadingCoefficient a, degree a)$A2 + map(f, reductum a)

@
<<FAMR2.dotabb>>=
"FAMR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FAMR2"]
"FAMR" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FAMR"]
"FAMR2" -> "FAMR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FDIV2 FiniteDivisorFunctions2}
\pagehead{FiniteDivisorFunctions2}{FDIV2}
\pagepic{ps/v104finitedivisorfunctions2.ps}{FDIV2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FDIV2 FiniteDivisorFunctions2>>=
)abbrev package FDIV2 FiniteDivisorFunctions2
++ Lift a map to finite divisors.
++ Author: Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 19 May 1993
FiniteDivisorFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 Exports == Implementation where
  R1   : Field
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  F1   : FunctionFieldCategory(R1, UP1, UPUP1)
  R2   : Field
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2
  F2   : FunctionFieldCategory(R2, UP2, UPUP2)

  Exports ==> with
    map: (R1 -> R2, FiniteDivisor(R1, UP1, UPUP1, F1)) ->
                                       FiniteDivisor(R2, UP2, UPUP2, F2)
	++ map(f,d) \undocumented{} 

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R1,UP1,R2,UP2)
    import FunctionFieldCategoryFunctions2(R1,UP1,UPUP1,F1,R2,UP2,UPUP2,F2)
    import FractionalIdealFunctions2(UP1, Fraction UP1, UPUP1, F1,
                                     UP2, Fraction UP2, UPUP2, F2)

    map(f, d) ==
      rec := decompose d
      divisor map(f, rec.principalPart) + divisor map(map(f, #1), rec.id)

@
<<FDIV2.dotabb>>=
"FDIV2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FDIV2"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"FDIV2" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFF FiniteFieldFunctions}
\pagehead{FiniteFieldFunctions}{FFF}
\pagepic{ps/v104finitefieldfunctions.ps}{FFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFF FiniteFieldFunctions>>=
)abbrev package FFF FiniteFieldFunctions
++ Author: J. Grabmeier, A. Scheerhorn
++ Date Created: 21 March 1991
++ Date Last Updated: 31 March 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ References:
++  Lidl, R. & Niederreiter, H., "Finite Fields",
++   Encycl. of Math. 20, Addison-Wesley, 1983
++  J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
++   AXIOM Technical Report Series, ATR/5 NP2522.
++ Description:
++  FiniteFieldFunctions(GF) is a package with functions
++  concerning finite extension fields of the finite ground field {\em GF},
++  e.g. Zech logarithms.
++ Keywords: finite field, Zech logarithm, Jacobi logarithm, normal basis

FiniteFieldFunctions(GF): Exports == Implementation where
  GF  : FiniteFieldCategory  -- the ground field

  PI   ==> PositiveInteger
  NNI  ==> NonNegativeInteger
  I    ==> Integer
  SI   ==> SingleInteger
  SUP  ==> SparseUnivariatePolynomial GF
  V    ==> Vector
  M    ==> Matrix
  L    ==> List
  OUT  ==> OutputForm
  SAE  ==> SimpleAlgebraicExtension
  ARR  ==> PrimitiveArray(SI)
  TERM ==> Record(value:GF,index:SI)
  MM   ==> ModMonic(GF,SUP)
  PF   ==> PrimeField

  Exports ==> with

      createZechTable: SUP -> ARR
        ++ createZechTable(f) generates a Zech logarithm table for the cyclic
        ++ group representation of a extension of the ground field by the
        ++ primitive polynomial {\em f(x)}, i.e. \spad{Z(i)},
        ++ defined by {\em x**Z(i) = 1+x**i} is stored at index i.
        ++ This is needed in particular
        ++ to perform addition of field elements in finite fields represented
        ++ in this way. See \spadtype{FFCGP}, \spadtype{FFCGX}.
      createMultiplicationTable: SUP -> V L TERM
        ++ createMultiplicationTable(f) generates a multiplication
        ++ table for the normal basis of the field extension determined
        ++ by {\em f}. This is needed to perform multiplications
        ++ between elements represented as coordinate vectors to this basis.
        ++ See \spadtype{FFNBP}, \spadtype{FFNBX}.
      createMultiplicationMatrix: V L TERM -> M GF
        ++ createMultiplicationMatrix(m) forms the multiplication table
        ++ {\em m} into a matrix over the ground field.
        -- only useful for the user to visualise the multiplication table
        -- in a nice form
      sizeMultiplication: V L TERM -> NNI
        ++ sizeMultiplication(m) returns the number of entries
        ++ of the multiplication table {\em m}.
        -- the time of the multiplication of field elements depends
        -- on this size
      createLowComplexityTable: PI -> Union(Vector List TERM,"failed")
        ++ createLowComplexityTable(n) tries to find
        ++ a low complexity normal basis of degree {\em n} over {\em GF}
        ++ and returns its multiplication matrix
        ++ Fails, if it does not find a low complexity basis
      createLowComplexityNormalBasis: PI -> Union(SUP, V L TERM)
        ++ createLowComplexityNormalBasis(n) tries to find a
        ++ a low complexity normal basis of degree {\em n} over {\em GF}
        ++ and returns its multiplication matrix
        ++ If no low complexity basis is found it calls
        ++ \axiomFunFrom{createNormalPoly}{FiniteFieldPolynomialPackage}(n) 
        ++ to produce a normal
        ++ polynomial of degree {\em n} over {\em GF}

  Implementation ==> add


    createLowComplexityNormalBasis(n) ==
      (u:=createLowComplexityTable(n)) case "failed" =>
        createNormalPoly(n)$FiniteFieldPolynomialPackage(GF)
      u::(V L TERM)

-- try to find a low complexity normal basis multiplication table
-- of the field of extension degree n
-- the algorithm is from:
-- Wassermann A., Konstruktion von Normalbasen,
-- Bayreuther Mathematische Schriften 31 (1989),1-9.

    createLowComplexityTable(n) ==
      q:=size()$GF
      -- this algorithm works only for prime fields
      p:=characteristic()$GF
      -- search of a suitable parameter k
      k:NNI:=0
      for i in 1..n-1  while (k=0) repeat
        if prime?(i*n+1) and not(p = (i*n+1)) then
          primitive?(q::PF(i*n+1))$PF(i*n+1) =>
              a:NNI:=1
              k:=i
              t1:PF(k*n+1):=(q::PF(k*n+1))**n
          gcd(n,a:=discreteLog(q::PF(n*i+1))$PF(n*i+1))$I = 1 =>
              k:=i
              t1:=primitiveElement()$PF(k*n+1)**n
      k = 0 => "failed"
      -- initialize some start values
      multmat:M PF(p):=zero(n,n)
      p1:=(k*n+1)
      pkn:=q::PF(p1)
      t:=t1 pretend PF(p1)
      if odd?(k) then
          jt:I:=(n quo 2)+1
          vt:I:=positiveRemainder((k-a) quo 2,k)+1
        else
          jt:I:=1
          vt:I:=(k quo 2)+1
      -- compute matrix
      vec:Vector I:=zero(p1 pretend NNI)
      for x in 1..k repeat
        for l in 1..n repeat
          vec.((t**(x-1) * pkn**(l-1)) pretend Integer+1):=_
                                            positiveRemainder(l,p1)
      lvj:M I:=zero(k::NNI,n)
      for v in 1..k repeat
        for j in 1..n repeat
          if (j^=jt) or (v^=vt) then
            help:PF(p1):=t**(v-1)*pkn**(j-1)+1@PF(p1)
            setelt(lvj,v,j,vec.(help pretend I +1))
      for j in 1..n repeat
        if j^=jt then
          for v in 1..k repeat
            lvjh:=elt(lvj,v,j)
            setelt(multmat,j,lvjh,elt(multmat,j,lvjh)+1)
      for i in 1..n repeat
        setelt(multmat,jt,i,positiveRemainder(-k,p)::PF(p))
      for v in 1..k repeat
        if v^=vt then
          lvjh:=elt(lvj,v,jt)
          setelt(multmat,jt,lvjh,elt(multmat,jt,lvjh)+1)
      -- multmat
      m:=nrows(multmat)$(M PF(p))
      multtable:V L TERM:=new(m,nil()$(L TERM))$(V L TERM)
      for i in 1..m repeat
        l:L TERM:=nil()$(L TERM)
        v:V PF(p):=row(multmat,i)
        for j in (1::I)..(m::I) repeat
          if (v.j ^= 0) then
            -- take -v.j to get trace 1 instead of -1
            term:TERM:=[(convert(-v.j)@I)::GF,(j-2) pretend SI]$TERM
            l:=cons(term,l)$(L TERM)
        qsetelt_!(multtable,i,copy l)$(V L TERM)
      multtable

    sizeMultiplication(m) ==
      s:NNI:=0
      for i in 1..#m repeat
        s := s + #(m.i)
      s

    createMultiplicationTable(f:SUP) ==
      sizeGF:NNI:=size()$GF -- the size of the ground field
      m:PI:=degree(f)$SUP pretend PI
      m=1 =>
        [[[-coefficient(f,0)$SUP,(-1)::SI]$TERM]$(L TERM)]::(V L TERM)
      m1:I:=m-1
      -- initialize basis change matrices
      setPoly(f)$MM
      e:=reduce(monomial(1,1)$SUP)$MM ** sizeGF
      w:=1$MM
      qpow:PrimitiveArray(MM):=new(m,0)
      qpow.0:=1$MM
      for i in 1..m1 repeat
        qpow.i:=(w:=w*e)
      -- qpow.i = x**(i*q)
      qexp:PrimitiveArray(MM):=new(m,0)
      qexp.0:=reduce(monomial(1,1)$SUP)$MM
      mat:M GF:=zero(m,m)$(M GF)
      qsetelt_!(mat,2,1,1$GF)$(M GF)
      h:=qpow.1
      qexp.1:=h
      setColumn_!(mat,2,Vectorise(h)$MM)$(M GF)
      for i in 2..m1 repeat
        g:=0$MM
        while h ^= 0 repeat
          g:=g + leadingCoefficient(h) * qpow.degree(h)$MM
          h:=reductum(h)$MM
        qexp.i:=g
        setColumn_!(mat,i+1,Vectorise(h:=g)$MM)$(M GF)
      -- loop invariant: qexp.i = x**(q**i)
      mat1:=inverse(mat)$(M GF)
      mat1 = "failed" =>
        error "createMultiplicationTable: polynomial must be normal"
      mat:=mat1 :: (M GF)
      -- initialize multiplication table
      multtable:V L TERM:=new(m,nil()$(L TERM))$(V L TERM)
      for i in 1..m repeat
        l:L TERM:=nil()$(L TERM)
        v:V GF:=mat *$(M GF) Vectorise(qexp.(i-1) *$MM qexp.0)$MM
        for j in (1::SI)..(m::SI) repeat
          if (v.j ^= 0$GF) then
            term:TERM:=[(v.j),j-(2::SI)]$TERM
            l:=cons(term,l)$(L TERM)
        qsetelt_!(multtable,i,copy l)$(V L TERM)
      multtable


    createZechTable(f:SUP) ==
      sizeGF:NNI:=size()$GF -- the size of the ground field
      m:=degree(f)$SUP::PI
      qm1:SI:=(sizeGF ** m -1) pretend SI
      zechlog:ARR:=new(((sizeGF ** m + 1) quo 2)::NNI,-1::SI)$ARR
      helparr:ARR:=new(sizeGF ** m::NNI,0$SI)$ARR
      primElement:=reduce(monomial(1,1)$SUP)$SAE(GF,SUP,f)
      a:=primElement
      for i in 1..qm1-1 repeat
        helparr.(lookup(a -$SAE(GF,SUP,f) 1$SAE(GF,SUP,f)_
           )$SAE(GF,SUP,f)):=i::SI
        a:=a * primElement
      characteristic() = 2 =>
        a:=primElement
        for i in 1..(qm1 quo 2) repeat
          zechlog.i:=helparr.lookup(a)$SAE(GF,SUP,f)
          a:=a * primElement
        zechlog
      a:=1$SAE(GF,SUP,f)
      for i in 0..((qm1-2) quo 2) repeat
        zechlog.i:=helparr.lookup(a)$SAE(GF,SUP,f)
        a:=a * primElement
      zechlog

    createMultiplicationMatrix(m) ==
      n:NNI:=#m
      mat:M GF:=zero(n,n)$(M GF)
      for i in 1..n repeat
        for t in m.i repeat
          qsetelt_!(mat,i,t.index+2,t.value)
      mat

@
<<FFF.dotabb>>=
"FFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FFF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFHOM FiniteFieldHomomorphisms}
\pagehead{FiniteFieldHomomorphisms}{FFHOM}
\pagepic{ps/v104finitefieldhomomorphisms.ps}{FFHOM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFHOM FiniteFieldHomomorphisms>>=
)abbrev package FFHOM FiniteFieldHomomorphisms
++ Authors: J.Grabmeier, A.Scheerhorn
++ Date Created: 26.03.1991
++ Date Last Updated:
++ Basic Operations:
++ Related Constructors: FiniteFieldCategory, FiniteAlgebraicExtensionField
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, homomorphism, isomorphism
++ References:
++  R.Lidl, H.Niederreiter: Finite Field, Encycoldia of Mathematics and
++  Its Applications, Vol. 20, Cambridge Univ. Press, 1983, ISBN 0 521 30240 4
++  J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
++  AXIOM Technical Report Series, ATR/5 NP2522.
++ Description:
++  FiniteFieldHomomorphisms(F1,GF,F2) exports coercion functions of
++  elements between the fields {\em F1} and {\em F2}, which both must be
++  finite simple algebraic extensions of the finite ground field {\em GF}.
FiniteFieldHomomorphisms(F1,GF,F2): Exports == Implementation where
  F1: FiniteAlgebraicExtensionField(GF)
  GF: FiniteFieldCategory
  F2: FiniteAlgebraicExtensionField(GF)
 -- the homorphism can only convert elements w.r.t. the last extension .
  -- Adding a function 'groundField()' which returns the groundfield of GF
  -- as a variable of type FiniteFieldCategory in the new compiler, one
  -- could build up 'convert' recursively to get an homomorphism w.r.t
  -- the whole extension.
 
  I   ==> Integer
  NNI ==> NonNegativeInteger
  SI  ==> SingleInteger
  PI  ==> PositiveInteger
  SUP ==> SparseUnivariatePolynomial
  M   ==> Matrix GF
  FFP ==> FiniteFieldExtensionByPolynomial
  FFPOL2 ==> FiniteFieldPolynomialPackage2
  FFPOLY ==> FiniteFieldPolynomialPackage
  OUT ==> OutputForm
 
  Exports ==> with
 
    coerce: F1  ->  F2
      ++ coerce(x) is the homomorphic image of x from
      ++ {\em F1} in {\em F2}. Thus {\em coerce} is a
      ++ field homomorphism between the fields extensions
      ++ {\em F1} and {\em F2} both over ground field {\em GF} 
      ++ (the second argument to the package).
      ++ Error: if the extension degree of {\em F1} doesn't divide
      ++ the extension degree of {\em F2}.
      ++ Note that the other coercion function in the 
      ++ \spadtype{FiniteFieldHomomorphisms} is a left inverse.
 
    coerce: F2  ->  F1
      ++ coerce(x) is the homomorphic image of x from
      ++ {\em F2} in {\em F1}, where {\em coerce} is a
      ++ field homomorphism between the fields extensions
      ++ {\em F2} and {\em F1} both over ground field {\em GF}
      ++ (the second argument to the package).
      ++ Error: if the extension degree of {\em F2} doesn't divide
      ++ the extension degree of {\em F1}.
      ++ Note that the other coercion function in the 
      ++ \spadtype{FiniteFieldHomomorphisms} is a left inverse.
    -- coerce(coerce(x:F1)@F2)@F1 = x and coerce(coerce(y:F2)@F1)@F2 = y
 
  Implementation ==> add
 
-- global variables ===================================================
 
    degree1:NNI:= extensionDegree()$F1
    degree2:NNI:= extensionDegree()$F2
    -- the degrees of the last extension
 
    -- a necessary condition for the one field being an subfield of
    -- the other one is, that the respective extension degrees are
    -- multiples
    if max(degree1,degree2) rem min(degree1,degree2) ^= 0 then
      error "FFHOM: one extension degree must divide the other one"
 
    conMat1to2:M:= zero(degree2,degree1)$M
    -- conversion Matix for the conversion direction F1 -> F2
    conMat2to1:M:= zero(degree1,degree2)$M
    -- conversion Matix for the conversion direction F2 -> F1
 
    repType1:=representationType()$F1
    repType2:=representationType()$F2
    -- the representation types of the fields
 
    init?:Boolean:=true
    -- gets false after initialization
 
    defPol1:=definingPolynomial()$F1
    defPol2:=definingPolynomial()$F2
    -- the defining polynomials of the fields
 
 
-- functions ==========================================================
 
 
    compare: (SUP GF,SUP GF) -> Boolean
    -- compares two polynomials
 
    convertWRTsameDefPol12: F1  ->  F2
    convertWRTsameDefPol21: F2  ->  F1
    -- homomorphism if the last extension of F1 and F2 was build up
    -- using the same defining polynomials
 
    convertWRTdifferentDefPol12: F1  ->  F2
    convertWRTdifferentDefPol21: F2  ->  F1
    -- homomorphism if the last extension of F1 and F2 was build up
    -- with different defining polynomials
 
    initialize: () -> Void
    -- computes the conversion matrices
 
    compare(g:(SUP GF),f:(SUP GF)) ==
      degree(f)$(SUP GF)  >$NNI degree(g)$(SUP GF) => true
      degree(f)$(SUP GF) <$NNI degree(g)$(SUP GF) => false
      equal:Integer:=0
      for i in degree(f)$(SUP GF)..0 by -1 while equal=0 repeat
        not zero?(coefficient(f,i)$(SUP GF))$GF and _
             zero?(coefficient(g,i)$(SUP GF))$GF => equal:=1
        not zero?(coefficient(g,i)$(SUP GF))$GF and _
             zero?(coefficient(f,i)$(SUP GF))$GF => equal:=(-1)
        (f1:=lookup(coefficient(f,i)$(SUP GF))$GF) >$PositiveInteger _
         (g1:=lookup(coefficient(g,i)$(SUP GF))$GF) =>  equal:=1
        f1 <$PositiveInteger g1 => equal:=(-1)
      equal=1 => true
      false
 
    initialize() ==
      -- 1) in the case of equal def. polynomials initialize is called only
      --  if one of the rep. types is "normal" and the other one is "polynomial"
      --  we have to compute the basis change matrix 'mat', which i-th
      --  column are the coordinates of a**(q**i), the i-th component of
      --  the normal basis ('a' the root of the def. polynomial and q the
      --  size of the groundfield)
      defPol1 =$(SUP GF) defPol2 =>
        -- new code using reducedQPowers
        mat:=zero(degree1,degree1)$M
        arr:=reducedQPowers(defPol1)$FFPOLY(GF)
        for i in 1..degree1 repeat
          setColumn_!(mat,i,vectorise(arr.(i-1),degree1)$SUP(GF))$M
          -- old code
          -- here one of the representation types must be "normal"
          --a:=basis()$FFP(GF,defPol1).2  -- the root of the def. polynomial
          --setColumn_!(mat,1,coordinates(a)$FFP(GF,defPol1))$M
          --for i in 2..degree1 repeat
          --  a:= a **$FFP(GF,defPol1) size()$GF
          --  setColumn_!(mat,i,coordinates(a)$FFP(GF,defPol1))$M
          --for the direction "normal" -> "polynomial" we have to multiply the
          -- coordinate vector of an element of the normal basis field with
          -- the matrix 'mat'. In this case 'mat' is the correct conversion
          -- matrix for the conversion of F1 to F2, its inverse the correct
          -- inversion matrix for the conversion of F2 to F1
        repType1 = "normal" =>  -- repType2 = "polynomial"
          conMat1to2:=copy(mat)
          conMat2to1:=copy(inverse(mat)$M :: M)
          --we finish the function for one case, hence reset initialization flag
          init? := false
          void()$Void
          -- print("'normal' <=> 'polynomial' matrices initialized"::OUT)
        -- in the other case we have to change the matrices
        -- repType2 = "normal" and repType1 = "polynomial"
        conMat2to1:=copy(mat)
        conMat1to2:=copy(inverse(mat)$M :: M)
        -- print("'normal' <=> 'polynomial' matrices initialized"::OUT)
        --we finish the function for one case, hence reset initialization flag
        init? := false
        void()$Void
      -- 2) in the case of different def. polynomials we have to order the
      --    fields to get the same isomorphism, if the package is called with
      --    the fields F1 and F2 swapped.
      dPbig:= defPol2
      rTbig:= repType2
      dPsmall:= defPol1
      rTsmall:= repType1
      degbig:=degree2
      degsmall:=degree1
      if compare(defPol2,defPol1) then
        degsmall:=degree2
        degbig:=degree1
        dPbig:= defPol1
        rTbig:= repType1
        dPsmall:= defPol2
        rTsmall:= repType2
      -- 3) in every case we need a conversion between the polynomial
      --  represented fields. Therefore we compute 'root' as a root of the
      --  'smaller' def. polynomial in the 'bigger' field.
      --  We compute the matrix 'matsb', which i-th column are the coordinates
      --  of the (i-1)-th power of root, i=1..degsmall. Multiplying a
      --  coordinate vector of an element of the 'smaller' field by this
      --  matrix, we got the coordinates of the corresponding element in the
      --  'bigger' field.
      -- compute the root of dPsmall in the 'big' field
      root:=rootOfIrreduciblePoly(dPsmall)$FFPOL2(FFP(GF,dPbig),GF)
      -- set up matrix for polynomial conversion
      matsb:=zero(degbig,degsmall)$M
      qsetelt_!(matsb,1,1,1$GF)$M
      a:=root
      for i in 2..degsmall repeat
        setColumn_!(matsb,i,coordinates(a)$FFP(GF,dPbig))$M
        a := a *$FFP(GF,dPbig) root
      --  the conversion from 'big' to 'small': we can't invert matsb
      --  directly, because it has degbig rows and degsmall columns and
      --  may be no square matrix. Therfore we construct a square matrix
      --  mat from degsmall linear independent rows of matsb and invert it.
      --  Now we get the conversion matrix 'matbs' for the conversion from
      --  'big' to 'small' by putting the columns of mat at the indices
      --  of the linear independent rows of matsb to columns of matbs.
      ra:I:=1   -- the rank
      mat:M:=transpose(row(matsb,1))$M -- has already rank 1
      rowind:I:=2
      iVec:Vector I:=new(degsmall,1$I)$(Vector I)
      while ra < degsmall repeat
        if rank(vertConcat(mat,transpose(row(matsb,rowind))$M)$M)$M > ra then
          mat:=vertConcat(mat,transpose(row(matsb,rowind))$M)$M
          ra:=ra+1
          iVec.ra := rowind
        rowind:=rowind + 1
      mat:=inverse(mat)$M :: M
      matbs:=zero(degsmall,degbig)$M
      for i in 1..degsmall repeat
        setColumn_!(matbs,iVec.i,column(mat,i)$M)$M
      -- print(matsb::OUT)
      -- print(matbs::OUT)
      -- 4) if the 'bigger' field is "normal" we have to compose the
      --  polynomial conversion with a conversion from polynomial to normal
      --  between the FFP(GF,dPbig) and FFNBP(GF,dPbig) the 'bigger'
      --  field. Therefore we compute a conversion matrix 'mat' as in 1)
      --  Multiplying with the inverse of 'mat' yields the desired
      --  conversion from polynomial to normal. Multiplying this matrix by
      --  the above computed 'matsb' we got the matrix for converting form
      --  'small polynomial' to 'big normal'.
      -- set up matrix 'mat' for polynomial to normal
      if rTbig = "normal" then
        arr:=reducedQPowers(dPbig)$FFPOLY(GF)
        mat:=zero(degbig,degbig)$M
        for i in 1..degbig repeat
          setColumn_!(mat,i,vectorise(arr.(i-1),degbig)$SUP(GF))$M
        -- old code
        --a:=basis()$FFP(GF,dPbig).2  -- the root of the def.Polynomial
        --setColumn_!(mat,1,coordinates(a)$FFP(GF,dPbig))$M
        --for i in 2..degbig repeat
        --  a:= a **$FFP(GF,dPbig) size()$GF
        --  setColumn_!(mat,i,coordinates(a)$FFP(GF,dPbig))$M
        -- print(inverse(mat)$M::OUT)
        matsb:= (inverse(mat)$M :: M) * matsb
        -- print("inv *.."::OUT)
        matbs:=matbs * mat
        -- 5) if the 'smaller' field is "normal" we have first to convert
        --    from 'small normal' to 'small polynomial', that is from
        --    FFNBP(GF,dPsmall) to FFP(GF,dPsmall). Therefore we compute a
        --    conversion matrix 'mat' as in 1). Multiplying with  'mat'
        --    yields the desired conversion from normal to polynomial.
        --    Multiplying the above computed 'matsb' with 'mat' we got the
        --    matrix for converting form 'small normal' to 'big normal'.
      -- set up matrix 'mat' for normal to polynomial
      if rTsmall = "normal" then
        arr:=reducedQPowers(dPsmall)$FFPOLY(GF)
        mat:=zero(degsmall,degsmall)$M
        for i in 1..degsmall repeat
          setColumn_!(mat,i,vectorise(arr.(i-1),degsmall)$SUP(GF))$M
      -- old code
      --b:FFP(GF,dPsmall):=basis()$FFP(GF,dPsmall).2
      --setColumn_!(mat,1,coordinates(b)$FFP(GF,dPsmall))$M
      --for i in 2..degsmall repeat
      --  b:= b **$FFP(GF,dPsmall) size()$GF
      --  setColumn_!(mat,i,coordinates(b)$FFP(GF,dPsmall))$M
        -- print(mat::OUT)
        matsb:= matsb * mat
        matbs:= (inverse(mat) :: M) * matbs
      -- now 'matsb' is the corret conversion matrix for 'small' to 'big'
      -- and 'matbs' the corret one for 'big' to 'small'.
      -- depending on the above ordering the conversion matrices are
      -- initialized
      dPbig =$(SUP GF) defPol2 =>
        conMat1to2 :=matsb
        conMat2to1 :=matbs
        -- print(conMat1to2::OUT)
        -- print(conMat2to1::OUT)
        -- print("conversion matrices initialized"::OUT)
        --we finish the function for one case, hence reset initialization flag
        init? := false
        void()$Void
      conMat1to2 :=matbs
      conMat2to1 :=matsb
      -- print(conMat1to2::OUT)
      -- print(conMat2to1::OUT)
      -- print("conversion matrices initialized"::OUT)
      --we finish the function for one case, hence reset initialization flag
      init? := false
      void()$Void
      
 
    coerce(x:F1) ==
      inGroundField?(x)$F1 => retract(x)$F1 :: F2
      -- if x is already in GF then we can use a simple coercion
      defPol1 =$(SUP GF) defPol2 => convertWRTsameDefPol12(x)
      convertWRTdifferentDefPol12(x)
 
    convertWRTsameDefPol12(x:F1)  ==
      repType1 = repType2 => x pretend F2
      -- same groundfields, same defining polynomials, same
      -- representation types --> F1 = F2, x is already in F2
      repType1 = "cyclic" =>
        x = 0$F1 => 0$F2
      -- the SI corresponding to the cyclic representation is the exponent of
      -- the primitiveElement, therefore we exponentiate the primitiveElement
      -- of F2 by it.
        primitiveElement()$F2 **$F2 (x pretend SI)
      repType2 = "cyclic" =>
        x = 0$F1 => 0$F2
      -- to get the exponent, we have to take the discrete logarithm of the
      -- element in the given field.
        (discreteLog(x)$F1 pretend SI) pretend F2
      -- here one of the representation types is "normal"
      if init? then initialize()
      -- here a conversion matrix is necessary, (see initialize())
      represents(conMat1to2 *$(Matrix GF) coordinates(x)$F1)$F2
 
    convertWRTdifferentDefPol12(x:F1) ==
      if init? then initialize()
      -- if we want to convert into a 'smaller' field, we have to test,
      -- whether the element is in the subfield of the 'bigger' field, which
      -- corresponds to the 'smaller' field
      if degree1 > degree2 then
        if positiveRemainder(degree2,degree(x)$F1)^= 0 then
          error "coerce: element doesn't belong to smaller field"
      represents(conMat1to2 *$(Matrix GF) coordinates(x)$F1)$F2
 
-- the three functions below equal the three functions above up to
-- '1' exchanged by '2' in all domain and variable names
 
 
    coerce(x:F2) ==
      inGroundField?(x)$F2 => retract(x)$F2 :: F1
      -- if x is already in GF then we can use a simple coercion
      defPol1 =$(SUP GF) defPol2 => convertWRTsameDefPol21(x)
      convertWRTdifferentDefPol21(x)
 
    convertWRTsameDefPol21(x:F2)  ==
      repType1 = repType2 => x pretend F1
      -- same groundfields, same defining polynomials,
      -- same representation types --> F1 = F2, that is:
      -- x is already in F1
      repType2 = "cyclic" =>
        x = 0$F2 => 0$F1
        primitiveElement()$F1 **$F1 (x pretend SI)
      repType1 = "cyclic" =>
        x = 0$F2 => 0$F1
        (discreteLog(x)$F2 pretend SI) pretend F1
      -- here one of the representation types is "normal"
      if init? then initialize()
      represents(conMat2to1 *$(Matrix GF) coordinates(x)$F2)$F1
 
    convertWRTdifferentDefPol21(x:F2) ==
      if init? then initialize()
      if degree2 > degree1 then
        if positiveRemainder(degree1,degree(x)$F2)^= 0 then
          error "coerce: element doesn't belong to smaller field"
      represents(conMat2to1 *$(Matrix GF) coordinates(x)$F2)$F1

@
<<FFHOM.dotabb>>=
"FFHOM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFHOM"]
"FAXF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FAXF"]
"FFHOM" -> "FAXF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFPOLY FiniteFieldPolynomialPackage}
\pagehead{FiniteFieldPolynomialPackage}{FFPOLY}
\pagepic{ps/v104finitefieldpolynomialpackage.ps}{FFPOLY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFPOLY FiniteFieldPolynomialPackage>>=
)abbrev package FFPOLY FiniteFieldPolynomialPackage
++ Author: A. Bouyer, J. Grabmeier, A. Scheerhorn, R. Sutor, B. Trager
++ Date Created: January 1991
++ Date Last Updated: 1 June 1994
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, polynomial, irreducible polynomial, normal
++   polynomial, primitive polynomial, random polynomials
++ References:
++   [LS] Lenstra, H. W. & Schoof, R. J., "Primitivive Normal Bases
++        for Finite Fields", Math. Comp. 48, 1987, pp. 217-231
++   [LN] Lidl, R. & Niederreiter, H., "Finite Fields",
++        Encycl. of Math. 20, Addison-Wesley, 1983
++  J. Grabmeier, A. Scheerhorn: Finite Fields in Axiom.
++   Axiom Technical Report Series, to appear.
++ Description:
++   This package provides a number of functions for generating, counting
++   and testing irreducible, normal, primitive, random polynomials
++   over finite fields.

FiniteFieldPolynomialPackage GF : Exports == Implementation where

  GF : FiniteFieldCategory

  I    ==> Integer
  L    ==> List
  NNI  ==> NonNegativeInteger
  PI   ==> PositiveInteger
  Rec  ==> Record(expnt:NNI, coeff:GF)
  Repr ==> L Rec
  SUP  ==> SparseUnivariatePolynomial GF

  Exports ==> with
 --    qEulerPhiCyclotomic : PI -> PI
--      ++ qEulerPhiCyclotomic(n)$FFPOLY(GF) yields the q-Euler's function
--      ++ of the n-th cyclotomic polynomial over the field {\em GF} of
--      ++ order q (cf. [LN] p.122);
--      ++ error if n is a multiple of the field characteristic.
    primitive? : SUP -> Boolean
      ++ primitive?(f) tests whether the polynomial f over a finite
      ++ field is primitive, i.e. all its roots are primitive.
    normal? : SUP -> Boolean
      ++ normal?(f) tests whether the polynomial f over a finite field is
      ++ normal, i.e. its roots are linearly independent over the field.
    numberOfIrreduciblePoly : PI -> PI
      ++ numberOfIrreduciblePoly(n)$FFPOLY(GF) yields the number of
      ++ monic irreducible univariate polynomials of degree n
      ++ over the finite field {\em GF}.
    numberOfPrimitivePoly : PI -> PI
      ++ numberOfPrimitivePoly(n)$FFPOLY(GF) yields the number of
      ++ primitive polynomials of degree n over the finite field {\em GF}.
    numberOfNormalPoly : PI -> PI
      ++ numberOfNormalPoly(n)$FFPOLY(GF) yields the number of
      ++ normal polynomials of degree n over the finite field {\em GF}.
    createIrreduciblePoly : PI -> SUP
      ++ createIrreduciblePoly(n)$FFPOLY(GF) generates a monic irreducible
      ++ univariate polynomial of degree n over the finite field {\em GF}.
    createPrimitivePoly : PI -> SUP
      ++ createPrimitivePoly(n)$FFPOLY(GF) generates a primitive polynomial
      ++ of degree n over the finite field {\em GF}.
    createNormalPoly : PI -> SUP
      ++ createNormalPoly(n)$FFPOLY(GF) generates a normal polynomial
      ++ of degree n over the finite field {\em GF}.
    createNormalPrimitivePoly : PI -> SUP
      ++ createNormalPrimitivePoly(n)$FFPOLY(GF) generates a normal and
      ++ primitive polynomial of degree n over the field {\em GF}.
      ++ Note: this function is equivalent to createPrimitiveNormalPoly(n)
    createPrimitiveNormalPoly : PI -> SUP
      ++ createPrimitiveNormalPoly(n)$FFPOLY(GF) generates a normal and
      ++ primitive polynomial of degree n over the field {\em GF}.
      ++ polynomial of degree n over the field {\em GF}.
    nextIrreduciblePoly : SUP -> Union(SUP, "failed")
      ++ nextIrreduciblePoly(f) yields the next monic irreducible polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ Also, \spad{f < g} if
      ++ the number of monomials of f is less
      ++ than this number for g.
      ++ If f and g have the same number of monomials,
      ++ the lists of exponents are compared lexicographically.
      ++ If these lists are also equal, the lists of coefficients
      ++ are compared according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
    nextPrimitivePoly : SUP -> Union(SUP, "failed")
      ++ nextPrimitivePoly(f) yields the next primitive polynomial over
      ++ a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ Also, \spad{f < g} if the {\em lookup} of the constant term
      ++ of f is less than
      ++ this number for g.
      ++ If these values are equal, then \spad{f < g} if
      ++ if the number of monomials of f is less than that for g or if
      ++ the lists of exponents of f are lexicographically less than the
      ++ corresponding list for g.
      ++ If these lists are also equal, the lists of coefficients are
      ++ compared according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
    nextNormalPoly : SUP -> Union(SUP, "failed")
      ++ nextNormalPoly(f) yields the next normal polynomial over
      ++ a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ Also, \spad{f < g} if the {\em lookup} of the coefficient
      ++ of the term of degree
      ++ {\em n-1} of f is less than that for g.
      ++ In case these numbers are equal, \spad{f < g} if
      ++ if the number of monomials of f is less that for g or if
      ++ the list of exponents of f are lexicographically less than the
      ++ corresponding list for g.
      ++ If these lists are also equal, the lists of coefficients are
      ++ compared according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
    nextNormalPrimitivePoly : SUP -> Union(SUP, "failed")
      ++ nextNormalPrimitivePoly(f) yields the next normal primitive polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ Also, \spad{f < g} if the {\em lookup} of the constant
      ++ term of f is less than
      ++ this number for g or if
      ++ {\em lookup} of the coefficient of the term of degree {\em n-1}
      ++ of f is less than this number for g.
      ++ Otherwise, \spad{f < g}
      ++ if the number of monomials of f is less than
      ++ that for g or if the lists of exponents for f are
      ++ lexicographically less than those for g.
      ++ If these lists are also equal, the lists of coefficients are
      ++ compared according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
      ++ This operation is equivalent to nextPrimitiveNormalPoly(f).
    nextPrimitiveNormalPoly : SUP -> Union(SUP, "failed")
      ++ nextPrimitiveNormalPoly(f) yields the next primitive normal polynomial
      ++ over a finite field {\em GF} of the same degree as f in the following
      ++ order, or "failed" if there are no greater ones.
      ++ Error: if f has degree 0.
      ++ Note: the input polynomial f is made monic.
      ++ Also, \spad{f < g} if the {\em lookup} of the
      ++ constant term of f is less than
      ++ this number for g or, in case these numbers are equal, if the
      ++ {\em lookup} of the coefficient of the term of degree {\em n-1}
      ++ of f is less than this number for g.
      ++ If these numbers are equals, \spad{f < g}
      ++ if the number of monomials of f is less than
      ++ that for g, or if the lists of exponents for f are lexicographically
      ++ less than those for g.
      ++ If these lists are also equal, the lists of coefficients are
      ++ coefficients according to the lexicographic ordering induced by
      ++ the ordering of the elements of {\em GF} given by {\em lookup}.
      ++ This operation is equivalent to nextNormalPrimitivePoly(f).
--    random : () -> SUP
--      ++ random()$FFPOLY(GF) generates a random monic polynomial
--      ++ of random degree over the field {\em GF}
    random : PI -> SUP
      ++ random(n)$FFPOLY(GF) generates a random monic polynomial
      ++ of degree n over the finite field {\em GF}.
    random : (PI, PI) -> SUP
      ++ random(m,n)$FFPOLY(GF) generates a random monic polynomial
      ++ of degree d over the finite field {\em GF}, d between m and n.
    leastAffineMultiple: SUP  -> SUP
      ++ leastAffineMultiple(f) computes the least affine polynomial which
      ++ is divisible by the polynomial f over the finite field {\em GF},
      ++ i.e. a polynomial whose exponents are 0 or a power of q, the
      ++ size of {\em GF}.
    reducedQPowers: SUP  -> PrimitiveArray SUP
      ++ reducedQPowers(f)
      ++ generates \spad{[x,x**q,x**(q**2),...,x**(q**(n-1))]}
      ++ reduced modulo f where \spad{q = size()$GF} and \spad{n = degree f}.
    --
    -- we intend to implement also the functions
    -- cyclotomicPoly: PI -> SUP, order: SUP -> PI,
    -- and maybe a new version of irreducible?


  Implementation ==> add

    import IntegerNumberTheoryFunctions
    import DistinctDegreeFactorize(GF, SUP)


    MM := ModMonic(GF, SUP)

    sizeGF : PI := size()$GF :: PI

    revListToSUP(l:Repr):SUP ==
        newl:Repr := empty()
        -- cannot use map since copy for Record is an XLAM
        for t in l repeat newl := cons(copy t, newl)
        newl pretend SUP

    listToSUP(l:Repr):SUP ==
        newl:Repr := [copy t for t in l]
        newl pretend SUP

    nextSubset : (L NNI, NNI) -> Union(L NNI, "failed")
      -- for a list s of length m with 1 <= s.1 < ... < s.m <= bound,
      -- nextSubset(s, bound) yields the immediate successor of s
      -- (resp. "failed" if s = [1,...,bound])
      -- where s < t if and only if:
      -- (i)  #s < #t; or
      -- (ii) #s = #t and s < t in the lexicographical order;
      -- (we have chosen to fix the signature with NNI instead of PI
      --  to avoid coercions in the main functions)

    reducedQPowers(f) ==
      m:PI:=degree(f)$SUP pretend PI
      m1:I:=m-1
      setPoly(f)$MM
      e:=reduce(monomial(1,1)$SUP)$MM ** sizeGF
      w:=1$MM
      qpow:PrimitiveArray SUP:=new(m,0)
      qpow.0:=1$SUP
      for i in 1..m1 repeat  qpow.i:=lift(w:=w*e)$MM
      qexp:PrimitiveArray SUP:=new(m,0)
      m = 1 =>
        qexp.(0$I):= (-coefficient(f,0$NNI)$SUP)::SUP
        qexp
      qexp.0$I:=monomial(1,1)$SUP
      h:=qpow.1
      qexp.1:=h
      for i in 2..m1 repeat
        g:=0$SUP
        while h ^= 0 repeat
          g:=g + leadingCoefficient(h) * qpow.degree(h)
          h:=reductum(h)
        qexp.i:=(h:=g)
      qexp

    leastAffineMultiple(f) ==
    -- [LS] p.112
      qexp:=reducedQPowers(f)
      n:=degree(f)$SUP
      b:Matrix GF:= transpose matrix [entries vectorise
           (qexp.i,n) for i in 0..n-1]
      col1:Matrix GF:= new(n,1,0)
      col1(1,1)  := 1
      ns : List Vector GF := nullSpace (horizConcat(col1,b) )
      ----------------------------------------------------------------
      -- perhaps one should use that the first vector in ns is already
      -- the right one
      ----------------------------------------------------------------
      dim:=n+2
      coeffVector : Vector GF
      until empty? ns repeat
        newCoeffVector := ns.1
        i : PI :=(n+1) pretend PI
        while newCoeffVector(i) = 0 repeat
          i := (i - 1) pretend PI
        if i < dim then
          dim := i
          coeffVector := newCoeffVector
        ns := rest ns
      (coeffVector(1)::SUP) +(+/[monomial(coeffVector.k, _
               sizeGF**((k-2)::NNI))$SUP for k in 2..dim])

--    qEulerPhiCyclotomic n ==
--      n = 1 => (sizeGF - 1) pretend PI
--      p : PI := characteristic()$GF :: PI
--      (n rem p) = 0 => error
--        "cyclotomic polynomial not defined for this argument value"
--      q  : PI := sizeGF
--      -- determine the multiplicative order of q modulo n
--      e  : PI := 1
--      qe : PI := q
--      while (qe rem n) ^= 1 repeat
--        e  := e + 1
--        qe := qe * q
--      ((qe - 1) ** ((eulerPhi(n) quo e) pretend PI) ) pretend PI

    numberOfIrreduciblePoly n ==
      -- we compute the number Nq(n) of monic irreducible polynomials
      -- of degree n over the field GF of order q by the formula
      -- Nq(n) = (1/n)* sum(moebiusMu(n/d)*q**d) where the sum extends
      -- over all divisors d of n (cf. [LN] p.93, Th. 3.25)
      n = 1 => sizeGF
      -- the contribution of d = 1 :
      lastd : PI  := 1
      qd    : PI  := sizeGF
      sum   :  I  := moebiusMu(n) * qd
      -- the divisors d > 1 of n :
      divisorsOfn : L PI := rest(divisors n) pretend L PI
      for d in divisorsOfn repeat
        qd := qd * (sizeGF) ** ((d - lastd) pretend PI)
        sum := sum + moebiusMu(n quo d) * qd
        lastd := d
      (sum quo n) :: PI

    numberOfPrimitivePoly n == (eulerPhi((sizeGF ** n) - 1) quo n) :: PI
      -- [each root of a primitive polynomial of degree n over a field
      --  with q elements is a generator of the multiplicative group
      --  of a field of order q**n (definition), and the number of such
      --  generators is precisely eulerPhi(q**n - 1)]

    numberOfNormalPoly n ==
      -- we compute the number Nq(n) of normal polynomials of degree n
      -- in GF[X], with GF of order q, by the formula
      -- Nq(n) = (1/n) * qPhi(X**n - 1) (cf. [LN] p.124) where,
      -- for any polynomial f in GF[X] of positive degree n,
      -- qPhi(f) = q**n * (1 - q**(-n1)) *...* (1 - q**(-nr)) =
      -- q**n * ((q**(n1)-1) / q**(n1)) *...* ((q**(nr)-1) / q**(n_r)),
      -- the ni being the degrees of the distinct irreducible factors
      -- of f in its canonical factorization over GF
      -- ([LN] p.122, Lemma 3.69).
      -- hence, if n = m * p**r where p is the characteristic of GF
      -- and gcd(m,p) = 1, we get
      -- Nq(n) = (1/n)* q**(n-m) * qPhi(X**m - 1)
      -- now X**m - 1 is the product of the (pairwise relatively prime)
      -- cyclotomic polynomials Qd(X) for which d divides m
      -- ([LN] p.64, Th. 2.45), and each Qd(X) factors into
      -- eulerPhi(d)/e (distinct) monic irreducible polynomials in GF[X]
      -- of the same degree e, where e is the least positive integer k
      -- such that d divides q**k - 1 ([LN] p.65, Th. 2.47)
      n = 1 => (sizeGF - 1) :: NNI :: PI
      m : PI := n
      p : PI := characteristic()$GF :: PI
      q : PI := sizeGF
      while (m rem p) = 0 repeat   -- find m such that
        m := (m quo p) :: PI       -- n = m * p**r and gcd(m,p) = 1
      m = 1 =>
         -- know that n is a power of p
        (((q ** ((n-1)::NNI) )  * (q - 1) ) quo n) :: PI
      prod : I := q - 1
      divisorsOfm : L PI := rest(divisors m) pretend L PI
      for d in divisorsOfm repeat
        -- determine the multiplicative order of q modulo d
        e  : PI := 1
        qe : PI := q
        while (qe rem d) ^= 1 repeat
          e  := e + 1
          qe := qe * q
        prod := prod * _
          ((qe - 1) ** ((eulerPhi(d) quo e) pretend PI) ) pretend PI
      (q**((n-m) pretend PI) * prod quo n) pretend PI

    primitive? f ==
      -- let GF be a field of order q; a monic polynomial f in GF[X]
      -- of degree n is primitive over GF if and only if its constant
      -- term is non-zero, f divides X**(q**n - 1) - 1 and,
      -- for each prime divisor d of q**n - 1,
      -- f does not divide X**((q**n - 1) / d) - 1
      -- (cf. [LN] p.89, Th. 3.16, and p.87, following Th. 3.11)
      n : NNI := degree f
      n = 0 => false
      leadingCoefficient f ^= 1 => false
      coefficient(f, 0) = 0 => false
      q  : PI := sizeGF
      qn1: PI := (q**n - 1) :: NNI :: PI
      setPoly f
      x := reduce(monomial(1,1)$SUP)$MM -- X rem f represented in MM
      --
      -- may be improved by tabulating the residues x**(i*q)
      -- for i = 0,...,n-1 :
      --
      lift(x ** qn1)$MM ^= 1 => false -- X**(q**n - 1) rem f in GF[X]
      lrec  : L Record(factor:I, exponent:I) := factors(factor qn1)
      lfact : L PI := []              -- collect the prime factors
      for rec in lrec repeat          -- of q**n - 1
        lfact := cons((rec.factor) :: PI, lfact)
      for d in lfact repeat
        if (expt := (qn1 quo d)) >= n then
          lift(x ** expt)$MM = 1 => return false
      true

    normal? f ==
      -- let GF be a field with q elements; a monic irreducible
      -- polynomial f in GF[X] of degree n is normal if its roots
      -- x, x**q, ... , x**(q**(n-1)) are linearly independent over GF
      n : NNI := degree f
      n = 0 => false
      leadingCoefficient f ^= 1 => false
      coefficient(f, 0) = 0 => false
      n = 1 => true
      not irreducible? f => false
      g:=reducedQPowers(f)
      l:=[entries vectorise(g.i,n)$SUP for i in 0..(n-1)::NNI]
      rank(matrix(l)$Matrix(GF)) = n => true
      false

    nextSubset(s, bound) ==
      m : NNI := #(s)
      m = 0 => [1]
      -- find the first element s(i) of s such that s(i) + 1 < s(i+1) :
      noGap : Boolean := true
      i : NNI := 0
      restOfs : L NNI
      while noGap and not empty?(restOfs := rest s) repeat
      -- after i steps (0 <= i <= m-1) we have s = [s(i), ... , s(m)]
      -- and restOfs = [s(i+1), ... , s(m)]
        secondOfs := first restOfs    -- s(i+1)
        firstOfsPlus1 := first s + 1  -- s(i) + 1
        secondOfs = firstOfsPlus1 =>
          s := restOfs
          i := i + 1
        setfirst_!(s, firstOfsPlus1)  -- s := [s(i)+1, s(i+1),..., s(m)]
        noGap := false
      if noGap then                   -- here s = [s(m)]
        firstOfs := first s
        firstOfs < bound => setfirst_!(s, firstOfs + 1) -- s := [s(m)+1]
        m < bound =>
            setfirst_!(s, m + 1)      -- s := [m+1]
            i := m
        return "failed"               -- (here m = s(m) = bound)
      for j in i..1 by -1 repeat  -- reconstruct the destroyed
        s := cons(j, s)           -- initial part of s
      s

    nextIrreduciblePoly f ==
      n : NNI := degree f
      n = 0 => error "polynomial must have positive degree"
      -- make f monic
      if (lcf := leadingCoefficient f) ^= 1 then f := (inv lcf) * f
      -- if f = fn*X**n + ... + f{i0}*X**{i0} with the fi non-zero
      -- then fRepr := [[n,fn], ... , [i0,f{i0}]]
      fRepr : Repr := f pretend Repr
      fcopy : Repr := []
      -- we can not simply write fcopy := copy fRepr because
      -- the input(!) f would be modified by assigning
      -- a new value to one of its records
      for term in fRepr repeat
        fcopy := cons(copy term, fcopy)
      if term.expnt ^= 0 then
        fcopy := cons([0,0]$Rec, fcopy)
      tailpol : Repr := []
      headpol : Repr := fcopy  -- [[0,f0], ... , [n,fn]] where
                               -- fi is non-zero for i > 0
      fcopy   := reverse fcopy
      weight  : NNI := (#(fcopy) - 1) :: NNI -- #s(f) as explained above
      taillookuplist : L NNI := []
      -- the zeroes in the headlookuplist stand for the fi
      -- whose lookup's were not yet computed :
      headlookuplist : L NNI := new(weight, 0)
      s  : L NNI := [] -- we will compute s(f) only if necessary
      n1 : NNI := (n - 1) :: NNI
      repeat
        -- (run through the possible weights)
        while not empty? headlookuplist repeat
          -- find next polynomial in the above order with fixed weight;
          -- assume at this point we have
          -- headpol = [[i1,f{i1}], [i2,f{i2}], ... , [n,1]]
          -- and tailpol = [[k,fk], ... , [0,f0]] (with k < i1)
          term := first headpol
          j := first headlookuplist
          if j = 0 then j := lookup(term.coeff)$GF
          j := j + 1 -- lookup(f{i1})$GF + 1
          j rem sizeGF = 0 =>
            -- in this case one has to increase f{i2}
            tailpol := cons(term, tailpol) -- [[i1,f{i1}],...,[0,f0]]
            headpol := rest headpol        -- [[i2,f{i2}],...,[n,1]]
            taillookuplist := cons(j, taillookuplist)
            headlookuplist := rest headlookuplist
          -- otherwise set f{i1} := index(j)$GF
          setelt(first headpol, coeff, index(j :: PI)$GF)
          setfirst_!(headlookuplist, j)
          if empty? taillookuplist then
            pol := revListToSUP(headpol)
            --
            -- may be improved by excluding reciprocal polynomials
            --
            irreducible? pol => return pol
          else
            -- go back to fk
            headpol := cons(first tailpol, headpol) -- [[k,fk],...,[n,1]]
            tailpol := rest tailpol
            headlookuplist := cons(first taillookuplist, headlookuplist)
            taillookuplist := rest taillookuplist
        -- must search for polynomial with greater weight
        if empty? s then -- compute s(f)
          restfcopy := rest fcopy
          for entry in restfcopy repeat s := cons(entry.expnt, s)
        weight = n => return "failed"
        s1 := nextSubset(rest s, n1) :: L NNI
        s := cons(0, s1)
        weight := #s
        taillookuplist := []
        headlookuplist := cons(sizeGF, new((weight-1) :: NNI, 1))
        tailpol := []
        headpol := [] -- [[0,0], [s.2,1], ... , [s.weight,1], [n,1]] :
        s1 := cons(n, reverse s1)
        while not empty? s1 repeat
          headpol := cons([first s1, 1]$Rec, headpol)
          s1 := rest s1
        headpol := cons([0, 0]$Rec, headpol)

    nextPrimitivePoly f ==
      n : NNI := degree f
      n = 0 => error "polynomial must have positive degree"
      -- make f monic
      if (lcf := leadingCoefficient f) ^= 1 then f := (inv lcf) * f
      -- if f = fn*X**n + ... + f{i0}*X**{i0} with the fi non-zero
      -- then fRepr := [[n,fn], ... , [i0,f{i0}]]
      fRepr : Repr := f pretend Repr
      fcopy : Repr := []
      -- we can not simply write fcopy := copy fRepr because
      -- the input(!) f would be modified by assigning
      -- a new value to one of its records
      for term in fRepr repeat
        fcopy := cons(copy term, fcopy)
      if term.expnt ^= 0 then
        term  := [0,0]$Rec
        fcopy := cons(term, fcopy)
      fcopy   := reverse fcopy
      xn : Rec := first fcopy
      c0 : GF  := term.coeff
      l  : NNI := lookup(c0)$GF rem sizeGF
      n = 1 =>
        -- the polynomial X + c is primitive if and only if -c
        -- is a primitive element of GF
        q1 : NNI  := (sizeGF - 1) :: NNI
        while l < q1 repeat -- find next c such that -c is primitive
          l := l + 1
          c := index(l :: PI)$GF
          primitive?(-c)$GF =>
            return [xn, [0,c]$Rec] pretend SUP
        "failed"
      weight : NNI := (#(fcopy) - 1) :: NNI -- #s(f)+1 as explained above
      s  : L NNI := [] -- we will compute s(f) only if necessary
      n1 : NNI := (n - 1) :: NNI
      -- a necessary condition for a monic polynomial f of degree n
      -- over GF to be primitive is that (-1)**n * f(0) be a
      -- primitive element of GF (cf. [LN] p.90, Th. 3.18)
      c  : GF  := c0
      while l < sizeGF repeat
        -- (run through the possible values of the constant term)
        noGenerator : Boolean := true
        while noGenerator and l < sizeGF repeat
          -- find least c >= c0 such that (-1)^n c0 is primitive
          primitive?((-1)**n * c)$GF => noGenerator := false
          l := l + 1
          c := index(l :: PI)$GF
        noGenerator => return "failed"
        constterm : Rec := [0, c]$Rec
        if c = c0 and weight > 1 then
          headpol : Repr := rest reverse fcopy -- [[i0,f{i0}],...,[n,1]]
                                               -- fi is non-zero for i>0
          -- the zeroes in the headlookuplist stand for the fi
          -- whose lookup's were not yet computed :
          headlookuplist : L NNI := new(weight, 0)
        else
          -- X**n + c can not be primitive for n > 1 (cf. [LN] p.90,
          -- Th. 3.18); next possible polynomial is X**n + X + c
          headpol : Repr := [[1,0]$Rec, xn] -- 0*X + X**n
          headlookuplist : L NNI := [sizeGF]
          s := [0,1]
          weight := 2
        tailpol : Repr := []
        taillookuplist : L NNI := []
        notReady : Boolean := true
        while notReady repeat
          -- (run through the possible weights)
          while not empty? headlookuplist repeat
            -- find next polynomial in the above order with fixed
            -- constant term and weight; assume at this point we have
            -- headpol = [[i1,f{i1}], [i2,f{i2}], ... , [n,1]] and
            -- tailpol = [[k,fk],...,[k0,fk0]] (k0<...<k<i1<i2<...<n)
            term := first headpol
            j := first headlookuplist
            if j = 0 then j := lookup(term.coeff)$GF
            j := j + 1 -- lookup(f{i1})$GF + 1
            j rem sizeGF = 0 =>
              -- in this case one has to increase f{i2}
              tailpol := cons(term, tailpol) -- [[i1,f{i1}],...,[k0,f{k0}]]
              headpol := rest headpol        -- [[i2,f{i2}],...,[n,1]]
              taillookuplist := cons(j, taillookuplist)
              headlookuplist := rest headlookuplist
            -- otherwise set f{i1} := index(j)$GF
            setelt(first headpol, coeff, index(j :: PI)$GF)
            setfirst_!(headlookuplist, j)
            if empty? taillookuplist then
              pol := revListToSUP cons(constterm, headpol)
              --
              -- may be improved by excluding reciprocal polynomials
              --
              primitive? pol => return pol
            else
              -- go back to fk
              headpol := cons(first tailpol, headpol) -- [[k,fk],...,[n,1]]
              tailpol := rest tailpol
              headlookuplist := cons(first taillookuplist,
                                              headlookuplist)
              taillookuplist := rest taillookuplist
          if weight = n then notReady := false
          else
            -- must search for polynomial with greater weight
            if empty? s then -- compute s(f)
              restfcopy := rest fcopy
              for entry in restfcopy repeat s := cons(entry.expnt, s)
            s1 := nextSubset(rest s, n1) :: L NNI
            s  := cons(0, s1)
            weight := #s
            taillookuplist := []
            headlookuplist := cons(sizeGF, new((weight-2) :: NNI, 1))
            tailpol := []
            -- headpol = [[s.2,0], [s.3,1], ... , [s.weight,1], [n,1]] :
            headpol := [[first s1, 0]$Rec]
            while not empty? (s1 := rest s1) repeat
              headpol := cons([first s1, 1]$Rec, headpol)
            headpol := reverse cons([n, 1]$Rec, headpol)
        -- next polynomial must have greater constant term
        l := l + 1
        c := index(l :: PI)$GF
      "failed"

    nextNormalPoly f ==
      n : NNI := degree f
      n = 0 => error "polynomial must have positive degree"
      -- make f monic
      if (lcf := leadingCoefficient f) ^= 1 then f := (inv lcf) * f
      -- if f = fn*X**n + ... + f{i0}*X**{i0} with the fi non-zero
      -- then fRepr := [[n,fn], ... , [i0,f{i0}]]
      fRepr : Repr := f pretend Repr
      fcopy : Repr := []
      -- we can not simply write fcopy := copy fRepr because
      -- the input(!) f would be modified by assigning
      -- a new value to one of its records
      for term in fRepr repeat
        fcopy := cons(copy term, fcopy)
      if term.expnt ^= 0 then
        term  := [0,0]$Rec
        fcopy := cons(term, fcopy)
      fcopy     := reverse fcopy -- [[n,1], [r,fr], ... , [0,f0]]
      xn : Rec  := first fcopy
      middlepol : Repr := rest fcopy -- [[r,fr], ... , [0,f0]]
      a0 : GF  := (first middlepol).coeff -- fr
      l  : NNI := lookup(a0)$GF rem sizeGF
      n = 1 =>
        -- the polynomial X + a is normal if and only if a is not zero
        l = sizeGF - 1 => "failed"
        [xn, [0, index((l+1) :: PI)$GF]$Rec] pretend SUP
      n1 : NNI := (n  - 1) :: NNI
      n2 : NNI := (n1 - 1) :: NNI
      -- if the polynomial X**n + a * X**(n-1) + ... is normal then
      -- a = -(x + x**q +...+ x**(q**n)) can not be zero (where q = #GF)
      a  : GF  := a0
      -- if a = 0 then set a := 1
      if l = 0 then
        l := 1
        a := 1$GF
      while l < sizeGF repeat
        -- (run through the possible values of a)
        if a = a0 then
          -- middlepol = [[0,f0], ... , [m,fm]] with m < n-1
          middlepol := reverse rest middlepol
          weight : NNI := #middlepol -- #s(f) as explained above
          -- the zeroes in the middlelookuplist stand for the fi
          -- whose lookup's were not yet computed :
          middlelookuplist : L NNI := new(weight, 0)
          s : L NNI := [] -- we will compute s(f) only if necessary
        else
          middlepol := [[0,0]$Rec]
          middlelookuplist : L NNI := [sizeGF]
          s : L NNI := [0]
          weight : NNI := 1
        headpol : Repr := [xn, [n1, a]$Rec] -- X**n + a * X**(n-1)
        tailpol : Repr := []
        taillookuplist : L NNI := []
        notReady : Boolean := true
        while notReady repeat
          -- (run through the possible weights)
          while not empty? middlelookuplist repeat
            -- find next polynomial in the above order with fixed
            -- a and weight; assume at this point we have
            -- middlepol = [[i1,f{i1}], [i2,f{i2}], ... , [m,fm]] and
            -- tailpol = [[k,fk],...,[0,f0]] ( with k<i1<i2<...<m)
            term := first middlepol
            j := first middlelookuplist
            if j = 0 then j := lookup(term.coeff)$GF
            j := j + 1 -- lookup(f{i1})$GF + 1
            j rem sizeGF = 0 =>
              -- in this case one has to increase f{i2}
              -- tailpol = [[i1,f{i1}],...,[0,f0]]
              tailpol   := cons(term, tailpol)
              middlepol := rest middlepol -- [[i2,f{i2}],...,[m,fm]]
              taillookuplist   := cons(j, taillookuplist)
              middlelookuplist := rest middlelookuplist
            -- otherwise set f{i1} := index(j)$GF
            setelt(first middlepol, coeff, index(j :: PI)$GF)
            setfirst_!(middlelookuplist, j)
            if empty? taillookuplist then
              pol := listToSUP append(headpol, reverse middlepol)
              --
              -- may be improved by excluding reciprocal polynomials
              --
              normal? pol => return pol
            else
              -- go back to fk
              -- middlepol = [[k,fk],...,[m,fm]]
              middlepol := cons(first tailpol, middlepol)
              tailpol := rest tailpol
              middlelookuplist := cons(first taillookuplist,
                                               middlelookuplist)
              taillookuplist := rest taillookuplist
          if weight = n1 then notReady := false
          else
            -- must search for polynomial with greater weight
            if empty? s then -- compute s(f)
              restfcopy := rest rest fcopy
              for entry in restfcopy repeat s := cons(entry.expnt, s)
            s1 := nextSubset(rest s, n2) :: L NNI
            s  := cons(0, s1)
            weight := #s
            taillookuplist := []
            middlelookuplist := cons(sizeGF, new((weight-1) :: NNI, 1))
            tailpol   := []
            -- middlepol = [[0,0], [s.2,1], ... , [s.weight,1]] :
            middlepol := []
            s1 := reverse s1
            while not empty? s1 repeat
              middlepol := cons([first s1, 1]$Rec, middlepol)
              s1 := rest s1
            middlepol := cons([0,0]$Rec, middlepol)
        -- next polynomial must have greater a
        l := l + 1
        a := index(l :: PI)$GF
      "failed"

    nextNormalPrimitivePoly f ==
      n : NNI := degree f
      n = 0 => error "polynomial must have positive degree"
      -- make f monic
      if (lcf := leadingCoefficient f) ^= 1 then f := (inv lcf) * f
      -- if f = fn*X**n + ... + f{i0}*X**{i0} with the fi non-zero
      -- then fRepr := [[n,fn], ... , [i0,f{i0}]]
      fRepr : Repr := f pretend Repr
      fcopy : Repr := []
      -- we can not simply write fcopy := copy fRepr because
      -- the input(!) f would be modified by assigning
      -- a new value to one of its records
      for term in fRepr repeat
        fcopy := cons(copy term, fcopy)
      if term.expnt ^= 0 then
        term  := [0,0]$Rec
        fcopy := cons(term, fcopy)
      fcopy   := reverse fcopy -- [[n,1], [r,fr], ... , [0,f0]]
      xn : Rec := first fcopy
      c0 : GF  := term.coeff
      lc : NNI := lookup(c0)$GF rem sizeGF
      n = 1 =>
        -- the polynomial X + c is primitive if and only if -c
        -- is a primitive element of GF
        q1 : NNI  := (sizeGF - 1) :: NNI
        while lc < q1 repeat -- find next c such that -c is primitive
          lc := lc + 1
          c  := index(lc :: PI)$GF
          primitive?(-c)$GF =>
            return [xn, [0,c]$Rec] pretend SUP
        "failed"
      n1 : NNI := (n  - 1) :: NNI
      n2 : NNI := (n1 - 1) :: NNI
      middlepol : Repr := rest fcopy -- [[r,fr],...,[i0,f{i0}],[0,f0]]
      a0 : GF  := (first middlepol).coeff
      la : NNI := lookup(a0)$GF rem sizeGF
      -- if the polynomial X**n + a * X**(n-1) +...+ c is primitive and
      -- normal over GF then (-1)**n * c is a primitive element of GF
      -- (cf. [LN] p.90, Th. 3.18), and a = -(x + x**q +...+ x**(q**n))
      -- is not zero (where q = #GF)
      c : GF  := c0
      a : GF  := a0
      -- if a = 0 then set a := 1
      if la = 0 then
        la := 1
        a  := 1$GF
      while lc < sizeGF repeat
        -- (run through the possible values of the constant term)
        noGenerator : Boolean := true
        while noGenerator and lc < sizeGF repeat
          -- find least c >= c0 such that (-1)**n * c0 is primitive
          primitive?((-1)**n * c)$GF => noGenerator := false
          lc := lc + 1
          c  := index(lc :: PI)$GF
        noGenerator => return "failed"
        constterm : Rec := [0, c]$Rec
        while la < sizeGF repeat
        -- (run through the possible values of a)
          headpol : Repr := [xn, [n1, a]$Rec] -- X**n + a X**(n-1)
          if c = c0 and a = a0 then
            -- middlepol = [[i0,f{i0}], ... , [m,fm]] with m < n-1
            middlepol := rest reverse rest middlepol
            weight : NNI := #middlepol + 1 -- #s(f)+1 as explained above
            -- the zeroes in the middlelookuplist stand for the fi
            -- whose lookup's were not yet computed :
            middlelookuplist : L NNI := new((weight-1) :: NNI, 0)
            s : L NNI := [] -- we will compute s(f) only if necessary
          else
            pol := listToSUP append(headpol, [constterm])
            normal? pol and primitive? pol => return pol
            middlepol := [[1,0]$Rec]
            middlelookuplist : L NNI := [sizeGF]
            s : L NNI := [0,1]
            weight : NNI := 2
          tailpol : Repr := []
          taillookuplist : L NNI := []
          notReady : Boolean := true
          while notReady repeat
          -- (run through the possible weights)
            while not empty? middlelookuplist repeat
              -- find next polynomial in the above order with fixed
              -- c, a and weight; assume at this point we have
              -- middlepol = [[i1,f{i1}], [i2,f{i2}], ... , [m,fm]]
              -- tailpol = [[k,fk],...,[k0,fk0]] (k0<...<k<i1<...<m)
              term := first middlepol
              j := first middlelookuplist
              if j = 0 then j := lookup(term.coeff)$GF
              j := j + 1 -- lookup(f{i1})$GF + 1
              j rem sizeGF = 0 =>
                -- in this case one has to increase f{i2}
                -- tailpol = [[i1,f{i1}],...,[k0,f{k0}]]
                tailpol   := cons(term, tailpol)
                middlepol := rest middlepol -- [[i2,f{i2}],...,[m,fm]]
                taillookuplist   := cons(j, taillookuplist)
                middlelookuplist := rest middlelookuplist
              -- otherwise set f{i1} := index(j)$GF
              setelt(first middlepol, coeff, index(j :: PI)$GF)
              setfirst_!(middlelookuplist, j)
              if empty? taillookuplist then
                pol := listToSUP append(headpol, reverse
                                cons(constterm, middlepol))
                --
                -- may be improved by excluding reciprocal polynomials
                --
                normal? pol and primitive? pol => return pol
              else
                -- go back to fk
                -- middlepol = [[k,fk],...,[m,fm]]
                middlepol := cons(first tailpol, middlepol)
                tailpol := rest tailpol
                middlelookuplist := cons(first taillookuplist,
                                                 middlelookuplist)
                taillookuplist := rest taillookuplist
            if weight = n1 then notReady := false
            else
              -- must search for polynomial with greater weight
              if empty? s then -- compute s(f)
                restfcopy := rest rest fcopy
                for entry in restfcopy repeat s := cons(entry.expnt, s)
              s1 := nextSubset(rest s, n2) :: L NNI
              s  := cons(0, s1)
              weight := #s
              taillookuplist := []
              middlelookuplist := cons(sizeGF, new((weight-2)::NNI, 1))
              tailpol   := []
              -- middlepol = [[s.2,0], [s.3,1], ... , [s.weight,1] :
              middlepol := [[first s1, 0]$Rec]
              while not empty? (s1 := rest s1) repeat
                middlepol := cons([first s1, 1]$Rec, middlepol)
              middlepol := reverse middlepol
          -- next polynomial must have greater a
          la := la + 1
          a  := index(la :: PI)$GF
        -- next polynomial must have greater constant term
        lc := lc + 1
        c  := index(lc :: PI)$GF
        la := 1
        a  := 1$GF
      "failed"

    nextPrimitiveNormalPoly f == nextNormalPrimitivePoly f

    createIrreduciblePoly n ==
      x := monomial(1,1)$SUP
      n = 1 => x
      xn := monomial(1,n)$SUP
      n >= sizeGF => nextIrreduciblePoly(xn + x) :: SUP
      -- (since in this case there is most no irreducible binomial X+a)
      odd? n => nextIrreduciblePoly(xn + 1) :: SUP
      nextIrreduciblePoly(xn) :: SUP

    createPrimitivePoly n ==
    -- (see also the comments in the code of nextPrimitivePoly)
      xn := monomial(1,n)$SUP
      n = 1 => xn + monomial(-primitiveElement()$GF, 0)$SUP
      c0 : GF := (-1)**n * primitiveElement()$GF
      constterm : Rec := [0, c0]$Rec
      -- try first (probably faster) the polynomials
      -- f = X**n + f{n-1}*X**(n-1) +...+ f1*X + c0 for which
      -- fi is 0 or 1 for i=1,...,n-1,
      -- and this in the order used to define nextPrimitivePoly
      s  : L NNI := [0,1]
      weight : NNI := 2
      s1 : L NNI := [1]
      n1 : NNI := (n - 1) :: NNI
      notReady : Boolean := true
      while notReady repeat
        polRepr : Repr := [constterm]
        while not empty? s1 repeat
          polRepr := cons([first s1, 1]$Rec, polRepr)
          s1 := rest s1
        polRepr := cons([n, 1]$Rec, polRepr)
        --
        -- may be improved by excluding reciprocal polynomials
        --
        primitive? (pol := listToSUP polRepr) => return pol
        if weight = n then notReady := false
        else
          s1 := nextSubset(rest s, n1) :: L NNI
          s  := cons(0, s1)
          weight := #s
      -- if there is no primitive f of the above form
      -- search now from the beginning, allowing arbitrary
      -- coefficients f_i, i = 1,...,n-1
      nextPrimitivePoly(xn + monomial(c0, 0)$SUP) :: SUP

    createNormalPoly n  ==
      n = 1 => monomial(1,1)$SUP + monomial(-1,0)$SUP
      -- get a normal polynomial f = X**n + a * X**(n-1) + ...
      -- with a = -1
      -- [recall that if f is normal over the field GF of order q
      -- then a = -(x + x**q +...+ x**(q**n)) can not be zero;
      -- hence the existence of such an f follows from the
      -- normal basis theorem ([LN] p.60, Th. 2.35) and the
      -- surjectivity of the trace ([LN] p.55, Th. 2.23 (iii))]
      nextNormalPoly(monomial(1,n)$SUP
                       + monomial(-1, (n-1) :: NNI)$SUP) :: SUP

    createNormalPrimitivePoly n ==
      xn := monomial(1,n)$SUP
      n = 1 => xn + monomial(-primitiveElement()$GF, 0)$SUP
      n1  : NNI := (n - 1) :: NNI
      c0  : GF  := (-1)**n * primitiveElement()$GF
      constterm  := monomial(c0, 0)$SUP
      -- try first the polynomials f = X**n + a *  X**(n-1) + ...
      -- with a = -1
      pol := xn + monomial(-1, n1)$SUP + constterm
      normal? pol and primitive? pol => pol
      res := nextNormalPrimitivePoly(pol)
      res case SUP => res
      -- if there is no normal primitive f with a = -1
      -- get now one with arbitrary (non-zero) a
      -- (the existence is proved in [LS])
      pol := xn + monomial(1, n1)$SUP + constterm
      normal? pol and primitive? pol => pol
      nextNormalPrimitivePoly(pol) :: SUP

    createPrimitiveNormalPoly n == createNormalPrimitivePoly n

--    qAdicExpansion m ==
--      ragits : List I := wholeRagits(m :: (RadixExpansion sizeGF))
--      pol  : SUP := 0
--      expt : NNI := #ragits
--      for i in ragits repeat
--        expt := (expt - 1) :: NNI
--        if i ^= 0 then pol := pol + monomial(index(i::PI)$GF, expt)
--      pol

--    random == qAdicExpansion(random()$I)

--    random n ==
--      pol := monomial(1,n)$SUP
--      n1 : NNI := (n - 1) :: NNI
--      for i in 0..n1 repeat
--        if (c := random()$GF) ^= 0 then
--          pol := pol + monomial(c, i)$SUP
--      pol

    random n ==
      polRepr : Repr := []
      n1 : NNI := (n - 1) :: NNI
      for i in 0..n1 repeat
        if (c := random()$GF) ^= 0 then
          polRepr := cons([i, c]$Rec, polRepr)
      cons([n, 1$GF]$Rec, polRepr) pretend SUP

    random(m,n) ==
      if m > n then (m,n) := (n,m)
      d : NNI := (n - m) :: NNI
      if d > 1 then n := ((random()$I rem (d::PI)) + m) :: PI
      random(n)

@
<<FFPOLY.dotabb>>=
"FFPOLY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFPOLY"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FFPOLY" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFPOLY2 FiniteFieldPolynomialPackage2}
\pagehead{FiniteFieldPolynomialPackage2}{FFPOLY2}
\pagepic{ps/v104finitefieldpolynomialpackage2.ps}{FFPOLY2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFPOLY2 FiniteFieldPolynomialPackage2>>=
)abbrev package FFPOLY2 FiniteFieldPolynomialPackage2
++ Authors: J.Grabmeier, A.Scheerhorn
++ Date Created: 26.03.1991
++ Date Last Updated:
++ Basic Operations: rootOfIrreduciblePoly
++ Related Constructors: FiniteFieldCategory
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, zeros of polynomials, Berlekamp's trace algorithm
++ References:
++  R.Lidl, H.Niederreiter: Finite Field, Encycoldia of Mathematics and
++  Its Applications, Vol. 20, Cambridge Univ. Press, 1983, ISBN 0 521 30240 4
++  AXIOM Technical Report Series, to appear.
++ Description:
++  FiniteFieldPolynomialPackage2(F,GF) exports some functions concerning
++  finite fields, which depend on a finite field {\em GF} and an
++  algebraic extension F of {\em GF}, e.g. a zero of a polynomial
++  over {\em GF} in F.
FiniteFieldPolynomialPackage2(F,GF):Exports == Implementation where
  F:FieldOfPrimeCharacteristic with
      coerce: GF -> F
	++ coerce(x) \undocumented{}
      lookup: F -> PositiveInteger
	++ lookup(x) \undocumented{}
      basis: PositiveInteger -> Vector F
	++ basis(n) \undocumented{}
      Frobenius: F -> F
	++ Frobenius(x) \undocumented{}
  -- F should be a algebraic extension of the finite field GF, either an
  -- algebraic closure of GF or a simple algebraic extension field of GF
  GF:FiniteFieldCategory

  I   ==> Integer
  NNI ==> NonNegativeInteger
  PI  ==> PositiveInteger
  SUP ==> SparseUnivariatePolynomial
  MM  ==> ModMonic(GF,SUP GF)
  OUT ==> OutputForm
  M   ==> Matrix
  V   ==> Vector
  L   ==> List
  FFPOLY ==> FiniteFieldPolynomialPackage(GF)
  SUPF2 ==> SparseUnivariatePolynomialFunctions2(GF,F)

  Exports ==> with

    rootOfIrreduciblePoly:SUP GF -> F
      ++ rootOfIrreduciblePoly(f) computes one root of the monic,
      ++ irreducible polynomial f, 
      ++ which degree must divide the extension degree
      ++ of {\em F} over {\em GF},
      ++ i.e. f splits into linear factors over {\em F}.


  Implementation ==> add

-- we use berlekamps trace algorithm
-- it is not checked whether the polynomial is irreducible over GF]]
    rootOfIrreduciblePoly(pf) ==
--    not irreducible(pf)$FFPOLY =>
--      error("polynomial has to be irreducible")
      sizeGF:=size()$GF
      -- if the polynomial is of degree one, we're ready
      deg:=degree(pf)$(SUP GF)::PI
      deg = 0 => error("no roots")
      deg = 1 => -coefficient(pf,0)$(SUP GF)::F
      p : SUP F := map(coerce,pf)$SUPF2
      -- compute qexp, qexp(i) = x **(size()GF ** i) mod p
      -- with this list it's easier to compute the gcd(p(x),trace(x))
      qexp:=reducedQPowers(pf)$FFPOLY
      stillToFactor:=p
      -- take linear independent elements, the basis of F over GF
      basis:Vector F:=basis(deg)$F
      basispointer:I:=1
      -- as p is irreducible over GF, 0 can't be a root of p
      -- therefore we can use the predicate zero?(root) for indicating
      -- whether a root is found
      root:=0$F
      while zero?(root)$F repeat
        beta:F:=basis.basispointer
        -- gcd(trace(x)+gf,p(x)) has degree 0,that's why we skip beta=1
        if beta = 1$F then
          basispointer:=basispointer + 1
          beta:= basis.basispointer
        basispointer:=basispointer+1
        -- compute the polynomial trace(beta * x) mod p(x) using explist
        trModp:SUP F:= map(coerce,qexp.0)$SUPF2 * beta
        for i in 1..deg-1 repeat
          beta:=Frobenius(beta)
          trModp:=trModp +$(SUP F) beta *$(SUP F) map(coerce,qexp.i)$SUPF2
        -- if it is of degree 0, it doesn't help us finding a root
        if degree(trModp)$(SUP F) > 0 then
          -- for all elements gf of GF do
          for j in 1..sizeGF repeat
            -- compute gcd(trace(beta * x) + gf,stillToFactor)
            h:=gcd(stillToFactor,trModp +$(SUP F) _
             (index(j pretend PI)$GF::F::(SUP F)))$(SUP F)
            -- make the gcd polynomial monic
            if leadingCoefficient(h)$(SUP F) ^= 1$F then
              h:= (inv leadingCoefficient(h)) * h
            degh:=degree(h)$(SUP F)
            degSTF:=degree(stillToFactor)$(SUP F)
            -- if the gcd has degree one we are ready
            degh = 1 => root:=-coefficient(h,0)$(SUP F)
            -- if the quotient of stillToFactor and the gcd has
            -- degree one, we're also ready
            degSTF - degh = 1 =>
              root:= -coefficient(stillToFactor quo h,0)$(SUP F)
            -- otherwise the gcd helps us finding a root, only if its
            -- degree is between 2 and degree(stillToFactor)-2
            if degh > 1 and degh < degSTF then
              2*degh > degSTF => stillToFactor := stillToFactor quo h
              stillToFactor := h
      root

@
<<FFPOLY2.dotabb>>=
"FFPOLY2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFPOLY2"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"FFPOLY2" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFSLPE FiniteFieldSolveLinearPolynomialEquation}
\pagehead{FiniteFieldSolveLinearPolynomialEquation}{FFSLPE}
\pagepic{ps/v104finitefieldsolvelinearpolynomialequation.ps}{FFSLPE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFSLPE FiniteFieldSolveLinearPolynomialEquation>>=
)abbrev package FFSLPE FiniteFieldSolveLinearPolynomialEquation
++ Author: Davenport
++ Date Created: 1991
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package solves linear diophantine equations for Bivariate polynomials
++ over finite fields

FiniteFieldSolveLinearPolynomialEquation(F:FiniteFieldCategory,
                                        FP:UnivariatePolynomialCategory F,
                                        FPP:UnivariatePolynomialCategory FP): with
   solveLinearPolynomialEquation: (List FPP, FPP) -> Union(List FPP,"failed")
              ++ solveLinearPolynomialEquation([f1, ..., fn], g)
              ++ (where the fi are relatively prime to each other)
              ++ returns a list of ai such that
              ++ \spad{g/prod fi = sum ai/fi}
              ++ or returns "failed" if no such list of ai's exists.
  == add
     oldlp:List FPP := []
     slpePrime: FP := monomial(1,1)
     oldtable:Vector List FPP := []
     lp: List FPP
     p: FPP
     import DistinctDegreeFactorize(F,FP)
     solveLinearPolynomialEquation(lp,p) ==
       if (oldlp ^= lp) then
          -- we have to generate a new table
          deg:= +/[degree u for u in lp]
          ans:Union(Vector List FPP,"failed"):="failed"
          slpePrime:=monomial(1,1)+monomial(1,0)   -- x+1: our starting guess
          while (ans case "failed") repeat
            ans:=tablePow(deg,slpePrime,lp)$GenExEuclid(FP,FPP)
            if (ans case "failed") then
               slpePrime:= nextItem(slpePrime)::FP
               while (degree slpePrime > 1) and
                     not irreducible? slpePrime repeat
                 slpePrime := nextItem(slpePrime)::FP
          oldtable:=(ans:: Vector List FPP)
       answer:=solveid(p,slpePrime,oldtable)
       answer

@
<<FFSLPE.dotabb>>=
"FFSLPE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFSLPE"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FFSLPE" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLAGG2 FiniteLinearAggregateFunctions2}
\pagehead{FiniteLinearAggregateFunctions2}{FLAGG2}
\pagepic{ps/v104finitelinearaggregatefunctions2.ps}{FLAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLAGG2 FiniteLinearAggregateFunctions2>>=
)abbrev package FLAGG2 FiniteLinearAggregateFunctions2
--% FiniteLinearAggregateFunctions2

++ Author: ???
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ FiniteLinearAggregateFunctions2 provides functions involving two
++ FiniteLinearAggregates where the underlying domains might be
++ different. An example of this might be creating a list of rational
++ numbers by mapping a function across a list of integers where the
++ function divides each integer by 1000.

FiniteLinearAggregateFunctions2(S, A, R, B):
 Exports == Implementation where
  S, R: Type
  A   : FiniteLinearAggregate S
  B   : FiniteLinearAggregate R

  Exports ==> with
    map    : (S -> R, A) -> B          
     ++ map(f,a) applies function f to each member of aggregate
     ++ \spad{a} resulting in a new aggregate over a
     ++ possibly different underlying domain.
    reduce : ((S, R) -> R, A, R) -> R  
     ++ reduce(f,a,r) applies function f to each
     ++ successive element of the
     ++ aggregate \spad{a} and an accumulant initialized to r.
     ++ For example,
     ++ \spad{reduce(_+$Integer,[1,2,3],0)}
     ++ does \spad{3+(2+(1+0))}. Note: third argument r
     ++ may be regarded as the
     ++ identity element for the function f.
    scan   : ((S, R) -> R, A, R) -> B  
     ++ scan(f,a,r) successively applies
     ++ \spad{reduce(f,x,r)} to more and more leading sub-aggregates
     ++ x of aggregrate \spad{a}.
     ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
     ++ \spad{scan(f,a,r)} returns
     ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
  Implementation ==> add
    if A has ListAggregate(S) then         -- A is a list-oid
      reduce(fn, l, ident) ==
        empty? l => ident
        reduce(fn, rest l, fn(first l, ident))

      if B has ListAggregate(R) or not(B has shallowlyMutable) then
        -- A is a list-oid, and B is either list-oids or not mutable
        map(f, l) == construct [f s for s in entries l]

        scan(fn, l, ident) ==
          empty? l => empty()
          val := fn(first l, ident)
          concat(val, scan(fn, rest l, val))

      else                      -- A is a list-oid, B a mutable array-oid
        map(f, l) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          for a in entries l repeat (qsetelt_!(w, i, f a); i := inc i)
          w

        scan(fn, l, ident) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          vl := ident
          for a in entries l repeat
            vl := qsetelt_!(w, i, fn(a, vl))
            i := inc i
          w

    else                              -- A is an array-oid
      reduce(fn, v, ident) ==
        val := ident
        for i in minIndex v .. maxIndex v repeat
          val := fn(qelt(v, i), val)
        val

      if B has ListAggregate(R) then   -- A is an array-oid, B a list-oid
        map(f, v) ==
          construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

        scan(fn, v, ident) ==
          w := empty()$B
          for i in minIndex v .. maxIndex v repeat
            ident := fn(qelt(v, i), ident)
            w := concat(ident, w)
          reverse_! w

      else                             -- A and B are array-oid's
        if B has shallowlyMutable then -- B is also mutable
          map(f, v) ==
            w := new(#v,NIL$Lisp)$B
            for i in minIndex w .. maxIndex w repeat
              qsetelt_!(w, i, f qelt(v, i))
            w

          scan(fn, v, ident) ==
            w   := new(#v,NIL$Lisp)$B
            vl := ident
            for i in minIndex v .. maxIndex v repeat
              vl := qsetelt_!(w, i, fn(qelt(v, i), vl))
            w

        else                                   -- B non mutable array-oid
          map(f, v) ==
            construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

          scan(fn, v, ident) ==
            w := empty()$B
            for i in minIndex v .. maxIndex v repeat
              ident := fn(qelt(v, i), ident)
              w := concat(w, ident)
            w

@
<<FLAGG2.dotabb>>=
"FLAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLAGG2"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"FLAGG2" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLASORT FiniteLinearAggregateSort}
\pagehead{FiniteLinearAggregateSort}{FLASORT}
\pagepic{ps/v104finitelinearaggregatesort.ps}{FLASORT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLASORT FiniteLinearAggregateSort>>=
)abbrev package FLASORT FiniteLinearAggregateSort
++ FiniteLinearAggregateSort
++ Sort package (in-place) for shallowlyMutable Finite Linear Aggregates
++ Author: Michael Monagan Sep/88
++ RelatedOperations: sort
++ Description:
++  This package exports 3 sorting algorithms which work over 
++  FiniteLinearAggregates.
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains
 
)bo PUSH('FiniteLinearAggregateSort, $mutableDomains) 

FiniteLinearAggregateSort(S, V): Exports == Implementation where
  S: Type
  V: FiniteLinearAggregate(S) with shallowlyMutable
 
  B ==> Boolean
  I ==> Integer
 
  Exports ==> with
    quickSort: ((S, S) -> B, V) -> V
      ++ quickSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the quicksort algorithm.
    heapSort : ((S, S) -> B, V) -> V
      ++ heapSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the heapsort algorithm.
    shellSort: ((S, S) -> B, V) -> V
      ++ shellSort(f, agg) sorts the aggregate agg with the ordering function
      ++ f using the shellSort algorithm.
 
  Implementation ==> add
    siftUp   : ((S, S) -> B, V, I, I) -> Void
    partition: ((S, S) -> B, V, I, I, I) -> I
    QuickSort: ((S, S) -> B, V, I, I) -> V
 
    quickSort(l, r) == QuickSort(l, r, minIndex r, maxIndex r)
 
    siftUp(l, r, i, n) ==
      t := qelt(r, i)
      while (j := 2*i+1) < n repeat
        if (k := j+1) < n and l(qelt(r, j), qelt(r, k)) then j := k
        if l(t,qelt(r,j)) then
           qsetelt_!(r, i, qelt(r, j))
           qsetelt_!(r, j, t)
           i := j
        else leave
 
    heapSort(l, r) ==
      not zero? minIndex r => error "not implemented"
      n := (#r)::I
      for k in shift(n,-1) - 1 .. 0 by -1 repeat siftUp(l, r, k, n)
      for k in n-1 .. 1 by -1 repeat
         swap_!(r, 0, k)
         siftUp(l, r, 0, k)
      r
 
    partition(l, r, i, j, k) ==
      -- partition r[i..j] such that r.s <= r.k <= r.t
      x := qelt(r, k)
      t := qelt(r, i)
      qsetelt_!(r, k, qelt(r, j))
      while i < j repeat
         if l(x,t) then
           qsetelt_!(r, j, t)
           j := j-1
           t := qsetelt_!(r, i, qelt(r, j))
         else (i := i+1; t := qelt(r, i))
      qsetelt_!(r, j, x)
      j
 
    QuickSort(l, r, i, j) ==
      n := j - i
--      if one? n and l(qelt(r, j), qelt(r, i)) then swap_!(r, i, j)
      if (n = 1) and l(qelt(r, j), qelt(r, i)) then swap_!(r, i, j)
      n < 2 => return r
      -- for the moment split at the middle item
      k := partition(l, r, i, j, i + shift(n,-1))
      QuickSort(l, r, i, k - 1)
      QuickSort(l, r, k + 1, j)
 
    shellSort(l, r) ==
      m := minIndex r
      n := maxIndex r
      -- use Knuths gap sequence: 1,4,13,40,121,...
      g := 1
      while g <= (n-m) repeat g := 3*g+1
      g := g quo 3
      while g > 0 repeat
         for i in m+g..n repeat
            j := i-g
            while j >= m and l(qelt(r, j+g), qelt(r, j)) repeat
               swap_!(r,j,j+g)
               j := j-g
         g := g quo 3
      r

@
<<FLASORT.dotabb>>=
"FLASORT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLASORT"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"FLASORT" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSAGG2 FiniteSetAggregateFunctions2}
\pagehead{FiniteSetAggregateFunctions2}{FSAGG2}
\pagepic{ps/v104finitesetaggregatefunctions2.ps}{FSAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSAGG2 FiniteSetAggregateFunctions2>>=
)abbrev package FSAGG2 FiniteSetAggregateFunctions2

--% FiniteSetAggregateFunctions2

++ Author: Robert S. Sutor
++ Date Created: 15 May 1990
++ Date Last Updated: 14 Oct 1993
++ Description:
++ FiniteSetAggregateFunctions2 provides functions involving two
++ finite set aggregates where the underlying domains might be
++ different. An example of this is to create a set of rational
++ numbers by mapping a function across a set of integers, where the
++ function divides each integer by 1000.

FiniteSetAggregateFunctions2(S, A, R, B): Exports == Implementation where
   S, R: SetCategory
   A   : FiniteSetAggregate S
   B   : FiniteSetAggregate R

   Exports ==> with
     map    : (S -> R, A) -> B          
      ++ map(f,a) applies function f to each member of
      ++ aggregate \spad{a}, creating a new aggregate with
      ++ a possibly different underlying domain.
     reduce : ((S, R) -> R, A, R) -> R  
      ++ reduce(f,a,r) applies function f to each
      ++ successive element of the aggregate \spad{a} and an
      ++ accumulant initialised to r.
      ++ For example,
      ++ \spad{reduce(_+$Integer,[1,2,3],0)}
      ++ does a \spad{3+(2+(1+0))}.
      ++ Note: third argument r may be regarded
      ++ as an identity element for the function.
     scan   : ((S, R) -> R, A, R) -> B  
      ++ scan(f,a,r) successively applies \spad{reduce(f,x,r)}
      ++ to more and more leading sub-aggregates x of
      ++ aggregate \spad{a}.
      ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
      ++ \spad{scan(f,a,r)} returns
      ++ \spad {[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
   Implementation ==> add
     map(fn, a) ==
       set(map(fn, parts a)$ListFunctions2(S, R))$B
     reduce(fn, a, ident) ==
       reduce(fn, parts a, ident)$ListFunctions2(S, R)
     scan(fn, a, ident) ==
       set(scan(fn, parts a, ident)$ListFunctions2(S, R))$B

@
<<FSAGG2.dotabb>>=
"FSAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSAGG2"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"FSAGG2" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLOATCP FloatingComplexPackage}
\pagehead{FloatingComplexPackage}{FLOATCP}
\pagepic{ps/v104floatingcomplexpackage.ps}{FLOATCP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLOATCP FloatingComplexPackage>>=
)abbrev package FLOATCP FloatingComplexPackage
++ Author: P. Gianni
++ Date Created: January 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: SystemSolvePackage, RadicalSolvePackage,
++ FloatingRealPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This is a package for the approximation of complex solutions for
++ systems of equations of rational functions with complex rational
++ coefficients. The results are expressed as either complex rational
++ numbers or complex floats depending on the type of the precision
++ parameter which can be either a rational number or a floating point number.
FloatingComplexPackage(Par): Cat == Cap where
    Par : Join(Field, OrderedRing)
    K   ==> GI
    FPK ==> Fraction P K
    C   ==> Complex
    I        ==> Integer
    NNI      ==> NonNegativeInteger
    P        ==> Polynomial
    EQ       ==> Equation
    L        ==> List
    SUP      ==> SparseUnivariatePolynomial
    RN       ==> Fraction Integer
    NF       ==> Float
    CF       ==> Complex Float
    GI       ==> Complex Integer
    GRN      ==> Complex RN
    SE       ==> Symbol
    RFI      ==> Fraction P I
    INFSP ==> InnerNumericFloatSolvePackage


    Cat == with

       complexSolve:    (L FPK,Par) -> L L EQ P C Par
         ++ complexSolve(lp,eps) finds all the complex solutions to
         ++ precision eps of the system lp of rational functions
         ++ over the complex rationals with respect to all the
         ++ variables appearing in lp.

       complexSolve:    (L EQ FPK,Par) -> L L EQ P C Par
         ++ complexSolve(leq,eps) finds all the complex solutions
         ++ to precision eps of the system leq of equations
         ++ of rational functions over complex rationals
         ++ with respect to all the variables appearing in lp.

       complexSolve:    (FPK,Par) -> L EQ P C Par
         ++ complexSolve(p,eps) find all the complex solutions of the
         ++ rational function p with complex rational coefficients
         ++ with respect to all the variables appearing in p,
         ++ with precision eps.

       complexSolve:    (EQ FPK,Par) ->  L EQ P C Par
         ++ complexSolve(eq,eps) finds all the complex solutions of the
         ++ equation eq of rational functions with rational rational coefficients
         ++ with respect to all the variables appearing in eq,
         ++ with precision eps.

       complexRoots : (FPK,Par) -> L C Par
         ++ complexRoots(rf, eps) finds all the complex solutions of a
         ++ univariate rational function with rational number coefficients.
         ++ The solutions are computed to precision eps.

       complexRoots : (L FPK,L SE,Par) -> L L C Par
         ++ complexRoots(lrf, lv, eps) finds all the complex solutions of a
         ++ list of rational functions with rational number coefficients
         ++ with respect the the variables appearing in lv.
         ++ Each solution is computed to precision eps and returned as
         ++ list corresponding to the order of variables in lv.

    Cap == add

       -- find the complex zeros of an univariate polynomial --
       complexRoots(q:FPK,eps:Par) : L C Par ==
         p:=numer q
         complexZeros(univariate p,eps)$ComplexRootPackage(SUP GI, Par)

       -- find the complex zeros of an univariate polynomial --
       complexRoots(lp:L FPK,lv:L SE,eps:Par) : L L C Par ==
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         innerSolve(lnum,lden,lv,eps)$INFSP(K,C Par,Par)

       complexSolve(lp:L FPK,eps : Par) : L L EQ  P C Par ==
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         lv:="setUnion"/[variables np for np in lnum]
         if lden^=[] then
          lv:=setUnion(lv,"setUnion"/[variables dp for dp in lden])
         [[equation(x::(P C Par),r::(P C Par)) for x in lv for r in nres]
           for nres in innerSolve(lnum,lden,lv,eps)$INFSP(K,C Par,Par)]

       complexSolve(le:L EQ FPK,eps : Par) : L L EQ  P C Par ==
         lp:=[lhs ep - rhs ep for ep in le]
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         lv:="setUnion"/[variables np for np in lnum]
         if lden^=[] then
          lv:=setUnion(lv,"setUnion"/[variables dp for dp in lden])
         [[equation(x::(P C Par),r::(P C Par)) for x in lv for r in nres]
           for nres in innerSolve(lnum,lden,lv,eps)$INFSP(K,C Par,Par)]

       complexSolve(p : FPK,eps : Par) : L EQ  P C Par ==
         (mvar := mainVariable numer p ) case "failed" =>
                 error "no variable found"
         x:P C Par:=mvar::SE::(P C Par)
         [equation(x,val::(P C Par)) for val in complexRoots(p,eps)]

       complexSolve(eq : EQ FPK,eps : Par) : L EQ  P C Par ==
         complexSolve(lhs eq - rhs eq,eps)

@
<<FLOATCP.dotabb>>=
"FLOATCP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLOATCP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"FLOATCP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLOATRP FloatingRealPackage}
\pagehead{FloatingRealPackage}{FLOATRP}
\pagepic{ps/v104floatingrealpackage.ps}{FLOATRP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLOATRP FloatingRealPackage>>=
)abbrev package FLOATRP FloatingRealPackage
++ Author: P. Gianni
++ Date Created: January 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: SystemSolvePackage, RadicalSolvePackage,
++ FloatingComplexPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This is a package for the approximation of real solutions for
++ systems of polynomial equations over the rational numbers.
++ The results are expressed as either rational numbers or floats
++ depending on the type of the precision parameter which can be
++ either a rational number or a floating point number.
FloatingRealPackage(Par): Cat == Cap where
    I        ==> Integer
    NNI      ==> NonNegativeInteger
    P        ==> Polynomial
    EQ       ==> Equation
    L        ==> List
    SUP      ==> SparseUnivariatePolynomial
    RN       ==> Fraction Integer
    NF       ==> Float
    CF       ==> Complex Float
    GI       ==> Complex Integer
    GRN      ==> Complex RN
    SE       ==> Symbol
    RFI      ==> Fraction P I
    INFSP ==> InnerNumericFloatSolvePackage

    Par : Join(OrderedRing, Field)  -- RN or NewFloat

    Cat == with

       solve:    (L RFI,Par) -> L L EQ P Par
         ++ solve(lp,eps) finds all of the real solutions of the
         ++ system lp of rational functions over the rational numbers
         ++ with respect to all the variables appearing in lp,
         ++ with precision eps.

       solve:    (L EQ RFI,Par) -> L L EQ P Par
         ++ solve(leq,eps) finds all of the real solutions of the
         ++ system leq of equationas of rational functions
         ++ with respect to all the variables appearing in lp,
         ++ with precision eps.

       solve:    (RFI,Par) ->  L EQ P Par
         ++ solve(p,eps) finds all of the real solutions of the
         ++ univariate rational function p with rational coefficients
         ++ with respect to the unique variable appearing in p,
         ++ with precision eps.

       solve:    (EQ RFI,Par) ->  L EQ P Par
         ++ solve(eq,eps) finds all of the real solutions of the
         ++ univariate equation eq of rational functions
         ++ with respect to the unique variables appearing in eq,
         ++ with precision eps.

       realRoots:    (L RFI,L SE,Par) -> L L Par
         ++ realRoots(lp,lv,eps) computes the list of the real
         ++ solutions of the list lp of rational functions with rational
         ++ coefficients with respect to the variables in lv,
         ++ with precision eps. Each solution is expressed as a list
         ++ of numbers in order corresponding to the variables in lv.

       realRoots : (RFI,Par) -> L Par
         ++ realRoots(rf, eps) finds the real zeros of a univariate
         ++ rational function with precision given by eps.

    Cap == add

       makeEq(nres:L Par,lv:L SE) : L EQ P Par ==
           [equation(x::(P Par),r::(P Par)) for x in lv for r in nres]

       -- find the real zeros of an univariate rational polynomial --
       realRoots(p:RFI,eps:Par) : L Par ==
         innerSolve1(numer p,eps)$INFSP(I,Par,Par)

       -- real zeros of the system of polynomial lp --
       realRoots(lp:L RFI,lv:L SE,eps: Par) : L L Par ==
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         innerSolve(lnum,lden,lv,eps)$INFSP(I,Par,Par)

       solve(lp:L RFI,eps : Par) : L L EQ  P Par ==
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         lv:="setUnion"/[variables np for np in lnum]
         if lden^=[] then
          lv:=setUnion(lv,"setUnion"/[variables dp for dp in lden])
         [makeEq(numres,lv) for numres
            in innerSolve(lnum,lden,lv,eps)$INFSP(I,Par,Par)]

       solve(le:L EQ RFI,eps : Par) : L L EQ  P Par ==
         lp:=[lhs ep - rhs ep for ep in le]
         lnum:=[numer p for p in lp]
         lden:=[dp for p in lp |(dp:=denom p)^=1]
         lv:="setUnion"/[variables np for np in lnum]
         if lden^=[] then
          lv:=setUnion(lv,"setUnion"/[variables dp for dp in lden])
         [makeEq(numres,lv) for numres
           in innerSolve(lnum,lden,lv,eps)$INFSP(I,Par,Par)]

       solve(p : RFI,eps : Par) :  L EQ  P Par ==
         (mvar := mainVariable numer p ) case "failed" =>
              error "no variable found"
         x:P Par:=mvar::SE::(P Par)
         [equation(x,val::(P Par)) for val in realRoots(p,eps)]

       solve(eq : EQ RFI,eps : Par) :  L EQ  P Par ==
         solve(lhs eq - rhs eq,eps)

@
<<FLOATRP.dotabb>>=
"FLOATRP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLOATRP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FLOATRP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FCPAK1 FortranCodePackage1}
\pagehead{FortranCodePackage1}{FCPAK1}
\pagepic{ps/v104fortrancodepackage1.ps}{FCPAK1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FCPAK1 FortranCodePackage1>>=
)abbrev package FCPAK1 FortranCodePackage1
++ Author: Grant Keady and Godfrey Nolan
++ Date Created: April 1993
++ Date Last Updated: 
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++  \spadtype{FortranCodePackage1} provides some utilities for
++  producing useful objects in FortranCode domain.
++  The Package may be used with the FortranCode domain and its
++  \spad{printCode} or possibly via an outputAsFortran.
++  (The package provides items of use in connection with ASPs
++  in the AXIOM-NAG link and, where appropriate, naming accords
++  with that in IRENA.)
++  The easy-to-use functions use Fortran loop variables I1, I2,
++  and it is users' responsibility to check that this is sensible.
++  The advanced functions use SegmentBinding to allow users control
++  over Fortran loop variable names.
-- Later might add functions to build
-- diagonalMatrix from List, i.e. the FC version of the corresponding
-- AXIOM function from MatrixCategory;
-- bandedMatrix, i.e. the full-matrix-FC version of the corresponding
-- AXIOM function in BandedMatrix Domain
-- bandedSymmetricMatrix, i.e. the full-matrix-FC version of the corresponding
-- AXIOM function in BandedSymmetricMatrix Domain

FortranCodePackage1: Exports  == Implementation where

  NNI    ==> NonNegativeInteger
  PI     ==> PositiveInteger
  PIN    ==> Polynomial(Integer)
  SBINT  ==> SegmentBinding(Integer)
  SEGINT ==> Segment(Integer)
  LSBINT ==> List(SegmentBinding(Integer))
  SBPIN  ==> SegmentBinding(Polynomial(Integer))
  SEGPIN ==> Segment(Polynomial(Integer))
  LSBPIN ==> List(SegmentBinding(Polynomial(Integer)))
  FC     ==> FortranCode
  EXPRESSION  ==> Union(Expression Integer,Expression Float,Expression Complex Integer,Expression Complex Float)

  Exports == with

    zeroVector: (Symbol,PIN) -> FC
      ++ zeroVector(s,p) \undocumented{}

    zeroMatrix: (Symbol,PIN,PIN) -> FC
      ++ zeroMatrix(s,p,q) uses loop variables in the Fortran, I1 and I2

    zeroMatrix: (Symbol,SBPIN,SBPIN) -> FC
      ++ zeroMatrix(s,b,d) in this version gives the user control 
      ++ over names of Fortran variables used in loops.

    zeroSquareMatrix: (Symbol,PIN) -> FC
      ++ zeroSquareMatrix(s,p) \undocumented{}

    identitySquareMatrix: (Symbol,PIN) -> FC
      ++ identitySquareMatrix(s,p) \undocumented{}

  Implementation ==> add
    import FC

    zeroVector(fname:Symbol,n:PIN):FC ==
      ue:Expression(Integer) := 0
      i1:Symbol := "I1"::Symbol
      lp1:PIN := 1::PIN
      hp1:PIN := n
      segp1:SEGPIN:= segment(lp1,hp1)$SEGPIN
      segbp1:SBPIN := equation(i1,segp1)$SBPIN
      ip1:PIN := i1::PIN
      indices:List(PIN) := [ip1]
      fa:FC := forLoop(segbp1,assign(fname,indices,ue)$FC)$FC
      fa

    zeroMatrix(fname:Symbol,m:PIN,n:PIN):FC ==
      ue:Expression(Integer) := 0
      i1:Symbol := "I1"::Symbol
      lp1:PIN := 1::PIN
      hp1:PIN := m
      segp1:SEGPIN:= segment(lp1,hp1)$SEGPIN
      segbp1:SBPIN := equation(i1,segp1)$SBPIN
      i2:Symbol := "I2"::Symbol
      hp2:PIN := n
      segp2:SEGPIN:= segment(lp1,hp2)$SEGPIN
      segbp2:SBPIN := equation(i2,segp2)$SBPIN
      ip1:PIN := i1::PIN
      ip2:PIN := i2::PIN
      indices:List(PIN) := [ip1,ip2]
      fa:FC :=forLoop(segbp1,forLoop(segbp2,assign(fname,indices,ue)$FC)$FC)$FC
      fa

    zeroMatrix(fname:Symbol,segbp1:SBPIN,segbp2:SBPIN):FC ==
      ue:Expression(Integer) := 0
      i1:Symbol := variable(segbp1)$SBPIN
      i2:Symbol := variable(segbp2)$SBPIN
      ip1:PIN := i1::PIN
      ip2:PIN := i2::PIN
      indices:List(PIN) := [ip1,ip2]
      fa:FC :=forLoop(segbp1,forLoop(segbp2,assign(fname,indices,ue)$FC)$FC)$FC
      fa

    zeroSquareMatrix(fname:Symbol,n:PIN):FC ==
      ue:Expression(Integer) := 0
      i1:Symbol := "I1"::Symbol
      lp1:PIN := 1::PIN
      hp1:PIN := n
      segp1:SEGPIN:= segment(lp1,hp1)$SEGPIN
      segbp1:SBPIN := equation(i1,segp1)$SBPIN
      i2:Symbol := "I2"::Symbol
      segbp2:SBPIN := equation(i2,segp1)$SBPIN
      ip1:PIN := i1::PIN
      ip2:PIN := i2::PIN
      indices:List(PIN) := [ip1,ip2]
      fa:FC :=forLoop(segbp1,forLoop(segbp2,assign(fname,indices,ue)$FC)$FC)$FC
      fa

    identitySquareMatrix(fname:Symbol,n:PIN):FC ==
      ue:Expression(Integer) := 0
      u1:Expression(Integer) := 1
      i1:Symbol := "I1"::Symbol
      lp1:PIN := 1::PIN
      hp1:PIN := n
      segp1:SEGPIN:= segment(lp1,hp1)$SEGPIN
      segbp1:SBPIN := equation(i1,segp1)$SBPIN
      i2:Symbol := "I2"::Symbol
      segbp2:SBPIN := equation(i2,segp1)$SBPIN
      ip1:PIN := i1::PIN
      ip2:PIN := i2::PIN
      indice1:List(PIN) := [ip1,ip1]
      indices:List(PIN) := [ip1,ip2]
      fc:FC := forLoop(segbp2,assign(fname,indices,ue)$FC)$FC
      f1:FC := assign(fname,indice1,u1)$FC
      fl:List(FC) := [fc,f1]
      fa:FC := forLoop(segbp1,block(fl)$FC)$FC
      fa

@
<<FCPAK1.dotabb>>=
"FCPAK1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FCPAK1"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"FCPAK1" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FOP FortranOutputStackPackage}
\pagehead{FortranOutputStackPackage}{FOP}
\pagepic{ps/v104fortranoutputstackpackage.ps}{FOP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FOP FortranOutputStackPackage>>=
)abbrev package FOP FortranOutputStackPackage
-- Because of a bug in the compiler:
)bo $noSubsumption:=false

++ Author: Mike Dewar
++ Date Created:  October 1992
++ Date Last Updated: 
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: Code to manipulate Fortran Output Stack
FortranOutputStackPackage() : specification == implementation where

  specification == with

    clearFortranOutputStack : () -> Stack String
      ++ clearFortranOutputStack() clears the Fortran output stack
    showFortranOutputStack : () -> Stack String
      ++ showFortranOutputStack() returns the Fortran output stack
    popFortranOutputStack : () -> Void
      ++ popFortranOutputStack() pops the Fortran output stack
    pushFortranOutputStack : FileName -> Void
      ++ pushFortranOutputStack(f) pushes f onto the Fortran output stack
    pushFortranOutputStack : String -> Void
      ++ pushFortranOutputStack(f) pushes f onto the Fortran output stack
    topFortranOutputStack : () -> String
      ++ topFortranOutputStack() returns the top element of the Fortran
      ++ output stack

  implementation == add

    import MoreSystemCommands

    -- A stack of filenames for Fortran output.  We are sharing this with
    -- the standard Fortran output code, so want to be a bit careful about
    -- how we interact with what the user does independently.  We get round
    -- potential problems by always examining the top element of the stack 
    -- before we push.  If the user has redirected output then we alter our
    -- top value accordingly.
    fortranOutputStack : Stack String := empty()@(Stack String)

    topFortranOutputStack():String == string(_$fortranOutputFile$Lisp)

    pushFortranOutputStack(fn:FileName):Void ==
      if empty? fortranOutputStack then
        push!(string(_$fortranOutputFile$Lisp),fortranOutputStack)
      else if not(top(fortranOutputStack)=string(_$fortranOutputFile$Lisp)) then
        pop! fortranOutputStack
        push!(string(_$fortranOutputFile$Lisp),fortranOutputStack)
      push!( fn::String,fortranOutputStack)
      systemCommand concat(["set output fortran quiet ", fn::String])$String
      void()

    pushFortranOutputStack(fn:String):Void ==
      if empty? fortranOutputStack then
        push!(string(_$fortranOutputFile$Lisp),fortranOutputStack)
      else if not(top(fortranOutputStack)=string(_$fortranOutputFile$Lisp)) then
        pop! fortranOutputStack
        push!(string(_$fortranOutputFile$Lisp),fortranOutputStack)
      push!( fn,fortranOutputStack)
      systemCommand concat(["set output fortran quiet ", fn])$String
      void()

    popFortranOutputStack():Void ==
      if not empty? fortranOutputStack then pop! fortranOutputStack
      if empty? fortranOutputStack then push!("CONSOLE",fortranOutputStack)
      systemCommand concat(["set output fortran quiet append ",_
                           top fortranOutputStack])$String
      void()

    clearFortranOutputStack():Stack String ==
      fortranOutputStack := empty()@(Stack String)

    showFortranOutputStack():Stack String ==
      fortranOutputStack

@
<<FOP.dotabb>>=
"FOP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FOP"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"FOP" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FORT FortranPackage}
\pagehead{FortranPackage}{FORT}
\pagepic{ps/v104fortranpackage.ps}{FORT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FORT FortranPackage>>=
)abbrev package FORT FortranPackage
-- Because of a bug in the compiler:
)bo $noSubsumption:=true 

++ Author: Mike Dewar
++ Date Created: October 6 1991
++ Date Last Updated: 13 July 1994
++ Basic Operations: linkToFortran
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ References:
++ Description: provides an interface to the boot code for calling Fortran
FortranPackage(): Exports == Implementation where
 FST ==> FortranScalarType
 SEX ==> SExpression
 L   ==> List
 S   ==> Symbol
 FOP ==> FortranOutputStackPackage
 U   ==> Union(array:L S,scalar:S)

 Exports ==> with
  linkToFortran: (S, L U, L L U, L S) -> SEX
	++ linkToFortran(s,l,ll,lv) \undocumented{}
  linkToFortran: (S, L U, L L U, L S, S) -> SEX
	++ linkToFortran(s,l,ll,lv,t) \undocumented{}
  linkToFortran: (S,L S,TheSymbolTable,L S) -> SEX
	++ linkToFortran(s,l,t,lv) \undocumented{}
  outputAsFortran: FileName -> Void
	++ outputAsFortran(fn) \undocumented{}
  setLegalFortranSourceExtensions: List String -> List String
	++ setLegalFortranSourceExtensions(l) \undocumented{}

 Implementation ==> add

  legalFortranSourceExtensions : List String := ["f"]

  setLegalFortranSourceExtensions(l:List String):List String ==
    legalFortranSourceExtensions := l
    
  checkExtension(fn : FileName) : String ==
    -- Does it end in a legal extension ?
    stringFn := fn::String
    not member?(extension fn,legalFortranSourceExtensions) =>
      error [stringFn,"is not a legal Fortran Source File."]
    stringFn

  outputAsFortran(fn:FileName):Void ==
--    source : String := checkExtension fn
    source : String := fn::String
    not readable? fn => 
      popFortranOutputStack()$FOP
      error([source,"is not readable"]@List(String))
    target : String := topFortranOutputStack()$FOP
    command : String := 
      concat(["sys rm -f ",target," ; cp ",source," ",target])$String
    systemCommand(command)$MoreSystemCommands
    void()$Void

  linkToFortran(name:S,args:L U, decls:L L U, res:L(S)):SEX == 
    makeFort(name,args,decls,res,NIL$Lisp,NIL$Lisp)$Lisp

  linkToFortran(name:S,args:L U, decls:L L U, res:L(S),returnType:S):SEX == 
    makeFort(name,args,decls,res,returnType,NIL$Lisp)$Lisp

  dimensions(type:FortranType):SEX ==
    convert([convert(convert(u)@InputForm)@SEX _
      for u in dimensionsOf(type)])@SEX

  ftype(name:S,type:FortranType):SEX ==
    [name,scalarTypeOf(type),dimensions(type),external? type]$Lisp

  makeAspList(asp:S,syms:TheSymbolTable):SExpression==
    symtab : SymbolTable := symbolTableOf(asp,syms)
    [asp,returnTypeOf(asp,syms),argumentListOf(asp,syms), _
     [ftype(u,fortranTypeOf(u,symtab)) for u in parametersOf symtab]]$Lisp

  linkToFortran(name:S,aArgs:L S,syms:TheSymbolTable,res:L S):SEX ==
    arguments : L S := argumentListOf(name,syms)$TheSymbolTable
    dummies : L S := setDifference(arguments,aArgs)
    symbolTable:SymbolTable := symbolTableOf(name,syms)
    symbolList := newTypeLists(symbolTable)
    rt:Union(fst: FST,void: "void") := returnTypeOf(name,syms)$TheSymbolTable

    -- Look for arguments which are subprograms
    asps :=[makeAspList(u,syms) for u in externalList(symbolTable)$SymbolTable]
    rt case fst =>
      makeFort1(name,arguments,aArgs,dummies,symbolList,res,(rt.fst)::S,asps)$Lisp
    makeFort1(name,arguments,aArgs,dummies,symbolList,res,NIL$Lisp,asps)$Lisp

@
<<FORT.dotabb>>=
"FORT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FORT"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"FORT" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FRIDEAL2 FractionalIdealFunctions2}
\pagehead{FractionalIdealFunctions2}{FRIDEAL2}
\pagepic{ps/v104fractionalidealfunctions2.ps}{FRIDEAL2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FRIDEAL2 FractionalIdealFunctions2>>=
)abbrev package FRIDEAL2 FractionalIdealFunctions2
++ Lifting of morphisms to fractional ideals.
++ Author: Manuel Bronstein
++ Date Created: 1 Feb 1989
++ Date Last Updated: 27 Feb 1990
++ Keywords: ideal, algebra, module.
FractionalIdealFunctions2(R1, F1, U1, A1, R2, F2, U2, A2):
 Exports == Implementation where
  R1, R2: EuclideanDomain
  F1: QuotientFieldCategory R1
  U1: UnivariatePolynomialCategory F1
  A1: Join(FramedAlgebra(F1, U1), RetractableTo F1)
  F2: QuotientFieldCategory R2
  U2: UnivariatePolynomialCategory F2
  A2: Join(FramedAlgebra(F2, U2), RetractableTo F2)

  Exports ==> with
    map: (R1 -> R2, FractionalIdeal(R1, F1, U1, A1)) ->
                                         FractionalIdeal(R2, F2, U2, A2)
	++ map(f,i) \undocumented{}

  Implementation ==> add
    fmap: (F1 -> F2, A1) -> A2

    fmap(f, a) ==
      v := coordinates a
      represents
        [f qelt(v, i) for i in minIndex v .. maxIndex v]$Vector(F2)

    map(f, i) ==
      b := basis i
      ideal [fmap(f(numer #1) / f(denom #1), qelt(b, j))
             for j in minIndex b .. maxIndex b]$Vector(A2)

@
<<FRIDEAL2.dotabb>>=
"FRIDEAL2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FRIDEAL2"]
"FRAMALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRAMALG"]
"FRIDEAL2" -> "FRAMALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFFG FractionFreeFastGaussian}
\pagehead{FractionFreeFastGaussian}{FFFG}
\pagepic{ps/v104fractionfreefastgaussian.ps}{FFFG}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFFG FractionFreeFastGaussian>>=
)abbrev package FFFG FractionFreeFastGaussian
++ Author: Martin Rubey
++ Description:
++ This package implements the interpolation algorithm proposed in Beckermann,
++ Bernhard and Labahn, George, Fraction-free computation of matrix rational
++ interpolants and matrix GCDs, SIAM Journal on Matrix Analysis and
++ Applications 22.
++ The packages defined in this file provide fast fraction free rational
++ interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)
FractionFreeFastGaussian(D, V): Exports == Implementation where
  D: Join(IntegralDomain, GcdDomain)
  V: AbelianMonoidRing(D, NonNegativeInteger) -- for example, SUP D

  SUP  ==> SparseUnivariatePolynomial

  cFunction ==> (NonNegativeInteger, Vector SUP D) -> D

  CoeffAction ==> (NonNegativeInteger, NonNegativeInteger, V) -> D

  Exports == with

    fffg: (List D, cFunction, List NonNegativeInteger) -> Matrix SUP D
      ++ \spad{fffg} is the general algorithm as proposed by Beckermann and
      ++ Labahn.
      ++

      ++ The first argument is the list of c_{i,i}.  These are the only values
      ++ of C explicitely needed in \spad{fffg}.
      ++
      ++ The second argument c, computes c_k(M), i.e., c_k(.) is the dual basis
      ++ of the vector space V, but also knows about the special multiplication
      ++ rule as descibed in Equation (2).  Note that the information about f
      ++ is therefore encoded in c.
      ++
      ++ The third argument is the vector of degree bounds n, as introduced in
      ++ Definition 2.1.  In particular, the sum of the entries is the order of
      ++ the Mahler system computed.

    interpolate: (List D, List D, NonNegativeInteger) -> Fraction SUP D
      ++ \spad{interpolate(xlist, ylist, deg} returns the rational function with
      ++ numerator degree at most \spad{deg} and denominator degree at most
      ++ \spad{#xlist-deg-1}  that interpolates the given points using
      ++ fraction free arithmetic. Note that rational interpolation does not
      ++ guarantee that all given points are interpolated correctly:
      ++ unattainable points may make this impossible.

@

\begin{verbatim}
  The following function could be moved to [[FFFGF]], parallel to
  [[generalInterpolation]].  However, the reason for moving
  [[generalInterpolation]] for fractions to a separate package was the need of
  a generic signature, hence the extra argument [[VF]] to [[FFFGF]].  In the
  special case of rational interpolation, this extra argument is not necessary,
  since we are always returning a fraction of [[SUP]]s, and ignore [[V]].  In
  fact, [[V]] is not needed for [[fffg]] itself, only if we want to specify a
  [[CoeffAction]].

  Thus, maybe it would be better to move [[fffg]] to a separate package?
\end{verbatim}

<<package FFFG FractionFreeFastGaussian>>=
    interpolate: (List Fraction D, List Fraction D, NonNegativeInteger) 
                -> Fraction SUP D
      ++ \spad{interpolate(xlist, ylist, deg} returns the rational function with
      ++ numerator degree \spad{deg} that interpolates the given points using
      ++ fraction free arithmetic.

    generalInterpolation: (List D, CoeffAction, 
                           Vector V, List NonNegativeInteger) -> Matrix SUP D
      ++ \spad{generalInterpolation(C, CA, f, eta)} performs Hermite-Pade
      ++ approximation using the given action CA of polynomials on the elements
      ++ of f. The result is guaranteed to be correct up to order
      ++ |eta|-1. Given that eta is a "normal" point, the degrees on the
      ++ diagonal are given by eta. The degrees of column i are in this case
      ++ eta + e.i - [1,1,...,1], where the degree of zero is -1.
      ++
      ++ The first argument C is the list of coefficients c_{k,k} in the 
      ++ expansion <x^k> z g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x).
      ++
      ++ The second argument, CA(k, l, f), should return the coefficient of x^k
      ++ in z^l f(x).

    generalInterpolation: (List D, CoeffAction, 
                           Vector V, NonNegativeInteger, NonNegativeInteger) 
                         -> Stream Matrix SUP D
      ++ \spad{generalInterpolation(C, CA, f, sumEta, maxEta)} applies
      ++ \spad{generalInterpolation(C, CA, f, eta)} for all possible \spad{eta}
      ++ with maximal entry \spad{maxEta} and sum of entries at most
      ++ \spad{sumEta}.
      ++
      ++ The first argument C is the list of coefficients c_{k,k} in the 
      ++ expansion <x^k> z g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x).
      ++
      ++ The second argument, CA(k, l, f), should return the coefficient of x^k 
      ++ in z^l f(x).

    generalCoefficient: (CoeffAction, Vector V, 
                         NonNegativeInteger, Vector SUP D) -> D
      ++ \spad{generalCoefficient(action, f, k, p)} gives the coefficient of
      ++ x^k in p(z)\dot f(x), where the action of z^l on a polynomial in x is
      ++ given by action, i.e., action(k, l, f) should return the coefficient
      ++ of x^k in z^l f(x).

    ShiftAction: (NonNegativeInteger, NonNegativeInteger, V) -> D
      ++ \spad{ShiftAction(k, l, g)} gives the coefficient of x^k in z^l g(x),
      ++ where \spad{z*(a+b*x+c*x^2+d*x^3+...) = (b*x+2*c*x^2+3*d*x^3+...)}. In
      ++ terms of sequences, z*u(n)=n*u(n).

    ShiftC: NonNegativeInteger -> List D
      ++ \spad{ShiftC} gives the coefficients c_{k,k} in the expansion <x^k> z
      ++ g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where z acts on g(x) by
      ++ shifting. In fact, the result is [0,1,2,...]

    DiffAction: (NonNegativeInteger, NonNegativeInteger, V) -> D
      ++ \spad{DiffAction(k, l, g)} gives the coefficient of x^k in z^l g(x),
      ++ where z*(a+b*x+c*x^2+d*x^3+...) = (a*x+b*x^2+c*x^3+...), i.e.,
      ++ multiplication with x.

    DiffC: NonNegativeInteger -> List D
      ++ \spad{DiffC} gives the coefficients c_{k,k} in the expansion <x^k> z
      ++ g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where z acts on g(x) by
      ++ shifting. In fact, the result is [0,0,0,...]

    qShiftAction: (D, NonNegativeInteger, NonNegativeInteger, V) -> D
      ++ \spad{qShiftAction(q, k, l, g)} gives the coefficient of x^k in z^l
      ++ g(x), where z*(a+b*x+c*x^2+d*x^3+...) =
      ++ (a+q*b*x+q^2*c*x^2+q^3*d*x^3+...). In terms of sequences,
      ++ z*u(n)=q^n*u(n).

    qShiftC: (D, NonNegativeInteger) -> List D
      ++ \spad{qShiftC} gives the coefficients c_{k,k} in the expansion <x^k> z
      ++ g(x) = sum_{i=0}^k c_{k,i} <x^i> g(x), where z acts on g(x) by
      ++ shifting. In fact, the result is [1,q,q^2,...]

  Implementation ==> add

-------------------------------------------------------------------------------
-- Shift Operator
-------------------------------------------------------------------------------

-- ShiftAction(k, l, f) is the CoeffAction appropriate for the shift operator.

    ShiftAction(k: NonNegativeInteger, l: NonNegativeInteger, f: V): D ==
      k**l*coefficient(f, k)


    ShiftC(total: NonNegativeInteger): List D == 
      [i::D for i in 0..total-1]

-------------------------------------------------------------------------------
-- q-Shift Operator
-------------------------------------------------------------------------------

-- q-ShiftAction(k, l, f) is the CoeffAction appropriate for the q-shift operator.

    qShiftAction(q: D, k: NonNegativeInteger, l: NonNegativeInteger, f: V): D ==
      q**(k*l)*coefficient(f, k)


    qShiftC(q: D, total: NonNegativeInteger): List D == 
      [q**i for i in 0..total-1]

-------------------------------------------------------------------------------
-- Differentiation Operator
-------------------------------------------------------------------------------

-- DiffAction(k, l, f) is the CoeffAction appropriate for the differentiation
-- operator.

    DiffAction(k: NonNegativeInteger, l: NonNegativeInteger, f: V): D ==
      coefficient(f, (k-l)::NonNegativeInteger)


    DiffC(total: NonNegativeInteger): List D == 
      [0 for i in 1..total]

-------------------------------------------------------------------------------
-- general - suitable for functions f
-------------------------------------------------------------------------------

-- get the coefficient of z^k in the scalar product of p and f, the action
-- being defined by coeffAction

    generalCoefficient(coeffAction: CoeffAction, f: Vector V, 
                       k: NonNegativeInteger, p: Vector SUP D): D == 
      res: D := 0
      for i in 1..#f repeat

-- Defining a and b and summing only over those coefficients that might be
-- nonzero makes a huge difference in speed
        a := f.i
        b := p.i
        for l in minimumDegree b..degree b repeat
            if not zero? coefficient(b, l)
            then res := res + coefficient(b, l) * coeffAction(k, l, a)
      res


    generalInterpolation(C: List D, coeffAction: CoeffAction, 
                         f: Vector V, 
                         eta: List NonNegativeInteger): Matrix SUP D == 

      c: cFunction := generalCoefficient(coeffAction, f,
                                         (#1-1)::NonNegativeInteger, #2)
      fffg(C, c, eta)



-------------------------------------------------------------------------------
-- general - suitable for functions f - trying all possible degree combinations
-------------------------------------------------------------------------------

@

The following function returns the lexicographically next vector with
non-negative components smaller than [[p]] with the same sum as [[v]].

<<package FFFG FractionFreeFastGaussian>>=
    nextVector!(p: NonNegativeInteger, v: List NonNegativeInteger)
               : Union("failed", List NonNegativeInteger) ==
      n := #v
      pos := position(#1 < p, v)
      zero? pos => return "failed"
      if pos = 1 then
        sum: Integer := v.1
        for i in 2..n repeat    
          if v.i < p and sum > 0 then
            v.i := v.i + 1
            sum := sum - 1
            for j in 1..i-1 repeat
              if sum > p then
                v.j := p
                sum := sum - p
              else
                v.j := sum::NonNegativeInteger
                sum := 0
            return v
          else sum := sum + v.i
        return "failed" 
      else
        v.pos     := v.pos + 1    
        v.(pos-1) := (v.(pos-1) - 1)::NonNegativeInteger

      v
@

The following function returns the stream of all possible degree vectors,
beginning with [[v]], where the degree vectors are sorted in reverse
lexicographic order. Furthermore, the entries are all less or equal to [[p]]
and their sum equals the sum of the entries of [[v]]. We assume that the
entries of [[v]] are also all less or equal to [[p]].

<<package FFFG FractionFreeFastGaussian>>=
    vectorStream(p: NonNegativeInteger, v: List NonNegativeInteger)
                : Stream List NonNegativeInteger == delay
      next := nextVector!(p, copy v)
      (next case "failed") => empty()$Stream(List NonNegativeInteger)
      cons(next, vectorStream(p, next))
@

[[vectorStream2]] skips every second entry of [[vectorStream]].

<<package FFFG FractionFreeFastGaussian>>=
    vectorStream2(p: NonNegativeInteger, v: List NonNegativeInteger)
                 : Stream List NonNegativeInteger == delay
      next := nextVector!(p, copy v)
      (next case "failed") => empty()$Stream(List NonNegativeInteger)
      next2 := nextVector!(p, copy next)
      (next2 case "failed") => cons(next, empty())
      cons(next2, vectorStream2(p, next2))
@

This version of [[generalInterpolation]] returns a stream of solutions, one for
each possible degree vector. Thus, it only needs to apply the previously
defined [[generalInterpolation]] to each degree vector. These are generated by
[[vectorStream]] and [[vectorStream2]] respectively.

If [[f]] consists of two elements only, we can skip every second degree vector:
note that [[fffg]], and thus also [[generalInterpolation]], returns a matrix
with [[#f]] columns, each corresponding to a solution of the interpolation
problem. More precisely, the $i$\textsuperscript{th} column is a solution with
degrees [[eta]]$-(1,1,\dots,1)+e_i$. Thus, in the case of $2\times 2$ matrices,
[[vectorStream]] would produce solutions corresponding to $(d,0), (d-1,1);
(d-1,1), (d-2, 2); (d-2, 2), (d-3,3)\dots$, i.e., every second matrix is
redundant.

Although some redundancy exists also for higher dimensional [[f]], the scheme
becomes much more complicated, thus we did not implement it.

<<package FFFG FractionFreeFastGaussian>>=
    generalInterpolation(C: List D, coeffAction: CoeffAction, 
                         f: Vector V, 
                         sumEta: NonNegativeInteger,
                         maxEta: NonNegativeInteger)
                        : Stream Matrix SUP D ==

      <<generate an initial degree vector>>

      if #f = 2 then
        map(generalInterpolation(C, coeffAction, f, #1), 
            cons(eta, vectorStream2(maxEta, eta)))
           $StreamFunctions2(List NonNegativeInteger,
                             Matrix SUP D)
      else
        map(generalInterpolation(C, coeffAction, f, #1), 
            cons(eta, vectorStream(maxEta, eta)))
           $StreamFunctions2(List NonNegativeInteger,
                           Matrix SUP D)
@

We need to generate an initial degree vector, being the minimal element in
reverse lexicographic order, i.e., $m, m, \dots, m, k, 0, 0, \dots$, where $m$
is [[maxEta]] and $k$ is the remainder of [[sumEta]] divided by
[[maxEta]]. This is done by the following code:

<<generate an initial degree vector>>=
sum: Integer := sumEta
entry: Integer
eta: List NonNegativeInteger
    := [(if sum < maxEta _
         then (entry := sum; sum := 0) _
         else (entry := maxEta; sum := sum - maxEta); _
         entry::NonNegativeInteger) for i in 1..#f]
@

We want to generate all vectors with sum of entries being at most
[[sumEta]]. Therefore the following is incorrect.
<<BUG generate an initial degree vector>>=
-- (sum > 0) => empty()$Stream(Matrix SUP D)
@

<<package FFFG FractionFreeFastGaussian>>=
-------------------------------------------------------------------------------
-- rational interpolation
-------------------------------------------------------------------------------

    interpolate(x: List Fraction D, y: List Fraction D, d: NonNegativeInteger) 
               : Fraction SUP D ==
      gx := splitDenominator(x)$InnerCommonDenominator(D, Fraction D, _
                                                       List D, _
                                                       List Fraction D)
      gy := splitDenominator(y)$InnerCommonDenominator(D, Fraction D, _
                                                       List D, _
                                                       List Fraction D)
      r := interpolate(gx.num, gy.num, d)
      elt(numer r, monomial(gx.den,1))/(gy.den*elt(denom r, monomial(gx.den,1)))


    interpolate(x: List D, y: List D, d: NonNegativeInteger): Fraction SUP D ==
-- berechne Interpolante mit Graden d und N-d-1
      if (N := #x) ~= #y then
        error "interpolate: number of points and values must match"
      if N <= d then
        error "interpolate: numerator degree must be smaller than number of data points"
      c: cFunction := y.#1 * elt(#2.2, x.#1) - elt(#2.1, x.#1)
      eta: List NonNegativeInteger := [d, (N-d)::NonNegativeInteger]
      M := fffg(x, c, eta)

      if zero?(M.(2,1)) then M.(1,2)/M.(2,2)
                        else M.(1,1)/M.(2,1)

@
Because of Lemma~5.3, [[M.1.(2,1)]] and [[M.1.(2,2)]] cannot both vanish,
since [[eta_sigma]] is always $\sigma$-normal by Theorem~7.2 and therefore also
para-normal, see Definition~4.2.

Because of Lemma~5.1 we have that [[M.1.(*,2)]] is a solution of the
interpolation problem, if [[M.1.(2,1)]] vanishes.

<<package FFFG FractionFreeFastGaussian>>=
-------------------------------------------------------------------------------
-- fffg
-------------------------------------------------------------------------------
@

[[recurrence]] computes the new matrix $M$, according to the following formulas
(cf. Table~2 in Beckermann and Labahn):
\[
\begin{array}{cc}
  &\textrm{Increase order}\\
  &\quad\quad\textrm{for $\ell=1\dots m$, $\ell\neq\pi$}\\
  &\quad\quad\quad\quad\mathbf M_{\sigma+1}^{(.,\ell)} := 
        \left(\mathbf M_{\sigma}^{(.,\ell)}r^{(\pi)} 
            - \mathbf M_{\sigma}^{(.,\pi)}r^{(\ell)}\right)/d_\sigma\\
  &\textrm{Increase order in column $\pi$}\\
  &\quad\quad\mathbf M_{\sigma+1}^{(.,\pi)} := 
        \left(z-c_{\sigma,\sigma}\right)\mathbf M_{\sigma}^{(.,\pi)}\\
  &\textrm{Adjust degree constraints:}\\
  &\quad\quad\mathbf M_{\sigma+1}^{(.,\pi)} := 
        \left(\mathbf M_{\sigma+1}^{(.,\pi)}r^{(\pi)} 
            - \sum_{\ell\neq\pi}\mathbf M_{\sigma+1}^{(.,\ell)}p^{(\ell)}
        \right)/d_\sigma
\end{array}
\]

Since we do not need the matrix $\mathbf M_{\sigma}$ anymore, we drop the index
and update the matrix destructively.  In the following, we write [[Ck]] for
$c_{\sigma,\sigma}$.

<<package FFFG FractionFreeFastGaussian>>=
-- a major part of the time is spent here
    recurrence(M: Matrix SUP D, pi: NonNegativeInteger, m: NonNegativeInteger,
               r: Vector D, d: D, z: SUP D, Ck: D, p: Vector D): Matrix SUP D ==

        rPi: D := qelt(r, pi)
        polyf: SUP D := rPi * (z - Ck::SUP D)

        for i in 1..m repeat
            MiPi: SUP D    := qelt(M, i, pi)
            newMiPi: SUP D := polyf * MiPi

-- update columns ~= pi and calculate their sum
            for l in 1..m | l ~= pi repeat
                rl: D  := qelt(r, l)
-- I need the coercion to SUP D, since exquo returns an element of
-- Union("failed", SUP D)...
                Mil: SUP D := ((qelt(M, i, l) * rPi - MiPi * rl) exquo d)::SUP D
                qsetelt!(M, i, l, Mil)

                pl: D  := qelt(p, l)
                newMiPi := newMiPi - pl * Mil

-- update column pi
            qsetelt!(M, i, pi, (newMiPi exquo d)::SUP D)

        M


    fffg(C: List D, c: cFunction, eta: List NonNegativeInteger): Matrix SUP D ==
-- eta is the vector of degrees. We compute M with degrees eta+e_i-1, i=1..m 
        z: SUP D := monomial(1, 1)
        m: NonNegativeInteger := #eta
        M: Matrix SUP D := scalarMatrix(m, 1)
        d: D := 1
        K: NonNegativeInteger := reduce(_+, eta)
        etak: Vector NonNegativeInteger := zero(m)
        r: Vector D := zero(m)
        p: Vector D := zero(m)
        Lambda: List Integer
        lambdaMax: Integer
        lambda: NonNegativeInteger

        for k in 1..K repeat
-- k = sigma+1

            for l in 1..m repeat r.l := c(k, column(M, l))

            Lambda := [eta.l-etak.l for l in 1..m | r.l ~= 0]

-- if Lambda is empty, then M, d and etak remain unchanged. Otherwise, we look
-- for the next closest para-normal point.

            (empty? Lambda) => "iterate"

            lambdaMax := reduce(max, Lambda)
            lambda := 1
            while eta.lambda-etak.lambda < lambdaMax or r.lambda = 0 repeat 
                lambda := lambda + 1

-- Calculate leading coefficients

            for l in 1..m | l ~= lambda repeat
                if etak.l > 0 then
                    p.l := coefficient(M.(l, lambda), 
                                       (etak.l-1)::NonNegativeInteger)
                else 
                    p.l := 0

-- increase order and adjust degree constraints

            M := recurrence(M, lambda, m, r, d, z, C.k, p)

            d := r.lambda
            etak.lambda := etak.lambda + 1

        M

@
<<FFFG.dotabb>>=
"FFFG" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFFG"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FFFG" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFFGF FractionFreeFastGaussianFractions}
\pagehead{FractionFreeFastGaussianFractions}{FFFGF}
\pagepic{ps/v104fractionfreefastgaussianfractions.ps}{FFFGF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFFGF FractionFreeFastGaussianFractions>>=
)abbrev package FFFGF FractionFreeFastGaussianFractions
++ Author: Martin Rubey
++ Description:
++ This package lifts the interpolation functions from
++ \spadtype{FractionFreeFastGaussian} to fractions.
++ The packages defined in this file provide fast fraction free rational
++ interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)
FractionFreeFastGaussianFractions(D, V, VF): Exports == Implementation where
  D: Join(IntegralDomain, GcdDomain)
  V: FiniteAbelianMonoidRing(D, NonNegativeInteger)
  VF: FiniteAbelianMonoidRing(Fraction D, NonNegativeInteger)

  F ==> Fraction D

  SUP  ==> SparseUnivariatePolynomial

  FFFG ==> FractionFreeFastGaussian

  FAMR2 ==> FiniteAbelianMonoidRingFunctions2

  cFunction ==> (NonNegativeInteger, Vector SUP D) -> D

  CoeffAction ==> (NonNegativeInteger, NonNegativeInteger, V) -> D
-- coeffAction(k, l, f) is the coefficient of x^k in z^l f(x)

  Exports == with

    generalInterpolation: (List D, CoeffAction, Vector VF, List NonNegativeInteger) 
                          -> Matrix SUP D
      ++ \spad{generalInterpolation(l, CA, f, eta)} performs Hermite-Pade
      ++ approximation using the given action CA of polynomials on the elements
      ++ of f. The result is guaranteed to be correct up to order
      ++ |eta|-1. Given that eta is a "normal" point, the degrees on the
      ++ diagonal are given by eta. The degrees of column i are in this case
      ++ eta + e.i - [1,1,...,1], where the degree of zero is -1.

    generalInterpolation: (List D, CoeffAction, 
                           Vector VF, NonNegativeInteger, NonNegativeInteger) 
                          -> Stream Matrix SUP D
      ++ \spad{generalInterpolation(l, CA, f, sumEta, maxEta)} applies
      ++ generalInterpolation(l, CA, f, eta) for all possible eta with maximal
      ++ entry maxEta and sum of entries sumEta

  Implementation == add

    multiplyRows!(v: Vector D, M: Matrix SUP D): Matrix SUP D ==
      n := #v
      for i in 1..n repeat
        for j in 1..n repeat
          M.(i,j) := v.i*M.(i,j)

      M

    generalInterpolation(C: List D, coeffAction: CoeffAction, 
                         f: Vector VF, eta: List NonNegativeInteger): Matrix SUP D == 
      n := #f
      g: Vector V   := new(n, 0)
      den: Vector D := new(n, 0)

      for i in 1..n repeat
        c := coefficients(f.i)
        den.i := commonDenominator(c)$CommonDenominator(D, F, List F)
        g.i := map(retract(#1*den.i)@D, f.i) 
                  $FAMR2(NonNegativeInteger, Fraction D, VF, D, V)

      M := generalInterpolation(C, coeffAction, g, eta)$FFFG(D, V)

-- The following is necessary since I'm multiplying each row with a factor, not
-- each column. Possibly I could factor out gcd den, but I'm not sure whether
-- this is efficient.

      multiplyRows!(den, M)

    generalInterpolation(C: List D, coeffAction: CoeffAction, 
                         f: Vector VF, 
                         sumEta: NonNegativeInteger,
                         maxEta: NonNegativeInteger)
                        : Stream Matrix SUP D == 

      n := #f
      g: Vector V   := new(n, 0)
      den: Vector D := new(n, 0)

      for i in 1..n repeat
        c := coefficients(f.i)
        den.i := commonDenominator(c)$CommonDenominator(D, F, List F)
        g.i := map(retract(#1*den.i)@D, f.i)
                  $FAMR2(NonNegativeInteger, Fraction D, VF, D, V)

      c: cFunction := generalCoefficient(coeffAction, g,
                                         (#1-1)::NonNegativeInteger, #2)$FFFG(D, V)


      MS: Stream Matrix SUP D 
         := generalInterpolation(C, coeffAction, g, sumEta, maxEta)$FFFG(D, V)

-- The following is necessary since I'm multiplying each row with a factor, not
-- each column. Possibly I could factor out gcd den, but I'm not sure whether
-- this is efficient.

      map(multiplyRows!(den, #1), MS)$Stream(Matrix SUP D)

@
<<FFFGF.dotabb>>=
"FFFGF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFFGF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"FFFGF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FRAC2 FractionFunctions2}
\pagehead{FractionFunctions2}{FRAC2}
\pagepic{ps/v104fractionfunctions2.ps}{FRAC2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FRAC2 FractionFunctions2>>=
)abbrev package FRAC2 FractionFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: This package extends a map between integral domains to
++ a map between Fractions over those domains by applying the map to the
++ numerators and denominators.
FractionFunctions2(A, B): Exports == Impl where
  A, B: IntegralDomain

  R ==> Fraction A
  S ==> Fraction B

  Exports ==> with
    map: (A -> B, R) -> S
      ++ map(func,frac) applies the function func to the numerator
      ++ and denominator of the fraction frac.

  Impl ==> add
    map(f, r) == map(f, r)$QuotientFieldCategoryFunctions2(A, B, R, S)

@
<<FRAC2.dotabb>>=
"FRAC2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FRAC2"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"FRAC2" -> "ALGEBRA"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FRNAAF2 FramedNonAssociativeAlgebraFunctions2}
\pagehead{FramedNonAssociativeAlgebraFunctions2}{FRNAAF2}
\pagepic{ps/v104framednonassociativealgebrafunctions2.ps}{FRNAAF2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FRNAAF2 FramedNonAssociativeAlgebraFunctions2>>=
)abbrev package FRNAAF2 FramedNonAssociativeAlgebraFunctions2
++ Author: Johannes Grabmeier
++ Date Created: 28 February 1992
++ Date Last Updated: 28 February 1992
++ Basic Operations: map
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: non-associative algebra
++ References:
++ Description:
++  FramedNonAssociativeAlgebraFunctions2 implements functions between
++  two framed non associative algebra domains defined over different rings.
++  The function map is used to coerce between algebras over different
++  domains having the same structural constants.

FramedNonAssociativeAlgebraFunctions2(AR,R,AS,S) : Exports ==
  Implementation where
    R  : CommutativeRing
    S  : CommutativeRing
    AR : FramedNonAssociativeAlgebra R
    AS : FramedNonAssociativeAlgebra S
    V ==> Vector
    Exports ==> with
      map:     (R -> S, AR) -> AS
        ++ map(f,u) maps f onto the coordinates of u to get an element
        ++ in \spad{AS} via identification of the basis of \spad{AR}
        ++ as beginning part of the basis of \spad{AS}.
    Implementation ==> add
      map(fn : R -> S, u : AR): AS ==
        rank()$AR > rank()$AS => error("map: ranks of algebras do not fit")
        vr : V R := coordinates u
        vs : V S := map(fn,vr)$VectorFunctions2(R,S)
@
This line used to read:
\begin{verbatim}
        rank()$AR = rank()$AR => represents(vs)$AS
\end{verbatim}
but the test is clearly always true and cannot be what was intended.
Gregory Vanuxem supplied the fix below.
<<package FRNAAF2 FramedNonAssociativeAlgebraFunctions2>>=
        rank()$AR = rank()$AS => represents(vs)$AS
        ba := basis()$AS
        represents(vs,[ba.i for i in 1..rank()$AR])

@
<<FRNAAF2.dotabb>>=
"FRNAAF2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FRNAAF2"]
"FRNAALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRNAALG"]
"FRNAAF2" -> "FRNAALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSPECF FunctionalSpecialFunction}
\pagehead{FunctionalSpecialFunction}{FSPECF}
\pagepic{ps/v104functionalspecialfunction.ps}{FSPECF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSPECF FunctionalSpecialFunction>>=
)abbrev package FSPECF FunctionalSpecialFunction
++ Provides the special functions
++ Author: Manuel Bronstein
++ Date Created: 18 Apr 1989
++ Date Last Updated: 4 October 1993
++ Description: Provides some special functions over an integral domain.
++ Keywords: special, function.
FunctionalSpecialFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  OP  ==> BasicOperator
  K   ==> Kernel F
  SE  ==> Symbol
  SPECIALDIFF  ==> "%specialDiff"

  Exports ==> with
    belong? : OP -> Boolean
      ++ belong?(op) is true if op is a special function operator;
    operator: OP -> OP
      ++ operator(op) returns a copy of op with the domain-dependent
      ++ properties appropriate for F;
      ++ error if op is not a special function operator
    abs     : F -> F
      ++ abs(f) returns the absolute value operator applied to f
    Gamma   : F -> F
      ++ Gamma(f) returns the formal Gamma function applied to f
    Gamma   : (F,F) -> F
      ++ Gamma(a,x) returns the incomplete Gamma function applied to a and x
    Beta:      (F,F) -> F
      ++ Beta(x,y) returns the beta function applied to x and y
    digamma:   F->F
      ++ digamma(x) returns the digamma function applied to x 
    polygamma: (F,F) ->F
      ++ polygamma(x,y) returns the polygamma function applied to x and y
    besselJ:   (F,F) -> F
      ++ besselJ(x,y) returns the besselj function applied to x and y
    besselY:   (F,F) -> F
      ++ besselY(x,y) returns the bessely function applied to x and y
    besselI:   (F,F) -> F
      ++ besselI(x,y) returns the besseli function applied to x and y
    besselK:   (F,F) -> F
      ++ besselK(x,y) returns the besselk function applied to x and y
    airyAi:    F -> F
      ++ airyAi(x) returns the airyai function applied to x 
    airyBi:    F -> F
      ++ airyBi(x) returns the airybi function applied to x

@

In case we want to have more special function operators here, do not forget to
add them to the list [[specop]] in [[CommonOperators]].  Otherwise they will
not have the \lq special\rq\ attribute and will not be recognised here.  One
effect could be that
\begin{verbatim}
myNewSpecOp(1::Expression Integer)::Expression DoubleFloat
\end{verbatim}
might not re-evaluate the operator.

<<package FSPECF FunctionalSpecialFunction>>=
    iiGamma : F -> F
      ++ iiGamma(x) should be local but conditional;
    iiabs     : F -> F
      ++ iiabs(x) should be local but conditional;
    iiBeta     : List F -> F
      ++ iiGamma(x) should be local but conditional;
    iidigamma  : F -> F
      ++ iidigamma(x) should be local but conditional;
    iipolygamma: List F -> F
      ++ iipolygamma(x) should be local but conditional;
    iiBesselJ  : List F -> F
      ++ iiBesselJ(x) should be local but conditional;
    iiBesselY  : List F -> F
      ++ iiBesselY(x) should be local but conditional;
    iiBesselI  : List F -> F
      ++ iiBesselI(x) should be local but conditional;
    iiBesselK  : List F -> F
      ++ iiBesselK(x) should be local but conditional;
    iiAiryAi   : F -> F
      ++ iiAiryAi(x) should be local but conditional;
    iiAiryBi   : F -> F
      ++ iiAiryBi(x) should be local but conditional;

  Implementation ==> add
    iabs      : F -> F
    iGamma    : F -> F
    iBeta     : (F, F) -> F
    idigamma  : F -> F
    iiipolygamma: (F, F) -> F
    iiiBesselJ  : (F, F) -> F
    iiiBesselY  : (F, F) -> F
    iiiBesselI  : (F, F) -> F
    iiiBesselK  : (F, F) -> F
    iAiryAi   : F -> F
    iAiryBi   : F -> F

    opabs       := operator("abs"::Symbol)$CommonOperators
    opGamma     := operator("Gamma"::Symbol)$CommonOperators
    opGamma2    := operator("Gamma2"::Symbol)$CommonOperators
    opBeta      := operator("Beta"::Symbol)$CommonOperators
    opdigamma   := operator("digamma"::Symbol)$CommonOperators
    oppolygamma := operator("polygamma"::Symbol)$CommonOperators
    opBesselJ   := operator("besselJ"::Symbol)$CommonOperators
    opBesselY   := operator("besselY"::Symbol)$CommonOperators
    opBesselI   := operator("besselI"::Symbol)$CommonOperators
    opBesselK   := operator("besselK"::Symbol)$CommonOperators
    opAiryAi    := operator("airyAi"::Symbol)$CommonOperators
    opAiryBi    := operator("airyBi"::Symbol)$CommonOperators

    abs x         == opabs x
    Gamma(x)      == opGamma(x)
    Gamma(a,x)    == opGamma2(a,x)
    Beta(x,y)     == opBeta(x,y)
    digamma x     == opdigamma(x)
    polygamma(k,x)== oppolygamma(k,x)
    besselJ(a,x)  == opBesselJ(a,x)
    besselY(a,x)  == opBesselY(a,x)
    besselI(a,x)  == opBesselI(a,x)
    besselK(a,x)  == opBesselK(a,x)
    airyAi(x)     == opAiryAi(x)
    airyBi(x)     == opAiryBi(x)

    belong? op == has?(op, "special")

    operator op ==
      is?(op, "abs"::Symbol)      => opabs
      is?(op, "Gamma"::Symbol)    => opGamma
      is?(op, "Gamma2"::Symbol)   => opGamma2
      is?(op, "Beta"::Symbol)     => opBeta
      is?(op, "digamma"::Symbol)  => opdigamma
      is?(op, "polygamma"::Symbol)=> oppolygamma
      is?(op, "besselJ"::Symbol)  => opBesselJ
      is?(op, "besselY"::Symbol)  => opBesselY
      is?(op, "besselI"::Symbol)  => opBesselI
      is?(op, "besselK"::Symbol)  => opBesselK
      is?(op, "airyAi"::Symbol)   => opAiryAi
      is?(op, "airyBi"::Symbol)   => opAiryBi

      error "Not a special operator"

    -- Could put more unconditional special rules for other functions here
    iGamma x ==
--      one? x => x
      (x = 1) => x
      kernel(opGamma, x)

    iabs x ==
      zero? x => 0
      is?(x, opabs) => x
      x < 0 => kernel(opabs, -x)
      kernel(opabs, x)

    iBeta(x, y) == kernel(opBeta, [x, y])
    idigamma x == kernel(opdigamma, x)
    iiipolygamma(n, x) == kernel(oppolygamma, [n, x])
    iiiBesselJ(x, y) == kernel(opBesselJ, [x, y])
    iiiBesselY(x, y) == kernel(opBesselY, [x, y])
    iiiBesselI(x, y) == kernel(opBesselI, [x, y])
    iiiBesselK(x, y) == kernel(opBesselK, [x, y])
    iAiryAi x == kernel(opAiryAi, x)
    iAiryBi x == kernel(opAiryBi, x)


    -- Could put more conditional special rules for other functions here

    if R has abs : R -> R then
      iiabs x ==
        (r := retractIfCan(x)@Union(Fraction Polynomial R, "failed"))
          case "failed" => iabs x
        f := r::Fraction Polynomial R
        (a := retractIfCan(numer f)@Union(R, "failed")) case "failed" or
          (b := retractIfCan(denom f)@Union(R,"failed")) case "failed" => iabs x
        abs(a::R)::F / abs(b::R)::F

    else iiabs x == iabs x

    if R has SpecialFunctionCategory then
      iiGamma x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iGamma x
        Gamma(r::R)::F

      iiBeta l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iBeta(first l, second l)
        Beta(r::R, s::R)::F

      iidigamma x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => idigamma x
        digamma(r::R)::F

      iipolygamma l ==
        (s:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (r:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiipolygamma(first l, second l)
        polygamma(s::R, r::R)::F

      iiBesselJ l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselJ(first l, second l)
        besselJ(r::R, s::R)::F

      iiBesselY l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselY(first l, second l)
        besselY(r::R, s::R)::F

      iiBesselI l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselI(first l, second l)
        besselI(r::R, s::R)::F

      iiBesselK l ==
        (r:=retractIfCan(first l)@Union(R,"failed")) case "failed" or _
        (s:=retractIfCan(second l)@Union(R,"failed")) case "failed" _
            => iiiBesselK(first l, second l)
        besselK(r::R, s::R)::F

      iiAiryAi x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iAiryAi x
        airyAi(r::R)::F

      iiAiryBi x ==
        (r:=retractIfCan(x)@Union(R,"failed")) case "failed" => iAiryBi x
        airyBi(r::R)::F

    else
      if R has RetractableTo Integer then
        iiGamma x ==
          (r := retractIfCan(x)@Union(Integer, "failed")) case Integer
            and (r::Integer >= 1) => factorial(r::Integer - 1)::F
          iGamma x
      else
        iiGamma x == iGamma x

      iiBeta l == iBeta(first l, second l)
      iidigamma x == idigamma x 
      iipolygamma l == iiipolygamma(first l, second l)
      iiBesselJ l == iiiBesselJ(first l, second l) 
      iiBesselY l == iiiBesselY(first l, second l)
      iiBesselI l == iiiBesselI(first l, second l)
      iiBesselK l == iiiBesselK(first l, second l)
      iiAiryAi x == iAiryAi x
      iiAiryBi x == iAiryBi x

    -- Default behaviour is to build a kernel
    evaluate(opGamma, iiGamma)$BasicOperatorFunctions1(F)
    evaluate(opabs, iiabs)$BasicOperatorFunctions1(F)
--    evaluate(opGamma2    ,iiGamma2   )$BasicOperatorFunctions1(F)
    evaluate(opBeta      ,iiBeta     )$BasicOperatorFunctions1(F)
    evaluate(opdigamma   ,iidigamma  )$BasicOperatorFunctions1(F)
    evaluate(oppolygamma ,iipolygamma)$BasicOperatorFunctions1(F)
    evaluate(opBesselJ   ,iiBesselJ  )$BasicOperatorFunctions1(F)
    evaluate(opBesselY   ,iiBesselY  )$BasicOperatorFunctions1(F)
    evaluate(opBesselI   ,iiBesselI  )$BasicOperatorFunctions1(F)
    evaluate(opBesselK   ,iiBesselK  )$BasicOperatorFunctions1(F)
    evaluate(opAiryAi    ,iiAiryAi   )$BasicOperatorFunctions1(F)
    evaluate(opAiryBi    ,iiAiryBi   )$BasicOperatorFunctions1(F)
@

\subsection{differentiation of special functions}

In the following we define the symbolic derivatives of the special functions we
provide.  The formulas we use for the Bessel functions can be found in Milton
Abramowitz and Irene A. Stegun, eds.  (1965). Handbook of Mathematical
Functions with Formulas, Graphs, and Mathematical Tables. New York: Dover. ISBN
0-486-61272-4, Equations~9.1.27 and 9.6.26.  Up to [[patch--50]] the formula
for $K$ missed the minus sign.  (Issue~\#355)

We do not attempt to provide formulas for the derivative with respect to the
first argument currently.  Instead, we leave such derivatives unevaluated.

<<package FSPECF FunctionalSpecialFunction>>=
    import Fraction Integer
    ahalf:  F    := recip(2::F)::F
    athird: F    := recip(2::F)::F
    twothirds: F := 2*recip(3::F)::F
@

We need to get hold of the differentiation operator as modified by
[[FunctionSpace]]. Otherwise, for example, display will be ugly.  We accomplish
that by differentiating an operator, which will certainly result in a single
kernel only.

<<package FSPECF FunctionalSpecialFunction>>=
    dummyArg: SE := new()$SE
    opdiff := operator first kernels D((operator(new()$SE)$BasicOperator)
                                            (dummyArg::F), dummyArg)
@

The differentiation operator [[opdiff]] takes three arguments corresponding to
$$
F_{,i}(a_1,a_2,\dots,a_n):
$$
\begin{enumerate}
\item $F(a_1,...,dm,...a_n)$, where the $i$\textsuperscript{th} argument is a
  dummy variable,
\item $dm$, the dummy variable, and
\item $a_i$, the point at which the differential is evaluated.
\end{enumerate}

In the following, it seems to be safe to use the same dummy variable
troughout.  At least, this is done also in [[FunctionSpace]], and did not cause
problems.

The operation [[symbolicGrad]] returns the first component of the gradient of
[[op l]].

<<package FSPECF FunctionalSpecialFunction>>=
    dm := new()$SE :: F

    iBesselJ(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselJ [dm, x], dm, n])
          + differentiate(x, t) * ahalf * (besselJ (n-1,x) - besselJ (n+1,x))

    iBesselY(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselY [dm, x], dm, n])
          + differentiate(x, t) * ahalf * (besselY (n-1,x) - besselY (n+1,x))

    iBesselI(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselI [dm, x], dm, n])
          + differentiate(x, t)* ahalf * (besselI (n-1,x) + besselI (n+1,x))

    iBesselK(l: List F, t: SE): F ==
        n := first l; x := second l
        differentiate(n, t)*kernel(opdiff, [opBesselK [dm, x], dm, n])
          - differentiate(x, t)* ahalf * (besselK (n-1,x) + besselK (n+1,x))

@

For the moment we throw an error if we try to differentiate [[polygamma]] with
respect to the first argument.

<<package FSPECF FunctionalSpecialFunction>>=
    ipolygamma(l: List F, x: SE): F ==
        member?(x, variables first l) =>
            error "cannot differentiate polygamma with respect to the first argument"
        n := first l; y := second l
        differentiate(y, x)*polygamma(n+1, y)
    iBetaGrad1(l: List F): F ==
        x := first l; y := second l
        Beta(x,y)*(digamma x - digamma(x+y))
    iBetaGrad2(l: List F): F ==
        x := first l; y := second l
        Beta(x,y)*(digamma y - digamma(x+y))

    if F has ElementaryFunctionCategory then
      iGamma2(l: List F, t: SE): F ==
        a := first l; x := second l
        differentiate(a, t)*kernel(opdiff, [opGamma2 [dm, x], dm, a])
          - differentiate(x, t)* x ** (a - 1) * exp(-x)
      setProperty(opGamma2, SPECIALDIFF, iGamma2@((List F, SE)->F) 
                                                 pretend None)
@

Finally, we tell Axiom to use these functions for differentiation.  Note that
up to [[patch--50]], the properties for the Bessel functions were set using
[[derivative(oppolygamma, [lzero, ipolygammaGrad])]], where [[lzero]] returned
zero always.  Trying to replace [[lzero]] by a function that returns the first
component of the gradient failed, it resulted in an infinite loop for
[[integrate(D(besselJ(a,x),a),a)]].

<<package FSPECF FunctionalSpecialFunction>>=
    derivative(opabs,       abs(#1) * inv(#1))
    derivative(opGamma,     digamma #1 * Gamma #1)
    derivative(opBeta,      [iBetaGrad1, iBetaGrad2])
    derivative(opdigamma,   polygamma(1, #1))
    setProperty(oppolygamma, SPECIALDIFF, ipolygamma@((List F, SE)->F)
                                                     pretend None)
    setProperty(opBesselJ, SPECIALDIFF, iBesselJ@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselY, SPECIALDIFF, iBesselY@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselI, SPECIALDIFF, iBesselI@((List F, SE)->F) 
                                                 pretend None)
    setProperty(opBesselK, SPECIALDIFF, iBesselK@((List F, SE)->F) 
                                                 pretend None)

@
<<FSPECF.dotabb>>=
"FSPECF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSPECF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"FSPECF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFCAT2 FunctionFieldCategoryFunctions2}
\pagehead{FunctionFieldCategoryFunctions2}{FFCAT2}
\pagepic{ps/v104functionfieldcategoryfunctions2.ps}{FFCAT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFCAT2 FunctionFieldCategoryFunctions2>>=
)abbrev package FFCAT2 FunctionFieldCategoryFunctions2
++ Lifts a map from rings to function fields over them
++ Author: Manuel Bronstein
++ Date Created: May 1988
++ Date Last Updated: 26 Jul 1988
++ Description: Lifts a map from rings to function fields over them.
FunctionFieldCategoryFunctions2(R1, UP1, UPUP1, F1, R2, UP2, UPUP2, F2):
 Exports == Implementation where
  R1   : UniqueFactorizationDomain
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  F1   : FunctionFieldCategory(R1, UP1, UPUP1)
  R2   : UniqueFactorizationDomain
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2
  F2   : FunctionFieldCategory(R2, UP2, UPUP2)

  Exports ==> with
    map: (R1 -> R2, F1) -> F2
      ++ map(f, p) lifts f to F1 and applies it to p.

  Implementation ==> add
    map(f, f1) ==
      reduce(map(f, lift f1)$MultipleMap(R1, UP1, UPUP1, R2, UP2, UPUP2))

@
<<FFCAT2.dotabb>>=
"FFCAT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFCAT2"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"FFCAT2" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FFINTBAS FunctionFieldIntegralBasis}
\pagehead{FunctionFieldIntegralBasis}{FFINTBAS}
\pagepic{ps/v104functionfieldintegralbasis.ps}{FFINTBAS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FFINTBAS FunctionFieldIntegralBasis>>=
)abbrev package FFINTBAS FunctionFieldIntegralBasis
++ Integral bases for function fields of dimension one
++ Author: Victor Miller
++ Date Created: 9 April 1990
++ Date Last Updated: 20 September 1994
++ Keywords:
++ Examples:
++ References:
++ Description:
++ In this package R is a Euclidean domain and F is a framed algebra
++ over R.  The package provides functions to compute the integral
++ closure of R in the quotient field of F.  It is assumed that
++ \spad{char(R/P) = char(R)} for any prime P of R.  A typical instance of
++ this is when \spad{R = K[x]} and F is a function field over R.


FunctionFieldIntegralBasis(R,UP,F): Exports == Implementation where
  R  : EuclideanDomain with 
	squareFree: $ -> Factored $
		++ squareFree(x) returns a square-free factorisation of x 
  UP : UnivariatePolynomialCategory R
  F  : FramedAlgebra(R,UP)

  I   ==> Integer
  Mat ==> Matrix R
  NNI ==> NonNegativeInteger

  Exports ==> with
    integralBasis : () -> Record(basis: Mat, basisDen: R, basisInv:Mat)
      ++ \spad{integralBasis()} returns a record
      ++ \spad{[basis,basisDen,basisInv]} containing information regarding
      ++ the integral closure of R in the quotient field of F, where
      ++ F is a framed algebra with R-module basis \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.
    localIntegralBasis : R -> Record(basis: Mat, basisDen: R, basisInv:Mat)
      ++ \spad{integralBasis(p)} returns a record
      ++ \spad{[basis,basisDen,basisInv]} containing information regarding
      ++ the local integral closure of R at the prime \spad{p} in the quotient
      ++ field of F, where F is a framed algebra with R-module basis
      ++ \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the local integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.

  Implementation ==> add
    import IntegralBasisTools(R, UP, F)
    import ModularHermitianRowReduction(R)
    import TriangularMatrixOperations(R, Vector R, Vector R, Matrix R)

    squaredFactors: R -> R
    squaredFactors px ==
           */[(if ffe.exponent > 1 then ffe.factor else 1$R)
                for ffe in factors squareFree px]

    iIntegralBasis: (Mat,R,R) -> Record(basis: Mat, basisDen: R, basisInv:Mat)
    iIntegralBasis(tfm,disc,sing) ==
      -- tfm = trace matrix of current order
      n := rank()$F; tfm0 := copy tfm; disc0 := disc
      rb := scalarMatrix(n, 1); rbinv := scalarMatrix(n, 1)
      -- rb    = basis matrix of current order
      -- rbinv = inverse basis matrix of current order
      -- these are wrt the original basis for F
      rbden : R := 1; index : R := 1; oldIndex : R := 1
      -- rbden = denominator for current basis matrix
      -- index = index of original order in current order
      not sizeLess?(1, sing) => [rb, rbden, rbinv]
      repeat
        -- compute the p-radical
        idinv := transpose squareTop rowEchelon(tfm, sing)
        -- [u1,..,un] are the coordinates of an element of the p-radical
        -- iff [u1,..,un] * idinv is in sing * R^n
        id := rowEchelon LowTriBddDenomInv(idinv, sing)
        -- id = basis matrix of the p-radical
        idinv := UpTriBddDenomInv(id, sing)
        -- id * idinv = sing * identity
        -- no need to check for inseparability in this case
        rbinv := idealiser(id * rb, rbinv * idinv, sing * rbden)
        index := diagonalProduct rbinv
        rb := rowEchelon LowTriBddDenomInv(rbinv, rbden * sing)
        g := matrixGcd(rb,sing,n)
        if sizeLess?(1,g) then rb := (rb exquo g) :: Mat
        rbden := rbden * (sing quo g)
        rbinv := UpTriBddDenomInv(rb, rbden)
        disc := disc0 quo (index * index)
        indexChange := index quo oldIndex; oldIndex := index
        sing := gcd(indexChange, squaredFactors disc)
        not sizeLess?(1, sing) => return [rb, rbden, rbinv]
        tfm := ((rb * tfm0 * transpose rb) exquo (rbden * rbden)) :: Mat

    integralBasis() ==
      n := rank()$F; p := characteristic()$F
      (not zero? p) and (n >= p) =>
        error "integralBasis: possible wild ramification"
      tfm := traceMatrix()$F; disc := determinant tfm
      sing := squaredFactors disc    -- singularities of relative Spec
      iIntegralBasis(tfm,disc,sing)

    localIntegralBasis prime ==
      n := rank()$F; p := characteristic()$F
      (not zero? p) and (n >= p) =>
        error "integralBasis: possible wild ramification"
      tfm := traceMatrix()$F; disc := determinant tfm
      (disc exquo (prime * prime)) case "failed" =>
        [scalarMatrix(n,1),1,scalarMatrix(n,1)]
      iIntegralBasis(tfm,disc,prime)

@
<<FFINTBAS.dotabb>>=
"FFINTBAS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FFINTBAS"]
"FRAMALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRAMALG"]
"FFINTBAS" -> "FRAMALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMASSFS FunctionSpaceAssertions}
\pagehead{FunctionSpaceAssertions}{PMASSFS}
\pagepic{ps/v104functionspaceassertions.ps}{PMASSFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMASSFS FunctionSpaceAssertions>>=
)abbrev package PMASSFS FunctionSpaceAssertions
++ Assertions for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching assertions to symbols for pattern matching;
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
FunctionSpaceAssertions(R, F): Exports == Implementation where
  R: OrderedSet
  F: FunctionSpace R

  K  ==> Kernel F
  PMOPT   ==> "%pmoptional"
  PMMULT  ==> "%pmmultiple"
  PMCONST ==> "%pmconstant"

  Exports ==> with
    assert  : (F, String) -> F
      ++ assert(x, s) makes the assertion s about x.
      ++ Error: if x is not a symbol.
    constant: F -> F
      ++ constant(x) tells the pattern matcher that x should
      ++ match only the symbol 'x and no other quantity.
      ++ Error: if x is not a symbol.
    optional: F -> F
      ++ optional(x) tells the pattern matcher that x can match
      ++ an identity (0 in a sum, 1 in a product or exponentiation).
      ++ Error: if x is not a symbol.
    multiple: F -> F
      ++ multiple(x) tells the pattern matcher that x should
      ++ preferably match a multi-term quantity in a sum or product.
      ++ For matching on lists, multiple(x) tells the pattern matcher
      ++ that x should match a list instead of an element of a list.
      ++ Error: if x is not a symbol.

  Implementation ==> add
    ass  : (K, String) -> F
    asst : (K, String) -> F
    mkk  : BasicOperator -> F

    mkk op == kernel(op, empty()$List(F))

    ass(k, s) ==
      has?(op := operator k, s) => k::F
      mkk assert(copy op, s)

    asst(k, s) ==
      has?(op := operator k, s) => k::F
      mkk assert(op, s)

    assert(x, s) ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        asst(retract(x)@K, s)
      error "assert must be applied to symbols only"

    constant x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMCONST)
      error "constant must be applied to symbols only"

    optional x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMOPT)
      error "optional must be applied to symbols only"

    multiple x ==
      retractIfCan(x)@Union(Symbol, "failed") case Symbol =>
        ass(retract(x)@K, PMMULT)
      error "multiple must be applied to symbols only"

@
<<PMASSFS.dotabb>>=
"PMASSFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMASSFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PMASSFS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMPREDFS FunctionSpaceAttachPredicates}
\pagehead{FunctionSpaceAttachPredicates}{PMPREDFS}
\pagepic{ps/v104functionspaceattachpredicates.ps}{PMPREDFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMPREDFS FunctionSpaceAttachPredicates>>=
)abbrev package PMPREDFS FunctionSpaceAttachPredicates
++ Predicates for pattern-matching.
++ Author: Manuel Bronstein
++ Description: Attaching predicates to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
FunctionSpaceAttachPredicates(R, F, D): Exports == Implementation where
  R: OrderedSet
  F: FunctionSpace R
  D: Type

  K  ==> Kernel F
  PMPRED  ==> "%pmpredicate"

  Exports ==> with
    suchThat: (F, D -> Boolean) -> F
      ++ suchThat(x, foo) attaches the predicate foo to x;
      ++ error if x is not a symbol.
    suchThat: (F, List(D -> Boolean)) -> F
      ++ suchThat(x, [f1, f2, ..., fn]) attaches the predicate
      ++ f1 and f2 and ... and fn to x.
      ++ Error: if x is not a symbol.

  Implementation ==> add
    import AnyFunctions1(D -> Boolean)

    st   : (K, List Any) -> F
    preds: K -> List Any
    mkk  : BasicOperator -> F

    suchThat(p:F, f:D -> Boolean) == suchThat(p, [f])
    mkk op                        == kernel(op, empty()$List(F))

    preds k ==
      (u := property(operator k, PMPRED)) case "failed" => empty()
      (u::None) pretend List(Any)

    st(k, l) ==
      mkk assert(setProperty(copy operator k, PMPRED,
                 concat(preds k, l) pretend None), string(new()$Symbol))

    suchThat(p:F, l:List(D -> Boolean)) ==
      retractIfCan(p)@Union(Symbol, "failed") case Symbol =>
        st(retract(p)@K, [f::Any for f in l])
      error "suchThat must be applied to symbols only"

@
<<PMPREDFS.dotabb>>=
"PMPREDFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMPREDFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PMPREDFS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSCINT FunctionSpaceComplexIntegration}
\pagehead{FunctionSpaceComplexIntegration}{FSCINT}
\pagepic{ps/v104functionspacecomplexintegration.ps}{FSCINT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSCINT FunctionSpaceComplexIntegration>>=
)abbrev package FSCINT FunctionSpaceComplexIntegration
++ Top-level complex function integration
++ Author: Manuel Bronstein
++ Date Created: 4 February 1988
++ Date Last Updated: 11 June 1993
++ Description:
++   \spadtype{FunctionSpaceComplexIntegration} provides functions for the
++   indefinite integration of complex-valued functions.
++ Keywords: function, integration.
FunctionSpaceComplexIntegration(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)
 
  SE  ==> Symbol
  G   ==> Complex R
  FG  ==> Expression G
  IR  ==> IntegrationResult F
 
  Exports ==> with
    internalIntegrate : (F, SE) -> IR
        ++ internalIntegrate(f, x) returns the integral of \spad{f(x)dx}
        ++ where x is viewed as a complex variable.
    internalIntegrate0: (F, SE) -> IR
        ++ internalIntegrate0 should be a local function, but is conditional.
    complexIntegrate  : (F, SE) -> F
        ++ complexIntegrate(f, x) returns the integral of \spad{f(x)dx}
        ++ where x is viewed as a complex variable.
 
  Implementation ==> add
    import IntegrationTools(R, F)
    import ElementaryIntegration(R, F)
    import ElementaryIntegration(G, FG)
    import AlgebraicManipulations(R, F)
    import AlgebraicManipulations(G, FG)
    import TrigonometricManipulations(R, F)
    import IntegrationResultToFunction(R, F)
    import IntegrationResultFunctions2(FG, F)
    import ElementaryFunctionStructurePackage(R, F)
    import ElementaryFunctionStructurePackage(G, FG)
    import InnerTrigonometricManipulations(R, F, FG)
 
    K2KG: Kernel F -> Kernel FG
 
    K2KG k                 == retract(tan F2FG first argument k)@Kernel(FG)
 
    complexIntegrate(f, x) ==
      removeConstantTerm(complexExpand internalIntegrate(f, x), x)
 
    if R has Join(ConvertibleTo Pattern Integer, PatternMatchable Integer)
      and F has Join(LiouvillianFunctionCategory, RetractableTo SE) then
        import PatternMatchIntegration(R, F)
        internalIntegrate0(f, x) ==
          intPatternMatch(f, x, lfintegrate, pmComplexintegrate)
 
    else internalIntegrate0(f, x) == lfintegrate(f, x)
 
    internalIntegrate(f, x) ==
      f := distribute(f, x::F)
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
        | member?(x, variables(k::F))]$List(Kernel F))$List(Kernel F) =>
          h := trigs2explogs(F2FG g, [K2KG k for k in tower f
                         | is?(k, "tan"::SE) or is?(k, "cot"::SE)], [x])
          real?(g := FG2F h) =>
            internalIntegrate0(rootSimp(rischNormalize(g, x).func), x)
          real?(g := FG2F(h := rootSimp(rischNormalize(h, x).func))) =>
                                                       internalIntegrate0(g, x)
          map(FG2F, lfintegrate(h, x))
      internalIntegrate0(rootSimp(rischNormalize(g, x).func), x)

@
<<FSCINT.dotabb>>=
"FSCINT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSCINT"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"FSCINT" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FS2 FunctionSpaceFunctions2}
\pagehead{FunctionSpaceFunctions2}{FS2}
\pagepic{ps/v104functionspacefunctions2.ps}{FS2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FS2 FunctionSpaceFunctions2>>=
)abbrev package FS2 FunctionSpaceFunctions2
++ Lifting of maps to function spaces
++ Author: Manuel Bronstein
++ Date Created: 22 March 1988
++ Date Last Updated: 3 May 1994
++ Description:
++   This package allows a mapping R -> S to be lifted to a mapping
++   from a function space over R to a function space over S;
FunctionSpaceFunctions2(R, A, S, B): Exports == Implementation where
  R, S: Join(Ring, OrderedSet)
  A   : FunctionSpace R
  B   : FunctionSpace S

  K  ==> Kernel A
  P  ==> SparseMultivariatePolynomial(R, K)

  Exports ==> with
    map: (R -> S, A) -> B
      ++ map(f, a) applies f to all the constants in R appearing in \spad{a}.

  Implementation ==> add
    smpmap: (R -> S, P) -> B

    smpmap(fn, p) ==
      map(map(map(fn, #1), #1)$ExpressionSpaceFunctions2(A,B),fn(#1)::B,
        p)$PolynomialCategoryLifting(IndexedExponents K, K, R, P, B)

    if R has IntegralDomain then
      if S has IntegralDomain then
        map(f, x) == smpmap(f, numer x) / smpmap(f, denom x)
      else
        map(f, x) == smpmap(f, numer x) * (recip(smpmap(f, denom x))::B)
    else
      map(f, x) == smpmap(f, numer x)

@
<<FS2.dotabb>>=
"FS2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FS2"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"FS2" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSINT FunctionSpaceIntegration}
\pagehead{FunctionSpaceIntegration}{FSINT}
\pagepic{ps/v104functionspaceintegration.ps}{FSINT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSINT FunctionSpaceIntegration>>=
)abbrev package FSINT FunctionSpaceIntegration
++ Top-level real function integration
++ Author: Manuel Bronstein
++ Date Created: 4 February 1988
++ Date Last Updated: 11 June 1993
++ Keywords: function, integration.
++ Description:
++   \spadtype{FunctionSpaceIntegration} provides functions for the
++   indefinite integration of real-valued functions.
++ Examples: )r INTEF INPUT
FunctionSpaceIntegration(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory, PrimitiveFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)
 
  B   ==> Boolean
  G   ==> Complex R
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  SE  ==> Symbol
  IR  ==> IntegrationResult F
  FG  ==> Expression G
  ALGOP ==> "%alg"
  TANTEMP ==> "%temptan"::SE
 
  Exports ==> with
    integrate: (F, SE) -> Union(F, List F)
        ++ integrate(f, x) returns the integral of \spad{f(x)dx}
        ++ where x is viewed as a real variable.
 
  Implementation ==> add
    import IntegrationTools(R, F)
    import ElementaryIntegration(R, F)
    import ElementaryIntegration(G, FG)
    import AlgebraicManipulations(R, F)
    import TrigonometricManipulations(R, F)
    import IntegrationResultToFunction(R, F)
    import TranscendentalManipulations(R, F)
    import IntegrationResultFunctions2(FG, F)
    import FunctionSpaceComplexIntegration(R, F)
    import ElementaryFunctionStructurePackage(R, F)
    import InnerTrigonometricManipulations(R, F, FG)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                      K, R, SparseMultivariatePolynomial(R, K), F)
 
    K2KG      : K -> Kernel FG
    postSubst : (F, List F, List K, B, List K, SE) -> F
    rinteg    : (IR, F, SE, B, B) -> Union(F, List F)
    mkPrimh   : (F, SE, B, B) -> F
    trans?    : F -> B
    goComplex?: (B, List K, List K) -> B
    halfangle : F -> F
    Khalf     : K -> F
    tan2temp  : K -> K
 
    optemp:BasicOperator := operator(TANTEMP, 1)
 
    K2KG k     == retract(tan F2FG first argument k)@Kernel(FG)
    tan2temp k == kernel(optemp, argument k, height k)$K
 
    trans? f ==
      any?(is?(#1,"log"::SE) or is?(#1,"exp"::SE) or is?(#1,"atan"::SE),
           operators f)$List(BasicOperator)
 
    mkPrimh(f, x, h, comp) ==
      f := real f
      if comp then f := removeSinSq f
      g := mkPrim(f, x)
      h and trans? g => htrigs g
      g
 
    rinteg(i, f, x, h, comp) ==
      not elem? i => integral(f, x)$F
      empty? rest(l := [mkPrimh(f, x, h, comp) for f in expand i]) => first l
      l
 
-- replace tan(a/2)**2 by (1-cos a)/(1+cos a) if tan(a/2) is in ltan
    halfangle a ==
      a := 2 * a
      (1 - cos a) / (1 + cos a)
 
    Khalf k ==
      a := 2 * first argument k
      sin(a) / (1 + cos a)
 
-- ltan = list of tangents in the integrand after real normalization
    postSubst(f, lv, lk, comp, ltan, x) ==
      for v in lv for k in lk repeat
        if ((u := retractIfCan(v)@Union(K, "failed")) case K) then
           if has?(operator(kk := u::K), ALGOP) then
             f := univariate(f, kk, minPoly kk) (kk::F)
           f := eval(f, [u::K], [k::F])
      if not(comp or empty? ltan) then
        ltemp := [tan2temp k for k in ltan]
        f := eval(f, ltan, [k::F for k in ltemp])
        f := eval(f, TANTEMP, 2, halfangle)
        f := eval(f, ltemp, [Khalf k for k in ltemp])
      removeConstantTerm(f, x)
 
-- can handle a single unnested tangent directly, otherwise go complex for now
-- l is the list of all the kernels containing x
-- ltan is the list of all the tangents in l
    goComplex?(rt, l, ltan) ==
      empty? ltan => rt
      not empty? rest rest l
 
    integrate(f, x) ==
      not real? f => complexIntegrate(f, x)
      f   := distribute(f, x::F)
      tf  := [k for k in tower f | member?(x, variables(k::F)@List(SE))]$List(K)
      ltf := select(is?(operator #1, "tan"::SE), tf)
      ht  := any?(has?(operator #1, "htrig"), tf)
      rec := rischNormalize(realElementary(f, x), x)
      g   := rootSimp(rec.func)
      tg  := [k for k in tower g | member?(x, variables(k::F))]$List(K)
      ltg := select(is?(operator #1, "tan"::SE), tg)
      rtg := any?(has?(operator #1, "rtrig"), tg)
      el  := any?(has?(operator #1, "elem"), tg)
      i:IR
      if (comp := goComplex?(rtg, tg, ltg)) then
        i := map(FG2F, lfintegrate(trigs2explogs(F2FG g,
                       [K2KG k for k in tf | is?(k, "tan"::SE) or
                            is?(k, "cot"::SE)], [x]), x))
      else i := lfintegrate(g, x)
      ltg := setDifference(ltg, ltf)   -- tan's added by normalization
      (u := rinteg(i, f, x, el and ht, comp)) case F =>
        postSubst(u::F, rec.vals, rec.kers, comp, ltg, x)
      [postSubst(h, rec.vals, rec.kers, comp, ltg, x) for h in u::List(F)]

@
<<FSINT.dotabb>>=
"FSINT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSINT"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"FSINT" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUMFS FunctionSpaceSum}
\pagehead{FunctionSpaceSum}{SUMFS}
\pagepic{ps/v104functionspacesum.ps}{SUMFS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUMFS FunctionSpaceSum>>=
)abbrev package SUMFS FunctionSpaceSum
++ Top-level sum function
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 19 April 1991
++ Description: computes sums of top-level expressions;
FunctionSpaceSum(R, F): Exports == Implementation where
  R: Join(IntegralDomain, OrderedSet,
          RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F: Join(FunctionSpace R, CombinatorialOpsCategory,
          AlgebraicallyClosedField, TranscendentalFunctionCategory)

  SE  ==> Symbol
  K   ==> Kernel F

  Exports ==> with
    sum: (F, SE) -> F
      ++ sum(a(n), n) returns A(n) such that A(n+1) - A(n) = a(n);
    sum: (F, SegmentBinding F) -> F
      ++ sum(f(n), n = a..b) returns f(a) + f(a+1) + ... + f(b);

  Implementation ==> add
    import ElementaryFunctionStructurePackage(R, F)
    import GosperSummationMethod(IndexedExponents K, K, R,
                                 SparseMultivariatePolynomial(R, K), F)

    innersum: (F, K) -> Union(F, "failed")
    notRF?  : (F, K) -> Boolean
    newk    : () -> K

    newk() == kernel(new()$SE)

    sum(x:F, s:SegmentBinding F) ==
      k := kernel(variable s)@K
      (u := innersum(x, k)) case "failed" => summation(x, s)
      eval(u::F, k, 1 + hi segment s) - eval(u::F, k, lo segment s)

    sum(x:F, v:SE) ==
      (u := innersum(x, kernel(v)@K)) case "failed" => summation(x,v)
      u::F

    notRF?(f, k) ==
      for kk in tower f repeat
        member?(k, tower(kk::F)) and (symbolIfCan(kk) case "failed") =>
          return true
      false

    innersum(x, k) ==
      zero? x => 0
      notRF?(f := normalize(x / (x1 := eval(x, k, k::F - 1))), k) =>
        "failed"
      (u := GospersMethod(f, k, newk)) case "failed" => "failed"
      x1 * eval(u::F, k, k::F - 1)

@
<<SUMFS.dotabb>>=
"SUMFS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUMFS"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"SUMFS" -> "FS"
"SUMFS" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FS2EXPXP FunctionSpaceToExponentialExpansion}
\pagehead{FunctionSpaceToExponentialExpansion}{FS2EXPXP}
\pagepic{ps/v104functionspacetoexponentialexpansion.ps}{FS2EXPXP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FS2EXPXP FunctionSpaceToExponentialExpansion>>=
)abbrev package FS2EXPXP FunctionSpaceToExponentialExpansion
++ Author: Clifton J. Williamson
++ Date Created: 17 August 1992
++ Date Last Updated: 2 December 1994
++ Basic Operations:
++ Related Domains: ExponentialExpansion, UnivariatePuiseuxSeries(FE,x,cen)
++ Also See: FunctionSpaceToUnivariatePowerSeries
++ AMS Classifications:
++ Keywords: elementary function, power series
++ Examples:
++ References:
++ Description:
++   This package converts expressions in some function space to exponential
++   expansions.
FunctionSpaceToExponentialExpansion(R,FE,x,cen):_
     Exports == Implementation where
  R     : Join(GcdDomain,OrderedSet,RetractableTo Integer,_
               LinearlyExplicitRingOver Integer)
  FE    : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
               FunctionSpace R)
  x     : Symbol
  cen   : FE
  B        ==> Boolean
  BOP      ==> BasicOperator
  Expon    ==> Fraction Integer
  I        ==> Integer
  NNI      ==> NonNegativeInteger
  K        ==> Kernel FE
  L        ==> List
  RN       ==> Fraction Integer
  S        ==> String
  SY       ==> Symbol
  PCL      ==> PolynomialCategoryLifting(IndexedExponents K,K,R,SMP,FE)
  POL      ==> Polynomial R
  SMP      ==> SparseMultivariatePolynomial(R,K)
  SUP      ==> SparseUnivariatePolynomial Polynomial R
  UTS      ==> UnivariateTaylorSeries(FE,x,cen)
  ULS      ==> UnivariateLaurentSeries(FE,x,cen)
  UPXS     ==> UnivariatePuiseuxSeries(FE,x,cen)
  EFULS    ==> ElementaryFunctionsUnivariateLaurentSeries(FE,UTS,ULS)
  EFUPXS   ==> ElementaryFunctionsUnivariatePuiseuxSeries(FE,ULS,UPXS,EFULS)
  FS2UPS   ==> FunctionSpaceToUnivariatePowerSeries(R,FE,RN,UPXS,EFUPXS,x)
  EXPUPXS  ==> ExponentialOfUnivariatePuiseuxSeries(FE,x,cen)
  UPXSSING ==> UnivariatePuiseuxSeriesWithExponentialSingularity(R,FE,x,cen)
  XXP      ==> ExponentialExpansion(R,FE,x,cen)
  Problem  ==> Record(func:String,prob:String)
  Result   ==> Union(%series:UPXS,%problem:Problem)
  XResult  ==> Union(%expansion:XXP,%problem:Problem)
  SIGNEF   ==> ElementaryFunctionSign(R,FE)

  Exports ==> with
    exprToXXP : (FE,B) -> XResult
      ++ exprToXXP(fcn,posCheck?) converts the expression \spad{fcn} to
      ++ an exponential expansion.  If \spad{posCheck?} is true,
      ++ log's of negative numbers are not allowed nor are nth roots of
      ++ negative numbers with n even.  If \spad{posCheck?} is false,
      ++ these are allowed.
    localAbs: FE -> FE
      ++ localAbs(fcn) = \spad{abs(fcn)} or \spad{sqrt(fcn**2)} depending
      ++ on whether or not FE has a function \spad{abs}.  This should be
      ++ a local function, but the compiler won't allow it.

  Implementation ==> add

    import FS2UPS  -- conversion of functional expressions to Puiseux series
    import EFUPXS  -- partial transcendental funtions on UPXS

    ratIfCan            : FE -> Union(RN,"failed")
    stateSeriesProblem  : (S,S) -> Result
    stateProblem        : (S,S) -> XResult
    newElem             : FE -> FE
    smpElem             : SMP -> FE
    k2Elem              : K -> FE
    iExprToXXP          : (FE,B) -> XResult
    listToXXP           : (L FE,B,XXP,(XXP,XXP) -> XXP) -> XResult
    isNonTrivPower      : FE -> Union(Record(val:FE,exponent:I),"failed")
    negativePowerOK?    : UPXS -> Boolean
    powerToXXP          : (FE,I,B) -> XResult
    carefulNthRootIfCan : (UPXS,NNI,B) -> Result
    nthRootXXPIfCan     : (XXP,NNI,B) -> XResult
    nthRootToXXP        : (FE,NNI,B) -> XResult
    genPowerToXXP       : (L FE,B) -> XResult
    kernelToXXP         : (K,B) -> XResult
    genExp              : (UPXS,B) -> Result
    exponential         : (UPXS,B) -> XResult
    expToXXP            : (FE,B) -> XResult
    genLog              : (UPXS,B) -> Result
    logToXXP            : (FE,B) -> XResult
    applyIfCan          : (UPXS -> Union(UPXS,"failed"),FE,S,B) -> XResult
    applyBddIfCan       : (FE,UPXS -> Union(UPXS,"failed"),FE,S,B) -> XResult
    tranToXXP           : (K,FE,B) -> XResult
    contOnReals?        : S -> B
    bddOnReals?         : S -> B
    opsInvolvingX       : FE -> L BOP
    opInOpList?         : (SY,L BOP) -> B
    exponential?        : FE -> B
    productOfNonZeroes? : FE -> B
    atancotToXXP        : (FE,FE,B,I) -> XResult

    ZEROCOUNT : RN := 1000/1
    -- number of zeroes to be removed when taking logs or nth roots

--% retractions

    ratIfCan fcn == retractIfCan(fcn)@Union(RN,"failed")

--% 'problems' with conversion

    stateSeriesProblem(function,problem) ==
      -- records the problem which occured in converting an expression
      -- to a power series
      [[function,problem]]

    stateProblem(function,problem) ==
      -- records the problem which occured in converting an expression
      -- to an exponential expansion
      [[function,problem]]

--% normalizations

    newElem f ==
      -- rewrites a functional expression; all trig functions are
      -- expressed in terms of sin and cos; all hyperbolic trig
      -- functions are expressed in terms of exp; all inverse
      -- hyperbolic trig functions are expressed in terms of exp
      -- and log
      smpElem(numer f) / smpElem(denom f)

    smpElem p == map(k2Elem,#1::FE,p)$PCL

    k2Elem k ==
    -- rewrites a kernel; all trig functions are
    -- expressed in terms of sin and cos; all hyperbolic trig
    -- functions are expressed in terms of exp
      null(args := [newElem a for a in argument k]) => k :: FE
      iez  := inv(ez  := exp(z := first args))
      sinz := sin z; cosz := cos z
      is?(k,"tan" :: SY)  => sinz / cosz
      is?(k,"cot" :: SY)  => cosz / sinz
      is?(k,"sec" :: SY)  => inv cosz
      is?(k,"csc" :: SY)  => inv sinz
      is?(k,"sinh" :: SY) => (ez - iez) / (2 :: FE)
      is?(k,"cosh" :: SY) => (ez + iez) / (2 :: FE)
      is?(k,"tanh" :: SY) => (ez - iez) / (ez + iez)
      is?(k,"coth" :: SY) => (ez + iez) / (ez - iez)
      is?(k,"sech" :: SY) => 2 * inv(ez + iez)
      is?(k,"csch" :: SY) => 2 * inv(ez - iez)
      is?(k,"acosh" :: SY) => log(sqrt(z**2 - 1) + z)
      is?(k,"atanh" :: SY) => log((z + 1) / (1 - z)) / (2 :: FE)
      is?(k,"acoth" :: SY) => log((z + 1) / (z - 1)) / (2 :: FE)
      is?(k,"asech" :: SY) => log((inv z) + sqrt(inv(z**2) - 1))
      is?(k,"acsch" :: SY) => log((inv z) + sqrt(1 + inv(z**2)))
      (operator k) args

--% general conversion function

    exprToXXP(fcn,posCheck?) == iExprToXXP(newElem fcn,posCheck?)

    iExprToXXP(fcn,posCheck?) ==
      -- converts a functional expression to an exponential expansion
      --!! The following line is commented out so that expressions of
      --!! the form a**b will be normalized to exp(b * log(a)) even if
      --!! 'a' and 'b' do not involve the limiting variable 'x'.
      --!!                         - cjw 1 Dec 94
      --not member?(x,variables fcn) => [monomial(fcn,0)$UPXS :: XXP]
      (poly := retractIfCan(fcn)@Union(POL,"failed")) case POL =>
        [exprToUPS(fcn,false,"real:two sides").%series :: XXP]
      (sum := isPlus fcn) case L(FE) =>
        listToXXP(sum :: L(FE),posCheck?,0,#1 + #2)
      (prod := isTimes fcn) case L(FE) =>
        listToXXP(prod :: L(FE),posCheck?,1,#1 * #2)
      (expt := isNonTrivPower fcn) case Record(val:FE,exponent:I) =>
        power := expt :: Record(val:FE,exponent:I)
        powerToXXP(power.val,power.exponent,posCheck?)
      (ker := retractIfCan(fcn)@Union(K,"failed")) case K =>
        kernelToXXP(ker :: K,posCheck?)
      error "exprToXXP: neither a sum, product, power, nor kernel"

--% sums and products

    listToXXP(list,posCheck?,ans,op) ==
      -- converts each element of a list of expressions to an exponential
      -- expansion and returns the sum of these expansions, when 'op' is +
      -- and 'ans' is 0, or the product of these expansions, when 'op' is *
      -- and 'ans' is 1
      while not null list repeat
        (term := iExprToXXP(first list,posCheck?)) case %problem =>
          return term
        ans := op(ans,term.%expansion)
        list := rest list
      [ans]

--% nth roots and integral powers

    isNonTrivPower fcn ==
      -- is the function a power with exponent other than 0 or 1?
      (expt := isPower fcn) case "failed" => "failed"
      power := expt :: Record(val:FE,exponent:I)
--      one? power.exponent => "failed"
      (power.exponent = 1) => "failed"
      power

    negativePowerOK? upxs ==
      -- checks the lower order coefficient of a Puiseux series;
      -- the coefficient may be inverted only if
      -- (a) the only function involving x is 'log', or
      -- (b) the lowest order coefficient is a product of exponentials
      --     and functions not involving x
      deg := degree upxs
      if (coef := coefficient(upxs,deg)) = 0 then
        deg := order(upxs,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(upxs,deg)) = 0 =>
          error "inverse of series with many leading zero coefficients"
      xOpList := opsInvolvingX coef
      -- only function involving x is 'log'
      (null xOpList) => true
      (null rest xOpList and is?(first xOpList,"log" :: SY)) => true
      -- lowest order coefficient is a product of exponentials and
      -- functions not involving x
      productOfNonZeroes? coef => true
      false

    powerToXXP(fcn,n,posCheck?) ==
      -- converts an integral power to an exponential expansion
      (b := iExprToXXP(fcn,posCheck?)) case %problem => b
      xxp := b.%expansion
      n > 0 => [xxp ** n]
      -- a Puiseux series will be reciprocated only if n < 0 and
      -- numerator of 'xxp' has exactly one monomial
      numberOfMonomials(num := numer xxp) > 1 => [xxp ** n]
      negativePowerOK? leadingCoefficient num =>
        (rec := recip num) case "failed" => error "FS2EXPXP: can't happen"
        nn := (-n) :: NNI
        [(((denom xxp) ** nn) * ((rec :: UPXSSING) ** nn)) :: XXP]
      --!! we may want to create a fraction instead of trying to
      --!! reciprocate the numerator
      stateProblem("inv","lowest order coefficient involves x")

    carefulNthRootIfCan(ups,n,posCheck?) ==
      -- similar to 'nthRootIfCan', but it is fussy about the series
      -- it takes as an argument.  If 'n' is EVEN and 'posCheck?'
      -- is truem then the leading coefficient of the series must
      -- be POSITIVE.  In this case, if 'rightOnly?' is false, the
      -- order of the series must be zero.  The idea is that the
      -- series represents a real function of a real variable, and
      -- we want a unique real nth root defined on a neighborhood
      -- of zero.
      n < 1 => error "nthRoot: n must be positive"
      deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(ups,deg)) = 0 =>
          error "log of series with many leading zero coefficients"
      -- if 'posCheck?' is true, we do not allow nth roots of negative
      -- numbers when n in even
      if even?(n :: I) then
        if posCheck? and ((signum := sign(coef)$SIGNEF) case I) then
          (signum :: I) = -1 =>
            return stateSeriesProblem("nth root","root of negative number")
      (ans := nthRootIfCan(ups,n)) case "failed" =>
        stateSeriesProblem("nth root","no nth root")
      [ans :: UPXS]

    nthRootXXPIfCan(xxp,n,posCheck?) ==
      num := numer xxp; den := denom xxp
      not zero?(reductum num) or not zero?(reductum den) =>
       stateProblem("nth root","several monomials in numerator or denominator")
      nInv : RN := 1/n
      newNum :=
        coef : UPXS :=
          root := carefulNthRootIfCan(leadingCoefficient num,n,posCheck?)
          root case %problem => return [root.%problem]
          root.%series
        deg := (nInv :: FE) * (degree num)
        monomial(coef,deg)
      newDen :=
        coef : UPXS :=
          root := carefulNthRootIfCan(leadingCoefficient den,n,posCheck?)
          root case %problem => return [root.%problem]
          root.%series
        deg := (nInv :: FE) * (degree den)
        monomial(coef,deg)
      [newNum/newDen]

    nthRootToXXP(arg,n,posCheck?) ==
      -- converts an nth root to a power series
      -- this is not used in the limit package, so the series may
      -- have non-zero order, in which case nth roots may not be unique
      (result := iExprToXXP(arg,posCheck?)) case %problem => [result.%problem]
      ans := nthRootXXPIfCan(result.%expansion,n,posCheck?)
      ans case %problem => [ans.%problem]
      [ans.%expansion]

--% general powers f(x) ** g(x)

    genPowerToXXP(args,posCheck?) ==
      -- converts a power f(x) ** g(x) to an exponential expansion
      (logBase := logToXXP(first args,posCheck?)) case %problem =>
        logBase
      (expon := iExprToXXP(second args,posCheck?)) case %problem =>
        expon
      xxp := (expon.%expansion) * (logBase.%expansion)
      (f := retractIfCan(xxp)@Union(UPXS,"failed")) case "failed" =>
        stateProblem("exp","multiply nested exponential")
      exponential(f,posCheck?)

--% kernels

    kernelToXXP(ker,posCheck?) ==
      -- converts a kernel to a power series
      (sym := symbolIfCan(ker)) case Symbol =>
        (sym :: Symbol) = x => [monomial(1,1)$UPXS :: XXP]
        [monomial(ker :: FE,0)$UPXS :: XXP]
      empty?(args := argument ker) => [monomial(ker :: FE,0)$UPXS :: XXP]
      empty? rest args =>
        arg := first args
        is?(ker,"%paren" :: Symbol) => iExprToXXP(arg,posCheck?)
        is?(ker,"log" :: Symbol) => logToXXP(arg,posCheck?)
        is?(ker,"exp" :: Symbol) => expToXXP(arg,posCheck?)
        tranToXXP(ker,arg,posCheck?)
      is?(ker,"%power" :: Symbol) => genPowerToXXP(args,posCheck?)
      is?(ker,"nthRoot" :: Symbol) =>
        n := retract(second args)@I
        nthRootToXXP(first args,n :: NNI,posCheck?)
      stateProblem(string name ker,"unknown kernel")

--% exponentials and logarithms

    genExp(ups,posCheck?) ==
      -- If the series has order zero and the constant term a0 of the
      -- series involves x, the function tries to expand exp(a0) as
      -- a power series.
      (deg := order(ups,1)) < 0 =>
        -- this "can't happen"
        error "exp of function with sigularity"
      deg > 0 => [exp(ups)]
      lc := coefficient(ups,0); varOpList := opsInvolvingX lc
      not opInOpList?("log" :: Symbol,varOpList) => [exp(ups)]
      -- try to fix exp(lc) if necessary
      expCoef := normalize(exp lc,x)$ElementaryFunctionStructurePackage(R,FE)
      result := exprToGenUPS(expCoef,posCheck?,"real:right side")$FS2UPS
      --!! will deal with problems in limitPlus in EXPEXPAN
      --result case %problem => result
      result case %problem => [exp(ups)]
      [(result.%series) * exp(ups - monomial(lc,0))]

    exponential(f,posCheck?) ==
      singPart := truncate(f,0) - (coefficient(f,0) :: UPXS)
      taylorPart := f - singPart
      expon := exponential(singPart)$EXPUPXS
      (coef := genExp(taylorPart,posCheck?)) case %problem => [coef.%problem]
      [monomial(coef.%series,expon)$UPXSSING :: XXP]

    expToXXP(arg,posCheck?) ==
      (result := iExprToXXP(arg,posCheck?)) case %problem => result
      xxp := result.%expansion
      (f := retractIfCan(xxp)@Union(UPXS,"failed")) case "failed" =>
        stateProblem("exp","multiply nested exponential")
      exponential(f,posCheck?)

    genLog(ups,posCheck?) ==
      deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT)
        (coef := coefficient(ups,deg)) = 0 =>
          error "log of series with many leading zero coefficients"
      -- if 'posCheck?' is true, we do not allow logs of negative numbers
      if posCheck? then
        if ((signum := sign(coef)$SIGNEF) case I) then
          (signum :: I) = -1 =>
            return stateSeriesProblem("log","negative leading coefficient")
      lt := monomial(coef,deg)$UPXS
      -- check to see if lowest order coefficient is a negative rational
      negRat? : Boolean :=
        ((rat := ratIfCan coef) case RN) =>
          (rat :: RN) < 0 => true
          false
        false
      logTerm : FE :=
        mon : FE := (x :: FE) - (cen :: FE)
        pow : FE := mon ** (deg :: FE)
        negRat? => log(coef * pow)
        term1 : FE := (deg :: FE) * log(mon)
        log(coef) + term1
      [monomial(logTerm,0)$UPXS + log(ups/lt)]

    logToXXP(arg,posCheck?) ==
      (result := iExprToXXP(arg,posCheck?)) case %problem => result
      xxp := result.%expansion
      num := numer xxp; den := denom xxp
      not zero?(reductum num) or not zero?(reductum den) =>
        stateProblem("log","several monomials in numerator or denominator")
      numCoefLog : UPXS :=
        (res := genLog(leadingCoefficient num,posCheck?)) case %problem =>
          return [res.%problem]
        res.%series
      denCoefLog : UPXS :=
        (res := genLog(leadingCoefficient den,posCheck?)) case %problem =>
          return [res.%problem]
        res.%series
      numLog := (exponent degree num) + numCoefLog
      denLog := (exponent degree den) + denCoefLog  --?? num?
      [(numLog - denLog) :: XXP]

--% other transcendental functions

    applyIfCan(fcn,arg,fcnName,posCheck?) ==
      -- converts fcn(arg) to an exponential expansion
      (xxpArg := iExprToXXP(arg,posCheck?)) case %problem => xxpArg
      xxp := xxpArg.%expansion
      (f := retractIfCan(xxp)@Union(UPXS,"failed")) case "failed" =>
        stateProblem(fcnName,"multiply nested exponential")
      upxs := f :: UPXS
      (deg := order(upxs,1)) < 0 =>
        stateProblem(fcnName,"essential singularity")
      deg > 0 => [fcn(upxs) :: UPXS :: XXP]
      lc := coefficient(upxs,0); xOpList := opsInvolvingX lc
      null xOpList => [fcn(upxs) :: UPXS :: XXP]
      opInOpList?("log" :: SY,xOpList) =>
        stateProblem(fcnName,"logs in constant coefficient")
      contOnReals? fcnName => [fcn(upxs) :: UPXS :: XXP]
      stateProblem(fcnName,"x in constant coefficient")

    applyBddIfCan(fe,fcn,arg,fcnName,posCheck?) ==
      -- converts fcn(arg) to a generalized power series, where the
      -- function fcn is bounded for real values
      -- if fcn(arg) has an essential singularity as a complex
      -- function, we return fcn(arg) as a monomial of degree 0
      (xxpArg := iExprToXXP(arg,posCheck?)) case %problem =>
        trouble := xxpArg.%problem
        trouble.prob = "essential singularity" => [monomial(fe,0)$UPXS :: XXP]
        xxpArg
      xxp := xxpArg.%expansion
      (f := retractIfCan(xxp)@Union(UPXS,"failed")) case "failed" =>
        stateProblem("exp","multiply nested exponential")
      (ans := fcn(f :: UPXS)) case "failed" => [monomial(fe,0)$UPXS :: XXP]
      [ans :: UPXS :: XXP]

    CONTFCNS : L S := ["sin","cos","atan","acot","exp","asinh"]
    -- functions which are defined and continuous at all real numbers

    BDDFCNS : L S := ["sin","cos","atan","acot"]
    -- functions which are bounded on the reals

    contOnReals? fcn == member?(fcn,CONTFCNS)
    bddOnReals? fcn  == member?(fcn,BDDFCNS)

    opsInvolvingX fcn ==
      opList := [op for k in tower fcn | unary?(op := operator k) _
                 and member?(x,variables first argument k)]
      removeDuplicates opList

    opInOpList?(name,opList) ==
      for op in opList repeat
        is?(op,name) => return true
      false

    exponential? fcn ==
      -- is 'fcn' of the form exp(f)?
      (ker := retractIfCan(fcn)@Union(K,"failed")) case K =>
        is?(ker :: K,"exp" :: Symbol)
      false

    productOfNonZeroes? fcn ==
      -- is 'fcn' a product of non-zero terms, where 'non-zero'
      -- means an exponential or a function not involving x
      exponential? fcn => true
      (prod := isTimes fcn) case "failed" => false
      for term in (prod :: L(FE)) repeat
        (not exponential? term) and member?(x,variables term) =>
          return false
      true

    tranToXXP(ker,arg,posCheck?) ==
      -- converts op(arg) to a power series for certain functions
      -- op in trig or hyperbolic trig categories
      -- N.B. when this function is called, 'k2elem' will have been
      -- applied, so the following functions cannot appear:
      -- tan, cot, sec, csc, sinh, cosh, tanh, coth, sech, csch
      -- acosh, atanh, acoth, asech, acsch
      is?(ker,"sin" :: SY) =>
        applyBddIfCan(ker :: FE,sinIfCan,arg,"sin",posCheck?)
      is?(ker,"cos" :: SY) =>
        applyBddIfCan(ker :: FE,cosIfCan,arg,"cos",posCheck?)
      is?(ker,"asin" :: SY) =>
        applyIfCan(asinIfCan,arg,"asin",posCheck?)
      is?(ker,"acos" :: SY) =>
        applyIfCan(acosIfCan,arg,"acos",posCheck?)
      is?(ker,"atan" :: SY) =>
        atancotToXXP(ker :: FE,arg,posCheck?,1)
      is?(ker,"acot" :: SY) =>
        atancotToXXP(ker :: FE,arg,posCheck?,-1)
      is?(ker,"asec" :: SY) =>
        applyIfCan(asecIfCan,arg,"asec",posCheck?)
      is?(ker,"acsc" :: SY) =>
        applyIfCan(acscIfCan,arg,"acsc",posCheck?)
      is?(ker,"asinh" :: SY) =>
        applyIfCan(asinhIfCan,arg,"asinh",posCheck?)
      stateProblem(string name ker,"unknown kernel")

    if FE has abs: FE -> FE then
      localAbs fcn == abs fcn
    else
      localAbs fcn == sqrt(fcn * fcn)

    signOfExpression: FE -> FE
    signOfExpression arg == localAbs(arg)/arg

    atancotToXXP(fe,arg,posCheck?,plusMinus) ==
      -- converts atan(f(x)) to a generalized power series
      atanFlag : String := "real: right side"; posCheck? : Boolean := true
      (result := exprToGenUPS(arg,posCheck?,atanFlag)$FS2UPS) case %problem =>
        trouble := result.%problem
        trouble.prob = "essential singularity" => [monomial(fe,0)$UPXS :: XXP]
        [result.%problem]
      ups := result.%series; coef := coefficient(ups,0)
      -- series involves complex numbers
      (ord := order(ups,0)) = 0 and coef * coef = -1 =>
        y := differentiate(ups)/(1 + ups*ups)
        yCoef := coefficient(y,-1)
        [(monomial(log yCoef,0)+integrate(y - monomial(yCoef,-1)$UPXS)) :: XXP]
      cc : FE :=
        ord < 0 =>
          (rn := ratIfCan(ord :: FE)) case "failed" =>
            -- this condition usually won't occur because exponents will
            -- be integers or rational numbers
            return stateProblem("atan","branch problem")
          lc := coefficient(ups,ord)
          (signum := sign(lc)$SIGNEF) case "failed" =>
            -- can't determine sign
            posNegPi2 := signOfExpression(lc) * pi()/(2 :: FE)
            plusMinus = 1 => posNegPi2
            pi()/(2 :: FE) - posNegPi2
          (n := signum :: Integer) = -1 =>
            plusMinus = 1 => -pi()/(2 :: FE)
            pi()
          plusMinus = 1 => pi()/(2 :: FE)
          0
        atan coef
      [((cc :: UPXS) + integrate(differentiate(ups)/(1 + ups*ups))) :: XXP]

@
<<FS2EXPXP.dotabb>>=
"FS2EXPXP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FS2EXPXP"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"FS2EXPXP" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FS2UPS FunctionSpaceToUnivariatePowerSeries}
\pagehead{FunctionSpaceToUnivariatePowerSeries}{FS2UPS}
\pagepic{ps/v104functionspacetounivariatepowerseries.ps}{FS2UPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FS2UPS FunctionSpaceToUnivariatePowerSeries>>=
)abbrev package FS2UPS FunctionSpaceToUnivariatePowerSeries
++ Author: Clifton J. Williamson
++ Date Created: 21 March 1989
++ Date Last Updated: 2 December 1994
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: elementary function, power series
++ Examples:
++ References:
++ Description:
++   This package converts expressions in some function space to power
++   series in a variable x with coefficients in that function space.
++   The function \spadfun{exprToUPS} converts expressions to power series
++   whose coefficients do not contain the variable x. The function
++   \spadfun{exprToGenUPS} converts functional expressions to power series
++   whose coefficients may involve functions of \spad{log(x)}.
FunctionSpaceToUnivariatePowerSeries(R,FE,Expon,UPS,TRAN,x):_
 Exports == Implementation where
  R     : Join(GcdDomain,OrderedSet,RetractableTo Integer,_
               LinearlyExplicitRingOver Integer)
  FE    : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
               FunctionSpace R)
            with
              coerce: Expon -> %
                ++ coerce(e) converts an 'exponent' e to an 'expression'
  Expon : OrderedRing
  UPS   : Join(UnivariatePowerSeriesCategory(FE,Expon),Field,_
               TranscendentalFunctionCategory)
            with
              differentiate: % -> %
                ++ differentiate(x) returns the derivative of x since we 
                ++ need to be able to differentiate a power series
              integrate: % -> %
                ++ integrate(x) returns the integral of x since
                ++ we need to be able to integrate a power series
  TRAN  : PartialTranscendentalFunctions UPS
  x     : Symbol
  B       ==> Boolean
  BOP     ==> BasicOperator
  I       ==> Integer
  NNI     ==> NonNegativeInteger
  K       ==> Kernel FE
  L       ==> List
  RN      ==> Fraction Integer
  S       ==> String
  SY      ==> Symbol
  PCL     ==> PolynomialCategoryLifting(IndexedExponents K,K,R,SMP,FE)
  POL     ==> Polynomial R
  SMP     ==> SparseMultivariatePolynomial(R,K)
  SUP     ==> SparseUnivariatePolynomial Polynomial R
  Problem ==> Record(func:String,prob:String)
  Result  ==> Union(%series:UPS,%problem:Problem)
  SIGNEF  ==> ElementaryFunctionSign(R,FE)

  Exports ==> with
    exprToUPS : (FE,B,S) -> Result
      ++ exprToUPS(fcn,posCheck?,atanFlag) converts the expression
      ++ \spad{fcn} to a power series.  If \spad{posCheck?} is true,
      ++ log's of negative numbers are not allowed nor are nth roots of
      ++ negative numbers with n even.  If \spad{posCheck?} is false,
      ++ these are allowed.  \spad{atanFlag} determines how the case
      ++ \spad{atan(f(x))}, where \spad{f(x)} has a pole, will be treated.
      ++ The possible values of \spad{atanFlag} are \spad{"complex"},
      ++ \spad{"real: two sides"}, \spad{"real: left side"},
      ++ \spad{"real: right side"}, and \spad{"just do it"}.
      ++ If \spad{atanFlag} is \spad{"complex"}, then no series expansion
      ++ will be computed because, viewed as a function of a complex
      ++ variable, \spad{atan(f(x))} has an essential singularity.
      ++ Otherwise, the sign of the leading coefficient of the series
      ++ expansion of \spad{f(x)} determines the constant coefficient
      ++ in the series expansion of \spad{atan(f(x))}.  If this sign cannot
      ++ be determined, a series expansion is computed only when
      ++ \spad{atanFlag} is \spad{"just do it"}.  When the leading term
      ++ in the series expansion of \spad{f(x)} is of odd degree (or is a
      ++ rational degree with odd numerator), then the constant coefficient
      ++ in the series expansion of \spad{atan(f(x))} for values to the
      ++ left differs from that for values to the right.  If \spad{atanFlag}
      ++ is \spad{"real: two sides"}, no series expansion will be computed.
      ++ If \spad{atanFlag} is \spad{"real: left side"} the constant
      ++ coefficient for values to the left will be used and if \spad{atanFlag}
      ++ \spad{"real: right side"} the constant coefficient for values to the
      ++ right will be used.
      ++ If there is a problem in converting the function to a power series,
      ++ a record containing the name of the function that caused the problem
      ++ and a brief description of the problem is returned.
      ++ When expanding the expression into a series it is assumed that
      ++ the series is centered at 0.  For a series centered at a, the
      ++ user should perform the substitution \spad{x -> x + a} before calling
      ++ this function.

    exprToGenUPS : (FE,B,S) -> Result
      ++ exprToGenUPS(fcn,posCheck?,atanFlag) converts the expression
      ++ \spad{fcn} to a generalized power series.  If \spad{posCheck?}
      ++ is true, log's of negative numbers are not allowed nor are nth roots
      ++ of negative numbers with n even. If \spad{posCheck?} is false,
      ++ these are allowed.  \spad{atanFlag} determines how the case
      ++ \spad{atan(f(x))}, where \spad{f(x)} has a pole, will be treated.
      ++ The possible values of \spad{atanFlag} are \spad{"complex"},
      ++ \spad{"real: two sides"}, \spad{"real: left side"},
      ++ \spad{"real: right side"}, and \spad{"just do it"}.
      ++ If \spad{atanFlag} is \spad{"complex"}, then no series expansion
      ++ will be computed because, viewed as a function of a complex
      ++ variable, \spad{atan(f(x))} has an essential singularity.
      ++ Otherwise, the sign of the leading coefficient of the series
      ++ expansion of \spad{f(x)} determines the constant coefficient
      ++ in the series expansion of \spad{atan(f(x))}.  If this sign cannot
      ++ be determined, a series expansion is computed only when
      ++ \spad{atanFlag} is \spad{"just do it"}.  When the leading term
      ++ in the series expansion of \spad{f(x)} is of odd degree (or is a
      ++ rational degree with odd numerator), then the constant coefficient
      ++ in the series expansion of \spad{atan(f(x))} for values to the
      ++ left differs from that for values to the right.  If \spad{atanFlag}
      ++ is \spad{"real: two sides"}, no series expansion will be computed.
      ++ If \spad{atanFlag} is \spad{"real: left side"} the constant
      ++ coefficient for values to the left will be used and if \spad{atanFlag}
      ++ \spad{"real: right side"} the constant coefficient for values to the
      ++ right will be used.
      ++ If there is a problem in converting the function to a power
      ++ series, we return a record containing the name of the function
      ++ that caused the problem and a brief description of the problem.
      ++ When expanding the expression into a series it is assumed that
      ++ the series is centered at 0.  For a series centered at a, the
      ++ user should perform the substitution \spad{x -> x + a} before calling
      ++ this function.
    localAbs: FE -> FE
      ++ localAbs(fcn) = \spad{abs(fcn)} or \spad{sqrt(fcn**2)} depending
      ++ on whether or not FE has a function \spad{abs}.  This should be
      ++ a local function, but the compiler won't allow it.

  Implementation ==> add

    ratIfCan            : FE -> Union(RN,"failed")
    carefulNthRootIfCan : (UPS,NNI,B,B) -> Result
    stateProblem        : (S,S) -> Result
    polyToUPS           : SUP -> UPS
    listToUPS           : (L FE,(FE,B,S) -> Result,B,S,UPS,(UPS,UPS) -> UPS)_
                                            -> Result
    isNonTrivPower      : FE -> Union(Record(val:FE,exponent:I),"failed")
    powerToUPS          : (FE,I,B,S) -> Result
    kernelToUPS         : (K,B,S) -> Result
    nthRootToUPS        : (FE,NNI,B,S) -> Result
    logToUPS            : (FE,B,S) -> Result
    atancotToUPS        : (FE,B,S,I) -> Result
    applyIfCan          : (UPS -> Union(UPS,"failed"),FE,S,B,S) -> Result
    tranToUPS           : (K,FE,B,S) -> Result
    powToUPS            : (L FE,B,S) -> Result
    newElem             : FE -> FE
    smpElem             : SMP -> FE
    k2Elem              : K -> FE
    contOnReals?        : S -> B
    bddOnReals?         : S -> B
    iExprToGenUPS       : (FE,B,S) -> Result
    opsInvolvingX       : FE -> L BOP
    opInOpList?         : (SY,L BOP) -> B
    exponential?        : FE -> B
    productOfNonZeroes? : FE -> B
    powerToGenUPS       : (FE,I,B,S) -> Result
    kernelToGenUPS      : (K,B,S) -> Result
    nthRootToGenUPS     : (FE,NNI,B,S) -> Result
    logToGenUPS         : (FE,B,S) -> Result
    expToGenUPS         : (FE,B,S) -> Result
    expGenUPS           : (UPS,B,S) -> Result
    atancotToGenUPS     : (FE,FE,B,S,I) -> Result
    genUPSApplyIfCan    : (UPS -> Union(UPS,"failed"),FE,S,B,S) -> Result
    applyBddIfCan       : (FE,UPS -> Union(UPS,"failed"),FE,S,B,S) -> Result
    tranToGenUPS        : (K,FE,B,S) -> Result
    powToGenUPS         : (L FE,B,S) -> Result

    ZEROCOUNT : I := 1000
    -- number of zeroes to be removed when taking logs or nth roots

    ratIfCan fcn == retractIfCan(fcn)@Union(RN,"failed")

    carefulNthRootIfCan(ups,n,posCheck?,rightOnly?) ==
      -- similar to 'nthRootIfCan', but it is fussy about the series
      -- it takes as an argument.  If 'n' is EVEN and 'posCheck?'
      -- is truem then the leading coefficient of the series must
      -- be POSITIVE.  In this case, if 'rightOnly?' is false, the
      -- order of the series must be zero.  The idea is that the
      -- series represents a real function of a real variable, and
      -- we want a unique real nth root defined on a neighborhood
      -- of zero.
      n < 1 => error "nthRoot: n must be positive"
      deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(ups,deg)) = 0 =>
          error "log of series with many leading zero coefficients"
      -- if 'posCheck?' is true, we do not allow nth roots of negative
      -- numbers when n in even
      if even?(n :: I) then
        if posCheck? and ((signum := sign(coef)$SIGNEF) case I) then
          (signum :: I) = -1 =>
            return stateProblem("nth root","negative leading coefficient")
          not rightOnly? and not zero? deg => -- nth root not unique
            return stateProblem("nth root","series of non-zero order")
      (ans := nthRootIfCan(ups,n)) case "failed" =>
        stateProblem("nth root","no nth root")
      [ans :: UPS]

    stateProblem(function,problem) ==
      -- records the problem which occured in converting an expression
      -- to a power series
      [[function,problem]]

    exprToUPS(fcn,posCheck?,atanFlag) ==
      -- converts a functional expression to a power series
      --!! The following line is commented out so that expressions of
      --!! the form a**b will be normalized to exp(b * log(a)) even if
      --!! 'a' and 'b' do not involve the limiting variable 'x'.
      --!!                         - cjw 1 Dec 94
      --not member?(x,variables fcn) => [monomial(fcn,0)]
      (poly := retractIfCan(fcn)@Union(POL,"failed")) case POL =>
        [polyToUPS univariate(poly :: POL,x)]
      (sum := isPlus fcn) case L(FE) =>
        listToUPS(sum :: L(FE),exprToUPS,posCheck?,atanFlag,0,#1 + #2)
      (prod := isTimes fcn) case L(FE) =>
        listToUPS(prod :: L(FE),exprToUPS,posCheck?,atanFlag,1,#1 * #2)
      (expt := isNonTrivPower fcn) case Record(val:FE,exponent:I) =>
        power := expt :: Record(val:FE,exponent:I)
        powerToUPS(power.val,power.exponent,posCheck?,atanFlag)
      (ker := retractIfCan(fcn)@Union(K,"failed")) case K =>
        kernelToUPS(ker :: K,posCheck?,atanFlag)
      error "exprToUPS: neither a sum, product, power, nor kernel"

    polyToUPS poly ==
      -- converts a polynomial to a power series
      zero? poly => 0
      -- we don't start with 'ans := 0' as this may lead to an
      -- enormous number of leading zeroes in the power series
      deg  := degree poly
      coef := leadingCoefficient(poly) :: FE
      ans  := monomial(coef,deg :: Expon)$UPS
      poly := reductum poly
      while not zero? poly repeat
        deg  := degree poly
        coef := leadingCoefficient(poly) :: FE
        ans  := ans + monomial(coef,deg :: Expon)$UPS
        poly := reductum poly
      ans

    listToUPS(list,feToUPS,posCheck?,atanFlag,ans,op) ==
      -- converts each element of a list of expressions to a power
      -- series and returns the sum of these series, when 'op' is +
      -- and 'ans' is 0, or the product of these series, when 'op' is *
      -- and 'ans' is 1
      while not null list repeat
        (term := feToUPS(first list,posCheck?,atanFlag)) case %problem =>
          return term
        ans := op(ans,term.%series)
        list := rest list
      [ans]

    isNonTrivPower fcn ==
      -- is the function a power with exponent other than 0 or 1?
      (expt := isPower fcn) case "failed" => "failed"
      power := expt :: Record(val:FE,exponent:I)
--      one? power.exponent => "failed"
      (power.exponent = 1) => "failed"
      power

    powerToUPS(fcn,n,posCheck?,atanFlag) ==
      -- converts an integral power to a power series
      (b := exprToUPS(fcn,posCheck?,atanFlag)) case %problem => b
      n > 0 => [(b.%series) ** n]
      -- check lowest order coefficient when n < 0
      ups := b.%series; deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(ups,deg)) = 0 =>
          error "inverse of series with many leading zero coefficients"
      [ups ** n]

    kernelToUPS(ker,posCheck?,atanFlag) ==
      -- converts a kernel to a power series
      (sym := symbolIfCan(ker)) case Symbol =>
        (sym :: Symbol) = x => [monomial(1,1)]
        [monomial(ker :: FE,0)]
      empty?(args := argument ker) => [monomial(ker :: FE,0)]
      not member?(x, variables(ker :: FE)) => [monomial(ker :: FE,0)]
      empty? rest args =>
        arg := first args
        is?(ker,"abs" :: Symbol) =>
          nthRootToUPS(arg*arg,2,posCheck?,atanFlag)
        is?(ker,"%paren" :: Symbol) => exprToUPS(arg,posCheck?,atanFlag)
        is?(ker,"log" :: Symbol) => logToUPS(arg,posCheck?,atanFlag)
        is?(ker,"exp" :: Symbol) =>
          applyIfCan(expIfCan,arg,"exp",posCheck?,atanFlag)
        tranToUPS(ker,arg,posCheck?,atanFlag)
      is?(ker,"%power" :: Symbol) => powToUPS(args,posCheck?,atanFlag)
      is?(ker,"nthRoot" :: Symbol) =>
        n := retract(second args)@I
        nthRootToUPS(first args,n :: NNI,posCheck?,atanFlag)
      stateProblem(string name ker,"unknown kernel")

    nthRootToUPS(arg,n,posCheck?,atanFlag) ==
      -- converts an nth root to a power series
      -- this is not used in the limit package, so the series may
      -- have non-zero order, in which case nth roots may not be unique
      (result := exprToUPS(arg,posCheck?,atanFlag)) case %problem => result
      ans := carefulNthRootIfCan(result.%series,n,posCheck?,false)
      ans case %problem => ans
      [ans.%series]

    logToUPS(arg,posCheck?,atanFlag) ==
      -- converts a logarithm log(f(x)) to a power series
      -- f(x) must have order 0 and if 'posCheck?' is true,
      -- then f(x) must have a non-negative leading coefficient
      (result := exprToUPS(arg,posCheck?,atanFlag)) case %problem => result
      ups := result.%series
      not zero? order(ups,1) =>
        stateProblem("log","series of non-zero order")
      coef := coefficient(ups,0)
      -- if 'posCheck?' is true, we do not allow logs of negative numbers
      if posCheck? then
        if ((signum := sign(coef)$SIGNEF) case I) then
          (signum :: I) = -1 =>
            return stateProblem("log","negative leading coefficient")
      [logIfCan(ups) :: UPS]

    if FE has abs: FE -> FE then
      localAbs fcn == abs fcn
    else
      localAbs fcn == sqrt(fcn * fcn)

    signOfExpression: FE -> FE
    signOfExpression arg == localAbs(arg)/arg

    atancotToUPS(arg,posCheck?,atanFlag,plusMinus) ==
      -- converts atan(f(x)) to a power series
      (result := exprToUPS(arg,posCheck?,atanFlag)) case %problem => result
      ups := result.%series; coef := coefficient(ups,0)
      (ord := order(ups,0)) = 0 and coef * coef = -1 =>
        -- series involves complex numbers
        return stateProblem("atan","logarithmic singularity")
      cc : FE :=
        ord < 0 =>
          atanFlag = "complex" =>
            return stateProblem("atan","essential singularity")
          (rn := ratIfCan(ord :: FE)) case "failed" =>
            -- this condition usually won't occur because exponents will
            -- be integers or rational numbers
            return stateProblem("atan","branch problem")
          if (atanFlag = "real: two sides") and (odd? numer(rn :: RN)) then
            -- expansions to the left and right of zero have different
            -- constant coefficients
            return stateProblem("atan","branch problem")
          lc := coefficient(ups,ord)
          (signum := sign(lc)$SIGNEF) case "failed" =>
            -- can't determine sign
            atanFlag = "just do it" =>
              plusMinus = 1 => pi()/(2 :: FE)
              0
            posNegPi2 := signOfExpression(lc) * pi()/(2 :: FE)
            plusMinus = 1 => posNegPi2
            pi()/(2 :: FE) - posNegPi2
            --return stateProblem("atan","branch problem")
          left? : B := atanFlag = "real: left side"; n := signum :: Integer
          (left? and n = 1) or (not left? and n = -1) =>
            plusMinus = 1 => -pi()/(2 :: FE)
            pi()
          plusMinus = 1 => pi()/(2 :: FE)
          0
        atan coef
      [(cc :: UPS) + integrate(plusMinus * differentiate(ups)/(1 + ups*ups))]

    applyIfCan(fcn,arg,fcnName,posCheck?,atanFlag) ==
      -- converts fcn(arg) to a power series
      (ups := exprToUPS(arg,posCheck?,atanFlag)) case %problem => ups
      ans := fcn(ups.%series)
      ans case "failed" => stateProblem(fcnName,"essential singularity")
      [ans :: UPS]

    tranToUPS(ker,arg,posCheck?,atanFlag) ==
      -- converts ker to a power series for certain functions
      -- in trig or hyperbolic trig categories
      is?(ker,"sin" :: SY) =>
        applyIfCan(sinIfCan,arg,"sin",posCheck?,atanFlag)
      is?(ker,"cos" :: SY) =>
        applyIfCan(cosIfCan,arg,"cos",posCheck?,atanFlag)
      is?(ker,"tan" :: SY) =>
        applyIfCan(tanIfCan,arg,"tan",posCheck?,atanFlag)
      is?(ker,"cot" :: SY) =>
        applyIfCan(cotIfCan,arg,"cot",posCheck?,atanFlag)
      is?(ker,"sec" :: SY) =>
        applyIfCan(secIfCan,arg,"sec",posCheck?,atanFlag)
      is?(ker,"csc" :: SY) =>
        applyIfCan(cscIfCan,arg,"csc",posCheck?,atanFlag)
      is?(ker,"asin" :: SY) =>
        applyIfCan(asinIfCan,arg,"asin",posCheck?,atanFlag)
      is?(ker,"acos" :: SY) =>
        applyIfCan(acosIfCan,arg,"acos",posCheck?,atanFlag)
      is?(ker,"atan" :: SY) => atancotToUPS(arg,posCheck?,atanFlag,1)
      is?(ker,"acot" :: SY) => atancotToUPS(arg,posCheck?,atanFlag,-1)
      is?(ker,"asec" :: SY) =>
        applyIfCan(asecIfCan,arg,"asec",posCheck?,atanFlag)
      is?(ker,"acsc" :: SY) =>
        applyIfCan(acscIfCan,arg,"acsc",posCheck?,atanFlag)
      is?(ker,"sinh" :: SY) =>
        applyIfCan(sinhIfCan,arg,"sinh",posCheck?,atanFlag)
      is?(ker,"cosh" :: SY) =>
        applyIfCan(coshIfCan,arg,"cosh",posCheck?,atanFlag)
      is?(ker,"tanh" :: SY) =>
        applyIfCan(tanhIfCan,arg,"tanh",posCheck?,atanFlag)
      is?(ker,"coth" :: SY) =>
        applyIfCan(cothIfCan,arg,"coth",posCheck?,atanFlag)
      is?(ker,"sech" :: SY) =>
        applyIfCan(sechIfCan,arg,"sech",posCheck?,atanFlag)
      is?(ker,"csch" :: SY) =>
        applyIfCan(cschIfCan,arg,"csch",posCheck?,atanFlag)
      is?(ker,"asinh" :: SY) =>
        applyIfCan(asinhIfCan,arg,"asinh",posCheck?,atanFlag)
      is?(ker,"acosh" :: SY) =>
        applyIfCan(acoshIfCan,arg,"acosh",posCheck?,atanFlag)
      is?(ker,"atanh" :: SY) =>
        applyIfCan(atanhIfCan,arg,"atanh",posCheck?,atanFlag)
      is?(ker,"acoth" :: SY) =>
        applyIfCan(acothIfCan,arg,"acoth",posCheck?,atanFlag)
      is?(ker,"asech" :: SY) =>
        applyIfCan(asechIfCan,arg,"asech",posCheck?,atanFlag)
      is?(ker,"acsch" :: SY) =>
        applyIfCan(acschIfCan,arg,"acsch",posCheck?,atanFlag)
      stateProblem(string name ker,"unknown kernel")

    powToUPS(args,posCheck?,atanFlag) ==
      -- converts a power f(x) ** g(x) to a power series
      (logBase := logToUPS(first args,posCheck?,atanFlag)) case %problem =>
        logBase
      (expon := exprToUPS(second args,posCheck?,atanFlag)) case %problem =>
        expon
      ans := expIfCan((expon.%series) * (logBase.%series))
      ans case "failed" => stateProblem("exp","essential singularity")
      [ans :: UPS]

-- Generalized power series: power series in x, where log(x) and
-- bounded functions of x are allowed to appear in the coefficients
-- of the series.  Used for evaluating REAL limits at x = 0.

    newElem f ==
    -- rewrites a functional expression; all trig functions are
    -- expressed in terms of sin and cos; all hyperbolic trig
    -- functions are expressed in terms of exp
      smpElem(numer f) / smpElem(denom f)

    smpElem p == map(k2Elem,#1::FE,p)$PCL

    k2Elem k ==
    -- rewrites a kernel; all trig functions are
    -- expressed in terms of sin and cos; all hyperbolic trig
    -- functions are expressed in terms of exp
      null(args := [newElem a for a in argument k]) => k::FE
      iez  := inv(ez  := exp(z := first args))
      sinz := sin z; cosz := cos z
      is?(k,"tan" :: Symbol)  => sinz / cosz
      is?(k,"cot" :: Symbol)  => cosz / sinz
      is?(k,"sec" :: Symbol)  => inv cosz
      is?(k,"csc" :: Symbol)  => inv sinz
      is?(k,"sinh" :: Symbol) => (ez - iez) / (2 :: FE)
      is?(k,"cosh" :: Symbol) => (ez + iez) / (2 :: FE)
      is?(k,"tanh" :: Symbol) => (ez - iez) / (ez + iez)
      is?(k,"coth" :: Symbol) => (ez + iez) / (ez - iez)
      is?(k,"sech" :: Symbol) => 2 * inv(ez + iez)
      is?(k,"csch" :: Symbol) => 2 * inv(ez - iez)
      (operator k) args

    CONTFCNS : L S := ["sin","cos","atan","acot","exp","asinh"]
    -- functions which are defined and continuous at all real numbers

    BDDFCNS : L S := ["sin","cos","atan","acot"]
    -- functions which are bounded on the reals

    contOnReals? fcn == member?(fcn,CONTFCNS)
    bddOnReals? fcn  == member?(fcn,BDDFCNS)

    exprToGenUPS(fcn,posCheck?,atanFlag) ==
      -- converts a functional expression to a generalized power
      -- series; "generalized" means that log(x) and bounded functions
      -- of x are allowed to appear in the coefficients of the series
      iExprToGenUPS(newElem fcn,posCheck?,atanFlag)

    iExprToGenUPS(fcn,posCheck?,atanFlag) ==
      -- converts a functional expression to a generalized power
      -- series without first normalizing the expression
      --!! The following line is commented out so that expressions of
      --!! the form a**b will be normalized to exp(b * log(a)) even if
      --!! 'a' and 'b' do not involve the limiting variable 'x'.
      --!!                         - cjw 1 Dec 94
      --not member?(x,variables fcn) => [monomial(fcn,0)]
      (poly := retractIfCan(fcn)@Union(POL,"failed")) case POL =>
        [polyToUPS univariate(poly :: POL,x)]
      (sum := isPlus fcn) case L(FE) =>
        listToUPS(sum :: L(FE),iExprToGenUPS,posCheck?,atanFlag,0,#1 + #2)
      (prod := isTimes fcn) case L(FE) =>
        listToUPS(prod :: L(FE),iExprToGenUPS,posCheck?,atanFlag,1,#1 * #2)
      (expt := isNonTrivPower fcn) case Record(val:FE,exponent:I) =>
        power := expt :: Record(val:FE,exponent:I)
        powerToGenUPS(power.val,power.exponent,posCheck?,atanFlag)
      (ker := retractIfCan(fcn)@Union(K,"failed")) case K =>
        kernelToGenUPS(ker :: K,posCheck?,atanFlag)
      error "exprToGenUPS: neither a sum, product, power, nor kernel"

    opsInvolvingX fcn ==
      opList := [op for k in tower fcn | unary?(op := operator k) _
                 and member?(x,variables first argument k)]
      removeDuplicates opList

    opInOpList?(name,opList) ==
      for op in opList repeat
        is?(op,name) => return true
      false

    exponential? fcn ==
      -- is 'fcn' of the form exp(f)?
      (ker := retractIfCan(fcn)@Union(K,"failed")) case K =>
        is?(ker :: K,"exp" :: Symbol)
      false

    productOfNonZeroes? fcn ==
      -- is 'fcn' a product of non-zero terms, where 'non-zero'
      -- means an exponential or a function not involving x
      exponential? fcn => true
      (prod := isTimes fcn) case "failed" => false
      for term in (prod :: L(FE)) repeat
        (not exponential? term) and member?(x,variables term) =>
          return false
      true

    powerToGenUPS(fcn,n,posCheck?,atanFlag) ==
      -- converts an integral power to a generalized power series
      -- if n < 0 and the lowest order coefficient of the series
      -- involves x, we are careful about inverting this coefficient
      -- the coefficient is inverted only if
      -- (a) the only function involving x is 'log', or
      -- (b) the lowest order coefficient is a product of exponentials
      --     and functions not involving x
      (b := exprToGenUPS(fcn,posCheck?,atanFlag)) case %problem => b
      n > 0 => [(b.%series) ** n]
      -- check lowest order coefficient when n < 0
      ups := b.%series; deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(ups,deg)) = 0 =>
          error "inverse of series with many leading zero coefficients"
      xOpList := opsInvolvingX coef
      -- only function involving x is 'log'
      (null xOpList) => [ups ** n]
      (null rest xOpList and is?(first xOpList,"log" :: SY)) =>
        [ups ** n]
      -- lowest order coefficient is a product of exponentials and
      -- functions not involving x
      productOfNonZeroes? coef => [ups ** n]
      stateProblem("inv","lowest order coefficient involves x")

    kernelToGenUPS(ker,posCheck?,atanFlag) ==
      -- converts a kernel to a generalized power series
      (sym := symbolIfCan(ker)) case Symbol =>
        (sym :: Symbol) = x => [monomial(1,1)]
        [monomial(ker :: FE,0)]
      empty?(args := argument ker) => [monomial(ker :: FE,0)]
      empty? rest args =>
        arg := first args
        is?(ker,"abs" :: Symbol) =>
          nthRootToGenUPS(arg*arg,2,posCheck?,atanFlag)
        is?(ker,"%paren" :: Symbol) => iExprToGenUPS(arg,posCheck?,atanFlag)
        is?(ker,"log" :: Symbol) => logToGenUPS(arg,posCheck?,atanFlag)
        is?(ker,"exp" :: Symbol) => expToGenUPS(arg,posCheck?,atanFlag)
        tranToGenUPS(ker,arg,posCheck?,atanFlag)
      is?(ker,"%power" :: Symbol) => powToGenUPS(args,posCheck?,atanFlag)
      is?(ker,"nthRoot" :: Symbol) =>
        n := retract(second args)@I
        nthRootToGenUPS(first args,n :: NNI,posCheck?,atanFlag)
      stateProblem(string name ker,"unknown kernel")

    nthRootToGenUPS(arg,n,posCheck?,atanFlag) ==
      -- convert an nth root to a power series
      -- used for computing right hand limits, so the series may have
      -- non-zero order, but may not have a negative leading coefficient
      -- when n is even
      (result := iExprToGenUPS(arg,posCheck?,atanFlag)) case %problem =>
        result
      ans := carefulNthRootIfCan(result.%series,n,posCheck?,true)
      ans case %problem => ans
      [ans.%series]

    logToGenUPS(arg,posCheck?,atanFlag) ==
      -- converts a logarithm log(f(x)) to a generalized power series
      (result := iExprToGenUPS(arg,posCheck?,atanFlag)) case %problem =>
        result
      ups := result.%series; deg := degree ups
      if (coef := coefficient(ups,deg)) = 0 then
        deg := order(ups,deg + ZEROCOUNT :: Expon)
        (coef := coefficient(ups,deg)) = 0 =>
          error "log of series with many leading zero coefficients"
      -- if 'posCheck?' is true, we do not allow logs of negative numbers
      if posCheck? then
        if ((signum := sign(coef)$SIGNEF) case I) then
          (signum :: I) = -1 =>
            return stateProblem("log","negative leading coefficient")
      -- create logarithmic term, avoiding log's of negative rationals
      lt := monomial(coef,deg)$UPS; cen := center lt
      -- check to see if lowest order coefficient is a negative rational
      negRat? : Boolean :=
        ((rat := ratIfCan coef) case RN) =>
          (rat :: RN) < 0 => true
          false
        false
      logTerm : FE :=
        mon : FE := (x :: FE) - (cen :: FE)
        pow : FE := mon ** (deg :: FE)
        negRat? => log(coef * pow)
        term1 : FE := (deg :: FE) * log(mon)
        log(coef) + term1
      [monomial(logTerm,0) + log(ups/lt)]

    expToGenUPS(arg,posCheck?,atanFlag) ==
      -- converts an exponential exp(f(x)) to a generalized
      -- power series
      (ups := iExprToGenUPS(arg,posCheck?,atanFlag)) case %problem => ups
      expGenUPS(ups.%series,posCheck?,atanFlag)

    expGenUPS(ups,posCheck?,atanFlag) ==
      -- computes the exponential of a generalized power series.
      -- If the series has order zero and the constant term a0 of the
      -- series involves x, the function tries to expand exp(a0) as
      -- a power series.
      (deg := order(ups,1)) < 0 =>
        stateProblem("exp","essential singularity")
      deg > 0 => [exp ups]
      lc := coefficient(ups,0); xOpList := opsInvolvingX lc
      not opInOpList?("log" :: SY,xOpList) => [exp ups]
      -- try to fix exp(lc) if necessary
      expCoef :=
        normalize(exp lc,x)$ElementaryFunctionStructurePackage(R,FE)
      opInOpList?("log" :: SY,opsInvolvingX expCoef) =>
        stateProblem("exp","logs in constant coefficient")
      result := exprToGenUPS(expCoef,posCheck?,atanFlag)
      result case %problem => result
      [(result.%series) * exp(ups - monomial(lc,0))]

    atancotToGenUPS(fe,arg,posCheck?,atanFlag,plusMinus) ==
      -- converts atan(f(x)) to a generalized power series
      (result := exprToGenUPS(arg,posCheck?,atanFlag)) case %problem =>
        trouble := result.%problem
        trouble.prob = "essential singularity" => [monomial(fe,0)$UPS]
        result
      ups := result.%series; coef := coefficient(ups,0)
      -- series involves complex numbers
      (ord := order(ups,0)) = 0 and coef * coef = -1 =>
        y := differentiate(ups)/(1 + ups*ups)
        yCoef := coefficient(y,-1)
        [monomial(log yCoef,0) + integrate(y - monomial(yCoef,-1)$UPS)]
      cc : FE :=
        ord < 0 =>
          atanFlag = "complex" =>
            return stateProblem("atan","essential singularity")
          (rn := ratIfCan(ord :: FE)) case "failed" =>
            -- this condition usually won't occur because exponents will
            -- be integers or rational numbers
            return stateProblem("atan","branch problem")
          if (atanFlag = "real: two sides") and (odd? numer(rn :: RN)) then
            -- expansions to the left and right of zero have different
            -- constant coefficients
            return stateProblem("atan","branch problem")
          lc := coefficient(ups,ord)
          (signum := sign(lc)$SIGNEF) case "failed" =>
            -- can't determine sign
            atanFlag = "just do it" =>
              plusMinus = 1 => pi()/(2 :: FE)
              0
            posNegPi2 := signOfExpression(lc) * pi()/(2 :: FE)
            plusMinus = 1 => posNegPi2
            pi()/(2 :: FE) - posNegPi2
            --return stateProblem("atan","branch problem")
          left? : B := atanFlag = "real: left side"; n := signum :: Integer
          (left? and n = 1) or (not left? and n = -1) =>
            plusMinus = 1 => -pi()/(2 :: FE)
            pi()
          plusMinus = 1 => pi()/(2 :: FE)
          0
        atan coef
      [(cc :: UPS) + integrate(differentiate(ups)/(1 + ups*ups))]

    genUPSApplyIfCan(fcn,arg,fcnName,posCheck?,atanFlag) ==
      -- converts fcn(arg) to a generalized power series
      (series := iExprToGenUPS(arg,posCheck?,atanFlag)) case %problem =>
        series
      ups := series.%series
      (deg := order(ups,1)) < 0 =>
        stateProblem(fcnName,"essential singularity")
      deg > 0 => [fcn(ups) :: UPS]
      lc := coefficient(ups,0); xOpList := opsInvolvingX lc
      null xOpList => [fcn(ups) :: UPS]
      opInOpList?("log" :: SY,xOpList) =>
        stateProblem(fcnName,"logs in constant coefficient")
      contOnReals? fcnName => [fcn(ups) :: UPS]
      stateProblem(fcnName,"x in constant coefficient")

    applyBddIfCan(fe,fcn,arg,fcnName,posCheck?,atanFlag) ==
      -- converts fcn(arg) to a generalized power series, where the
      -- function fcn is bounded for real values
      -- if fcn(arg) has an essential singularity as a complex
      -- function, we return fcn(arg) as a monomial of degree 0
      (ups := iExprToGenUPS(arg,posCheck?,atanFlag)) case %problem =>
        trouble := ups.%problem
        trouble.prob = "essential singularity" => [monomial(fe,0)$UPS]
        ups
      (ans := fcn(ups.%series)) case "failed" => [monomial(fe,0)$UPS]
      [ans :: UPS]

    tranToGenUPS(ker,arg,posCheck?,atanFlag) ==
      -- converts op(arg) to a power series for certain functions
      -- op in trig or hyperbolic trig categories
      -- N.B. when this function is called, 'k2elem' will have been
      -- applied, so the following functions cannot appear:
      -- tan, cot, sec, csc, sinh, cosh, tanh, coth, sech, csch
      is?(ker,"sin" :: SY) =>
        applyBddIfCan(ker :: FE,sinIfCan,arg,"sin",posCheck?,atanFlag)
      is?(ker,"cos" :: SY) =>
        applyBddIfCan(ker :: FE,cosIfCan,arg,"cos",posCheck?,atanFlag)
      is?(ker,"asin" :: SY) =>
        genUPSApplyIfCan(asinIfCan,arg,"asin",posCheck?,atanFlag)
      is?(ker,"acos" :: SY) =>
        genUPSApplyIfCan(acosIfCan,arg,"acos",posCheck?,atanFlag)
      is?(ker,"atan" :: SY) =>
        atancotToGenUPS(ker :: FE,arg,posCheck?,atanFlag,1)
      is?(ker,"acot" :: SY) =>
        atancotToGenUPS(ker :: FE,arg,posCheck?,atanFlag,-1)
      is?(ker,"asec" :: SY) =>
        genUPSApplyIfCan(asecIfCan,arg,"asec",posCheck?,atanFlag)
      is?(ker,"acsc" :: SY) =>
        genUPSApplyIfCan(acscIfCan,arg,"acsc",posCheck?,atanFlag)
      is?(ker,"asinh" :: SY) =>
        genUPSApplyIfCan(asinhIfCan,arg,"asinh",posCheck?,atanFlag)
      is?(ker,"acosh" :: SY) =>
        genUPSApplyIfCan(acoshIfCan,arg,"acosh",posCheck?,atanFlag)
      is?(ker,"atanh" :: SY) =>
        genUPSApplyIfCan(atanhIfCan,arg,"atanh",posCheck?,atanFlag)
      is?(ker,"acoth" :: SY) =>
        genUPSApplyIfCan(acothIfCan,arg,"acoth",posCheck?,atanFlag)
      is?(ker,"asech" :: SY) =>
        genUPSApplyIfCan(asechIfCan,arg,"asech",posCheck?,atanFlag)
      is?(ker,"acsch" :: SY) =>
        genUPSApplyIfCan(acschIfCan,arg,"acsch",posCheck?,atanFlag)
      stateProblem(string name ker,"unknown kernel")

    powToGenUPS(args,posCheck?,atanFlag) ==
      -- converts a power f(x) ** g(x) to a generalized power series
      (logBase := logToGenUPS(first args,posCheck?,atanFlag)) case %problem =>
        logBase
      expon := iExprToGenUPS(second args,posCheck?,atanFlag)
      expon case %problem => expon
      expGenUPS((expon.%series) * (logBase.%series),posCheck?,atanFlag)

@
<<FS2UPS.dotabb>>=
"FS2UPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FS2UPS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"FS2UPS" -> "ACF"
"FS2UPS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSUPFACT FunctionSpaceUnivariatePolynomialFactor}
\pagehead{FunctionSpaceUnivariatePolynomialFactor}{FSUPFACT}
\pagepic{ps/v104functionspaceunivariatepolynomialfactor.ps}{FSUPFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSUPFACT FunctionSpaceUnivariatePolynomialFactor>>=
)abbrev package FSUPFACT FunctionSpaceUnivariatePolynomialFactor
++ Used internally by IR2F
++ Author: Manuel Bronstein
++ Date Created: 12 May 1988
++ Date Last Updated: 22 September 1993
++ Keywords: function, space, polynomial, factoring
FunctionSpaceUnivariatePolynomialFactor(R, F, UP):
 Exports == Implementation where
  R : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  F : FunctionSpace R
  UP: UnivariatePolynomialCategory F

  Q   ==> Fraction Integer
  K   ==> Kernel F
  AN  ==> AlgebraicNumber
  PQ  ==> SparseMultivariatePolynomial(Q, K)
  PR  ==> SparseMultivariatePolynomial(R, K)
  UPQ ==> SparseUnivariatePolynomial Q
  UPA ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
  FRQ ==> Factored UPQ
  FRA ==> Factored UPA

  Exports ==> with
    ffactor: UP -> FR
      ++ ffactor(p) tries to factor a univariate polynomial p over F
    qfactor: UP -> Union(FRQ, "failed")
      ++ qfactor(p) tries to factor p over fractions of integers,
      ++ returning "failed" if it cannot
    UP2ifCan: UP  -> Union(overq: UPQ, overan: UPA, failed: Boolean)
      ++ UP2ifCan(x) should be local but conditional.
    if F has RetractableTo AN then
      anfactor: UP -> Union(FRA, "failed")
        ++ anfactor(p) tries to factor p over algebraic numbers,
        ++ returning "failed" if it cannot

  Implementation ==> add
    import AlgFactor(UPA)
    import RationalFactorize(UPQ)

    P2QifCan : PR  -> Union(PQ, "failed")
    UPQ2UP   : (SparseUnivariatePolynomial PQ, F) -> UP
    PQ2F     : (PQ, F) -> F
    ffactor0 : UP -> FR

    dummy := kernel(new()$Symbol)$K

    if F has RetractableTo AN then
      UPAN2F: UPA -> UP
      UPQ2AN: UPQ -> UPA

      UPAN2F p ==
        map(#1::F, p)$UnivariatePolynomialCategoryFunctions2(AN,UPA,F,UP)

      UPQ2AN p ==
        map(#1::AN, p)$UnivariatePolynomialCategoryFunctions2(Q,UPQ,AN,UPA)

      ffactor p ==
        (pq := anfactor p) case FRA =>
                         map(UPAN2F, pq::FRA)$FactoredFunctions2(UPA, UP)
        ffactor0 p

      anfactor p ==
        (q := UP2ifCan p) case overq =>
                     map(UPQ2AN, factor(q.overq))$FactoredFunctions2(UPQ, UPA)
        q case overan => factor(q.overan)
        "failed"

      UP2ifCan p ==
        ansq := 0$UPQ ; ansa := 0$UPA
        goforq? := true
        while p ^= 0 repeat
          if goforq? then
            rq := retractIfCan(leadingCoefficient p)@Union(Q, "failed")
            if rq case Q then
              ansq := ansq + monomial(rq::Q, degree p)
              ansa := ansa + monomial(rq::Q::AN, degree p)
            else
              goforq? := false
              ra := retractIfCan(leadingCoefficient p)@Union(AN, "failed")
              if ra case AN then ansa := ansa + monomial(ra::AN, degree p)
                            else return [true]
          else
            ra := retractIfCan(leadingCoefficient p)@Union(AN, "failed")
            if ra case AN then ansa := ansa + monomial(ra::AN, degree p)
                          else return [true]
          p := reductum p
        goforq? => [ansq]
        [ansa]

    else
      UPQ2F: UPQ -> UP

      UPQ2F p ==
        map(#1::F, p)$UnivariatePolynomialCategoryFunctions2(Q,UPQ,F,UP)

      ffactor p ==
        (pq := qfactor p) case FRQ =>
                         map(UPQ2F, pq::FRQ)$FactoredFunctions2(UPQ, UP)
        ffactor0 p

      UP2ifCan p ==
        ansq := 0$UPQ
        while p ^= 0 repeat
          rq := retractIfCan(leadingCoefficient p)@Union(Q, "failed")
          if rq case Q then ansq := ansq + monomial(rq::Q, degree p)
                       else return [true]
          p := reductum p
        [ansq]

    ffactor0 p ==
      smp := numer(ep := p(dummy::F))
      (q := P2QifCan smp) case "failed" => p::FR
      map(UPQ2UP(univariate(#1, dummy), denom(ep)::F), factor(q::PQ
             )$MRationalFactorize(IndexedExponents K, K, Integer,
                  PQ))$FactoredFunctions2(PQ, UP)

    UPQ2UP(p, d) ==
      map(PQ2F(#1, d), p)$UnivariatePolynomialCategoryFunctions2(PQ,
                                   SparseUnivariatePolynomial PQ, F, UP)

    PQ2F(p, d) ==
      map(#1::F, #1::F, p)$PolynomialCategoryLifting(IndexedExponents K,
                                                K, Q, PQ, F) / d

    qfactor p ==
      (q := UP2ifCan p) case overq => factor(q.overq)
      "failed"

    P2QifCan p ==
      and/[retractIfCan(c::F)@Union(Q, "failed") case Q
           for c in coefficients p] =>
            map(#1::PQ, retract(#1::F)@Q :: PQ,
              p)$PolynomialCategoryLifting(IndexedExponents K,K,R,PR,PQ)
      "failed"

@
<<FSUPFACT.dotabb>>=
"FSUPFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSUPFACT"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FSUPFACT" -> "FS"
"FSUPFACT" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter G}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GALFACTU GaloisGroupFactorizationUtilities}
\pagehead{GaloisGroupFactorizationUtilities}{GALFACTU}
\pagepic{ps/v104galoisgroupfactorizationutilities.ps}{GALFACTU}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GALFACTU GaloisGroupFactorizationUtilities>>=
)abbrev package GALFACTU GaloisGroupFactorizationUtilities
++ Author: Frederic Lehobey
++ Date Created: 30 June 1994
++ Date Last Updated: 19 October 1995
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References: 
++ [1] Bernard Beauzamy, Products of polynomials and a priori estimates for
++ coefficients in polynomial decompositions: a sharp result,
++ J. Symbolic Computation (1992) 13, 463-472
++ [2] David W. Boyd, Bounds for the Height of a Factor of a Polynomial in
++ Terms of Bombieri's Norms: I. The Largest Factor,
++ J. Symbolic Computation (1993) 16, 115-130
++ [3] David W. Boyd, Bounds for the Height of a Factor of a Polynomial in
++ Terms of Bombieri's Norms: II. The Smallest Factor,
++ J. Symbolic Computation (1993) 16, 131-145
++ [4] Maurice Mignotte, Some Useful Bounds,
++ Computing, Suppl. 4, 259-263 (1982), Springer-Verlag
++ [5] Donald E. Knuth, The Art of Computer Programming, Vol. 2, (Seminumerical
++ Algorithms) 1st edition, 2nd printing, Addison-Wesley 1971, p. 397-398
++ [6] Bernard Beauzamy, Vilmar Trevisan and Paul S. Wang, Polynomial 
++ Factorization: Sharp Bounds, Efficient Algorithms,
++ J. Symbolic Computation (1993) 15, 393-413
++ [7] Augustin-Lux Cauchy, Exercices de Math\'ematiques Quatri\`eme Ann\'ee.
++ De Bure Fr\`eres, Paris 1829 (reprinted Oeuvres, II S\'erie, Tome IX,
++ Gauthier-Villars, Paris, 1891).
++ Description: 
++ \spadtype{GaloisGroupFactorizationUtilities} provides functions
++ that will be used by the factorizer.

GaloisGroupFactorizationUtilities(R,UP,F): Exports == Implementation where
  R : Ring
  UP : UnivariatePolynomialCategory R
  F : Join(FloatingPointSystem,RetractableTo(R),Field,
   TranscendentalFunctionCategory,ElementaryFunctionCategory)
  N ==> NonNegativeInteger
  P ==> PositiveInteger
  Z ==> Integer
 
  Exports ==> with
    beauzamyBound: UP -> Z -- See [1]
      ++ beauzamyBound(p) returns a bound on the larger coefficient of any
      ++ factor of p.
    bombieriNorm: UP -> F -- See [1]
      ++ bombieriNorm(p) returns quadratic Bombieri's norm of p.
    bombieriNorm: (UP,P) -> F -- See [2] and [3]
      ++ bombieriNorm(p,n) returns the nth Bombieri's norm of p.
    rootBound: UP -> Z -- See [4] and [5]
      ++ rootBound(p) returns a bound on the largest norm of the complex roots
      ++ of p.
    singleFactorBound: (UP,N) -> Z -- See [6]
      ++ singleFactorBound(p,r) returns a bound on the infinite norm of
      ++ the factor of p with smallest Bombieri's norm. r is a lower bound
      ++ for the number of factors of p. p shall be of degree higher or equal
      ++ to 2.
    singleFactorBound: UP -> Z -- See [6]
      ++ singleFactorBound(p,r) returns a bound on the infinite norm of
      ++ the factor of p with smallest Bombieri's norm. p shall be of degree
      ++ higher or equal to 2.
    norm: (UP,P) -> F
      ++ norm(f,p) returns the lp norm of the polynomial f.
    quadraticNorm: UP -> F
      ++ quadraticNorm(f) returns the l2 norm of the polynomial f.
    infinityNorm: UP -> F
      ++ infinityNorm(f) returns the maximal absolute value of the coefficients
      ++ of the polynomial f.
    height: UP -> F
      ++ height(p) returns the maximal absolute value of the coefficients of
      ++ the polynomial p.
    length: UP -> F
      ++ length(p) returns the sum of the absolute values of the coefficients
      ++ of the polynomial p.

  Implementation ==> add

    import GaloisGroupUtilities(F)

    height(p:UP):F == infinityNorm(p)

    length(p:UP):F == norm(p,1)

    norm(f:UP,p:P):F ==
      n : F := 0
      for c in coefficients f repeat
        n := n+abs(c::F)**p
      nthRoot(n,p::N)

    quadraticNorm(f:UP):F == norm(f,2)

    infinityNorm(f:UP):F ==
      n : F := 0
      for c in coefficients f repeat
        n := max(n,c::F)
      n

    singleFactorBound(p:UP,r:N):Z == -- See [6]
      n : N := degree p
      r := max(2,r)
      n < r => error "singleFactorBound: Bad arguments."
      nf : F := n :: F
      num : F := nthRoot(bombieriNorm(p),r)
      if F has Gamma: F -> F then
        num := num*nthRoot(Gamma(nf+1$F),2*r)
        den : F := Gamma(nf/((2*r)::F)+1$F)
      else
        num := num*(2::F)**(5/8+n/2)*exp(1$F/(4*nf))
        den : F := (pi()$F*nf)**(3/8)
      safeFloor( num/den )

    singleFactorBound(p:UP):Z == singleFactorBound(p,2) -- See [6]

    rootBound(p:UP):Z == -- See [4] and [5]
      n := degree p
      zero? n => 0
      lc := abs(leadingCoefficient(p)::F)
      b1 : F := 0 -- Mignotte
      b2 : F := 0 -- Knuth
      b3 : F := 0 -- Zassenhaus in [5]
      b4 : F := 0 -- Cauchy in [7]
      c : F := 0
      cl : F := 0
      for i in 1..n repeat
        c := abs(coefficient(p,(n-i)::N)::F)
        b1 := max(b1,c)
        cl := c/lc
        b2 := max(b2,nthRoot(cl,i))
        b3 := max(b3,nthRoot(cl/pascalTriangle(n,i),i))
        b4 := max(b4,nthRoot(n*cl,i))
      min(1+safeCeiling(b1/lc),min(safeCeiling(2*b2),min(safeCeiling(b3/
       (nthRoot(2::F,n)-1)),safeCeiling(b4))))

    beauzamyBound(f:UP):Z == -- See [1]
      d := degree f
      zero? d => safeFloor bombieriNorm f
      safeFloor( (bombieriNorm(f)*(3::F)**(3/4+d/2))/
       (2*sqrt(pi()$F*(d::F))) )

    bombieriNorm(f:UP,p:P):F == -- See [2] and [3]
      d := degree f
      b := abs(coefficient(f,0)::F)
      if zero? d then return b
       else b := b**p
      b := b+abs(leadingCoefficient(f)::F)**p
      dd := (d-1) quo 2
      for i in 1..dd repeat
        b := b+(abs(coefficient(f,i)::F)**p+abs(coefficient(f,(d-i)::N)::F)**p)
         /pascalTriangle(d,i)
      if even? d then
        dd := dd+1
        b := b+abs(coefficient(f, dd::N)::F)**p/pascalTriangle(d,dd)
      nthRoot(b,p::N)

    bombieriNorm(f:UP):F == bombieriNorm(f,2) -- See [1]

@
<<GALFACTU.dotabb>>=
"GALFACTU" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GALFACTU"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GALFACTU" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GALFACT GaloisGroupFactorizer}
\pagehead{GaloisGroupFactorizer}{GALFACT}
\pagepic{ps/v104galoisgroupfactorizer.ps}{GALFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GALFACT GaloisGroupFactorizer>>=
)abbrev package GALFACT GaloisGroupFactorizer
++ Author: Frederic Lehobey
++ Date Created: 28 June 1994
++ Date Last Updated: 11 July 1997
++ Basic Operations: factor
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: factorization
++ Examples:
++ References:
++ [1] Bernard Beauzamy, Vilmar Trevisan and Paul S. Wang, Polynomial 
++ Factorization: Sharp Bounds, Efficient Algorithms,
++ J. Symbolic Computation (1993) 15, 393-413
++ [2] John Brillhart, Note on Irreducibility Testing,
++ Mathematics of Computation, vol. 35, num. 35, Oct. 1980, 1379-1381
++ [3] David R. Musser, On the Efficiency of a Polynomial Irreducibility Test,
++ Journal of the ACM, Vol. 25, No. 2, April 1978, pp. 271-282
++ Description: \spadtype{GaloisGroupFactorizer} provides functions
++ to factor resolvents.
-- improvements to do :
--   + reformulate the lifting problem in completeFactor -- See [1] (hard)
--   + implement algorithm RC -- See [1] (easy)
--   + use Dedekind's criterion to prove sometimes irreducibility (easy)
--     or even to improve early detection of true factors (hard)
--   + replace Sets by Bits
GaloisGroupFactorizer(UP): Exports == Implementation where
  Z ==> Integer
  UP: UnivariatePolynomialCategory Z
  N ==> NonNegativeInteger
  P ==> PositiveInteger
  CYC ==> CyclotomicPolynomialPackage()
  SUPZ ==> SparseUnivariatePolynomial Z

  ParFact ==> Record(irr: UP, pow: Z)
  FinalFact ==> Record(contp: Z, factors: List ParFact)
  DDRecord ==> Record(factor: UP, degree: Z) -- a Distinct-Degree factor
  DDList ==> List DDRecord
  MFact ==> Record(prime: Z,factors: List UP) -- Modular Factors
  LR ==> Record(left: UP, right: UP) -- Functional decomposition

  Exports ==> with
    makeFR: FinalFact -> Factored UP
      ++ makeFR(flist) turns the final factorization of henselFact into a
      ++ \spadtype{Factored} object.
    degreePartition: DDList -> Multiset N
      ++ degreePartition(ddfactorization) returns the degree partition of
      ++ the polynomial f modulo p where ddfactorization is the distinct
      ++ degree factorization of f computed by 
      ++ \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer}
      ++ for some prime p.
    musserTrials: () -> P
      ++ musserTrials() returns the number of primes that are tried in
      ++ \spadfun{modularFactor}.
    musserTrials: P -> P
      ++ musserTrials(n) sets to n the number of primes to be tried in
      ++ \spadfun{modularFactor} and returns the previous value.
    stopMusserTrials: () -> P
      ++ stopMusserTrials() returns the bound on the number of factors for
      ++ which \spadfun{modularFactor} stops to look for an other prime. You
      ++ will have to remember that the step of recombining the extraneous
      ++ factors may take up to \spad{2**stopMusserTrials()} trials. 
    stopMusserTrials: P -> P
      ++ stopMusserTrials(n) sets to n the bound on the number of factors for
      ++ which \spadfun{modularFactor} stops to look for an other prime. You
      ++ will have to remember that the step of recombining the extraneous
      ++ factors may take up to \spad{2**n} trials. Returns the previous
      ++ value.
    numberOfFactors: DDList -> N
      ++ numberOfFactors(ddfactorization) returns the number of factors of 
      ++ the polynomial f modulo p where ddfactorization is the distinct
      ++ degree factorization of f computed by 
      ++ \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer}
      ++ for some prime p.
    modularFactor: UP -> MFact
      ++ modularFactor(f) chooses a "good" prime and returns the factorization
      ++ of f modulo this prime in a form that may be used by
      ++ \spadfunFrom{completeHensel}{GeneralHenselPackage}. If prime is zero
      ++ it means that f has been proved to be irreducible over the integers
      ++ or that f is a unit (i.e. 1 or -1).
      ++ f shall be primitive (i.e. content(p)=1) and square free (i.e.
      ++ without repeated factors).
    useSingleFactorBound?: () -> Boolean
      ++ useSingleFactorBound?() returns \spad{true} if algorithm with single
      ++ factor bound is used for factorization, \spad{false} for algorithm
      ++ with overall bound.
    useSingleFactorBound: Boolean -> Boolean
      ++ useSingleFactorBound(b) chooses the algorithm to be used by the
      ++ factorizers: \spad{true} for algorithm with single
      ++ factor bound, \spad{false} for algorithm with overall bound.
      ++ Returns the previous value.
    useEisensteinCriterion?: () -> Boolean
      ++ useEisensteinCriterion?() returns \spad{true} if factorizers
      ++ check Eisenstein's criterion before factoring.
    useEisensteinCriterion: Boolean -> Boolean
      ++ useEisensteinCriterion(b) chooses whether factorizers check
      ++ Eisenstein's criterion before factoring: \spad{true} for
      ++ using it, \spad{false} else. Returns the previous value.
    eisensteinIrreducible?: UP -> Boolean
      ++ eisensteinIrreducible?(p) returns \spad{true} if p can be
      ++ shown to be irreducible by Eisenstein's criterion,
      ++ \spad{false} is inconclusive.
    tryFunctionalDecomposition?: () -> Boolean
      ++ tryFunctionalDecomposition?() returns \spad{true} if
      ++ factorizers try functional decomposition of polynomials before
      ++ factoring them.
    tryFunctionalDecomposition: Boolean -> Boolean
      ++ tryFunctionalDecomposition(b) chooses whether factorizers have
      ++ to look for functional decomposition of polynomials
      ++ (\spad{true}) or not (\spad{false}). Returns the previous value.
    factor: UP -> Factored UP
      ++ factor(p) returns the factorization of p over the integers.
    factor: (UP,N) -> Factored UP
      ++ factor(p,r) factorizes the polynomial p using the single factor bound
      ++ algorithm and knowing that p has at least r factors.
    factor: (UP,List N) -> Factored UP
      ++ factor(p,listOfDegrees) factorizes the polynomial p using the single
      ++ factor bound algorithm and knowing that p has for possible 
      ++ splitting of its degree listOfDegrees.
    factor: (UP,List N,N) -> Factored UP
      ++ factor(p,listOfDegrees,r) factorizes the polynomial p using the single
      ++ factor bound algorithm, knowing that p has for possible 
      ++ splitting of its degree listOfDegrees and that p has at least r
      ++ factors.
    factor: (UP,N,N) -> Factored UP
      ++ factor(p,d,r) factorizes the polynomial p using the single
      ++ factor bound algorithm, knowing that d divides the degree of all 
      ++ factors of p and that p has at least r factors.
    factorSquareFree: UP -> Factored UP
      ++ factorSquareFree(p) returns the factorization of p which is supposed
      ++ not having any repeated factor (this is not checked).
    factorSquareFree: (UP,N) -> Factored UP
      ++ factorSquareFree(p,r) factorizes the polynomial p using the single
      ++ factor bound algorithm and knowing that p has at least r factors.
      ++ f is supposed not having any repeated factor (this is not checked).
    factorSquareFree: (UP,List N) -> Factored UP
      ++ factorSquareFree(p,listOfDegrees) factorizes the polynomial p using
      ++ the single factor bound algorithm and knowing that p has for possible 
      ++ splitting of its degree listOfDegrees.
      ++ f is supposed not having any repeated factor (this is not checked).
    factorSquareFree: (UP,List N,N) -> Factored UP
      ++ factorSquareFree(p,listOfDegrees,r) factorizes the polynomial p using
      ++ the single factor bound algorithm, knowing that p has for possible 
      ++ splitting of its degree listOfDegrees and that p has at least r
      ++ factors.
      ++ f is supposed not having any repeated factor (this is not checked).
    factorSquareFree: (UP,N,N) -> Factored UP
      ++ factorSquareFree(p,d,r) factorizes the polynomial p using the single
      ++ factor bound algorithm, knowing that d divides the degree of all 
      ++ factors of p and that p has at least r factors.
      ++ f is supposed not having any repeated factor (this is not checked).
    factorOfDegree: (P,UP) -> Union(UP,"failed")
      ++ factorOfDegree(d,p) returns a factor of p of degree d.
    factorOfDegree: (P,UP,N) -> Union(UP,"failed")
      ++ factorOfDegree(d,p,r) returns a factor of p of degree
      ++ d knowing that p has at least r factors.
    factorOfDegree: (P,UP,List N) -> Union(UP,"failed")
      ++ factorOfDegree(d,p,listOfDegrees) returns a factor 
      ++ of p of degree d knowing that p has for possible splitting of its
      ++ degree listOfDegrees.
    factorOfDegree: (P,UP,List N,N) -> Union(UP,"failed")
      ++ factorOfDegree(d,p,listOfDegrees,r) returns a factor 
      ++ of p of degree d knowing that p has for possible splitting of its
      ++ degree listOfDegrees, and that p has at least r factors.
    factorOfDegree: (P,UP,List N,N,Boolean) -> Union(UP,"failed")
      ++ factorOfDegree(d,p,listOfDegrees,r,sqf) returns a
      ++ factor of p of degree d knowing that p has for possible splitting of
      ++ its degree listOfDegrees, and that p has at least r factors.
      ++ If \spad{sqf=true} the polynomial is assumed to be square free (i.e. 
      ++ without repeated factors).
    henselFact: (UP,Boolean) -> FinalFact
      ++ henselFact(p,sqf) returns the factorization of p, the result
      ++ is a Record such that \spad{contp=}content p,
      ++ \spad{factors=}List of irreducible factors of p with exponent.
      ++ If \spad{sqf=true} the polynomial is assumed to be square free (i.e. 
      ++ without repeated factors).
    btwFact: (UP,Boolean,Set N,N) -> FinalFact
      ++ btwFact(p,sqf,pd,r) returns the factorization of p, the result
      ++ is a Record such that \spad{contp=}content p,
      ++ \spad{factors=}List of irreducible factors of p with exponent.
      ++ If \spad{sqf=true} the polynomial is assumed to be square free (i.e. 
      ++ without repeated factors).
      ++ pd is the \spadtype{Set} of possible degrees. r is a lower bound for
      ++ the number of factors of p. Please do not use this function in your
      ++ code because its design may change.

  Implementation ==> add

    fUnion ==> Union("nil", "sqfr", "irred", "prime")
    FFE ==> Record(flg:fUnion, fctr:UP, xpnt:Z) -- Flag-Factor-Exponent
    DDFact ==> Record(prime:Z, ddfactors:DDList) -- Distinct Degree Factors
    HLR ==> Record(plist:List UP, modulo:Z) -- HenselLift Record

    mussertrials: P := 5
    stopmussertrials: P := 8
    usesinglefactorbound: Boolean := true
    tryfunctionaldecomposition: Boolean := true
    useeisensteincriterion: Boolean := true

    useEisensteinCriterion?():Boolean == useeisensteincriterion

    useEisensteinCriterion(b:Boolean):Boolean ==
      (useeisensteincriterion,b) := (b,useeisensteincriterion)
      b

    tryFunctionalDecomposition?():Boolean == tryfunctionaldecomposition

    tryFunctionalDecomposition(b:Boolean):Boolean ==
      (tryfunctionaldecomposition,b) := (b,tryfunctionaldecomposition)
      b

    useSingleFactorBound?():Boolean == usesinglefactorbound

    useSingleFactorBound(b:Boolean):Boolean ==
      (usesinglefactorbound,b) := (b,usesinglefactorbound)
      b

    stopMusserTrials():P == stopmussertrials

    stopMusserTrials(n:P):P ==
      (stopmussertrials,n) := (n,stopmussertrials)
      n

    musserTrials():P == mussertrials

    musserTrials(n:P):P ==
      (mussertrials,n) := (n,mussertrials)
      n

    import GaloisGroupFactorizationUtilities(Z,UP,Float)

    import GaloisGroupPolynomialUtilities(Z,UP)

    import IntegerPrimesPackage(Z)
    import IntegerFactorizationPackage(Z)

    import ModularDistinctDegreeFactorizer(UP)

    eisensteinIrreducible?(f:UP):Boolean ==
      rf := reductum f
      c: Z := content rf
      zero? c => false
      unit? c => false
      lc := leadingCoefficient f
      tc := lc
      while not zero? rf repeat
        tc := leadingCoefficient rf
        rf := reductum rf
      for p in factors(factor c)$Factored(Z) repeat
--        if (one? p.exponent) and (not zero? (lc rem p.factor)) and
        if (p.exponent = 1) and (not zero? (lc rem p.factor)) and
         (not zero? (tc rem ((p.factor)**2))) then return true
      false

    numberOfFactors(ddlist:DDList):N ==
      n: N := 0
      d: Z := 0
      for dd in ddlist repeat
        n := n +
          zero? (d := degree(dd.factor)::Z) => 1
          (d quo dd.degree)::N
      n

    -- local function, returns the a Set of shifted elements
    shiftSet(s:Set N,shift:N):Set N == set [ e+shift for e in parts s ]

    -- local function, returns the "reductum" of an Integer (as chain of bits)
    reductum(n:Z):Z == n-shift(1,length(n)-1)

    -- local function, returns an integer with level lowest bits set to 1
    seed(level:Z):Z == shift(1,level)-1

    -- local function, returns the next number (as a chain of bit) for
    -- factor reconciliation of a given level (which is the number of
    -- extraneaous factors involved) or "End of level" if not any
    nextRecNum(levels:N,level:Z,n:Z):Union("End of level",Z) ==
      if (l := length n)<levels then return(n+shift(1,l-1))
      (n=shift(seed(level),levels-level)) => "End of level"
      b: Z := 1
      while ((l-b) = (lr := length(n := reductum n)))@Boolean repeat b := b+1
      reductum(n)+shift(seed(b+1),lr)

    -- local function, return the set of N, 0..n
    fullSet(n:N):Set N == set [ i for i in 0..n ]

    modularFactor(p:UP):MFact ==
--      not one? abs(content(p)) => 
      not (abs(content(p)) = 1) => 
       error "modularFactor: the polynomial is not primitive."
      zero? (n := degree p) => [0,[p]]

      -- declarations --
      cprime: Z := 2
      trials: List DDFact := empty()
      d: Set N := fullSet(n)
      dirred: Set N := set [0,n]
      s: Set N := empty()
      ddlist: DDList := empty()
      degfact: N := 0
      nf: N := stopmussertrials+1
      i: Z

      -- Musser, see [3] --
      diffp := differentiate p
      for i in 1..mussertrials | nf>stopmussertrials repeat
        -- test 1: cprime divides leading coefficient
        -- test 2: "bad" primes: (in future: use Dedekind's Criterion)
        while (zero? ((leadingCoefficient p) rem cprime)) or
         (not zero? degree gcd(p,diffp,cprime)) repeat
          cprime := nextPrime(cprime)
        ddlist := ddFact(p,cprime)
        -- degree compatibility: See [3] --
        s := set [0]
        for f in ddlist repeat
          degfact := f.degree::N
          if not zero? degfact then 
            for j in 1..(degree(f.factor) quo degfact) repeat
              s := union(s, shiftSet(s,degfact))
        trials := cons([cprime,ddlist]$DDFact,trials)
        d := intersect(d, s)
        d = dirred => return [0,[p]] -- p is irreducible
        cprime := nextPrime(cprime)
        nf := numberOfFactors ddlist

      -- choose the one with the smallest number of factors
      choice := first trials
      nfc := numberOfFactors(choice.ddfactors)
      for t in rest trials repeat
        nf := numberOfFactors(t.ddfactors)
        if nf<nfc or ((nf=nfc) and (t.prime>choice.prime)) then
          nfc := nf
          choice := t
      cprime := choice.prime
      -- HenselLift$GHENSEL expects the degree 0 factor first 
      [cprime,separateFactors(choice.ddfactors,cprime)]

    degreePartition(ddlist:DDList):Multiset N ==
      dp: Multiset N := empty()
      d: N := 0
      dd: N := 0
      for f in ddlist repeat
        zero? (d := degree(f.factor)) => dp := insert!(0,dp)
        dd := f.degree::N
        dp := insert!(dd,dp,d quo dd)
      dp

    import GeneralHenselPackage(Z,UP)
    import UnivariatePolynomialDecompositionPackage(Z,UP)
    import BrillhartTests(UP) -- See [2]

    -- local function, finds the factors of f primitive, square-free, with
    -- positive leading coefficient and non zero trailing coefficient,
    -- using the overall bound technique. If pdecomp is true then look
    -- for a functional decomposition of f.
    henselfact(f:UP,pdecomp:Boolean):List UP ==
      if brillhartIrreducible? f or
       (useeisensteincriterion => eisensteinIrreducible? f ; false)
      then return [f]
      cf: Union(LR,"failed")
      if pdecomp and tryfunctionaldecomposition then
        cf := monicDecomposeIfCan f
      else
        cf := "failed"
      cf case "failed" =>
        m := modularFactor f
        zero? (cprime := m.prime) => m.factors
        b: P := (2*leadingCoefficient(f)*beauzamyBound(f)) :: P
        completeHensel(f,m.factors,cprime,b)
      lrf := cf::LR
      "append"/[ henselfact(g(lrf.right),false) for g in
       henselfact(lrf.left,true) ]

    -- local function, returns the complete factorization of its arguments,
    -- using the single-factor bound technique 
    completeFactor(f:UP,lf:List UP,cprime:Z,pk:P,r:N,d:Set N):List UP ==
      lc := leadingCoefficient f
      f0 := coefficient(f,0)
      ltrue: List UP := empty()
      found? := true
      degf: N := 0
      degg: N := 0
      g0: Z := 0
      g: UP := 0
      rg: N := 0
      nb: Z := 0
      lg: List UP := empty()
      b: P := 1
      dg: Set N := empty()
      llg: HLR := [empty(),0]
      levels: N := #lf
      level: Z := 1
      ic: Union(Z,"End of level") := 0
      i: Z := 0
      while level<levels repeat
        -- try all possible factors with degree in d
        ic := seed(level)
        while ((not found?) and (ic case Z)) repeat
          i := ic::Z
          degg := 0
          g0 := 1 -- LC algorithm
          for j in 1..levels repeat
            if bit?(i,j-1) then
              degg := degg+degree lf.j
              g0 := g0*coefficient(lf.j,0) -- LC algorithm
          g0 := symmetricRemainder(lc*g0,pk) -- LC algorithm
          if member?(degg,d) and (((lc*f0) exquo g0) case Z) then 
            --                       LC algorithm
            g := lc::UP -- build the possible factor -- LC algorithm
            for j in 1..levels repeat if bit?(i,j-1) then g := g*lf.j
            g := primitivePart reduction(g,pk)
            f1 := f exquo g
            if f1 case UP then -- g is a true factor
              found? := true
              -- remove the factors of g from lf
              nb := 1
              for j in 1..levels repeat
                if bit?(i,j-1) then 
                  swap!(lf,j,nb)
                  nb := nb+1
              lg := lf
              lf := rest(lf,level::N)
              setrest!(rest(lg,(level-1)::N),empty()$List(UP))
              f := f1::UP
              lc := leadingCoefficient f
              f0 := coefficient(f,0)
              -- is g irreducible?
              dg := select(#1<=degg,d)
              if not(dg=set [0,degg]) then -- implies degg >= 2
                rg := max(2,r+level-levels)::N
                b := (2*leadingCoefficient(g)*singleFactorBound(g,rg)) :: P
                if b>pk and (not brillhartIrreducible?(g)) and
                  (useeisensteincriterion => not eisensteinIrreducible?(g) ;
                  true)
                then
                  -- g may be reducible
                  llg := HenselLift(g,lg,cprime,b)
                  gpk: P := (llg.modulo)::P 
                  -- In case exact factorisation has been reached by
                  -- HenselLift before coefficient bound.
                  if gpk<b then
                    lg := llg.plist
                  else
                    lg := completeFactor(g,llg.plist,cprime,gpk,rg,dg)
                else lg := [ g ] -- g irreducible
              else lg := [ g ] -- g irreducible
              ltrue := append(ltrue,lg)
              r := max(2,(r-#lg))::N
              degf := degree f
              d := select(#1<=degf,d)
              if degf<=1 then -- lf exhausted
--                if one? degf then
                if (degf = 1) then
                  ltrue := cons(f,ltrue)
                return ltrue -- 1st exit, all factors found
              else -- can we go on with the same pk?
                b := (2*lc*singleFactorBound(f,r)) :: P
                if b>pk then -- unlucky: no we can't
                  llg := HenselLift(f,lf,cprime,b) -- I should reformulate
                   -- the lifting probleme, but hadn't time for that.
                   -- In any case, such case should be quite exceptional.
                  lf := llg.plist
                  pk := (llg.modulo)::P
                  -- In case exact factorisation has been reached by
                  -- HenselLift before coefficient bound.
                  if pk<b then return append(lf,ltrue) -- 2nd exit
                  level := 1
          ic := nextRecNum(levels,level,i)
        if found? then
          levels := #lf
          found? := false
        if not (ic case Z) then level := level+1
      cons(f,ltrue) -- 3rd exit, the last factor was irreducible but not "true"

    -- local function, returns the set of elements "divided" by an integer
    divideSet(s:Set N, n:N):Set N ==
      l: List N := [ 0 ]
      for e in parts s repeat
        if (ee := (e exquo n)$N) case N then l := cons(ee::N,l)
      set(l)

    -- Beauzamy-Trevisan-Wang FACTOR, see [1] with some refinements
    -- and some differences. f is assumed to be primitive, square-free
    -- and with positive leading coefficient. If pdecomp is true then
    -- look for a functional decomposition of f. 
    btwFactor(f:UP,d:Set N,r:N,pdecomp:Boolean):List UP ==
      df := degree f
      not (max(d) = df) => error "btwFact: Bad arguments"
      reverse?: Boolean := false
      negativelc?: Boolean := false

      (d = set [0,df]) => [ f ]
      if abs(coefficient(f,0))<abs(leadingCoefficient(f)) then
        f := reverse f
        reverse? := true
      brillhartIrreducible? f or 
       (useeisensteincriterion => eisensteinIrreducible?(f) ; false) =>
        if reverse? then [ reverse f ] else [ f ]
      if leadingCoefficient(f)<0 then
        f := -f
        negativelc? := true
      cf: Union(LR,"failed")
      if pdecomp and tryfunctionaldecomposition then
        cf := monicDecomposeIfCan f
      else
        cf := "failed"
      if cf case "failed" then
        m := modularFactor f
        zero? (cprime := m.prime) => 
          if reverse? then
            if negativelc? then return [ -reverse f ]
            else return [ reverse f ]
          else if negativelc? then return [ -f ]
               else return [ f ]
        if noLinearFactor? f then d := remove(1,d)
        lc := leadingCoefficient f
        f0 := coefficient(f,0)
        b: P := (2*lc*singleFactorBound(f,r)) :: P -- LC algorithm
        lm := HenselLift(f,m.factors,cprime,b)
        lf := lm.plist
        pk: P := (lm.modulo)::P
        if ground? first lf then lf := rest lf
        -- in case exact factorisation has been reached by HenselLift
        -- before coefficient bound
        if not pk < b then lf := completeFactor(f,lf,cprime,pk,r,d)
      else
        lrf := cf::LR
        dh := degree lrf.right
        lg := btwFactor(lrf.left,divideSet(d,dh),2,true)
        lf: List UP := empty()
        for i in 1..#lg repeat
          g := lg.i
          dgh := (degree g)*dh
          df := subtractIfCan(df,dgh)::N
          lfg := btwFactor(g(lrf.right),
           select(#1<=dgh,d),max(2,r-df)::N,false)
          lf := append(lf,lfg)
          r := max(2,r-#lfg)::N
      if reverse? then lf := [ reverse(fact) for fact in lf ]
      for i in 1..#lf repeat
        if leadingCoefficient(lf.i)<0 then lf.i := -lf.i
        -- because we assume f with positive leading coefficient
      lf

    makeFR(flist:FinalFact):Factored UP ==
      ctp := factor flist.contp
      fflist: List FFE := empty()
      for ff in flist.factors repeat
        fflist := cons(["prime", ff.irr, ff.pow]$FFE, fflist)
      for fc in factorList ctp repeat
        fflist := cons([fc.flg, fc.fctr::UP, fc.xpnt]$FFE, fflist)
      makeFR(unit(ctp)::UP, fflist)

    import IntegerRoots(Z)

    -- local function, factorizes a quadratic polynomial
    quadratic(p:UP):List UP ==
      a := leadingCoefficient p
      b := coefficient(p,1)
      d := b**2-4*a*coefficient(p,0)
      r := perfectSqrt(d)
      r case "failed" => [p]
      b := b+(r::Z)
      a := 2*a
      d := gcd(a,b)
--      if not one? d then
      if not (d = 1) then
        a := a quo d
        b := b quo d
      f: UP := monomial(a,1)+monomial(b,0)
      cons(f,[(p exquo f)::UP])

    isPowerOf2(n:Z): Boolean ==
       n = 1 => true
       qr: Record(quotient: Z, remainder: Z) := divide(n,2)
       qr.remainder = 1 => false
       isPowerOf2 qr.quotient

    subMinusX(supPol: SUPZ): UP ==
       minusX: SUPZ := monomial(-1,1)$SUPZ
       unmakeSUP(elt(supPol,minusX)$SUPZ)

    henselFact(f:UP, sqf:Boolean):FinalFact ==
      factorlist: List(ParFact) := empty()

      -- make m primitive
      c: Z := content f
      f := (f exquo c)::UP

      -- make the leading coefficient positive
      if leadingCoefficient f < 0 then
        c := -c
        f := -f

      -- is x**d factor of f
      if (d := minimumDegree f) > 0 then
        f := monicDivide(f,monomial(1,d)).quotient
        factorlist := [[monomial(1,1),d]$ParFact]

      d := degree f

      -- is f constant?
      zero? d => [c,factorlist]$FinalFact

      -- is f linear?
--      one? d => [c,cons([f,1]$ParFact,factorlist)]$FinalFact
      (d = 1) => [c,cons([f,1]$ParFact,factorlist)]$FinalFact

      lcPol: UP := leadingCoefficient(f) :: UP

      -- is f cyclotomic (x**n - 1)?
      -lcPol = reductum(f) =>    -- if true, both will = 1
        for fac in map(unmakeSUP(#1)$UP,
         cyclotomicDecomposition(d)$CYC)$ListFunctions2(SUPZ,UP) repeat 
          factorlist := cons([fac,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- is f odd cyclotomic (x**(2*n+1) + 1)?
      odd?(d) and (lcPol = reductum(f)) =>
        for sfac in cyclotomicDecomposition(d)$CYC repeat
           fac := subMinusX sfac
           if leadingCoefficient fac < 0 then fac := -fac
           factorlist := cons([fac,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- is the poly of the form x**n + 1 with n a power of 2?
      -- if so, then irreducible
      isPowerOf2(d) and (lcPol = reductum(f)) =>
        factorlist := cons([f,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- other special cases to implement...

      -- f is square-free :
      sqf => [c, append([[pf,1]$ParFact for pf in henselfact(f,true)],
       factorlist)]$FinalFact

      -- f is not square-free :
      sqfflist := factors squareFree f
      for sqfr in sqfflist repeat
        mult := sqfr.exponent
        sqff := sqfr.factor
        d := degree sqff
--        one? d => factorlist := cons([sqff,mult]$ParFact,factorlist)
        (d = 1) => factorlist := cons([sqff,mult]$ParFact,factorlist)
        d=2 =>
          factorlist := append([[pf,mult]$ParFact for pf in quadratic(sqff)],
           factorlist)
        factorlist := append([[pf,mult]$ParFact for pf in
         henselfact(sqff,true)],factorlist) 
      [c,factorlist]$FinalFact

    btwFact(f:UP, sqf:Boolean, fd:Set N, r:N):FinalFact ==
      d := degree f
      not(max(fd)=d) => error "btwFact: Bad arguments"
      factorlist: List(ParFact) := empty()

      -- make m primitive
      c: Z := content f
      f := (f exquo c)::UP

      -- make the leading coefficient positive
      if leadingCoefficient f < 0 then
        c := -c
        f := -f

      -- is x**d factor of f
      if (maxd := minimumDegree f) > 0 then
        f := monicDivide(f,monomial(1,maxd)).quotient
        factorlist := [[monomial(1,1),maxd]$ParFact]
        r := max(2,r-maxd)::N
        d := subtractIfCan(d,maxd)::N
        fd := select(#1<=d,fd)

      -- is f constant?
      zero? d => [c,factorlist]$FinalFact

      -- is f linear?
--      one? d => [c,cons([f,1]$ParFact,factorlist)]$FinalFact
      (d = 1) => [c,cons([f,1]$ParFact,factorlist)]$FinalFact

      lcPol: UP := leadingCoefficient(f) :: UP

      -- is f cyclotomic (x**n - 1)?
      -lcPol = reductum(f) =>    -- if true, both will = 1
        for fac in map(unmakeSUP(#1)$UP,
         cyclotomicDecomposition(d)$CYC)$ListFunctions2(SUPZ,UP) repeat 
          factorlist := cons([fac,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- is f odd cyclotomic (x**(2*n+1) + 1)?
      odd?(d) and (lcPol = reductum(f)) =>
        for sfac in cyclotomicDecomposition(d)$CYC repeat
           fac := subMinusX sfac
           if leadingCoefficient fac < 0 then fac := -fac
           factorlist := cons([fac,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- is the poly of the form x**n + 1 with n a power of 2?
      -- if so, then irreducible
      isPowerOf2(d) and (lcPol = reductum(f)) =>
        factorlist := cons([f,1]$ParFact,factorlist)
        [c,factorlist]$FinalFact

      -- other special cases to implement...

      -- f is square-free :
      sqf => [c, append([[pf,1]$ParFact for pf in btwFactor(f,fd,r,true)],
       factorlist)]$FinalFact

      -- f is not square-free :
      sqfflist := factors squareFree(f)
--      if one?(#(sqfflist)) then -- indeed f was a power of a square-free 
      if ((#(sqfflist)) = 1) then -- indeed f was a power of a square-free 
        r := max(r quo ((first sqfflist).exponent),2)::N
      else
        r := 2
      for sqfr in sqfflist repeat
        mult := sqfr.exponent
        sqff := sqfr.factor
        d := degree sqff
--        one? d => 
        (d = 1) => 
          factorlist := cons([sqff,mult]$ParFact,factorlist)
          maxd := (max(fd)-mult)::N
          fd := select(#1<=maxd,fd)
        d=2 =>
          factorlist := append([[pf,mult]$ParFact for pf in quadratic(sqff)],
           factorlist)
          maxd := (max(fd)-2*mult)::N
          fd := select(#1<=maxd,fd)
        factorlist := append([[pf,mult]$ParFact for pf in 
         btwFactor(sqff,select(#1<=d,fd),r,true)],factorlist)
        maxd := (max(fd)-d*mult)::N
        fd := select(#1<=maxd,fd)
      [c,factorlist]$FinalFact

    factor(f:UP):Factored UP ==
      makeFR
        usesinglefactorbound => btwFact(f,false,fullSet(degree f),2)
        henselFact(f,false)

    -- local function, returns true if the sum of the elements of the list
    -- is not the degree.
    errorsum?(d:N,ld:List N):Boolean == not (d = +/ld)

    -- local function, turns list of degrees into a Set
    makeSet(ld:List N):Set N ==
      s := set [0]
      for d in ld repeat s := union(s,shiftSet(s,d))
      s
      
    factor(f:UP,ld:List N,r:N):Factored UP ==
      errorsum?(degree f,ld) => error "factor: Bad arguments"
      makeFR btwFact(f,false,makeSet(ld),r)

    factor(f:UP,r:N):Factored UP == makeFR btwFact(f,false,fullSet(degree f),r)
    
    factor(f:UP,ld:List N):Factored UP == factor(f,ld,2)

    factor(f:UP,d:N,r:N):Factored UP ==
      n := (degree f) exquo d
      n case "failed" => error "factor: Bad arguments"
      factor(f,new(n::N,d)$List(N),r)

    factorSquareFree(f:UP):Factored UP ==
      makeFR
        usesinglefactorbound => btwFact(f,true,fullSet(degree f),2)
        henselFact(f,true)

    factorSquareFree(f:UP,ld:List(N),r:N):Factored UP ==
      errorsum?(degree f,ld) => error "factorSquareFree: Bad arguments"
      makeFR btwFact(f,true,makeSet(ld),r)

    factorSquareFree(f:UP,r:N):Factored UP ==
      makeFR btwFact(f,true,fullSet(degree f),r)
    
    factorSquareFree(f:UP,ld:List N):Factored UP == factorSquareFree(f,ld,2)

    factorSquareFree(f:UP,d:N,r:N):Factored UP ==
      n := (degree f) exquo d
      n case "failed" => error "factorSquareFree: Bad arguments"
      factorSquareFree(f,new(n::N,d)$List(N),r)

    factorOfDegree(d:P,p:UP,ld:List N,r:N,sqf:Boolean):Union(UP,"failed") ==
      dp := degree p
      errorsum?(dp,ld) => error "factorOfDegree: Bad arguments"
--      (one? (d::N)) and noLinearFactor?(p) => "failed"
      ((d::N) = 1) and noLinearFactor?(p) => "failed"
      lf := btwFact(p,sqf,makeSet(ld),r).factors
      for f in lf repeat
        degree(f.irr)=d => return f.irr
      "failed"

    factorOfDegree(d:P,p:UP,ld:List N,r:N):Union(UP,"failed") ==
      factorOfDegree(d,p,ld,r,false)

    factorOfDegree(d:P,p:UP,r:N):Union(UP,"failed") ==
      factorOfDegree(d,p,new(degree p,1)$List(N),r,false)

    factorOfDegree(d:P,p:UP,ld:List N):Union(UP,"failed") ==
      factorOfDegree(d,p,ld,2,false)

    factorOfDegree(d:P,p:UP):Union(UP,"failed") ==
      factorOfDegree(d,p,new(degree p,1)$List(N),2,false)

@
<<GALFACT.dotabb>>=
"GALFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GALFACT"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"GALFACT" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GALPOLYU GaloisGroupPolynomialUtilities}
\pagehead{GaloisGroupPolynomialUtilities}{GALPOLYU}
\pagepic{ps/v104galoisgrouppolynomialutilities.ps}{GALPOLYU}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GALPOLYU GaloisGroupPolynomialUtilities>>=
)abbrev package GALPOLYU GaloisGroupPolynomialUtilities
++ Author: Frederic Lehobey
++ Date Created: 30 June 1994
++ Date Last Updated: 15 July 1994
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: \spadtype{GaloisGroupPolynomialUtilities} provides useful
++ functions for univariate polynomials which should be added to 
++ \spadtype{UnivariatePolynomialCategory} or to \spadtype{Factored}
++ (July 1994).

GaloisGroupPolynomialUtilities(R,UP): Exports == Implementation where
  R : Ring
  UP : UnivariatePolynomialCategory R
  N ==> NonNegativeInteger
  P ==> PositiveInteger

  Exports ==> with
    monic?: UP -> Boolean
      ++ monic?(p) tests if p is monic (i.e. leading coefficient equal to 1).
    unvectorise: Vector R -> UP
      ++ unvectorise(v) returns the polynomial which has for coefficients the
      ++ entries of v in the increasing order.
    reverse: UP -> UP
      ++ reverse(p) returns the reverse polynomial of p.
    scaleRoots: (UP,R) -> UP
      ++ scaleRoots(p,c) returns the polynomial which has c times the roots
      ++ of p.
    shiftRoots: (UP,R) -> UP
      ++ shiftRoots(p,c) returns the polynomial which has for roots c added 
      ++ to the roots of p.
    degreePartition: Factored UP -> Multiset N
      ++ degreePartition(f) returns the degree partition (i.e. the multiset
      ++ of the degrees of the irreducible factors) of
      ++ the polynomial f.
    factorOfDegree: (P, Factored UP) -> UP
      ++ factorOfDegree(d,f) returns a factor of degree d of the factored
      ++ polynomial f. Such a factor shall exist.
    factorsOfDegree: (P, Factored UP) -> List UP
      ++ factorsOfDegree(d,f) returns the factors of degree d of the factored
      ++ polynomial f.

  Implementation ==> add

    import Factored UP

    factorsOfDegree(d:P,r:Factored UP):List UP ==
      lfact : List UP := empty()
      for fr in factors r | degree(fr.factor)=(d::N) repeat
        for i in 1..fr.exponent repeat
          lfact := cons(fr.factor,lfact)
      lfact

    factorOfDegree(d:P,r:Factored UP):UP ==
      factor : UP := 0
      for i in 1..numberOfFactors r repeat
        factor := nthFactor(r,i)
        if degree(factor)=(d::N) then return factor
      error "factorOfDegree: Bad arguments"

    degreePartition(r:Factored UP):Multiset N ==
      multiset([ degree(nthFactor(r,i)) for i in 1..numberOfFactors r ])

--    monic?(p:UP):Boolean == one? leadingCoefficient p
    monic?(p:UP):Boolean == (leadingCoefficient p) = 1

    unvectorise(v:Vector R):UP ==
      p : UP := 0
      for i in 1..#v repeat p := p + monomial(v(i),(i-1)::N)
      p

    reverse(p:UP):UP ==
      r : UP := 0
      n := degree(p)
      for i in 0..n repeat r := r + monomial(coefficient(p,(n-i)::N),i)
      r

    scaleRoots(p:UP,c:R):UP ==
--      one? c => p
      (c = 1) => p
      n := degree p
      zero? c => monomial(leadingCoefficient p,n)
      r : UP := 0
      mc : R := 1
      for i in n..0 by -1 repeat
        r := r + monomial(mc*coefficient(p,i),i)
        mc := mc*c
      r

    import UnivariatePolynomialCategoryFunctions2(R,UP,UP,
     SparseUnivariatePolynomial UP)

    shiftRoots(p:UP,c:R):UP == elt(map(coerce,p),monomial(1,1)$UP-c::UP)::UP

@
<<GALPOLYU.dotabb>>=
"GALPOLYU" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GALPOLYU"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GALPOLYU" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GALUTIL GaloisGroupUtilities}
\pagehead{GaloisGroupUtilities}{GALUTIL}
\pagepic{ps/v104galoisgrouputilities.ps}{GALUTIL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GALUTIL GaloisGroupUtilities>>=
)abbrev package GALUTIL GaloisGroupUtilities
++ Author: Frederic Lehobey
++ Date Created: 29 June 1994
++ Date Last Updated: 30 June 1994 
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: 
++ \spadtype{GaloisGroupUtilities} provides several useful functions.

GaloisGroupUtilities(R): Exports == Implementation where
  N ==> NonNegativeInteger
  Z ==> Integer
  R : Ring

  Exports ==> with
    pascalTriangle: (N,Z) -> R
      ++ pascalTriangle(n,r) returns the binomial coefficient
      ++ \spad{C(n,r)=n!/(r! (n-r)!)}
      ++ and stores it in a table to prevent recomputation.
    rangePascalTriangle: N -> N
      ++ rangePascalTriangle(n) sets the maximal number of lines which
      ++ are stored and returns the previous value.
    rangePascalTriangle: () -> N
      ++ rangePascalTriangle() returns the maximal number of lines stored.
    sizePascalTriangle: () -> N
      ++ sizePascalTriangle() returns the number of entries currently stored
      ++ in the table.
    fillPascalTriangle: () -> Void
      ++ fillPascalTriangle() fills the stored table.

    if R has FloatingPointSystem then
      safeCeiling: R -> Z
        ++ safeCeiling(x) returns the integer which is greater than any integer
        ++ with the same floating point number representation.
      safeFloor: R -> Z
        ++ safeFloor(x) returns the integer which is lower or equal to the
        ++ largest integer which has the same floating point number
        ++ representation.
      safetyMargin: N -> N
        ++ safetyMargin(n) sets to n the number of low weight digits we do not
        ++ trust in the floating point representation and returns the previous
        ++ value (for use by \spadfun{safeCeiling}).
      safetyMargin: () -> N
        ++ safetyMargin() returns the number of low weight digits we do not
        ++ trust in the floating point representation (used by 
        ++ \spadfun{safeCeiling}).

  Implementation ==> add

    if R has FloatingPointSystem then
      safetymargin : N := 6
      
      safeFloor(x:R):Z ==
        if (shift := order(x)-precision()$R+safetymargin) >= 0 then
          x := x+float(1,shift)
        retract(floor(x))@Z

      safeCeiling(x:R):Z ==
        if (shift := order(x)-precision()$R+safetymargin) >= 0 then
          x := x+float(1,shift)
        retract(ceiling(x))@Z

      safetyMargin(n:N):N == 
        (safetymargin,n) := (n,safetymargin)
        n

      safetyMargin():N == safetymargin

    pascaltriangle : FlexibleArray(R) := empty()
    ncomputed : N := 3
    rangepascaltriangle : N := 216

    pascalTriangle(n:N, r:Z):R ==
      negative? r => 0
      (d := n-r) < r => pascalTriangle(n,d)
      zero? r => 1$R
--      one? r => n :: R
      (r = 1) => n :: R
      n > rangepascaltriangle => 
       binomial(n,r)$IntegerCombinatoricFunctions(Z) :: R
      n <= ncomputed =>
        m := divide(n-4,2)
        mq := m.quotient
        pascaltriangle((mq+1)*(mq+m.remainder)+r-1)
      -- compute the missing lines
      for i in (ncomputed+1)..n repeat
        for j in 2..(i quo 2) repeat
          pascaltriangle := concat!(pascaltriangle,pascalTriangle((i-1) 
           :: N, j-1)+pascalTriangle((i-1) :: N,j))
        ncomputed := i
      pascalTriangle(n,r)

    rangePascalTriangle(n:N):N ==
      if n<ncomputed then
        if n<3 then
          pascaltriangle := delete!(pascaltriangle,1..#pascaltriangle)
          ncomputed := 3
        else
          d := divide(n-3,2)
          dq := d.quotient
          pascaltriangle := delete!(pascaltriangle,((dq+1)*(dq+d.remainder)
           +1)..#pascaltriangle)
          ncomputed := n
      (rangepascaltriangle,n) := (n,rangepascaltriangle)
      n

    rangePascalTriangle():N == rangepascaltriangle

    sizePascalTriangle():N == #pascaltriangle

    fillPascalTriangle():Void == pascalTriangle(rangepascaltriangle,2)

@
<<GALUTIL.dotabb>>=
"GALUTIL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GALUTIL"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"GALUTIL" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GAUSSFAC GaussianFactorizationPackage}
\pagehead{GaussianFactorizationPackage}{GAUSSFAC}
\pagepic{ps/v104gaussianfactorizationpackage.ps}{GAUSSFAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GAUSSFAC GaussianFactorizationPackage>>=
)abbrev package GAUSSFAC GaussianFactorizationPackage
++ Author: Patrizia Gianni
++ Date Created: Summer 1986
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: Package for the factorization of complex or gaussian
++ integers.
GaussianFactorizationPackage() : C == T
 where
  NNI  ==  NonNegativeInteger
  Z      ==> Integer
  ZI     ==> Complex Z
  FRZ    ==> Factored ZI
  fUnion ==> Union("nil", "sqfr", "irred", "prime")
  FFE    ==> Record(flg:fUnion, fctr:ZI, xpnt:Integer)

  C  == with
     factor      :     ZI     ->     FRZ
       ++ factor(zi) produces the complete factorization of the complex
       ++ integer zi.
     sumSquares  :     Z      ->    List Z
       ++ sumSquares(p) construct \spad{a} and b such that \spad{a**2+b**2}
       ++ is equal to
       ++ the integer prime p, and otherwise returns an error.
       ++ It will succeed if the prime number p is 2 or congruent to 1
       ++ mod 4.
     prime?      :     ZI     ->    Boolean
       ++ prime?(zi) tests if the complex integer zi is prime.

  T  == add
     import IntegerFactorizationPackage Z

     reduction(u:Z,p:Z):Z ==
       p=0 => u
       positiveRemainder(u,p)

     merge(p:Z,q:Z):Union(Z,"failed") ==
       p = q => p
       p = 0 => q
       q = 0 => p
       "failed"

     exactquo(u:Z,v:Z,p:Z):Union(Z,"failed") ==
        p=0 => u exquo v
        v rem p = 0 => "failed"
        positiveRemainder((extendedEuclidean(v,p,u)::Record(coef1:Z,coef2:Z)).coef1,p)

     FMod := ModularRing(Z,Z,reduction,merge,exactquo)

     fact2:ZI:= complex(1,1)

             ----  find the solution of x**2+1 mod q  ----
     findelt(q:Z) : Z ==
       q1:=q-1
       r:=q1
       r1:=r exquo 4
       while ^(r1 case "failed") repeat
         r:=r1::Z
         r1:=r exquo 2
       s : FMod := reduce(1,q)
       qq1:FMod :=reduce(q1,q)
       for i in 2.. while (s=1 or s=qq1) repeat
         s:=reduce(i,q)**(r::NNI)
       t:=s
       while t^=qq1 repeat
         s:=t
         t:=t**2
       s::Z


     ---- write p, congruent to 1 mod 4, as a sum of two squares ----
     sumsq1(p:Z) : List Z ==
       s:= findelt(p)
       u:=p
       while u**2>p repeat
         w:=u rem s
         u:=s
         s:=w
       [u,s]

            ---- factorization of an integer  ----
     intfactor(n:Z) : Factored ZI ==
       lfn:= factor n
       r : List FFE :=[]
       unity:ZI:=complex(unit lfn,0)
       for term in (factorList lfn) repeat
         n:=term.fctr
         exp:=term.xpnt
         n=2 =>
           r :=concat(["prime",fact2,2*exp]$FFE,r)
           unity:=unity*complex(0,-1)**(exp rem 4)::NNI

         (n rem 4) = 3 => r:=concat(["prime",complex(n,0),exp]$FFE,r)

         sz:=sumsq1(n)
         z:=complex(sz.1,sz.2)
         r:=concat(["prime",z,exp]$FFE,
                 concat(["prime",conjugate(z),exp]$FFE,r))
       makeFR(unity,r)

           ---- factorization of a gaussian number  ----
     factor(m:ZI) : FRZ ==
       m=0 => primeFactor(0,1)
       a:= real m

       (b:= imag m)=0 => intfactor(a) :: FRZ

       a=0 =>
         ris:=intfactor(b)
         unity:= unit(ris)*complex(0,1)
         makeFR(unity,factorList ris)

       d:=gcd(a,b)
       result : List FFE :=[]
       unity:ZI:=1$ZI

       if d^=1 then
         a:=(a exquo d)::Z
         b:=(b exquo d)::Z
         r:= intfactor(d)
         result:=factorList r
         unity:=unit r
         m:=complex(a,b)

       n:Z:=a**2+b**2
       factn:= factorList(factor n)
       part:FFE:=["prime",0$ZI,0]
       for term in factn repeat
         n:=term.fctr
         exp:=term.xpnt
         n=2 =>
           part:= ["prime",fact2,exp]$FFE
           m:=m quo (fact2**exp:NNI)
           result:=concat(part,result)

         (n rem 4) = 3 =>
           g0:=complex(n,0)
           part:= ["prime",g0,exp quo 2]$FFE
           m:=m quo g0
           result:=concat(part,result)

         z:=gcd(m,complex(n,0))
         part:= ["prime",z,exp]$FFE
         z:=z**(exp:NNI)
         m:=m quo z
         result:=concat(part,result)

       if m^=1 then unity:=unity * m
       makeFR(unity,result)

           ----  write p prime like sum of two squares  ----
     sumSquares(p:Z) : List Z ==
       p=2 => [1,1]
       p rem 4 ^= 1 => error "no solutions"
       sumsq1(p)


     prime?(a:ZI) : Boolean ==
        n : Z := norm a
        n=0 => false            -- zero
        n=1 => false            -- units
        prime?(n)$IntegerPrimesPackage(Z)  => true
        re : Z := real a
        im : Z := imag a
        re^=0 and im^=0 => false
        p : Z := abs(re+im)     -- a is of the form p, -p, %i*p or -%i*p
        p rem 4 ^= 3 => false
        -- return-value true, if p is a rational prime,
        -- and false, otherwise
        prime?(p)$IntegerPrimesPackage(Z)

@
<<GAUSSFAC.dotabb>>=
"GAUSSFAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GAUSSFAC"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"GAUSSFAC" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GHENSEL GeneralHenselPackage}
\pagehead{GeneralHenselPackage}{GHENSEL}
\pagepic{ps/v104generalhenselpackage.ps}{GHENSEL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GHENSEL GeneralHenselPackage>>=
)abbrev package GHENSEL GeneralHenselPackage
++ Author : P.Gianni
++ General Hensel Lifting
++ Used for Factorization of bivariate polynomials over a finite field.
GeneralHenselPackage(RP,TP):C == T where
   RP :   EuclideanDomain
   TP :   UnivariatePolynomialCategory RP

   PI ==> PositiveInteger

   C == with
      HenselLift: (TP,List(TP),RP,PI) -> Record(plist:List(TP), modulo:RP)
        ++ HenselLift(pol,lfacts,prime,bound) lifts lfacts, 
        ++ that are the factors of pol mod prime,
        ++ to factors of pol mod prime**k > bound. No recombining is done .

      completeHensel: (TP,List(TP),RP,PI) -> List TP
        ++ completeHensel(pol,lfact,prime,bound) lifts lfact, 
        ++ the factorization mod prime of pol,
        ++ to the factorization mod prime**k>bound. 
        ++ Factors are recombined on the way.
  
      reduction     :  (TP,RP)  ->  TP 
        ++ reduction(u,pol) computes the symmetric reduction of u mod pol

   T == add
     GenExEuclid: (List(FP),List(FP),FP) -> List(FP)
     HenselLift1: (TP,List(TP),List(FP),List(FP),RP,RP,F) -> List(TP)
     mQuo: (TP,RP) -> TP

     reduceCoef(c:RP,p:RP):RP ==
        zero? p => c
        RP is Integer => symmetricRemainder(c,p)
        c rem p

     reduction(u:TP,p:RP):TP ==
        zero? p => u
        RP is Integer => map(symmetricRemainder(#1,p),u)
        map(#1 rem p,u)

     merge(p:RP,q:RP):Union(RP,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

     modInverse(c:RP,p:RP):RP ==
        (extendedEuclidean(c,p,1)::Record(coef1:RP,coef2:RP)).coef1

     exactquo(u:TP,v:TP,p:RP):Union(TP,"failed") ==
        invlcv:=modInverse(leadingCoefficient v,p)
        r:=monicDivide(u,reduction(invlcv*v,p))
        reduction(r.remainder,p) ^=0 => "failed"
        reduction(invlcv*r.quotient,p)

     FP:=EuclideanModularRing(RP,TP,RP,reduction,merge,exactquo)

     mQuo(poly:TP,n:RP) : TP == map(#1 quo n,poly)

     GenExEuclid(fl:List FP,cl:List FP,rhs:FP) :List FP ==
        [clp*rhs rem flp for clp in cl for flp in fl]

     -- generate the possible factors
     genFact(fln:List TP,factlist:List List TP) : List List TP ==
       factlist=[] => [[pol] for pol in fln]
       maxd := +/[degree f for f in fln] quo 2
       auxfl:List List TP := []
       for poly in fln while factlist^=[] repeat
         factlist := [term for term in factlist | ^member?(poly,term)]
         dp := degree poly
         for term in factlist repeat
           (+/[degree f for f in term]) + dp > maxd => "next term"
           auxfl := cons(cons(poly,term),auxfl)
       auxfl

     HenselLift1(poly:TP,fln:List TP,fl1:List FP,cl1:List FP,
                 prime:RP,Modulus:RP,cinv:RP):List TP ==
        lcp := leadingCoefficient poly
        rhs := reduce(mQuo(poly - lcp * */fln,Modulus),prime)
        zero? rhs => fln
        lcinv:=reduce(cinv::TP,prime)
        vl := GenExEuclid(fl1,cl1,lcinv*rhs)
        [flp + Modulus*(vlp::TP) for flp in fln for vlp in vl]

     HenselLift(poly:TP,tl1:List TP,prime:RP,bound:PI) ==
        -- convert tl1
        constp:TP:=0
        if degree first tl1 = 0 then
           constp:=tl1.first
           tl1 := rest tl1
        fl1:=[reduce(ttl,prime) for ttl in tl1]
        cl1 := multiEuclidean(fl1,1)::List FP
        Modulus:=prime
        fln :List TP := [ffl1::TP for ffl1 in fl1]
        lcinv:RP:=retract((inv
                  (reduce((leadingCoefficient poly)::TP,prime)))::TP)
        while euclideanSize(Modulus)<bound repeat
           nfln:=HenselLift1(poly,fln,fl1,cl1,prime,Modulus,lcinv)
           fln = nfln and zero?(err:=poly-*/fln) => leave "finished"
           fln := nfln
           Modulus := prime*Modulus
        if constp^=0 then fln:=cons(constp,fln)
        [fln,Modulus]

     completeHensel(m:TP,tl1:List TP,prime:RP,bound:PI) ==
      hlift:=HenselLift(m,tl1,prime,bound)
      Modulus:RP:=hlift.modulo
      fln:List TP:=hlift.plist
      nm := degree m
      u:Union(TP,"failed")
      aux,auxl,finallist:List TP
      auxfl,factlist:List List TP
      factlist := []
      dfn :NonNegativeInteger := nm
      lcm1 := leadingCoefficient m
      mm := lcm1*m
      while dfn>0 and (factlist := genFact(fln,factlist))^=[] repeat
        auxfl := []
        while factlist^=[] repeat
          auxl := factlist.first
          factlist := factlist.rest
          tc := reduceCoef((lcm1 * */[coefficient(poly,0)
                          for poly in auxl]), Modulus)
          coefficient(mm,0) exquo tc case "failed" =>
            auxfl := cons(auxl,auxfl)
          pol := */[poly for poly in auxl]
          poly :=reduction(lcm1*pol,Modulus)
          u := mm exquo poly
          u case "failed"  => auxfl := cons(auxl,auxfl)
          poly1: TP := primitivePart poly
          m := mQuo((u::TP),leadingCoefficient poly1)
          lcm1 := leadingCoefficient(m)
          mm := lcm1*m
          finallist := cons(poly1,finallist)
          dfn := degree m
          aux := []
          for poly in fln repeat
            ^member?(poly,auxl) => aux := cons(poly,aux)
            auxfl := [term for term in auxfl | ^member?(poly,term)]
            factlist := [term for term in factlist |^member?(poly,term)]
          fln := aux
        factlist := auxfl
      if dfn > 0 then finallist := cons(m,finallist)
      finallist

@
<<GHENSEL.dotabb>>=
"GHENSEL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GHENSEL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GHENSEL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENMFACT GeneralizedMultivariateFactorize}
\pagehead{GeneralizedMultivariateFactorize}{GENMFACT}
\pagepic{ps/v104generalizedmultivariatefactorize.ps}{GENMFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENMFACT GeneralizedMultivariateFactorize>>=
)abbrev package GENMFACT GeneralizedMultivariateFactorize
++ Author: P. Gianni
++ Date Created: 1983
++ Date Last Updated: Sept. 1990
++ Basic Functions:
++ Related Constructors: MultFiniteFactorize, AlgebraicMultFact, MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This is the top level package for doing multivariate factorization
++ over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.

GeneralizedMultivariateFactorize(OV,E,S,R,P) : C == T
 where
  R          :   IntegralDomain
                    -- with factor on R[x]
  S          :   IntegralDomain
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(R,E,OV)

  C == with
    factor      :      P  ->  Factored P
      ++ factor(p) factors the multivariate polynomial p over its coefficient
      ++ domain

  T == add
    factor(p:P) : Factored P ==
      R has FiniteFieldCategory => factor(p)$MultFiniteFactorize(OV,E,R,P)
      R is Polynomial(S) and S has EuclideanDomain =>
         factor(p)$MPolyCatPolyFactorizer(E,OV,S,P)
      R is Fraction(S) and S has CharacteristicZero and 
        S has EuclideanDomain =>
            factor(p)$MRationalFactorize(E,OV,S,P)
      R is Fraction Polynomial S =>
         factor(p)$MPolyCatRationalFunctionFactorizer(E,OV,S,P)
      R has CharacteristicZero and R has EuclideanDomain =>
               factor(p)$MultivariateFactorize(OV,E,R,P)
      squareFree p

@
<<GENMFACT.dotabb>>=
"GENMFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENMFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GENMFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENPGCD GeneralPolynomialGcdPackage}
\pagehead{GeneralPolynomialGcdPackage}{GENPGCD}
\pagepic{ps/v104generalpolynomialgcdpackage.ps}{GENPGCD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENPGCD GeneralPolynomialGcdPackage>>=
)abbrev package GENPGCD GeneralPolynomialGcdPackage
++ Description:
++ This package provides operations for GCD computations
++ on polynomials 
GeneralPolynomialGcdPackage(E,OV,R,P):C == T where
    R     :  PolynomialFactorizationExplicit
    P     :  PolynomialCategory(R,E,OV)
    OV    :  OrderedSet
    E     :  OrderedAbelianMonoidSup
 
    SUPP      ==> SparseUnivariatePolynomial P
--JHD    ContPrim  ==> Record(cont:P,prim:P)
 
    C == with
           gcdPolynomial     :   (SUPP,SUPP) -> SUPP
		++ gcdPolynomial(p,q) returns the GCD of p and q
           randomR        : ()                ->R
		++ randomR() should be local but conditional
--JHD      gcd               :   (P,P)    -> P
--JHD      gcd               :   List P   -> P
--JHD      gcdprim           :   (P,P)    -> P
--JHD      gcdprim           :   List P   -> P
 
--JHD      gcdcofact         :   List P   -> List P
--JHD      gcdcofactprim     :   List P   -> List P
 
--JHD      primitate         :   (P,OV)   -> P
--JHD      primitate         :    SUPP    -> SUPP
 
--JHD      content           :     P      -> P
--JHD      content           :   List P   -> List P
--JHD      contprim          :   List P   -> List ContPrim
 
--JHD      monomContent      :   (P,OV)   -> P
--JHD      monomContent      :    SUPP    -> SUPP
 
 
    T == add
 
      SUPR     ==> SparseUnivariatePolynomial R
--JHD      SUPLGcd  ==> Record(locgcd:SUPP,goodint:List R)
--JHD      LGcd     ==> Record(locgcd:P,goodint:List R)
--JHD      UTerm    ==> Record(lpol:List SUPR,lint:List R,mpol:P)
--JHD--JHD      pmod:R   :=  (prevPrime(2**26)$IntegerPrimesPackage(Integer))::R
 
--JHD      import MultivariateLifting(E,OV,R,P,pmod)
      import UnivariatePolynomialCategoryFunctions2(R,SUPR,P,SUPP)
      import UnivariatePolynomialCategoryFunctions2(P,SUPP,R,SUPR)
                 --------  Local  Functions  --------
 
--JHD      abs             :      P       -> P
      better          :    (P,P)     -> Boolean
--JHD      failtest        :   (P,P,P)    -> Boolean
--JHD      gcdMonom        :  (P,P,OV)    -> P
--JHD      gcdTermList     :    (P,P)     -> P
--JHD      gcdPrim         :  (P,P,OV)    -> P
--JHD      gcdSameMainvar  :  (P,P,OV)    -> P
--JHD      internal        :  (P,P,OV)    -> P
--JHD      good            :  (P,List OV) -> Record(upol:SUPR,inval:List R)
--JHD      gcdPrs          : (P,P,NNI,OV) -> Union(P,"failed")
--JHD
--JHD      chooseVal       :     (P,P,List OV)          -> UTerm
--JHD      localgcd        :     (P,P,List OV)          -> LGcd
--JHD      notCoprime      :  (P,P, List NNI,List OV)   -> P
--JHD      imposelc        : (List SUPR,List OV,List R,List P)  -> List SUPR
 
--JHD      lift? :(P,P,UTerm,List NNI,List OV)  -> Union("failed",P)
--      lift  :(P,SUPR,SUPR,P,List OV,List NNI,List R) -> P
      lift  :  (SUPR,SUPP,SUPR,List OV,List R) -> Union(SUPP,"failed")
         -- lifts first and third arguments as factors of the second
         -- fourth is number of variables.
--JHD      monomContent      :   (P,OV)   -> P
      monomContentSup   :    SUPP    -> SUPP
--
--JHD  gcdcofact         :   List P   -> List P
 
      gcdTrivial      :  (SUPP,SUPP)   -> SUPP
      gcdSameVariables:  (SUPP,SUPP,List OV)    -> SUPP
      recursivelyGCDCoefficients: (SUPP,List OV,SUPP,List OV) -> SUPP
      flatten         : (SUPP,List OV) -> SUPP
                        -- evaluates out all variables in the second
                        -- argument, leaving a polynomial of the same
                        -- degree
--    eval            : (SUPP,List OV,List R) -> SUPP
      variables       :  SUPP          -> List OV
                     ---- JHD's exported functions ---
      gcdPolynomial(p1:SUPP,p2:SUPP) ==
        zero? p1 => p2
        zero? p2 => p1
        0=degree p1  => gcdTrivial(p1,p2)
        0=degree p2  => gcdTrivial(p2,p1)
        if degree p1 < degree p2 then (p1,p2):=(p2,p1)
        p1 exquo p2 case SUPP  => (unitNormal p2).canonical
        c1:= monomContentSup(p1)
        c2:= monomContentSup(p2)
        p1:= (p1 exquo c1)::SUPP
        p2:= (p2 exquo c2)::SUPP
        (p1 exquo p2) case SUPP => (unitNormal p2).canonical * gcd(c1,c2)
        vp1:=variables p1
        vp2:=variables p2
        v1:=setDifference(vp1,vp2)
        v2:=setDifference(vp2,vp1)
        #v1 = 0 and #v2 = 0 => gcdSameVariables(p1,p2,vp1)*gcd(c1,c2)
                 -- all variables are in common
        v:=setDifference(vp1,v1)
        pp1:=flatten(p1,v1)
        pp2:=flatten(p2,v2)
        g:=gcdSameVariables(pp1,pp2,v)
--        one? g => gcd(c1,c2)::SUPP
        (g = 1) => gcd(c1,c2)::SUPP
        (#v1 = 0 or not (p1 exquo g) case "failed") and
                     -- if #vi = 0 then pp1 = p1, so we know g divides
              (#v2 = 0 or not (p2 exquo g) case "failed")
            => g*gcd(c1,c2)  -- divdes them both, so is the gcd
        -- OK, so it's not the gcd: try again
        v:=variables g -- there can be at most these variables in answer
        v1:=setDifference(vp1,v)
        v2:=setDifference(vp2,v)
        if (#v1 = 0) then g:= gcdSameVariables(g,flatten(p2,v2),v)
        else if (#v2=0) then g:=gcdSameVariables(g,flatten(p1,v1),v)
        else g:=gcdSameVariables(g,flatten(p1,v1)-flatten(p2,v2),v)
--        one? g => gcd(c1,c2)::SUPP
        (g = 1) => gcd(c1,c2)::SUPP
        (#v1 = 0 or not (p1 exquo g) case "failed") and
              (#v2 = 0 or not (p2 exquo g) case "failed")
            => g*gcd(c1,c2)::SUPP  -- divdes them both, so is the gcd
        v:=variables g -- there can be at most these variables in answer
        v1:=setDifference(vp1,v)
        if #v1 ^= 0 then
           g:=recursivelyGCDCoefficients(g,v,p1,v1)
--           one? g => return gcd(c1,c2)::SUPP
           (g = 1) => return gcd(c1,c2)::SUPP
           v:=variables g -- there can be at most these variables in answer
        v2:=setDifference(vp2,v)
        recursivelyGCDCoefficients(g,v,p2,v2)*gcd(c1,c2)
      if R has StepThrough then
         randomCount:R := init()
         randomR() ==
            (v:=nextItem(randomCount)) case R =>
                randomCount:=v
                v
            SAY("Taking next stepthrough range in GeneralPolynomialGcdPackage")$Lisp
            randomCount:=init()
            randomCount
      else
            randomR() == (random$Integer() rem 100)::R
                     ---- JHD's local functions ---
      gcdSameVariables(p1:SUPP,p2:SUPP,lv:List OV) ==
            -- two non-trivial primitive (or, at least, we don't care
            -- about content)
            -- polynomials with precisely the same degree
          #lv = 0 => map(#1::P,gcdPolynomial(map(ground,p1),
                                             map(ground,p2)))
          degree p2 = 1 =>
            p1 exquo p2 case SUPP => p2
            1
          gcdLC:=gcd(leadingCoefficient p1,leadingCoefficient p2)
          lr:=[randomR() for vv in lv]
          count:NonNegativeInteger:=0
          while count<10 repeat
	    while zero? eval(gcdLC,lv,lr) and count<10 repeat
		  lr:=[randomR() for vv in lv]
		  count:=count+1
	    count = 10 => error "too many evaluations in GCD code"
	    up1:SUPR:=map(ground eval(#1,lv,lr),p1)
	    up2:SUPR:=map(ground eval(#1,lv,lr),p2)
	    u:=gcdPolynomial(up1,up2)
	    degree u = 0 => return 1
            -- let's pick a second one, just to check
            lrr:=[randomR() for vv in lv]
	    while zero? eval(gcdLC,lv,lrr) and count<10 repeat
		  lrr:=[randomR() for vv in lv]
		  count:=count+1
	    count = 10 => error "too many evaluations in GCD code"
	    vp1:SUPR:=map(ground eval(#1,lv,lrr),p1)
	    vp2:SUPR:=map(ground eval(#1,lv,lrr),p2)
	    v:=gcdPolynomial(vp1,vp2)
	    degree v = 0 => return 1
            if degree v < degree u then
               u:=v
               up1:=vp1
               up2:=vp2
               lr:=lrr
	    up1:=(up1 exquo u)::SUPR
	    degree gcd(u,up1) = 0 =>
                ans:=lift(u,p1,up1,lv,lr)
                ans case SUPP => return ans
                "next"
	    up2:=(up2 exquo u)::SUPR
	    degree gcd(u,up2) = 0 =>
                ans:=lift(u,p2,up2,lv,lr)
                ans case SUPP => return ans
                "next"
	    -- so neither cofactor is relatively prime
	    count:=0
	    while count < 10 repeat
	       r:=randomR()
	       uu:=up1+r*up2
	       degree gcd(u,uu)=0 =>
                 ans:= lift(u,p1+r::P *p2,uu,lv,lr)
                 ans case SUPP => return ans
                 "next"
	    error "too many evaluations in GCD code"
          count >= 10 => error "too many evaluations in GCD code"
      lift(gR:SUPR,p:SUPP,cfR:SUPR,lv:List OV,lr:List R) ==
        -- lift the coprime factorisation gR*cfR = (univariate of p)
        -- where the variables lv have been evaluated at lr
        lcp:=leadingCoefficient p
        g:=monomial(lcp,degree gR)+map(#1::P,reductum gR)
        cf:=monomial(lcp,degree cfR)+map(#1::P,reductum cfR)
        p:=lcp*p       -- impose leaidng coefficient of p on each factor
        while lv ^= [] repeat
           v:=first lv
           r:=first lr
           lv:=rest lv
           lr:=rest lr
           thisp:=map(eval(#1,lv,lr),p)
           d:="max"/[degree(c,v) for c in coefficients p]
           prime:=v::P - r::P
           pn:=prime
           origFactors:=[g,cf]::List SUPP
           for n in 1..d repeat
              Ecart:=(thisp- g*cf) exquo pn
              Ecart case "failed" =>
                 error "failed lifting in hensel in Complex Polynomial GCD"
              zero? Ecart => leave
              step:=solveLinearPolynomialEquation(origFactors,
                                                  map(eval(#1,v,r),Ecart::SUPP))
              step case "failed" => return "failed"
              g:=g+pn*first step
              cf:=cf+pn*second step
              pn:=pn*prime
           thisp ^= g*cf => return "failed"
        g
      recursivelyGCDCoefficients(g:SUPP,v:List OV,p:SUPP,pv:List OV) ==
         mv:=first pv   -- take each coefficient w.r.t. mv
         pv:=rest pv    -- and recurse on pv as necessary
         d:="max"/[degree(u,mv) for u in coefficients p]
         for i in 0..d repeat
             p1:=map(coefficient(#1,mv,i),p)
             oldg:=g
             if pv = [] then g:=gcdSameVariables(g,p1,v)
             else g:=recursivelyGCDCoefficients(p,v,p1,pv)
--             one? g => return 1
             (g = 1) => return 1
             g^=oldg =>
                oldv:=v
                v:=variables g
                pv:=setUnion(pv,setDifference(v,oldv))
         g
      flatten(p1:SUPP,lv:List OV) ==
         #lv = 0 => p1
         lr:=[ randomR() for vv in lv]
         dg:=degree p1
         while dg ^= degree (ans:= map(eval(#1,lv,lr),p1)) repeat
           lr:=[ randomR() for vv in lv]
         ans
--      eval(p1:SUPP,lv:List OV,lr:List R) == map(eval(#1,lv,lr),p1)
      variables(p1:SUPP) ==
        removeDuplicates ("concat"/[variables u for u in coefficients p1])
      gcdTrivial(p1:SUPP,p2:SUPP) ==
        -- p1 is non-zero, but has degree zero
        -- p2 is non-zero
        cp1:=leadingCoefficient p1
--        one? cp1 => 1
        (cp1 = 1) => 1
        degree p2 = 0 => gcd(cp1,leadingCoefficient p2)::SUPP
        un?:=unit? cp1
        while not zero? p2 and not un? repeat
           cp1:=gcd(leadingCoefficient p2,cp1)
           un?:=unit? cp1
           p2:=reductum p2
        un? => 1
        cp1::SUPP
 
                     ---- Local  functions ----
--JHD    -- test if something wrong happened in the gcd
--JHD      failtest(f:P,p1:P,p2:P) : Boolean ==
--JHD        (p1 exquo f) case "failed" or (p2 exquo f) case "failed"
--JHD
--JHD    -- Choose the integers
--JHD      chooseVal(p1:P,p2:P,lvar:List OV):UTerm ==
--JHD        x:OV:=lvar.first
--JHD        lvr:=lvar.rest
--JHD        d1:=degree(p1,x)
--JHD        d2:=degree(p2,x)
--JHD        dd:NNI:=0$NNI
--JHD        nvr:NNI:=#lvr
--JHD        lval:List R :=[]
--JHD        range:I:=8
--JHD        for i in 1..  repeat
--JHD          range:=2*range
--JHD          lval:=[(random()$I rem (2*range) - range)::R  for i in 1..nvr]
--JHD          uf1:SUPR:=univariate eval(p1,lvr,lval)
--JHD          degree uf1 ^= d1 => "new point"
--JHD          uf2:SUPR:=univariate eval(p2,lvr,lval)
--JHD          degree uf2 ^= d2 => "new point"
--JHD          u:=gcd(uf1,uf2)
--JHD          du:=degree u
--JHD         --the univariate gcd is 1
--JHD          if du=0 then return [[1$SUPR],lval,0$P]$UTerm
--JHD
--JHD          ugcd:List SUPR:=[u,(uf1 exquo u)::SUPR,(uf2 exquo u)::SUPR]
--JHD          uterm:=[ugcd,lval,0$P]$UTerm
--JHD          dd=0 => dd:=du
--JHD
--JHD        --the degree is not changed
--JHD          du=dd =>
--JHD
--JHD           --test if one of the polynomials is the gcd
--JHD            dd=d1 =>
--JHD              if ^((f:=p2 exquo p1) case "failed") then
--JHD                return [[u],lval,p1]$UTerm
--JHD              if dd^=d2 then dd:=(dd-1)::NNI
--JHD
--JHD            dd=d2 =>
--JHD              if ^((f:=p1 exquo p2) case "failed") then
--JHD                return [[u],lval,p2]$UTerm
--JHD              dd:=(dd-1)::NNI
--JHD            return uterm
--JHD
--JHD         --the new gcd has degree less
--JHD          du<dd => dd:=du
--JHD
--JHD      good(f:P,lvr:List OV):Record(upol:SUPR,inval:List R) ==
--JHD        nvr:NNI:=#lvr
--JHD        range:I:=1
--JHD        ltry:List List R:=[]
--JHD        while true repeat
--JHD          range:=2*range
--JHD          lval:=[(random()$I rem (2*range) -range)::R  for i in 1..nvr]
--JHD          member?(lval,ltry) => "new point"
--JHD          ltry:=cons(lval,ltry)
--JHD          uf:=univariate eval(f,lvr,lval)
--JHD          if degree gcd(uf,differentiate uf)=0 then return [uf,lval]
--JHD
--JHD      -- impose the right lc
--JHD      imposelc(lipol:List SUPR,
--JHD               lvar:List OV,lval:List R,leadc:List P):List SUPR ==
--JHD        result:List SUPR :=[]
--JHD        lvar:=lvar.rest
--JHD        for pol in lipol for leadpol in leadc repeat
--JHD           p1:= univariate eval(leadpol,lvar,lval) * pol
--JHD           result:= cons((p1 exquo leadingCoefficient pol)::SUPR,result)
--JHD        reverse result
--JHD
--JHD    --Compute the gcd between not coprime polynomials
--JHD      notCoprime(g:P,p2:P,ldeg:List NNI,lvar:List OV) : P ==
--JHD        x:OV:=lvar.first
--JHD        lvar1:List OV:=lvar.rest
--JHD        lg1:=gcdcofact([g,differentiate(g,x)])
--JHD        g1:=lg1.1
--JHD        lg:LGcd:=localgcd(g1,p2,lvar)
--JHD        (l,lval):=(lg.locgcd,lg.goodint)
--JHD        p2:=(p2 exquo l)::P
--JHD        (gd1,gd2):=(l,l)
--JHD        ul:=univariate(eval(l,lvar1,lval))
--JHD        dl:=degree ul
--JHD        if degree gcd(ul,differentiate ul) ^=0 then
--JHD          newchoice:=good(l,lvar.rest)
--JHD          ul:=newchoice.upol
--JHD          lval:=newchoice.inval
--JHD        ug1:=univariate(eval(g1,lvar1,lval))
--JHD        ulist:=[ug1,univariate eval(p2,lvar1,lval)]
--JHD        lcpol:=[leadingCoefficient univariate(g1,x),
--JHD                leadingCoefficient univariate(p2,x)]
--JHD        while true repeat
--JHD          d:SUPR:=gcd(cons(ul,ulist))
--JHD          if degree d =0 then return gd1
--JHD          lquo:=(ul exquo d)::SUPR
--JHD          if degree lquo ^=0 then
--JHD            lgcd:=gcd(cons(leadingCoefficient univariate(l,x),lcpol))
--JHD            gd2:=lift(l,d,lquo,lgcd,lvar,ldeg,lval)
--JHD            l:=gd2
--JHD            ul:=univariate(eval(l,lvar1,lval))
--JHD            dl:=degree ul
--JHD          gd1:=gd1*gd2
--JHD          ulist:=[(uf exquo d)::SUPR for uf in ulist]
--JHD
--JHD -- we suppose that the poly have the same mainvar, deg p1<deg p2 and the
--JHD -- polys primitive
--JHD      internal(p1:P,p2:P,x:OV) : P ==
--JHD        lvar:List OV:=sort(#1>#2,setUnion(variables p1,variables p2))
--JHD        d1:=degree(p1,x)
--JHD        d2:=degree(p2,x)
--JHD        result: P:=localgcd(p1,p2,lvar).locgcd
--JHD        -- special cases
--JHD        result=1 => 1$P
--JHD        (dr:=degree(result,x))=d1 or dr=d2  => result
--JHD        while failtest(result,p1,p2) repeat
--JHD          SAY$Lisp  "retrying gcd"
--JHD          result:=localgcd(p1,p2,lvar).locgcd
--JHD        result
--JHD
--JHD    --local function for the gcd : it returns the evaluation point too
--JHD      localgcd(p1:P,p2:P,lvar:List(OV)) : LGcd ==
--JHD        x:OV:=lvar.first
--JHD        uterm:=chooseVal(p1,p2,lvar)
--JHD        listpol:= uterm.lpol
--JHD        ud:=listpol.first
--JHD        dd:= degree ud
--JHD
--JHD        --the univariate gcd is 1
--JHD        dd=0 => [1$P,uterm.lint]$LGcd
--JHD
--JHD        --one of the polynomials is the gcd
--JHD        dd=degree(p1,x) or dd=degree(p2,x) =>
--JHD                                           [uterm.mpol,uterm.lint]$LGcd
--JHD        ldeg:List NNI:=map(min,degree(p1,lvar),degree(p2,lvar))
--JHD
--JHD       -- if there is a polynomial g s.t. g/gcd and gcd are coprime ...
--JHD        -- I can lift
--JHD        (h:=lift?(p1,p2,uterm,ldeg,lvar)) case "failed" =>
--JHD          [notCoprime(p1,p2,ldeg,lvar),uterm.lint]$LGcd
--JHD        [h::P,uterm.lint]$LGcd
--JHD
--JHD
--JHD  -- content, internal functions return the poly if it is a monomial
--JHD      monomContent(p:P,var:OV):P ==
--JHD        ground? p => 1$P
--JHD        md:= minimumDegree(p,var)
--JHD        ((var::P)**md)*(gcd sort(better,coefficients univariate(p,var)))
 
      monomContentSup(u:SUPP):SUPP ==
        degree(u) = 0$NonNegativeInteger => 1$SUPP
        md:= minimumDegree u
        gcd(sort(better,coefficients u)) * monomial(1$P,md)$SUPP
 
--JHD  -- change the polynomials to have positive lc
--JHD      abs(p:P): P == unitNormal(p).canonical
 
  -- Ordering for gcd purposes
      better(p1:P,p2:P):Boolean ==
        ground? p1 => true
        ground? p2 => false
        degree(p1,mainVariable(p1)::OV) < degree(p2,mainVariable(p2)::OV)
 
   -- PRS algorithm
   -- gcdPrs(p1:P,p2:P,d:NNI,var:OV):Union(P,"failed") ==
   --   u1:= univariate(p1,var)
   --   u2:= univariate(p2,var)
   --   finished:Boolean:= false
   --   until finished repeat
   --     dd:NNI:=(degree u1 - degree u2)::NNI
   --     lc1:SUPP:=leadingCoefficient u2 * reductum u1
   --     lc2:SUPP:=leadingCoefficient u1 * reductum u2
   --     u3:SUPP:= primitate((lc1-lc2)*monomial(1$P,dd))$%
   --     (d3:=degree(u3)) <= d => finished:= true
   --     u1:= u2
   --     u2:= u3
   --     if d3 > degree(u1) then (u1,u2):= (u2,u1)
   --   g:= (u2 exquo u3)
   --   g case SUPP => abs multivariate(u3,var)
   --   "failed"
 
  -- Gcd between polynomial p1 and p2 with
  -- mainVariable p1 < x=mainVariable p2
--JHD      gcdTermList(p1:P,p2:P) : P ==
--JHD        termList:=sort(better,
--JHD           cons(p1,coefficients univariate(p2,(mainVariable p2)::OV)))
--JHD        q:P:=termList.first
--JHD        for term in termList.rest until q = 1$P repeat q:= gcd(q,term)
--JHD        q
--JHD
--JHD  -- Gcd between polynomials with the same mainVariable
--JHD      gcdSameMainvar(p1:P,p2:P,mvar:OV): P ==
--JHD        if degree(p1,mvar) < degree(p2,mvar) then (p1,p2):= (p2,p1)
--JHD        (p1 exquo p2) case P => abs p2
--JHD        c1:= monomContent(p1,mvar)$%
--JHD        c1 = p1 => gcdMonom(p1,p2,mvar)
--JHD        c2:= monomContent(p2,mvar)$%
--JHD        c2 = p2 => gcdMonom(p2,p1,mvar)
--JHD        p1:= (p1 exquo c1)::P
--JHD        p2:= (p2 exquo c2)::P
--JHD        if degree(p1,mvar) < degree(p2,mvar) then (p1,p2):= (p2,p1)
--JHD        (p1 exquo p2) case P => abs(p2) * gcd(c1,c2)
--JHD        abs(gcdPrim(p1,p2,mvar)) * gcd(c1,c2)
--JHD
--JHD   --  make the polynomial primitive with respect to var
--JHD      primitate(p:P,var:OV):P == (p exquo monomContent(p,var))::P
--JHD
--JHD      primitate(u:SUPP):SUPP == (u exquo monomContentSup u)::SUPP
--JHD
--JHD   -- gcd between primitive polynomials with the same mainVariable
--JHD      gcdPrim(p1:P,p2:P,mvar:OV):P ==
--JHD        vars:= removeDuplicates append(variables p1,variables p2)
--JHD        #vars=1 => multivariate(gcd(univariate p1,univariate p2),mvar)
--JHD        vars:=delete(vars,position(mvar,vars))
--JHD        --d:= degModGcd(p1,p2,mvar,vars)
--JHD        --d case "failed" => internal(p2,p1,mvar)
--JHD        --deg:= d:NNI
--JHD        --deg = 0$NNI => 1$P
--JHD        --deg = degree(p1,mvar) =>
--JHD        --  (p2 exquo p1) case P => abs(p1)  -- already know that
--JHD                                           -- ^(p1 exquo p2)
--JHD        --  internal(p2,p1,mvar)
--JHD        --cheapPrs?(p1,p2,deg,mvar) =>
--JHD        --  g:= gcdPrs(p1,p2,deg,mvar)
--JHD        --  g case P => g::P
--JHD        --  internal(p2,p1,mvar)
--JHD        internal(p2,p1,mvar)
--JHD
--JHD   -- gcd between a monomial and a polynomial
--JHD      gcdMonom(m:P,p:P,var:OV):P ==
--JHD        ((var::P) ** min(minimumDegree(m,var),minimumDegree(p,var))) *
--JHD          gcdTermList(leadingCoefficient(univariate(m,var)),p)
--JHD
--JHD    --If there is a pol s.t. pol/gcd and gcd are coprime I can lift
--JHD      lift?(p1:P,p2:P,uterm:UTerm,ldeg:List NNI,
--JHD                     lvar:List OV) : Union("failed",P) ==
--JHD        x:OV:=lvar.first
--JHD        leadpol:Boolean:=false
--JHD        (listpol,lval):=(uterm.lpol,uterm.lint)
--JHD        d:=listpol.first
--JHD        listpol:=listpol.rest
--JHD        nolift:Boolean:=true
--JHD        for uf in listpol repeat
--JHD              --note uf and d not necessarily primitive
--JHD          degree gcd(uf,d) =0 => nolift:=false
--JHD        nolift => "failed"
--JHD        f:P:=([p1,p2]$List(P)).(position(uf,listpol))
--JHD        lgcd:=gcd(leadingCoefficient univariate(p1,x),
--JHD                  leadingCoefficient univariate(p2,x))
--JHD        lift(f,d,uf,lgcd,lvar,ldeg,lval)
--JHD
--JHD   -- interface with the general "lifting" function
--JHD      lift(f:P,d:SUPR,uf:SUPR,lgcd:P,lvar:List OV,
--JHD                        ldeg:List NNI,lval:List R):P ==
--JHD        x:OV:=lvar.first
--JHD        leadpol:Boolean:=false
--JHD        lcf:P
--JHD        lcf:=leadingCoefficient univariate(f,x)
--JHD        df:=degree(f,x)
--JHD        leadlist:List(P):=[]
--JHD
--JHD        if lgcd^=1$P then
--JHD          leadpol:=true
--JHD          f:=lgcd*f
--JHD          ldeg:=[n0+n1 for n0 in ldeg for n1 in degree(lgcd,lvar)]
--JHD          lcd:R:=leadingCoefficient d
--JHD          if ground? lgcd then d:=((retract lgcd) *d exquo lcd)::SUPR
--JHD          else d:=(retract(eval(lgcd,lvar.rest,lval)) * d exquo lcd)::SUPR
--JHD          uf:=lcd*uf
--JHD        leadlist:=[lgcd,lcf]
--JHD        lg:=imposelc([d,uf],lvar,lval,leadlist)
--JHD        plist:=lifting(univariate(f,x),lvar,lg,lval,leadlist,ldeg)::List P
--JHD        (p0:P,p1:P):=(plist.first,plist.2)
--JHD        if univariate eval(p0,rest lvar,lval) ^= lg.first then
--JHD           (p0,p1):=(p1,p0)
--JHD        ^leadpol => p0
--JHD        cprim:=contprim([p0])
--JHD        cprim.first.prim
--JHD
--JHD  -- Gcd for two multivariate polynomials
--JHD      gcd(p1:P,p2:P) : P ==
--JHD        (p1:= abs(p1)) = (p2:= abs(p2)) => p1
--JHD        ground? p1 =>
--JHD          p1 = 1$P => p1
--JHD          p1 = 0$P => p2
--JHD          ground? p2 => gcd((retract p1)@R,(retract p2)@R)::P
--JHD          gcdTermList(p1,p2)
--JHD        ground? p2 =>
--JHD          p2 = 1$P => p2
--JHD          p2 = 0$P => p1
--JHD          gcdTermList(p2,p1)
--JHD        mv1:= mainVariable(p1)::OV
--JHD        mv2:= mainVariable(p2)::OV
--JHD        mv1 = mv2 => gcdSameMainvar(p1,p2,mv1)
--JHD        mv1 < mv2 => gcdTermList(p1,p2)
--JHD        gcdTermList(p2,p1)
--JHD
--JHD  -- Gcd for a list of multivariate polynomials
--JHD      gcd(listp:List P) : P ==
--JHD        lf:=sort(better,listp)
--JHD        f:=lf.first
--JHD        for g in lf.rest repeat
--JHD          f:=gcd(f,g)
--JHD          if f=1$P then return f
--JHD        f
--JHD   -- Gcd and cofactors for a list of polynomials
--JHD      gcdcofact(listp : List P) : List P ==
--JHD         h:=gcd listp
--JHD         cons(h,[(f exquo h) :: P  for f in listp])
--JHD
--JHD   -- Gcd for primitive polynomials
--JHD      gcdprim(p1:P,p2:P):P ==
--JHD        (p1:= abs(p1)) = (p2:= abs(p2)) => p1
--JHD        ground? p1 =>
--JHD          ground? p2 => gcd((retract p1)@R,(retract p2)@R)::P
--JHD          p1 = 0$P => p2
--JHD          1$P
--JHD        ground? p2 =>
--JHD          p2 = 0$P => p1
--JHD          1$P
--JHD        mv1:= mainVariable(p1)::OV
--JHD        mv2:= mainVariable(p2)::OV
--JHD        mv1 = mv2 =>
--JHD          md:=min(minimumDegree(p1,mv1),minimumDegree(p2,mv1))
--JHD          mp:=1$P
--JHD          if md>1 then
--JHD            mp:=(mv1::P)**md
--JHD            p1:=(p1 exquo mp)::P
--JHD            p2:=(p2 exquo mp)::P
--JHD          mp*gcdPrim(p1,p2,mv1)
--JHD        1$P
--JHD
--JHD  -- Gcd for a list of primitive multivariate polynomials
--JHD      gcdprim(listp:List P) : P ==
--JHD        lf:=sort(better,listp)
--JHD        f:=lf.first
--JHD        for g in lf.rest repeat
--JHD          f:=gcdprim(f,g)
--JHD          if f=1$P then return f
--JHD        f
--JHD   -- Gcd and cofactors for a list of primitive polynomials
--JHD      gcdcofactprim(listp : List P) : List P ==
--JHD         h:=gcdprim listp
--JHD         cons(h,[(f exquo h) :: P  for f in listp])
--JHD
--JHD   -- content of a polynomial (with respect to its main var)
--JHD      content(f:P):P ==
--JHD        ground? f => f
--JHD        x:OV:=(mainVariable f)::OV
--JHD        gcd sort(better,coefficients univariate(f,x))
--JHD
--JHD   -- contents of a list of polynomials
--JHD      content(listf:List P) : List P == [content f for f in listf]
--JHD
--JHD   -- contents and primitive parts of a list  of polynomials
--JHD      contprim(listf:List P) : List ContPrim ==
--JHD        prelim :List P := content listf
--JHD        [[q,(f exquo q)::P]$ContPrim for q in prelim for f in listf]
--JHD

@
<<GENPGCD.dotabb>>=
"GENPGCD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENPGCD"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GENPGCD" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENUPS GenerateUnivariatePowerSeries}
\pagehead{GenerateUnivariatePowerSeries}{GENUPS}
\pagepic{ps/v104generateunivariatepowerseries.ps}{GENUPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENUPS GenerateUnivariatePowerSeries>>=
)abbrev package GENUPS GenerateUnivariatePowerSeries
++ Author: Clifton J. Williamson
++ Date Created: 29 April 1990
++ Date Last Updated: 31 May 1990
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: series, Taylor, Laurent, Puiseux
++ Examples:
++ References:
++ Description:
++   \spadtype{GenerateUnivariatePowerSeries} provides functions that create
++   power series from explicit formulas for their \spad{n}th coefficient.
GenerateUnivariatePowerSeries(R,FE): Exports == Implementation where
  R  : Join(IntegralDomain,OrderedSet,RetractableTo Integer,_
            LinearlyExplicitRingOver Integer)
  FE : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
            FunctionSpace R)
  ANY1 ==> AnyFunctions1
  EQ   ==> Equation
  I    ==> Integer
  NNI  ==> NonNegativeInteger
  RN   ==> Fraction Integer
  SEG  ==> UniversalSegment
  ST   ==> Stream
  SY   ==> Symbol
  UTS  ==> UnivariateTaylorSeries
  ULS  ==> UnivariateLaurentSeries
  UPXS ==> UnivariatePuiseuxSeries
 
  Exports ==> with
    taylor: (I -> FE,EQ FE) -> Any
      ++ \spad{taylor(n +-> a(n),x = a)} returns
      ++ \spad{sum(n = 0..,a(n)*(x-a)**n)}.
    taylor: (FE,SY,EQ FE) -> Any
      ++ \spad{taylor(a(n),n,x = a)} returns \spad{sum(n = 0..,a(n)*(x-a)**n)}.
    taylor: (I -> FE,EQ FE,SEG NNI) -> Any
      ++ \spad{taylor(n +-> a(n),x = a,n0..)} returns
      ++ \spad{sum(n=n0..,a(n)*(x-a)**n)};
      ++ \spad{taylor(n +-> a(n),x = a,n0..n1)} returns
      ++ \spad{sum(n = n0..,a(n)*(x-a)**n)}.
    taylor: (FE,SY,EQ FE,SEG NNI) -> Any
      ++ \spad{taylor(a(n),n,x = a,n0..)} returns
      ++ \spad{sum(n = n0..,a(n)*(x-a)**n)};
      ++ \spad{taylor(a(n),n,x = a,n0..n1)} returns
      ++ \spad{sum(n = n0..,a(n)*(x-a)**n)}.
 
    laurent: (I -> FE,EQ FE,SEG I) -> Any
      ++ \spad{laurent(n +-> a(n),x = a,n0..)} returns
      ++ \spad{sum(n = n0..,a(n) * (x - a)**n)};
      ++ \spad{laurent(n +-> a(n),x = a,n0..n1)} returns
      ++ \spad{sum(n = n0..n1,a(n) * (x - a)**n)}.
    laurent: (FE,SY,EQ FE,SEG I) -> Any
      ++ \spad{laurent(a(n),n,x=a,n0..)} returns
      ++ \spad{sum(n = n0..,a(n) * (x - a)**n)};
      ++ \spad{laurent(a(n),n,x=a,n0..n1)} returns
      ++ \spad{sum(n = n0..n1,a(n) * (x - a)**n)}.
 
    puiseux: (RN -> FE,EQ FE,SEG RN,RN) -> Any
      ++ \spad{puiseux(n +-> a(n),x = a,r0..,r)} returns
      ++ \spad{sum(n = r0,r0 + r,r0 + 2*r..., a(n) * (x - a)**n)};
      ++ \spad{puiseux(n +-> a(n),x = a,r0..r1,r)} returns
      ++ \spad{sum(n = r0 + k*r while n <= r1, a(n) * (x - a)**n)}.
    puiseux: (FE,SY,EQ FE,SEG RN,RN) -> Any
      ++ \spad{puiseux(a(n),n,x = a,r0..,r)} returns
      ++ \spad{sum(n = r0,r0 + r,r0 + 2*r..., a(n) * (x - a)**n)};
      ++ \spad{puiseux(a(n),n,x = a,r0..r1,r)} returns
      ++ \spad{sum(n = r0 + k*r while n <= r1, a(n) * (x - a)**n)}.
 
    series: (I -> FE,EQ FE) -> Any
      ++ \spad{series(n +-> a(n),x = a)} returns
      ++ \spad{sum(n = 0..,a(n)*(x-a)**n)}.
    series: (FE,SY,EQ FE) -> Any
      ++ \spad{series(a(n),n,x = a)} returns
      ++ \spad{sum(n = 0..,a(n)*(x-a)**n)}.
    series: (I -> FE,EQ FE,SEG I) -> Any
      ++ \spad{series(n +-> a(n),x = a,n0..)} returns
      ++ \spad{sum(n = n0..,a(n) * (x - a)**n)};
      ++ \spad{series(n +-> a(n),x = a,n0..n1)} returns
      ++ \spad{sum(n = n0..n1,a(n) * (x - a)**n)}.
    series: (FE,SY,EQ FE,SEG I) -> Any
      ++ \spad{series(a(n),n,x=a,n0..)} returns
      ++ \spad{sum(n = n0..,a(n) * (x - a)**n)};
      ++ \spad{series(a(n),n,x=a,n0..n1)} returns
      ++ \spad{sum(n = n0..n1,a(n) * (x - a)**n)}.
    series: (RN -> FE,EQ FE,SEG RN,RN) -> Any
      ++ \spad{series(n +-> a(n),x = a,r0..,r)} returns
      ++ \spad{sum(n = r0,r0 + r,r0 + 2*r..., a(n) * (x - a)**n)};
      ++ \spad{series(n +-> a(n),x = a,r0..r1,r)} returns
      ++ \spad{sum(n = r0 + k*r while n <= r1, a(n) * (x - a)**n)}.
    series: (FE,SY,EQ FE,SEG RN,RN) -> Any
      ++ \spad{series(a(n),n,x = a,r0..,r)} returns
      ++ \spad{sum(n = r0,r0 + r,r0 + 2*r..., a(n) * (x - a)**n)};
      ++ \spad{series(a(n),n,x = a,r0..r1,r)} returns
      ++ \spad{sum(n = r0 + k*r while n <= r1, a(n) * (x - a)**n)}.
 
  Implementation ==> add
 
    genStream: (I -> FE,I) -> ST FE
    genStream(f,n) == delay concat(f(n),genStream(f,n + 1))
 
    genFiniteStream: (I -> FE,I,I) -> ST FE
    genFiniteStream(f,n,m) == delay
      n > m => empty()
      concat(f(n),genFiniteStream(f,n + 1,m))
 
    taylor(f,eq) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      coerce(series(genStream(f,0))$UTS(FE,x,a))$ANY1(UTS(FE,x,a))
 
    taylor(an:FE,n:SY,eq:EQ FE) ==
      taylor(eval(an,(n :: FE) = (#1 :: FE)),eq)
 
    taylor(f:I -> FE,eq:EQ FE,seg:SEG NNI) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      hasHi seg =>
        n0 := lo seg; n1 := hi seg
        if n1 < n0 then (n0,n1) := (n1,n0)
        uts := series(genFiniteStream(f,n0,n1))$UTS(FE,x,a)
        uts := uts * monomial(1,n0)$UTS(FE,x,a)
        coerce(uts)$ANY1(UTS(FE,x,a))
      n0 := lo seg
      uts := series(genStream(f,n0))$UTS(FE,x,a)
      uts := uts * monomial(1,n0)$UTS(FE,x,a)
      coerce(uts)$ANY1(UTS(FE,x,a))
 
    taylor(an,n,eq,seg) ==
      taylor(eval(an,(n :: FE) = (#1 :: FE)),eq,seg)
 
    laurent(f,eq,seg) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "taylor: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      hasHi seg =>
        n0 := lo seg; n1 := hi seg
        if n1 < n0 then (n0,n1) := (n1,n0)
        uts := series(genFiniteStream(f,n0,n1))$UTS(FE,x,a)
        coerce(laurent(n0,uts)$ULS(FE,x,a))$ANY1(ULS(FE,x,a))
      n0 := lo seg
      uts := series(genStream(f,n0))$UTS(FE,x,a)
      coerce(laurent(n0,uts)$ULS(FE,x,a))$ANY1(ULS(FE,x,a))
 
    laurent(an,n,eq,seg) ==
      laurent(eval(an,(n :: FE) = (#1 :: FE)),eq,seg)
 
    modifyFcn:(RN -> FE,I,I,I,I) -> FE
    modifyFcn(f,n0,nn,q,m) == (zero?((m - n0) rem nn) => f(m/q); 0)
 
    puiseux(f,eq,seg,r) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "puiseux: left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      not positive? r => error "puiseux: last argument must be positive"
      hasHi seg =>
        r0 := lo seg; r1 := hi seg
        if r1 < r0 then (r0,r1) := (r1,r0)
        p0 := numer r0; q0 := denom r0
        p1 := numer r1; q1 := denom r1
        p2 := numer r; q2 := denom r
        q := lcm(lcm(q0,q1),q2)
        n0 := p0 * (q quo q0); n1 := p1 * (q quo q1)
        nn := p2 * (q quo q2)
        ulsUnion := laurent(modifyFcn(f,n0,nn,q,#1),eq,segment(n0,n1))
        uls := retract(ulsUnion)$ANY1(ULS(FE,x,a))
        coerce(puiseux(1/q,uls)$UPXS(FE,x,a))$ANY1(UPXS(FE,x,a))
      p0 := numer(r0 := lo seg); q0 := denom r0
      p2 := numer r; q2 := denom r
      q := lcm(q0,q2)
      n0 := p0 * (q quo q0); nn := p2 * (q quo q2)
      ulsUnion := laurent(modifyFcn(f,n0,nn,q,#1),eq,segment n0)
      uls := retract(ulsUnion)$ANY1(ULS(FE,x,a))
      coerce(puiseux(1/q,uls)$UPXS(FE,x,a))$ANY1(UPXS(FE,x,a))
 
    puiseux(an,n,eq,r0,m) ==
      puiseux(eval(an,(n :: FE) = (#1 :: FE)),eq,r0,m)
 
    series(f:I -> FE,eq:EQ FE) == puiseux(f(numer #1),eq,segment 0,1)
    series(an:FE,n:SY,eq:EQ FE) == puiseux(an,n,eq,segment 0,1)
    series(f:I -> FE,eq:EQ FE,seg:SEG I) ==
      ratSeg : SEG RN := map(#1::RN,seg)$UniversalSegmentFunctions2(I,RN)
      puiseux(f(numer #1),eq,ratSeg,1)
    series(an:FE,n:SY,eq:EQ FE,seg:SEG I) ==
      ratSeg : SEG RN := map(#1::RN,seg)$UniversalSegmentFunctions2(I,RN)
      puiseux(an,n,eq,ratSeg,1)
    series(f:RN -> FE,eq:EQ FE,seg:SEG RN,r:RN) == puiseux(f,eq,seg,r)
    series(an:FE,n:SY,eq:EQ FE,seg:SEG RN,r:RN) == puiseux(an,n,eq,seg,r)

@
<<GENUPS.dotabb>>=
"GENUPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENUPS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"GENUPS" -> "ACF"
"GENUPS" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENEEZ GenExEuclid}
\pagehead{GenExEuclid}{GENEEZ}
\pagepic{ps/v104genexeuclid.ps}{GENEEZ}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENEEZ GenExEuclid>>=
)abbrev package GENEEZ GenExEuclid
++ Author : P.Gianni.
++ January 1990
++ The equation \spad{Af+Bg=h} and its generalization to n polynomials
++ is solved for solutions over the R, euclidean domain.
++ A table containing the solutions of \spad{Af+Bg=x**k} is used.
++ The operations are performed modulus a prime 
++ which are in principle big enough,
++ but the solutions are tested and, in case of failure, a hensel
++ lifting process is used to get to the right solutions.
++ It will be used in the factorization of multivariate polynomials
++ over finite field, with \spad{R=F[x]}.

GenExEuclid(R,BP) : C == T
 where
  R   :   EuclideanDomain
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  BP  :   UnivariatePolynomialCategory R
  L   ==> List

  C == with
       reduction: (BP,R) -> BP
         ++ reduction(p,prime) reduces the polynomial p modulo prime of R.
         ++ Note: this function is exported only because it's conditional.
       compBound: (BP,L BP) -> NNI
         ++ compBound(p,lp)
         ++ computes a bound for the coefficients of the solution
         ++ polynomials.
         ++ Given a polynomial right hand side p, 
         ++ and a list lp of left hand side polynomials.
         ++ Exported because it depends on the valuation.
       tablePow :    (NNI,R,L BP)     -> Union(Vector(L BP),"failed")
         ++ tablePow(maxdeg,prime,lpol) constructs the table with the
         ++ coefficients of the Extended Euclidean Algorithm for lpol.
         ++ Here the right side is \spad{x**k}, for k less or equal to maxdeg.
         ++ The operation returns "failed" when the elements 
         ++ are not coprime modulo prime.
       solveid  : (BP,R,Vector L BP) -> Union(L BP,"failed")
         ++ solveid(h,table) computes the coefficients of the
         ++ extended euclidean algorithm for a list of polynomials
         ++ whose tablePow is table and with right side h.

       testModulus : (R, L BP)    -> Boolean
         ++ testModulus(p,lp) returns true if the the prime p
         ++ is valid for the list of polynomials lp, i.e. preserves
         ++ the degree and they remain relatively prime.

  T == add
    if R has multiplicativeValuation then
      compBound(m:BP,listpolys:L BP) : NNI ==
        ldeg:=[degree f for f in listpolys]
        n:NNI:= (+/[df for df in ldeg])
        normlist:=[ +/[euclideanSize(u)**2 for u in coefficients f]
                         for f in listpolys]
        nm:= +/[euclideanSize(u)**2 for u in coefficients m]
	normprod := */[g**((n-df)::NNI) for g in normlist for df in ldeg]
        2*(approxSqrt(normprod * nm)$IntegerRoots(Integer))::NNI
    else if R has additiveValuation then
      -- a fairly crude Hadamard-style bound for the solution
      -- based on regarding the problem as a system of linear equations.
      compBound(m:BP,listpolys:L BP) : NNI ==
        "max"/[euclideanSize u for u in coefficients m] +
          +/["max"/[euclideanSize u for u in coefficients p]
             for p in listpolys]
    else
      compBound(m:BP,listpolys:L BP) : NNI ==
        error "attempt to use compBound without a well-understood valuation"
    if R has IntegerNumberSystem then
      reduction(u:BP,p:R):BP ==
        p = 0 => u
        map(symmetricRemainder(#1,p),u)
    else reduction(u:BP,p:R):BP ==
        p = 0 => u
        map(#1 rem p,u)

    merge(p:R,q:R):Union(R,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

    modInverse(c:R,p:R):R ==
        (extendedEuclidean(c,p,1)::Record(coef1:R,coef2:R)).coef1

    exactquo(u:BP,v:BP,p:R):Union(BP,"failed") ==
        invlcv:=modInverse(leadingCoefficient v,p)
        r:=monicDivide(u,reduction(invlcv*v,p))
        reduction(r.remainder,p) ^=0 => "failed"
        reduction(invlcv*r.quotient,p)

    FP:=EuclideanModularRing(R,BP,R,reduction,merge,exactquo)

    --make table global variable!
    table:Vector L BP
    import GeneralHenselPackage(R,BP)

                       --local  functions
    makeProducts :    L BP   -> L BP
    liftSol: (L BP,BP,R,R,Vector L BP,BP,NNI) -> Union(L BP,"failed")

    reduceList(lp:L BP,lmod:R): L FP ==[reduce(ff,lmod) for ff in lp]

    coerceLFP(lf:L FP):L BP == [fm::BP for fm in lf]

    liftSol(oldsol:L BP,err:BP,lmod:R,lmodk:R,
           table:Vector L BP,m:BP,bound:NNI):Union(L BP,"failed") ==
      euclideanSize(lmodk) > bound => "failed"
      d:=degree err
      ftab:Vector L FP :=
        map(reduceList(#1,lmod),table)$VectorFunctions2(List BP,List FP)
      sln:L FP:=[0$FP for xx in ftab.1 ]
      for i in 0 .. d |(cc:=coefficient(err,i)) ^=0 repeat
        sln:=[slp+reduce(cc::BP,lmod)*pp
              for pp in ftab.(i+1) for slp in sln]
      nsol:=[f-lmodk*reduction(g::BP,lmod) for f in oldsol for g in sln]
      lmodk1:=lmod*lmodk
      nsol:=[reduction(slp,lmodk1) for slp in nsol]
      lpolys:L BP:=table.(#table)
      (fs:=+/[f*g for f in lpolys for g in nsol]) = m => nsol
      a:BP:=((fs-m) exquo lmodk1)::BP
      liftSol(nsol,a,lmod,lmodk1,table,m,bound)

    makeProducts(listPol:L BP):L BP ==
      #listPol < 2 => listPol
      #listPol = 2 => reverse listPol
      f:= first listPol
      ll := rest listPol
      [*/ll,:[f*g for g in makeProducts ll]]

    testModulus(pmod, listPol) ==
         redListPol := reduceList(listPol, pmod)
         for pol in listPol for rpol in redListPol repeat
              degree(pol) ^= degree(rpol::BP) => return false
         while not empty? redListPol repeat
             rpol := first redListPol
             redListPol := rest redListPol
             for rpol2 in redListPol repeat
                gcd(rpol, rpol2) ^= 1 => return false
         true

    if R has Field then
      tablePow(mdeg:NNI,pmod:R,listPol:L BP) ==
        multiE:=multiEuclidean(listPol,1$BP)
        multiE case "failed" => "failed"
        ptable:Vector L BP :=new(mdeg+1,[])
        ptable.1:=multiE
        x:BP:=monomial(1,1)
        for i in 2..mdeg repeat ptable.i:=
            [tpol*x rem fpol for tpol in ptable.(i-1) for fpol in listPol]
        ptable.(mdeg+1):=makeProducts listPol
        ptable

      solveid(m:BP,pmod:R,table:Vector L BP) : Union(L BP,"failed") ==
            -- Actually, there's no possibility of failure
        d:=degree m
        sln:L BP:=[0$BP for xx in table.1]
        for i in 0 .. d | coefficient(m,i)^=0 repeat
          sln:=[slp+coefficient(m,i)*pp
                for pp in table.(i+1) for slp in sln]
        sln

    else

      tablePow(mdeg:NNI,pmod:R,listPol:L BP) ==
        listP:L FP:= [reduce(pol,pmod) for pol in listPol]
        multiE:=multiEuclidean(listP,1$FP)
        multiE case "failed" => "failed"
        ftable:Vector L FP :=new(mdeg+1,[])
        fl:L FP:= [ff::FP for ff in multiE]
        ftable.1:=[fpol for fpol in fl]
        x:FP:=reduce(monomial(1,1),pmod)
        for i in 2..mdeg repeat ftable.i:=
            [tpol*x rem fpol for tpol in ftable.(i-1) for fpol in listP]
        ptable:= map(coerceLFP,ftable)$VectorFunctions2(List FP,List BP)
        ptable.(mdeg+1):=makeProducts listPol
        ptable

      solveid(m:BP,pmod:R,table:Vector L BP) : Union(L BP,"failed") ==
        d:=degree m
        ftab:Vector L FP:=
          map(reduceList(#1,pmod),table)$VectorFunctions2(List BP,List FP)
        lpolys:L BP:=table.(#table)
        sln:L FP:=[0$FP for xx in ftab.1]
        for i in 0 .. d | coefficient(m,i)^=0 repeat
          sln:=[slp+reduce(coefficient(m,i)::BP,pmod)*pp
                for pp in ftab.(i+1) for slp in sln]
        soln:=[slp::BP for slp in sln]
        (fs:=+/[f*g for f in lpolys for g in soln]) = m=> soln
        -- Compute bound
        bound:=compBound(m,lpolys)
        a:BP:=((fs-m) exquo pmod)::BP
        liftSol(soln,a,pmod,pmod,table,m,bound)

@
<<GENEEZ.dotabb>>=
"GENEEZ" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENEEZ"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GENEEZ" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENUFACT GenUFactorize}
\pagehead{GenUFactorize}{GENUFACT}
\pagepic{ps/v104genufactorize.ps}{GENUFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENUFACT GenUFactorize>>=
)abbrev package GENUFACT GenUFactorize
++ Description
++ This package provides operations for the factorization 
++ of univariate polynomials with integer
++ coefficients. The factorization is done by "lifting" the
++ finite "berlekamp's" factorization
GenUFactorize(R) : public == private where
  R    :    EuclideanDomain
  PR   ==>  SparseUnivariatePolynomial R  -- with factor
            -- should be UnivariatePolynomialCategory
  NNI  ==>  NonNegativeInteger
  SUP  ==>  SparseUnivariatePolynomial
 
 
  public == with
     factor      :           PR  -> Factored PR
	++ factor(p) returns the factorisation of p
 
  private == add

    -- Factorisation currently fails when algebraic extensions have multiple
    -- generators.
    factorWarning(f:OutputForm):Void ==
      import AnyFunctions1(String)
      import AnyFunctions1(OutputForm)
      outputList(["WARNING (genufact): No known algorithm to factor "::Any, _
              f::Any, _
              ", trying square-free."::Any])$OutputPackage
 
    factor(f:PR) : Factored PR ==
      R is Integer => (factor f)$GaloisGroupFactorizer(PR)
 
      R is Fraction Integer  =>
                                (factor f)$RationalFactorize(PR)
 
--      R has Field and R has Finite =>
      R has FiniteFieldCategory =>
                                (factor f)$DistinctDegreeFactorize(R,PR)
 
      R is (Complex Integer) => (factor f)$ComplexFactorization(Integer,PR)
 
      R is (Complex Fraction Integer) =>
                           (factor f)$ComplexFactorization(Fraction Integer,PR)
 
      R is AlgebraicNumber =>   (factor f)$AlgFactor(PR)
 
   -- following is to handle SAE
      R has generator : () -> R =>
        var := symbol(convert(generator()::OutputForm)@InputForm)
        up:=UnivariatePolynomial(var,Fraction Integer)
        R has MonogenicAlgebra(Fraction Integer, up) =>
           factor(f)$SimpleAlgebraicExtensionAlgFactor(up, R, PR)
        upp:=UnivariatePolynomial(var,Fraction Polynomial Integer)
        R has MonogenicAlgebra(Fraction Polynomial Integer, upp) =>
           factor(f)$SAERationalFunctionAlgFactor(upp, R, PR)
        factorWarning(f::OutputForm)
        squareFree f            
      factorWarning(f::OutputForm)
      squareFree f

@
<<GENUFACT.dotabb>>=
"GENUFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENUFACT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"GENUFACT" -> "COMPCAT"
"GENUFACT" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTG0 GenusZeroIntegration}
\pagehead{GenusZeroIntegration}{INTG0}
\pagepic{ps/v104genuszerointegration.ps}{INTG0}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTG0 GenusZeroIntegration>>=
)abbrev package INTG0 GenusZeroIntegration
++ Rationalization of several types of genus 0 integrands;
++ Author: Manuel Bronstein
++ Date Created: 11 October 1988
++ Date Last Updated: 24 June 1994
++ Description:
++ This internal package rationalises integrands on curves of the form:
++   \spad{y\^2 = a x\^2 + b x + c}
++   \spad{y\^2 = (a x + b) / (c x + d)}
++   \spad{f(x, y) = 0} where f has degree 1 in x
++ The rationalization is done for integration, limited integration,
++ extended integration and the risch differential equation;
GenusZeroIntegration(R, F, L): Exports == Implementation where
  R: Join(GcdDomain, RetractableTo Integer, OrderedSet, CharacteristicZero,
          LinearlyExplicitRingOver Integer)
  F: Join(FunctionSpace R, AlgebraicallyClosedField,
          TranscendentalFunctionCategory)
  L: SetCategory

  SY  ==> Symbol
  Q   ==> Fraction Integer
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  UPUP ==> SparseUnivariatePolynomial RF
  IR  ==> IntegrationResult F
  LOG ==> Record(coeff:F, logand:F)
  U1  ==> Union(F, "failed")
  U2  ==> Union(Record(ratpart:F, coeff:F),"failed")
  U3  ==> Union(Record(mainpart:F, limitedlogs:List LOG), "failed")
  REC ==> Record(coeff:F, var:List K, val:List F)
  ODE ==> Record(particular: Union(F, "failed"), basis: List F)
  LODO==> LinearOrdinaryDifferentialOperator1 RF

  Exports ==> with
    palgint0   : (F, K, K, F, UP)    -> IR
      ++ palgint0(f, x, y, d, p) returns the integral of \spad{f(x,y)dx}
      ++ where y is an algebraic function of x satisfying
      ++ \spad{d(x)\^2 y(x)\^2 = P(x)}.
    palgint0   : (F, K, K, K, F, RF) -> IR
      ++ palgint0(f, x, y, z, t, c) returns the integral of \spad{f(x,y)dx}
      ++ where y is an algebraic function of x satisfying
      ++ \spad{f(x,y)dx = c f(t,y) dy}; c and t are rational functions of y.
      ++ Argument z is a dummy variable not appearing in \spad{f(x,y)}.
    palgextint0: (F, K, K, F, F, UP) -> U2
      ++ palgextint0(f, x, y, g, d, p) returns functions \spad{[h, c]} such
      ++ that \spad{dh/dx = f(x,y) - c g}, where y is an algebraic function
      ++ of x satisfying \spad{d(x)\^2 y(x)\^2 = P(x)},
      ++ or "failed" if no such functions exist.
    palgextint0: (F, K, K, F, K, F, RF) -> U2
      ++ palgextint0(f, x, y, g, z, t, c) returns functions \spad{[h, d]} such
      ++ that \spad{dh/dx = f(x,y) - d g}, where y is an algebraic function
      ++ of x satisfying \spad{f(x,y)dx = c f(t,y) dy}, and c and t are 
      ++ rational functions of y.
      ++ Argument z is a dummy variable not appearing in \spad{f(x,y)}.
      ++ The operation returns "failed" if no such functions exist.
    palglimint0: (F, K, K, List F, F, UP) -> U3
      ++ palglimint0(f, x, y, [u1,...,un], d, p) returns functions
      ++ \spad{[h,[[ci, ui]]]} such that the ui's are among \spad{[u1,...,un]}
      ++ and \spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist,
      ++ and "failed" otherwise.
      ++ Argument y is an algebraic function of x satisfying
      ++ \spad{d(x)\^2y(x)\^2 = P(x)}.
    palglimint0: (F, K, K, List F, K, F, RF) -> U3
      ++ palglimint0(f, x, y, [u1,...,un], z, t, c) returns functions
      ++ \spad{[h,[[ci, ui]]]} such that the ui's are among \spad{[u1,...,un]}
      ++ and \spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist,
      ++ and "failed" otherwise.
      ++ Argument y is an algebraic function of x satisfying
      ++ \spad{f(x,y)dx = c f(t,y) dy}; c and t are rational functions of y.
    palgRDE0   : (F, F, K, K, (F, F, SY) -> U1, F, UP) -> U1
      ++ palgRDE0(f, g, x, y, foo, d, p) returns a function \spad{z(x,y)}
      ++ such that \spad{dz/dx + n * df/dx z(x,y) = g(x,y)} if such a z exists,
      ++ and "failed" otherwise.
      ++ Argument y is an algebraic function of x satisfying
      ++ \spad{d(x)\^2y(x)\^2 = P(x)}.
      ++ Argument foo, called by \spad{foo(a, b, x)}, is a function that solves
      ++ \spad{du/dx + n * da/dx u(x) = u(x)}
      ++ for an unknown \spad{u(x)} not involving y.
    palgRDE0   : (F, F, K, K, (F, F, SY) -> U1, K, F, RF) -> U1
      ++ palgRDE0(f, g, x, y, foo, t, c) returns a function \spad{z(x,y)}
      ++ such that \spad{dz/dx + n * df/dx z(x,y) = g(x,y)} if such a z exists,
      ++ and "failed" otherwise.
      ++ Argument y is an algebraic function of x satisfying
      ++ \spad{f(x,y)dx = c f(t,y) dy}; c and t are rational functions of y.
      ++ Argument \spad{foo}, called by \spad{foo(a, b, x)}, is a function that
      ++ solves \spad{du/dx + n * da/dx u(x) = u(x)}
      ++ for an unknown \spad{u(x)} not involving y.
    univariate: (F, K, K, UP) -> UPUP
	++ univariate(f,k,k,p) \undocumented
    multivariate: (UPUP, K, F) -> F
	++ multivariate(u,k,f) \undocumented
    lift: (UP, K) -> UPUP
	++ lift(u,k) \undocumented
    if L has LinearOrdinaryDifferentialOperatorCategory F then
      palgLODE0  : (L, F, K, K, F, UP) -> ODE
        ++ palgLODE0(op, g, x, y, d, p) returns the solution of \spad{op f = g}.
        ++ Argument y is an algebraic function of x satisfying
        ++ \spad{d(x)\^2y(x)\^2 = P(x)}.
      palgLODE0  : (L, F, K, K, K, F, RF) -> ODE
        ++ palgLODE0(op,g,x,y,z,t,c) returns the solution of \spad{op f = g}
        ++ Argument y is an algebraic function of x satisfying
        ++ \spad{f(x,y)dx = c f(t,y) dy}; c and t are rational functions of y.

  Implementation ==> add
    import RationalIntegration(F, UP)
    import AlgebraicManipulations(R, F)
    import IntegrationResultFunctions2(RF, F)
    import ElementaryFunctionStructurePackage(R, F)
    import SparseUnivariatePolynomialFunctions2(F, RF)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                        K, R, P, F)

    mkRat    : (F, REC, List K) -> RF
    mkRatlx  : (F, K, K, F, K, RF) -> RF
    quadsubst: (K, K, F, UP) -> Record(diff:F, subs:REC, newk:List K)
    kerdiff  : (F, F) -> List K
    checkroot: (F, List K) -> F
    univ     : (F, List K, K) -> RF

    dummy := kernel(new()$SY)@K

    kerdiff(sa, a)         == setDifference(kernels sa, kernels a)
    checkroot(f, l)        == (empty? l => f; rootNormalize(f, first l))
    univ(c, l, x)          == univariate(checkroot(c, l), x)
    univariate(f, x, y, p) == lift(univariate(f, y, p), x)
    lift(p, k)             == map(univariate(#1, k), p)

    palgint0(f, x, y, den, radi) ==
      -- y is a square root so write f as f1 y + f0 and integrate separately
      ff := univariate(f, x, y, minPoly y)
      f0 := reductum ff
      pr := quadsubst(x, y, den, radi)
      map(#1(x::F), integrate(retract(f0)@RF)) +
        map(#1(pr.diff),
            integrate
              mkRat(multivariate(leadingMonomial ff,x,y::F), pr.subs, pr.newk))

-- the algebraic relation is (den * y)**2 = p  where p is a * x**2 + b * x + c
-- if p is squarefree, then parametrize in the following form:
--     u  = y - x \sqrt{a}
--     x  = (u^2 - c) / (b - 2 u \sqrt{a}) = h(u)
--     dx = h'(u) du
--     y  = (u + a h(u)) / den = g(u)
-- if a is a perfect square,
--     u  = (y - \sqrt{c}) / x
--     x  = (b - 2 u \sqrt{c}) / (u^2 - a) = h(u)
--     dx = h'(u) du
--     y  = (u h(u) + \sqrt{c}) / den = g(u)
-- otherwise.
-- if p is a square p = a t^2, then we choose only one branch for now:
--     u  = x
--     x  = u = h(u)
--     dx = du
--     y  = t \sqrt{a} / den = g(u)
-- returns [u(x,y), [h'(u), [x,y], [h(u), g(u)], l] in both cases,
-- where l is empty if no new square root was needed,
-- l := [k] if k is the new square root kernel that was created.
    quadsubst(x, y, den, p) ==
      u   := dummy::F
      b   := coefficient(p, 1)
      c   := coefficient(p, 0)
      sa  := rootSimp sqrt(a := coefficient(p, 2))
      zero?(b * b - 4 * a * c) =>    -- case where p = a (x + b/(2a))^2
        [x::F, [1, [x, y], [u, sa * (u + b / (2*a)) / eval(den,x,u)]], empty()]
      empty? kerdiff(sa, a) =>
        bm2u := b - 2 * u * sa
        q    := eval(den, x, xx := (u**2 - c) / bm2u)
        yy   := (ua := u + xx * sa) / q
        [y::F - x::F * sa, [2 * ua / bm2u, [x, y], [xx, yy]], empty()]
      u2ma:= u**2 - a
      sc  := rootSimp sqrt c
      q   := eval(den, x, xx := (b - 2 * u * sc) / u2ma)
      yy  := (ux := xx * u + sc) / q
      [(y::F - sc) / x::F, [- 2 * ux / u2ma, [x ,y], [xx, yy]], kerdiff(sc, c)]

    mkRatlx(f,x,y,t,z,dx) ==
      rat := univariate(eval(f, [x, y], [t, z::F]), z) * dx
      numer(rat) / denom(rat)

    mkRat(f, rec, l) ==
      rat:=univariate(checkroot(rec.coeff * eval(f,rec.var,rec.val), l), dummy)
      numer(rat) / denom(rat)

    palgint0(f, x, y, z, xx, dx) ==
      map(multivariate(#1, y), integrate mkRatlx(f, x, y, xx, z, dx))

    palgextint0(f, x, y, g, z, xx, dx) ==
      map(multivariate(#1, y),
            extendedint(mkRatlx(f,x,y,xx,z,dx), mkRatlx(g,x,y,xx,z,dx)))

    palglimint0(f, x, y, lu, z, xx, dx) ==
      map(multivariate(#1, y), limitedint(mkRatlx(f, x, y, xx, z, dx),
                             [mkRatlx(u, x, y, xx, z, dx) for u in lu]))

    palgRDE0(f, g, x, y, rischde, z, xx, dx) ==
      (u := rischde(eval(f, [x, y], [xx, z::F]),
                      multivariate(dx, z) * eval(g, [x, y], [xx, z::F]),
                          symbolIfCan(z)::SY)) case "failed" => "failed"
      eval(u::F, z, y::F)

-- given p = sum_i a_i(X) Y^i, returns  sum_i a_i(x) y^i
    multivariate(p, x, y) ==
      (map(multivariate(#1, x),
           p)$SparseUnivariatePolynomialFunctions2(RF, F))
              (y)

    palgextint0(f, x, y, g, den, radi) ==
      pr := quadsubst(x, y, den, radi)
      map(#1(pr.diff),
          extendedint(mkRat(f, pr.subs, pr.newk), mkRat(g, pr.subs, pr.newk)))

    palglimint0(f, x, y, lu, den, radi) ==
      pr := quadsubst(x, y, den, radi)
      map(#1(pr.diff),
         limitedint(mkRat(f, pr.subs, pr.newk),
                    [mkRat(u, pr.subs, pr.newk) for u in lu]))

    palgRDE0(f, g, x, y, rischde, den, radi) ==
      pr := quadsubst(x, y, den, radi)
      (u := rischde(checkroot(eval(f, pr.subs.var, pr.subs.val), pr.newk),
                   checkroot(pr.subs.coeff * eval(g, pr.subs.var, pr.subs.val),
                             pr.newk), symbolIfCan(dummy)::SY)) case "failed"
                                    => "failed"
      eval(u::F, dummy, pr.diff)

    if L has LinearOrdinaryDifferentialOperatorCategory F then
      import RationalLODE(F, UP)

      palgLODE0(eq, g, x, y, den, radi) ==
        pr := quadsubst(x, y, den, radi)
        d := monomial(univ(inv(pr.subs.coeff), pr.newk, dummy), 1)$LODO
        di:LODO := 1                  -- will accumulate the powers of d
        op:LODO := 0                  -- will accumulate the new LODO
        for i in 0..degree eq repeat
          op := op + univ(eval(coefficient(eq, i), pr.subs.var, pr.subs.val),
                        pr.newk, dummy) * di
          di := d * di
        rec := ratDsolve(op,univ(eval(g,pr.subs.var,pr.subs.val),pr.newk,dummy))
        bas:List(F) := [b(pr.diff) for b in rec.basis]
        rec.particular case "failed" => ["failed", bas]
        [((rec.particular)::RF) (pr.diff), bas]

      palgLODE0(eq, g, x, y, kz, xx, dx) ==
        d := monomial(univariate(inv multivariate(dx, kz), kz), 1)$LODO
        di:LODO := 1                  -- will accumulate the powers of d
        op:LODO := 0                  -- will accumulate the new LODO
        lk:List(K) := [x, y]
        lv:List(F) := [xx, kz::F]
        for i in 0..degree eq repeat
          op := op + univariate(eval(coefficient(eq, i), lk, lv), kz) * di
          di := d * di
        rec := ratDsolve(op, univariate(eval(g, lk, lv), kz))
        bas:List(F) := [multivariate(b, y) for b in rec.basis]
        rec.particular case "failed" => ["failed", bas]
        [multivariate((rec.particular)::RF, y), bas]

@
<<INTG0.dotabb>>=
"INTG0" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTG0"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"INTG0" -> "FS"
"INTG0" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GRDEF GraphicsDefaults}
\pagehead{GraphicsDefaults}{GRDEF}
\pagepic{ps/v104graphicsdefaults.ps}{GRDEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GRDEF GraphicsDefaults>>=
)abbrev package GRDEF GraphicsDefaults
++ Author: Clifton J. Williamson
++ Date Created: 8 January 1990
++ Date Last Updated: 8 January 1990
++ Basic Operations: clipPointsDefault, drawToScale, adaptive, maxPoints,
++ minPoints, screenResolution
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TwoDimensionalPlotSettings sets global flags and constants 
++ for 2-dimensional plotting.

GraphicsDefaults(): Exports == Implementation where
  B  ==> Boolean
  I  ==> Integer
  SF ==> DoubleFloat
  maxWidth  ==> 1000
  maxHeight ==> 1000

  Exports ==> with
    clipPointsDefault: () -> B
      ++ clipPointsDefault() determines whether or not automatic clipping is 
      ++ to be done.
    drawToScale: () -> B
      ++ drawToScale() determines whether or not plots are to be drawn to scale.

    clipPointsDefault: B -> B
      ++ clipPointsDefault(true) turns on automatic clipping;
      ++ \spad{clipPointsDefault(false)} turns off automatic clipping.
      ++ The default setting is true.
    drawToScale: B -> B
      ++ drawToScale(true) causes plots to be drawn to scale.
      ++ \spad{drawToScale(false)} causes plots to be drawn so that they
      ++ fill up the viewport window.
      ++ The default setting is false.

--% settings from the two-dimensional plot package

    adaptive: () -> B
      ++ adaptive() determines whether plotting will be done adaptively.
    maxPoints: () -> I
      ++ maxPoints() returns the maximum number of points in a plot.
    minPoints: () -> I
      ++ minPoints() returns the minimum number of points in a plot.
    screenResolution: () -> I
      ++ screenResolution() returns the screen resolution n.

    adaptive: B -> B
      ++ adaptive(true) turns adaptive plotting on;
      ++ \spad{adaptive(false)} turns adaptive plotting off.
    maxPoints: I -> I
      ++ maxPoints() sets the maximum number of points in a plot.
    minPoints: I -> I
      ++ minPoints() sets the minimum number of points in a plot.
    screenResolution: I -> I
      ++ screenResolution(n) sets the screen resolution to n.

  Implementation ==> add

--% global flags and constants

    CLIPPOINTSDEFAULT : B := true
    TOSCALE  : B := false

--% functions

    clipPointsDefault()     == CLIPPOINTSDEFAULT
    drawToScale()  == TOSCALE

    clipPointsDefault b    == CLIPPOINTSDEFAULT := b
    drawToScale b == TOSCALE := b

--% settings from the two-dimensional plot package

    adaptive() == adaptive?()$Plot
    minPoints() == minPoints()$Plot
    maxPoints() == maxPoints()$Plot
    screenResolution() == screenResolution()$Plot

    adaptive b == setAdaptive(b)$Plot
    minPoints n == setMinPoints(n)$Plot
    maxPoints n == setMaxPoints(n)$Plot
    screenResolution n == setScreenResolution(n)$Plot

@
<<GRDEF.dotabb>>=
"GRDEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GRDEF"]
"Package" [color="#FF4488"]
"GRDEF" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GBF GroebnerFactorizationPackage}
<<GroebnerFactorizationPackage.input>>=
-- groebf.spad.pamphlet GroebnerFactorizationPackage.input
)sys rm GroebnerFactorizationPackage.output
)spool GroebnerFactorizationPackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 3
mfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ]
--R 
--R
--R        +0  1  1  1  1  1+
--R        |                |
--R        |         8     8|
--R        |1  0  1  -  x  -|
--R        |         3     3|
--R        |                |
--R        |            8   |
--R        |1  1  0  1  -  y|
--R        |            3   |
--R        |                |
--R   (1)  |   8           8|
--R        |1  -  1  0  1  -|
--R        |   3           3|
--R        |                |
--R        |      8         |
--R        |1  x  -  1  0  1|
--R        |      3         |
--R        |                |
--R        |   8     8      |
--R        |1  -  y  -  1  0|
--R        +   3     3      +
--RType: SquareMatrix(6,DistributedMultivariatePolynomial([x,y,z],Fraction Integer))
--E 1

--S 2 of 3
eq := determinant mfzn
--R 
--R
--R   (2)
--R      2 2   22  2    25  2   22    2   388       250     25  2   250     14575
--R   - x y  + -- x y - -- x  + -- x y  - --- x y - --- x - -- y  - --- y + -----
--R             3        9       3         9         27      9       27       81
--R            Type: DistributedMultivariatePolynomial([x,y,z],Fraction Integer)
--E 2

--S 3 of 3
groebnerFactorize [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])] 
--R 
--R
--R   (3)
--R   [
--R                  22           22     22     121
--R     [x y + x z - -- x + y z - -- y - -- z + ---,
--R                   3            3      3      3
--R         2   22       25        2   22       25     22  2   388     250
--R      x z  - -- x z + -- x + y z  - -- y z + -- y - -- z  + --- z + ---,
--R              3        9             3        9      3       9       27
--R       2 2   22  2    25  2   22    2   388       250     25  2   250     14575
--R      y z  - -- y z + -- y  - -- y z  + --- y z + --- y + -- z  + --- z - -----]
--R              3        9       3         9         27      9       27       81
--R     ,
--R             21994  2   21994     4427     463
--R    [x + y - -----,y  - ----- y + ----,z - ---],
--R              5625       5625      675      87
--R      2   1       11     5     265        2   38     265
--R    [x  - - x z - -- x - - z + ---,y - z,z  - -- z + ---],
--R          2        2     6      18             3      9
--R         25     11     11        11     11     11        5     5     5
--R    [x - --,y - --,z - --], [x - --,y - --,z - --], [x + -,y + -,z + -],
--R          9      3      3         3      3      3        3     3     3
--R         19     5     5
--R    [x - --,y + -,z + -]]
--R          3     3     3
--R  Type: List List DistributedMultivariatePolynomial([x,y,z],Fraction Integer)
--E 3
)spool
)lisp (bye)
@
<<GroebnerFactorizationPackage.help>>=
====================================================================
GroebnerFactorizationPackage examples
====================================================================

Solving systems of polynomial equations with the Groebner basis
algorithm can often be very time consuming because, in general, the
algorithm has exponential run-time.  These systems, which often come
from concrete applications, frequently have symmetries which are not
taken advantage of by the algorithm.  However, it often happens in
this case that the polynomials which occur during the Groebner
calculations are reducible.  Since Axiom has an excellent polynomial
factorization algorithm, it is very natural to combine the Groebner
and factorization algorithms.

GroebnerFactorizationPackage exports the groebnerFactorize operation
which implements a modified Groebner basis algorithm.  In this
algorithm, each polynomial that is to be put into the partial list of
the basis is first factored.  The remaining calculation is split into
as many parts as there are irreducible factors.  Call these factors
p1,...,pN. In the branches corresponding to p2,...,pN, the factor p1
can be divided out, and so on.  This package also contains operations
that allow you to specify the polynomials that are not zero on the
common roots of the final Groebner basis.

Here is an example from chemistry.  In a theoretical model of the
cyclohexan C6H12, the six carbon atoms each sit in the center of
gravity of a tetrahedron that has two hydrogen atoms and two carbon
atoms at its corners.  We first normalize and set the length of each
edge to 1.  Hence, the distances of one fixed carbon atom to each of
its immediate neighbours is 1.  We will denote the distances to the
other three carbon atoms by x, y and z.

A. Dress developed a theory to decide whether a set of points
and distances between them can be realized in an n-dimensional space.
Here, of course, we have n = 3.

  mfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := _
   [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], _
     [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ]
        +0  1  1  1  1  1+
        |                |
        |         8     8|
        |1  0  1  -  x  -|
        |         3     3|
        |                |
        |            8   |
        |1  1  0  1  -  y|
        |            3   |
        |                |
        |   8           8|
        |1  -  1  0  1  -|
        |   3           3|
        |                |
        |      8         |
        |1  x  -  1  0  1|
        |      3         |
        |                |
        |   8     8      |
        |1  -  y  -  1  0|
        +   3     3      +
Type: SquareMatrix(6,DistributedMultivariatePolynomial([x,y,z],
                      Fraction Integer))

For the cyclohexan, the distances have to satisfy this equation.

  eq := determinant mfzn
      2 2   22  2    25  2   22    2   388       250     25  2   250     14575
   - x y  + -- x y - -- x  + -- x y  - --- x y - --- x - -- y  - --- y + -----
             3        9       3         9         27      9       27       81
            Type: DistributedMultivariatePolynomial([x,y,z],Fraction Integer)

They also must satisfy the equations given by cyclic shifts of the
indeterminates.

  groebnerFactorize [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])] 
   [
                 22           22     22     121
    [x y + x z - -- x + y z - -- y - -- z + ---,
                  3            3      3      3
        2   22       25        2   22       25     22  2   388     250
     x z  - -- x z + -- x + y z  - -- y z + -- y - -- z  + --- z + ---,
             3        9             3        9      3       9       27
      2 2   22  2    25  2   22    2   388       250     25  2   250     14575
     y z  - -- y z + -- y  - -- y z  + --- y z + --- y + -- z  + --- z - -----]
             3        9       3         9         27      9       27       81
    ,
            21994  2   21994     4427     463
   [x + y - -----,y  - ----- y + ----,z - ---],
             5625       5625      675      87
     2   1       11     5     265        2   38     265
   [x  - - x z - -- x - - z + ---,y - z,z  - -- z + ---],
         2        2     6      18             3      9
        25     11     11        11     11     11        5     5     5
   [x - --,y - --,z - --], [x - --,y - --,z - --], [x + -,y + -,z + -],
         9      3      3         3      3      3        3     3     3
        19     5     5
   [x - --,y + -,z + -]]
         3     3     3
  Type: List List DistributedMultivariatePolynomial([x,y,z],Fraction Integer)

The union of the solutions of this list is the solution of our original 
problem.  If we impose positivity conditions, we get two relevant ideals.  
One ideal is zero-dimensional, namely x = y = z =11/3, and this determines 
the "boat" form of the cyclohexan.  The other ideal is one-dimensional, 
which means that we have a solution space given by one parameter.  This 
gives the "chair" form of the cyclohexan.  The parameter describes the 
angle of the "back of the chair."

groebnerFactorize has an optional Boolean-valued second argument.
When it is true partial results are displayed, since it may happen
that the calculation does not terminate in a reasonable time.  See the
source code for GroebnerFactorizationPackage in groebf.spad.pamphlet
for more details about the algorithms used.

See Also:
o )display operations groebnerFactorize
o )show GroebnerFactorizationPackage
o) show GroebnerPackage
o )show EuclideanGroebnerBasisPackage

@
\pagehead{GroebnerFactorizationPackage}{GBF}
\pagepic{ps/v104groebnerfactorizationpackage.ps}{GBF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GBF GroebnerFactorizationPackage>>=
)abbrev package GBF GroebnerFactorizationPackage
++ Author: H. Michael Moeller, Johannes Grabmeier
++ Date Created: 24 August 1989
++ Date Last Updated: 01 January 1992
++ Basic Operations: groebnerFactorize factorGroebnerBasis
++ Related Constructors:
++ Also See: GroebnerPackage, Ideal, IdealDecompositionPackage
++ AMS Classifications:
++ Keywords: groebner basis, groebner factorization, ideal decomposition
++ References:
++ Description:
++   \spadtype{GroebnerFactorizationPackage} provides the function
++   groebnerFactor" which uses the factorization routines of \Language{} to
++   factor each polynomial under consideration while doing the groebner basis
++   algorithm. Then it writes the ideal as an intersection of ideals
++   determined by the irreducible factors. Note that the whole ring may
++   occur as well as other redundancies. We also use the fact, that from the
++   second factor on we can assume that the preceding factors are
++   not equal to 0 and we divide all polynomials under considerations
++   by the elements of this list of "nonZeroRestrictions".
++   The result is a list of groebner bases, whose union of solutions
++   of the corresponding systems of equations is the solution of
++   the system of equation corresponding to the input list.
++   The term ordering is determined by the polynomial type used.
++   Suggested types include
++   \spadtype{DistributedMultivariatePolynomial},
++   \spadtype{HomogeneousDistributedMultivariatePolynomial},
++   \spadtype{GeneralDistributedMultivariatePolynomial}.

GroebnerFactorizationPackage(Dom, Expon, VarSet, Dpol): T == C where

 Dom :    Join(EuclideanDomain,CharacteristicZero)
 Expon :  OrderedAbelianMonoidSup
 VarSet : OrderedSet
 Dpol: PolynomialCategory(Dom, Expon, VarSet)
 MF       ==>   MultivariateFactorize(VarSet,Expon,Dom,Dpol)
 sugarPol ==>   Record(totdeg: NonNegativeInteger, pol : Dpol)
 critPair ==>   Record(lcmfij: Expon,totdeg: NonNegativeInteger, poli: Dpol, polj: Dpol )
 L        ==>   List
 B        ==>   Boolean
 NNI      ==>   NonNegativeInteger
 OUT      ==>   OutputForm

 T ==> with

   factorGroebnerBasis : L Dpol -> L L Dpol
     ++ factorGroebnerBasis(basis) checks whether the basis contains
     ++ reducible polynomials and uses these to split the basis.
   factorGroebnerBasis : (L Dpol, Boolean) -> L L Dpol
     ++ factorGroebnerBasis(basis,info) checks whether the basis contains
     ++ reducible polynomials and uses these to split the basis.
     ++ If argument {\em info} is true, information is printed about
     ++ partial results.
   groebnerFactorize : (L Dpol, L Dpol) -> L L Dpol
     ++ groebnerFactorize(listOfPolys, nonZeroRestrictions) returns
     ++ a list of groebner basis. The union of their solutions
     ++ is the solution of the system of equations given by {\em listOfPolys}
     ++ under the restriction that the polynomials of {\em nonZeroRestrictions}
     ++ don't vanish.
     ++ At each stage the polynomial p under consideration (either from
     ++ the given basis or obtained from a reduction of the next S-polynomial)
     ++ is factorized. For each irreducible factors of p, a
     ++ new {\em createGroebnerBasis} is started
     ++ doing the usual updates with the factor
     ++ in place of p.
   groebnerFactorize : (L Dpol, L Dpol, Boolean) -> L L Dpol
     ++ groebnerFactorize(listOfPolys, nonZeroRestrictions, info) returns
     ++ a list of groebner basis. The union of their solutions
     ++ is the solution of the system of equations given by {\em listOfPolys}
     ++ under the restriction that the polynomials of {\em nonZeroRestrictions}
     ++ don't vanish.
     ++ At each stage the polynomial p under consideration (either from
     ++ the given basis or obtained from a reduction of the next S-polynomial)
     ++ is factorized. For each irreducible factors of p a
     ++ new {\em createGroebnerBasis} is started 
     ++ doing the usual updates with the factor in place of p.
     ++ If argument {\em info} is true, information is printed about
     ++ partial results.
   groebnerFactorize : L Dpol  -> L L Dpol
     ++ groebnerFactorize(listOfPolys) returns 
     ++ a list of groebner bases. The union of their solutions
     ++ is the solution of the system of equations given by {\em listOfPolys}.
     ++ At each stage the polynomial p under consideration (either from
     ++ the given basis or obtained from a reduction of the next S-polynomial)
     ++ is factorized. For each irreducible factors of p, a
     ++ new {\em createGroebnerBasis} is started 
     ++ doing the usual updates with the factor 
     ++ in place of p.
     ++
     ++X mfzn : SQMATRIX(6,DMP([x,y,z],Fraction INT)) := _
     ++X   [ [0,1,1,1,1,1], [1,0,1,8/3,x,8/3], [1,1,0,1,8/3,y], _
     ++X   [1,8/3,1,0,1,8/3], [1,x,8/3,1,0,1], [1,8/3,y,8/3,1,0] ]
     ++X eq := determinant mfzn
     ++X groebnerFactorize _
     ++X   [eq,eval(eq, [x,y,z],[y,z,x]), eval(eq,[x,y,z],[z,x,y])] 
   groebnerFactorize : (L Dpol, Boolean)  -> L L Dpol
     ++ groebnerFactorize(listOfPolys, info) returns
     ++ a list of groebner bases. The union of their solutions
     ++ is the solution of the system of equations given by {\em listOfPolys}.
     ++ At each stage the polynomial p under consideration (either from
     ++ the given basis or obtained from a reduction of the next S-polynomial)
     ++ is factorized. For each irreducible factors of p, a
     ++ new {\em createGroebnerBasis} is started 
     ++ doing the usual updates with the factor
     ++ in place of p.
     ++ If {\em info} is true, information is printed about partial results.

 C ==> add

   import GroebnerInternalPackage(Dom,Expon,VarSet,Dpol)
   -- next to help compiler to choose correct signatures:
   info: Boolean
   -- signatures of local functions

   newPairs : (L sugarPol, Dpol) -> L critPair
     -- newPairs(lp, p) constructs list of critical pairs from the list of
     -- {\em lp} of input polynomials and a given further one p.
     -- It uses criteria M and T to reduce the list.
   updateCritPairs : (L critPair, L critPair, Dpol) -> L critPair
     -- updateCritPairs(lcP1,lcP2,p) applies criterion B to {\em lcP1} using
     -- p. Then this list is merged with {\em lcP2}.
   updateBasis : (L sugarPol, Dpol, NNI) -> L sugarPol
     -- updateBasis(li,p,deg) every polynomial in {\em li} is dropped if
     -- its leading term is a multiple of the leading term of p.
     -- The result is this list enlarged by p.
   createGroebnerBases : (L sugarPol, L Dpol, L Dpol, L Dpol, L critPair,_
                          L L Dpol, Boolean) -> L L Dpol
     -- createGroebnerBases(basis, redPols, nonZeroRestrictions, inputPolys,
     --   lcP,listOfBases): This function is used to be called from
     -- groebnerFactorize.
     -- basis: part of a Groebner basis, computed so far
     -- redPols: Polynomials from the ideal to be used for reducing,
     --   we don't throw away polynomials
     -- nonZeroRestrictions: polynomials not zero in the common zeros
     --   of the polynomials in the final (Groebner) basis
     -- inputPolys: assumed to be in descending order
     -- lcP: list of critical pairs built from polynomials of the
     --   actual basis
     -- listOfBases: Collects the (Groebner) bases constructed by this
     --   recursive algorithm at different stages.
     --   we print info messages if info is true
   createAllFactors: Dpol -> L Dpol
     -- factor reduced critpair polynomial

   -- implementation of local functions


   createGroebnerBases(basis, redPols, nonZeroRestrictions, inputPolys,_
       lcP, listOfBases, info) ==
     doSplitting? : B := false
     terminateWithBasis : B := false
     allReducedFactors : L Dpol := []
     nP : Dpol  -- actual polynomial under consideration
     p :  Dpol  -- next polynomial from input list
     h :  Dpol  -- next polynomial from critical pairs
     stopDividing : Boolean
     --    STEP 1   do the next polynomials until a splitting is possible
     -- In the first step we take the first polynomial of "inputPolys"
     -- if empty, from list of critical pairs "lcP" and do the following:
     -- Divide it, if possible, by the polynomials from "nonZeroRestrictions".
     -- We factorize it and reduce each irreducible  factor with respect to
     -- "basis". If 0$Dpol occurs in the list we update the list and continue
     -- with next polynomial.
     -- If there are at least two (irreducible) factors
     -- in the list of factors we finish STEP 1 and set a boolean variable
     -- to continue with STEP 2, the splitting step.
     -- If there is just one of it, we do the following:
     -- If it is 1$Dpol we stop the whole calculation and put
     -- [1$Dpol] into the listOfBases
     -- Otherwise we update the "basis" and the other lists and continue
     -- with next polynomial.

     while (not doSplitting?) and (not terminateWithBasis) repeat
       terminateWithBasis := (null inputPolys and null lcP)
       not terminateWithBasis =>  -- still polynomials left
         -- determine next polynomial "nP"
         nP :=
           not null inputPolys =>
             p := first inputPolys
             inputPolys := rest inputPolys
             -- we know that p is not equal to 0 or 1, but, although,
             -- the inputPolys and the basis are ordered, we cannot assume
             -- that p is reduced w.r.t. basis, as the ordering is only quasi
             -- and we could have equal leading terms, and due to factorization
             -- polynomials of smaller leading terms, hence reduce p first:
             hMonic redPol(p,redPols)
           -- now we have inputPolys empty and hence lcP is not empty:
           -- create S-Polynomial from first critical pair:
           h := sPol first lcP
           lcP := rest lcP
           hMonic redPol(h,redPols)

         nP = 1$Dpol =>
           basis := [[0,1$Dpol]$sugarPol]
           terminateWithBasis := true

         -- if "nP" ^= 0, then  we continue, otherwise we determine next "nP"
         nP ^= 0$Dpol =>
           -- now we divide "nP", if possible, by the polynomials
           -- from "nonZeroRestrictions"
           for q in nonZeroRestrictions repeat
             stopDividing := false
             until stopDividing repeat
               nPq := nP exquo q
               stopDividing := (nPq case "failed")
               if not stopDividing then nP := autoCoerce nPq
               stopDividing := stopDividing or zero? degree nP

           zero? degree nP =>
             basis := [[0,1$Dpol]$sugarPol]
             terminateWithBasis := true  -- doSplitting? is still false

           -- a careful analysis has to be done, when and whether the
           -- following reduction and case nP=1 is necessary

           nP := hMonic redPol(nP,redPols)
           zero? degree nP =>
             basis := [[0,1$Dpol]$sugarPol]
             terminateWithBasis := true  -- doSplitting? is still false

           -- if "nP" ^= 0, then  we continue, otherwise we determine next "nP"
           nP ^= 0$Dpol =>
             -- now we factorize "nP", which is not constant
             irreducibleFactors : L Dpol := createAllFactors(nP)
             -- if there are more than 1 factors we reduce them and split
             (doSplitting? := not null rest irreducibleFactors) =>
               -- and reduce and normalize the factors
               for fnP in irreducibleFactors repeat
                 fnP := hMonic redPol(fnP,redPols)
                 -- no factor reduces to 0, as then "fP" would have been
                 -- reduced to zero,
                 -- but 1 may occur, which we will drop in a later version.
                 allReducedFactors := cons(fnP, allReducedFactors)
               -- end of "for fnP in irreducibleFactors repeat"

               -- we want that the smaller factors are dealt with first
               allReducedFactors := reverse allReducedFactors
             -- now the case of exactly 1 factor, but certainly not
             -- further reducible with respect to "redPols"
             nP := first irreducibleFactors
             -- put "nP" into "basis" and update "lcP" and "redPols":
             lcP : L critPair := updateCritPairs(lcP,newPairs(basis,nP),nP)
             basis := updateBasis(basis,nP,virtualDegree nP)
             redPols := concat(redPols,nP)
     -- end of "while not doSplitting? and not terminateWithBasis repeat"

     --    STEP 2  splitting step

     doSplitting? =>
       for fnP in allReducedFactors repeat
         if fnP ^= 1$Dpol
           then
             newInputPolys : L Dpol  := _
               sort( degree #1 > degree #2 ,cons(fnP,inputPolys))
             listOfBases := createGroebnerBases(basis, redPols, _
               nonZeroRestrictions,newInputPolys,lcP,listOfBases,info)
             -- update "nonZeroRestrictions"
             nonZeroRestrictions := cons(fnP,nonZeroRestrictions)
           else
             if info then
               messagePrint("we terminated with [1]")$OUT
             listOfBases := cons([1$Dpol],listOfBases)

       -- we finished with all the branches on one level and hence
       -- finished this call of createGroebnerBasis. Therefore
       -- we terminate with the actual "listOfBasis" as
       -- everything is done in the recursions
       listOfBases
     -- end of "doSplitting? =>"

     --    STEP 3 termination step

     --  we found a groebner basis and put it into the list "listOfBases"
     --  (auto)reduce each basis element modulo the others
     newBasis := minGbasis(sort(degree #1 > degree #2,[p.pol for p in basis]))
     -- now check whether the normalized basis again has reducible
     -- polynomials, in this case continue splitting!
     if info then
       messagePrint("we found a groebner basis and check whether it ")$OUT
       messagePrint("contains reducible polynomials")$OUT
       print(newBasis::OUT)$OUT
       -- here we should create an output form which is reusable by the system
       -- print(convert(newBasis::OUT)$InputForm :: OUT)$OUT
     removeDuplicates append(factorGroebnerBasis(newBasis, info), listOfBases)

   createAllFactors(p: Dpol) ==
     loF : L Dpol := [el.fctr for el in factorList factor(p)$MF]
     sort(degree #1 < degree #2, loF)
   newPairs(lp : L sugarPol,p : Dpol) ==
     totdegreeOfp : NNI := virtualDegree p
     -- next list lcP contains all critPair constructed from
     -- p and and the polynomials q in lp
     lcP: L critPair := _
       --[[sup(degree q, degreeOfp), q, p]$critPair for q in lp]
       [makeCrit(q, p, totdegreeOfp) for q in lp]
     -- application of the criteria to reduce the list lcP
     critMTonD1 sort(critpOrder,lcP)
   updateCritPairs(oldListOfcritPairs, newListOfcritPairs, p)==
     updatD (newListOfcritPairs, critBonD(p,oldListOfcritPairs))
   updateBasis(lp, p, deg) == updatF(p,deg,lp)

   -- exported functions

   factorGroebnerBasis basis == factorGroebnerBasis(basis, false)

   factorGroebnerBasis (basis, info) ==
     foundAReducible : Boolean := false
     for p in basis while not foundAReducible repeat
       -- we use fact that polynomials have content 1
       foundAReducible := 1 < #[el.fctr for el in factorList factor(p)$MF]
     not foundAReducible =>
       if info then  messagePrint("factorGroebnerBasis: no reducible polynomials in this basis")$OUT
       [basis]
     -- improve! Use the fact that the irreducible ones already
     -- build part of the basis, use the done factorizations, etc.
     if info then  messagePrint("factorGroebnerBasis:_
        we found reducible polynomials and continue splitting")$OUT
     createGroebnerBases([],[],[],basis,[],[],info)

   groebnerFactorize(basis, nonZeroRestrictions) ==
     groebnerFactorize(basis, nonZeroRestrictions, false)

   groebnerFactorize(basis, nonZeroRestrictions, info) ==
     basis = [] => [basis]
     basis := remove(#1 = 0$Dpol,basis)
     basis = [] => [[0$Dpol]]
     -- normalize all input polynomial
     basis := [hMonic p for p in basis]
     member?(1$Dpol,basis) => [[1$Dpol]]
     basis :=  sort(degree #1 > degree #2, basis)
     createGroebnerBases([],[],nonZeroRestrictions,basis,[],[],info)

   groebnerFactorize(basis) == groebnerFactorize(basis, [], false)
   groebnerFactorize(basis,info) == groebnerFactorize(basis, [], info)

@
<<GBF.dotabb>>=
"GBF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GBF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GBF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GBINTERN GroebnerInternalPackage}
\pagehead{GroebnerInternalPackage}{GBINTERN}
\pagepic{ps/v104groebnerinternalpackage.ps}{GBINTERN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GBINTERN GroebnerInternalPackage>>=
)abbrev package GBINTERN GroebnerInternalPackage
++ Author: 
++ Date Created: 
++ Date Last Updated: 
++ Keywords: 
++ Description
++ This package provides low level tools for Groebner basis computations
GroebnerInternalPackage(Dom, Expon, VarSet, Dpol): T == C where
 Dom:   GcdDomain
 Expon: OrderedAbelianMonoidSup
 VarSet: OrderedSet
 Dpol:  PolynomialCategory(Dom, Expon, VarSet)
 NNI    ==> NonNegativeInteger
   ------  Definition of Record critPair and Prinp

 critPair ==> Record( lcmfij: Expon, totdeg: NonNegativeInteger,
                      poli: Dpol, polj: Dpol )
 sugarPol ==> Record( totdeg: NonNegativeInteger, pol : Dpol)
 Prinp    ==> Record( ci:Dpol,tci:Integer,cj:Dpol,tcj:Integer,c:Dpol,
                tc:Integer,rc:Dpol,trc:Integer,tF:Integer,tD:Integer)
 Prinpp   ==> Record( ci:Dpol,tci:Integer,cj:Dpol,tcj:Integer,c:Dpol,
                tc:Integer,rc:Dpol,trc:Integer,tF:Integer,tDD:Integer,
                 tDF:Integer)
 T== with

     credPol:  (Dpol, List(Dpol))  -> Dpol
	++ credPol \undocumented
     redPol:   (Dpol, List(Dpol))  -> Dpol
	++ redPol \undocumented
     gbasis:  (List(Dpol), Integer, Integer) -> List(Dpol)
	++ gbasis \undocumented
     critT:  critPair   -> Boolean
	++ critT \undocumented
     critM:  (Expon, Expon) -> Boolean
	++ critM \undocumented
     critB:  (Expon, Expon, Expon, Expon) -> Boolean
	++ critB \undocumented
     critBonD:  (Dpol, List(critPair)) -> List(critPair)
	++ critBonD \undocumented
     critMTonD1: (List(critPair)) -> List(critPair)
	++ critMTonD1 \undocumented
     critMonD1:  (Expon, List(critPair)) -> List(critPair)
	++ critMonD1 \undocumented
     redPo: (Dpol, List(Dpol) )  ->  Record(poly:Dpol, mult:Dom)
	++ redPo \undocumented
     hMonic:  Dpol  -> Dpol
	++ hMonic \undocumented
     updatF: (Dpol, NNI, List(sugarPol) ) -> List(sugarPol)
	++ updatF \undocumented
     sPol:  critPair  -> Dpol
	++ sPol \undocumented
     updatD: (List(critPair), List(critPair)) -> List(critPair)
	++ updatD \undocumented
     minGbasis: List(Dpol) -> List(Dpol)
	++ minGbasis \undocumented
     lepol: Dpol -> Integer
	++ lepol \undocumented
     prinshINFO : Dpol -> Void
	++ prinshINFO \undocumented
     prindINFO: (critPair, Dpol, Dpol,Integer,Integer,Integer) -> Integer
	++ prindINFO \undocumented
     fprindINFO: (critPair, Dpol, Dpol, Integer,Integer,Integer
                 ,Integer) ->  Integer
	++ fprindINFO \undocumented
     prinpolINFO: List(Dpol) -> Void
	++ prinpolINFO \undocumented
     prinb: Integer-> Void
	++ prinb \undocumented
     critpOrder: (critPair, critPair) -> Boolean
	++ critpOrder \undocumented
     makeCrit: (sugarPol, Dpol, NonNegativeInteger) -> critPair
	++ makeCrit \undocumented
     virtualDegree : Dpol -> NonNegativeInteger
	++ virtualDegree \undocumented

 C== add
   Ex ==> OutputForm
   import OutputForm

   ------  Definition of intermediate functions
   if Dpol has totalDegree: Dpol -> NonNegativeInteger then
     virtualDegree p == totalDegree p
   else
     virtualDegree p == 0

   ------  ordering of critpairs

   critpOrder(cp1,cp2) ==
     cp1.totdeg < cp2.totdeg => true
     cp2.totdeg < cp1.totdeg => false
     cp1.lcmfij < cp2.lcmfij

   ------    creating a critical pair

   makeCrit(sp1, p2, totdeg2) ==
     p1 := sp1.pol
     deg := sup(degree(p1), degree(p2))
     e1 := subtractIfCan(deg, degree(p1))::Expon
     e2 := subtractIfCan(deg, degree(p2))::Expon
     tdeg := max(sp1.totdeg + virtualDegree(monomial(1,e1)),
                 totdeg2 + virtualDegree(monomial(1,e2)))
     [deg, tdeg, p1, p2]$critPair

   ------    calculate basis

   gbasis(Pol: List(Dpol), xx1: Integer, xx2: Integer ) ==
     D, D1: List(critPair)
     ---------   create D and Pol

     Pol1:= sort(degree #1 > degree #2, Pol)
     basPols:= updatF(hMonic(first Pol1),virtualDegree(first Pol1),[])
     Pol1:= rest(Pol1)
     D:= nil
     while _^ null Pol1 repeat
        h:= hMonic(first(Pol1))
        Pol1:= rest(Pol1)
        toth := virtualDegree h
        D1:= [makeCrit(x,h,toth) for x in basPols]
        D:= updatD(critMTonD1(sort(critpOrder, D1)),
                   critBonD(h,D))
        basPols:= updatF(h,toth,basPols)
     D:= sort(critpOrder, D)
     xx:= xx2
     --------  loop

     redPols := [x.pol for x in basPols]
     while _^ null D repeat
         D0:= first D
         s:= hMonic(sPol(D0))
         D:= rest(D)
         h:= hMonic(redPol(s,redPols))
         if xx1 = 1  then
              prinshINFO(h)
         h = 0  =>
          if xx2 = 1 then
           prindINFO(D0,s,h,# basPols, # D,xx)
           xx:= 2
          " go to top of while "
         degree(h) = 0 =>
           D:= nil
           if xx2 = 1 then
            prindINFO(D0,s,h,# basPols, # D,xx)
            xx:= 2
           basPols:= updatF(h,0,[])
           leave "out of while"
         D1:= [makeCrit(x,h,D0.totdeg) for x in basPols]
         D:= updatD(critMTonD1(sort(critpOrder, D1)),
                   critBonD(h,D))
         basPols:= updatF(h,D0.totdeg,basPols)
         redPols := concat(redPols,h)
         if xx2 = 1 then
            prindINFO(D0,s,h,# basPols, # D,xx)
            xx:= 2
     Pol := [x.pol for x in basPols]
     if xx2 = 1 then
       prinpolINFO(Pol)
       messagePrint("    THE GROEBNER BASIS POLYNOMIALS")
     if xx1 = 1 and xx2 ^= 1 then
       messagePrint("    THE GROEBNER BASIS POLYNOMIALS")
     Pol

             --------------------------------------

             --- erase multiple of e in D2 using crit M

   critMonD1(e: Expon, D2: List(critPair))==
      null D2 => nil
      x:= first(D2)
      critM(e, x.lcmfij) => critMonD1(e, rest(D2))
      cons(x, critMonD1(e, rest(D2)))

             ----------------------------

             --- reduce D1 using crit T and crit M

   critMTonD1(D1: List(critPair))==
           null D1 => nil
           f1:= first(D1)
           s1:= #(D1)
           cT1:= critT(f1)
           s1= 1 and cT1 => nil
           s1= 1 => D1
           e1:= f1.lcmfij
           r1:= rest(D1)
           e1 = (first r1).lcmfij  =>
              cT1 =>   critMTonD1(cons(f1, rest(r1)))
              critMTonD1(r1)
           D1 := critMonD1(e1, r1)
           cT1 => critMTonD1(D1)
           cons(f1, critMTonD1(D1))

             -----------------------------

             --- erase elements in D fullfilling crit B

   critBonD(h:Dpol, D: List(critPair))==
         null D => nil
         x:= first(D)
         critB(degree(h), x.lcmfij, degree(x.poli), degree(x.polj)) =>
           critBonD(h, rest(D))
         cons(x, critBonD(h, rest(D)))

             -----------------------------

             --- concat F and h and erase multiples of h in F

   updatF(h: Dpol, deg:NNI, F: List(sugarPol)) ==
       null F => [[deg,h]]
       f1:= first(F)
       critM(degree(h), degree(f1.pol))  => updatF(h, deg, rest(F))
       cons(f1, updatF(h, deg, rest(F)))

             -----------------------------

             --- concat ordered critical pair lists D1 and D2

   updatD(D1: List(critPair), D2: List(critPair)) ==
      null D1 => D2
      null D2 => D1
      dl1:= first(D1)
      dl2:= first(D2)
      critpOrder(dl1,dl2) => cons(dl1, updatD(D1.rest, D2))
      cons(dl2, updatD(D1, D2.rest))

            -----------------------------

            --- remove gcd from pair of coefficients

   gcdCo(c1:Dom, c2:Dom):Record(co1:Dom,co2:Dom) ==
      d:=gcd(c1,c2)
      [(c1 exquo d)::Dom, (c2 exquo d)::Dom]

            --- calculate S-polynomial of a critical pair

   sPol(p:critPair)==
      Tij := p.lcmfij
      fi := p.poli
      fj := p.polj
      cc := gcdCo(leadingCoefficient fi, leadingCoefficient fj)
      reductum(fi)*monomial(cc.co2,subtractIfCan(Tij, degree fi)::Expon) -
        reductum(fj)*monomial(cc.co1,subtractIfCan(Tij, degree fj)::Expon)

            ----------------------------

            --- reduce critpair polynomial mod F
            --- iterative version

   redPo(s: Dpol, F: List(Dpol)) ==
      m:Dom := 1
      Fh := F
      while _^ ( s = 0 or null F ) repeat
        f1:= first(F)
        s1:= degree(s)
        e: Union(Expon, "failed")
        (e:= subtractIfCan(s1, degree(f1))) case Expon  =>
           cc:=gcdCo(leadingCoefficient f1, leadingCoefficient s)
           s:=cc.co1*reductum(s) - monomial(cc.co2,e)*reductum(f1)
           m := m*cc.co1
           F:= Fh
        F:= rest F
      [s,m]

   redPol(s: Dpol, F: List(Dpol)) ==  credPol(redPo(s,F).poly,F)

            ----------------------------

            --- crit T  true, if e1 and e2 are disjoint

   critT(p: critPair) == p.lcmfij =  (degree(p.poli) + degree(p.polj))

            ----------------------------

            --- crit M - true, if lcm#2 multiple of lcm#1

   critM(e1: Expon, e2: Expon) ==
         en: Union(Expon, "failed")
         (en:=subtractIfCan(e2, e1)) case Expon

            ----------------------------

            --- crit B - true, if eik is a multiple of eh and eik ^equal
            ---          lcm(eh,ei) and eik ^equal lcm(eh,ek)

   critB(eh:Expon, eik:Expon, ei:Expon, ek:Expon) ==
       critM(eh, eik) and (eik ^= sup(eh, ei)) and (eik ^= sup(eh, ek))

            ----------------------------

            ---  make polynomial monic case Domain a Field

   hMonic(p: Dpol) ==
        p= 0 => p
        -- inv(leadingCoefficient(p))*p
        primitivePart p

            -----------------------------

            ---  reduce all terms of h mod F  (iterative version )

   credPol(h: Dpol, F: List(Dpol) ) ==
        null F => h
        h0:Dpol:= monomial(leadingCoefficient h, degree h)
        while (h:=reductum h) ^= 0 repeat
           hred:= redPo(h, F)
           h := hred.poly
           h0:=(hred.mult)*h0 + monomial(leadingCoefficient(h),degree h)
        h0

            -------------------------------

            ----  calculate minimal basis for ordered F

   minGbasis(F: List(Dpol)) ==
        null F => nil
        newbas := minGbasis rest F
        cons(hMonic credPol( first(F), newbas),newbas)

            -------------------------------

            ----  calculate number of terms of polynomial

   lepol(p1:Dpol)==
      n: Integer
      n:= 0
      while p1 ^= 0 repeat
         n:= n + 1
         p1:= reductum(p1)
      n

            ----  print blanc lines

   prinb(n: Integer)==
      for x in 1..n repeat
         messagePrint("    ")

            ----  print reduced critpair polynom

   prinshINFO(h: Dpol)==
           prinb(2)
           messagePrint(" reduced Critpair - Polynom :")
           prinb(2)
           print(h::Ex)
           prinb(2)

            -------------------------------

            ----  print info string

   prindINFO(cp: critPair, ps: Dpol, ph: Dpol, i1:Integer,
             i2:Integer, n:Integer) ==
       ll: List Prinp
       a: Dom
       cpi:= cp.poli
       cpj:= cp.polj
       if n = 1 then
        prinb(1)
        messagePrint("you choose option  -info-  ")
        messagePrint("abbrev. for the following information strings are")
        messagePrint("  ci  =>  Leading monomial  for critpair calculation")
        messagePrint("  tci =>  Number of terms of polynomial i")
        messagePrint("  cj  =>  Leading monomial  for critpair calculation")
        messagePrint("  tcj =>  Number of terms of polynomial j")
        messagePrint("  c   =>  Leading monomial of critpair polynomial")
        messagePrint("  tc  =>  Number of terms of critpair polynomial")
        messagePrint("  rc  =>  Leading monomial of redcritpair polynomial")
        messagePrint("  trc =>  Number of terms of redcritpair polynomial")
        messagePrint("  tF  =>  Number of polynomials in reduction list F")
        messagePrint("  tD  =>  Number of critpairs still to do")
        prinb(4)
        n:= 2
       prinb(1)
       a:= 1
       ph = 0  =>
          ps = 0 =>
            ll:= [[monomial(a,degree(cpi)),lepol(cpi),
                  monomial(a,degree(cpj)),
                   lepol(cpj),ps,0,ph,0,i1,i2]$Prinp]
            print(ll::Ex)
            prinb(1)
            n
          ll:= [[monomial(a,degree(cpi)),lepol(cpi),
             monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
              lepol(ps), ph,0,i1,i2]$Prinp]
          print(ll::Ex)
          prinb(1)
          n
       ll:= [[monomial(a,degree(cpi)),lepol(cpi),
            monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
             lepol(ps),monomial(a,degree(ph)),lepol(ph),i1,i2]$Prinp]
       print(ll::Ex)
       prinb(1)
       n

            -------------------------------

            ----  print the groebner basis polynomials

   prinpolINFO(pl: List(Dpol))==
       n:Integer
       n:= # pl
       prinb(1)
       n = 1 =>
         messagePrint("  There is 1  Groebner Basis Polynomial ")
         prinb(2)
       messagePrint("  There are ")
       prinb(1)
       print(n::Ex)
       prinb(1)
       messagePrint("  Groebner Basis Polynomials. ")
       prinb(2)

   fprindINFO(cp: critPair, ps: Dpol, ph: Dpol, i1:Integer,
             i2:Integer, i3:Integer, n: Integer) ==
       ll: List Prinpp
       a: Dom
       cpi:= cp.poli
       cpj:= cp.polj
       if n = 1 then
        prinb(1)
        messagePrint("you choose option  -info-  ")
        messagePrint("abbrev. for the following information strings are")
        messagePrint("  ci  =>  Leading monomial  for critpair calculation")
        messagePrint("  tci =>  Number of terms of polynomial i")
        messagePrint("  cj  =>  Leading monomial  for critpair calculation")
        messagePrint("  tcj =>  Number of terms of polynomial j")
        messagePrint("  c   =>  Leading monomial of critpair polynomial")
        messagePrint("  tc  =>  Number of terms of critpair polynomial")
        messagePrint("  rc  =>  Leading monomial of redcritpair polynomial")
        messagePrint("  trc =>  Number of terms of redcritpair polynomial")
        messagePrint("  tF  =>  Number of polynomials in reduction list F")
        messagePrint("  tD  =>  Number of critpairs still to do")
        messagePrint("  tDF =>  Number of subproblems still to do")
        prinb(4)
        n:= 2
       prinb(1)
       a:= 1
       ph = 0  =>
          ps = 0 =>
            ll:= [[monomial(a,degree(cpi)),lepol(cpi),
              monomial(a,degree(cpj)),
               lepol(cpj),ps,0,ph,0,i1,i2,i3]$Prinpp]
            print(ll::Ex)
            prinb(1)
            n
          ll:= [[monomial(a,degree(cpi)),lepol(cpi),
            monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
             lepol(ps), ph,0,i1,i2,i3]$Prinpp]
          print(ll::Ex)
          prinb(1)
          n
       ll:= [[monomial(a,degree(cpi)),lepol(cpi),
            monomial(a,degree(cpj)),lepol(cpj),monomial(a,degree(ps)),
             lepol(ps),monomial(a,degree(ph)),lepol(ph),i1,i2,i3]$Prinpp]
       print(ll::Ex)
       prinb(1)
       n

@
<<GBINTERN.dotabb>>=
"GBINTERN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GBINTERN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GBINTERN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GB GroebnerPackage}
<<GroebnerPackage.input>>=
)sys rm GroebnerPackage.output
)spool GroebnerPackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 24
s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
--R
--R   (1)  45p + 35s - 165b - 36
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 1

--S 2 of 24
s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
--R
--R   (2)  35p + 40z + 25t - 27s
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 2

--S 3 of 24
s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
--R
--R                                      2
--R   (3)  15w + 25p s + 30z - 18t - 165b
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 3

--S 4 of 24
s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
--R
--R   (4)  - 9w + 15p t + 20z s
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 4

--S 5 of 24
s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
--R
--R                        3
--R   (5)  w p + 2z t - 11b
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 5

--S 6 of 24
s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
--R
--R                        2
--R   (6)  99w - 11s b + 3b
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 6

--S 7 of 24
s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
--R
--R         2   33      2673
--R   (7)  b  + -- b + -----
--R             50     10000
--R      Type: DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 7

--S 8 of 24
sn7:=[s1,s2,s3,s4,s5,s6,s7]
--R
--R   (8)
--R   [45p + 35s - 165b - 36, 35p + 40z + 25t - 27s,
--R                                  2                                        3
--R    15w + 25p s + 30z - 18t - 165b , - 9w + 15p t + 20z s, w p + 2z t - 11b ,
--R                    2   2   33      2673
--R    99w - 11s b + 3b , b  + -- b + -----]
--R                            50     10000
--R Type: List DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 8

--S 9 of 24
groebner(sn7)
--R
--R   (9)
--R         19      1323      31     153      49     1143      37      27
--R   [w + --- b + -----, p - -- b - ---, z + -- b + ----, t - -- b + ---,
--R        120     20000      18     200      36     2000      15     250
--R        5      9    2   33      2673
--R    s - - b - ---, b  + -- b + -----]
--R        2     200       50     10000
--R Type: List DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 9

--S 10 of 24
groebner(sn7,"redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5     61     77      7
--R   z + - t - -- s + -- b + --
--R       8     45     24     10
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         66        603     278  2   11       672     2277     415881
--R   t s - -- t b + ---- t - --- s  + -- s b - --- s - ---- b - ------
--R         29       1450     435      29       725     7250     725000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       100  2   160       104      37      79
--R   t + --- s  - --- s b - --- s - --- b - ---
--R       189       63        63     105     125
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R    3   1026  2    5424  2   2529       1326807     12717      660717
--R   s  - ---- s b - ---- s  - ---- s b - ------- s + ----- b + -------
--R         145       3625       725        362500      6250     3625000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2     91248294  2   6550614        7087292937     20020838931
--R     s b + --------- s  - ------- s b + ----------- s - ----------- b
--R           128176525      5127061       12817652500     12817652500
--R   + 
--R       37595502243
--R     - -----------
--R       51270610000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2   4746183626079988       1015195815329760     30723564870033201
--R     s  - ---------------- s b - ---------------- s - ----------------- b
--R           987357073521193        987357073521193     24683926838029825
--R   + 
--R       3696123458901625353
--R     - -------------------
--R       2468392683802982500
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R           16827373608076633182513471     1262793163581645698534964
--R     s b + -------------------------- s - ------------------------- b
--R           23063714246644859914108300     5765928561661214978527075
--R   + 
--R      91594345205981119652436033
--R     ---------------------------
--R     144148214041530374463176875
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5      9
--R   s - - b - ---
--R       2     200
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (10)
--R         19      1323      31     153      49     1143      37      27
--R   [w + --- b + -----, p - -- b - ---, z + -- b + ----, t - -- b + ---,
--R        120     20000      18     200      36     2000      15     250
--R        5      9    2   33      2673
--R    s - - b - ---, b  + -- b + -----]
--R        2     200       50     10000
--R Type: List DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 10

--S 11 of 24
groebner(sn7,"info")
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R   [[ci= p,tci= 4,cj= p,tcj= 4,c= z,tc= 5,rc= z,trc= 5,tF= 4,tD= 3]]
--R
--R
--R   [[ci= w,tci= 3,cj= w,tcj= 5,c= p t,tc= 6,rc= t s,trc= 8,tF= 5,tD= 2]]
--R
--R
--R   [[ci= w,tci= 3,cj= w,tcj= 3,c= p t,tc= 4,rc= t,trc= 6,tF= 5,tD= 2]]
--R
--R
--R                                                   3
--R   [[ci= t s,tci= 8,cj= t,tcj= 6,c= t b,tc= 9,rc= s ,trc= 7,tF= 6,tD= 1]]
--R
--R
--R                                                     2
--R   [[ci= w p,tci= 3,cj= w,tcj= 3,c= p s b,tc= 4,rc= s b,trc= 6,tF= 7,tD= 2]]
--R
--R
--R          2             2             2             2
--R   [[ci= b ,tci= 3,cj= s b,tcj= 6,c= s b,tc= 6,rc= s ,trc= 5,tF= 6,tD= 2]]
--R
--R
--R          2              2            2
--R   [[ci= s b,tci= 6,cj= s ,tcj= 5,c= s ,tc= 7,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R          3             2            2
--R   [[ci= s ,tci= 7,cj= s ,tcj= 5,c= s b,tc= 6,rc= s b,trc= 4,tF= 7,tD= 2]]
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= s b,tcj= 4,c= s b,tc= 4,rc= s,trc= 3,tF= 6,tD= 2]]
--R
--R
--R   [[ci= s b,tci= 4,cj= s,tcj= 3,c= s,tc= 4,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R          2
--R   [[ci= s ,tci= 5,cj= s,tcj= 3,c= s b,tc= 4,rc= 0,trc= 0,tF= 6,tD= 0]]
--R
--R
--R     There are
--R
--R   6
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (11)
--R         19      1323      31     153      49     1143      37      27
--R   [w + --- b + -----, p - -- b - ---, z + -- b + ----, t - -- b + ---,
--R        120     20000      18     200      36     2000      15     250
--R        5      9    2   33      2673
--R    s - - b - ---, b  + -- b + -----]
--R        2     200       50     10000
--R Type: List DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 11

--S 12 of 24
groebner(sn7,"redcrit","info")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5     61     77      7
--R   z + - t - -- s + -- b + --
--R       8     45     24     10
--R
--R
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R   [[ci= p,tci= 4,cj= p,tcj= 4,c= z,tc= 5,rc= z,trc= 5,tF= 4,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         66        603     278  2   11       672     2277     415881
--R   t s - -- t b + ---- t - --- s  + -- s b - --- s - ---- b - ------
--R         29       1450     435      29       725     7250     725000
--R
--R
--R
--R   [[ci= w,tci= 3,cj= w,tcj= 5,c= p t,tc= 6,rc= t s,trc= 8,tF= 5,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       100  2   160       104      37      79
--R   t + --- s  - --- s b - --- s - --- b - ---
--R       189       63        63     105     125
--R
--R
--R
--R   [[ci= w,tci= 3,cj= w,tcj= 3,c= p t,tc= 4,rc= t,trc= 6,tF= 5,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R    3   1026  2    5424  2   2529       1326807     12717      660717
--R   s  - ---- s b - ---- s  - ---- s b - ------- s + ----- b + -------
--R         145       3625       725        362500      6250     3625000
--R
--R
--R
--R                                                   3
--R   [[ci= t s,tci= 8,cj= t,tcj= 6,c= t b,tc= 9,rc= s ,trc= 7,tF= 6,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2     91248294  2   6550614        7087292937     20020838931
--R     s b + --------- s  - ------- s b + ----------- s - ----------- b
--R           128176525      5127061       12817652500     12817652500
--R   + 
--R       37595502243
--R     - -----------
--R       51270610000
--R
--R
--R
--R                                                     2
--R   [[ci= w p,tci= 3,cj= w,tcj= 3,c= p s b,tc= 4,rc= s b,trc= 6,tF= 7,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2   4746183626079988       1015195815329760     30723564870033201
--R     s  - ---------------- s b - ---------------- s - ----------------- b
--R           987357073521193        987357073521193     24683926838029825
--R   + 
--R       3696123458901625353
--R     - -------------------
--R       2468392683802982500
--R
--R
--R
--R          2             2             2             2
--R   [[ci= b ,tci= 3,cj= s b,tcj= 6,c= s b,tc= 6,rc= s ,trc= 5,tF= 6,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2              2            2
--R   [[ci= s b,tci= 6,cj= s ,tcj= 5,c= s ,tc= 7,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R           16827373608076633182513471     1262793163581645698534964
--R     s b + -------------------------- s - ------------------------- b
--R           23063714246644859914108300     5765928561661214978527075
--R   + 
--R      91594345205981119652436033
--R     ---------------------------
--R     144148214041530374463176875
--R
--R
--R
--R          3             2            2
--R   [[ci= s ,tci= 7,cj= s ,tcj= 5,c= s b,tc= 6,rc= s b,trc= 4,tF= 7,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5      9
--R   s - - b - ---
--R       2     200
--R
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= s b,tcj= 4,c= s b,tc= 4,rc= s,trc= 3,tF= 6,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= s b,tci= 4,cj= s,tcj= 3,c= s,tc= 4,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2
--R   [[ci= s ,tci= 5,cj= s,tcj= 3,c= s b,tc= 4,rc= 0,trc= 0,tF= 6,tD= 0]]
--R
--R
--R     There are
--R
--R   6
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (12)
--R         19      1323      31     153      49     1143      37      27
--R   [w + --- b + -----, p - -- b - ---, z + -- b + ----, t - -- b + ---,
--R        120     20000      18     200      36     2000      15     250
--R        5      9    2   33      2673
--R    s - - b - ---, b  + -- b + -----]
--R        2     200       50     10000
--R Type: List DistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 12

--S 13 of 24
hs1:HDMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
--R
--R   (13)  45p + 35s - 165b - 36
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 13

--S 14 of 24
hs2:HDMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
--R
--R   (14)  35p + 40z + 25t - 27s
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 14

--S 15 of 24
hs3:HDMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
--R                     2
--R   (15)  25p s - 165b  + 15w + 30z - 18t
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 15

--S 16 of 24
hs4:HDMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
--R
--R   (16)  15p t + 20z s - 9w
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 16

--S 17 of 24
hs5:HDMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
--R
--R              3
--R   (17)  - 11b  + w p + 2z t
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 17

--S 18 of 24
hs6:HDMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
--R
--R                     2
--R   (18)  - 11s b + 3b  + 99w
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 18

--S 19 of 24
hs7:HDMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
--R
--R          2   33      2673
--R   (19)  b  + -- b + -----
--R              50     10000
--RType: HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 19

--S 20 of 24
hsn7:=[hs1,hs2,hs3,hs4,hs5,hs6,hs7]
--R
--R   (20)
--R   [45p + 35s - 165b - 36, 35p + 40z + 25t - 27s,
--R                2                                             3
--R    25p s - 165b  + 15w + 30z - 18t, 15p t + 20z s - 9w, - 11b  + w p + 2z t,
--R                2         2   33      2673
--R    - 11s b + 3b  + 99w, b  + -- b + -----]
--R                              50     10000
--RType: List HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 20

--S 21 of 24
groebner(hsn7)
--R
--R   (21)
--R     2   33      2673       19      1323      31     153      49     1143
--R   [b  + -- b + -----, w + --- b + -----, p - -- b - ---, z + -- b + ----,
--R         50     10000      120     20000      18     200      36     2000
--R        37      27      5      9
--R    t - -- b + ---, s - - b - ---]
--R        15     250      2     200
--RType: List HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 21

--S 22 of 24
groebner(hsn7,"redcrit")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5     61     77      7
--R   z + - t - -- s + -- b + --
--R       8     45     24     10
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R    2   216     189     78      99     10557
--R   s  - --- w + --- t - -- s + --- b - -----
--R         5      100     25     500     12500
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         66       17541     5886     10588      9273     8272413
--R   t s - -- t b - ----- w + ---- t - ----- s - ----- b - -------
--R         29        725      3625      3625     36250     7250000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2   28       44       143       962712     420652     5166944
--R     t  + -- w s - -- w b + --- t b - ------ w + ------ t - ------- s
--R          45       15       725        18125      90625      815625
--R   + 
--R     5036339     83580953
--R     ------- b - --------
--R     5437500     90625000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         33      297        81
--R   w b + -- w + ----- s - ----- b
--R         50     10000     10000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          21        33      6723      2031      104247
--R   w s + --- t b - --- w + ----- s - ----- b + -------
--R         100       250     50000     25000     5000000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2373       41563      17253      578853      258751      11330361
--R   w t + ---- t b - ----- w + ------ t + ------- s - ------- b + ---------
--R         7250       36250     290000     7250000     3625000     362500000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         51061712      91248294     1516761889      481096937      5789482077
--R   t b - -------- w + --------- t - ---------- s + ---------- b + -----------
--R          5127061     128176525     1922647875     1281765250     51270610000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2962071220563579     1229379913128787     4524811449715289
--R     w + ---------------- t - ---------------- s + ---------------- b
--R          98138188260880       36801820597830       490690941304400
--R   + 
--R     59240140318722273
--R     -----------------
--R     12267273532610000
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       172832706542351932      47302810289036749      2736061156820726
--R   t - ------------------ s + ------------------ b + -----------------
--R       155991468675747195     155991468675747195     17332385408416355
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5      9
--R   s - - b - ---
--R       2     200
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (22)
--R     2   33      2673       19      1323      31     153      49     1143
--R   [b  + -- b + -----, w + --- b + -----, p - -- b - ---, z + -- b + ----,
--R         50     10000      120     20000      18     200      36     2000
--R        37      27      5      9
--R    t - -- b + ---, s - - b - ---]
--R        15     250      2     200
--RType: List HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 22

--S 23 of 24
groebner(hsn7,"info")
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R   [[ci= p,tci= 4,cj= p,tcj= 4,c= z,tc= 5,rc= z,trc= 5,tF= 4,tD= 5]]
--R
--R
--R                                                   2
--R   [[ci= p s,tci= 5,cj= p,tcj= 4,c= z s,tc= 7,rc= s ,trc= 6,tF= 5,tD= 5]]
--R
--R
--R   [[ci= p t,tci= 3,cj= p,tcj= 4,c= z t,tc= 5,rc= t s,trc= 7,tF= 6,tD= 6]]
--R
--R
--R          3             2                          2
--R   [[ci= b ,tci= 3,cj= b ,tcj= 3,c= w p,tc= 4,rc= t ,trc= 9,tF= 7,tD= 6]]
--R
--R
--R                         2            3
--R   [[ci= s b,tci= 3,cj= b ,tcj= 3,c= b ,tc= 4,rc= w b,trc= 4,tF= 8,tD= 7]]
--R
--R
--R                         2              2
--R   [[ci= s b,tci= 3,cj= s ,tcj= 6,c= s b ,tc= 7,rc= w s,trc= 6,tF= 9,tD= 9]]
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= t s,tcj= 7,c= t b ,tc= 7,rc= w t,trc= 7,tF= 10,tD= 11]]
--R
--R
--R                                         2
--R   [[ci= p s,tci= 5,cj= s b,tcj= 3,c= p b ,tc= 6,rc= 0,trc= 0,tF= 10,tD= 10]]
--R
--R
--R          2
--R   [[ci= s ,tci= 6,cj= t s,tcj= 7,c= t s b,tc= 10,rc= t b,trc= 6,tF= 11,tD= 13]]
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= t b,tcj= 6,c= w b,tc= 6,rc= w,trc= 5,tF= 9,tD= 14]]
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= w b,tcj= 4,c= s b,tc= 3,rc= 0,trc= 0,tF= 9,tD= 13]]
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= t b,tcj= 6,c= t b ,tc= 7,rc= t,trc= 4,tF= 7,tD= 11]]
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= w b,tcj= 4,c= w b ,tc= 5,rc= s,trc= 3,tF= 6,tD= 9]]
--R
--R
--R                                       2
--R   [[ci= w b,tci= 4,cj= t b,tcj= 6,c= w ,tc= 7,rc= 0,trc= 0,tF= 6,tD= 8]]
--R
--R
--R                                     2
--R   [[ci= s b,tci= 3,cj= s,tcj= 3,c= b ,tc= 3,rc= 0,trc= 0,tF= 6,tD= 7]]
--R
--R
--R   [[ci= t b,tci= 6,cj= t,tcj= 4,c= s b,tc= 7,rc= 0,trc= 0,tF= 6,tD= 6]]
--R
--R
--R   [[ci= w b,tci= 4,cj= w,tcj= 5,c= t b,tc= 6,rc= 0,trc= 0,tF= 6,tD= 5]]
--R
--R
--R          2
--R   [[ci= s ,tci= 6,cj= s,tcj= 3,c= s b,tc= 6,rc= 0,trc= 0,tF= 6,tD= 4]]
--R
--R
--R                                     2
--R   [[ci= t s,tci= 7,cj= t,tcj= 4,c= s ,tc= 8,rc= 0,trc= 0,tF= 6,tD= 3]]
--R
--R
--R   [[ci= w s,tci= 6,cj= w,tcj= 5,c= t s,tc= 8,rc= 0,trc= 0,tF= 6,tD= 2]]
--R
--R
--R          2
--R   [[ci= t ,tci= 9,cj= t,tcj= 4,c= w s,tc= 9,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R                                     2
--R   [[ci= w t,tci= 7,cj= w,tcj= 5,c= t ,tc= 8,rc= 0,trc= 0,tF= 6,tD= 0]]
--R
--R
--R     There are
--R
--R   6
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (23)
--R     2   33      2673       19      1323      31     153      49     1143
--R   [b  + -- b + -----, w + --- b + -----, p - -- b - ---, z + -- b + ----,
--R         50     10000      120     20000      18     200      36     2000
--R        37      27      5      9
--R    t - -- b + ---, s - - b - ---]
--R        15     250      2     200
--RType: List HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 23

--S 24 of 24
groebner(hsn7,"redcrit","info")
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5     61     77      7
--R   z + - t - -- s + -- b + --
--R       8     45     24     10
--R
--R
--R
--R   you choose option  -info-
--R   abbrev. for the following information strings are
--R     ci  =>  Leading monomial  for critpair calculation
--R     tci =>  Number of terms of polynomial i
--R     cj  =>  Leading monomial  for critpair calculation
--R     tcj =>  Number of terms of polynomial j
--R     c   =>  Leading monomial of critpair polynomial
--R     tc  =>  Number of terms of critpair polynomial
--R     rc  =>  Leading monomial of redcritpair polynomial
--R     trc =>  Number of terms of redcritpair polynomial
--R     tF  =>  Number of polynomials in reduction list F
--R     tD  =>  Number of critpairs still to do
--R
--R
--R
--R
--R
--R   [[ci= p,tci= 4,cj= p,tcj= 4,c= z,tc= 5,rc= z,trc= 5,tF= 4,tD= 5]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R    2   216     189     78      99     10557
--R   s  - --- w + --- t - -- s + --- b - -----
--R         5      100     25     500     12500
--R
--R
--R
--R                                                   2
--R   [[ci= p s,tci= 5,cj= p,tcj= 4,c= z s,tc= 7,rc= s ,trc= 6,tF= 5,tD= 5]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         66       17541     5886     10588      9273     8272413
--R   t s - -- t b - ----- w + ---- t - ----- s - ----- b - -------
--R         29        725      3625      3625     36250     7250000
--R
--R
--R
--R   [[ci= p t,tci= 3,cj= p,tcj= 4,c= z t,tc= 5,rc= t s,trc= 7,tF= 6,tD= 6]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R      2   28       44       143       962712     420652     5166944
--R     t  + -- w s - -- w b + --- t b - ------ w + ------ t - ------- s
--R          45       15       725        18125      90625      815625
--R   + 
--R     5036339     83580953
--R     ------- b - --------
--R     5437500     90625000
--R
--R
--R
--R          3             2                          2
--R   [[ci= b ,tci= 3,cj= b ,tcj= 3,c= w p,tc= 4,rc= t ,trc= 9,tF= 7,tD= 6]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         33      297        81
--R   w b + -- w + ----- s - ----- b
--R         50     10000     10000
--R
--R
--R
--R                         2            3
--R   [[ci= s b,tci= 3,cj= b ,tcj= 3,c= b ,tc= 4,rc= w b,trc= 4,tF= 8,tD= 7]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R          21        33      6723      2031      104247
--R   w s + --- t b - --- w + ----- s - ----- b + -------
--R         100       250     50000     25000     5000000
--R
--R
--R
--R                         2              2
--R   [[ci= s b,tci= 3,cj= s ,tcj= 6,c= s b ,tc= 7,rc= w s,trc= 6,tF= 9,tD= 9]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2373       41563      17253      578853      258751      11330361
--R   w t + ---- t b - ----- w + ------ t + ------- s - ------- b + ---------
--R         7250       36250     290000     7250000     3625000     362500000
--R
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= t s,tcj= 7,c= t b ,tc= 7,rc= w t,trc= 7,tF= 10,tD= 11]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                                         2
--R   [[ci= p s,tci= 5,cj= s b,tcj= 3,c= p b ,tc= 6,rc= 0,trc= 0,tF= 10,tD= 10]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         51061712      91248294     1516761889      481096937      5789482077
--R   t b - -------- w + --------- t - ---------- s + ---------- b + -----------
--R          5127061     128176525     1922647875     1281765250     51270610000
--R
--R
--R
--R          2
--R   [[ci= s ,tci= 6,cj= t s,tcj= 7,c= t s b,tc= 10,rc= t b,trc= 6,tF= 11,tD= 13]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R         2962071220563579     1229379913128787     4524811449715289
--R     w + ---------------- t - ---------------- s + ---------------- b
--R          98138188260880       36801820597830       490690941304400
--R   + 
--R     59240140318722273
--R     -----------------
--R     12267273532610000
--R
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= t b,tcj= 6,c= w b,tc= 6,rc= w,trc= 5,tF= 9,tD= 14]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2
--R   [[ci= b ,tci= 3,cj= w b,tcj= 4,c= s b,tc= 3,rc= 0,trc= 0,tF= 9,tD= 13]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       172832706542351932      47302810289036749      2736061156820726
--R   t - ------------------ s + ------------------ b + -----------------
--R       155991468675747195     155991468675747195     17332385408416355
--R
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= t b,tcj= 6,c= t b ,tc= 7,rc= t,trc= 4,tF= 7,tD= 11]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R       5      9
--R   s - - b - ---
--R       2     200
--R
--R
--R
--R                                         2
--R   [[ci= s b,tci= 3,cj= w b,tcj= 4,c= w b ,tc= 5,rc= s,trc= 3,tF= 6,tD= 9]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                                       2
--R   [[ci= w b,tci= 4,cj= t b,tcj= 6,c= w ,tc= 7,rc= 0,trc= 0,tF= 6,tD= 8]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                                     2
--R   [[ci= s b,tci= 3,cj= s,tcj= 3,c= b ,tc= 3,rc= 0,trc= 0,tF= 6,tD= 7]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= t b,tci= 6,cj= t,tcj= 4,c= s b,tc= 7,rc= 0,trc= 0,tF= 6,tD= 6]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= w b,tci= 4,cj= w,tcj= 5,c= t b,tc= 6,rc= 0,trc= 0,tF= 6,tD= 5]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2
--R   [[ci= s ,tci= 6,cj= s,tcj= 3,c= s b,tc= 6,rc= 0,trc= 0,tF= 6,tD= 4]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                                     2
--R   [[ci= t s,tci= 7,cj= t,tcj= 4,c= s ,tc= 8,rc= 0,trc= 0,tF= 6,tD= 3]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R   [[ci= w s,tci= 6,cj= w,tcj= 5,c= t s,tc= 8,rc= 0,trc= 0,tF= 6,tD= 2]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R          2
--R   [[ci= t ,tci= 9,cj= t,tcj= 4,c= w s,tc= 9,rc= 0,trc= 0,tF= 6,tD= 1]]
--R
--R
--R
--R    reduced Critpair - Polynom :
--R
--R
--R   0
--R
--R
--R
--R                                     2
--R   [[ci= w t,tci= 7,cj= w,tcj= 5,c= t ,tc= 8,rc= 0,trc= 0,tF= 6,tD= 0]]
--R
--R
--R     There are
--R
--R   6
--R
--R     Groebner Basis Polynomials.
--R
--R
--R       THE GROEBNER BASIS POLYNOMIALS
--R
--R   (24)
--R     2   33      2673       19      1323      31     153      49     1143
--R   [b  + -- b + -----, w + --- b + -----, p - -- b - ---, z + -- b + ----,
--R         50     10000      120     20000      18     200      36     2000
--R        37      27      5      9
--R    t - -- b + ---, s - - b - ---]
--R        15     250      2     200
--RType: List HomogeneousDistributedMultivariatePolynomial([w,p,z,t,s,b],Fraction Integer)
--E 24

)spool
)lisp (bye)
@
<<GroebnerPackage.help>>=
====================================================================
groebner examples
====================================================================

Example to call groebner:

  s1:DMP[w,p,z,t,s,b]RN:= 45*p + 35*s - 165*b - 36
  s2:DMP[w,p,z,t,s,b]RN:= 35*p + 40*z + 25*t - 27*s
  s3:DMP[w,p,z,t,s,b]RN:= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
  s4:DMP[w,p,z,t,s,b]RN:= -9*w + 15*p*t + 20*z*s
  s5:DMP[w,p,z,t,s,b]RN:= w*p + 2*z*t - 11*b**3
  s6:DMP[w,p,z,t,s,b]RN:= 99*w - 11*b*s + 3*b**2
  s7:DMP[w,p,z,t,s,b]RN:= b**2 + 33/50*b + 2673/10000

  sn7:=[s1,s2,s3,s4,s5,s6,s7]

  groebner(sn7,info)

groebner calculates a minimal Groebner Basis
all reductions are TOTAL reductions

To get the reduced critical pairs do:

  groebner(sn7,"redcrit")

You can get other information by calling:

  groebner(sn7,"info")

which returns:
      ci  =>  Leading monomial  for critpair calculation
      tci =>  Number of terms of polynomial i
      cj  =>  Leading monomial  for critpair calculation
      tcj =>  Number of terms of polynomial j
      c   =>  Leading monomial of critpair polynomial
      tc  =>  Number of terms of critpair polynomial
      rc  =>  Leading monomial of redcritpair polynomial
      trc =>  Number of terms of redcritpair polynomial
      tF  =>  Number of polynomials in reduction list F
      tD  =>  Number of critpairs still to do
 
See Also:
o )display operations groebner
o )show GroebnerPackage
o )show DistributedMultivariatePolynomial
o )show HomogeneousDistributedMultivariatePolynomial
o )show EuclideanGroebnerBasisPackage

@
\pagehead{GroebnerPackage}{GB}
\pagepic{ps/v104groebnerpackage.ps}{GB}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GB GroebnerPackage>>=
)abbrev package GB GroebnerPackage
++ Authors: Gebauer, Trager
++ Date Created: 12-1-86
++ Date Last Updated: 2-28-91
++ Basic Functions: groebner normalForm
++ Related Constructors: Ideal, IdealDecompositionPackage
++ Also See:
++ AMS Classifications:
++ Keywords: groebner basis, polynomial ideal
++ References:
++ Description: \spadtype{GroebnerPackage} computes groebner
++ bases for polynomial ideals. The basic computation provides
++ a distinguished set of generators for polynomial ideals over fields.
++ This basis allows an easy test for membership: the operation \spadfun{normalForm}
++ returns zero on ideal members. When the provided coefficient domain, Dom,
++ is not a field, the result is equivalent to considering the extended
++ ideal with \spadtype{Fraction(Dom)} as coefficients, but considerably more efficient
++ since all calculations are performed in Dom. Additional argument "info" and "redcrit"
++ can be given to provide incremental information during
++ computation. Argument "info" produces a computational summary for each s-polynomial.
++ Argument "redcrit" prints out the reduced critical pairs. The term ordering
++ is determined by the polynomial type used. Suggested types include
++ \spadtype{DistributedMultivariatePolynomial},
++ \spadtype{HomogeneousDistributedMultivariatePolynomial},
++ \spadtype{GeneralDistributedMultivariatePolynomial}.
 
GroebnerPackage(Dom, Expon, VarSet, Dpol): T == C where
 
 Dom:   GcdDomain
 Expon: OrderedAbelianMonoidSup
 VarSet: OrderedSet
 Dpol:  PolynomialCategory(Dom, Expon, VarSet)
 
 T== with
 
  groebner: List(Dpol) -> List(Dpol)
   ++ groebner(lp) computes a groebner basis for a polynomial ideal
   ++ generated by the list of polynomials lp.
   ++
   ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
   ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
   ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
   ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
   ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
   ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
   ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
   ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
   ++X groebner(sn7)

  groebner: ( List(Dpol), String ) -> List(Dpol)
   ++ groebner(lp, infoflag) computes a groebner basis 
   ++ for a polynomial ideal
   ++ generated by the list of polynomials lp.
   ++ Argument infoflag is used to get information on the computation.
   ++ If infoflag is "info", then summary information
   ++ is displayed for each s-polynomial generated.
   ++ If infoflag is "redcrit", the reduced critical pairs are displayed.
   ++ If infoflag is any other string, 
   ++ no information is printed during computation.
   ++
   ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
   ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
   ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
   ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
   ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
   ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
   ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
   ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
   ++X groebner(sn7,"info")
   ++X groebner(sn7,"redcrit")

  groebner: ( List(Dpol), String, String ) -> List(Dpol)
   ++ groebner(lp, "info", "redcrit") computes a groebner basis
   ++ for a polynomial ideal generated by the list of polynomials lp,
   ++ displaying both a summary of the critical pairs considered ("info")
   ++ and the result of reducing each critical pair ("redcrit").
   ++ If the second or third arguments have any other string value,
   ++ the indicated information is suppressed.
   ++
   ++X s1:DMP([w,p,z,t,s,b],FRAC(INT)):= 45*p + 35*s - 165*b - 36
   ++X s2:DMP([w,p,z,t,s,b],FRAC(INT)):= 35*p + 40*z + 25*t - 27*s
   ++X s3:DMP([w,p,z,t,s,b],FRAC(INT)):= 15*w + 25*p*s + 30*z - 18*t - 165*b**2
   ++X s4:DMP([w,p,z,t,s,b],FRAC(INT)):= -9*w + 15*p*t + 20*z*s
   ++X s5:DMP([w,p,z,t,s,b],FRAC(INT)):= w*p + 2*z*t - 11*b**3
   ++X s6:DMP([w,p,z,t,s,b],FRAC(INT)):= 99*w - 11*b*s + 3*b**2
   ++X s7:DMP([w,p,z,t,s,b],FRAC(INT)):= b**2 + 33/50*b + 2673/10000
   ++X sn7:=[s1,s2,s3,s4,s5,s6,s7]
   ++X groebner(sn7,"info","redcrit")
       
  if Dom has Field then
    normalForm: (Dpol, List(Dpol))  -> Dpol
      ++ normalForm(poly,gb) reduces the polynomial poly modulo the
      ++ precomputed groebner basis gb giving a canonical representative
      ++ of the residue class.
 C== add
   import OutputForm
   import GroebnerInternalPackage(Dom,Expon,VarSet,Dpol)
 
   if Dom has Field then
     monicize(p: Dpol):Dpol ==
--       one?(lc := leadingCoefficient p) => p
       ((lc := leadingCoefficient p) = 1) => p
       inv(lc)*p

     normalForm(p : Dpol, l : List(Dpol)) : Dpol ==
       redPol(p,map(monicize,l))
 
   ------    MAIN ALGORITHM GROEBNER ------------------------
 
   groebner( Pol: List(Dpol) ) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     minGbasis(sort( degree #1 > degree #2, gbasis(Pol,0,0)))
 
   groebner( Pol: List(Dpol), xx1: String) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     xx1 = "redcrit" =>
       minGbasis(sort( degree #1 > degree #2, gbasis(Pol,1,0)))
     xx1 = "info" =>
       minGbasis(sort( degree #1 > degree #2, gbasis(Pol,2,1)))
     messagePrint("   ")
     messagePrint("WARNING: options are - redcrit and/or info - ")
     messagePrint("         you didn't type them correct")
     messagePrint("         please try again")
     messagePrint("   ")
     []
 
   groebner( Pol: List(Dpol), xx1: String, xx2: String) ==
     Pol=[] => Pol
     Pol:=[x for x in Pol | x ^= 0]
     Pol=[] => [0]
     (xx1 = "redcrit" and xx2 = "info") or
      (xx1 = "info" and xx2 = "redcrit")   =>
       minGbasis(sort( degree #1 > degree #2, gbasis(Pol,1,1)))
     xx1 = "redcrit" and xx2 = "redcrit" =>
       minGbasis(sort( degree #1 > degree #2, gbasis(Pol,1,0)))
     xx1 = "info" and xx2 = "info" =>
       minGbasis(sort( degree #1 > degree #2, gbasis(Pol,2,1)))
     messagePrint("   ")
     messagePrint("WARNING:  options are - redcrit and/or info - ")
     messagePrint("          you didn't type them correctly")
     messagePrint("          please try again ")
     messagePrint("   ")
     []

@
<<GB.dotabb>>=
"GB" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GB"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"GB" -> "PFECAT"
"GB" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GROEBSOL GroebnerSolve}
\pagehead{GroebnerSolve}{GROEBSOL}
\pagepic{ps/v104groebnersolve.ps}{GROEBSOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GROEBSOL GroebnerSolve>>=
)abbrev package GROEBSOL GroebnerSolve
++ Author : P.Gianni, Summer '88, revised November '89
++ Solve systems of polynomial equations using Groebner bases
++ Total order Groebner bases are computed and then converted to lex ones
++ This package is mostly intended for internal use.
GroebnerSolve(lv,F,R) : C == T

  where
   R      :   GcdDomain
   F      :   GcdDomain
   lv     :   List Symbol

   NNI    ==>  NonNegativeInteger
   I      ==>  Integer
   S      ==>  Symbol

   OV     ==>  OrderedVariableList(lv)
   IES    ==>  IndexedExponents Symbol

   DP     ==>  DirectProduct(#lv,NonNegativeInteger)
   DPoly  ==>  DistributedMultivariatePolynomial(lv,F)

   HDP    ==>  HomogeneousDirectProduct(#lv,NonNegativeInteger)
   HDPoly ==>  HomogeneousDistributedMultivariatePolynomial(lv,F)

   SUP    ==>  SparseUnivariatePolynomial(DPoly)
   L      ==>  List
   P      ==>  Polynomial

   C == with
      groebSolve   : (L DPoly,L OV)  -> L L DPoly
        ++ groebSolve(lp,lv) reduces the polynomial system lp in variables lv
        ++ to triangular form. Algorithm based on groebner bases algorithm
        ++ with linear algebra for change of ordering.
        ++ Preprocessing for the general solver.
        ++ The polynomials in input are of type \spadtype{DMP}.

      testDim     : (L HDPoly,L OV)  -> Union(L HDPoly,"failed")
        ++ testDim(lp,lv) tests if the polynomial system lp
        ++ in variables lv is zero dimensional.

      genericPosition : (L DPoly, L OV) -> Record(dpolys:L DPoly, coords: L I)
        ++ genericPosition(lp,lv) puts a radical zero dimensional ideal
        ++ in general position, for system lp in variables lv.

   T == add
     import PolToPol(lv,F)
     import GroebnerPackage(F,DP,OV,DPoly)
     import GroebnerInternalPackage(F,DP,OV,DPoly)
     import GroebnerPackage(F,HDP,OV,HDPoly)
     import LinGroebnerPackage(lv,F)

     nv:NNI:=#lv

          ---- test if f is power of a linear mod (rad lpol) ----
                     ----  f is monic  ----
     testPower(uf:SUP,x:OV,lpol:L DPoly) : Union(DPoly,"failed") ==
       df:=degree(uf)
       trailp:DPoly := coefficient(uf,(df-1)::NNI)
       (testquo := trailp exquo (df::F)) case "failed" => "failed"
       trailp := testquo::DPoly
       gg:=gcd(lc:=leadingCoefficient(uf),trailp)
       trailp := (trailp exquo gg)::DPoly
       lc := (lc exquo gg)::DPoly
       linp:SUP:=monomial(lc,1$NNI)$SUP + monomial(trailp,0$NNI)$SUP
       g:DPoly:=multivariate(uf-linp**df,x)
       redPol(g,lpol) ^= 0 => "failed"
       multivariate(linp,x)

            -- is the 0-dimensional ideal I in general position ?  --
                     ----  internal function  ----
     testGenPos(lpol:L DPoly,lvar:L OV):Union(L DPoly,"failed") ==
       rlpol:=reverse lpol
       f:=rlpol.first
       #lvar=1 => [f]
       rlvar:=rest reverse lvar
       newlpol:List(DPoly):=[f]
       for f in rlpol.rest repeat
         x:=first rlvar
         fi:= univariate(f,x)
         if (mainVariable leadingCoefficient fi case "failed") then
           if ((g:= testPower(fi,x,newlpol)) case "failed")
           then return "failed"
           newlpol :=concat(redPol(g::DPoly,newlpol),newlpol)
           rlvar:=rest rlvar
         else if redPol(f,newlpol)^=0 then return"failed"
       newlpol


        -- change coordinates and out the ideal in general position  ----
     genPos(lp:L DPoly,lvar:L OV): Record(polys:L HDPoly, lpolys:L DPoly,
                                           coord:L I, univp:HDPoly) ==
           rlvar:=reverse lvar
           lnp:=[dmpToHdmp(f) for f in lp]
           x := first rlvar;rlvar:=rest rlvar
           testfail:=true
           for count in 1.. while testfail repeat
             ranvals:L I:=[1+(random()$I rem (count*(# lvar))) for vv in rlvar]
             val:=+/[rv*(vv::HDPoly)
                        for vv in rlvar for rv in ranvals]
             val:=val+x::HDPoly
             gb:L HDPoly:= [elt(univariate(p,x),val) for p in lnp]
             gb:=groebner gb
             gbt:=totolex gb
             (gb1:=testGenPos(gbt,lvar)) case "failed"=>"try again"
             testfail:=false
           [gb,gbt,ranvals,dmpToHdmp(last (gb1::L DPoly))]

     genericPosition(lp:L DPoly,lvar:L OV) ==
        nans:=genPos(lp,lvar)
        [nans.lpolys, nans.coord]

        ---- select  the univariate factors
     select(lup:L L HDPoly) : L L HDPoly ==
       lup=[] => list []
       [:[cons(f,lsel) for lsel in select lup.rest] for f in lup.first]

        ---- in the non generic case, we compute the prime ideals ----
           ---- associated to leq, basis is the algebra basis  ----
     findCompon(leq:L HDPoly,lvar:L OV):L L DPoly ==
       teq:=totolex(leq)
       #teq = #lvar => [teq]
      -- ^((teq1:=testGenPos(teq,lvar)) case "failed") => [teq1::L DPoly]
       gp:=genPos(teq,lvar)
       lgp:= gp.polys
       g:HDPoly:=gp.univp
       fg:=(factor g)$GeneralizedMultivariateFactorize(OV,HDP,R,F,HDPoly)
       lfact:=[ff.factor for ff in factors(fg::Factored(HDPoly))]
       result: L L HDPoly := []
       #lfact=1 => [teq]
       for tfact in lfact repeat
         tlfact:=concat(tfact,lgp)
         result:=concat(tlfact,result)
       ranvals:L I:=gp.coord
       rlvar:=reverse lvar
       x:=first rlvar
       rlvar:=rest rlvar
       val:=+/[rv*(vv::HDPoly) for vv in rlvar for rv in ranvals]
       val:=(x::HDPoly)-val
       ans:=[totolex groebner [elt(univariate(p,x),val) for p in lp]
                           for lp in result]
       [ll for ll in ans | ll^=[1]]

     zeroDim?(lp: List HDPoly,lvar:L OV) : Boolean ==
       empty? lp => false
       n:NNI := #lvar
       #lp < n => false
       lvint1 := lvar
       for f in lp while not empty?(lvint1) repeat
          g:= f - reductum f
          x:=mainVariable(g)::OV
          if ground?(leadingCoefficient(univariate(g,x))) then
               lvint1 := remove(x, lvint1)
       empty? lvint1

     -- general solve, gives an error if the system not 0-dimensional
     groebSolve(leq: L DPoly,lvar:L OV) : L L DPoly ==
       lnp:=[dmpToHdmp(f) for f in leq]
       leq1:=groebner lnp
       #(leq1) = 1 and first(leq1) = 1 => list empty()
       ^(zeroDim?(leq1,lvar)) =>
         error "system does not have a finite number of solutions"
       -- add computation of dimension, for a more useful error
       basis:=computeBasis(leq1)
       lup:L HDPoly:=[]
       llfact:L Factored(HDPoly):=[]
       for x in lvar repeat
         g:=minPol(leq1,basis,x)
         fg:=(factor g)$GeneralizedMultivariateFactorize(OV,HDP,R,F,HDPoly)
         llfact:=concat(fg::Factored(HDPoly),llfact)
         if degree(g,x) = #basis then leave "stop factoring"
       result: L L DPoly := []
       -- selecting a factor from the lists of the univariate factors
       lfact:=select [[ff.factor for ff in factors llf]
                       for llf in llfact]
       for tfact in lfact repeat
         tfact:=groebner concat(tfact,leq1)
         tfact=[1] => "next value"
         result:=concat(result,findCompon(tfact,lvar))
       result

     -- test if the system is zero dimensional
     testDim(leq : L HDPoly,lvar : L OV) : Union(L HDPoly,"failed") ==
       leq1:=groebner leq
       #(leq1) = 1 and first(leq1) = 1 => empty()
       ^(zeroDim?(leq1,lvar)) => "failed"
       leq1

@
<<GROEBSOL.dotabb>>=
"GROEBSOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GROEBSOL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"DIRPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=DIRPCAT"]
"GROEBSOL" -> "PFECAT"
"GROEBSOL" -> "DIRPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESS Guess}
The packages defined in this file enable {Axiom} to guess formulas for
sequences of, for example, rational numbers or rational functions, given the
first few terms.  It extends and complements Christian Krattenthaler's
program Rate and the relevant parts of Bruno Salvy and Paul Zimmermann's
GFUN.
\pagehead{Guess}{GUESS}
\pagepic{ps/v104guess.ps}{GUESS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESS Guess>>=
)abbrev package GUESS Guess
++ Author: Martin Rubey
++ Description: This package implements guessing of sequences. Packages for the
++ most common cases are provided as \spadtype{GuessInteger},
++ \spadtype{GuessPolynomial}, etc.
Guess(F, S, EXPRR, R, retract, coerce): Exports == Implementation where
    F: Field                                 -- zB.: FRAC POLY PF 5
-- in F we interpolate und check 

    S: GcdDomain

-- in guessExpRat I would like to determine the roots of polynomials in F. When
-- F is a quotientfield, I can get rid of the denominator.  In this case F is
-- roughly QFCAT S

    R: Join(OrderedSet, IntegralDomain)      -- zB.: FRAC POLY INT

-- results are given as elements of EXPRR
--    EXPRR: Join(ExpressionSpace, IntegralDomain,
    EXPRR: Join(FunctionSpace Integer, IntegralDomain,
                RetractableTo R, RetractableTo Symbol, 
                RetractableTo Integer, CombinatorialOpsCategory,
                PartialDifferentialRing Symbol) with
              _* : (%,%) -> %
              _/ : (%,%) -> %
              _*_* : (%,%) -> %
              numerator : % -> %
              denominator : % -> %
              ground? : % -> Boolean

                                             -- zB.: EXPR INT
-- EXPR FRAC POLY INT is forbidden. Thus i cannot just use EXPR R

-- EXPRR exists, in case at some point there is support for EXPR PF 5.


-- the following I really would like to get rid of

    retract: R -> F                          -- zB.: i+->i
    coerce: F -> EXPRR                       -- zB.: i+->i
-- attention: EXPRR ~= EXPR R

    LGOPT ==> List GuessOption
    GOPT0 ==> GuessOptionFunctions0

    NNI ==> NonNegativeInteger
    PI ==> PositiveInteger
    EXPRI ==> Expression Integer
    GUESSRESULT ==> List Record(function: EXPRR, order: NNI)

    UFPSF ==> UnivariateFormalPowerSeries F
    UFPS1 ==> UnivariateFormalPowerSeriesFunctions

    UFPSS ==> UnivariateFormalPowerSeries S

    SUP ==> SparseUnivariatePolynomial

    UFPSSUPF ==> UnivariateFormalPowerSeries SUP F

    FFFG ==> FractionFreeFastGaussian
    FFFGF ==> FractionFreeFastGaussianFractions

-- CoeffAction
    DIFFSPECA ==> (NNI, NNI, SUP S) -> S

    DIFFSPECAF ==> (NNI, NNI, UFPSSUPF) -> SUP F

    DIFFSPECAX ==> (NNI, Symbol, EXPRR) -> EXPRR

-- the diagonal of the C-matrix
    DIFFSPECC ==> NNI -> List S


    HPSPEC ==> Record(guessStream:  UFPSF -> Stream UFPSF,
                      degreeStream: Stream NNI,
                      testStream:   UFPSSUPF -> Stream UFPSSUPF, 
                      exprStream:   (EXPRR, Symbol) -> Stream EXPRR,
                      A:  DIFFSPECA,
                      AF: DIFFSPECAF,
                      AX: DIFFSPECAX,
                      C:  DIFFSPECC)

-- note that empty?(guessStream.o) has to return always. In other words, if the
-- stream is finite, empty? should recognize it.

    DIFFSPECN ==> EXPRR -> EXPRR             -- eg.: i+->q^i

    GUESSER ==> (List F, LGOPT) -> GUESSRESULT

    FSUPS ==> Fraction SUP S
    FSUPF ==> Fraction SUP F

    V ==> OrderedVariableList(['a1, 'A])
    POLYF ==> SparseMultivariatePolynomial(F, V)
    FPOLYF ==> Fraction POLYF
    FSUPFPOLYF ==> Fraction SUP FPOLYF
    POLYS ==> SparseMultivariatePolynomial(S, V)
    FPOLYS ==> Fraction POLYS
    FSUPFPOLYS ==> Fraction SUP FPOLYS

@
The following should be commented out when not debugging, see also
Section~\ref{sec:Hermite-Pade}.

<<package GUESS Guess>>=
    --@<<implementation: Guess - Hermite-Pade - Types for Operators>>
    -- EXT ==> (Integer, V, V) -> FPOLYS
    -- EXTEXPR ==> (Symbol, F, F) -> EXPRR
@

<<package GUESS Guess>>=
    Exports == with

        guess: List F -> GUESSRESULT
          ++ \spad{guess l} applies recursively \spadfun{guessRec} and
          ++ \spadfun{guessADE} to the successive differences and quotients of
          ++ the list. Default options as described in
          ++ \spadtype{GuessOptionFunctions0} are used.

        guess: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guess(l, options)} applies recursively \spadfun{guessRec}
          ++ and \spadfun{guessADE} to the successive differences and quotients
          ++ of the list. The given options are used.

        guess: (List F, List GUESSER, List Symbol) -> GUESSRESULT
          ++ \spad{guess(l, guessers, ops)} applies recursively the given
          ++ guessers to the successive differences if ops contains the symbol
          ++ guessSum and quotients if ops contains the symbol guessProduct to
          ++ the list. Default options as described in
          ++ \spadtype{GuessOptionFunctions0} are used.

        guess: (List F, List GUESSER, List Symbol, LGOPT) -> GUESSRESULT
          ++ \spad{guess(l, guessers, ops)} applies recursively the given
          ++ guessers to the successive differences if ops contains the symbol
          ++ \spad{guessSum} and quotients if ops contains the symbol
          ++ \spad{guessProduct} to the list. The given options are used.

        guessExpRat: List F -> GUESSRESULT
          ++ \spad{guessExpRat l} tries to find a function of the form 
          ++ n+->(a+b n)^n r(n), where r(n) is a rational function, that fits
          ++ l. 

        guessExpRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessExpRat(l, options)} tries to find a function of the
          ++ form n+->(a+b n)^n r(n), where r(n) is a rational function, that
          ++ fits l. 

        guessBinRat: List F -> GUESSRESULT
          ++ \spad{guessBinRat(l, options)} tries to find a function of the
          ++ form n+->binomial(a+b n, n) r(n), where r(n) is a rational 
          ++ function, that fits l. 

        guessBinRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessBinRat(l, options)} tries to find a function of the
          ++ form n+->binomial(a+b n, n) r(n), where r(n) is a rational 
          ++ function, that fits l. 

        if F has RetractableTo Symbol and S has RetractableTo Symbol then

            guessExpRat: Symbol -> GUESSER
              ++ \spad{guessExpRat q} returns a guesser that tries to find a
              ++ function of the form n+->(a+b q^n)^n r(q^n), where r(q^n) is a
              ++ q-rational function, that fits l.

            guessBinRat: Symbol -> GUESSER
              ++ \spad{guessBinRat q} returns a guesser that tries to find a
              ++ function of the form n+->qbinomial(a+b n, n) r(n), where r(q^n) is a
              ++ q-rational function, that fits l.

        guessHP: (LGOPT -> HPSPEC) -> GUESSER
          ++ \spad{guessHP f} constructs an operation that applies Hermite-Pade
          ++ approximation to the series generated by the given function f.

        guessADE: List F -> GUESSRESULT
          ++ \spad{guessADE l} tries to find an algebraic differential equation
          ++ for a generating function whose first Taylor coefficients are
          ++ given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}.

        guessADE: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessADE(l, options)} tries to find an algebraic
          ++ differential equation for a generating function whose first Taylor
          ++ coefficients are given by l, using the given options.

        guessAlg: List F -> GUESSRESULT
          ++ \spad{guessAlg l} tries to find an algebraic equation for a
          ++ generating function whose first Taylor coefficients are given by
          ++ l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessADE}(l, maxDerivative == 0).

        guessAlg: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessAlg(l, options)} tries to find an algebraic equation
          ++ for a generating function whose first Taylor coefficients are
          ++ given by l, using the given options. It is equivalent to
          ++ \spadfun{guessADE}(l, options) with \spad{maxDerivative == 0}.

        guessHolo: List F -> GUESSRESULT
          ++ \spad{guessHolo l} tries to find an ordinary linear differential
          ++ equation for a generating function whose first Taylor coefficients
          ++ are given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessADE}\spad{(l, maxPower == 1)}.

        guessHolo: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessHolo(l, options)} tries to find an ordinary linear
          ++ differential equation for a generating function whose first Taylor
          ++ coefficients are given by l, using the given options. It is
          ++ equivalent to \spadfun{guessADE}\spad{(l, options)} with
          ++ \spad{maxPower == 1}.

        guessPade: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessPade(l, options)} tries to find a rational function
          ++ whose first Taylor coefficients are given by l, using the given
          ++ options. It is equivalent to \spadfun{guessADE}\spad{(l,
          ++ maxDerivative == 0, maxPower == 1, allDegrees == true)}.

        guessPade: List F -> GUESSRESULT
          ++ \spad{guessPade(l, options)} tries to find a rational function
          ++ whose first Taylor coefficients are given by l, using the default
          ++ options described in \spadtype{GuessOptionFunctions0}. It is
          ++ equivalent to \spadfun{guessADE}\spad{(l, options)} with
          ++ \spad{maxDerivative == 0, maxPower == 1, allDegrees == true}.

        guessRec: List F -> GUESSRESULT
          ++ \spad{guessRec l} tries to find an ordinary difference equation
          ++ whose first values are given by l, using the default options
          ++ described in \spadtype{GuessOptionFunctions0}.

        guessRec: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessRec(l, options)} tries to find an ordinary difference
          ++ equation whose first values are given by l, using the given
          ++ options. 

        guessPRec: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessPRec(l, options)} tries to find a linear recurrence
          ++ with polynomial coefficients whose first values are given by l,
          ++ using the given options. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, options)} with \spad{maxPower == 1}.

        guessPRec: List F -> GUESSRESULT
          ++ \spad{guessPRec l} tries to find a linear recurrence with
          ++ polynomial coefficients whose first values are given by l, using
          ++ the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, maxPower == 1)}. 

        guessRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessRat(l, options)} tries to find a rational function
          ++ whose first values are given by l, using the given options. It is
          ++ equivalent to \spadfun{guessRec}\spad{(l, maxShift == 0, maxPower
          ++ == 1, allDegrees == true)}.

        guessRat: List F -> GUESSRESULT
          ++ \spad{guessRat l} tries to find a rational function whose first
          ++ values are given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, maxShift == 0, maxPower == 1,
          ++ allDegrees == true)}.

        diffHP: LGOPT -> HPSPEC
          ++ \spad{diffHP options} returns a specification for Hermite-Pade
          ++ approximation with the differential operator

        shiftHP: LGOPT -> HPSPEC
          ++ \spad{shiftHP options} returns a specification for Hermite-Pade
          ++ approximation with the shift operator

        if F has RetractableTo Symbol and S has RetractableTo Symbol then

            shiftHP: Symbol -> (LGOPT -> HPSPEC)
              ++ \spad{shiftHP options} returns a specification for
              ++ Hermite-Pade approximation with the $q$-shift operator

            diffHP: Symbol -> (LGOPT -> HPSPEC)
              ++ \spad{diffHP options} returns a specification for Hermite-Pade
              ++ approximation with the  $q$-dilation operator

            guessRec: Symbol -> GUESSER
              ++ \spad{guessRec q} returns a guesser that finds an ordinary
              ++ q-difference equation whose first values are given by l, using
              ++ the given options.

            guessPRec: Symbol -> GUESSER
              ++ \spad{guessPRec q} returns a guesser that tries to find
              ++ a linear q-recurrence with polynomial coefficients whose first
              ++ values are given by l, using the given options. It is
              ++ equivalent to \spadfun{guessRec}\spad{(q)} with 
              ++ \spad{maxPower == 1}.

            guessRat: Symbol -> GUESSER
              ++ \spad{guessRat q} returns a guesser that tries to find a
              ++ q-rational function whose first values are given by l, using
              ++ the given options. It is equivalent to \spadfun{guessRec} with
              ++ \spad{(l, maxShift == 0, maxPower == 1, allDegrees == true)}.

            guessADE: Symbol -> GUESSER
              ++ \spad{guessADE q} returns a guesser that tries to find an
              ++ algebraic differential equation for a generating function whose
              ++ first Taylor coefficients are given by l, using the given
              ++ options.

        --@<<debug exports: Guess>>
@

<<debug exports: Guess>>=
--termAsUFPSF: (UFPSF, List Integer, DIFFSPECS, DIFFSPEC1) -> UFPSF
--termAsUFPSF2: (UFPSF, List Integer, DIFFSPECS, DIFFSPEC1) -> UFPSF
--termAsEXPRR: (EXPRR, Symbol, List Integer, DIFFSPECX, DIFFSPEC1X) -> EXPRR
--termAsUFPSSUPF: (UFPSSUPF, List Integer, DIFFSPECSF, DIFFSPEC1F) -> UFPSSUPF
--termAsUFPSSUPF2: (UFPSSUPF, List Integer, DIFFSPECSF, DIFFSPEC1F) -> UFPSSUPF
--
--ShiftSXGF: (EXPRR, Symbol, NNI) -> EXPRR
--ShiftAXGF: (NNI, Symbol, EXPRR) -> EXPRR
--
--FilteredPartitionStream: LGOPT -> Stream List Integer
--
--guessInterpolate: (List SUP F, List NNI, HPSPEC) -> Matrix SUP S
testInterpolant: (List SUP S, List F, List UFPSSUPF, List EXPRR, List EXPRR, _
                  NNI, HPSPEC, Symbol, BasicOperator, LGOPT) _
                  -> Union("failed", Record(function: EXPRR, order: NNI))

--checkResult: (EXPRR, Symbol, Integer, List F, LGOPT) -> NNI
--
--guessBinRatAux: (Symbol, List F, DIFFSPECN, EXT, EXTEXPR,
--                 List Integer, LGOPT) -> List EXPRR
--guessBinRatAux0: (List F, DIFFSPECN, EXT, EXTEXPR,
--                  LGOPT) -> GUESSRESULT
--binExt: EXT
--binExtEXPR: EXTEXPR
--defaultD: DIFFSPECN

@

<<package GUESS Guess>>=
    Implementation == add
        <<implementation: Guess>>
@

<<implementation: Guess>>=

-- We have to put this chunk at the beginning, because otherwise it will take
-- very long to compile.

<<implementation: Guess - guessExpRat - Order and Degree>>

<<implementation: Guess - Utilities>>
<<implementation: Guess - guessExpRat>>
<<implementation: Guess - guessBinRat>>
<<implementation: Guess - Hermite-Pade>>
<<implementation: Guess - guess>>
@

\subsection{general utilities}

<<implementation: Guess - Utilities>>=
checkResult(res: EXPRR, n: Symbol, l: Integer, list: List F, 
            options: LGOPT): NNI ==
    for i in l..1 by -1 repeat
        den := eval(denominator res, n::EXPRR, (i-1)::EXPRR)
        if den = 0 then return i::NNI
        num := eval(numerator res, n::EXPRR, (i-1)::EXPRR)
        if list.i ~= retract(retract(num/den)@R)
        then return i::NNI
    0$NNI

SUPS2SUPF(p: SUP S): SUP F ==
  if F is S then 
    p pretend SUP(F)
  else if F is Fraction S then
    map(coerce(#1)$Fraction(S), p)
      $SparseUnivariatePolynomialFunctions2(S, F)
  else error "Type parameter F should be either equal to S or equal _
              to Fraction S"

@
%$

\subsection{guessing rational functions with an exponential term}

<<implementation: Guess - guessExpRat>>=
<<implementation: Guess - guessExpRat - Utilities>>
<<implementation: Guess - guessExpRat - Main>>
@

\subsubsection{Utilities}

\paragraph{conversion routines}

<<implementation: Guess - guessExpRat - Utilities>>=
F2FPOLYS(p: F): FPOLYS ==
  if F is S then 
    p::POLYF::FPOLYF pretend FPOLYS
  else if F is Fraction S then
    numer(p)$Fraction(S)::POLYS/denom(p)$Fraction(S)::POLYS
  else error "Type parameter F should be either equal to S or equal _
               to Fraction S"

MPCSF ==> MPolyCatFunctions2(V, IndexedExponents V, 
                                IndexedExponents V, S, F,
                                POLYS, POLYF)

SUPF2EXPRR(xx: Symbol, p: SUP F): EXPRR ==
  zero? p => 0
  (coerce(leadingCoefficient p))::EXPRR * (xx::EXPRR)**degree p
     + SUPF2EXPRR(xx, reductum p)

FSUPF2EXPRR(xx: Symbol, p: FSUPF): EXPRR ==
  (SUPF2EXPRR(xx, numer p)) / (SUPF2EXPRR(xx, denom p))


POLYS2POLYF(p: POLYS): POLYF ==
  if F is S then 
    p pretend POLYF
  else if F is Fraction S then
    map(coerce(#1)$Fraction(S), p)$MPCSF
  else error "Type parameter F should be either equal to S or equal _
              to Fraction S"

SUPPOLYS2SUPF(p: SUP POLYS, a1v: F, Av: F): SUP F ==
  zero? p => 0
  lc: POLYF := POLYS2POLYF leadingCoefficient(p)
  monomial(retract(eval(lc, [index(1)$V, index(2)$V]::List V, 
                            [a1v, Av])),
           degree p) 
    + SUPPOLYS2SUPF(reductum p, a1v, Av)


SUPFPOLYS2FSUPPOLYS(p: SUP FPOLYS): Fraction SUP POLYS  ==
  cden := splitDenominator(p)
         $UnivariatePolynomialCommonDenominator(POLYS, FPOLYS,SUP FPOLYS)

  pnum: SUP POLYS 
       := map(retract(#1 * cden.den)$FPOLYS, p)
             $SparseUnivariatePolynomialFunctions2(FPOLYS, POLYS)
  pden: SUP POLYS := (cden.den)::SUP POLYS

  pnum/pden


POLYF2EXPRR(p: POLYF): EXPRR ==
  map(convert(#1)@Symbol::EXPRR, coerce(#1)@EXPRR, p)
     $PolynomialCategoryLifting(IndexedExponents V, V, 
                                F, POLYF, EXPRR)

-- this needs documentation. In particular, why is V appearing here?
GF ==> GeneralizedMultivariateFactorize(SingletonAsOrderedSet,
                                        IndexedExponents V, F, F,
                                        SUP F)

-- does not work:
--                                                     6
--   WARNING (genufact): No known algorithm to factor ? , trying square-free.

-- GF ==> GenUFactorize F
@

\paragraph{mimicking $q$-analoga}

<<implementation: Guess - guessExpRat - Utilities>>=
defaultD: DIFFSPECN
defaultD(expr: EXPRR): EXPRR == expr

-- applies n+->q^n or whatever DN is to i
DN2DL: (DIFFSPECN, Integer) -> F
DN2DL(DN, i) == retract(retract(DN(i::EXPRR))@R)

<<implementation: Guess - guessExpRat - evalResultant>>
<<implementation: Guess - guessExpRat - substitute>>
@

\subsubsection{reducing the degree of the polynomials}

The degree of [[poly3]] is governed by $(a_0+x_m a_1)^{x_m}$. Therefore, we
substitute $A-x_m a1$ for $a_0$, which reduces the degree in $a_1$ by
$x_m-x_{i+1}$.

<<implementation: Guess - guessExpRat - substitute>>=
p(xm: Integer, i: Integer, va1: V, vA: V, basis: DIFFSPECN): FPOLYS == 
    vA::POLYS::FPOLYS + va1::POLYS::FPOLYS _ 
                       * F2FPOLYS(DN2DL(basis, i) - DN2DL(basis, xm))

p2(xm: Integer, i: Symbol, a1v: F, Av: F, basis: DIFFSPECN): EXPRR == 
    coerce(Av) + coerce(a1v)*(basis(i::EXPRR) - basis(xm::EXPRR))

@

<<not interesting implementation: Guess - guessExpRat - substitute>>=
p(xm: Integer, i: Integer, va1: V, vA: V, basis: DIFFSPECN): FPOLYS == 
    vA::POLYS::FPOLYS + (i-xm)*va1::POLYS::FPOLYS

p2(xm: Integer, i: Symbol, a1v: F, Av: F, basis: DIFFSPECN): EXPRR == 
    coerce(Av) + coerce(a1v)*(i::EXPRR - xm::EXPRR)

@

\subsubsection{Order and Degree}

The following expressions for order and degree of the resultants [[res1]] and
[[res2]] in [[guessExpRatAux]] were first guessed -- partially with the aid of
[[guessRat]], and then proven to be correct.

<<implementation: Guess - guessExpRat - Order and Degree>>=
ord1(x: List Integer, i: Integer): Integer == 
    n := #x - 3 - i
    x.(n+1)*reduce(_+, [x.j for j in 1..n], 0) + _
        2*reduce(_+, [reduce(_+, [x.k*x.j for k in 1..j-1], 0) _
                      for j in 1..n], 0)

ord2(x: List Integer, i: Integer): Integer == 
    if zero? i then
        n := #x - 3 - i
        ord1(x, i) + reduce(_+, [x.j for j in 1..n], 0)*(x.(n+2)-x.(n+1))
    else
        ord1(x, i)

deg1(x: List Integer, i: Integer): Integer == 
    m := #x - 3 
    (x.(m+3)+x.(m+1)+x.(1+i))*reduce(_+, [x.j for j in 2+i..m], 0) + _
        x.(m+3)*x.(m+1) + _
        2*reduce(_+, [reduce(_+, [x.k*x.j for k in 2+i..j-1], 0) _
                      for j in 2+i..m], 0)

deg2(x: List Integer, i: Integer): Integer == 
    m := #x - 3
    deg1(x, i) + _
        (x.(m+3) + reduce(_+, [x.j for j in 2+i..m], 0)) * _
        (x.(m+2)-x.(m+1))

@

[[evalResultant]] evaluates the resultant of [[p1]] and [[p2]] at [[d-o+1]]
points, so that we can recover it by interpolation.

<<implementation: Guess - guessExpRat - evalResultant>>=
evalResultant(p1: POLYS, p2: POLYS, o: Integer, d: Integer, va1: V, vA: V)_
: List S == 
    res: List S := []
    d1 := degree(p1, va1)
    d2 := degree(p2, va1)
    lead: S
    for k in 1..d-o+1 repeat
        p1atk := univariate eval(p1, vA, k::S)
        p2atk := univariate eval(p2, vA, k::S)

@

It may happen, that the leading coefficients of one or both of the polynomials
changes, when we evaluate it at $k$. In this case, we need to correct this by
multiplying with the corresponding power of the leading coefficient of the
other polynomial.

Consider the Sylvester matrix of the original polynomials. We want to evaluate
it at $A=k$. If the first few leading coefficients of $p2$ vanish, the first
few columns of the Sylvester matrix have triangular shape, with the leading
coefficient of $p1$ on the diagonal. The same thing happens, if we exchange the
roles of $p1$ and $p2$, only that we have to take care of the sign, too.

<<implementation: Guess - guessExpRat - evalResultant>>=
        d1atk := degree p1atk
        d2atk := degree p2atk

--      output("k: " string(k))$OutputPackage
--      output("d1: " string(d1) " d1atk: " string(d1atk))$OutputPackage
--      output("d2: " string(d2) " d2atk: " string(d2atk))$OutputPackage


        if d2atk < d2 then
            if  d1atk < d1
            then lead := 0$S
            else lead := (leadingCoefficient p1atk)**((d2-d2atk)::NNI)
        else
            if  d1atk < d1
            then lead := (-1$S)**d2 * (leadingCoefficient p2atk)**((d1-d1atk)::NNI)
            else lead := 1$S

        if zero? lead 
        then res := cons(0, res)
        else res := cons(lead * (resultant(p1atk, p2atk)$SUP(S) exquo _
                                (k::S)**(o::NNI))::S, 
                         res)

@
%$

Since we also have an lower bound for the order of the resultant, we need to
evaluate it only at $d-o+1$ points. Furthermore, we can divide by $k^o$ and
still obtain a polynomial.

<<implementation: Guess - guessExpRat - evalResultant>>=
    reverse res

@

\subsubsection{The main routine}

<<implementation: Guess - guessExpRat - Main>>=
guessExpRatAux(xx: Symbol, list: List F, basis: DIFFSPECN, 
               xValues: List Integer, options: LGOPT): List EXPRR ==

    a1: V := index(1)$V
    A: V := index(2)$V

    len: NNI := #list
    if len < 4 then return []
               else len := (len-3)::NNI

    xlist := [F2FPOLYS DN2DL(basis, xValues.i) for i in 1..len]
    x1 := F2FPOLYS DN2DL(basis, xValues.(len+1))
    x2 := F2FPOLYS DN2DL(basis, xValues.(len+2))
    x3 := F2FPOLYS DN2DL(basis, xValues.(len+3))

@

We try to fit the data $(s1,s2,\dots)$ to the model $(a+b n)^n y(n)$, $r$ being
a rational function. To obtain $y$, we compute $y(n)=s_n*(a+b n)^{-n}$.

<<implementation: Guess - guessExpRat - Main>>=
    y: NNI -> FPOLYS := 
        F2FPOLYS(list.#1) * _
        p(last xValues, (xValues.#1)::Integer, a1, A, basis)**_
            (-(xValues.#1)::Integer)

    ylist: List FPOLYS := [y i for i in 1..len]

    y1 := y(len+1)
    y2 := y(len+2)
    y3 := y(len+3)

    res := []::List EXPRR
    if maxDegree(options)$GOPT0 = -1
    then maxDeg := len-1
    else maxDeg := min(maxDegree(options)$GOPT0, len-1)

    for i in 0..maxDeg repeat
        if debug(options)$GOPT0 then
            output(hconcat("degree ExpRat "::OutputForm, i::OutputForm))
                $OutputPackage

@

\begin{verbatim}
  Shouldn't we use the algorithm over [[POLYS]] here? Strange enough, for
  polynomial interpolation, it is faster, but for rational interpolation
  \emph{much} slower. This should be investigated.
\end{verbatim}

\begin{verbatim}
  It seems that [[maxDeg]] bounds the degree of the denominator, rather than
  the numerator? This is now added to the documentation of [[maxDegree]], it
  should make sense.
\end{verbatim}

<<implementation: Guess - guessExpRat - Main>>=
        if debug(options)$GOPT0 then 
            systemCommand("sys date +%s")$MoreSystemCommands
            output("interpolating..."::OutputForm)$OutputPackage

        ri: FSUPFPOLYS
           := interpolate(xlist, ylist, (len-1-i)::NNI) _
                         $FFFG(FPOLYS, SUP FPOLYS)

-- for experimental fraction free interpolation
--        ri: Fraction SUP POLYS
--           := interpolate(xlist, ylist, (len-1-i)::NNI) _
--                         $FFFG(POLYS, SUP POLYS)

        if debug(options)$GOPT0 then 
--            output(hconcat("xlist: ", xlist::OutputForm))$OutputPackage
--            output(hconcat("ylist: ", ylist::OutputForm))$OutputPackage
--            output(hconcat("ri: ", ri::OutputForm))$OutputPackage
            systemCommand("sys date +%s")$MoreSystemCommands
            output("polynomials..."::OutputForm)$OutputPackage

        poly1: POLYS := numer(elt(ri, x1)$SUP(FPOLYS) - y1)
        poly2: POLYS := numer(elt(ri, x2)$SUP(FPOLYS) - y2)
        poly3: POLYS := numer(elt(ri, x3)$SUP(FPOLYS) - y3)

-- for experimental fraction free interpolation
--        ri2: FSUPFPOLYS := map(#1::FPOLYS, numer ri)                           _
--                           $SparseUnivariatePolynomialFunctions2(POLYS, FPOLYS)_ 
--                          /map(#1::FPOLYS, denom ri)                           _
--                           $SparseUnivariatePolynomialFunctions2(POLYS, FPOLYS)
--
--        poly1: POLYS := numer(elt(ri2, x1)$SUP(FPOLYS) - y1)
--        poly2: POLYS := numer(elt(ri2, x2)$SUP(FPOLYS) - y2)
--        poly3: POLYS := numer(elt(ri2, x3)$SUP(FPOLYS) - y3)

        n:Integer := len - i
        o1: Integer := ord1(xValues, i)
        d1: Integer := deg1(xValues, i)
        o2: Integer := ord2(xValues, i)
        d2: Integer := deg2(xValues, i)

-- another compiler bug: using i as iterator here makes the loop break

        if debug(options)$GOPT0 then 
            systemCommand("sys date +%s")$MoreSystemCommands
            output("interpolating resultants..."::OutputForm)$OutputPackage

        res1: SUP S
             := newton(evalResultant(poly1, poly3, o1, d1, a1, A))
                      $NewtonInterpolation(S)

        res2: SUP S
             := newton(evalResultant(poly2, poly3, o2, d2, a1, A))
                      $NewtonInterpolation(S)

        if debug(options)$GOPT0 then 
--            res1: SUP S := univariate(resultant(poly1, poly3, a1))
--            res2: SUP S := univariate(resultant(poly2, poly3, a1))
--            if res1 ~= res1res or res2 ~= res2res then
--            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
--                output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
--            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage
--                output(hconcat("res1 ", res1::OutputForm))$OutputPackage
--                output(hconcat("res2 ", res2::OutputForm))$OutputPackage
            output("n/i: " string(n) " " string(i))$OutputPackage
            output("res1 ord: " string(o1) " " string(minimumDegree res1))
                  $OutputPackage
            output("res1 deg: " string(d1) " " string(degree res1))
                  $OutputPackage
            output("res2 ord: " string(o2) " " string(minimumDegree res2))
                  $OutputPackage
            output("res2 deg: " string(d2) " " string(degree res2))
                  $OutputPackage

        if debug(options)$GOPT0 then 
            systemCommand("sys date +%s")$MoreSystemCommands
            output("computing gcd..."::OutputForm)$OutputPackage

-- we want to solve over F
-- for polynomial domains S this seems to be very costly!     
        res3: SUP F := SUPS2SUPF(primitivePart(gcd(res1, res2)))

        if debug(options)$GOPT0 then 
            systemCommand("sys date +%s")$MoreSystemCommands
            output("solving..."::OutputForm)$OutputPackage

-- res3 is a polynomial in A=a0+(len+3)*a1
-- now we have to find the roots of res3

        for f in factors factor(res3)$GF | degree f.factor = 1 repeat 
-- we are only interested in the linear factors
             if debug(options)$GOPT0 then 
                 output(hconcat("f: ", f::OutputForm))$OutputPackage

             Av: F := -coefficient(f.factor, 0)
                     / leadingCoefficient f.factor

-- FIXME: in an earlier version, we disregarded vanishing Av
--        maybe we intended to disregard vanishing a1v? Either doesn't really
--        make sense to me right now.

             evalPoly := eval(POLYS2POLYF poly3, A, Av)
             if zero? evalPoly 
             then evalPoly := eval(POLYS2POLYF poly1, A, Av)
-- Note that it really may happen that poly3 vanishes when specializing
-- A. Consider for example guessExpRat([1,1,1,1]).

-- FIXME: We check poly1 below, too. I should work out in what cases poly3
-- vanishes.

             for g in factors factor(univariate evalPoly)$GF 
                      | degree g.factor = 1 repeat
                 if debug(options)$GOPT0 then 
                     output(hconcat("g: ", g::OutputForm))$OutputPackage

                 a1v: F := -coefficient(g.factor, 0)
                          / leadingCoefficient g.factor

-- check whether poly1 and poly2 really vanish. Note that we could have found
-- an extraneous solution, since we only computed the gcd of the two
-- resultants.

                 t1 := eval(POLYS2POLYF poly1, [a1, A]::List V, 
                                               [a1v, Av]::List F)
                 if zero? t1 then  
                     t2 := eval(POLYS2POLYF poly2, [a1, A]::List V, 
                                                   [a1v, Av]::List F)
                     if zero? t2 then

                         ri1: Fraction SUP POLYS 
                             := SUPFPOLYS2FSUPPOLYS(numer ri)
                              / SUPFPOLYS2FSUPPOLYS(denom ri)

-- for experimental fraction free interpolation
--                         ri1: Fraction SUP POLYS := ri

                         numr: SUP F := SUPPOLYS2SUPF(numer ri1, a1v, Av)
                         denr: SUP F := SUPPOLYS2SUPF(denom ri1, a1v, Av)

                         if not zero? denr then
                             res4: EXPRR := eval(FSUPF2EXPRR(xx, numr/denr), 
                                                 kernel(xx), 
                                                 basis(xx::EXPRR))
                                           *p2(last xValues, _
                                               xx, a1v, Av, basis)_
                                            **xx::EXPRR
                             res := cons(res4, res)
                         else if zero? numr and debug(options)$GOPT0 then
                             output("numerator and denominator vanish!")
                                   $OutputPackage

-- If we are only interested in one solution, we do not try other degrees if we
-- have found already some solutions. I.e., the indentation here is correct.

        if not null(res) and one(options)$GOPT0 then return res

    res

guessExpRatAux0(list: List F, basis: DIFFSPECN, options: LGOPT): GUESSRESULT ==
    if zero? safety(options)$GOPT0 then
        error "Guess: guessExpRat does not support zero safety"
-- guesses Functions of the Form (a1*n+a0)^n*rat(n)
    xx := indexName(options)$GOPT0

-- restrict to safety

    len: Integer := #list
    if len-safety(options)$GOPT0+1 < 0 then return []

    shortlist: List F := first(list, (len-safety(options)$GOPT0+1)::NNI)

-- remove zeros from list

    zeros: EXPRR := 1
    newlist: List F
    xValues: List Integer

    i: Integer := -1
    for x in shortlist repeat
        i := i+1
        if x = 0 then 
            zeros := zeros * (basis(xx::EXPRR) - basis(i::EXPRR))

    i := -1
    for x in shortlist repeat
        i := i+1
        if x ~= 0 then
            newlist := cons(x/retract(retract(eval(zeros, xx::EXPRR, 
                                                          i::EXPRR))@R),
                            newlist)
            xValues := cons(i, xValues)

    newlist := reverse newlist
    xValues := reverse xValues

    res: List EXPRR 
        := [eval(zeros * f, xx::EXPRR, xx::EXPRR) _
            for f in guessExpRatAux(xx, newlist, basis, xValues, options)]

    reslist := map([#1, checkResult(#1, xx, len, list, options)], res)
                  $ListFunctions2(EXPRR, Record(function: EXPRR, order: NNI))

    select(#1.order < len-safety(options)$GOPT0, reslist)

guessExpRat(list : List F): GUESSRESULT ==
    guessExpRatAux0(list, defaultD, [])

guessExpRat(list: List F, options: LGOPT): GUESSRESULT ==
    guessExpRatAux0(list, defaultD, options)

if F has RetractableTo Symbol and S has RetractableTo Symbol then

    guessExpRat(q: Symbol): GUESSER ==
        guessExpRatAux0(#1, q::EXPRR**#1, #2)

@

\subsection{guessing rational functions with a binomial term}

\begin{verbatim}
  It is not clear whether one should take the model
  \begin{equation*}
    \binom{a+bn}{n}q(n),
  \end{equation*}
  which includes rational functions, or
  \begin{equation*}
    (a+bn)(a+bn+1)\dots (a+bn+n)q(n).
  \end{equation*}
  which includes rational functions times $n!$. We choose the former, since
  dividing by $n!$ is a common normalisation. The question remains whether we
  should do the same for [[guessExpRat]].
\end{verbatim}


<<implementation: Guess - guessBinRat>>=

EXT ==> (Integer, V, V) -> FPOLYS
EXTEXPR ==> (Symbol, F, F) -> EXPRR

binExt: EXT
binExt(i: Integer, va1: V, vA: V): FPOLYS == 
    numl: List POLYS := [(vA::POLYS) + i * (va1::POLYS) - (l::POLYS) _
                         for l in 0..i-1]
    num: POLYS := reduce(_*, numl, 1)

    num/(factorial(i)::POLYS)

binExtEXPR: EXTEXPR
binExtEXPR(i: Symbol, a1v: F, Av: F): EXPRR == 
    binomial(coerce Av + coerce a1v * (i::EXPRR), i::EXPRR)


guessBinRatAux(xx: Symbol, list: List F, 
               basis: DIFFSPECN, ext: EXT, extEXPR: EXTEXPR,
               xValues: List Integer, options: LGOPT): List EXPRR ==

    a1: V := index(1)$V
    A: V := index(2)$V

    len: NNI := #list
    if len < 4 then return []
               else len := (len-3)::NNI

    xlist := [F2FPOLYS DN2DL(basis, xValues.i) for i in 1..len]
    x1 := F2FPOLYS DN2DL(basis, xValues.(len+1))
    x2 := F2FPOLYS DN2DL(basis, xValues.(len+2))
    x3 := F2FPOLYS DN2DL(basis, xValues.(len+3))

@

We try to fit the data $(s1,s2,\dots)$ to the model $\binom{a+b n}{n} y(n)$,
$r$ being a rational function. To obtain $y$, we compute
$y(n)=s_n*\binom{a+bn}{n}^-1$.

<<implementation: Guess - guessBinRat>>=
    y: NNI -> FPOLYS := 
        F2FPOLYS(list.#1) / _
        ext((xValues.#1)::Integer, a1, A)

    ylist: List FPOLYS := [y i for i in 1..len]

    y1 := y(len+1)
    y2 := y(len+2)
    y3 := y(len+3)

    res := []::List EXPRR
    if maxDegree(options)$GOPT0 = -1
    then maxDeg := len-1
    else maxDeg := min(maxDegree(options)$GOPT0, len-1)

    for i in 0..maxDeg repeat
--        if debug(options)$GOPT0 then
--            output(hconcat("degree BinRat "::OutputForm, i::OutputForm))
--                $OutputPackage

@

\begin{verbatim}
  Shouldn't we use the algorithm over [[POLYS]] here? Strange enough, for
  polynomial interpolation, it is faster, but for rational interpolation
  \emph{much} slower. This should be investigated.
\end{verbatim}

\begin{verbatim}
  It seems that [[maxDeg]] bounds the degree of the denominator, rather than
  the numerator? This is now added to the documentation of [[maxDegree]], it
  should make sense.
\end{verbatim}

<<implementation: Guess - guessBinRat>>=
--        if debug(options)$GOPT0 then 
--            output("interpolating..."::OutputForm)$OutputPackage

        ri: FSUPFPOLYS
           := interpolate(xlist, ylist, (len-1-i)::NNI) _
                         $FFFG(FPOLYS, SUP FPOLYS)

--        if debug(options)$GOPT0 then 
--            output(hconcat("ri ", ri::OutputForm))$OutputPackage

        poly1: POLYS := numer(elt(ri, x1)$SUP(FPOLYS) - y1)
        poly2: POLYS := numer(elt(ri, x2)$SUP(FPOLYS) - y2)
        poly3: POLYS := numer(elt(ri, x3)$SUP(FPOLYS) - y3)

--        if debug(options)$GOPT0 then
--            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
--            output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
--            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage


        n:Integer := len - i
        res1: SUP S := univariate(resultant(poly1, poly3, a1))
        res2: SUP S := univariate(resultant(poly2, poly3, a1))
        if debug(options)$GOPT0 then
--            output(hconcat("res1 ", res1::OutputForm))$OutputPackage
--            output(hconcat("res2 ", res2::OutputForm))$OutputPackage

--            if res1 ~= res1res or res2 ~= res2res then
--            output(hconcat("poly1 ", poly1::OutputForm))$OutputPackage
--                output(hconcat("poly2 ", poly2::OutputForm))$OutputPackage
--            output(hconcat("poly3 ", poly3::OutputForm))$OutputPackage
--                output(hconcat("res1 ", res1::OutputForm))$OutputPackage
--                output(hconcat("res2 ", res2::OutputForm))$OutputPackage
--            output("n/i: " string(n) " " string(i))$OutputPackage
            output("res1 ord: " string(minimumDegree res1))
                  $OutputPackage
            output("res1 deg: " string(degree res1))
                  $OutputPackage
            output("res2 ord: " string(minimumDegree res2))
                  $OutputPackage
            output("res2 deg: " string(degree res2))
                  $OutputPackage

        if debug(options)$GOPT0 then 
            output("computing gcd..."::OutputForm)$OutputPackage

-- we want to solve over F            
        res3: SUP F := SUPS2SUPF(primitivePart(gcd(res1, res2)))

--        if debug(options)$GOPT0 then 
--            output(hconcat("res3 ", res3::OutputForm))$OutputPackage

-- res3 is a polynomial in A=a0+(len+3)*a1
-- now we have to find the roots of res3

        for f in factors factor(res3)$GF | degree f.factor = 1 repeat 
-- we are only interested in the linear factors
--             if debug(options)$GOPT0 then 
--                 output(hconcat("f: ", f::OutputForm))$OutputPackage

             Av: F := -coefficient(f.factor, 0)
                     / leadingCoefficient f.factor

--             if debug(options)$GOPT0 then 
--                 output(hconcat("Av: ", Av::OutputForm))$OutputPackage

-- FIXME: in an earlier version, we disregarded vanishing Av
--        maybe we intended to disregard vanishing a1v? Either doesn't really
--        make sense to me right now.

             evalPoly := eval(POLYS2POLYF poly3, A, Av)
             if zero? evalPoly 
             then evalPoly := eval(POLYS2POLYF poly1, A, Av)
-- Note that it really may happen that poly3 vanishes when specializing
-- A. Consider for example guessExpRat([1,1,1,1]).

-- FIXME: We check poly1 below, too. I should work out in what cases poly3
-- vanishes.

             for g in factors factor(univariate evalPoly)$GF 
                      | degree g.factor = 1 repeat
--                 if debug(options)$GOPT0 then 
--                     output(hconcat("g: ", g::OutputForm))$OutputPackage

                 a1v: F := -coefficient(g.factor, 0)
                          / leadingCoefficient g.factor

--                 if debug(options)$GOPT0 then 
--                     output(hconcat("a1v: ", a1v::OutputForm))$OutputPackage

-- check whether poly1 and poly2 really vanish. Note that we could have found
-- an extraneous solution, since we only computed the gcd of the two
-- resultants.

                 t1 := eval(POLYS2POLYF poly1, [a1, A]::List V, 
                                               [a1v, Av]::List F)

--                 if debug(options)$GOPT0 then 
--                     output(hconcat("t1: ", t1::OutputForm))$OutputPackage

                 if zero? t1 then  
                     t2 := eval(POLYS2POLYF poly2, [a1, A]::List V, 
                                                   [a1v, Av]::List F)

--                     if debug(options)$GOPT0 then 
--                         output(hconcat("t2: ", t2::OutputForm))$OutputPackage

                     if zero? t2 then

                         ri1: Fraction SUP POLYS 
                             := SUPFPOLYS2FSUPPOLYS(numer ri)
                              / SUPFPOLYS2FSUPPOLYS(denom ri)

--                         if debug(options)$GOPT0 then 
--                             output(hconcat("ri1: ", ri1::OutputForm))$OutputPackage

                         numr: SUP F := SUPPOLYS2SUPF(numer ri1, a1v, Av)
                         denr: SUP F := SUPPOLYS2SUPF(denom ri1, a1v, Av)

--                         if debug(options)$GOPT0 then 
--                             output(hconcat("numr: ", numr::OutputForm))$OutputPackage
--                             output(hconcat("denr: ", denr::OutputForm))$OutputPackage

                         if not zero? denr then
                             res4: EXPRR := eval(FSUPF2EXPRR(xx, numr/denr), 
                                                 kernel(xx), 
                                                 basis(xx::EXPRR))
                                           * extEXPR(xx, a1v, Av)

--                             if debug(options)$GOPT0 then 
--                                 output(hconcat("res4: ", res4::OutputForm))$OutputPackage

                             res := cons(res4, res)
                         else if zero? numr and debug(options)$GOPT0 then
                             output("numerator and denominator vanish!")
                                   $OutputPackage

-- If we are only interested in one solution, we do not try other degrees if we
-- have found already some solutions. I.e., the indentation here is correct.

        if not null(res) and one(options)$GOPT0 then return res

    res

guessBinRatAux0(list: List F,
                basis: DIFFSPECN, ext: EXT, extEXPR: EXTEXPR,
                options: LGOPT): GUESSRESULT ==

    if zero? safety(options)$GOPT0 then
        error "Guess: guessBinRat does not support zero safety"
-- guesses Functions of the form binomial(a+b*n, n)*rat(n)
    xx := indexName(options)$GOPT0

-- restrict to safety

    len: Integer := #list
    if len-safety(options)$GOPT0+1 < 0 then return []

    shortlist: List F := first(list, (len-safety(options)$GOPT0+1)::NNI)

-- remove zeros from list

    zeros: EXPRR := 1
    newlist: List F
    xValues: List Integer

    i: Integer := -1
    for x in shortlist repeat
        i := i+1
        if x = 0 then 
            zeros := zeros * (basis(xx::EXPRR) - basis(i::EXPRR))

    i := -1
    for x in shortlist repeat
        i := i+1
        if x ~= 0 then
            newlist := cons(x/retract(retract(eval(zeros, xx::EXPRR, 
                                                          i::EXPRR))@R),
                            newlist)
            xValues := cons(i, xValues)

    newlist := reverse newlist
    xValues := reverse xValues

    res: List EXPRR 
        := [eval(zeros * f, xx::EXPRR, xx::EXPRR) _
            for f in guessBinRatAux(xx, newlist, basis, ext, extEXPR, xValues, _
                                    options)]

    reslist := map([#1, checkResult(#1, xx, len, list, options)], res)
                  $ListFunctions2(EXPRR, Record(function: EXPRR, order: NNI))

    select(#1.order < len-safety(options)$GOPT0, reslist)

guessBinRat(list : List F): GUESSRESULT ==
    guessBinRatAux0(list, defaultD, binExt, binExtEXPR, [])

guessBinRat(list: List F, options: LGOPT): GUESSRESULT ==
    guessBinRatAux0(list, defaultD, binExt, binExtEXPR, options)


if F has RetractableTo Symbol and S has RetractableTo Symbol then

    qD: Symbol -> DIFFSPECN
    qD q == (q::EXPRR)**#1


    qBinExtAux(q: Symbol, i: Integer, va1: V, vA: V): FPOLYS == 
        fl: List FPOLYS 
             := [(1$FPOLYS - _
                  va1::POLYS::FPOLYS * (vA::POLYS::FPOLYS)**(i-1) * _
                  F2FPOLYS(q::F)**l) / (1-F2FPOLYS(q::F)**l) _ 
                 for l in 1..i]
        reduce(_*, fl, 1)

    qBinExt: Symbol -> EXT
    qBinExt q == qBinExtAux(q, #1, #2, #3)

    qBinExtEXPRaux(q: Symbol, i: Symbol, a1v: F, Av: F): EXPRR == 
        l: Symbol := 'l
        product((1$EXPRR - _
                 coerce a1v * (coerce Av) ** (coerce i - 1$EXPRR) * _
                 (q::EXPRR) ** coerce(l)) / _
                (1$EXPRR - (q::EXPRR) ** coerce(l)), _
                equation(l, 1$EXPRR..i::EXPRR))

    qBinExtEXPR: Symbol -> EXTEXPR
    qBinExtEXPR q == qBinExtEXPRaux(q, #1, #2, #3)

    guessBinRat(q: Symbol): GUESSER ==
        guessBinRatAux0(#1, qD q, qBinExt q, qBinExtEXPR q, #2)_

@


\subsection{Hermite Pad\'e interpolation}\label{sec:Hermite-Pade}

<<implementation: Guess - Hermite-Pade>>=
<<implementation: Guess - Hermite-Pade - Types for Operators>>
<<implementation: Guess - Hermite-Pade - Streams>>
<<implementation: Guess - Hermite-Pade - Operators>>
<<implementation: Guess - Hermite-Pade - Utilities>>
<<implementation: Guess - guessHPaux>>
<<implementation: Guess - guessHP>>
@

\subsubsection{Types for Operators}
<<implementation: Guess - Hermite-Pade - Types for Operators>>=
-- some useful types for Ore operators that work on series

-- the differentiation operator
DIFFSPECX ==> (EXPRR, Symbol, NonNegativeInteger) -> EXPRR
                                               -- eg.: f(x)+->f(q*x)
                                               --      f(x)+->D(f, x)
DIFFSPECS ==> (UFPSF, NonNegativeInteger) -> UFPSF
                                               -- eg.: f(x)+->f(q*x)

DIFFSPECSF ==> (UFPSSUPF, NonNegativeInteger) -> UFPSSUPF
                                               -- eg.: f(x)+->f(q*x)

-- the constant term for the inhomogeneous case

DIFFSPEC1 ==> UFPSF

DIFFSPEC1F ==> UFPSSUPF

DIFFSPEC1X ==> Symbol -> EXPRR

@

\subsubsection{Streams}\label{sec:streams}

In this section we define some functions that provide streams for
[[HermitePade]].

The following three functions transform a partition [[l]] into a product of
derivatives of [[f]], using the given operators. We need to provide the same
functionality for expressions, series and series with a transcendental element.
Only for expressions we do not provide a version using the Hadamard product,
although it would be quite easy to define an appropriate operator on
expressions.

A partition $(\lambda_1^{p_1},\lambda_2^{p_2},\dots)$ is transformed into the
expression $(f^{(\lambda_1-1)})^{p_1}(f^{(\lambda_2-1)})^{p_2}\cdots$, i.e.,
the size of the part is interpreted as derivative, the exponent as power.

<<implementation: Guess - Hermite-Pade - Streams>>=
termAsEXPRR(f: EXPRR, xx: Symbol, l: List Integer, 
            DX: DIFFSPECX, D1X: DIFFSPEC1X): EXPRR ==
    if empty? l then D1X(xx)
    else
        ll: List List Integer := powers(l)$Partition

        fl: List EXPRR := [DX(f, xx, (first part-1)::NonNegativeInteger)
                           ** second(part)::NNI for part in ll]
        reduce(_*, fl)

termAsUFPSF(f: UFPSF, l: List Integer, DS: DIFFSPECS, D1: DIFFSPEC1): UFPSF ==
    if empty? l then D1
    else
        ll: List List Integer := powers(l)$Partition

-- first of each element of ll is the derivative, second is the power

        fl: List UFPSF := [DS(f, (first part -1)::NonNegativeInteger) _
                           ** second(part)::NNI for part in ll]

        reduce(_*, fl)

-- returns \prod f^(l.i), but using the Hadamard product
termAsUFPSF2(f: UFPSF, l: List Integer, 
             DS: DIFFSPECS, D1: DIFFSPEC1): UFPSF ==
    if empty? l then D1
    else
        ll: List List Integer := powers(l)$Partition

-- first of each element of ll is the derivative, second is the power

        fl: List UFPSF 
            := [map(#1** second(part)::NNI, DS(f, (first part -1)::NNI)) _
                for part in ll]

        reduce(hadamard$UFPS1(F), fl)


termAsUFPSSUPF(f: UFPSSUPF, l: List Integer, 
                     DSF: DIFFSPECSF, D1F: DIFFSPEC1F): UFPSSUPF ==
    if empty? l then D1F
    else
        ll: List List Integer := powers(l)$Partition

-- first of each element of ll is the derivative, second is the power

        fl: List UFPSSUPF
           := [DSF(f, (first part -1)::NonNegativeInteger)
               ** second(part)::NNI for part in ll]

        reduce(_*, fl)


-- returns \prod f^(l.i), but using the Hadamard product
termAsUFPSSUPF2(f: UFPSSUPF, l: List Integer, 
                DSF: DIFFSPECSF, D1F: DIFFSPEC1F): UFPSSUPF ==
    if empty? l then D1F
    else
        ll: List List Integer := powers(l)$Partition

-- first of each element of ll is the derivative, second is the power

        fl: List UFPSSUPF 
           := [map(#1 ** second(part)::NNI, DSF(f, (first part -1)::NNI)) _
               for part in ll]

        reduce(hadamard$UFPS1(SUP F), fl)

@
%$

It is not clear whether we should \lq prefer\rq\ shifting and differentiation over
powering. Currently, we produce the stream
\[
  \begin{array}{rrrrrrrrr}
    \emptyset& 1& 11 & 2 & 111& 2 1 & 3  & 1111\\
            1& f& f^2& f'& f^3& f f'& f''& f^4 &\dots  
  \end{array}
\]

Maybe it would be better to produce
\[
  \begin{array}{rrrrrrrrr}
    \emptyset& 1& 2&  11 & 3  & 21  & 111& 4\\
    1& f& f'& f^2& f''& f f'& f^3& f''' &\dots 
  \end{array}
\]
instead, i.e., to leave the partitions unconjugated. Note however, that
shifting and differentiation decrease the number of valid terms, while powering
does not.

Note that we conjugate all partitions at the very end of the following
procedure\dots

<<implementation: Guess - Hermite-Pade - Streams>>=
FilteredPartitionStream(options: LGOPT): Stream List Integer ==
    maxD := 1+maxDerivative(options)$GOPT0
    maxP := maxPower(options)$GOPT0

    if maxD > 0 and maxP > -1 then
        s := partitions(maxD, maxP)$PartitionsAndPermutations
    else
        s1: Stream Integer := generate(inc, 1)$Stream(Integer)
        s2: Stream Stream List Integer 
           := map(partitions(#1)$PartitionsAndPermutations, s1)
                 $StreamFunctions2(Integer, Stream List Integer)
        s3: Stream List Integer 
           := concat(s2)$StreamFunctions1(List Integer)

--        s := cons([],
--                  select(((maxD = 0) or (first #1 <= maxD)) _
--                     and ((maxP = -1) or (# #1 <= maxP)), s3))

        s := cons([],
                  select(((maxD = 0) or (# #1 <= maxD)) _
                     and ((maxP = -1) or (first #1 <= maxP)), s3))

    s := conjugates(s)$PartitionsAndPermutations
    if homogeneous(options)$GOPT0 then rest s else s

-- for functions
ADEguessStream(f: UFPSF, partitions: Stream List Integer, 
               DS: DIFFSPECS, D1: DIFFSPEC1): Stream UFPSF ==
    map(termAsUFPSF(f, #1, DS, D1), partitions)
       $StreamFunctions2(List Integer, UFPSF)

-- for coefficients, i.e., using the Hadamard product
ADEguessStream2(f: UFPSF, partitions: Stream List Integer, 
                DS: DIFFSPECS, D1: DIFFSPEC1): Stream UFPSF ==
    map(termAsUFPSF2(f, #1, DS, D1), partitions)
       $StreamFunctions2(List Integer, UFPSF)

@
%$

The entries of the following stream indicate how many terms we loose when
applying one of the power and shift or differentiation operators. More
precisely, the $n$\textsuperscript{th} entry of the stream takes into account
all partitions up to index $n$. Thus, the entries of the stream are weakly
increasing.

<<implementation: Guess - Hermite-Pade - Streams>>=       
ADEdegreeStream(partitions: Stream List Integer): Stream NNI ==
    scan(0, max((if empty? #1 then 0 else (first #1 - 1)::NNI), #2),
         partitions)$StreamFunctions2(List Integer, NNI)

ADEtestStream(f: UFPSSUPF, partitions: Stream List Integer, 
              DSF: DIFFSPECSF, D1F: DIFFSPEC1F): Stream UFPSSUPF ==
    map(termAsUFPSSUPF(f, #1, DSF, D1F), partitions)
       $StreamFunctions2(List Integer, UFPSSUPF)

ADEtestStream2(f: UFPSSUPF, partitions: Stream List Integer, 
              DSF: DIFFSPECSF, D1F: DIFFSPEC1F): Stream UFPSSUPF ==
    map(termAsUFPSSUPF2(f, #1, DSF, D1F), partitions)
       $StreamFunctions2(List Integer, UFPSSUPF)

ADEEXPRRStream(f: EXPRR, xx: Symbol, partitions: Stream List Integer, 
               DX: DIFFSPECX, D1X: DIFFSPEC1X): Stream EXPRR ==
    map(termAsEXPRR(f, xx, #1, DX, D1X), partitions)
       $StreamFunctions2(List Integer, EXPRR)

@
\subsubsection{Operators}

We need to define operators that transform series for differentiation and
shifting. We also provide operators for $q$-analogs. The functionality
corresponding to powering and taking the Hadamard product if provided by the
streams, see Section~\ref{sec:streams}.

We have to provide each operator in three versions: 
\begin{itemize}
\item for expressions,
\item for series, and
\item for series with an additional transcendental element.
\end{itemize}

The latter makes it possible to detect lazily whether a computed coefficient of
a series is valid or not.

Furthermore, we have to define for each operator how to extract the coefficient
of $x^k$ in $z^l f(x)$, where multiplication with $z$ is defined depending on
the operator. Again, it is necessary to provide this functionality for
expressions, series and series with a transcendental element.

Finally, we define a function that returns the diagonal elements $c_{k,k}$ in
the expansion $\langle x^k\rangle z f(x) = \sum_{i=0}^k c_{k,i} \langle x^i\rangle f(x)$,
and an expression that represents the constant term for the inhomogeneous case.

\paragraph{The Differentiation Setting} In this setting, we have $z f(x) := x
f(x)$. 

<<implementation: Guess - Hermite-Pade - Operators>>=
diffDX: DIFFSPECX
diffDX(expr, x, n) == D(expr, x, n)

diffDS: DIFFSPECS
diffDS(s, n) == D(s, n)

diffDSF: DIFFSPECSF
diffDSF(s, n) == 
-- I have to help the compiler here a little to choose the right signature...
    if SUP F has _*: (NonNegativeInteger, SUP F) -> SUP F
    then D(s, n)

@

The next three functions extract the coefficient of $x^k$ in $z^l f(x)$. Only,
for expressions, we rather need $\sum_{k\ge0} \langle x^k\rangle z^l f(x)$,
i.e., the function itself, which is by definition equal to $x^l f(x)$.

<<implementation: Guess - Hermite-Pade - Operators>>=
diffAX: DIFFSPECAX
diffAX(l: NNI, x: Symbol, f: EXPRR): EXPRR ==
    (x::EXPRR)**l * f

diffA: DIFFSPECA
diffA(k: NNI, l: NNI, f: SUP S): S ==
    DiffAction(k, l, f)$FFFG(S, SUP S)

diffAF: DIFFSPECAF
diffAF(k: NNI, l: NNI, f: UFPSSUPF): SUP F ==
    DiffAction(k, l, f)$FFFG(SUP F, UFPSSUPF)

diffC: DIFFSPECC
diffC(total: NNI): List S == DiffC(total)$FFFG(S, SUP S)

diff1X: DIFFSPEC1X
diff1X(x: Symbol)== 1$EXPRR

diffHP options == 
    if displayAsGF(options)$GOPT0 then
        partitions := FilteredPartitionStream options
        [ADEguessStream(#1, partitions, diffDS, 1$UFPSF), _
         ADEdegreeStream partitions, _
         ADEtestStream(#1, partitions, diffDSF, 1$UFPSSUPF), _
         ADEEXPRRStream(#1, #2, partitions, diffDX, diff1X), _
         diffA, diffAF, diffAX, diffC]$HPSPEC
    else
        error "Guess: guessADE supports only displayAsGF"

@

\paragraph{$q$-dilation} In this setting, we also have $z f(x) := x f(x)$,
therefore we can reuse some of the functions of the previous paragraph.
Differentiation is defined by $D_q f(x, q) = f(qx, q)$.

<<implementation: Guess - Hermite-Pade - Operators>>=
if F has RetractableTo Symbol and S has RetractableTo Symbol then

    qDiffDX(q: Symbol, expr: EXPRR, x: Symbol, n: NonNegativeInteger): EXPRR ==
        eval(expr, x::EXPRR, (q::EXPRR)**n*x::EXPRR)

    qDiffDS(q: Symbol, s: UFPSF, n: NonNegativeInteger): UFPSF ==
        multiplyCoefficients((q::F)**((n*#1)::NonNegativeInteger), s)

    qDiffDSF(q: Symbol, s: UFPSSUPF, n: NonNegativeInteger): UFPSSUPF ==
        multiplyCoefficients((q::F::SUP F)**((n*#1)::NonNegativeInteger), s)

    diffHP(q: Symbol): (LGOPT -> HPSPEC) == 
        if displayAsGF(#1)$GOPT0 then
            partitions := FilteredPartitionStream #1
            [ADEguessStream(#1, partitions, qDiffDS(q, #1, #2), 1$UFPSF), _
             repeating([0$NNI])$Stream(NNI), _
             ADEtestStream(#1, partitions, qDiffDSF(q, #1, #2), 1$UFPSSUPF), _
             ADEEXPRRStream(#1, #2, partitions, qDiffDX(q, #1, #2, #3), diff1X), _
             diffA, diffAF, diffAX, diffC]$HPSPEC
        else
            error "Guess: guessADE supports only displayAsGF"

@

\paragraph{Shifting} The shift operator transforms a sequence $u(k)$ into
$u(k+1)$. We also provide operators [[ShiftSXGF]], [[ShiftAXGF]] that act on
the power series, as long as no powering is involved. In this case, shifting
transforms $f(x)$ into $\frac{f(x)-f(0)}{x}$.

Multiplication with $z$ transforms the coefficients $u(n)$ of the series into
$z u(n) := n u(n)$. The description in terms of power series is given by
$xDf(x)$.

% The coefficients of $x^n$ are $1, f(n), f(n+1), f(n)^2, f(n)f(n+1),\dots$
% What does this remark mean?
<<implementation: Guess - Hermite-Pade - Operators>>=
ShiftSX(expr: EXPRR, x: Symbol, n: NNI): EXPRR == 
    eval(expr, x::EXPRR, x::EXPRR+n::EXPRR)

ShiftSXGF(expr: EXPRR, x: Symbol, n: NNI): EXPRR == 
    if zero? n then expr
    else
        l := [eval(D(expr, x, i)/factorial(i)::EXPRR, x::EXPRR, 0$EXPRR)_
              *(x::EXPRR)**i for i in 0..n-1]
        (expr-reduce(_+, l))/(x::EXPRR**n)

ShiftSS(s:UFPSF, n:NNI): UFPSF == 
    ((quoByVar #1)**n)$MappingPackage1(UFPSF) (s)

ShiftSF(s:UFPSSUPF, n: NNI):UFPSSUPF == 
    ((quoByVar #1)**n)$MappingPackage1(UFPSSUPF) (s)

@
%$

As before, next three functions extract the coefficient of $x^k$ in $z^l f(x)$.

<<implementation: Guess - Hermite-Pade - Operators>>=
ShiftAX(l: NNI, n: Symbol, f: EXPRR): EXPRR == 
    n::EXPRR**l * f

ShiftAXGF(l: NNI, x: Symbol, f: EXPRR): EXPRR == 
-- I need to help the compiler here, unfortunately
      if zero? l then f
      else
          s := [stirling2(l, i)$IntegerCombinatoricFunctions(Integer)::EXPRR _
                * (x::EXPRR)**i*D(f, x, i) for i in 1..l]
          reduce(_+, s)

ShiftA(k: NNI, l: NNI, f: SUP S): S == 
    ShiftAction(k, l, f)$FFFG(S, SUP S)

ShiftAF(k: NNI, l: NNI, f: UFPSSUPF): SUP F == 
    ShiftAction(k, l, f)$FFFG(SUP F, UFPSSUPF)

ShiftC(total: NNI): List S == 
    ShiftC(total)$FFFG(S, SUP S)

shiftHP options == 
    partitions := FilteredPartitionStream options
    if displayAsGF(options)$GOPT0 then
        if maxPower(options)$GOPT0 = 1 then
            [ADEguessStream(#1, partitions, ShiftSS, (1-monomial(1,1))**(-1)),_
             ADEdegreeStream partitions, _
             ADEtestStream(#1, partitions, ShiftSF, (1-monomial(1,1))**(-1)), _
             ADEEXPRRStream(#1, #2, partitions, ShiftSXGF, 1/(1-#1::EXPRR)), _
             ShiftA, ShiftAF, ShiftAXGF, ShiftC]$HPSPEC
       else
            error "Guess: no support for the Shift operator with displayAsGF _
                   and maxPower>1"
    else
        [ADEguessStream2(#1, partitions, ShiftSS, (1-monomial(1,1))**(-1)), _
         ADEdegreeStream partitions, _
         ADEtestStream2(#1, partitions, ShiftSF, (1-monomial(1,1))**(-1)), _
         ADEEXPRRStream(#1, #2, partitions, ShiftSX, diff1X), _
         ShiftA, ShiftAF, ShiftAX, ShiftC]$HPSPEC

@

\paragraph{$q$-Shifting} The $q$-shift also transforms $u(n)$ into $u(n+1)$,
and we can reuse the corresponding functions of the previous paragraph.
However, this time multiplication with $z$ is defined differently: the
coefficient of $x^k$ in $z u(n)$ is $q^n u(n)$. We do not define the
corresponding functionality for power series.

%The coefficients of $x^n$ are $1, f(n), f(n+1), f(n)^2, f(n)f(n+1),\dots$
% What does this remark mean?
<<implementation: Guess - Hermite-Pade - Operators>>=
if F has RetractableTo Symbol and S has RetractableTo Symbol then

    qShiftAX(q: Symbol, l: NNI, n: Symbol, f: EXPRR): EXPRR == 
        (q::EXPRR)**(l*n::EXPRR) * f

    qShiftA(q: Symbol, k: NNI, l: NNI, f: SUP S): S ==
        qShiftAction(q::S, k, l, f)$FFFG(S, SUP S)

    qShiftAF(q: Symbol, k: NNI, l: NNI, f: UFPSSUPF): SUP F ==
        qShiftAction(q::F::SUP(F), k, l, f)$FFFG(SUP F, UFPSSUPF)

    qShiftC(q: Symbol, total: NNI): List S == 
        qShiftC(q::S, total)$FFFG(S, SUP S)

    shiftHP(q: Symbol): (LGOPT -> HPSPEC) == 
        partitions := FilteredPartitionStream #1
        if displayAsGF(#1)$GOPT0 then
            error "Guess: no support for the qShift operator with displayAsGF"
        else
            [ADEguessStream2(#1, partitions, ShiftSS, _
                             (1-monomial(1,1))**(-1)), _
             ADEdegreeStream partitions, _
             ADEtestStream2(#1, partitions, ShiftSF, _
                            (1-monomial(1,1))**(-1)), _
             ADEEXPRRStream(#1, #2, partitions, ShiftSX, diff1X), _
             qShiftA(q, #1, #2, #3), qShiftAF(q, #1, #2, #3), _
             qShiftAX(q, #1, #2, #3), qShiftC(q, #1)]$HPSPEC

@
%$
\paragraph{Extend the action to polynomials}

The following operation uses the given action of $z$ on a function to multiply
a $f$ with a polynomial.

<<implementation: Guess - Hermite-Pade - Operators>>=
makeEXPRR(DAX: DIFFSPECAX, x: Symbol, p: SUP F, expr: EXPRR): EXPRR ==
    if zero? p then 0$EXPRR
    else
        coerce(leadingCoefficient p)::EXPRR * DAX(degree p, x, expr) _
        + makeEXPRR(DAX, x, reductum p, expr)

@
%$

\subsubsection{Utilities}

[[list2UFPSF]] and [[list2UFPSSUPF]] transform the list passed to the guessing
functions into a series. One might be tempted to transform the list into a
polynomial instead, but the present approach makes computing powers and
derivatives much cheaper, since, because of laziness, only coefficients that
are actually used are computed.

The second of the two procedures augments the list with a transcendental
element. This way we can easily check whether a coefficient is valid or not: if
it contains the transcendental element, it depends on data we do not have. In
other words, this transcendental element simply represents the $O(x^d)$, when
$d$ is the number of elements in the list.

<<implementation: Guess - Hermite-Pade - Utilities>>=
list2UFPSF(list: List F): UFPSF == series(list::Stream F)$UFPSF

list2UFPSSUPF(list: List F): UFPSSUPF == 
    l := [e::SUP(F) for e in list for i in 0..]::Stream SUP F
    series(l)$UFPSSUPF + monomial(monomial(1,1)$SUP(F), #list)$UFPSSUPF

@

[[SUPF2SUPSUPF]] interprets each coefficient as a univariate polynomial.

<<implementation: Guess - Hermite-Pade - Utilities>>=
SUPF2SUPSUPF(p: SUP F): SUP SUP F ==
    map(#1::SUP F, p)$SparseUnivariatePolynomialFunctions2(F, SUP F)

@

[[getListSUPF]] returns the first [[o]] elements of the stream, each truncated
after degree [[deg]]. 

<<implementation: Guess - Hermite-Pade - Utilities>>=
UFPSF2SUPF(f: UFPSF, deg: NNI): SUP F == 
    makeSUP univariatePolynomial(f, deg)

getListSUPF(s: Stream UFPSF, o: NNI, deg: NNI): List SUP F ==
    map(UFPSF2SUPF(#1, deg), entries complete first(s, o))
       $ListFunctions2(UFPSF, SUP F)

S2EXPRR(s: S): EXPRR ==
    if F is S then 
        coerce(s pretend F)@EXPRR
    else if F is Fraction S then
        coerce(s::Fraction(S))@EXPRR
    else error "Type parameter F should be either equal to S or equal _
                to Fraction S"

<<implementation: Guess - guessInterpolate>>
<<implementation: Guess - guessInterpolate2>>
<<implementation: Guess - testInterpolant>>
@
%$

[[guessInterpolate]] calls the appropriate [[generalInterpolation]] from
[[FFFG]], for one vector of degrees, namely [[eta]].

<<implementation: Guess - guessInterpolate>>=
guessInterpolate(guessList: List SUP F, eta: List NNI, D: HPSPEC)
                : Matrix SUP S ==
    if F is S then 
        vguessList: Vector SUP S := vector(guessList pretend List(SUP(S)))
        generalInterpolation((D.C)(reduce(_+, eta)), D.A, 
                             vguessList, eta)$FFFG(S, SUP S)
    else if F is Fraction S then
        vguessListF: Vector SUP F := vector(guessList)
        generalInterpolation((D.C)(reduce(_+, eta)), D.A, 
                             vguessListF, eta)$FFFGF(S, SUP S, SUP F)

    else error "Type parameter F should be either equal to S or equal _
                to Fraction S"
@

[[guessInterpolate2]] calls the appropriate [[generalInterpolation]] from
[[FFFG]], for all degree vectors with given [[sumEta]] and [[maxEta]].

<<implementation: Guess - guessInterpolate2>>=
guessInterpolate2(guessList: List SUP F, 
                  sumEta: NNI, maxEta: NNI, 
                  D: HPSPEC): Stream Matrix SUP S ==
    if F is S then 
        vguessList: Vector SUP S := vector(guessList pretend List(SUP(S)))
        generalInterpolation((D.C)(sumEta), D.A, 
                             vguessList, sumEta, maxEta)
                            $FFFG(S, SUP S)
    else if F is Fraction S then
        vguessListF: Vector SUP F := vector(guessList)
        generalInterpolation((D.C)(sumEta), D.A, 
                             vguessListF, sumEta, maxEta)
                            $FFFGF(S, SUP S, SUP F)

    else error "Type parameter F should be either equal to S or equal _
                to Fraction S"
@

[[testInterpolant]] checks whether p is really a solution.
<<implementation: Guess - testInterpolant>>=
testInterpolant(resi: List SUP S, 
                list: List F,
                testList: List UFPSSUPF, 
                exprList: List EXPRR,
                initials: List EXPRR,
                guessDegree: NNI,
                D: HPSPEC, 
                dummy: Symbol, op: BasicOperator, options: LGOPT)
               : Union("failed", Record(function: EXPRR, order: NNI)) ==
@

First we make sure it is not a solution we should have found already. Note that
we cannot check this if [[maxDegree]] is set, in which case some initial
solutions may have been overlooked.

<<implementation: Guess - testInterpolant>>=
    ((maxDegree(options)$GOPT0 = -1) and 
     (allDegrees(options)$GOPT0 = false) and 
     zero?(last resi)) 
     => return "failed"
@

Then we check all the coefficients that should be valid.  We want the zero
solution only, if the function is really zero. Without this test, every
sequence ending with zero is interpreted as the zero sequence, since the factor
in front of the only non-vanishing term can cancel everything else.

<<implementation: Guess - testInterpolant>>=
    nonZeroCoefficient: Integer := 0

    for i in 1..#resi repeat
        if not zero? resi.i then
            if zero? nonZeroCoefficient then
                nonZeroCoefficient := i
            else 
                nonZeroCoefficient := 0
                break
@

We set [[nonZeroCoefficient]] to the only non zero coefficient or, if there are
several, it is $0$. It should not happen that all coefficients in [[resi]]
vanish.
\begin{verbatim}
  Check that not all coefficients in [[resi]] can vanish simultaneously.
\end{verbatim}

<<implementation: Guess - testInterpolant>>=
    if not zero? nonZeroCoefficient then
        (freeOf?(exprList.nonZeroCoefficient, name op)) => return "failed"

        for e in list repeat
            if not zero? e then return "failed"
@

We first deal with the case that there is only one non-vanishing coefficient in
[[resi]]. If the only expression in [[exprList]] whose coefficient does not
vanish does not contain the name of the generating function, or if there is a
non-zero term in [[list]], we reject the proposed solution.

<<implementation: Guess - testInterpolant>>=
    else
        resiSUPF := map(SUPF2SUPSUPF SUPS2SUPF #1, resi)
                       $ListFunctions2(SUP S, SUP SUP F)

        iterate? := true;
        for d in guessDegree+1.. repeat
            c: SUP F := generalCoefficient(D.AF, vector testList, 
                                           d, vector resiSUPF)
                                          $FFFG(SUP F, UFPSSUPF)

            if not zero? c then 
                iterate? := ground? c
                break

        iterate? => return "failed"
@

Here we check for each degree [[d]] larger than [[guessDegree]] whether the
proposed linear combination vanishes. When the first coefficient that does not
vanish contains the transcendental element we accept the linear combination as
a solution.

Finally, it seems that we have found a solution. Now we cancel the greatest
common divisor of the equation. Note that this may take quite some time, it
seems to be quicker to check [[generalCoefficient]] with the original [[resi]].

If [[S]] is a [[Field]], the [[gcd]] will always be $1$.  Thus, in this case we
make the result monic.

<<implementation: Guess - testInterpolant>>=
    g: SUP S
    if S has Field 
    then g := leadingCoefficient(find(not zero? #1, reverse resi)::SUP(S))::SUP(S)
    else g := gcd resi
    resiF := map(SUPS2SUPF((#1 exquo g)::SUP(S)), resi)
                $ListFunctions2(SUP S, SUP F)


    if debug(options)$GOPT0 then 
        output(hconcat("trying possible solution ", resiF::OutputForm))
              $OutputPackage

-- transform each term into an expression

    ex: List EXPRR := [makeEXPRR(D.AX, dummy, p, e) _
                       for p in resiF for e in exprList]

-- transform the list of expressions into a sum of expressions

    res: EXPRR
    if displayAsGF(options)$GOPT0 then 
        res := evalADE(op, dummy, variableName(options)$GOPT0::EXPRR, 
                       indexName(options)$GOPT0::EXPRR,
                       numerator reduce(_+, ex), 
                       reverse initials)
                      $RecurrenceOperator(Integer, EXPRR)
        ord: NNI := 0
-- FIXME: checkResult doesn't really work yet for generating functions
    else 
        res := evalRec(op, dummy, indexName(options)$GOPT0::EXPRR, 
                       indexName(options)$GOPT0::EXPRR,
                       numerator reduce(_+, ex), 
                       reverse initials)
                      $RecurrenceOperator(Integer, EXPRR)
        ord: NNI := checkResult(res, indexName(options)$GOPT0, _
                                #list, list, options)


    [res, ord]$Record(function: EXPRR, order: NNI)

@

\subsubsection{The main routine}

The following is the main guessing routine, called by all others -- except
[[guessExpRat]].

<<implementation: Guess - guessHPaux>>=
guessHPaux(list: List F, D: HPSPEC, options: LGOPT): GUESSRESULT ==
    reslist: GUESSRESULT := []

    listDegree := #list-1-safety(options)$GOPT0
    if listDegree < 0 then return reslist
@
%$

\sloppypar We do as if we knew only the coefficients up to and including degree
[[listDegree-safety]]. Thus, if we have less elements of the sequence than
[[safety]], there remain no elements for guessing.  Originally we demanded to
have at least two elements for guessing.  However, we want to be able to induce
from $[c,c]$ that the function equals $c$ with [[safety]] one. This is
important if we apply, for example, [[guessRat]] recursively. In this case,
[[listDegree]] equals zero.

<<implementation: Guess - guessHPaux>>=
    a := functionName(options)$GOPT0
    op := operator a
    x := variableName(options)$GOPT0
    dummy := new$Symbol

    initials: List EXPRR := [coerce(e)@EXPRR for e in list]

@
%$

We need to create several streams. Let $P$ be the univariate power series whose
first few elements are given by [[list]]. As an example, consider the
differentiation setting. In this case, the elements of [[guessS]] consist of
$P$ differentiated and taken to some power. The elements of [[degreeS]] are
integers, that tell us how many terms less than in [[list]] are valid in the
corresponding element of [[guessS]]. The elements of [[testS]] are very similar
to those of [[guessS]], with the difference that they are derived from $P$ with
an transcendental element added, which corresponds to $O(x^d)$. Finally, the
elements of [[exprS]] contain representations of the transformations applied to
$P$ as expressions.

\begin{verbatim}
  I am not sure whether it is better to get rid of denominators in [[list]]
  here or, as I currently do it, only in [[generalInterpolation$FFFG]]. %$
  If we clear them at here, we cannot take advantage of factors that may appear
  only after differentiating or powering.
\end{verbatim}


<<implementation: Guess - guessHPaux>>=
    guessS  := (D.guessStream)(list2UFPSF list)
    degreeS := D.degreeStream
    testS   := (D.testStream)(list2UFPSSUPF list)
    exprS   := (D.exprStream)(op(dummy::EXPRR)::EXPRR, dummy)
@

We call the number of terms of the linear combination its \emph{order}.  We
consider linear combinations of at least two terms, since otherwise the
function would have to vanish identically\dots

When proceeding in the stream [[guessS]], it may happen that we loose valid
terms. For example, when trying to find a linear ordinary differential
equation, we are looking for a linear combination of $f, f^\prime,
f^{\prime\prime}, \dots$. Suppose [[listDegree]] equals $2$, i.e. we have
\begin{verbatim}
  f                &= l_0 + l_1 x + l_2 x^2\\
  f^\prime         &= l_1 + 2l_2 x\\
  f^{\prime\prime} &= 2l_2.    
\end{verbatim}
Thus, each time we differentiate the series, we loose one term for guessing.
Therefore, we cannot use the coefficient of $x^2$ of $f^{\prime\prime}$ for
generating a linear combination. [[guessDegree]] contains the degree up to
which all the generated series are correct, taking into account [[safety]].

<<implementation: Guess - guessHPaux>>=
    iterate?: Boolean := false -- this is necessary because the compiler
                               -- doesn't understand => "iterate" properly
                               -- the latter just leaves the current block, it
                               -- seems 
    for o in 2.. repeat
        empty? rest(guessS, (o-1)::NNI) => break
        guessDegree: Integer := listDegree-(degreeS.o)::Integer
        guessDegree < 0 => break
        if debug(options)$GOPT0 then 
            output(hconcat("Trying order ", o::OutputForm))$OutputPackage
            output(hconcat("guessDegree is ", guessDegree::OutputForm))
                  $OutputPackage
@ 
%$"

We now have to distinguish between the case where we try all combination of
degrees and the case where we try only an (nearly) evenly distributed vector of
degrees.

In the first case, [[guessInterpolate2]] is going to look at all degree vectors
with [[o]] elements with total degree [[guessDegree+1]].  We give up as soon as
the order [[o]] is greater than the number of available terms plus one. In the
extreme case, i.e., when [[o=guessDegree+2]], we allow for example constant
coefficients for all terms of the linear combination. It seems that it is a bit
arbitrary at what point we stop, however, we would like to be consistent with
the evenly distributed case.

<<implementation: Guess - guessHPaux>>=
        if allDegrees(options)$GOPT0 then
            (o > guessDegree+2) => return reslist

            maxEta: Integer := 1+maxDegree(options)$GOPT0
            if maxEta = 0 
            then maxEta := guessDegree+1
        else
@

In the second case, we first compute the number of parameters available for
determining the coefficient polynomials. We have to take care of the fact, that
HermitePade produces solutions with sum of degrees being one more than the sum
of elements in [[eta]].

<<implementation: Guess - guessHPaux>>=
            maxParams := divide(guessDegree::NNI+1, o)
            if debug(options)$GOPT0 
            then output(hconcat("maxParams: ", maxParams::OutputForm))
                       $OutputPackage
@

If we do not have enough parameters, we give up. We allow for at most one zero
entry in the degree vector, because then there is one column that allows at
least a constant term in each entry.

<<implementation: Guess - guessHPaux>>=
            if maxParams.quotient = 0 and maxParams.remainder < o-1 
            then return reslist
@

If [[maxDegree]] is set, we skip the first few partitions, unless we cannot
increase the order anymore.
\begin{verbatim}
  I have no satisfactory way to determine whether we can increase the order or
  not.
\end{verbatim}

<<implementation: Guess - guessHPaux>>=
            if ((maxDegree(options)$GOPT0 ~= -1) and
                (maxDegree(options)$GOPT0 < maxParams.quotient)) and
                not (empty? rest(guessS, o) or
                     ((newGuessDegree := listDegree-(degreeS.(o+1))::Integer)
                          < 0) or
                      (((newMaxParams := divide(newGuessDegree::NNI+1, o+1))
                          .quotient = 0) and
                       (newMaxParams.remainder < o)))
            then iterate? := true
            else if ((maxDegree(options)$GOPT0 ~= -1) and
                     (maxParams.quotient > maxDegree(options)$GOPT0))
                 then
                     guessDegree := o*(1+maxDegree(options)$GOPT0)-2
                     eta: List NNI
                         := [(if i < o    _
                               then maxDegree(options)$GOPT0 + 1   _
                               else maxDegree(options)$GOPT0)::NNI _
                             for i in 1..o]
                 else eta: List NNI
                          := [(if i <= maxParams.remainder   _
                               then maxParams.quotient + 1   _
                               else maxParams.quotient)::NNI for i in 1..o]
@

We distribute the parameters as evenly as possible.  Is it better to have
higher degrees at the end or at the beginning?

It remains to prepare [[guessList]], which is the list of [[o]] power series
polynomials truncated after degree [[guessDegree]]. Then we can call
HermitePade.

\begin{verbatim}
  [[maxDegree]] should be handled differently, maybe: we should only pass as
  many coefficients to [[FFFG]] as [[maxDegree]] implies! That is, if we cannot
  increase the order anymore, we should decrease [[guessDegree]] to %
  $o\cdot [[maxDegree]] - 2$ and set [[eta]] accordingly.  I might have to take
  care of [[allDegrees]], too.
\end{verbatim}

<<implementation: Guess - guessHPaux>>=
        if iterate? 
        then 
            iterate? := false
            if debug(options)$GOPT0 then output("iterating")$OutputPackage
        else 
            guessList: List SUP F    := getListSUPF(guessS, o, guessDegree::NNI)
            testList:  List UFPSSUPF := entries complete first(testS, o)
            exprList:  List EXPRR    := entries complete first(exprS, o)

            if debug(options)$GOPT0 then 
                output("The list of expressions is")$OutputPackage
                output(exprList::OutputForm)$OutputPackage

            if allDegrees(options)$GOPT0 then
                MS: Stream Matrix SUP S := guessInterpolate2(guessList, 
                                                             guessDegree::NNI+1,
                                                             maxEta::NNI, D)
                repeat
                    (empty? MS) => break
                    M := first MS

                    for i in 1..o repeat
                        res := testInterpolant(entries column(M, i), 
                                               list,
                                               testList, 
                                               exprList,
                                               initials,
                                               guessDegree::NNI, 
                                               D, dummy, op, options)

                        (res case "failed") => "iterate"

                        if not member?(res, reslist) 
                        then reslist := cons(res, reslist)

                        if one(options)$GOPT0 then return reslist 

                    MS := rest MS
            else
                M: Matrix SUP S := guessInterpolate(guessList, eta, D)

                for i in 1..o repeat
                    res := testInterpolant(entries column(M, i), 
                                           list,
                                           testList, 
                                           exprList,
                                           initials,
                                           guessDegree::NNI, 
                                           D, dummy, op, options)
                    (res case "failed") => "iterate"

                    if not member?(res, reslist) 
                    then reslist := cons(res, reslist)

                    if one(options)$GOPT0 then return reslist 

    reslist

@

\begin{verbatim}
  The duplicated block at the end should really go into [[testInterpolant]], I
  guess. Furthermore, it would be better to remove duplicates already there.
\end{verbatim}

\subsubsection{Specialisations}

For convenience we provide some specialisations that cover the most common
situations.

\paragraph{generating functions}

<<implementation: Guess - guessHP>>=
guessHP(D: LGOPT -> HPSPEC): GUESSER == guessHPaux(#1, D #2, #2)

guessADE(list: List F, options: LGOPT): GUESSRESULT == 
    opts: LGOPT := cons(displayAsGF(true)$GuessOption, options)
    guessHPaux(list, diffHP opts, opts)

guessADE(list: List F): GUESSRESULT == guessADE(list, [])

guessAlg(list: List F, options: LGOPT) == 
    guessADE(list, cons(maxDerivative(0)$GuessOption, options))

guessAlg(list: List F): GUESSRESULT == guessAlg(list, [])

guessHolo(list: List F, options: LGOPT): GUESSRESULT ==
    guessADE(list, cons(maxPower(1)$GuessOption, options))

guessHolo(list: List F): GUESSRESULT == guessHolo(list, [])

guessPade(list: List F, options: LGOPT): GUESSRESULT ==
    opts := append(options, [maxDerivative(0)$GuessOption, 
                             maxPower(1)$GuessOption, 
                             allDegrees(true)$GuessOption])
    guessADE(list, opts)

guessPade(list: List F): GUESSRESULT == guessPade(list, [])
@

\paragraph{$q$-generating functions}

<<implementation: Guess - guessHP>>=
if F has RetractableTo Symbol and S has RetractableTo Symbol then

    guessADE(q: Symbol): GUESSER ==
        opts: LGOPT := cons(displayAsGF(true)$GuessOption, #2)
        guessHPaux(#1, (diffHP q)(opts), opts)

@
%$

\paragraph{coefficients}

<<implementation: Guess - guessHP>>=
guessRec(list: List F, options: LGOPT): GUESSRESULT == 
      opts: LGOPT := cons(displayAsGF(false)$GuessOption, options)
      guessHPaux(list, shiftHP opts, opts)

guessRec(list: List F): GUESSRESULT == guessRec(list, [])

guessPRec(list: List F, options: LGOPT): GUESSRESULT ==
      guessRec(list, cons(maxPower(1)$GuessOption, options))

guessPRec(list: List F): GUESSRESULT == guessPRec(list, [])

guessRat(list: List F, options: LGOPT): GUESSRESULT ==
      opts := append(options, [maxShift(0)$GuessOption, 
                               maxPower(1)$GuessOption, 
                               allDegrees(true)$GuessOption])
      guessRec(list, opts)

guessRat(list: List F): GUESSRESULT == guessRat(list, [])

@
%$

\paragraph{$q$-coefficients}

<<implementation: Guess - guessHP>>=
if F has RetractableTo Symbol and S has RetractableTo Symbol then

    guessRec(q: Symbol): GUESSER ==
        opts: LGOPT := cons(displayAsGF(false)$GuessOption, #2)
        guessHPaux(#1, (shiftHP q)(opts), opts)

    guessPRec(q: Symbol): GUESSER ==
        opts: LGOPT := append([displayAsGF(false)$GuessOption, 
                               maxPower(1)$GuessOption], #2)
        guessHPaux(#1, (shiftHP q)(opts), opts)

    guessRat(q: Symbol): GUESSER ==
        opts := append(#2, [displayAsGF(false)$GuessOption, 
                            maxShift(0)$GuessOption, 
                            maxPower(1)$GuessOption, 
                            allDegrees(true)$GuessOption])
        guessHPaux(#1, (shiftHP q)(opts), opts)

@
%$

\subsection{[[guess]] -- applying operators recursively}

The main observation made by Christian Krattenthaler in designing his program
Rate is the following: it occurs frequently that although a sequence of
numbers is not generated by a rational function, the sequence of successive
quotients is.

We slightly extend upon this idea, and apply recursively one or both of the two
following operators:
\begin{description}
\item[$\Delta_n$] the differencing operator, transforming $f(n)$ into
  $f(n)-f(n-1)$, and
\item[$Q_n$] the operator that transforms $f(n)$ into $f(n)/f(n-1)$.
\end{description}

<<implementation: Guess - guess>>=
guess(list: List F, guessers: List GUESSER, ops: List Symbol, 
      options: LGOPT): GUESSRESULT ==
    maxLevel := maxLevel(options)$GOPT0
    xx := indexName(options)$GOPT0
    if debug(options)$GOPT0 then
        output(hconcat("guessing level ", maxLevel::OutputForm))
              $OutputPackage
        output(hconcat("guessing ", list::OutputForm))$OutputPackage
    res: GUESSRESULT := []
    len := #list :: PositiveInteger
    if len <= 1 then return res

    for guesser in guessers repeat
        res := append(guesser(list, options), res)

        if debug(options)$GOPT0 then
            output(hconcat("res ", res::OutputForm))$OutputPackage

        if one(options)$GOPT0 and not empty? res then return res

    if (maxLevel = 0) then return res

    if member?('guessProduct, ops) and not member?(0$F, list) then
        prodList: List F := [(list.(i+1))/(list.i) for i in 1..(len-1)]

        if not every?(one?, prodList) then
            var: Symbol := subscript('p, [len::OutputForm])
            prodGuess := 
                [[coerce(list.(guess.order+1)) 
                  * product(guess.function, _
                            equation(var, _
                                     (guess.order)::EXPRR..xx::EXPRR-1)), _
                  guess.order] _
                 for guess in guess(prodList, guessers, ops,  
                                    append([indexName(var)$GuessOption,
                                            maxLevel(maxLevel-1)
                                                    $GuessOption],
                                           options))$%]

            if debug(options)$GOPT0 then
                output(hconcat("prodGuess "::OutputForm, 
                               prodGuess::OutputForm))
                      $OutputPackage

            for guess in prodGuess 
                    | not any?(guess.function = #1.function, res) repeat
                res := cons(guess, res)

    if one(options)$GOPT0 and not empty? res then return res

    if member?('guessSum, ops) then
        sumList: List F := [(list.(i+1))-(list.i) for i in 1..(len-1)]

        if not every?(#1=sumList.1, sumList) then
            var: Symbol := subscript('s, [len::OutputForm])
            sumGuess := 
                [[coerce(list.(guess.order+1)) _
                  + summation(guess.function, _
                              equation(var, _
                                       (guess.order)::EXPRR..xx::EXPRR-1)),_
                  guess.order] _
                 for guess in guess(sumList, guessers, ops,
                                    append([indexName(var)$GuessOption,
                                            maxLevel(maxLevel-1)
                                                    $GuessOption],
                                           options))$%]

            for guess in sumGuess 
                    | not any?(guess.function = #1.function, res) repeat
                res := cons(guess, res)

    res

guess(list: List F): GUESSRESULT == 
    guess(list, [guessADE$%, guessRec$%], ['guessProduct, 'guessSum], [])

guess(list: List F, options: LGOPT): GUESSRESULT == 
    guess(list, [guessADE$%, guessRat$%], ['guessProduct, 'guessSum], 
          options)

guess(list: List F, guessers: List GUESSER, ops: List Symbol)
     : GUESSRESULT == 
    guess(list, guessers, ops, [])

@
<<GUESS.dotabb>>=
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"RECOP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RECOP"]
"GUESS" -> "RECOP"  

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSAN GuessAlgebraicNumber}
\pagehead{GuessAlgebraicNumber}{GUESSAN}
\pagepic{ps/v104guessalgebraicnumber.ps}{GUESSAN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSAN GuessAlgebraicNumber>>=
)abbrev package GUESSAN GuessAlgebraicNumber
++ Description:
++ This package exports guessing of sequences of rational functions
GuessAlgebraicNumber() == Guess(AlgebraicNumber, AlgebraicNumber, 
                           Expression Integer, 
                           AlgebraicNumber,
                           id$MappingPackage1(AlgebraicNumber), 
                           coerce$Expression(Integer))

@
<<GUESSAN.dotabb>>=
"GUESSAN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSAN"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSAN" -> "GUESS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSF GuessFinite}
\pagehead{GuessFinite}{GUESSF}
\pagepic{ps/v104guessfinite.ps}{GUESSF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSF GuessFinite>>=
)abbrev package GUESSF GuessFinite
++ Description:
++ This package exports guessing of sequences of numbers in a finite field
GuessFinite(F:Join(FiniteFieldCategory, ConvertibleTo Integer)) ==
  Guess(F, F, Expression Integer, Integer, coerce$F,
        F2EXPRR$GuessFiniteFunctions(F))

@
<<GUESSF.dotabb>>=
"GUESSF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSF"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSF1" -> "GUESS" 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSF1 GuessFiniteFunctions}
\pagehead{GuessFiniteFunctions}{GUESSF1}
\pagepic{ps/v104guessfinitefunctions.ps}{GUESSF1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSF1 GuessFiniteFunctions>>=
)abbrev package GUESSF1 GuessFiniteFunctions
++ Description:
++ This package exports guessing of sequences of numbers in a finite field
GuessFiniteFunctions(F:Join(FiniteFieldCategory, ConvertibleTo Integer)):
  Exports == Implementation where

    EXPRR ==> Expression Integer

    Exports == with

      F2EXPRR: F -> EXPRR

    Implementation == add

      F2EXPRR(p: F): EXPRR == convert(p)@Integer::EXPRR

@
<<GUESSF1.dotabb>>=
"GUESSF1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSF1"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSF1" -> "GUESS" 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSINT GuessInteger}
\pagehead{GuessInteger}{GUESSINT}
\pagepic{ps/v104guessinteger.ps}{GUESSINT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSINT GuessInteger>>=
-- concerning algebraic functions, it may make sense to look at A.J.van der
-- Poorten, Power Series Representing Algebraic Functions, Section 6.
)abbrev package GUESSINT GuessInteger
++ Description:
++ This package exports guessing of sequences of rational numbers
GuessInteger() == Guess(Fraction Integer, Integer, Expression Integer, 
                     Fraction Integer,
                     id$MappingPackage1(Fraction Integer), 
                     coerce$Expression(Integer))

@
<<GUESSINT.dotabb>>=
"GUESSINT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSINT"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSINT" -> "GUESS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GOPT0 GuessOptionFunctions0}
\pagehead{GuessOptionFunctions0}{GOPT0}
\pagepic{ps/v104guessoptionfunctions0.ps}{GOPT0}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GOPT0 GuessOptionFunctions0>>=
)abbrev package GOPT0 GuessOptionFunctions0
++ Author: Martin Rubey 
++ Description: GuessOptionFunctions0 provides operations that extract the
++ values of options for \spadtype{Guess}.
GuessOptionFunctions0(): Exports == Implementation where 

  LGOPT ==> List GuessOption

  Exports == SetCategory with

    maxLevel: LGOPT -> Integer
      ++ maxLevel returns the specified maxLevel or -1 as default.

    maxPower: LGOPT -> Integer
      ++ maxPower returns the specified maxPower or -1 as default.

    maxDerivative: LGOPT -> Integer
      ++ maxDerivative returns the specified maxDerivative or -1 as default.

    maxShift: LGOPT -> Integer
      ++ maxShift returns the specified maxShift or -1 as default.

    maxDegree: LGOPT -> Integer
      ++ maxDegree returns the specified maxDegree or -1 as default.

    allDegrees: LGOPT -> Boolean
      ++ allDegrees returns whether all possibilities of the degree vector
      ++ should be tried, the default being false.

    safety: LGOPT -> NonNegativeInteger
      ++ safety returns the specified safety or 1 as default.

    one: LGOPT -> Boolean
      ++ one returns whether we need only one solution, default being true.

    homogeneous: LGOPT -> Boolean
      ++ homogeneous returns whether we allow only homogeneous algebraic
      ++ differential equations, default being false

    functionName: LGOPT -> Symbol
      ++ functionName returns the name of the function given by the algebraic
      ++ differential equation, default being f

    variableName: LGOPT -> Symbol
      ++ variableName returns the name of the variable used in by the
      ++ algebraic differential equation, default being x

    indexName: LGOPT -> Symbol
      ++ indexName returns the name of the index variable used for the
      ++ formulas, default being n

    displayAsGF: LGOPT -> Boolean
      ++ displayAsGF specifies whether the result is a generating function
      ++ or a recurrence. This option should not be set by the user, but rather
      ++ by the HP-specification, therefore, there is no default.

    debug: LGOPT -> Boolean
      ++ debug returns whether we want additional output on the progress,
      ++ default being false

  Implementation == add

    maxLevel l ==
      if (opt := option(l, "maxLevel" :: Symbol)) case "failed" then
        -1
      else 
        retract(opt :: Any)$AnyFunctions1(Integer)

    maxDerivative l ==
      if (opt := option(l, "maxDerivative" :: Symbol)) case "failed" then
        -1
      else 
        retract(opt :: Any)$AnyFunctions1(Integer)

    maxShift l == maxDerivative l

    maxDegree l ==
      if (opt := option(l, "maxDegree" :: Symbol)) case "failed" then
        -1
      else 
        retract(opt :: Any)$AnyFunctions1(Integer)

    allDegrees l ==
      if (opt := option(l, "allDegrees" :: Symbol)) case "failed" then
        false
      else 
        retract(opt :: Any)$AnyFunctions1(Boolean)

    maxPower l ==
      if (opt := option(l, "maxPower" :: Symbol)) case "failed" then
        -1
      else 
        retract(opt :: Any)$AnyFunctions1(Integer)

    safety l ==
      if (opt := option(l, "safety" :: Symbol)) case "failed" then
        1$NonNegativeInteger
      else
        retract(opt :: Any)$AnyFunctions1(Integer)::NonNegativeInteger

    one l ==
      if (opt := option(l, "one" :: Symbol)) case "failed" then
        true
      else 
        retract(opt :: Any)$AnyFunctions1(Boolean)

    debug l ==
      if (opt := option(l, "debug" :: Symbol)) case "failed" then
        false
      else 
        retract(opt :: Any)$AnyFunctions1(Boolean)

    homogeneous l ==
      if (opt := option(l, "homogeneous" :: Symbol)) case "failed" then
        false
      else 
        retract(opt :: Any)$AnyFunctions1(Boolean)

    variableName l ==
      if (opt := option(l, "variableName" :: Symbol)) case "failed" then
        "x" :: Symbol
      else 
        retract(opt :: Any)$AnyFunctions1(Symbol)

    functionName l ==
      if (opt := option(l, "functionName" :: Symbol)) case "failed" then
        "f" :: Symbol
      else 
        retract(opt :: Any)$AnyFunctions1(Symbol)

    indexName l ==
      if (opt := option(l, "indexName" :: Symbol)) case "failed" then
        "n" :: Symbol
      else 
        retract(opt :: Any)$AnyFunctions1(Symbol)

    displayAsGF l ==
      if (opt := option(l, "displayAsGF" :: Symbol)) case "failed" then
        error "GuessOption: displayAsGF not set"
      else 
        retract(opt :: Any)$AnyFunctions1(Boolean)

@
<<GOPT0.dotabb>>=
"GOPT0" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GOPT0"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"GOPT0" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSP GuessPolynomial}
\pagehead{GuessPolynomial}{GUESSP}
\pagepic{ps/v104guesspolynomial.ps}{GUESSP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSP GuessPolynomial>>=
)abbrev package GUESSP GuessPolynomial
++ Description:
++ This package exports guessing of sequences of rational functions
GuessPolynomial() == Guess(Fraction Polynomial Integer, Polynomial Integer, 
                           Expression Integer, 
                           Fraction Polynomial Integer,
                           id$MappingPackage1(Fraction Polynomial Integer), 
                           coerce$Expression(Integer))

@
<<GUESSP.dotabb>>=
"GUESSP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSP"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSP" -> "GUESS" 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GUESSUP GuessUnivariatePolynomial}
\pagehead{GuessUnivariatePolynomial}{GUESSUP}
\pagepic{ps/v104guessunivariatepolynomial.ps}{GUESSUP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GUESSUP GuessUnivariatePolynomial>>=
)abbrev package GUESSUP GuessUnivariatePolynomial
++ Description:
++ This package exports guessing of sequences of univariate rational functions
GuessUnivariatePolynomial(q: Symbol): Exports == Implementation where

    UP ==> MyUnivariatePolynomial(q, Integer)
    EXPRR ==> MyExpression(q, Integer)
    F ==> Fraction UP
    S ==> UP
    NNI ==> NonNegativeInteger
    LGOPT ==> List GuessOption
    GUESSRESULT ==> List Record(function: EXPRR, order: NNI)
    GUESSER ==> (List F, LGOPT) -> GUESSRESULT

    Exports == with

        guess: List F -> GUESSRESULT
          ++ \spad{guess l} applies recursively \spadfun{guessRec} and
          ++ \spadfun{guessADE} to the successive differences and quotients of
          ++ the list. Default options as described in
          ++ \spadtype{GuessOptionFunctions0} are used.

        guess: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guess(l, options)} applies recursively \spadfun{guessRec}
          ++ and \spadfun{guessADE} to the successive differences and quotients
          ++ of the list. The given options are used.

        guess: (List F, List GUESSER, List Symbol) -> GUESSRESULT
          ++ \spad{guess(l, guessers, ops)} applies recursively the given
          ++ guessers to the successive differences if ops contains the symbol
          ++ guessSum and quotients if ops contains the symbol guessProduct to
          ++ the list. Default options as described in
          ++ \spadtype{GuessOptionFunctions0} are used.

        guess: (List F, List GUESSER, List Symbol, LGOPT) -> GUESSRESULT
          ++ \spad{guess(l, guessers, ops)} applies recursively the given
          ++ guessers to the successive differences if ops contains the symbol
          ++ \spad{guessSum} and quotients if ops contains the symbol
          ++ \spad{guessProduct} to the list. The given options are used.

        guessExpRat: List F -> GUESSRESULT
          ++ \spad{guessExpRat l} tries to find a function of the form 
          ++ n+->(a+b n)^n r(n), where r(n) is a rational function, that fits
          ++ l. 

        guessExpRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessExpRat(l, options)} tries to find a function of the
          ++ form n+->(a+b n)^n r(n), where r(n) is a rational function, that
          ++ fits l. 

        guessBinRat: List F -> GUESSRESULT
          ++ \spad{guessBinRat(l, options)} tries to find a function of the
          ++ form n+->binomial(a+b n, n) r(n), where r(n) is a rational 
          ++ function, that fits l. 

        guessBinRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessBinRat(l, options)} tries to find a function of the
          ++ form n+->binomial(a+b n, n) r(n), where r(n) is a rational 
          ++ function, that fits l. 

--        if F has RetractableTo Symbol and S has RetractableTo Symbol then

        guessExpRat: Symbol -> GUESSER
          ++ \spad{guessExpRat q} returns a guesser that tries to find a
          ++ function of the form n+->(a+b q^n)^n r(q^n), where r(q^n) is a
          ++ q-rational function, that fits l.

        guessBinRat: Symbol -> GUESSER
          ++ \spad{guessBinRat q} returns a guesser that tries to find a
          ++ function of the form n+->qbinomial(a+b n, n) r(n), where r(q^n) is a
          ++ q-rational function, that fits l.

-------------------------------------------------------------------------------

        guessHP: (LGOPT -> HPSPEC) -> GUESSER
          ++ \spad{guessHP f} constructs an operation that applies Hermite-Pade
          ++ approximation to the series generated by the given function f.

        guessADE: List F -> GUESSRESULT
          ++ \spad{guessADE l} tries to find an algebraic differential equation
          ++ for a generating function whose first Taylor coefficients are
          ++ given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}.

        guessADE: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessADE(l, options)} tries to find an algebraic
          ++ differential equation for a generating function whose first Taylor
          ++ coefficients are given by l, using the given options.

        guessAlg: List F -> GUESSRESULT
          ++ \spad{guessAlg l} tries to find an algebraic equation for a
          ++ generating function whose first Taylor coefficients are given by
          ++ l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessADE}(l, maxDerivative == 0).

        guessAlg: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessAlg(l, options)} tries to find an algebraic equation
          ++ for a generating function whose first Taylor coefficients are
          ++ given by l, using the given options. It is equivalent to
          ++ \spadfun{guessADE}(l, options) with \spad{maxDerivative == 0}.

        guessHolo: List F -> GUESSRESULT
          ++ \spad{guessHolo l} tries to find an ordinary linear differential
          ++ equation for a generating function whose first Taylor coefficients
          ++ are given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessADE}\spad{(l, maxPower == 1)}.

        guessHolo: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessHolo(l, options)} tries to find an ordinary linear
          ++ differential equation for a generating function whose first Taylor
          ++ coefficients are given by l, using the given options. It is
          ++ equivalent to \spadfun{guessADE}\spad{(l, options)} with
          ++ \spad{maxPower == 1}.

        guessPade: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessPade(l, options)} tries to find a rational function
          ++ whose first Taylor coefficients are given by l, using the given
          ++ options. It is equivalent to \spadfun{guessADE}\spad{(l,
          ++ maxDerivative == 0, maxPower == 1, allDegrees == true)}.

        guessPade: List F -> GUESSRESULT
          ++ \spad{guessPade(l, options)} tries to find a rational function
          ++ whose first Taylor coefficients are given by l, using the default
          ++ options described in \spadtype{GuessOptionFunctions0}. It is
          ++ equivalent to \spadfun{guessADE}\spad{(l, options)} with
          ++ \spad{maxDerivative == 0, maxPower == 1, allDegrees == true}.

        guessRec: List F -> GUESSRESULT
          ++ \spad{guessRec l} tries to find an ordinary difference equation
          ++ whose first values are given by l, using the default options
          ++ described in \spadtype{GuessOptionFunctions0}.

        guessRec: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessRec(l, options)} tries to find an ordinary difference
          ++ equation whose first values are given by l, using the given
          ++ options. 

        guessPRec: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessPRec(l, options)} tries to find a linear recurrence
          ++ with polynomial coefficients whose first values are given by l,
          ++ using the given options. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, options)} with \spad{maxPower == 1}.

        guessPRec: List F -> GUESSRESULT
          ++ \spad{guessPRec l} tries to find a linear recurrence with
          ++ polynomial coefficients whose first values are given by l, using
          ++ the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, maxPower == 1)}. 

        guessRat: (List F, LGOPT) -> GUESSRESULT
          ++ \spad{guessRat(l, options)} tries to find a rational function
          ++ whose first values are given by l, using the given options. It is
          ++ equivalent to \spadfun{guessRec}\spad{(l, maxShift == 0, maxPower
          ++ == 1, allDegrees == true)}.

        guessRat: List F -> GUESSRESULT
          ++ \spad{guessRat l} tries to find a rational function whose first
          ++ values are given by l, using the default options described in
          ++ \spadtype{GuessOptionFunctions0}. It is equivalent to
          ++ \spadfun{guessRec}\spad{(l, maxShift == 0, maxPower == 1,
          ++ allDegrees == true)}.

        diffHP: LGOPT -> HPSPEC
          ++ \spad{diffHP options} returns a specification for Hermite-Pade
          ++ approximation with the differential operator

        shiftHP: LGOPT -> HPSPEC
          ++ \spad{shiftHP options} returns a specification for Hermite-Pade
          ++ approximation with the shift operator

--        if F has RetractableTo Symbol and S has RetractableTo Symbol then

        shiftHP: Symbol -> (LGOPT -> HPSPEC)
          ++ \spad{shiftHP options} returns a specification for
          ++ Hermite-Pade approximation with the $q$-shift operator

        diffHP: Symbol -> (LGOPT -> HPSPEC)
          ++ \spad{diffHP options} returns a specification for Hermite-Pade
          ++ approximation with the  $q$-dilation operator

        guessRec: Symbol -> GUESSER
          ++ \spad{guessRec q} returns a guesser that finds an ordinary
          ++ q-difference equation whose first values are given by l, using
          ++ the given options.

        guessPRec: Symbol -> GUESSER
          ++ \spad{guessPRec q} returns a guesser that tries to find
          ++ a linear q-recurrence with polynomial coefficients whose first
          ++ values are given by l, using the given options. It is
          ++ equivalent to \spadfun{guessRec}\spad{(q)} with 
          ++ \spad{maxPower == 1}.

        guessRat: Symbol -> GUESSER
          ++ \spad{guessRat q} returns a guesser that tries to find a
          ++ q-rational function whose first values are given by l, using
          ++ the given options. It is equivalent to \spadfun{guessRec} with
          ++ \spad{(l, maxShift == 0, maxPower == 1, allDegrees == true)}.

        guessADE: Symbol -> GUESSER
          ++ \spad{guessADE q} returns a guesser that tries to find an
          ++ algebraic differential equation for a generating function whose
          ++ first Taylor coefficients are given by l, using the given
          ++ options.

-------------------------------------------------------------------------------

    Implementation == Guess(Fraction UP, UP,
                            MyExpression(q, Integer),
                            Fraction UP,
                            id$MappingPackage1(Fraction UP),
                            coerce$MyExpression(q, Integer))
@
<<GUESSUP.dotabb>>=
"GUESSUP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESSUP"]
"GUESS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GUESS"]
"GUESSUP" -> "GUESS" 

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter H}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package HB HallBasis}
\pagehead{HallBasis}{HB}
\pagepic{ps/v104hallbasis.ps}{HB}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package HB HallBasis>>=
)abbrev package HB HallBasis
++ Author : Larry Lambe
++ Date Created : August  1988
++ Date Last Updated : March 9 1990
++ Related Constructors: OrderedSetInts, Commutator, FreeNilpotentLie
++ AMS Classification: Primary 17B05, 17B30; Secondary 17A50
++ Keywords: free Lie algebra, Hall basis, basic commutators
++ Description : Generate a basis for the free Lie algebra on n
++ generators over a ring R with identity up to basic commutators
++ of length c using the algorithm of P. Hall as given in Serre's
++ book Lie Groups -- Lie Algebras

HallBasis() : Export == Implement where
   B   ==> Boolean
   I   ==> Integer
   NNI ==> NonNegativeInteger
   VI  ==> Vector Integer
   VLI ==> Vector List Integer

   Export  ==> with
     lfunc : (I,I) -> I
       ++ lfunc(d,n) computes the rank of the nth factor in the
       ++ lower central series of the free d-generated free Lie
       ++ algebra;  This rank is d if n = 1 and binom(d,2) if
       ++ n = 2
     inHallBasis? : (I,I,I,I) -> B
       ++ inHallBasis?(numberOfGens, leftCandidate, rightCandidate, left)
       ++ tests to see if a new element should be added to the P. Hall
       ++ basis being constructed.
       ++ The list \spad{[leftCandidate,wt,rightCandidate]}
       ++ is included in the basis if in the unique factorization of
       ++ rightCandidate, we have left factor leftOfRight, and
       ++ leftOfRight <= leftCandidate
     generate : (NNI,NNI) -> VLI
       ++ generate(numberOfGens, maximalWeight) generates a vector of
       ++ elements of the form [left,weight,right] which represents a
       ++ P. Hall basis element for the free lie algebra on numberOfGens
       ++ generators.  We only generate those basis elements of weight
       ++ less than or equal to maximalWeight

   Implement ==> add

     lfunc(d,n) ==
        n < 0 => 0
        n = 0 => 1
        n = 1 => d
        sum:I := 0
        m:I
        for m in 1..(n-1) repeat
          if n rem m = 0 then
            sum := sum + m * lfunc(d,m)
        res := (d**(n::NNI) - sum) quo n

     inHallBasis?(n,i,j,l) ==
        i >= j => false
        j <= n => true
        l <= i => true
        false

     generate(n:NNI,c:NNI) ==
        gens:=n
        maxweight:=c
        siz:I := 0
        for i in 1 .. maxweight repeat siz := siz + lfunc(gens,i)
        v:VLI:= new(siz::NNI,[])
        for i in 1..gens repeat v(i) := [0, 1, i]
        firstindex:VI := new(maxweight::NNI,0)
        wt:I := 1
        firstindex(1) := 1
        numComms:I := gens
        newNumComms:I := numComms
        done:B := false
        while not done repeat
          wt := wt + 1
          if wt > maxweight then done := true
          else
            firstindex(wt) := newNumComms + 1
            leftIndex := 1
            -- cW == complimentaryWeight
            cW:I := wt - 1
            while (leftIndex <= numComms) and (v(leftIndex).2 <= cW) repeat
              for rightIndex in firstindex(cW)..(firstindex(cW+1) - 1) repeat
                if inHallBasis?(gens,leftIndex,rightIndex,v(rightIndex).1) then
                  newNumComms := newNumComms + 1
                  v(newNumComms) := [leftIndex,wt,rightIndex]
              leftIndex := leftIndex + 1
              cW := wt - v(leftIndex).2
            numComms := newNumComms
        v

@
<<HB.dotabb>>=
"HB" [color="#FF4488",href="bookvol10.4.pdf#nameddest=HB"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"HB" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package HEUGCD HeuGcd}
\pagehead{HeuGcd}{HEUGCD}
\pagepic{ps/v104heugcd.ps}{HEUGCD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package HEUGCD HeuGcd>>=
)abbrev package HEUGCD HeuGcd
++ Author: P.Gianni
++ Date Created:
++ Date Last Updated: 13 September 94
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides the functions for the heuristic integer gcd.
++ Geddes's algorithm,for univariate polynomials with integer coefficients
HeuGcd (BP):C == T
 where
  BP       :   UnivariatePolynomialCategory Integer
  Z        ==> Integer
  ContPrim ==> Record(cont:Z,prim:BP)


  C == with
     gcd          : List BP  -> BP
       ++ gcd([f1,..,fk]) = gcd of the polynomials fi.
       ++
       ++X gcd([671*671*x^2-1,671*671*x^2+2*671*x+1])
       ++X gcd([7*x^2+1,(7*x^2+1)^2])

     gcdprim      : List BP  -> BP
       ++ gcdprim([f1,..,fk]) = gcd of k PRIMITIVE univariate polynomials
     gcdcofact    : List BP  -> List BP
       ++ gcdcofact([f1,..fk]) = gcd and cofactors of k univariate polynomials.
     gcdcofactprim: List BP  -> List BP
       ++ gcdcofactprim([f1,..fk]) = gcd and cofactors of k
       ++ primitive polynomials.
     content      : List BP  -> List Z
       ++ content([f1,..,fk]) = content of a list of univariate polynonials
     lintgcd      : List  Z  -> Z
       ++ lintgcd([a1,..,ak]) = gcd of a list of integers

  T == add

    PI    ==> PositiveInteger
    NNI   ==> NonNegativeInteger
    Cases ==> Union("gcdprim","gcd","gcdcofactprim","gcdcofact")
    import ModularDistinctDegreeFactorizer BP

    --local functions
    localgcd     :        List BP       -> List BP
    constNotZero :           BP         -> Boolean
    height       :           BP         -> PI
    genpoly      :         (Z,PI)       -> BP
    negShiftz    :         (Z,PI)       -> Z
    internal     :     (Cases,List BP ) -> List BP
    constcase    : (List NNI ,List BP ) -> List BP
    lincase      : (List NNI ,List BP ) -> List BP
    myNextPrime  :        ( Z , NNI )   -> Z

    bigPrime:= prevPrime(2**26)$IntegerPrimesPackage(Integer)

    myNextPrime(val:Z,bound:NNI) : Z == nextPrime(val)$IntegerPrimesPackage(Z)

    constNotZero(f : BP ) : Boolean == (degree f = 0) and ^(zero? f)

    negShiftz(n:Z,Modulus:PI):Z ==
      n < 0 => n:= n+Modulus
      n > (Modulus quo 2) => n-Modulus
      n

    --compute the height of a polynomial
    height(f:BP):PI ==
      k:PI:=1
      while f^=0 repeat
           k:=max(k,abs(leadingCoefficient(f)@Z)::PI)
           f:=reductum f
      k

    --reconstruct the polynomial from the value-adic representation of
    --dval.
    genpoly(dval:Z,value:PI):BP ==
      d:=0$BP
      val:=dval
      for i in 0..  while (val^=0) repeat
        val1:=negShiftz(val rem value,value)
        d:= d+monomial(val1,i)
        val:=(val-val1) quo value
      d

    --gcd of a list of integers
    lintgcd(lval:List(Z)):Z ==
      empty? lval => 0$Z
      member?(1,lval) => 1$Z
      lval:=sort(#1<#2,lval)
      val:=lval.first
      for val1 in lval.rest while ^(val=1) repeat val:=gcd(val,val1)
      val

    --content for a list of univariate polynomials
    content(listf:List BP ):List(Z) ==
      [lintgcd coefficients f for f in listf]

    --content of a list of polynomials with the relative primitive parts
    contprim(listf:List BP ):List(ContPrim) ==
       [[c:=lintgcd coefficients f,(f exquo c)::BP]$ContPrim  for f in listf]

    -- one polynomial is constant, remark that they are primitive
    -- but listf can contain the zero polynomial
    constcase(listdeg:List NNI ,listf:List BP ): List BP  ==
      lind:=select(constNotZero,listf)
      empty? lind =>
        member?(1,listdeg) => lincase(listdeg,listf)
        localgcd listf
      or/[n>0 for n in listdeg] => cons(1$BP,listf)
      lclistf:List(Z):= [leadingCoefficient f for f in listf]
      d:=lintgcd(lclistf)
      d=1 =>  cons(1$BP,listf)
      cons(d::BP,[(lcf quo d)::BP for lcf in lclistf])

    testDivide(listf: List BP, g:BP):Union(List BP, "failed") ==
      result:List BP := []
      for f in listf repeat
        if (f1:=f exquo g) case "failed" then return "failed"
        result := cons(f1::BP,result)
      reverse!(result)

    --one polynomial is linear, remark that they are primitive
    lincase(listdeg:List NNI ,listf:List BP ):List BP  ==
      n:= position(1,listdeg)
      g:=listf.n
      result:=[g]
      for f in listf repeat
        if (f1:=f exquo g) case "failed" then return cons(1$BP,listf)
        result := cons(f1::BP,result)
      reverse(result)

    IMG := InnerModularGcd(Z,BP,67108859,myNextPrime)

    mindegpol(f:BP, g:BP):BP ==
      degree(g) < degree (f) => g
      f

    --local function for the gcd among n PRIMITIVE univariate polynomials
    localgcd(listf:List BP ):List BP  ==
      hgt:="min"/[height(f) for f in listf|^zero? f]
      answr:=2+2*hgt
      minf := "mindegpol"/[f for f in listf|^zero? f]
      (result := testDivide(listf, minf)) case List(BP) =>
           cons(minf, result::List BP)
      if degree minf < 100 then for k in 1..10 repeat
        listval:=[f answr for f in listf]
        dval:=lintgcd(listval)
        dd:=genpoly(dval,answr)
        contd:=content(dd)
        d:=(dd exquo contd)::BP
        result:List BP :=[d]
        flag : Boolean := true
        for f in listf while flag repeat
          (f1:=f exquo d) case "failed" => flag:=false
          result := cons (f1::BP,result)
        if flag then return reverse(result)
        nvalue:= answr*832040 quo 317811
        if ((nvalue + answr) rem 2) = 0 then nvalue:=nvalue+1
        answr:=nvalue::PI
      gg:=modularGcdPrimitive(listf)$IMG
      cons(gg,[(f exquo gg) :: BP for f in listf])

    --internal function:it evaluates the gcd and avoids duplication of
    --code.
    internal(flag:Cases,listf:List BP ):List BP  ==
      --special cases
      listf=[] => [1$BP]
      (nlf:=#listf)=1 => [first listf,1$BP]
      minpol:=1$BP
      -- extract a monomial gcd
      mdeg:= "min"/[minimumDegree f for f in listf]
      if mdeg>0 then
        minpol1:= monomial(1,mdeg)
        listf:= [(f exquo minpol1)::BP for f in listf]
        minpol:=minpol*minpol1
      -- make the polynomials primitive
      Cgcd:List(Z):=[]
      contgcd : Z := 1
      if (flag case "gcd") or (flag case "gcdcofact") then
        contlistf:List(ContPrim):=contprim(listf)
        Cgcd:= [term.cont for term in contlistf]
        contgcd:=lintgcd(Cgcd)
        listf:List BP :=[term.prim for term in contlistf]
        minpol:=contgcd*minpol
      listdeg:=[degree f for f in listf ]
      f:= first listf
      if positiveRemainder(leadingCoefficient(f), bigPrime) ~= 0 then
        for g in rest listf repeat
          lcg := leadingCoefficient(g)
          if positiveRemainder(lcg, bigPrime) = 0 then
            leave
          f:=gcd(f,g,bigPrime)
          if degree f = 0 then return cons(minpol,listf)
      ans:List BP :=
         --one polynomial is constant
         member?(0,listdeg) => constcase(listdeg,listf)
         --one polynomial is linear
         member?(1,listdeg) => lincase(listdeg,listf)
         localgcd(listf)
      (result,ans):=(first ans*minpol,rest ans)
      if (flag case "gcdcofact") then
        ans:= [(p quo contgcd)*q for p in Cgcd for q in ans]
      cons(result,ans)

    --gcd among n PRIMITIVE univariate polynomials
    gcdprim (listf:List BP ):BP == first internal("gcdprim",listf)

    --gcd and cofactors for n PRIMITIVE univariate polynomials
    gcdcofactprim(listf:List BP ):List BP  == internal("gcdcofactprim",listf)

    --gcd for n generic univariate polynomials.
    gcd(listf:List BP ): BP  ==  first internal("gcd",listf)

    --gcd and cofactors for n generic univariate polynomials.
    gcdcofact (listf:List BP ):List BP == internal("gcdcofact",listf)

@
<<HEUGCD.dotabb>>=
"HEUGCD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=HEUGCD"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"HEUGCD" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter I}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IDECOMP IdealDecompositionPackage}
\pagehead{IdealDecompositionPackage}{IDECOMP}
\pagepic{ps/v104idealdecompositionpackage.ps}{IDECOMP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IDECOMP IdealDecompositionPackage>>=
)abbrev package IDECOMP IdealDecompositionPackage
++ Author: P. Gianni
++ Date Created: summer 1986
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: PolynomialIdeals
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package provides functions for the primary decomposition of
++ polynomial ideals over the rational numbers. The ideals are members
++ of the \spadtype{PolynomialIdeals} domain, and the polynomial generators are
++ required to be from the \spadtype{DistributedMultivariatePolynomial} domain.

IdealDecompositionPackage(vl,nv) : C == T -- take away nv, now doesn't
                                          -- compile if it isn't there
 where
   vl      :  List Symbol
   nv      :  NonNegativeInteger
   Z      ==>  Integer  -- substitute with PFE cat
   Q      ==>  Fraction Z
   F      ==>  Fraction P
   P      ==>  Polynomial Z
   UP     ==>  SparseUnivariatePolynomial P
   Expon  ==>  DirectProduct(nv,NNI)
   OV     ==>  OrderedVariableList(vl)
   SE     ==>  Symbol
   SUP    ==>  SparseUnivariatePolynomial(DPoly)

   DPoly1 ==>  DistributedMultivariatePolynomial(vl,Q)
   DPoly  ==>  DistributedMultivariatePolynomial(vl,F)
   NNI    ==>  NonNegativeInteger

   Ideal  ==  PolynomialIdeals(Q,Expon,OV,DPoly1)
   FIdeal ==  PolynomialIdeals(F,Expon,OV,DPoly)
   Fun0   ==  Union("zeroPrimDecomp","zeroRadComp")
   GenPos ==  Record(changeval:List Z,genideal:FIdeal)

   C == with


     zeroDimPrime?       :        Ideal         -> Boolean
       ++ zeroDimPrime?(I) tests if the ideal I is a 0-dimensional prime.

     zeroDimPrimary?     :        Ideal         -> Boolean
       ++ zeroDimPrimary?(I) tests if the ideal I is 0-dimensional primary.
     prime?              :        Ideal         -> Boolean
       ++ prime?(I) tests if the ideal I is prime.
     radical             :        Ideal         -> Ideal
       ++ radical(I) returns the radical of the ideal I.
     primaryDecomp       :        Ideal         -> List(Ideal)
       ++ primaryDecomp(I) returns a list of primary ideals such that their
       ++ intersection is the ideal I.

     contract        : (Ideal,List OV   )       -> Ideal
       ++ contract(I,lvar) contracts the ideal I to the polynomial ring
       ++ \spad{F[lvar]}.

   T  == add

     import MPolyCatRationalFunctionFactorizer(Expon,OV,Z,DPoly)
     import GroebnerPackage(F,Expon,OV,DPoly)
     import GroebnerPackage(Q,Expon,OV,DPoly1)

                  ----  Local  Functions  -----
     genPosLastVar       :    (FIdeal,List OV)     -> GenPos
     zeroPrimDecomp      :    (FIdeal,List OV)     -> List(FIdeal)
     zeroRadComp         :    (FIdeal,List OV)     -> FIdeal
     zerodimcase         :    (FIdeal,List OV)     -> Boolean
     is0dimprimary       :    (FIdeal,List OV)     -> Boolean
     backGenPos          : (FIdeal,List Z,List OV) -> FIdeal
     reduceDim           : (Fun0,FIdeal,List OV)   -> List FIdeal
     findvar             :   (FIdeal,List OV)      -> OV
     testPower           :    (SUP,OV,FIdeal)      -> Boolean
     goodPower           :     (DPoly,FIdeal)  -> Record(spol:DPoly,id:FIdeal)
     pushdown            :      (DPoly,OV)        -> DPoly
     pushdterm           :     (DPoly,OV,Z)       -> DPoly
     pushup              :      (DPoly,OV)        -> DPoly
     pushuterm           :    (DPoly,SE,OV)       -> DPoly
     pushucoef           :       (UP,OV)          -> DPoly
     trueden             :        (P,SE)          -> P
     rearrange           :       (List OV)        -> List OV
     deleteunit          :      List FIdeal        -> List FIdeal
     ismonic             :      (DPoly,OV)        -> Boolean


     MPCFQF ==> MPolyCatFunctions2(OV,Expon,Expon,Q,F,DPoly1,DPoly)
     MPCFFQ ==> MPolyCatFunctions2(OV,Expon,Expon,F,Q,DPoly,DPoly1)

     convertQF(a:Q) : F == ((numer a):: F)/((denom a)::F)
     convertFQ(a:F) : Q == (ground numer a)/(ground denom a)

     internalForm(I:Ideal) : FIdeal ==
       Id:=generators I
       nId:=[map(convertQF,poly)$MPCFQF for poly in Id]
       groebner? I => groebnerIdeal nId
       ideal nId

     externalForm(I:FIdeal) : Ideal ==
       Id:=generators I
       nId:=[map(convertFQ,poly)$MPCFFQ for poly in Id]
       groebner? I => groebnerIdeal nId
       ideal nId

     lvint:=[variable(xx)::OV for xx in vl]
     nvint1:=(#lvint-1)::NNI

     deleteunit(lI: List FIdeal) : List FIdeal ==
       [I for I in lI | _^ element?(1$DPoly,I)]

     rearrange(vlist:List OV) :List OV ==
       vlist=[] => vlist
       sort(#1>#2,setDifference(lvint,setDifference(lvint,vlist)))

            ---- radical of a 0-dimensional ideal  ----
     zeroRadComp(I:FIdeal,truelist:List OV) : FIdeal ==
       truelist=[] => I
       Id:=generators I
       x:OV:=truelist.last
       #Id=1 =>
         f:=Id.first
	 g:= (f exquo (gcd (f,differentiate(f,x))))::DPoly
         groebnerIdeal([g])
       y:=truelist.first
       px:DPoly:=x::DPoly
       py:DPoly:=y::DPoly
       f:=Id.last
       g:= (f exquo (gcd (f,differentiate(f,x))))::DPoly
       Id:=groebner(cons(g,remove(f,Id)))
       lf:=Id.first
       pv:DPoly:=0
       pw:DPoly:=0
       while degree(lf,y)^=1 repeat
         val:=random()$Z rem 23
         pv:=px+val*py
         pw:=px-val*py
	 Id:=groebner([(univariate(h,x)).pv for h in Id])
         lf:=Id.first
       ris:= generators(zeroRadComp(groebnerIdeal(Id.rest),truelist.rest))
       ris:=cons(lf,ris)
       if pv^=0 then
	 ris:=[(univariate(h,x)).pw for h in ris]
       groebnerIdeal(groebner ris)

          ----  find the power that stabilizes (I:s)  ----
     goodPower(s:DPoly,I:FIdeal) : Record(spol:DPoly,id:FIdeal) ==
       f:DPoly:=s
       I:=groebner I
       J:=generators(JJ:= (saturate(I,s)))
       while _^ in?(ideal([f*g for g in J]),I) repeat f:=s*f
       [f,JJ]

              ----  is the ideal zerodimensional?  ----
       ----     the "true variables" are  in truelist         ----
     zerodimcase(J:FIdeal,truelist:List OV) : Boolean ==
       element?(1,J) => true
       truelist=[] => true
       n:=#truelist
       Jd:=groebner generators J
       for x in truelist while Jd^=[] repeat
         f := Jd.first
         Jd:=Jd.rest
	 if ((y:=mainVariable f) case "failed") or (y::OV ^=x )
              or _^ (ismonic (f,x)) then return false
	 while Jd^=[] and (mainVariable Jd.first)::OV=x repeat Jd:=Jd.rest
	 if Jd=[] and position(x,truelist)<n then return false
       true

         ----  choose the variable for the reduction step  ----
                    --- J groebnerner in gen pos  ---
     findvar(J:FIdeal,truelist:List OV) : OV ==
       lmonicvar:List OV :=[]
       for f in generators J repeat
	 t:=f - reductum f
	 vt:List OV :=variables t
         if #vt=1 then lmonicvar:=setUnion(vt,lmonicvar)
       badvar:=setDifference(truelist,lmonicvar)
       badvar.first

            ---- function for the "reduction step  ----
     reduceDim(flag:Fun0,J:FIdeal,truelist:List OV) : List(FIdeal) ==
       element?(1,J) => [J]
       zerodimcase(J,truelist) =>
         (flag case "zeroPrimDecomp") => zeroPrimDecomp(J,truelist)
         (flag case "zeroRadComp") => [zeroRadComp(J,truelist)]
       x:OV:=findvar(J,truelist)
       Jnew:=[pushdown(f,x) for f in generators J]
       Jc: List FIdeal :=[]
       Jc:=reduceDim(flag,groebnerIdeal Jnew,remove(x,truelist))
       res1:=[ideal([pushup(f,x) for f in generators idp]) for idp in Jc]
       s:=pushup((_*/[leadingCoefficient f for f in Jnew])::DPoly,x)
       degree(s,x)=0 => res1
       res1:=[saturate(II,s) for II in res1]
       good:=goodPower(s,J)
       sideal := groebnerIdeal(groebner(cons(good.spol,generators J)))
       in?(good.id, sideal) => res1
       sresult:=reduceDim(flag,sideal,truelist)
       for JJ in sresult repeat
          if not(in?(good.id,JJ)) then res1:=cons(JJ,res1)
       res1

      ----  Primary Decomposition for 0-dimensional ideals  ----
     zeroPrimDecomp(I:FIdeal,truelist:List OV): List(FIdeal) ==
       truelist=[] => list I
       newJ:=genPosLastVar(I,truelist);lval:=newJ.changeval;
       J:=groebner newJ.genideal
       x:=truelist.last
       Jd:=generators J
       g:=Jd.last
       lfact:= factors factor(g)
       ris:List FIdeal:=[]
       for ef in lfact repeat
         g:DPoly:=(ef.factor)**(ef.exponent::NNI)
         J1:= groebnerIdeal(groebner cons(g,Jd))
         if _^ (is0dimprimary (J1,truelist)) then
                                   return zeroPrimDecomp(I,truelist)
         ris:=cons(groebner backGenPos(J1,lval,truelist),ris)
       ris

             ----  radical of an Ideal  ----
     radical(I:Ideal) : Ideal ==
       J:=groebner(internalForm I)
       truelist:=rearrange("setUnion"/[variables f for f in generators J])
       truelist=[] => externalForm J
       externalForm("intersect"/reduceDim("zeroRadComp",J,truelist))


-- the following functions are used to "push" x in the coefficient ring -

        ----  push x in the coefficient domain for a polynomial ----
     pushdown(g:DPoly,x:OV) : DPoly ==
       rf:DPoly:=0$DPoly
       i:=position(x,lvint)
       while g^=0 repeat
	 g1:=reductum g
         rf:=rf+pushdterm(g-g1,x,i)
         g := g1
       rf

      ----  push x in the coefficient domain for a term ----
     pushdterm(t:DPoly,x:OV,i:Z):DPoly ==
       n:=degree(t,x)
       xp:=convert(x)@SE
       cf:=monomial(1,xp,n)$P :: F
       newt := t exquo monomial(1,x,n)$DPoly
       cf * newt::DPoly

               ----  push back the variable  ----
     pushup(f:DPoly,x:OV) :DPoly ==
       h:=1$P
       rf:DPoly:=0$DPoly
       g := f
       xp := convert(x)@SE
       while g^=0 repeat
         h:=lcm(trueden(denom leadingCoefficient g,xp),h)
         g:=reductum g
       f:=(h::F)*f
       while f^=0 repeat
	 g:=reductum f
         rf:=rf+pushuterm(f-g,xp,x)
         f:=g
       rf

     trueden(c:P,x:SE) : P ==
       degree(c,x) = 0 => 1
       c

      ----  push x back from the coefficient domain for a term ----
     pushuterm(t:DPoly,xp:SE,x:OV):DPoly ==
       pushucoef((univariate(numer leadingCoefficient t,xp)$P), x)*
	  monomial(inv((denom leadingCoefficient t)::F),degree t)$DPoly


     pushucoef(c:UP,x:OV):DPoly ==
       c = 0 => 0
       monomial((leadingCoefficient c)::F::DPoly,x,degree c) +
		 pushucoef(reductum c,x)

           -- is the 0-dimensional ideal I primary ?  --
               ----  internal function  ----
     is0dimprimary(J:FIdeal,truelist:List OV) : Boolean ==
       element?(1,J) => true
       Jd:=generators(groebner J)
       #(factors factor Jd.last)^=1 => return false
       i:=subtractIfCan(#truelist,1)
       (i case "failed") => return true
       JR:=(reverse Jd);JM:=groebnerIdeal([JR.first]);JP:List(DPoly):=[]
       for f in JR.rest repeat
         if _^ ismonic(f,truelist.i) then
           if _^ inRadical?(f,JM) then return false
           JP:=cons(f,JP)
          else
           x:=truelist.i
           i:=(i-1)::NNI
	   if _^ testPower(univariate(f,x),x,JM) then return false
           JM :=groebnerIdeal(append(cons(f,JP),generators JM))
       true

         ---- Functions for the General Position step  ----

       ----  put the ideal in general position  ----
     genPosLastVar(J:FIdeal,truelist:List OV):GenPos ==
       x := last truelist ;lv1:List OV :=remove(x,truelist)
       ranvals:List(Z):=[(random()$Z rem 23) for vv in lv1]
       val:=_+/[rv*(vv::DPoly)  for vv in lv1 for rv in ranvals]
       val:=val+(x::DPoly)
       [ranvals,groebnerIdeal(groebner([(univariate(p,x)).val
                             for p in generators J]))]$GenPos


             ----  convert back the ideal  ----
     backGenPos(I:FIdeal,lval:List Z,truelist:List OV) : FIdeal ==
       lval=[] => I
       x := last truelist ;lv1:List OV:=remove(x,truelist)
       val:=-(_+/[rv*(vv::DPoly) for vv in lv1 for rv in lval])
       val:=val+(x::DPoly)
       groebnerIdeal
	   (groebner([(univariate(p,x)).val for p in generators I ]))

     ismonic(f:DPoly,x:OV) : Boolean == ground? leadingCoefficient(univariate(f,x))

         ---- test if f is power of a linear mod (rad J) ----
                    ----  f is monic  ----
     testPower(uf:SUP,x:OV,J:FIdeal) : Boolean ==
       df:=degree(uf)
       trailp:DPoly := inv(df:Z ::F) *coefficient(uf,(df-1)::NNI)
       linp:SUP:=(monomial(1$DPoly,1$NNI)$SUP +
		  monomial(trailp,0$NNI)$SUP)**df
       g:DPoly:=multivariate(uf-linp,x)
       inRadical?(g,J)


                    ----  Exported Functions  ----

           -- is the 0-dimensional ideal I prime ?  --
     zeroDimPrime?(I:Ideal) : Boolean ==
       J:=groebner((genPosLastVar(internalForm I,lvint)).genideal)
       element?(1,J) => true
       n:NNI:=#vl;i:NNI:=1
       Jd:=generators J
       #Jd^=n => false
       for f in Jd repeat
         if _^ ismonic(f,lvint.i) then return false
	 if i<n and (degree univariate(f,lvint.i))^=1 then return false
         i:=i+1
       g:=Jd.n
       #(lfact:=factors(factor g)) >1 => false
       lfact.1.exponent =1


           -- is the 0-dimensional ideal I primary ?  --
     zeroDimPrimary?(J:Ideal):Boolean ==
       is0dimprimary(internalForm J,lvint)

             ----  Primary Decomposition of I  -----

     primaryDecomp(I:Ideal) : List(Ideal) ==
       J:=groebner(internalForm I)
       truelist:=rearrange("setUnion"/[variables f for f in generators J])
       truelist=[] => [externalForm J]
       [externalForm II for II in reduceDim("zeroPrimDecomp",J,truelist)]

          ----  contract I to the ring with lvar variables  ----
     contract(I:Ideal,lvar: List OV) : Ideal ==
       Id:= generators(groebner I)
       empty?(Id) => I
       fullVars:= "setUnion"/[variables g for g in Id]
       fullVars = lvar => I
       n:= # lvar
       #fullVars < n  => error "wrong vars"
       n=0 => I
       newVars:= append([vv for vv in fullVars| ^member?(vv,lvar)]$List(OV),lvar)
       subsVars := [monomial(1,vv,1)$DPoly1 for vv in newVars]
       lJ:= [eval(g,fullVars,subsVars) for g in Id]
       J := groebner(lJ)
       J=[1] => groebnerIdeal J
       J=[0] => groebnerIdeal empty()
       J:=[f for f in J| member?(mainVariable(f)::OV,newVars)]
       fullPol :=[monomial(1,vv,1)$DPoly1 for vv in fullVars]
       groebnerIdeal([eval(gg,newVars,fullPol) for gg in J])

@
<<IDECOMP.dotabb>>=
"IDECOMP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IDECOMP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"DIRPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=DIRPCAT"]
"IDECOMP" -> "PFECAT"
"IDECOMP" -> "DIRPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INFPROD0 InfiniteProductCharacteristicZero}
\pagehead{InfiniteProductCharacteristicZero}{INFPROD0}
\pagepic{ps/v104infiniteproductcharacteristiczero.ps}{INFPROD0}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INFPROD0 InfiniteProductCharacteristicZero>>=
)abbrev package INFPROD0 InfiniteProductCharacteristicZero
++ Author: Clifton J. Williamson
++ Date Created: 22 February 1990
++ Date Last Updated: 23 February 1990
++ Basic Operations: infiniteProduct, evenInfiniteProduct, oddInfiniteProduct,
++   generalInfiniteProduct
++ Related Domains: UnivariateTaylorSeriesCategory
++ Also See:
++ AMS Classifications:
++ Keywords: Taylor series, infinite product
++ Examples:
++ References:
++ Description: 
++   This package computes infinite products of univariate Taylor series
++   over an integral domain of characteristic 0.
InfiniteProductCharacteristicZero(Coef,UTS):_
 Exports == Implementation where
  Coef : Join(IntegralDomain,CharacteristicZero)
  UTS  : UnivariateTaylorSeriesCategory Coef
  I  ==> Integer
 
  Exports ==> with
 
    infiniteProduct: UTS -> UTS
      ++ infiniteProduct(f(x)) computes \spad{product(n=1,2,3...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    evenInfiniteProduct: UTS -> UTS
      ++ evenInfiniteProduct(f(x)) computes \spad{product(n=2,4,6...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    oddInfiniteProduct: UTS -> UTS
      ++ oddInfiniteProduct(f(x)) computes \spad{product(n=1,3,5...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    generalInfiniteProduct: (UTS,I,I) -> UTS
      ++ generalInfiniteProduct(f(x),a,d) computes
      ++ \spad{product(n=a,a+d,a+2*d,...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
 
  Implementation ==> add
 
    import StreamInfiniteProduct Coef
 
    infiniteProduct x     == series infiniteProduct coefficients x
    evenInfiniteProduct x == series evenInfiniteProduct coefficients x
    oddInfiniteProduct x  == series oddInfiniteProduct coefficients x
 
    generalInfiniteProduct(x,a,d) ==
      series generalInfiniteProduct(coefficients x,a,d)

@
<<INFPROD0.dotabb>>=
"INFPROD0" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INFPROD0"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"INFPROD0" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INPRODFF InfiniteProductFiniteField}
\pagehead{InfiniteProductFiniteField}{INPRODFF}
\pagepic{ps/v104infiniteproductfinitefield.ps}{INPRODFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INPRODFF InfiniteProductFiniteField>>=
)abbrev package INPRODFF InfiniteProductFiniteField
++ Author: Clifton J. Williamson
++ Date Created: 22 February 1990
++ Date Last Updated: 23 February 1990
++ Basic Operations: infiniteProduct, evenInfiniteProduct, oddInfiniteProduct,
++   generalInfiniteProduct
++ Related Domains: UnivariateTaylorSeriesCategory
++ Also See:
++ AMS Classifications:
++ Keywords: Taylor series, infinite product
++ Examples:
++ References:
++ Description: 
++   This package computes infinite products of univariate Taylor series
++   over an arbitrary finite field.
InfiniteProductFiniteField(K,UP,Coef,UTS):_
 Exports == Implementation where
  K    :  Join(Field,Finite,ConvertibleTo Integer)
  UP   :  UnivariatePolynomialCategory K
  Coef :  MonogenicAlgebra(K,UP)
  UTS  :  UnivariateTaylorSeriesCategory Coef
  I   ==> Integer
  RN  ==> Fraction Integer
  SAE ==> SimpleAlgebraicExtension
  ST  ==> Stream
  STF ==> StreamTranscendentalFunctions
  STT ==> StreamTaylorSeriesOperations
  ST2 ==> StreamFunctions2
  SUP ==> SparseUnivariatePolynomial
 
  Exports ==> with
 
    infiniteProduct: UTS -> UTS
      ++ infiniteProduct(f(x)) computes \spad{product(n=1,2,3...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    evenInfiniteProduct: UTS -> UTS
      ++ evenInfiniteProduct(f(x)) computes \spad{product(n=2,4,6...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    oddInfiniteProduct: UTS -> UTS
      ++ oddInfiniteProduct(f(x)) computes \spad{product(n=1,3,5...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    generalInfiniteProduct: (UTS,I,I) -> UTS
      ++ generalInfiniteProduct(f(x),a,d) computes
      ++ \spad{product(n=a,a+d,a+2*d,...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
 
  Implementation ==> add
 
    liftPoly: UP -> SUP RN
    liftPoly poly ==
      -- lift coefficients of 'poly' to integers
      ans : SUP RN := 0
      while not zero? poly repeat
        coef := convert(leadingCoefficient poly)@I :: RN
        ans := ans + monomial(coef,degree poly)
        poly := reductum poly
      ans
 
    reducePoly: SUP RN -> UP
    reducePoly poly ==
      -- reduce coefficients of 'poly' to elements of K
      ans : UP := 0
      while not zero? poly repeat
        coef := numer(leadingCoefficient(poly)) :: K
        ans := ans + monomial(coef,degree poly)
        poly := reductum poly
      ans
 
    POLY := liftPoly definingPolynomial()$Coef
    ALG  := SAE(RN,SUP RN,POLY)
 
    infiniteProduct x ==
      stUP := map(lift,coefficients x)$ST2(Coef,UP)
      stSUP := map(liftPoly,stUP)$ST2(UP,SUP RN)
      stALG := map(reduce,stSUP)$ST2(SUP RN,ALG)
      stALG := exp(lambert(log(stALG)$STF(ALG))$STT(ALG))$STF(ALG)
      stSUP := map(lift,stALG)$ST2(ALG,SUP RN)
      stUP := map(reducePoly,stSUP)$ST2(SUP RN,UP)
      series map(reduce,stUP)$ST2(UP,Coef)
 
    evenInfiniteProduct x ==
      stUP := map(lift,coefficients x)$ST2(Coef,UP)
      stSUP := map(liftPoly,stUP)$ST2(UP,SUP RN)
      stALG := map(reduce,stSUP)$ST2(SUP RN,ALG)
      stALG := exp(evenlambert(log(stALG)$STF(ALG))$STT(ALG))$STF(ALG)
      stSUP := map(lift,stALG)$ST2(ALG,SUP RN)
      stUP := map(reducePoly,stSUP)$ST2(SUP RN,UP)
      series map(reduce,stUP)$ST2(UP,Coef)
 
    oddInfiniteProduct x ==
      stUP := map(lift,coefficients x)$ST2(Coef,UP)
      stSUP := map(liftPoly,stUP)$ST2(UP,SUP RN)
      stALG := map(reduce,stSUP)$ST2(SUP RN,ALG)
      stALG := exp(oddlambert(log(stALG)$STF(ALG))$STT(ALG))$STF(ALG)
      stSUP := map(lift,stALG)$ST2(ALG,SUP RN)
      stUP := map(reducePoly,stSUP)$ST2(SUP RN,UP)
      series map(reduce,stUP)$ST2(UP,Coef)
 
    generalInfiniteProduct(x,a,d) ==
      stUP := map(lift,coefficients x)$ST2(Coef,UP)
      stSUP := map(liftPoly,stUP)$ST2(UP,SUP RN)
      stALG := map(reduce,stSUP)$ST2(SUP RN,ALG)
      stALG := generalLambert(log(stALG)$STF(ALG),a,d)$STT(ALG)
      stALG := exp(stALG)$STF(ALG)
      stSUP := map(lift,stALG)$ST2(ALG,SUP RN)
      stUP := map(reducePoly,stSUP)$ST2(SUP RN,UP)
      series map(reduce,stUP)$ST2(UP,Coef)

@
<<INPRODFF.dotabb>>=
"INPRODFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INPRODFF"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"INPRODFF" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INPRODPF InfiniteProductPrimeField}
\pagehead{InfiniteProductPrimeField}{INPRODPF}
\pagepic{ps/v104infiniteproductprimefield.ps}{INPRODPF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INPRODPF InfiniteProductPrimeField>>=
)abbrev package INPRODPF InfiniteProductPrimeField
++ Author: Clifton J. Williamson
++ Date Created: 22 February 1990
++ Date Last Updated: 23 February 1990
++ Basic Operations: infiniteProduct, evenInfiniteProduct, oddInfiniteProduct,
++   generalInfiniteProduct
++ Related Domains: UnivariateTaylorSeriesCategory
++ Also See:
++ AMS Classifications:
++ Keywords: Taylor series, infinite product
++ Examples:
++ References:
++ Description: 
++    This package computes infinite products of univariate Taylor series
++    over a field of prime order.
InfiniteProductPrimeField(Coef,UTS): Exports == Implementation where
  Coef : Join(Field,Finite,ConvertibleTo Integer)
  UTS  : UnivariateTaylorSeriesCategory Coef
  I  ==> Integer
  ST ==> Stream
 
  Exports ==> with
 
    infiniteProduct: UTS -> UTS
      ++ infiniteProduct(f(x)) computes \spad{product(n=1,2,3...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    evenInfiniteProduct: UTS -> UTS
      ++ evenInfiniteProduct(f(x)) computes \spad{product(n=2,4,6...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    oddInfiniteProduct: UTS -> UTS
      ++ oddInfiniteProduct(f(x)) computes \spad{product(n=1,3,5...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    generalInfiniteProduct: (UTS,I,I) -> UTS
      ++ generalInfiniteProduct(f(x),a,d) computes
      ++ \spad{product(n=a,a+d,a+2*d,...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
 
  Implementation ==> add
 
    import StreamInfiniteProduct Integer
 
    applyOverZ:(ST I -> ST I,ST Coef) -> ST Coef
    applyOverZ(f,st) ==
      stZ := map(convert(#1)@Integer,st)$StreamFunctions2(Coef,I)
      map(#1 :: Coef,f stZ)$StreamFunctions2(I,Coef)
 
    infiniteProduct x ==
      series applyOverZ(infiniteProduct,coefficients x)
    evenInfiniteProduct x ==
      series applyOverZ(evenInfiniteProduct,coefficients x)
    oddInfiniteProduct x ==
      series applyOverZ(oddInfiniteProduct,coefficients x)
    generalInfiniteProduct(x,a,d) ==
      series applyOverZ(generalInfiniteProduct(#1,a,d),coefficients x)

@
<<INPRODPF.dotabb>>=
"INPRODPF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INPRODPF"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"INPRODPF" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ITFUN2 InfiniteTupleFunctions2}
\pagehead{InfiniteTupleFunctions2}{ITFUN2}
\pagepic{ps/v104infinitetuplefunctions2.ps}{ITFUN2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ITFUN2 InfiniteTupleFunctions2>>=
)abbrev package ITFUN2 InfiniteTupleFunctions2
InfiniteTupleFunctions2(A:Type,B:Type): Exports == Implementation where
  ++ Functions defined on streams with entries in two sets.
  IT   ==> InfiniteTuple

  Exports ==> with
    map: ((A -> B),IT A) -> IT B
      ++ \spad{map(f,[x0,x1,x2,...])} returns \spad{[f(x0),f(x1),f(x2),..]}.

  Implementation ==> add

    map(f,x) ==
      map(f,x pretend Stream(A))$StreamFunctions2(A,B) pretend IT(B)

@
<<ITFUN2.dotabb>>=
"ITFUN2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ITFUN2"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"ITFUN2" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ITFUN3 InfiniteTupleFunctions3}
\pagehead{InfiniteTupleFunctions3}{ITFUN3}
\pagepic{ps/v104infinitetuplefunctions3.ps}{ITFUN3}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ITFUN3 InfiniteTupleFunctions3>>=
)abbrev package ITFUN3 InfiniteTupleFunctions3
InfiniteTupleFunctions3(A:Type, B:Type,C:Type): Exports
 == Implementation where
   ++ Functions defined on streams with entries in two sets.
   IT   ==> InfiniteTuple
   ST   ==> Stream
   SF3  ==> StreamFunctions3(A,B,C)
   FUN  ==> ((A,B)->C)
   Exports ==> with
     map: (((A,B)->C), IT A, IT B) -> IT C
	++ map(f,a,b) \undocumented
     map: (((A,B)->C), ST A, IT B) -> ST C
	++ map(f,a,b) \undocumented
     map: (((A,B)->C), IT A, ST B) -> ST C
	++ map(f,a,b) \undocumented

   Implementation ==> add

     map(f:FUN, s1:IT A, s2:IT B):IT C ==
       map(f, s1 pretend Stream(A), s2 pretend Stream(B))$SF3 pretend IT(C)
     map(f:FUN, s1:ST A, s2:IT B):ST C ==
       map(f, s1, s2 pretend Stream(B))$SF3
     map(f:FUN, s1:IT A, s2:ST B):ST C ==
       map(f, s1 pretend Stream(A), s2)$SF3

@
<<ITFUN3.dotabb>>=
"ITFUN3" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ITFUN3"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"ITFUN3" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INFINITY Infinity}
\pagehead{Infinity}{INFINITY}
\pagepic{ps/v104infinity.ps}{INFINITY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INFINITY Infinity>>=
)abbrev package INFINITY Infinity
++ Top-level infinity
++ Author: Manuel Bronstein
++ Description: Default infinity signatures for the interpreter;
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
Infinity(): with
  infinity     : () -> OnePointCompletion Integer
    ++ infinity() returns infinity.
  plusInfinity : () -> OrderedCompletion  Integer
    ++ plusInfinity() returns plusIinfinity.
  minusInfinity: () -> OrderedCompletion  Integer
    ++ minusInfinity() returns minusInfinity.
 == add
  infinity()      == infinity()$OnePointCompletion(Integer)
  plusInfinity()  == plusInfinity()$OrderedCompletion(Integer)
  minusInfinity() == minusInfinity()$OrderedCompletion(Integer)

@
<<INFINITY.dotabb>>=
"INFINITY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INFINITY"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"INFINITY" -> "PID"
"INFINITY" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IALGFACT InnerAlgFactor}
\pagehead{InnerAlgFactor}{IALGFACT}
\pagepic{ps/v104inneralgfactor.ps}{IALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IALGFACT InnerAlgFactor>>=
)abbrev package IALGFACT InnerAlgFactor
++ Factorisation in a simple algebraic extension
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: 20 Jul 1988
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of a field over which we can factor UP's;
++ Keywords: factorization, algebraic extension, univariate polynomial

InnerAlgFactor(F, UP, AlExt, AlPol): Exports == Implementation where
  F    : Field
  UP   : UnivariatePolynomialCategory F
  AlPol: UnivariatePolynomialCategory AlExt
  AlExt : Join(Field, CharacteristicZero, MonogenicAlgebra(F,UP))
  NUP   ==> SparseUnivariatePolynomial UP
  N     ==> NonNegativeInteger
  Z     ==> Integer
  FR    ==> Factored UP
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2


  Exports ==> with
    factor: (AlPol, UP -> FR)  ->  Factored AlPol
      ++ factor(p, f) returns a prime factorisation of p;
      ++ f is a factorisation map for elements of UP;
 
  Implementation ==> add
    pnorm        : AlPol -> UP
    convrt       : AlPol -> NUP
    change       : UP    -> AlPol
    perturbfactor: (AlPol, Z, UP -> FR) -> List AlPol
    irrfactor    : (AlPol, Z, UP -> FR) -> List AlPol
 
 
    perturbfactor(f, k, fact) ==
      pol   := monomial(1$AlExt,1)-
               monomial(reduce monomial(k::F,1)$UP ,0)
      newf  := elt(f, pol)
      lsols := irrfactor(newf, k, fact)
      pol   := monomial(1, 1) +
               monomial(reduce monomial(k::F,1)$UP,0)
      [elt(pp, pol) for pp in lsols]
 
    ---  factorize the square-free parts of f  ---
    irrfactor(f, k, fact) ==
      degree(f) =$N 1 => [f]
      newf := f
      nn   := pnorm f
      --newval:RN:=1
      --pert:=false
      --if ^ SqFr? nn then
      --  pert:=true
      --  newterm:=perturb(f)
      --  newf:=newterm.ppol
      --  newval:=newterm.pval
      --  nn:=newterm.nnorm
      listfact := factors fact nn
      #listfact =$N 1 =>
        first(listfact).exponent =$Z 1 => [f]
        perturbfactor(f, k + 1, fact)
      listerm:List(AlPol):= []
      for pelt in listfact repeat
        g    := gcd(change(pelt.factor), newf)
        newf := (newf exquo g)::AlPol
        listerm :=
          pelt.exponent =$Z 1 => cons(g, listerm)
          append(perturbfactor(g, k + 1, fact), listerm)
      listerm
 
    factor(f, fact) ==
      sqf := squareFree f
      unit(sqf) * _*/[_*/[primeFactor(pol, sqterm.exponent)
                          for pol in irrfactor(sqterm.factor, 0, fact)]
                                            for sqterm in factors sqf]
 
    p := definingPolynomial()$AlExt
    newp := map(#1::UP, p)$UPCF2(F, UP, UP, NUP)
 
    pnorm  q == resultant(convrt q, newp)
    change q == map(coerce, q)$UPCF2(F,UP,AlExt,AlPol)
 
    convrt q ==
      swap(map(lift, q)$UPCF2(AlExt, AlPol,
           UP, NUP))$CommuteUnivariatePolynomialCategory(F, UP, NUP)

@
<<IALGFACT.dotabb>>=
"IALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ICDEN InnerCommonDenominator}
\pagehead{InnerCommonDenominator}{ICDEN}
\pagepic{ps/v104innercommondenominator.ps}{ICDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ICDEN InnerCommonDenominator>>=
)abbrev package ICDEN InnerCommonDenominator
--% InnerCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Nov 1989
++ Description: InnerCommonDenominator provides functions to compute
++ the common denominator of a finite linear aggregate of elements
++ of the quotient field of an integral domain.
++ Keywords: gcd, quotient, common, denominator.
InnerCommonDenominator(R, Q, A, B): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
  A: FiniteLinearAggregate R
  B: FiniteLinearAggregate Q
 
  Exports ==> with
    commonDenominator: B -> R 
      ++ commonDenominator([q1,...,qn]) returns a common denominator
      ++ d for q1,...,qn.
    clearDenominator : B -> A 
      ++ clearDenominator([q1,...,qn]) returns \spad{[p1,...,pn]} such that
      ++ \spad{qi = pi/d} where d is a common denominator for the qi's.
    splitDenominator : B -> Record(num: A, den: R)
      ++ splitDenominator([q1,...,qn]) returns
      ++ \spad{[[p1,...,pn], d]} such that
      ++ \spad{qi = pi/d} and d is a common denominator for the qi's.
 
  Implementation ==> add
    import FiniteLinearAggregateFunctions2(Q, B, R, A)
 
    clearDenominator l ==
      d := commonDenominator l
      map(numer(d * #1), l)
 
    splitDenominator l ==
      d := commonDenominator l
      [map(numer(d * #1), l), d]
 
    if R has GcdDomain then
      commonDenominator l == reduce(lcm, map(denom, l),1)
    else
      commonDenominator l == reduce("*", map(denom, l), 1)

@
<<ICDEN.dotabb>>=
"ICDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ICDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"ICDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IMATLIN InnerMatrixLinearAlgebraFunctions}
\pagehead{InnerMatrixLinearAlgebraFunctions}{IMATLIN}
\pagepic{ps/v104innermatrixlinearalgebrafunctions.ps}{IMATLIN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IMATLIN InnerMatrixLinearAlgebraFunctions>>=
)abbrev package IMATLIN InnerMatrixLinearAlgebraFunctions
++ Author: Clifton J. Williamson, P.Gianni
++ Date Created: 13 November 1989
++ Date Last Updated: September 1993
++ Basic Operations:
++ Related Domains: IndexedMatrix(R,minRow,minCol), Matrix(R),
++    RectangularMatrix(n,m,R), SquareMatrix(n,R)
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, canonical forms, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{InnerMatrixLinearAlgebraFunctions} is an internal package
++   which provides standard linear algebra functions on domains in
++   \spad{MatrixCategory}
InnerMatrixLinearAlgebraFunctions(R,Row,Col,M):_
             Exports == Implementation where
  R   : Field
  Row : FiniteLinearAggregate R
  Col : FiniteLinearAggregate R
  M   : MatrixCategory(R,Row,Col)
  I ==> Integer

  Exports ==> with
    rowEchelon: M -> M
      ++ \spad{rowEchelon(m)} returns the row echelon form of the matrix m.
    rank: M -> NonNegativeInteger
      ++ \spad{rank(m)} returns the rank of the matrix m.
    nullity: M -> NonNegativeInteger
      ++ \spad{nullity(m)} returns the mullity of the matrix m. This is the
      ++ dimension of the null space of the matrix m.
    if Col has shallowlyMutable then
      nullSpace: M -> List Col
        ++ \spad{nullSpace(m)} returns a basis for the null space of the
        ++ matrix m.
    determinant: M -> R
      ++ \spad{determinant(m)} returns the determinant of the matrix m.
      ++ an error message is returned if the matrix is not square.
    generalizedInverse: M -> M
      ++ \spad{generalizedInverse(m)} returns the generalized (Moore--Penrose)
      ++ inverse of the matrix m, i.e. the matrix h such that
      ++ m*h*m=h, h*m*h=m, m*h and h*m are both symmetric matrices.
    inverse: M -> Union(M,"failed")
      ++ \spad{inverse(m)} returns the inverse of the matrix m.
      ++ If the matrix is not invertible, "failed" is returned.
      ++ Error: if the matrix is not square.

  Implementation ==> add

    rowAllZeroes?: (M,I) -> Boolean
    rowAllZeroes?(x,i) ==
      -- determines if the ith row of x consists only of zeroes
      -- internal function: no check on index i
      for j in minColIndex(x)..maxColIndex(x) repeat
        qelt(x,i,j) ^= 0 => return false
      true

    colAllZeroes?: (M,I) -> Boolean
    colAllZeroes?(x,j) ==
      -- determines if the ith column of x consists only of zeroes
      -- internal function: no check on index j
      for i in minRowIndex(x)..maxRowIndex(x) repeat
        qelt(x,i,j) ^= 0 => return false
      true

    rowEchelon y ==
      -- row echelon form via Gaussian elimination
      x := copy y
      minR := minRowIndex x; maxR := maxRowIndex x
      minC := minColIndex x; maxC := maxColIndex x
      i := minR
      n: I := minR - 1
      for j in minC..maxC repeat
        i > maxR => return x
        n := minR - 1
        -- n = smallest k such that k >= i and x(k,j) ^= 0
        for k in i..maxR repeat
          if qelt(x,k,j) ^= 0 then leave (n := k)
        n = minR - 1 => "no non-zeroes"
        -- put nth row in ith position
        if i ^= n then swapRows_!(x,i,n)
        -- divide ith row by its first non-zero entry
        b := inv qelt(x,i,j)
        qsetelt_!(x,i,j,1)
        for k in (j+1)..maxC repeat qsetelt_!(x,i,k,b * qelt(x,i,k))
        -- perform row operations so that jth column has only one 1
        for k in minR..maxR repeat
          if k ^= i and qelt(x,k,j) ^= 0 then
            for k1 in (j+1)..maxC repeat
              qsetelt_!(x,k,k1,qelt(x,k,k1) - qelt(x,k,j) * qelt(x,i,k1))
            qsetelt_!(x,k,j,0)
        -- increment i
        i := i + 1
      x

    rank x ==
      y :=
        (rk := nrows x) > (rh := ncols x) =>
          rk := rh
          transpose x
        copy x
      y := rowEchelon y; i := maxRowIndex y
      while rk > 0 and rowAllZeroes?(y,i) repeat
        i := i - 1
        rk := (rk - 1) :: NonNegativeInteger
      rk :: NonNegativeInteger

    nullity x == (ncols x - rank x) :: NonNegativeInteger

    if Col has shallowlyMutable then

      nullSpace y ==
        x := rowEchelon y
        minR := minRowIndex x; maxR := maxRowIndex x
        minC := minColIndex x; maxC := maxColIndex x
        nrow := nrows x; ncol := ncols x
        basis : List Col := nil()
        rk := nrow; row := maxR
        -- compute rank = # rows - # rows of all zeroes
        while rk > 0 and rowAllZeroes?(x,row) repeat
          rk := (rk - 1) :: NonNegativeInteger
          row := (row - 1) :: NonNegativeInteger
        -- if maximal rank, return zero vector
        ncol <= nrow and rk = ncol => [new(ncol,0)]
        -- if rank = 0, return standard basis vectors
        rk = 0 =>
          for j in minC..maxC repeat
            w : Col := new(ncol,0)
            qsetelt_!(w,j,1)
            basis := cons(w,basis)
          basis
        -- v contains information about initial 1's in the rows of x
        -- if the ith row has an initial 1 in the jth column, then
        -- v.j = i; v.j = minR - 1, otherwise
        v : IndexedOneDimensionalArray(I,minC) := new(ncol,minR - 1)
        for i in minR..(minR + rk - 1) repeat
          for j in minC.. while qelt(x,i,j) = 0 repeat j
          qsetelt_!(v,j,i)
        j := maxC; l := minR + ncol - 1
        while j >= minC repeat
          w : Col := new(ncol,0)
          -- if there is no row with an initial 1 in the jth column,
          -- create a basis vector with a 1 in the jth row
          if qelt(v,j) = minR - 1 then
            colAllZeroes?(x,j) =>
              qsetelt_!(w,l,1)
              basis := cons(w,basis)
            for k in minC..(j-1) for ll in minR..(l-1) repeat
              if qelt(v,k) ^= minR - 1 then
                qsetelt_!(w,ll,-qelt(x,qelt(v,k),j))
            qsetelt_!(w,l,1)
            basis := cons(w,basis)
          j := j - 1; l := l - 1
        basis

    determinant y ==
      (ndim := nrows y) ^= (ncols y) =>
        error "determinant: matrix must be square"
      -- Gaussian Elimination
      ndim = 1 => qelt(y,minRowIndex y,minColIndex y)
      x := copy y
      minR := minRowIndex x; maxR := maxRowIndex x
      minC := minColIndex x; maxC := maxColIndex x
      ans : R := 1
      for i in minR..(maxR - 1) for j in minC..(maxC - 1) repeat
        if qelt(x,i,j) = 0 then
          rown := minR - 1
          for k in (i+1)..maxR repeat
            qelt(x,k,j) ^= 0 => leave (rown := k)
          if rown = minR - 1 then return 0
          swapRows_!(x,i,rown); ans := -ans
        ans := qelt(x,i,j) * ans; b := -inv qelt(x,i,j)
        for l in (j+1)..maxC repeat qsetelt_!(x,i,l,b * qelt(x,i,l))
        for k in (i+1)..maxR repeat
          if (b := qelt(x,k,j)) ^= 0 then
            for l in (j+1)..maxC repeat
              qsetelt_!(x,k,l,qelt(x,k,l) + b * qelt(x,i,l))
      qelt(x,maxR,maxC) * ans

    generalizedInverse(x) ==
      SUP:=SparseUnivariatePolynomial R
      FSUP := Fraction SUP
      VFSUP := Vector FSUP
      MATCAT2 := MatrixCategoryFunctions2(R, Row, Col, M,
                   FSUP, VFSUP, VFSUP, Matrix FSUP)
      MATCAT22 := MatrixCategoryFunctions2(FSUP, VFSUP, VFSUP, Matrix FSUP,
                   R, Row, Col, M)
      y:= map(coerce(coerce(#1)$SUP)$(Fraction SUP),x)$MATCAT2
      ty:=transpose y
      yy:=ty*y
      nc:=ncols yy
      var:=monomial(1,1)$SUP ::(Fraction SUP)
      yy:=inverse(yy+scalarMatrix(ncols yy,var))::Matrix(FSUP)*ty
      map(elt(#1,0),yy)$MATCAT22

    inverse x ==
      (ndim := nrows x) ^= (ncols x) =>
        error "inverse: matrix must be square"
      ndim = 2 =>
         ans2 : M := zero(ndim, ndim)
         zero?(det :=  x(1,1)*x(2,2)-x(1,2)*x(2,1)) => "failed"
         detinv := inv det
         ans2(1,1) := x(2,2)*detinv
         ans2(1,2) := -x(1,2)*detinv
         ans2(2,1) := -x(2,1)*detinv
         ans2(2,2) := x(1,1)*detinv
         ans2
      AB : M := zero(ndim,ndim + ndim)
      minR := minRowIndex x; maxR := maxRowIndex x
      minC := minColIndex x; maxC := maxColIndex x
      kmin := minRowIndex AB; kmax := kmin + ndim - 1
      lmin := minColIndex AB; lmax := lmin + ndim - 1
      for i in minR..maxR for k in kmin..kmax repeat
        for j in minC..maxC for l in lmin..lmax repeat
          qsetelt_!(AB,k,l,qelt(x,i,j))
        qsetelt_!(AB,k,lmin + ndim + k - kmin,1)
      AB := rowEchelon AB
      elt(AB,kmax,lmax) = 0 => "failed"
      subMatrix(AB,kmin,kmax,lmin + ndim,lmax + ndim)

@
<<IMATLIN.dotabb>>=
"IMATLIN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IMATLIN"]
"PFECAT" -> "IVECTOR"
"IMATLIN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IMATQF InnerMatrixQuotientFieldFunctions}
\pagehead{InnerMatrixQuotientFieldFunctions}{IMATQF}
\pagepic{ps/v104innermatrixquotientfieldfunctions.ps}{IMATQF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IMATQF InnerMatrixQuotientFieldFunctions>>=
)abbrev package IMATQF InnerMatrixQuotientFieldFunctions
++ Author: Clifton J. Williamson
++ Date Created: 22 November 1989
++ Date Last Updated: 22 November 1989
++ Basic Operations:
++ Related Domains: IndexedMatrix(R,minRow,minCol), Matrix(R), RectangularMatrix(n,m,R), SquareMatrix(n,R)
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, inverse, integral domain
++ Examples:
++ References:
++ Description:
++   \spadtype{InnerMatrixQuotientFieldFunctions} provides functions on matrices
++   over an integral domain which involve the quotient field of that integral
++   domain.  The functions rowEchelon and inverse return matrices with
++   entries in the quotient field.
InnerMatrixQuotientFieldFunctions(R,Row,Col,M,QF,Row2,Col2,M2):_
         Exports == Implementation where
  R    : IntegralDomain
  Row  : FiniteLinearAggregate R
  Col  : FiniteLinearAggregate R
  M    : MatrixCategory(R,Row,Col)
  QF   : QuotientFieldCategory R
  Row2 : FiniteLinearAggregate QF
  Col2 : FiniteLinearAggregate QF
  M2   : MatrixCategory(QF,Row2,Col2)
  IMATLIN ==> InnerMatrixLinearAlgebraFunctions(QF,Row2,Col2,M2)
  MATCAT2 ==> MatrixCategoryFunctions2(R,Row,Col,M,QF,Row2,Col2,M2)
  CDEN    ==> InnerCommonDenominator(R,QF,Col,Col2)

  Exports ==> with
      rowEchelon: M -> M2
        ++ \spad{rowEchelon(m)} returns the row echelon form of the matrix m.
        ++ the result will have entries in the quotient field.
      inverse: M -> Union(M2,"failed")
        ++ \spad{inverse(m)} returns the inverse of the matrix m.
        ++ If the matrix is not invertible, "failed" is returned.
        ++ Error: if the matrix is not square.
        ++ Note: the result will have entries in the quotient field.
      if Col2 has shallowlyMutable then
        nullSpace : M -> List Col
          ++ \spad{nullSpace(m)} returns a basis for the null space of the
          ++ matrix m.
  Implementation ==> add

    qfMat: M -> M2
    qfMat m == map(#1 :: QF,m)$MATCAT2

    rowEchelon m == rowEchelon(qfMat m)$IMATLIN
    inverse m ==
      (inv := inverse(qfMat m)$IMATLIN) case "failed" => "failed"
      inv :: M2

    if Col2 has shallowlyMutable then
      nullSpace m ==
        [clearDenominator(v)$CDEN for v in nullSpace(qfMat m)$IMATLIN]

@
<<IMATQF.dotabb>>=
"IMATQF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IMATQF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"IMATQF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INMODGCD InnerModularGcd}
\pagehead{InnerModularGcd}{INMODGCD}
\pagepic{ps/v104innermodulargcd.ps}{INMODGCD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INMODGCD InnerModularGcd>>=
)abbrev package INMODGCD InnerModularGcd
++ Author: J.H. Davenport and P. Gianni
++ Date Created: July 1990
++ Date Last Updated: November 1991
++ Description:
++ This file contains the functions for modular gcd algorithm
++ for univariate polynomials with coefficients in a
++ non-trivial euclidean domain (i.e. not a field).
++ The package parametrised by the coefficient domain,
++ the polynomial domain, a prime,
++ and a function for choosing the next prime

Z    ==> Integer
NNI  ==> NonNegativeInteger

InnerModularGcd(R,BP,pMod,nextMod):C == T
 where
  R       :  EuclideanDomain
  BP      :  UnivariatePolynomialCategory(R)
  pMod    :  R
  nextMod :  (R,NNI) -> R

  C == with
     modularGcdPrimitive    : List BP  -> BP
         ++ modularGcdPrimitive(f1,f2) computes the gcd of the two polynomials
         ++ f1 and f2 by modular methods.
     modularGcd    : List BP  -> BP
         ++ modularGcd(listf) computes the gcd of the list of polynomials
         ++ listf  by modular methods.
     reduction :       (BP,R)              ->   BP
         ++ reduction(f,p) reduces the coefficients of the polynomial f
         ++ modulo the prime p.

  T == add

                    -- local functions --
    height    :         BP                ->   NNI
    mbound    :       (BP,BP)             ->   NNI
    modGcdPrimitive    :   (BP,BP)        ->   BP
    test         :     (BP,BP,BP)         ->   Boolean
    merge        :        (R,R)           ->   Union(R,"failed")
    modInverse   :      (R,R)             ->   R
    exactquo     :       (BP,BP,R)        ->   Union(BP,"failed")
    constNotZero :           BP           ->   Boolean
    constcase    : (List NNI ,List BP )   ->   BP 
    lincase      : (List NNI ,List BP )   ->   BP 


    if R has IntegerNumberSystem then
        reduction(u:BP,p:R):BP ==
            p = 0 => u
            map(symmetricRemainder(#1,p),u)
      else
        reduction(u:BP,p:R):BP ==
            p = 0 => u
            map(#1 rem p,u)

    FP:=EuclideanModularRing(R,BP,R,reduction,merge,exactquo)
    zeroChar : Boolean := R has CharacteristicZero

                 --  exported functions --

    -- modular Gcd for a list of primitive polynomials
    modularGcdPrimitive(listf : List BP) :BP ==
      empty? listf => 0$BP
      g := first listf
      for f in rest listf | ^zero? f  while degree g > 0 repeat
        g:=modGcdPrimitive(g,f)
      g		

    -- gcd for univariate polynomials
    modularGcd(listf : List BP): BP  ==
      listf:=remove!(0$BP,listf)
      empty? listf => 0$BP
      # listf = 1 => first listf 
      minpol:=1$BP
      -- extract a monomial gcd
      mdeg:= "min"/[minimumDegree f for f in listf]
      if mdeg>0 then
        minpol1:= monomial(1,mdeg)
        listf:= [(f exquo minpol1)::BP for f in listf]
        minpol:=minpol*minpol1
      listdeg:=[degree f for f in listf ]
    -- make the polynomials primitive
      listCont := [content f for f in listf]
      contgcd:= gcd listCont
      -- make the polynomials primitive
      listf :=[(f exquo cf)::BP for f in listf for cf in listCont]
      minpol:=contgcd*minpol
      ans:BP :=  
         --one polynomial is constant
         member?(1,listf) => 1
         --one polynomial is linear
         member?(1,listdeg) => lincase(listdeg,listf)
         modularGcdPrimitive listf
      minpol*ans
 
                  --  local functions --

    --one polynomial is linear, remark that they are primitive
    lincase(listdeg:List NNI ,listf:List BP ): BP  ==
      n:= position(1,listdeg)
      g:=listf.n
      for f in listf repeat
        if (f1:=f exquo g) case "failed" then return 1$BP
      g

    -- test if d is the gcd
    test(f:BP,g:BP,d:BP):Boolean ==
      d0:=coefficient(d,0)
      coefficient(f,0) exquo d0 case "failed" => false
      coefficient(g,0) exquo d0 case "failed" => false
      f exquo d case "failed" => false
      g exquo d case "failed" => false
      true

    -- gcd and cofactors for PRIMITIVE univariate polynomials
    -- also assumes that constant terms are non zero
    modGcdPrimitive(f:BP,g:BP): BP ==
      df:=degree f
      dg:=degree g
      dp:FP
      lcf:=leadingCoefficient f
      lcg:=leadingCoefficient g
      testdeg:NNI
      lcd:R:=gcd(lcf,lcg)
      prime:=pMod
      bound:=mbound(f,g)
      while zero? (lcd rem prime) repeat
        prime := nextMod(prime,bound)
      soFar:=gcd(reduce(f,prime),reduce(g,prime))::BP
      testdeg:=degree soFar
      zero? testdeg => return 1$BP
      ldp:FP:=
        ((lcdp:=leadingCoefficient(soFar::BP)) = 1) =>
                                        reduce(lcd::BP,prime)
        reduce((modInverse(lcdp,prime)*lcd)::BP,prime)
      soFar:=reduce(ldp::BP *soFar,prime)::BP
      soFarModulus:=prime
      -- choose the prime
      while true repeat
        prime := nextMod(prime,bound)
        lcd rem prime =0 => "next prime"
        fp:=reduce(f,prime)
        gp:=reduce(g,prime)
        dp:=gcd(fp,gp)
        dgp :=euclideanSize dp
        if dgp =0 then return 1$BP
        if dgp=dg and ^(f exquo g case "failed") then return g
        if dgp=df and ^(g exquo f case "failed") then return f
        dgp > testdeg => "next prime"
        ldp:FP:=
          ((lcdp:=leadingCoefficient(dp::BP)) = 1) =>
                                        reduce(lcd::BP,prime)
          reduce((modInverse(lcdp,prime)*lcd)::BP,prime)
        dp:=ldp *dp
        dgp=testdeg  =>
           correction:=reduce(dp::BP-soFar,prime)::BP
           zero? correction =>
              ans:=reduce(lcd::BP*soFar,soFarModulus)::BP
              cont:=content ans
              ans:=(ans exquo cont)::BP
              test(f,g,ans) => return ans
              soFarModulus:=soFarModulus*prime
           correctionFactor:=modInverse(soFarModulus rem prime,prime)
                             -- the initial rem is just for efficiency
           soFar:=soFar+soFarModulus*(correctionFactor*correction)
           soFarModulus:=soFarModulus*prime
           soFar:=reduce(soFar,soFarModulus)::BP
        dgp<testdeg =>
          soFarModulus:=prime
          soFar:=dp::BP
          testdeg:=dgp
        if ^zeroChar and euclideanSize(prime)>1 then
           result:=dp::BP
           test(f,g,result) => return result
        -- this is based on the assumption that the caller of this package,
        -- in non-zero characteristic, will use primes of the form
        -- x-alpha as long as possible, but, if these are exhausted,
        -- will switch to a prime of degree larger than the answer
        -- so the result can be used directly.

    merge(p:R,q:R):Union(R,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

    modInverse(c:R,p:R):R ==
        (extendedEuclidean(c,p,1)::Record(coef1:R,coef2:R)).coef1

    exactquo(u:BP,v:BP,p:R):Union(BP,"failed") ==
        invlcv:=modInverse(leadingCoefficient v,p)
        r:=monicDivide(u,reduction(invlcv*v,p))
        reduction(r.remainder,p) ^=0 => "failed"
        reduction(invlcv*r.quotient,p)


    -- compute the height of a polynomial --
    height(f:BP):NNI ==
      degf:=degree f
      "max"/[euclideanSize cc for cc in coefficients f]

    -- compute the bound
    mbound(f:BP,g:BP):NNI ==
      hf:=height f
      hg:=height g
      2*min(hf,hg)

\section{package FOMOGCD ForModularGcd}
-- ForModularGcd(R,BP) : C == T
--  where
--   R          :   EuclideanDomain  -- characteristic 0
--   BP         :   UnivariatePolynomialCategory(R)
--
--   C == with
--     nextMod :  (R,NNI) -> R
--
--   T == add
--     nextMod(val:R,bound:NNI) : R  ==
--       ival:Z:= val pretend Z
--       (nextPrime(ival)$IntegerPrimesPackage(Z))::R
--
-- ForTwoGcd(F) : C == T
--  where
--   F          :   Join(Finite,Field)
--   SUP       ==>  SparseUnivariatePolynomial
--   R         ==>  SUP F
--   P         ==>  SUP R
--   UPCF2     ==>  UnivariatePolynomialCategoryFunctions2
--
--   C == with
--     nextMod :  (R,NNI) -> R
--
--   T == add
--     nextMod(val:R,bound:NNI) : R ==
--       ris:R:= nextItem(val) :: R
--       euclideanSize ris < 2 => ris
--       generateIrredPoly(
--             (bound+1)::PositiveInteger)$IrredPolyOverFiniteField(F)
--
--
-- ModularGcd(R,BP) == T
--  where
--   R  : EuclideanDomain -- characteristic 0
--   BP : UnivariatePolynomialCategory(R)
--   T ==> InnerModularGcd(R,BP,67108859::R,nextMod$ForModularGcd(R,BP))
--
-- TwoGcd(F) : C == T
--  where
--   F          :   Join(Finite,Field)
--   SUP       ==>  SparseUnivariatePolynomial
--   R         ==>  SUP F
--   P         ==>  SUP R
--
--   T ==> InnerModularGcd(R,P,nextMod(monomial(1,1)$R)$ForTwoGcd(F),
--                         nextMod$ForTwoGcd(F))

@
<<INMODGCD.dotabb>>=
"INMODGCD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INMODGCD"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INMODGCD" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INNMFACT InnerMultFact}
\pagehead{InnerMultFact}{INNMFACT}
\pagepic{ps/v104innermultfact.ps}{INNMFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INNMFACT InnerMultFact>>=
)abbrev package INNMFACT InnerMultFact
++ Author: P. Gianni
++ Date Created: 1983
++ Date Last Updated: Sept. 1990
++ Additional Comments: JHD Aug 1997
++ Basic Functions:
++ Related Constructors: MultivariateFactorize, AlgebraicMultFact
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This is an inner package for factoring multivariate polynomials
++ over various coefficient domains in characteristic 0.
++ The univariate factor operation is passed as a parameter.
++ Multivariate hensel lifting is used to lift the univariate
++ factorization

-- Both exposed functions call mFactor. This deals with issues such as 
-- monomial factors, contents, square-freeness etc., then calls intfact.
-- This uses intChoose to find a "good" evaluation and factorise the 
-- corresponding univariate, and then uses MultivariateLifting to find
-- the multivariate factors.

InnerMultFact(OV,E,R,P) : C == T
 where
  R          :   Join(EuclideanDomain, CharacteristicZero)
                      -- with factor on R[x]
  OV         :   OrderedSet
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(R,E,OV)
  BP         ==> SparseUnivariatePolynomial R
  UFactor    ==> (BP -> Factored BP)
  Z            ==> Integer
  MParFact     ==> Record(irr:P,pow:Z)
  USP          ==> SparseUnivariatePolynomial P
  SUParFact    ==> Record(irr:USP,pow:Z)
  SUPFinalFact ==> Record(contp:R,factors:List SUParFact)
  MFinalFact   ==> Record(contp:R,factors:List MParFact)

               --  contp   =  content,
               --  factors =  List of irreducible factors with exponent
  L          ==> List

  C == with
    factor      :      (P,UFactor)    ->  Factored P
      ++ factor(p,ufact) factors the multivariate polynomial p
      ++ by specializing variables and calling the univariate
      ++ factorizer ufact.
    factor      :      (USP,UFactor)    ->  Factored USP
      ++ factor(p,ufact) factors the multivariate polynomial p
      ++ by specializing variables and calling the univariate
      ++ factorizer ufact. p is represented as a univariate
      ++ polynomial with multivariate coefficients.

  T == add

    NNI       ==> NonNegativeInteger

    LeadFact  ==> Record(polfac:L P,correct:R,corrfact:L BP)
    ContPrim  ==> Record(cont:P,prim:P)
    ParFact   ==> Record(irr:BP,pow:Z)
    FinalFact ==> Record(contp:R,factors:L ParFact)
    NewOrd    ==> Record(npol:USP,nvar:L OV,newdeg:L NNI)
    pmod:R   :=  (prevPrime(2**26)$IntegerPrimesPackage(Integer))::R

    import GenExEuclid(R,BP)
    import MultivariateLifting(E,OV,R,P)
    import FactoringUtilities(E,OV,R,P)
    import LeadingCoefDetermination(OV,E,R,P)
    Valuf ==> Record(inval:L L R,unvfact:L BP,lu:R,complead:L R)
    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

                   ----  Local Functions  ----
    mFactor   :            (P,UFactor)           ->  MFinalFact
    supFactor :           (USP,UFactor)          ->  SUPFinalFact
    mfconst   :      (USP,L OV,L NNI,UFactor)    -> L USP
    mfpol     :      (USP,L OV,L NNI,UFactor)    -> L USP
    monicMfpol:      (USP,L OV,L NNI,UFactor)    -> L USP
    varChoose :           (P,L OV,L NNI)         -> NewOrd
    simplify  :       (P,L OV,L NNI,UFactor)     -> MFinalFact
    intChoose :  (USP,L OV,R,L P,L L R,UFactor)  -> Union(Valuf,"failed")
    intfact   : (USP,L OV,L NNI,MFinalFact,L L R,UFactor) -> L USP
    pretest   :         (P,NNI,L OV,L R)         -> FinalFact
    checkzero :            (USP,BP)              -> Boolean
    localNorm :               L BP               -> Z

    convertPUP(lfg:MFinalFact): SUPFinalFact ==
      [lfg.contp,[[lff.irr ::USP,lff.pow]$SUParFact
                    for lff in lfg.factors]]$SUPFinalFact

    -- intermediate routine if an SUP was passed in.
    supFactor(um:USP,ufactor:UFactor) : SUPFinalFact ==
      ground?(um) => convertPUP(mFactor(ground um,ufactor))
      lvar:L OV:= "setUnion"/[variables cf for cf in coefficients um]
      empty? lvar => -- the polynomial is univariate
        umv:= map(ground,um)$UPCF2(P,USP,R,BP)
        lfact:=ufactor umv
        [retract unit lfact,[[map(coerce,ff.factor)$UPCF2(R,BP,P,USP),
           ff.exponent] for ff in factors lfact]]$SUPFinalFact
      lcont:P
      lf:L USP
      flead : SUPFinalFact:=[0,empty()]$SUPFinalFact
      factorlist:L SUParFact :=empty()

      mdeg :=minimumDegree um     ---- is the Mindeg > 0? ----
      if mdeg>0 then
        f1:USP:=monomial(1,mdeg)
        um:=(um exquo f1)::USP
        factorlist:=cons([monomial(1,1),mdeg],factorlist)
        if degree um=0 then return
          lfg:=convertPUP mFactor(ground um, ufactor)
          [lfg.contp,append(factorlist,lfg.factors)]
      uum:=unitNormal um
      um :=uum.canonical
      sqfacs := squareFree(um)$MultivariateSquareFree(E,OV,R,P)
      lcont :=  ground(uum.unit * unit sqfacs)
                                   ----  Factorize the content  ----
      flead:=convertPUP mFactor(lcont,ufactor)
      factorlist:=append(flead.factors,factorlist)
                               ----  Make the polynomial square-free  ----
      sqqfact:=factors sqfacs
                        ---  Factorize the primitive square-free terms ---
      for fact in sqqfact repeat
        ffactor:USP:=fact.factor
        ffexp:=fact.exponent
        zero? degree ffactor =>
          lfg:=mFactor(ground ffactor,ufactor)
          lcont:=lfg.contp * lcont
          factorlist := append(factorlist,
             [[lff.irr ::USP,lff.pow * ffexp]$SUParFact
                       for lff in lfg.factors])
        coefs := coefficients ffactor
        ldeg:= ["max"/[degree(fc,xx) for fc in coefs] for xx in lvar]
        lf :=
          ground?(leadingCoefficient ffactor) =>
             mfconst(ffactor,lvar,ldeg,ufactor)
          mfpol(ffactor,lvar,ldeg,ufactor)
        auxfl:=[[lfp,ffexp]$SUParFact  for lfp in lf]
        factorlist:=append(factorlist,auxfl)
      lcfacs := */[leadingCoefficient leadingCoefficient(f.irr)**((f.pow)::NNI)
                           for f in factorlist]
      [(leadingCoefficient leadingCoefficient(um) exquo lcfacs)::R,
                     factorlist]$SUPFinalFact

    factor(um:USP,ufactor:UFactor):Factored USP ==
      flist := supFactor(um,ufactor)
      (flist.contp):: P :: USP *
        (*/[primeFactor(u.irr,u.pow) for u in flist.factors])

    checkzero(u:USP,um:BP) : Boolean ==
      u=0 => um =0
      um = 0 => false
      degree u = degree um => checkzero(reductum u, reductum um)
      false
              ---  Choose the variable of less degree  ---
    varChoose(m:P,lvar:L OV,ldeg:L NNI) : NewOrd ==
      k:="min"/[d for d in ldeg]
      k=degree(m,first lvar) =>
                             [univariate(m,first lvar),lvar,ldeg]$NewOrd
      i:=position(k,ldeg)
      x:OV:=lvar.i
      ldeg:=cons(k,delete(ldeg,i))
      lvar:=cons(x,delete(lvar,i))
      [univariate(m,x),lvar,ldeg]$NewOrd

    localNorm(lum: L BP): Z ==
      R is AlgebraicNumber =>
        "max"/[numberOfMonomials ff for ff in lum]

      "max"/[+/[euclideanSize cc for i in 0..degree ff|
                (cc:= coefficient(ff,i))^=0] for ff in lum]

          ---  Choose the integer to reduce to univariate case  ---
    intChoose(um:USP,lvar:L OV,clc:R,plist:L P,ltry:L L R,
                                 ufactor:UFactor) : Union(Valuf,"failed") ==
      -- declarations
      degum:NNI := degree um
      nvar1:=#lvar
      range:NNI:=5
      unifact:L BP
      ctf1 : R := 1
      testp:Boolean :=             -- polynomial leading coefficient
        empty? plist => false
        true
      leadcomp,leadcomp1 : L R
      leadcomp:=leadcomp1:=empty()
      nfatt:NNI := degum+1
      lffc:R:=1
      lffc1:=lffc
      newunifact : L BP:=empty()
      leadtest:=true --- the lc test with polCase has to be performed
      int:L R:=empty()

   --  New sets of integers are chosen to reduce the multivariate problem to
   --  a univariate one, until we find twice the
   --  same (and minimal) number of "univariate" factors:
   --  the set smaller in modulo is chosen.
   --  Note that there is no guarantee that this is the truth:
   --  merely the closest approximation we have found!

      while true repeat
       testp and #ltry>10 => return "failed"
       lval := [ ran(range) for i in 1..nvar1]
       member?(lval,ltry) => range:=2*range
       ltry := cons(lval,ltry)
       leadcomp1:=[retract eval(pol,lvar,lval) for pol in plist]
       testp and or/[unit? epl for epl in leadcomp1] => range:=2*range
       newm:BP:=completeEval(um,lvar,lval)
       degum ^= degree newm or minimumDegree newm ^=0 => range:=2*range
       lffc1:=content newm
       newm:=(newm exquo lffc1)::BP
       testp and leadtest and ^ polCase(lffc1*clc,#plist,leadcomp1)
                             => range:=2*range
       degree(gcd [newm,differentiate(newm)])^=0 => range:=2*range
       luniv:=ufactor(newm)
       lunivf:= factors luniv
       lffc1:R:=retract(unit luniv)@R * lffc1
       nf:= #lunivf

       nf=0 or nf>nfatt => "next values"      ---  pretest failed ---

                        --- the univariate polynomial is irreducible ---
       if nf=1 then leave (unifact:=[newm])

   --  the new integer give the same number of factors
       nfatt = nf =>
       -- if this is the first univariate factorization with polCase=true
       -- or if the last factorization has smaller norm and satisfies
       -- polCase
         if leadtest or
           ((localNorm unifact > localNorm [ff.factor for ff in lunivf])
             and (^testp or polCase(lffc1*clc,#plist,leadcomp1))) then
                unifact:=[uf.factor for uf in lunivf]
                int:=lval
                lffc:=lffc1
                if testp then leadcomp:=leadcomp1
         leave "foundit"

   --  the first univariate factorization, inizialize
       nfatt > degum =>
         unifact:=[uf.factor for uf in lunivf]
         lffc:=lffc1
         if testp then leadcomp:=leadcomp1
         int:=lval
         leadtest := false
         nfatt := nf

       nfatt>nf =>  -- for the previous values there were more factors
         if testp then leadtest:=^polCase(lffc*clc,#plist,leadcomp)
         else leadtest:= false
         -- if polCase=true we can consider the univariate decomposition
         if ^leadtest then
           unifact:=[uf.factor for uf in lunivf]
           lffc:=lffc1
           if testp then leadcomp:=leadcomp1
           int:=lval
         nfatt := nf
      [cons(int,ltry),unifact,lffc,leadcomp]$Valuf


                ----  The polynomial has mindeg>0   ----

    simplify(m:P,lvar:L OV,lmdeg:L NNI,ufactor:UFactor):MFinalFact ==
      factorlist:L MParFact:=[]
      pol1:P:= 1$P
      for x in lvar repeat
        i := lmdeg.(position(x,lvar))
        i=0 => "next value"
        pol1:=pol1*monomial(1$P,x,i)
        factorlist:=cons([x::P,i]$MParFact,factorlist)
      m := (m exquo pol1)::P
      ground? m => [retract m,factorlist]$MFinalFact
      flead:=mFactor(m,ufactor)
      flead.factors:=append(factorlist,flead.factors)
      flead

    -- This is the key internal function
    -- We now know that the polynomial is square-free etc.,
    -- We use intChoose to find a set of integer values to reduce the
    -- problem to univariate (and for efficiency, intChoose returns
    -- the univariate factors).
    -- In the case of a polynomial leading coefficient, we check that this 
    -- is consistent with leading coefficient determination (else try again)
    -- We then lift the univariate factors to multivariate factors, and
    -- return the result
    intfact(um:USP,lvar: L OV,ldeg:L NNI,tleadpol:MFinalFact,
                                   ltry:L L R,ufactor:UFactor) :  L USP ==
      polcase:Boolean:=(not empty? tleadpol.factors)
      vfchoo:Valuf:=
        polcase =>
          leadpol:L P:=[ff.irr for ff in tleadpol.factors]
          check:=intChoose(um,lvar,tleadpol.contp,leadpol,ltry,ufactor)
          check case "failed" => return monicMfpol(um,lvar,ldeg,ufactor)
          check::Valuf
        intChoose(um,lvar,1,empty(),empty(),ufactor)::Valuf
      unifact:List BP := vfchoo.unvfact
      nfact:NNI := #unifact
      nfact=1 => [um]
      ltry:L L R:= vfchoo.inval
      lval:L R:=first ltry
      dd:= vfchoo.lu
      leadval:L R:=empty()
      lpol:List P:=empty()
      if polcase then
        leadval := vfchoo.complead
        distf := distFact(vfchoo.lu,unifact,tleadpol,leadval,lvar,lval)
        distf case "failed" =>
             return intfact(um,lvar,ldeg,tleadpol,ltry,ufactor)
        dist := distf :: LeadFact
          -- check the factorization of leading coefficient
        lpol:= dist.polfac
        dd := dist.correct
        unifact:=dist.corrfact
      if dd^=1 then
--        if polcase then lpol := [unitCanonical lp for lp in lpol]
--        dd:=unitCanonical(dd)
        unifact := [dd * unif for unif in unifact]
        umd := unitNormal(dd).unit * ((dd**(nfact-1)::NNI)::P)*um
      else umd := um
      (ffin:=lifting(umd,lvar,unifact,lval,lpol,ldeg,pmod))
        case "failed" => intfact(um,lvar,ldeg,tleadpol,ltry,ufactor)
      factfin: L USP:=ffin :: L USP
      if dd^=1 then
        factfin:=[primitivePart ff for ff in factfin]
      factfin

                ----  m square-free,primitive,lc constant  ----
    mfconst(um:USP,lvar:L OV,ldeg:L NNI,ufactor:UFactor):L USP ==
      factfin:L USP:=empty()
      empty? lvar =>
        lum:=factors ufactor(map(ground,um)$UPCF2(P,USP,R,BP))
        [map(coerce,uf.factor)$UPCF2(R,BP,P,USP) for uf in lum]
      intfact(um,lvar,ldeg,[0,empty()]$MFinalFact,empty(),ufactor)

    monicize(um:USP,c:P):USP ==
      n:=degree(um)
      ans:USP := monomial(1,n)
      n:=(n-1)::NonNegativeInteger
      prod:P:=1
      while (um:=reductum(um)) ^= 0 repeat
        i := degree um
        lc := leadingCoefficient um
        prod := prod * c ** (n-(n:=i))::NonNegativeInteger
        ans := ans + monomial(prod*lc, i)
      ans

    unmonicize(m:USP,c:P):USP == primitivePart m(monomial(c,1))

              --- m is square-free,primitive,lc is a polynomial  ---
    monicMfpol(um:USP,lvar:L OV,ldeg:L NNI,ufactor:UFactor):L USP ==
      l := leadingCoefficient um
      monpol := monicize(um,l)
      nldeg := degree(monpol,lvar)
      map(unmonicize(#1,l),
                mfconst(monpol,lvar,nldeg,ufactor))

    mfpol(um:USP,lvar:L OV,ldeg:L NNI,ufactor:UFactor):L USP ==
      R has Field =>
        monicMfpol(um,lvar,ldeg,ufactor)
      tleadpol:=mFactor(leadingCoefficient um,ufactor)
      intfact(um,lvar,ldeg,tleadpol,[],ufactor)

    mFactor(m:P,ufactor:UFactor) : MFinalFact ==
      ground?(m) => [retract(m),empty()]$MFinalFact
      lvar:L OV:= variables m
      lcont:P
      lf:L USP
      flead : MFinalFact:=[0,empty()]$MFinalFact
      factorlist:L MParFact :=empty()

      lmdeg :=minimumDegree(m,lvar)     ---- is the Mindeg > 0? ----
      or/[n>0 for n in lmdeg] => simplify(m,lvar,lmdeg,ufactor)

      sqfacs := squareFree m
      lcont := unit sqfacs

                                  ----  Factorize the content  ----
      if ground? lcont then flead.contp:=retract lcont
      else flead:=mFactor(lcont,ufactor)
      factorlist:=flead.factors



                              ----  Make the polynomial square-free  ----
      sqqfact:=factors sqfacs

                       ---  Factorize the primitive square-free terms ---
      for fact in sqqfact repeat
        ffactor:P:=fact.factor
        ffexp := fact.exponent
        lvar := variables ffactor
        x:OV :=lvar.first
        ldeg:=degree(ffactor,lvar)
             ---  Is the polynomial linear in one of the variables ? ---
        member?(1,ldeg) =>
          x:OV:=lvar.position(1,ldeg)
          lcont:= gcd coefficients(univariate(ffactor,x))
          ffactor:=(ffactor exquo lcont)::P
          factorlist:=cons([ffactor,ffexp]$MParFact,factorlist)
          for lcterm in mFactor(lcont,ufactor).factors repeat
           factorlist:=cons([lcterm.irr,lcterm.pow * ffexp], factorlist)

        varch:=varChoose(ffactor,lvar,ldeg)
        um:=varch.npol

        x:=lvar.first
        ldeg:=ldeg.rest
        lvar := lvar.rest
        if varch.nvar.first ^= x then
          lvar:= varch.nvar
          x := lvar.first
          lvar := lvar.rest
        pc:= gcd coefficients um
        if pc^=1 then
            um:=(um exquo pc)::USP
            ffactor:=multivariate(um,x)
            for lcterm in mFactor(pc,ufactor).factors repeat
              factorlist:=cons([lcterm.irr,lcterm.pow*ffexp],factorlist)
        ldeg:=degree(ffactor,lvar)
        um := unitCanonical um
        if ground?(leadingCoefficient um) then
           lf:= mfconst(um,lvar,ldeg,ufactor)
        else lf:=mfpol(um,lvar,ldeg,ufactor)
        auxfl:=[[unitCanonical multivariate(lfp,x),ffexp]$MParFact  for lfp in lf]
        factorlist:=append(factorlist,auxfl)
      lcfacs := */[leadingCoefficient(f.irr)**((f.pow)::NNI) for f in factorlist]
      [(leadingCoefficient(m) exquo lcfacs):: R,factorlist]$MFinalFact

    factor(m:P,ufactor:UFactor):Factored P ==
      flist := mFactor(m,ufactor)
      (flist.contp):: P *
        (*/[primeFactor(u.irr,u.pow) for u in flist.factors])

@
<<INNMFACT.dotabb>>=
"INNMFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INNMFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INNMFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INBFF InnerNormalBasisFieldFunctions}
\pagehead{InnerNormalBasisFieldFunctions}{INBFF}
\pagepic{ps/v104innernormalbasisfieldfunctions.ps}{INBFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INBFF InnerNormalBasisFieldFunctions>>=
)abbrev package INBFF InnerNormalBasisFieldFunctions
++ Authors: J.Grabmeier, A.Scheerhorn
++ Date Created: 26.03.1991
++ Date Last Updated: 31 March 1991
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: finite field, normal basis
++ References:
++  R.Lidl, H.Niederreiter: Finite Field, Encyclopedia of Mathematics and
++   Its Applications, Vol. 20, Cambridge Univ. Press, 1983, ISBN 0 521 30240 4
++  D.R.Stinson: Some observations on parallel Algorithms for fast
++   exponentiation in GF(2^n), Siam J. Comp., Vol.19, No.4, pp.711-717,
++   August 1990
++  T.Itoh, S.Tsujii: A fast algorithm for computing multiplicative inverses
++   in GF(2^m) using normal bases, Inf. and Comp. 78, pp.171-177, 1988
++  J. Grabmeier, A. Scheerhorn: Finite Fields in AXIOM.
++   AXIOM Technical Report Series, ATR/5 NP2522.
++ Description:
++  InnerNormalBasisFieldFunctions(GF) (unexposed):
++  This package has functions used by
++  every normal basis finite field extension domain.

InnerNormalBasisFieldFunctions(GF): Exports == Implementation where
  GF    : FiniteFieldCategory       -- the ground field

  PI   ==> PositiveInteger
  NNI  ==> NonNegativeInteger
  I    ==> Integer
  SI   ==> SingleInteger
  SUP  ==> SparseUnivariatePolynomial
  VGF  ==> Vector GF
  M    ==> Matrix
  V    ==> Vector
  L    ==> List
  OUT  ==> OutputForm
  TERM ==> Record(value:GF,index:SI)
  MM   ==> ModMonic(GF,SUP GF)

  Exports ==> with

      setFieldInfo: (V L TERM,GF) -> Void
        ++ setFieldInfo(m,p) initializes the field arithmetic, where m is
        ++ the multiplication table and p is the respective normal element
        ++ of the ground field GF.
      random    : PI           -> VGF
        ++ random(n) creates a vector over the ground field with random entries.
      index     : (PI,PI)      -> VGF
        ++ index(n,m) is a index function for vectors of length n over
        ++ the ground field.
      pol       : VGF          -> SUP GF
        ++ pol(v) turns the vector \spad{[v0,...,vn]} into the polynomial
        ++ \spad{v0+v1*x+ ... + vn*x**n}.
      xn         : NNI          -> SUP GF
        ++ xn(n) returns the polynomial \spad{x**n-1}.
      dAndcExp  : (VGF,NNI,SI) -> VGF
        ++ dAndcExp(v,n,k) computes \spad{v**e} interpreting v as an element of
        ++ normal basis field. A divide and conquer algorithm similar to the
        ++ one from D.R.Stinson,
        ++ "Some observations on parallel Algorithms for fast exponentiation in
        ++ GF(2^n)", Siam J. Computation, Vol.19, No.4, pp.711-717, August 1990
        ++ is used. Argument k is a parameter of this algorithm.
      repSq     : (VGF,NNI)    -> VGF
        ++ repSq(v,e) computes \spad{v**e} by repeated squaring,
        ++ interpreting v as an element of a normal basis field.
      expPot    : (VGF,SI,SI)  -> VGF
        ++ expPot(v,e,d) returns the sum from \spad{i = 0} to
        ++ \spad{e - 1} of \spad{v**(q**i*d)}, interpreting
        ++ v as an element of a normal basis field and where q is
        ++ the size of the ground field.
        ++ Note: for a description of the algorithm, see T.Itoh and S.Tsujii,
        ++ "A fast algorithm for computing multiplicative inverses in GF(2^m)
        ++ using normal bases",
        ++ Information and Computation 78, pp.171-177, 1988.
      qPot      : (VGF,I)      -> VGF
        ++ qPot(v,e) computes \spad{v**(q**e)}, interpreting v as an element of
        ++ normal basis field, q the size of the ground field.
        ++ This is done by a cyclic e-shift of the vector v.

-- the semantic of the following functions is obvious from the finite field
-- context, for description see category FAXF
      "**"      :(VGF,I)       -> VGF
	++ x**n \undocumented{}
	++ See \axiomFunFrom{**}{DivisionRing}
      "*"       :(VGF,VGF)     -> VGF
	++ x*y \undocumented{}
	++ See \axiomFunFrom{*}{SemiGroup}
      "/"       :(VGF,VGF)     -> VGF
	++ x/y \undocumented{}
	++ See \axiomFunFrom{/}{Field}
      norm      :(VGF,PI)      -> VGF
	++ norm(x,n) \undocumented{}
	++ See \axiomFunFrom{norm}{FiniteAlgebraicExtensionField}
      trace     :(VGF,PI)      -> VGF
	++ trace(x,n) \undocumented{}
	++ See \axiomFunFrom{trace}{FiniteAlgebraicExtensionField}
      inv       : VGF          -> VGF
	++ inv x \undocumented{}
	++ See \axiomFunFrom{inv}{DivisionRing}
      lookup    : VGF          -> PI
	++ lookup(x) \undocumented{}
	++ See \axiomFunFrom{lookup}{Finite}
      normal?   : VGF          -> Boolean
	++ normal?(x) \undocumented{}
	++ See \axiomFunFrom{normal?}{FiniteAlgebraicExtensionField}
      basis     : PI           -> V VGF
	++ basis(n) \undocumented{}
	++ See \axiomFunFrom{basis}{FiniteAlgebraicExtensionField}
      normalElement:PI         -> VGF
	++ normalElement(n) \undocumented{}
	++ See \axiomFunFrom{normalElement}{FiniteAlgebraicExtensionField}
      minimalPolynomial: VGF   -> SUP GF
	++ minimalPolynomial(x) \undocumented{}
	++ See \axiomFunFrom{minimalPolynomial}{FiniteAlgebraicExtensionField}

  Implementation ==> add

-- global variables ===================================================

    sizeGF:NNI:=size()$GF
    -- the size of the ground field

    multTable:V L TERM:=new(1,nil()$(L TERM))$(V L TERM)
    -- global variable containing the multiplication table

    trGen:GF:=1$GF
    -- controls the imbedding of the ground field

    logq:List SI:=[0,10::SI,16::SI,20::SI,23::SI,0,28::SI,_
                             30::SI,32::SI,0,35::SI]
    -- logq.i is about 10*log2(i) for the values <12 which
    -- can match sizeGF. It's used by "**"

    expTable:L L SI:=[[],_
        [4::SI,12::SI,48::SI,160::SI,480::SI,0],_
        [8::SI,72::SI,432::SI,0],_
        [18::SI,216::SI,0],_
        [32::SI,480::SI,0],[],_
        [72::SI,0],[98::SI,0],[128::SI,0],[],[200::SI,0]]
    -- expT is used by "**" to optimize the parameter k
    -- before calling dAndcExp(..,..,k)

-- functions ===========================================================

--  computes a**(-1) = a**((q**extDeg)-2)
--  see reference of function expPot
    inv(a) ==
      b:VGF:=qPot(expPot(a,(#a-1)::NNI::SI,1::SI)$$,1)$$
      erg:VGF:=inv((a *$$ b).1 *$GF trGen)$GF *$VGF b

-- "**" decides which exponentiation algorithm will be used, in order to
-- get the fastest computation. If dAndcExp is used, it chooses the
-- optimal parameter k for that algorithm.
    a ** ex  ==
      e:NNI:=positiveRemainder(ex,sizeGF**((#a)::PI)-1)$I :: NNI
      zero?(e)$NNI => new(#a,trGen)$VGF
--      one?(e)$NNI  => copy(a)$VGF
      (e = 1)$NNI  => copy(a)$VGF
--    inGroundField?(a) => new(#a,((a.1*trGen) **$GF e))$VGF
      e1:SI:=(length(e)$I)::SI
      sizeGF >$I 11 =>
        q1:SI:=(length(sizeGF)$I)::SI
        logqe:SI:=(e1 quo$SI q1) +$SI 1$SI
        10::SI * (logqe + sizeGF-2) > 15::SI * e1 =>
--        print("repeatedSquaring"::OUT)
          repSq(a,e)
--      print("divAndConquer(a,e,1)"::OUT)
        dAndcExp(a,e,1)
      logqe:SI:=((10::SI *$SI e1) quo$SI (logq.sizeGF)) +$SI 1$SI
      k:SI:=1$SI
      expT:List SI:=expTable.sizeGF
      while (logqe >= expT.k) and not zero? expT.k repeat k:=k +$SI 1$SI
      mult:I:=(sizeGF-1) *$I sizeGF **$I ((k-1)pretend NNI) +$I_
              ((logqe +$SI k -$SI 1$SI) quo$SI k)::I -$I 2
      (10*mult) >= (15 * (e1::I)) =>
--      print("repeatedSquaring(a,e)"::OUT)
        repSq(a,e)
--    print(hconcat(["divAndConquer(a,e,"::OUT,k::OUT,")"::OUT])$OUT)
      dAndcExp(a,e,k)

-- computes a**e by repeated squaring
    repSq(b,e) ==
      a:=copy(b)$VGF
--      one? e => a
      (e = 1) => a
      odd?(e)$I => a * repSq(a*a,(e quo 2) pretend NNI)
      repSq(a*a,(e quo 2) pretend NNI)

-- computes a**e using the divide and conquer algorithm similar to the
-- one from D.R.Stinson,
-- "Some observations on parallel Algorithms for fast exponentiation in
-- GF(2^n)", Siam J. Computation, Vol.19, No.4, pp.711-717, August 1990
    dAndcExp(a,e,k) ==
      plist:List VGF:=[copy(a)$VGF]
      qk:I:=sizeGF**(k pretend NNI)
      for j in 2..(qk-1) repeat
        if positiveRemainder(j,sizeGF)=0 then b:=qPot(plist.(j quo sizeGF),1)$$
                            else b:=a *$$ last(plist)$(List VGF)
        plist:=concat(plist,b)
      l:List NNI:=nil()
      ex:I:=e
      while not(ex = 0) repeat
        l:=concat(l,positiveRemainder(ex,qk) pretend NNI)
        ex:=ex quo qk
      if first(l)=0 then erg:VGF:=new(#a,trGen)$VGF
                    else erg:VGF:=plist.(first(l))
      i:SI:=k
      for j in rest(l) repeat
        if j^=0 then erg:=erg *$$ qPot(plist.j,i)$$
        i:=i+k
      erg

    a * b ==
      e:SI:=(#a)::SI
      erg:=zero(#a)$VGF
      for t in multTable.1 repeat
        for j in 1..e repeat
          y:=t.value  -- didn't work without defining x and y
          x:=t.index
          k:SI:=addmod(x,j::SI,e)$SI +$SI 1$SI
          erg.k:=erg.k +$GF a.j *$GF b.j *$GF y
      for i in 1..e-1 repeat
        for j in i+1..e repeat
          for t in multTable.(j-i+1) repeat
            y:=t.value   -- didn't work without defining x and y
            x:=t.index
            k:SI:=addmod(x,i::SI,e)$SI +$SI 1$SI
            erg.k:GF:=erg.k +$GF (a.i *$GF b.j +$GF a.j *$GF b.i) *$GF y
      erg

    lookup(x) ==
      erg:I:=0
      for j in (#x)..1 by -1 repeat
        erg:=(erg * sizeGF) + (lookup(x.j)$GF rem sizeGF)
      erg=0 => (sizeGF**(#x)) :: PI
      erg :: PI

--  computes the norm of a over GF**d, d must devide extdeg
--  see reference of function expPot below
    norm(a,d) ==
      dSI:=d::SI
      r:=divide((#a)::SI,dSI)
      not(r.remainder = 0) => error "norm: 2.arg must divide extdeg"
      expPot(a,r.quotient,dSI)$$

--  computes expPot(a,e,d) = sum form i=0 to e-1 over a**(q**id))
--  see T.Itoh and S.Tsujii,
--  "A fast algorithm for computing multiplicative inverses in GF(2^m)
--   using normal bases",
--  Information and Computation 78, pp.171-177, 1988
    expPot(a,e,d) ==
      deg:SI:=(#a)::SI
      e=1 => copy(a)$VGF
      k2:SI:=d
      y:=copy(a)
      if bit?(e,0) then
        erg:=copy(y)
        qpot:SI:=k2
      else
        erg:=new(#a,inv(trGen)$GF)$VGF
        qpot:SI:=0
      for k in 1..length(e) repeat
        y:= y *$$ qPot(y,k2)
        k2:=addmod(k2,k2,deg)$SI
        if bit?(e,k) then
          erg:=erg *$$ qPot(y,qpot)
          qpot:=addmod(qpot,k2,deg)$SI
      erg

-- computes qPot(a,n) = a**(q**n), q=size of GF
    qPot(e,n) ==
      ei:=(#e)::SI
      m:SI:= positiveRemainder(n::SI,ei)$SI
      zero?(m) => e
      e1:=zero(#e)$VGF
      for i in m+1..ei repeat e1.i:=e.(i-m)
      for i in 1..m    repeat e1.i:=e.(ei+i-m)
      e1

    trace(a,d) ==
      dSI:=d::SI
      r:=divide((#a)::SI,dSI)$SI
      not(r.remainder = 0) => error "trace: 2.arg must divide extdeg"
      v:=copy(a.(1..dSI))$VGF
      sSI:SI:=r.quotient
      for i in 1..dSI repeat
        for j in 1..sSI-1 repeat
          v.i:=v.i+a.(i+j::SI*dSI)
      v

    random(n) ==
      v:=zero(n)$VGF
      for i in 1..n repeat v.i:=random()$GF
      v


    xn(m) == monomial(1,m)$(SUP GF) - 1$(SUP GF)

    normal?(x) ==
      gcd(xn(#x),pol(x))$(SUP GF) = 1 => true
      false

    x:VGF / y:VGF == x *$$ inv(y)$$


    setFieldInfo(m,n) ==
      multTable:=m
      trGen:=n
      void()$Void

    minimalPolynomial(x) ==
      dx:=#x
      y:=new(#x,inv(trGen)$GF)$VGF
      m:=zero(dx,dx+1)$(M GF)
      for i in 1..dx+1 repeat
        dy:=#y
        for j in 1..dy repeat
          for k in 0..((dx quo dy)-1) repeat
            qsetelt_!(m,j+k*dy,i,y.j)$(M GF)
        y:=y *$$ x
      v:=first nullSpace(m)$(M GF)
      pol(v)$$

    basis(n) ==
      bas:(V VGF):=new(n,zero(n)$VGF)$(V VGF)
      for i in 1..n repeat
        uniti:=zero(n)$VGF
        qsetelt_!(uniti,i,1$GF)$VGF
        qsetelt_!(bas,i,uniti)$(V VGF)
      bas

    normalElement(n) ==
       v:=zero(n)$VGF
       qsetelt_!(v,1,1$GF)
       v
--    normalElement(n) == index(n,1)$$

    index(degm,n) ==
      m:I:=n rem$I (sizeGF ** degm)
      erg:=zero(degm)$VGF
      for j in 1..degm repeat
        erg.j:=index((sizeGF+(m rem sizeGF)) pretend PI)$GF
        m:=m quo sizeGF
      erg

    pol(x) ==
      +/[monomial(x.i,(i-1)::NNI)$(SUP GF) for i in 1..(#x)::I]

@
<<INBFF.dotabb>>=
"INBFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INBFF"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"INBFF" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INEP InnerNumericEigenPackage}
\pagehead{InnerNumericEigenPackage}{INEP}
\pagepic{ps/v104innernumericeigenpackage.ps}{INEP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INEP InnerNumericEigenPackage>>=
)abbrev package INEP InnerNumericEigenPackage
++ Author:P. Gianni
++ Date Created: Summer 1990
++ Date Last Updated:Spring 1991
++ Basic Functions:
++ Related Constructors: ModularField
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package is the inner package to be used by NumericRealEigenPackage
++ and NumericComplexEigenPackage for the computation of numeric
++ eigenvalues and eigenvectors.
InnerNumericEigenPackage(K,F,Par) : C == T
 where
   F    :   Field  -- this is the field where the answer will be
                   -- for dealing with the complex case
   K    :   Field  -- type of the  input
   Par  :   Join(Field,OrderedRing)  -- it will be NF or RN

   SE    ==> Symbol()
   RN    ==> Fraction Integer
   I     ==> Integer
   NF    ==> Float
   CF    ==> Complex Float
   GRN   ==> Complex RN
   GI    ==> Complex Integer
   PI    ==> PositiveInteger
   NNI   ==> NonNegativeInteger
   MRN   ==> Matrix RN

   MK          ==> Matrix K
   PK          ==> Polynomial K
   MF          ==> Matrix F
   SUK         ==> SparseUnivariatePolynomial K
   SUF         ==> SparseUnivariatePolynomial F
   SUP         ==> SparseUnivariatePolynomial
   MSUK        ==> Matrix SUK

   PEigenForm  ==> Record(algpol:SUK,almult:Integer,poleigen:List(MSUK))

   outForm     ==> Record(outval:F,outmult:Integer,outvect:List MF)

   IntForm     ==> Union(outForm,PEigenForm)
   UFactor     ==> (SUK -> Factored SUK)
   C == with

     charpol  :  MK   ->  SUK
       ++ charpol(m) computes the characteristic polynomial of a matrix
       ++ m with entries in K.
       ++ This function returns a polynomial
       ++ over K, while the general one (that is in EiegenPackage) returns
       ++ Fraction P K

     solve1   : (SUK, Par) -> List F
       ++ solve1(pol, eps) finds the roots of the univariate polynomial
       ++ polynomial pol to precision eps. If K is \spad{Fraction Integer}
       ++ then only the real roots are returned, if K is
       ++ \spad{Complex Fraction Integer} then all roots are found.

     innerEigenvectors    : (MK,Par,UFactor)   ->  List(outForm)
       ++ innerEigenvectors(m,eps,factor) computes explicitly
       ++ the eigenvalues and the correspondent eigenvectors
       ++ of the matrix m. The parameter eps determines the type of
       ++ the output, factor is the univariate factorizer to br used
       ++ to reduce the characteristic polynomial into irreducible factors.

   T == add

     numeric(r:K):F ==
       K is RN =>
         F is NF => convert(r)$RN
         F is RN    => r
         F is CF    => r :: RN :: CF
         F is GRN   => r::RN::GRN
       K is GRN =>
         F is GRN => r
         F is CF  => convert(convert r)
       error "unsupported coefficient type"

    ---- next functions neeeded for defining  ModularField ----

     monicize(f:SUK) : SUK ==
       (a:=leadingCoefficient f) =1 => f
       inv(a)*f

     reduction(u:SUK,p:SUK):SUK == u rem p

     merge(p:SUK,q:SUK):Union(SUK,"failed") ==
         p = q => p
         p = 0 => q
         q = 0 => p
         "failed"

     exactquo(u:SUK,v:SUK,p:SUK):Union(SUK,"failed") ==
        val:=extendedEuclidean(v,p,u)
        val case "failed" => "failed"
        val.coef1

         ----  eval a vector of F in a radical expression  ----
     evalvect(vect:MSUK,alg:F) : MF ==
       n:=nrows vect
       w:MF:=zero(n,1)$MF
       for i in 1..n repeat
         polf:=map(numeric,
           vect(i,1))$UnivariatePolynomialCategoryFunctions2(K,SUK,F,SUF)
         v:F:=elt(polf,alg)
         setelt(w,i,1,v)
       w

       ---- internal function for the computation of eigenvectors  ----
     inteigen(A:MK,p:SUK,fact:UFactor) : List(IntForm) ==
       dimA:NNI:=  nrows A
       MM:=ModularField(SUK,SUK,reduction,merge,exactquo)
       AM:=Matrix(MM)
       lff:=factors fact(p)
       res: List IntForm  :=[]
       lr : List MF:=[]
       for ff in lff repeat
         pol:SUK:= ff.factor
         if (degree pol)=1 then
           alpha:K:=-coefficient(pol,0)/leadingCoefficient pol
           -- compute the eigenvectors, rational case
           B1:MK := zero(dimA,dimA)$MK
           for i in 1..dimA repeat
             for j in 1..dimA repeat B1(i,j):=A(i,j)
             B1(i,i):= B1(i,i) - alpha
           lr:=[]
           for vecr in nullSpace B1 repeat
             wf:MF:=zero(dimA,1)
             for i in 1..dimA repeat wf(i,1):=numeric vecr.i
             lr:=cons(wf,lr)
           res:=cons([numeric alpha,ff.exponent,lr]$outForm,res)
         else
           ppol:=monicize pol
           alg:MM:= reduce(monomial(1,1),ppol)
           B:AM:= zero(dimA,dimA)$AM
           for i in 1..dimA  repeat
             for j in 1..dimA repeat B(i,j):=reduce(A(i,j) ::SUK,ppol)
             B(i,i):=B(i,i) - alg
           sln2:=nullSpace B
           soln:List MSUK :=[]
           for vec in sln2 repeat
             wk:MSUK:=zero(dimA,1)
             for i in 1..dimA repeat wk(i,1):=(vec.i)::SUK
             soln:=cons(wk,soln)
           res:=cons([ff.factor,ff.exponent,soln]$PEigenForm,
                            res)
       res

     if K is RN then
         solve1(up:SUK, eps:Par) : List(F) ==
           denom := "lcm"/[denom(c::RN) for c in coefficients up]
           up:=denom*up
           upi := map(numer,up)$UnivariatePolynomialCategoryFunctions2(RN,SUP RN,I,SUP I)
           innerSolve1(upi, eps)$InnerNumericFloatSolvePackage(I,F,Par)
     else if K is GRN then
         solve1(up:SUK, eps:Par) : List(F) ==
           denom := "lcm"/[lcm(denom real(c::GRN), denom imag(c::GRN))
                                for c in coefficients up]
           up:=denom*up
           upgi := map(complex(numer(real #1), numer(imag #1)),
                      up)$UnivariatePolynomialCategoryFunctions2(GRN,SUP GRN,GI,SUP GI)
           innerSolve1(upgi, eps)$InnerNumericFloatSolvePackage(GI,F,Par)
     else error "unsupported matrix type"

          ----  the real eigenvectors expressed as floats  ----

     innerEigenvectors(A:MK,eps:Par,fact:UFactor) : List outForm ==
       pol:= charpol A
       sln1:List(IntForm):=inteigen(A,pol,fact)
       n:=nrows A
       sln:List(outForm):=[]
       for lev in sln1 repeat
         lev case outForm => sln:=cons(lev,sln)
         leva:=lev::PEigenForm
         lval:List(F):= solve1(leva.algpol,eps)
         lvect:=leva.poleigen
         lmult:=leva.almult
         for alg in lval repeat
           nsl:=[alg,lmult,[evalvect(ep,alg) for ep in lvect]]$outForm
           sln:=cons(nsl,sln)
       sln

     charpol(A:MK) : SUK ==
       dimA :PI := (nrows A):PI
       dimA ^= ncols A => error " The matrix is not square"
       B:Matrix SUK :=zero(dimA,dimA)
       for i in 1..dimA repeat
         for j in 1..dimA repeat  B(i,j):=A(i,j)::SUK
         B(i,i) := B(i,i) - monomial(1,1)$SUK
       determinant B


@
<<INEP.dotabb>>=
"INEP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INEP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"INEP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INFSP InnerNumericFloatSolvePackage}
\pagehead{InnerNumericFloatSolvePackage}{INFSP}
\pagepic{ps/v104innernumericfloatsolvepackage.ps}{INFSP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INFSP InnerNumericFloatSolvePackage>>=
)abbrev package INFSP InnerNumericFloatSolvePackage
++ Author: P. Gianni
++ Date Created: January 1990
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This is an internal package
++ for computing approximate solutions to systems of polynomial equations.
++ The parameter K specifies the coefficient field of the input polynomials
++ and must be either \spad{Fraction(Integer)} or \spad{Complex(Fraction Integer)}.
++ The parameter F specifies where the solutions must lie and can
++ be one of the following: \spad{Float}, \spad{Fraction(Integer)}, \spad{Complex(Float)},
++ \spad{Complex(Fraction Integer)}. The last parameter specifies the type
++ of the precision operand and must be either \spad{Fraction(Integer)} or \spad{Float}.
InnerNumericFloatSolvePackage(K,F,Par): Cat == Cap where
    F    :   Field  -- this is the field where the answer will be
    K    :   GcdDomain  -- type of the  input
    Par  :   Join(Field, OrderedRing ) -- it will be NF or RN

    I        ==> Integer
    NNI      ==> NonNegativeInteger
    P        ==> Polynomial
    EQ       ==> Equation
    L        ==> List
    SUP      ==> SparseUnivariatePolynomial
    RN       ==> Fraction Integer
    NF       ==> Float
    CF       ==> Complex Float
    GI       ==> Complex Integer
    GRN      ==> Complex RN
    SE       ==> Symbol
    RFI      ==> Fraction P I

    Cat == with

       innerSolve1   :  (SUP K,Par)  -> L F
          ++ innerSolve1(up,eps) returns the list of the zeros
          ++ of the univariate polynomial up with precision eps.
       innerSolve1   :  (P K,Par)  -> L F
          ++ innerSolve1(p,eps) returns the list of the zeros
          ++ of the polynomial p with precision eps.
       innerSolve    : (L P K,L P K,L SE,Par) -> L L F
          ++ innerSolve(lnum,lden,lvar,eps) returns a list of
          ++ solutions of the system of polynomials lnum, with
          ++ the side condition that none of the members of lden
          ++ vanish identically on any solution. Each solution
          ++ is expressed as a list corresponding to the list of
          ++ variables in lvar and with precision specified by eps.
       makeEq        : (L F,L SE)     -> L EQ P F
          ++ makeEq(lsol,lvar) returns a list of equations formed
          ++ by corresponding members of lvar and lsol.

    Cap == add

                  ------  Local Functions  ------
       isGeneric? : (L P K,L SE) -> Boolean
       evaluate  : (P K,SE,SE,F) ->  F
       numeric   :     K          -> F
       oldCoord      : (L F,L I) -> L F
       findGenZeros  : (L P K,L SE,Par) -> L L F
       failPolSolve  : (L P K,L SE)  -> Union(L L P K,"failed")

       numeric(r:K):F ==
         K is I =>
           F is Float => r::I::Float
           F is RN    => r::I::RN
           F is CF    => r::I::CF
           F is GRN   => r::I::GRN
         K is GI =>
           gr:GI := r::GI
           F is GRN => complex(real(gr)::RN,imag(gr)::RN)$GRN
           F is CF  => convert(gr)
         error "case not handled"

       -- construct the equation
       makeEq(nres:L F,lv:L SE) : L EQ P F ==
           [equation(x::(P F),r::(P F)) for x in lv for r in nres]

       evaluate(pol:P K,xvar:SE,zvar:SE,z:F):F ==
         rpp:=map(numeric,pol)$PolynomialFunctions2(K,F)
         rpp := eval(rpp,zvar,z)
         upol:=univariate(rpp,xvar)
         retract(-coefficient(upol,0))/retract(leadingCoefficient upol)

       myConvert(eps:Par) : RN ==
         Par is RN => eps
         Par is NF => retract(eps)$NF

       innerSolve1(pol:P K,eps:Par) : L F == innerSolve1(univariate pol,eps)

       innerSolve1(upol:SUP K,eps:Par) : L F ==
         K is GI and (Par is RN or Par is NF) =>
             (complexZeros(upol,
                        eps)$ComplexRootPackage(SUP K,Par)) pretend L(F)
         K is I =>
           F is Float =>
             z:= realZeros(upol,myConvert eps)$RealZeroPackage(SUP I)
             [convert((1/2)*(x.left+x.right))@Float for x in z] pretend L(F)

           F is RN =>
             z:= realZeros(upol,myConvert eps)$RealZeroPackage(SUP I)
             [(1/2)*(x.left + x.right) for x in z] pretend L(F)
           error "improper arguments to INFSP"
         error "improper arguments to INFSP"


       -- find the zeros of components in "generic" position --
       findGenZeros(lp:L P K,rlvar:L SE,eps:Par) : L L F ==
         rlp:=reverse lp
         f:=rlp.first
         zvar:= rlvar.first
         rlp:=rlp.rest
         lz:=innerSolve1(f,eps)
         [reverse cons(z,[evaluate(pol,xvar,zvar,z) for pol in rlp
                         for xvar in rlvar.rest]) for z in lz]

       -- convert to the old coordinates --
       oldCoord(numres:L F,lval:L I) : L F ==
         rnumres:=reverse numres
         rnumres.first:= rnumres.first +
            (+/[n*nr for n in lval for nr in rnumres.rest])
         reverse rnumres

       -- real zeros of a system of 2 polynomials lp (incomplete)
       innerSolve2(lp:L P K,lv:L SE,eps: Par):L L F ==
          mainvar := first lv
          up1:=univariate(lp.1, mainvar)
          up2:=univariate(lp.2, mainvar)
          vec := subresultantVector(up1,up2)$SubResultantPackage(P K,SUP P K)
          p0 := primitivePart multivariate(vec.0, mainvar)
          p1 := primitivePart(multivariate(vec.1, mainvar),mainvar)
          zero? p1 or
            gcd(p0, leadingCoefficient(univariate(p1,mainvar))) ^=1 =>
              innerSolve(cons(0,lp),empty(),lv,eps)
          findGenZeros([p1, p0], reverse lv, eps)

       -- real zeros of the system of polynomial lp --
       innerSolve(lp:L P K,ld:L P K,lv:L SE,eps: Par) : L L F ==
          -- empty?(ld) and (#lv = 2) and (# lp = 2) => innerSolve2(lp, lv, eps)
           lnp:= [pToDmp(p)$PolToPol(lv,K) for p in lp]
           OV:=OrderedVariableList(lv)
           lvv:L OV:= [variable(vv)::OV for vv in lv]
           DP:=DirectProduct(#lv,NonNegativeInteger)
           dmp:=DistributedMultivariatePolynomial(lv,K)
           lq:L dmp:=[]
           if ld^=[] then
             lq:= [(pToDmp(q1)$PolToPol(lv,K)) pretend dmp for q1 in ld]
           partRes:=groebSolve(lnp,lvv)$GroebnerSolve(lv,K,K) pretend (L L dmp)
           partRes=list [] => []
           -- remove components where denominators vanish
           if lq^=[] then
             gb:=GroebnerInternalPackage(K,DirectProduct(#lv,NNI),OV,dmp)
             partRes:=[pr for pr in partRes|
                       and/[(redPol(fq,pr pretend List(dmp))$gb) ^=0
                         for fq in lq]]

           -- select the components in "generic" form
           rlv:=reverse lv
           rrlvv:= rest reverse lvv

           listGen:L L dmp:=[]
           for res in partRes repeat
             res1:=rest reverse res
             "and"/[("max"/degree(f,rrlvv))=1  for f in res1] =>
                      listGen:=concat(res pretend (L dmp),listGen)
           result:L L F := []
           if listGen^=[] then
             listG :L L P K:=
               [[dmpToP(pf)$PolToPol(lv,K) for pf in pr] for pr in listGen]
             result:=
               "append"/[findGenZeros(res,rlv,eps) for res in listG]
             for gres in listGen repeat
                partRes:=delete(partRes,position(gres,partRes))
           -- adjust the non-generic components
           for gres in partRes repeat
               genRecord := genericPosition(gres,lvv)$GroebnerSolve(lv,K,K)
               lgen := genRecord.dpolys
               lval := genRecord.coords
               lgen1:=[dmpToP(pf)$PolToPol(lv,K) for pf in lgen]
               lris:=findGenZeros(lgen1,rlv,eps)
               result:= append([oldCoord(r,lval) for r in lris],result)
           result

@
<<INFSP.dotabb>>=
"INFSP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INFSP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"INFSP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ITRIGMNP InnerTrigonometricManipulations}
\pagehead{InnerTrigonometricManipulations}{ITRIGMNP}
\pagepic{ps/v104innertrigonometricmanipulations.ps}{ITRIGMNP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ITRIGMNP InnerTrigonometricManipulations>>=
)abbrev package ITRIGMNP InnerTrigonometricManipulations
++ Trigs to/from exps and logs
++ Author: Manuel Bronstein
++ Date Created: 4 April 1988
++ Date Last Updated: 9 October 1993
++ Description:
++   This package provides transformations from trigonometric functions
++   to exponentials and logarithms, and back.
++   F and FG should be the same type of function space.
++ Keywords: trigonometric, function, manipulation.
InnerTrigonometricManipulations(R,F,FG): Exports == Implementation where
  R  : Join(IntegralDomain, OrderedSet)
  F  : Join(FunctionSpace R, RadicalCategory,
            TranscendentalFunctionCategory)
  FG : Join(FunctionSpace Complex R, RadicalCategory,
            TranscendentalFunctionCategory)

  Z   ==> Integer
  SY  ==> Symbol
  OP  ==> BasicOperator
  GR  ==> Complex R
  GF  ==> Complex F
  KG  ==> Kernel FG
  PG  ==> SparseMultivariatePolynomial(GR, KG)
  UP  ==> SparseUnivariatePolynomial PG
  NTHR  ==> "nthRoot"::SY

  Exports ==> with
    GF2FG        : GF -> FG
      ++ GF2FG(a + i b) returns \spad{a + i b} viewed as a function with
      ++ the \spad{i} pushed down into the coefficient domain.
    FG2F         : FG -> F
      ++ FG2F(a + i b) returns \spad{a + sqrt(-1) b}.
    F2FG         : F  -> FG
      ++ F2FG(a + sqrt(-1) b) returns \spad{a + i b}.
    explogs2trigs: FG -> GF
      ++ explogs2trigs(f) rewrites all the complex logs and
      ++ exponentials appearing in \spad{f} in terms of trigonometric
      ++ functions.
    trigs2explogs: (FG, List KG, List SY) -> FG
      ++ trigs2explogs(f, [k1,...,kn], [x1,...,xm]) rewrites
      ++ all the trigonometric functions appearing in \spad{f} and involving
      ++ one of the \spad{xi's} in terms of complex logarithms and
      ++ exponentials. A kernel of the form \spad{tan(u)} is expressed
      ++ using \spad{exp(u)**2} if it is one of the \spad{ki's}, in terms of
      ++ \spad{exp(2*u)} otherwise.

  Implementation ==> add
    ker2explogs: (KG, List KG, List SY) -> FG
    smp2explogs: (PG, List KG, List SY) -> FG
    supexp     : (UP, GF, GF, Z) -> GF
    GR2GF      : GR -> GF
    GR2F       : GR -> F
    KG2F       : KG -> F
    PG2F       : PG -> F
    ker2trigs  : (OP, List GF) -> GF
    smp2trigs  : PG -> GF
    sup2trigs  : (UP, GF) -> GF

    nth := R has RetractableTo(Integer) and F has RadicalCategory

    GR2F g        == real(g)::F + sqrt(-(1::F)) * imag(g)::F
    KG2F k        == map(FG2F, k)$ExpressionSpaceFunctions2(FG, F)
    FG2F f        == (PG2F numer f) / (PG2F denom f)
    F2FG f        == map(#1::GR, f)$FunctionSpaceFunctions2(R,F,GR,FG)
    GF2FG f       == (F2FG real f) + complex(0, 1)$GR ::FG * F2FG imag f
    GR2GF gr      == complex(real(gr)::F, imag(gr)::F)

-- This expects the argument to have only tan and atans left.
-- Does a half-angle correction if k is not in the initial kernel list.
    ker2explogs(k, l, lx) ==
      empty?([v for v in variables(kf := k::FG) |
                                         member?(v, lx)]$List(SY)) => kf
      empty?(args := [trigs2explogs(a, l, lx)
                                    for a in argument k]$List(FG)) => kf
      im := complex(0, 1)$GR :: FG
      z  := first args
      is?(k, "tan"::Symbol)  =>
        e := (member?(k, l) => exp(im * z) ** 2;  exp(2 * im * z))
        - im * (e - 1) /$FG (e + 1)
      is?(k, "atan"::Symbol) =>
        im * log((1 -$FG im *$FG z)/$FG (1 +$FG im *$FG z))$FG / (2::FG)
      (operator k) args

    trigs2explogs(f, l, lx) ==
      smp2explogs(numer f, l, lx) / smp2explogs(denom f, l, lx)

    -- return op(arg) as f + %i g
    -- op is already an operator with semantics over R, not GR
    ker2trigs(op, arg) ==
      "and"/[zero? imag x for x in arg] =>
        complex(op [real x for x in arg]$List(F), 0)
      a := first arg
      is?(op, "exp"::Symbol)  => exp a
      is?(op, "log"::Symbol)  => log a
      is?(op, "sin"::Symbol)  => sin a
      is?(op, "cos"::Symbol)  => cos a
      is?(op, "tan"::Symbol)  => tan a
      is?(op, "cot"::Symbol)  => cot a
      is?(op, "sec"::Symbol)  => sec a
      is?(op, "csc"::Symbol)  => csc a
      is?(op, "asin"::Symbol)  => asin a
      is?(op, "acos"::Symbol)  => acos a
      is?(op, "atan"::Symbol)  => atan a
      is?(op, "acot"::Symbol)  => acot a
      is?(op, "asec"::Symbol)  => asec a
      is?(op, "acsc"::Symbol)  => acsc a
      is?(op, "sinh"::Symbol)  => sinh a
      is?(op, "cosh"::Symbol)  => cosh a
      is?(op, "tanh"::Symbol)  => tanh a
      is?(op, "coth"::Symbol)  => coth a
      is?(op, "sech"::Symbol)  => sech a
      is?(op, "csch"::Symbol)  => csch a
      is?(op, "asinh"::Symbol)  => asinh a
      is?(op, "acosh"::Symbol)  => acosh a
      is?(op, "atanh"::Symbol)  => atanh a
      is?(op, "acoth"::Symbol)  => acoth a
      is?(op, "asech"::Symbol)  => asech a
      is?(op, "acsch"::Symbol)  => acsch a
      is?(op, "abs"::Symbol)    => sqrt(norm a)::GF
      nth and is?(op, NTHR) => nthRoot(a, retract(second arg)@Z)
      error "ker2trigs: cannot convert kernel to gaussian function"

    sup2trigs(p, f) ==
      map(smp2trigs, p)$SparseUnivariatePolynomialFunctions2(PG, GF) f

    smp2trigs p ==
      map(explogs2trigs(#1::FG),GR2GF, p)$PolynomialCategoryLifting(
                                    IndexedExponents KG, KG, GR, PG, GF)

    explogs2trigs f ==
      (m := mainKernel f) case "failed" =>
        GR2GF(retract(numer f)@GR) / GR2GF(retract(denom f)@GR)
      op  := operator(operator(k := m::KG))$F
      arg := [explogs2trigs x for x in argument k]
      num := univariate(numer f, k)
      den := univariate(denom f, k)
      is?(op, "exp"::Symbol) =>
        e  := exp real first arg
        y  := imag first arg
        g  := complex(e *  cos y, e * sin y)$GF
        gi := complex(cos(y) / e, - sin(y) / e)$GF
        supexp(num,g,gi,b := (degree num)::Z quo 2)/supexp(den,g,gi,b)
      sup2trigs(num, g := ker2trigs(op, arg)) / sup2trigs(den, g)

    supexp(p, f1, f2, bse) ==
      ans:GF := 0
      while p ^= 0 repeat
        g := explogs2trigs(leadingCoefficient(p)::FG)
        if ((d := degree(p)::Z - bse) >= 0) then
             ans := ans + g * f1 ** d
        else ans := ans + g * f2 ** (-d)
        p := reductum p
      ans

    PG2F p ==
      map(KG2F, GR2F, p)$PolynomialCategoryLifting(IndexedExponents KG,
                                                          KG, GR, PG, F)

    smp2explogs(p, l, lx) ==
      map(ker2explogs(#1, l, lx), #1::FG, p)$PolynomialCategoryLifting(
                                    IndexedExponents KG, KG, GR, PG, FG)

@
<<ITRIGMNP.dotabb>>=
"ITRIGMNP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ITRIGMNP"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"ITRIGMNP" -> "FS"
"ITRIGMNP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INFORM1 InputFormFunctions1}
\pagehead{InputFormFunctions1}{INFORM1}
\pagepic{ps/v104inputformfunctions1.ps}{INFORM1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INFORM1 InputFormFunctions1>>=
)abbrev package INFORM1 InputFormFunctions1
--)boot $noSubsumption := false

++ Tools for manipulating input forms
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 19 April 1991
++ Description: Tools for manipulating input forms.

InputFormFunctions1(R:Type):with
  packageCall: Symbol -> InputForm
    ++ packageCall(f) returns the input form corresponding to f$R.
  interpret  : InputForm -> R
    ++ interpret(f) passes f to the interpreter, and transforms
    ++ the result into an object of type R.
 == add
  Rname := devaluate(R)$Lisp :: InputForm

  packageCall name ==
    convert([convert("$elt"::Symbol), Rname,
                                convert name]$List(InputForm))@InputForm

  interpret form ==
    retract(interpret(convert([convert("@"::Symbol), form,
          Rname]$List(InputForm))@InputForm)$InputForm)$AnyFunctions1(R)

@
<<INFORM1.dotabb>>=
"INFORM1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INFORM1"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"INFORM1" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package COMBINAT IntegerCombinatoricFunctions}
\pagehead{IntegerCombinatoricFunctions}{COMBINAT}
\pagepic{ps/v104integercombinatoricfunctions.ps}{COMBINAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package COMBINAT IntegerCombinatoricFunctions>>=
)abbrev package COMBINAT IntegerCombinatoricFunctions
++ Authors: Martin Brock, Robert Sutor, Michael Monagan
++ Date Created: June 1987
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: integer, combinatoric function
++ Examples:
++ References:
++ Description:
++   The \spadtype{IntegerCombinatoricFunctions} package provides some
++   standard functions in combinatorics.
Z   ==> Integer
N   ==> NonNegativeInteger
SUP ==> SparseUnivariatePolynomial

IntegerCombinatoricFunctions(I:IntegerNumberSystem): with
   binomial: (I, I) -> I
      ++ \spad{binomial(n,r)} returns the binomial coefficient
      ++ \spad{C(n,r) = n!/(r! (n-r)!)}, where \spad{n >= r >= 0}.
      ++ This is the number of combinations of n objects taken r at a time.
   factorial: I -> I
      ++ \spad{factorial(n)} returns \spad{n!}. this is the product of all
      ++ integers between 1 and n (inclusive). 
      ++ Note: \spad{0!} is defined to be 1.
   multinomial: (I, List I) -> I
      ++ \spad{multinomial(n,[m1,m2,...,mk])} returns the multinomial
      ++ coefficient \spad{n!/(m1! m2! ... mk!)}.
   partition: I -> I
      ++ \spad{partition(n)} returns the number of partitions of the integer n.
      ++ This is the number of distinct ways that n can be written as
      ++ a sum of positive integers.
   permutation: (I, I) -> I
      ++ \spad{permutation(n)} returns \spad{!P(n,r) = n!/(n-r)!}. This is
      ++ the number of permutations of n objects taken r at a time.
   stirling1: (I, I) -> I
      ++ \spad{stirling1(n,m)} returns the Stirling number of the first kind
      ++ denoted \spad{S[n,m]}.
   stirling2: (I, I) -> I
      ++ \spad{stirling2(n,m)} returns the Stirling number of the second kind
      ++ denoted \spad{SS[n,m]}.
 == add
   F : Record(Fn:I, Fv:I) := [0,1]
   B : Record(Bn:I, Bm:I, Bv:I) := [0,0,0]
   S : Record(Sn:I, Sp:SUP I) := [0,0]
   P : IndexedFlexibleArray(I,0) := new(1,1)$IndexedFlexibleArray(I,0)
 
   partition n ==
      -- This is the number of ways of expressing n as a sum of positive
      -- integers, without regard to order.  For example partition 5 = 7
      -- since 5 = 1+1+1+1+1 = 1+1+1+2 = 1+2+2 = 1+1+3 = 1+4 = 2+3 = 5 .
      -- Uses O(sqrt n) term recurrence from Abramowitz & Stegun pp. 825
      -- p(n) = sum (-1)**k p(n-j) where 0 < j := (3*k**2+-k) quo 2 <= n
      minIndex(P) ^= 0 => error "Partition: must have minIndex of 0"
      m := #P
      n < 0 => error "partition is not defined for negative integers"
      n < m::I => P(convert(n)@Z)
      concat_!(P, new((convert(n+1)@Z - m)::N,0)$IndexedFlexibleArray(I,0))
      for i in m..convert(n)@Z repeat
         s:I := 1
         t:I := 0
         for k in 1.. repeat
            l := (3*k*k-k) quo 2
            l > i => leave
            u := l+k
            t := t + s * P(convert(i-l)@Z)
            u > i => leave
            t := t + s * P(convert(i-u)@Z)
            s := -s
         P.i := t
      P(convert(n)@Z)
 
   factorial n ==
      s,f,t : I
      n < 0 => error "factorial not defined for negative integers"
      if n <= F.Fn then s := f := 1 else (s, f) := F
      for k in convert(s+1)@Z .. convert(n)@Z by 2 repeat
         if k::I = n then t := n else t := k::I * (k+1)::I
         f := t * f
      F.Fn := n
      F.Fv := f
 
   binomial(n, m) ==
      s,b:I
      n < 0 or m < 0 or m > n => 0
      m = 0 => 1
      n < 2*m => binomial(n, n-m)
      (s,b) := (0,1)
      if B.Bn = n then
         B.Bm = m+1 =>
            b := (B.Bv * (m+1)) quo (n-m)
            B.Bn := n
            B.Bm := m
            return(B.Bv := b)
         if m >= B.Bm then (s := B.Bm; b := B.Bv) else (s,b) := (0,1)
      for k in convert(s+1)@Z .. convert(m)@Z repeat
        b := (b*(n-k::I+1)) quo k::I
      B.Bn := n
      B.Bm := m
      B.Bv := b
 
   multinomial(n, m) ==
      for t in m repeat t < 0 => return 0
      n < _+/m => 0
      s:I := 1
      for t in m repeat s := s * factorial t
      factorial n quo s
 
   permutation(n, m) ==
      t:I
      m < 0 or n < m => 0
      m := n-m
      p:I := 1
      for k in convert(m+1)@Z .. convert(n)@Z by 2 repeat
         if k::I = n then t := n else t := (k*(k+1))::I
         p := p * t
      p
 
   stirling1(n, m) ==
      -- Definition: (-1)**(n-m) S[n,m] is the number of
      -- permutations of n symbols which have m cycles.
      n < 0 or m < 1 or m > n => 0
      m = n => 1
      S.Sn = n => coefficient(S.Sp, convert(m)@Z :: N)
      x := monomial(1, 1)$SUP(I)
      S.Sn := n
      S.Sp := x
      for k in 1 .. convert(n-1)@Z repeat S.Sp := S.Sp * (x - k::SUP(I))
      coefficient(S.Sp, convert(m)@Z :: N)
 
   stirling2(n, m) ==
      -- definition: SS[n,m] is the number of ways of partitioning
      -- a set of n elements into m non-empty subsets
      n < 0 or m < 1 or m > n => 0
      m = 1 or n = m => 1
      s:I := if odd? m then -1 else 1
      t:I := 0
      for k in 1..convert(m)@Z repeat
         s := -s
         t := t + s * binomial(m, k::I) * k::I ** (convert(n)@Z :: N)
      t quo factorial m

@
<<COMBINAT.dotabb>>=
"COMBINAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=COMBINAT"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"COMBINAT" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTFACT IntegerFactorizationPackage}
\pagehead{IntegerFactorizationPackage}{INTFACT}
\pagepic{ps/v104integerfactorizationpackage.ps}{INTFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTFACT IntegerFactorizationPackage>>=
)abbrev package INTFACT IntegerFactorizationPackage
++ This Package contains basic methods for integer factorization.
++ The factor operation employs trial division up to 10,000.  It
++ then tests to see if n is a perfect power before using Pollards
++ rho method.  Because Pollards method may fail, the result
++ of factor may contain composite factors.  We should also employ
++ Lenstra's eliptic curve method.

IntegerFactorizationPackage(I): Exports == Implementation where
  I: IntegerNumberSystem

  B      ==> Boolean
  FF     ==> Factored I
  NNI    ==> NonNegativeInteger
  LMI    ==> ListMultiDictionary I
  FFE    ==> Record(flg:Union("nil","sqfr","irred","prime"),
                                                   fctr:I, xpnt:Integer)

  Exports ==>  with
    factor : I -> FF
      ++ factor(n) returns the full factorization of integer n
    squareFree   : I -> FF
      ++ squareFree(n) returns the square free factorization of integer n
    BasicMethod : I -> FF
      ++ BasicMethod(n) returns the factorization
      ++ of integer n by trial division
    PollardSmallFactor: I -> Union(I,"failed")
       ++ PollardSmallFactor(n) returns a factor
       ++ of n or "failed" if no one is found

  Implementation ==> add
    import IntegerRoots(I)
    
    BasicSieve: (I, I) -> FF

@
\subsection{squareFree}
<<package INTFACT IntegerFactorizationPackage>>=
    squareFree(n:I):FF ==
       u:I
       if n<0 then (m := -n; u := -1)
              else (m := n; u := 1)
       (m > 1) and ((v := perfectSqrt m) case I) =>
          for rec in (l := factorList(sv := squareFree(v::I))) repeat
            rec.xpnt := 2 * rec.xpnt
          makeFR(u * unit sv, l)
    -- avoid using basic sieve when the lim is too big
    -- we know the sieve constants up to sqrt(100000000)
       lim := 1 + approxSqrt(m)
       lim > (100000000::I) => makeFR(u, factorList factor m)
       x := BasicSieve(m, lim)
       y :=
         ((m:= unit x) = 1) => factorList x
         (v := perfectSqrt m) case I => 
            concat_!(factorList x, ["sqfr",v,2]$FFE)
         concat_!(factorList x, ["sqfr",m,1]$FFE)
       makeFR(u, y)

@
\subsection{PollardSmallFactor}
This is Brent's\cite{1} optimization of Pollard's\cite{2} rho factoring.
Brent's algorithm is about 24 percent faster than Pollard's. Pollard;s
algorithm has complexity $O(p^{1/2})$ where $p$ is the smallest prime
factor of the composite number $N$.

Pollard's idea is based on the observation that two numbers $x$ and $y$
are congruent modulo $p$ with probability 0.5 after $1.177*\sqrt{p}$ numbers
have been randomly chosen. If we try to factor $n$ and $p$ is a factor of 
$n$, then
$$1 < gcd(\vert x-y\vert,n) \le n$$ since $p$ divides both $\vert x-y\vert$
and $n$.

Given a function $f$ which generates a pseudo-random sequence of numbers
we allow $x$ to walk the sequence in order and $y$ to walk the sequence
at twice the rate. At each cycle we compute $gcd(\vert x-y\vert,n)$.
If this GCD ever equals $n$ then $x=y$ which means that we have walked
"all the way around the pseudo-random cycle" and we terminate with failure.

This algorithm returns failure on all primes but also fails on some
composite numbers.

Quoting Brent's back-tracking idea:
\begin{quote}
The best-known algorithm for finding GCDs is the Euclidean algorithm
which takes $O(\log N)$ times as long as one multiplication mod $N$. Pollard
showed that most of the GCD computations in Floyd's algorithm could be
dispensed with. ... The idea is simple: if $P_F$ computes $GCD(z_1,N)$, 
$GCD(z_2,N)$,$\ldots$, then we compute
$$q_i=\prod_{j=1}^i{z_j}(\textrm{mod }N)$$
and only compute $GCD(q_i,N)$ when $i$ is a multiple of $m$, where
$\log N < < m < < N^{1/4}$. Since $q_{i+1}=q_i \times z_{i+1}(\textrm{mod }N)$,
the work required for each GCD computation in algorithm $P_F$ is effectively
reduced to that for a multiplication mod $N$ in the modified algorithm.
The probability of the algorithm failing because $q_i=0$ increases, so it
is best not to choose $m$ too large. This problem can be minimized by
backtracking to the state after the previous GCD computation and setting
$m=1$.
\end{quote}
Brent incorporates back-tracking, omits the random choice of u, and
makes some minor modifications. His algorithm (p192-183) reads:

\noindent
$y:=x_0; r:=1; q:=1;$

\noindent
\hbox{\hskip 0.5cm}{\bf repeat} $x:=y;$

\noindent
\hbox{\hskip 1.0cm}{\bf for} $i:=1$ {\bf to} $r$ {\bf do} $y:=f(y); k:=0;$

\noindent
\hbox{\hskip 1.0cm}{\bf repeat} $ys:=y;$

\noindent
\hbox{\hskip 1.5cm}{\bf for} $i:=1$ {\bf to} $min(m,r-k)$ {\bf do}

\noindent
\hbox{\hskip 2.0cm}{\bf begin} $y:=f(y); q:=q*\vert x-y\vert mod N$

\noindent
\hbox{\hskip 2.0cm}{\bf end};

\noindent
\hbox{\hskip 1.5cm}$G:=GCD(q,N); k:=k+m$

\noindent
\hbox{\hskip 1.0cm}{\bf until} $(k \ge r)$ {\bf or} $(G > 1); r:=2*r$

\noindent
\hbox{\hskip 0.5cm}{\bf until} $G > 1$;

\noindent
\hbox{\hskip 0.5cm}{\bf if} $G=N$ {\bf then}

\noindent
\hbox{\hskip 1.0cm}{\bf repeat} $ys:=f(ys); G:=GCD(\vert y-yx\vert,N)$

\noindent
\hbox{\hskip 1.0cm}{\bf until} $G > 1$;

\noindent
\hbox{\hskip 0.5cm}{\bf if} $G=N$ {\bf then} failure {\bf else} success

Here we use the function
$$(y*y+5::I)~{\textrm rem}~ n$$
as our pseudo-random sequence with a random starting value for y.

On possible optimization to explore is to keep a hash table for the
computed values of the function $y_{i+1}:=f(y_i)$ since we effectively
walk the sequence several times. And we walk the sequence in a loop
many times.  But because we are generating a very large number of
numbers the array can be a simple array of fixed size that captures
the last n values. So if we make a fixed array F of, say $2^q$
elements we can store $f(y_i)$ in F[$y_i$ mod $2^q$].

One property that this algorithm assumes is that the function used
to generate the numbers has a long, hopefully complete, period. It
is not clear that the recommended function has that property.

<<package INTFACT IntegerFactorizationPackage>>=
    PollardSmallFactor(n:I):Union(I,"failed") ==
       -- Use the Brent variation
       x0 := random()$I
       m := 100::I
       y := x0 rem n
       r:I := 1
       q:I := 1
       G:I := 1
       until G > 1 repeat
          x := y
          for i in 1..convert(r)@Integer repeat
             y := (y*y+5::I) rem n
             k:I := 0
          until (k>=r) or (G>1) repeat
             ys := y
             for i in 1..convert(min(m,r-k))@Integer repeat
                y := (y*y+5::I) rem n
                q := q*abs(x-y) rem n
             G := gcd(q,n)
             k := k+m
          r := 2*r
       if G=n then
          until G>1 repeat
             ys := (ys*ys+5::I) rem n
             G := gcd(abs(x-ys),n)
       G=n => "failed"
       G

@
\subsection{BasicSieve}
We create a list of prime numbers up to the limit given. The prior code
used a circular list but tests of that list show that on average more
than 50% of those numbers are not prime. Now we call primes to generate
the required prime numbers. Overall this is a small percentage of the
time needed to factor.

This loop uses three pieces of information
\begin{enumerate}
\item n which is the number we are testing
\item d which is the current prime to test
\item lim which is the upper limit of the primes to test
\end{enumerate}

We loop d over the list of primes. If the remaining number n is
smaller than the square of d then n must be prime and if it is
not one, we add it to the list of primes. If the remaining number
is larger than the square of d we remove all factors of d, reducing
n each time. Then we add a record of the new factor and its multiplicity, m.
We continue the loop until we run out of primes.

Annoyingly enough, primes does not return an ordered list so we fix this.

The sieve works up to a given limit, reducing out the factors that it
finds. If it can find all of the factors than it returns a factored
result where the first element is the unit 1. If there is still a 
part of the number unfactored it returns the number and a list of
the factors found and their multiplicity.

Basically we just loop thru the prime factors checking to see if
they are a component of the number, n. If so, we remove the factor from
the number n (possibly m times) and continue thru the list of primes.
<<package INTFACT IntegerFactorizationPackage>>=
    BasicSieve(n, lim) ==
       p:=primes(1::I,lim::I)$IntegerPrimesPackage(I)
       l:List(I) := append([first p],reverse rest p)
       ls := empty()$List(FFE)
       for d in l repeat
          if n<d*d then
             if n>1 then ls := concat_!(ls, ["prime",n,1]$FFE)
             return makeFR(1, ls)
          for m in 0.. while zero?(n rem d) repeat n := n quo d
          if m>0 then ls := concat_!(ls, ["prime",d,convert m]$FFE)
       makeFR(n,ls)

@
\subsection{BasicMethod}
<<package INTFACT IntegerFactorizationPackage>>=
    BasicMethod n ==
       u:I
       if n<0 then (m := -n; u := -1)
              else (m := n; u := 1)
       x := BasicSieve(m, 1 + approxSqrt m)
       makeFR(u, factorList x)

@
\subsection{factor}
The factor function is many orders of magnitude slower than the results
of other systems. A posting on sci.math.symbolic showed that NTL could
factor the final value (t6) in about 11 seconds. Axiom takes about 8 hours.
\begin{verbatim}
a1:=101
a2:=109
t1:=a1*a2
factor t1

a3:=21525175387
t2:=t1*a3
factor t2

a4:=218301576858349
t3:=t2*a4
factor t3

a5:=13731482973783137
t4:=t3*a5
factor t4

a6:=23326138687706820109
t5:=t4*a6
factor t5

a7:=4328240801173188438252813716944518369161
t6:=t5*a7
factor t6
\end{verbatim}
<<package INTFACT IntegerFactorizationPackage>>=
    factor m ==
       u:I
       zero? m => 0
       if negative? m then (n := -m; u := -1)
                      else (n := m; u := 1)
       b := BasicSieve(n, 10000::I)
       flb := factorList b
       ((n := unit b) = 1) => makeFR(u, flb)
       a:LMI := dictionary() -- numbers yet to be factored
       b:LMI := dictionary() -- prime factors found
       f:LMI := dictionary() -- number which could not be factored
       insert_!(n, a)
       while not empty? a repeat
          n := inspect a; c := count(n, a); remove_!(n, a)
          prime?(n)$IntegerPrimesPackage(I) => insert_!(n, b, c)
          -- test for a perfect power
          (s := perfectNthRoot n).exponent > 1 =>
            insert_!(s.base, a, c * s.exponent)
          -- test for a difference of square
          x:=approxSqrt n
          if (x**2<n) then x:=x+1
          (y:=perfectSqrt (x**2-n)) case I =>
                insert_!(x+y,a,c)
                insert_!(x-y,a,c)
          (d := PollardSmallFactor n) case I =>
             for m in 0.. while zero?(n rem d) repeat n := n quo d
             insert_!(d, a, m * c)
             if n > 1 then insert_!(n, a, c)
          -- an elliptic curve factorization attempt should be made here
          insert_!(n, f, c)
       -- insert prime factors found
       while not empty? b repeat
          n := inspect b; c := count(n, b); remove_!(n, b)
          flb := concat_!(flb, ["prime",n,convert c]$FFE)
       -- insert non-prime factors found
       while not empty? f repeat
          n := inspect f; c := count(n, f); remove_!(n, f)
          flb := concat_!(flb, ["nil",n,convert c]$FFE)
       makeFR(u, flb)

@
<<INTFACT.dotabb>>=
"INTFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTFACT"]
"MDAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MDAGG"]
"INTFACT" -> "MDAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ZLINDEP IntegerLinearDependence}
<<IntegerLinearDependence.input>>=
-- lindep.spad.pamphlet IntegerLinearDependence.input
)spool IntegerLinearDependence.output
)set message test on
)set message auto off
)clear all
--S 1
M := SQMATRIX(2,INT)
--R 
--R
--R   (1)  SquareMatrix(2,Integer)
--R                                                                 Type: Domain
--E 1

--S 2
m1: M := squareMatrix matrix [ [1, 2], [0, -1] ]
--R 
--R
--R        +1   2 +
--R   (2)  |      |
--R        +0  - 1+
--R                                                Type: SquareMatrix(2,Integer)
--E 2

--S 3
m2: M := squareMatrix matrix [ [2, 3], [1, -2] ]
--R 
--R
--R        +2   3 +
--R   (3)  |      |
--R        +1  - 2+
--R                                                Type: SquareMatrix(2,Integer)
--E 3

--S 4
m3: M := squareMatrix matrix [ [3, 4], [2, -3] ]
--R 
--R
--R        +3   4 +
--R   (4)  |      |
--R        +2  - 3+
--R                                                Type: SquareMatrix(2,Integer)
--E 4

--S 5
linearlyDependentOverZ? vector [m1, m2, m3]
--R 
--R
--R   (5)  true
--R                                                                Type: Boolean
--E 5

--S 6
c := linearDependenceOverZ vector [m1, m2, m3]
--R 
--R
--R   (6)  [1,- 2,1]
--R                                              Type: Union(Vector Integer,...)
--E 6

--S 7
c.1 * m1 + c.2 * m2 + c.3 * m3
--R 
--R
--R        +0  0+
--R   (7)  |    |
--R        +0  0+
--R                                                Type: SquareMatrix(2,Integer)
--E 7

--S 8
solveLinearlyOverQ(vector [m1, m3], m2)
--R 
--R
--R         1 1
--R   (8)  [-,-]
--R         2 2
--R                                     Type: Union(Vector Fraction Integer,...)
--E 8
)spool
)lisp (bye)
@
<<IntegerLinearDependence.help>>=
====================================================================
IntegerLinearDependence examples
====================================================================

The elements v1,...,vN of a module M over a ring R are said to be 
linearly dependent over R if there exist c1,...,cN in R, not all 0, 
such that c1 v1 + ...  cN vNn = 0.  If such ci's exist, they form 
what is called a linear dependence relation over R for the vi's.

The package IntegerLinearDependence provides functions for testing
whether some elements of a module over the integers are linearly
dependent over the integers, and to find the linear dependence
relations, if any.

Consider the domain of two by two square matrices with integer entries.

  M := SQMATRIX(2,INT)
    SquareMatrix(2,Integer)
                      Type: Domain

Now create three such matrices.

  m1: M := squareMatrix matrix [ [1, 2], [0, -1] ]
     +1   2 +
     |      |
     +0  - 1+
                      Type: SquareMatrix(2,Integer)

  m2: M := squareMatrix matrix [ [2, 3], [1, -2] ]
    +2   3 +
    |      |
    +1  - 2+
                      Type: SquareMatrix(2,Integer)

  m3: M := squareMatrix matrix [ [3, 4], [2, -3] ]
    +3   4 +
    |      |
    +2  - 3+
                      Type: SquareMatrix(2,Integer)

This tells you whether m1, m2 and m3 are linearly dependent over the integers.

  linearlyDependentOverZ? vector [m1, m2, m3]
    true
                      Type: Boolean

Since they are linearly dependent, you can ask for the dependence relation.

  c := linearDependenceOverZ vector [m1, m2, m3]
    [1,- 2,1]
                      Type: Union(Vector Integer,...)

This means that the following linear combination should be 0.

  c.1 * m1 + c.2 * m2 + c.3 * m3
    +0  0+
    |    |
    +0  0+
                      Type: SquareMatrix(2,Integer)

When a given set of elements are linearly dependent over R, this also 
means that at least one of them can be rewritten as a linear combination 
of the others with coefficients in the quotient field of R.

To express a given element in terms of other elements, use the operation
solveLinearlyOverQ.

  solveLinearlyOverQ(vector [m1, m3], m2)
     1 1
    [-,-]
     2 2
                      Type: Union(Vector Fraction Integer,...)

See Also:
o )show IntegerLinearDependence
o $AXIOM/doc/src/algebra/lindep.spad.dvi

@
\pagehead{IntegerLinearDependence}{ZLINDEP}
\pagepic{ps/v104integerlineardependence.ps}{ZLINDEP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ZLINDEP IntegerLinearDependence>>=
)abbrev package ZLINDEP IntegerLinearDependence
++ Test for linear dependence over the integers
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Test for linear dependence over the integers.
IntegerLinearDependence(R): Exports == Implementation where
  R: LinearlyExplicitRingOver Integer

  Z ==> Integer

  Exports ==> with
    linearlyDependentOverZ?: Vector R -> Boolean
      ++ \spad{linearlyDependentOverZ?([v1,...,vn])} returns true if the
      ++ vi's are linearly dependent over the integers, false otherwise.
    linearDependenceOverZ  : Vector R -> Union(Vector Z, "failed")
      ++ \spad{linearlyDependenceOverZ([v1,...,vn])} returns
      ++ \spad{[c1,...,cn]} if
      ++ \spad{c1*v1 + ... + cn*vn = 0} and not all the ci's are 0, "failed"
      ++ if the vi's are linearly independent over the integers.
    solveLinearlyOverQ     : (Vector R, R) ->
                                      Union(Vector Fraction Z, "failed")
      ++ \spad{solveLinearlyOverQ([v1,...,vn], u)} returns \spad{[c1,...,cn]}
      ++ such that \spad{c1*v1 + ... + cn*vn = u},
      ++ "failed" if no such rational numbers ci's exist.

  Implementation ==> add
    import LinearDependence(Z, R)

    linearlyDependentOverZ? v == linearlyDependent? v
    linearDependenceOverZ   v == linearDependence v
    solveLinearlyOverQ(v, c)  == solveLinear(v, c)

@
<<ZLINDEP.dotabb>>=
"ZLINDEP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ZLINDEP"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"ZLINDEP" -> "PID"
"ZLINDEP" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTHEORY IntegerNumberTheoryFunctions}
<<IntegerNumberTheoryFunctions.input>>=
-- numtheor.spad.pamphlet IntegerNumberTheoryFunctions.input
)spool IntegerNumberTheoryFunctions.output
)set message test on
)set message auto off
)clear all
div144 := divisors(144)
--R 
--R
--R   (1)  [1,2,3,4,6,8,9,12,16,18,24,36,48,72,144]
--R                                                           Type: List Integer
#(div144)
--R 
--R
--R   (2)  15
--R                                                        Type: PositiveInteger
reduce(+,div144)
--R 
--R
--R   (3)  403
--R                                                        Type: PositiveInteger
numberOfDivisors(144)
--R 
--R
--R   (4)  15
--R                                                        Type: PositiveInteger
sumOfDivisors(144)
--R 
--R
--R   (5)  403
--R                                                        Type: PositiveInteger
f1(n)==reduce(+,[moebiusMu(d)*numberOfDivisors(quo(n,d))_
     for d in divisors(n)])
--R 
--R                                                                   Type: Void
f1(200)
--R 
--R   Compiling function f1 with type PositiveInteger -> Integer 
--R
--R   (7)  1
--R                                                        Type: PositiveInteger
f1(846)
--R 
--R
--R   (8)  1
--R                                                        Type: PositiveInteger
f2(n) == reduce(+,[moebiusMu(d) * sumOfDivisors(quo(n,d))_
     for d in divisors(n)]) 
--R 
--R                                                                   Type: Void
f2(200)
--R 
--R   Compiling function f2 with type PositiveInteger -> Integer 
--R
--R   (10)  200
--R                                                        Type: PositiveInteger
f2(846)
--R 
--R
--R   (11)  846
--R                                                        Type: PositiveInteger
fibonacci(25)
--R 
--R
--R   (12)  75025
--R                                                        Type: PositiveInteger
[fibonacci(n) for n in 1..15]
--R 
--R
--R   (13)  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
--R                                                           Type: List Integer
fib(n) == reduce(+,[binomial(n-1-k,k) for k in 0..quo(n-1,2)])
--R 
--R                                                                   Type: Void
fib(25)
--R 
--R   Compiling function fib with type PositiveInteger -> Integer 
--R
--R   (15)  75025
--R                                                        Type: PositiveInteger
[fib(n) for n in 1..15]
--R 
--R
--R   (16)  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
--R                                                           Type: List Integer
legendre(3,5)
--R 
--R
--R   (17)  - 1
--R                                                                Type: Integer
legendre(23,691)
--R 
--R
--R   (18)  - 1
--R                                                                Type: Integer
h(d) == quo(reduce(+,[jacobi(d,k) for k in 1..quo(-d, 2)]),2-jacobi(d,2))
--R 
--R                                                                   Type: Void
h(-163)
--R 
--R   Compiling function h with type Integer -> Integer 
--R
--R   (20)  1
--R                                                        Type: PositiveInteger
h(-499)
--R 
--R
--R   (21)  3
--R                                                        Type: PositiveInteger
h(-1832)
--R 
--R
--R   (22)  26
--R                                                        Type: PositiveInteger
inverse:(INT,INT)->INT
--R 
--R                                                                   Type: Void
inverse(a,b) ==
  borg:INT:=b
  c1:INT := 1
  d1:INT := 0
  while b ~= 0 repeat
    q := a quo b
    r := a-q*b
    print [a, "=", q, "*(", b, ")+", r]
    (a,b):=(b,r)
    (c1,d1):=(d1,c1-q*d1)
  a ~= 1 => error("moduli are not relatively prime")
  positiveRemainder(c1,borg)
--R 
--R                                                                   Type: Void
inverse(15,26)
--R 
--R   Compiling function inverse with type (Integer,Integer) -> Integer 
--R   [15,"=",0,"*(",26,")+",15]
--R   [26,"=",1,"*(",15,")+",11]
--R   [15,"=",1,"*(",11,")+",4]
--R   [11,"=",2,"*(",4,")+",3]
--R   [4,"=",1,"*(",3,")+",1]
--R   [3,"=",3,"*(",1,")+",0]
--R
--R   (25)  7
--R                                                        Type: PositiveInteger
x1:=4
--R 
--R
--R   (26)  4
--R                                                        Type: PositiveInteger
m1:=5
--R 
--R
--R   (27)  5
--R                                                        Type: PositiveInteger
x2:=2
--R 
--R
--R   (28)  2
--R                                                        Type: PositiveInteger
m2:=3
--R 
--R
--R   (29)  3
--R                                                        Type: PositiveInteger
result:=chineseRemainder(x1,m1,x2,m2)
--R 
--R
--R   (30)  14
--R                                                        Type: PositiveInteger
)spool
)lisp (bye)
@
<<IntegerNumberTheoryFunctions.help>>=
====================================================================
IntegerNumberTheoryFunctions examples
====================================================================

The IntegerNumberTheoryFunctions package contains a variety of operations 
of interest to number theorists.  Many of these operations deal with 
divisibility properties of integers.  (Recall that an integer a divides 
an integer b if there is an integer c such that b = a * c.)

The operation divisors returns a list of the divisors of an integer.

  div144 := divisors(144)
    [1,2,3,4,6,8,9,12,16,18,24,36,48,72,144]
                           Type: List Integer

You can now compute the number of divisors of 144 and the sum of the
divisors of 144 by counting and summing the elements of the list we
just created.

  #(div144)
    15
                           Type: PositiveInteger

  reduce(+,div144)
    403
                           Type: PositiveInteger

Of course, you can compute the number of divisors of an integer n,
usually denoted d(n), and the sum of the divisors of an integer n,
usually denoted sigma(n), without ever listing the divisors of n.

In Axiom, you can simply call the operations numberOfDivisors and
sumOfDivisors.

  numberOfDivisors(144)
    15
                           Type: PositiveInteger

  sumOfDivisors(144)
    403
                           Type: PositiveInteger

The key is that d(n) and sigma(n) are "multiplicative functions."  
This means that when n and m are relatively prime, that is, when 
n and m have no prime factor in common, then d(nm) = d(n) d(m) and 
sigma(nm) = sigma(n) sigma(m).  Note that these functions are trivial to
compute when n is a prime power and are computed for general n from the 
prime factorization of n.  Other examples of multiplicative functions 
are sigma_k(n), the sum of the k-th powers of the divisors of n and 
varphi(n), the number of integers between 1 and n which are prime to n.
The corresponding Axiom operations are called sumOfKthPowerDivisors and
eulerPhi.

An interesting function is mu(n), the Moebius mu function, defined as 
follows: mu(1) = 1, mu(n) = 0, when n is divisible by a square, and 
mu = (-1)^k, when n is the product of k distinct primes.  The corresponding
Axiom operation is moebiusMu. This function occurs in the following theorem:

Theorem: (Moebius Inversion Formula): 
  Let f(n) be a function on the positive integers and let F(n)
  be defined by 
    F(n) = \sum_{d | n} f(n) 
  the sum of f(n) over d | n where the sum is taken over the 
  positive divisors of n.  Then the values of f(n) can be recovered 
  from the values of F(n): f(n) = sum_{d | n} \mu(n) F(n/d) where 
  again the sum is taken over the positive divisors of n.

When f(n) = 1, then F(n) = d(n).  Thus, if you sum mu(d)..d(n/d) over 
the positive divisors d of n, you should always get 1.

  f1(n)==reduce(+,[moebiusMu(d)*numberOfDivisors(quo(n,d))_
     for d in divisors(n)])
                           Type: Void

  f1(200)
    1
                           Type: PositiveInteger

  f1(846)
    1
                           Type: PositiveInteger

Similarly, when f(n) = n, then F(n) = sigma(n).  Thus, if you sum 
mu(d)..sigma(n/d) over the positive divisors d of n, you should always get n.

  f2(n) == reduce(+,[moebiusMu(d) * sumOfDivisors(quo(n,d))_
     for d in divisors(n)]) 
                           Type: Void

  f2(200)
    200
                           Type: PositiveInteger

  f2(846)
    846
                           Type: PositiveInteger

The Fibonacci numbers are defined by 
   F(1) = F(2) = 1 and
   F(n) = F(n-1) + F(n-2) for n = 3,4,...

The operation fibonacci computes the n-th Fibonacci number.

  fibonacci(25)
    75025
                           Type: PositiveInteger

  [fibonacci(n) for n in 1..15]
    [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
                           Type: List Integer

Fibonacci numbers can also be expressed as sums of binomial coefficients.

  fib(n) == reduce(+,[binomial(n-1-k,k) for k in 0..quo(n-1,2)])
                            Type: Void

  fib(25)
    75025
                            Type: PositiveInteger

  [fib(n) for n in 1..15]
    [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
                            Type: List Integer

Quadratic symbols can be computed with the operations legendre and
jacobi.  The Legendre symbol a/p is defined for integers a and p with
p an odd prime number.  By definition,

  (a/p) = +1, when a is a square (mod p),
  (a/p)= -1, when a is not a square (mod p), and
  (a/p) = 0, when a is divisible by p.

You compute (a/p) via the command legendre(a,p).

  legendre(3,5)
    - 1
                             Type: Integer

  legendre(23,691)
    - 1
                             Type: Integer

The Jacobi symbol (a/n) is the usual extension of the Legendre symbol,
where n is an arbitrary integer.  The most important property of the
Jacobi symbol is the following: if K is a quadratic field with
discriminant d and quadratic character chi, then chi(n) = (d/n).
Thus, you can use the Jacobi symbol to compute, say, the class numbers
of imaginary quadratic fields from a standard class number formula.

This function computes the class number of the imaginary quadratic
field with discriminant d.

  h(d) == quo(reduce(+,[jacobi(d,k) for k in 1..quo(-d, 2)]),2-jacobi(d,2))
                             Type: Void

  h(-163)
    1
                             Type: PositiveInteger

  h(-499)
    3
                             Type: PositiveInteger

  h(-1832)
    26
                             Type: PositiveInteger

====================================================================
The inverse function
====================================================================

The inverse function is derived from the Extended Euclidean Algorithm.
If we divide one integer by another nonzero integer we get an integer
quotient plus a remainder which is, in general, a rational number. 
For instance, 
  13/5 = 2 + 3/5
where 2 is the quotient and 3/5 is the remainder.

If we multiply thru by the denominator of the remainder we get an answer
in integer terms which no longer involves division:
  13 = 2(5) + 3

This gives a method of dividing integers. Specifically, if a and b are
positive integers, there exist unique non-negative integers q and r so that

  a = qb + r , where 0 <= r < b

q is called the quotient and r the remainder.

The greatest common divisor of integers a and b, denoted by gcd(a,b),
is the largest integer that divides (without remainder) both a and
b. So, for example: 
  gcd(15, 5)  = 5, 
  gcd(7, 9)   = 1, 
  gcd(12, 9)  = 3,
  gcd(81, 57) = 3.

The gcd of two integers can be found by repeated application of the
division algorithm, this is known as the Euclidean Algorithm. You
repeatedly divide the divisor by the remainder until the remainder is
0. The gcd is the last non-zero remainder in this algorithm. The
following example shows the algorithm.

Finding the gcd of 81 and 57 by the Euclidean Algorithm:
  81 = 1(57) + 24
  57 = 2(24) + 9
  24 = 2(9)  + 6
  9  = 1(6)  + 3
  6  = 2(3)  + 0

So the greatest commmon divisor, the GCD(81,51)=3.

If the gcd(a, b) = r then there exist integers s and t so that
  
  s(a) + t(b) = r

By back substitution in the steps in the Euclidean Algorithm, it is
possible to find these integers s and t. We shall do this with the
above example:

Starting with the next to last line, we have:

   3 = 9 -1(6)

From the line before that, we see that 6 = 24 - 2(9), so:

  3 = 9 - 1(24 - 2(9)) = 3(9) - 1(24)

From the line before that, we have 9 = 57 - 2(24), so:

  3 = 3( 57 - 2(24)) - 1(24) = 3(57) - 7(24)

And, from the line before that 24 = 81 - 1(57), giving us:

  3 = 3(57) - 7( 81 - 1(57)) = 10(57) -7(81)

So we have found s = -7 and t = 10.

The Extended Euclidean Algorithm computes the GCD(a,b) and 
the values for s and t.

Suppose we were doing arithmetics modulo 26 and we needed to find the
inverse of a number mod 26. This turned out to be a difficult task (and
not always possible). We observed that a number x had an inverse mod 26 
(i.e., a number y so that xy = 1 mod 26) if and only if gcd(x,26) = 1. 
In the general case the inverse of x exists if and only if gcd(x, n) = 1 
and if it exists then there exist integers s and t so that

  sx + tn = 1

But this says that sx = 1 + (-t)n, or in other words, 

  sx == 1 mod n

So, s (reduced mod n if need be) is the inverse of x mod n. 
The extended Euclidean algorithm calculates s efficiently.

====================================================================
Finding the inverse mod n
====================================================================

We will number the steps of the Euclidean algorithm starting with step 0. 
The quotient obtained at step i will be denoted by qi and an auxillary 
number, si. For the first two steps, the value of this number is given: 
  s(0) = 0 and 
  s(1) = 1. 

For the remainder of the steps, we recursively calculate 
  s(i) = s(i-2) - s(i-1) q(i-2) mod n

The algorithm starts by "dividing" n by x. If the last non-zero remainder 
occurs at step k, then if this remainder is 1, x has an inverse and it is 
s(k+2). If the remainder is not 1, then x does not have an inverse. 

For example, find the inverse of 15 mod 26.

Step 0: 26 = 1(15) + 11 s(0) = 0
Step 1: 15 = 1(11) + 4  s(1) = 1
Step 2: 11 = 2(4) + 3   s(2) = 0  -  1( 1) mod 26 =  25
Step 3: 4  = 1(3) + 1   s(3) = 1  - 25( 1) mod 26 = -24 mod 26 = 2
Step 4: 3  = 3(1) + 0   s(4) = 25 -  2( 2) mod 26 =  21
                        s(5) = 2  - 21( 1) mod 26 = -19 mod 26 = 7

Notice that 15(7) = 105 = 1 + 4(26) == 1 (mod 26). 

Using the half extended Euclidean algorithm we compute 1/a mod b.

  inverse:(INT,INT)->INT
                              Type: Void

  inverse(a,b) ==
    borg:INT:=b
    c1:INT := 1
    d1:INT := 0
    while b ~= 0 repeat
      q := a quo b
      r := a-q*b
      print [a, "=", q, "*(", b, ")+", r]
      (a,b):=(b,r)
      (c1,d1):=(d1,c1-q*d1)
    a ~= 1 => error("moduli are not relatively prime")
    positiveRemainder(c1,borg)
                              Type: Void

  inverse(15,26)
   [15,"=",0,"*(",26,")+",15]
   [26,"=",1,"*(",15,")+",11]
   [15,"=",1,"*(",11,")+",4]
   [11,"=",2,"*(",4,")+",3]
   [4,"=",1,"*(",3,")+",1]
   [3,"=",3,"*(",1,")+",0]

   7
                              Type: PositiveInteger


====================================================================
The Chinese Remainder Algorithm
====================================================================

Let m1,m2,...,mr be positive integers that are pairwise relatively prime. 
Let x1,x2,..,xr be integers with 0 <= xi < mi. Then, there is exactly one 
x in the interval 0 <= x < m1 ... m2 ... mr
that satisfies the remainder equations 

  irem(x,mi) = xi, i=1,2,...,r

where irem is the positive integer remainder function.

For example, et x1 = 4, m1 = 5, x2 = 2, m2 = 3. We know that 
  irem(x,m1) = x1
  irem(x,m2) = x2
where 0 <= x_ < m1 and 0 <= x2 < m2. 

By the extended Euclidean Algorithm there are integers c and d such that
  c m1 + d m2 = 1

In this case we are looking for an integer such that
 irem(x,5) = 4,
 irem(x,3) = 2

The algorithm we use is to first compute the positive integer remainder of 
x1 and m1 to get a new x1:

 x1 = positiveRemainder(x1,m1)
  4 = positiveRemainder(4,5)

Next compute the positive integer remainder of x2 and m2 to get a new x2:

 x2 = positiveRemainder(x2,m2)
  2 = positiveRemainder(2,3)

Then we compute x1 + m1 ... positiveRemainder(((x2-x1)*inverse(m1,m2)),m2)
or
  4+5*positiveRemainder(((2-4)*inverse(5,3)),3)
or
  4+5*positiveRemainder(-2*2),3)
or
  4+5*2
or
  14

This function has a restricted signature which only allows for
computing the chinese remainder of two numbers and two moduli.
  x1:=4
    4
                          Type: PositiveInteger
  m1:=5
    5
                          Type: PositiveInteger
  x2:=2
    2
                          Type: PositiveInteger
  m2:=3
    3
                          Type: PositiveInteger
  result:=chineseRemainder(x1,m1,x2,m2)
    14
                          Type: PositiveInteger

See Also:
o )show IntegerNumberTheoryFunctions

@
\pagehead{IntegerNumberTheoryFunctions}{INTHEORY}
\pagepic{ps/v104integernumbertheoryfunctions.ps}{INTHEORY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTHEORY IntegerNumberTheoryFunctions>>=
)abbrev package INTHEORY IntegerNumberTheoryFunctions
++ Author: Michael Monagan, Martin Brock, Robert Sutor, Timothy Daly
++ Date Created: June 1987
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: number theory, integer
++ Examples:
++ References: Knuth, The Art of Computer Programming Vol.2
++ Description:
++ This package provides various number theoretic functions on the integers.
IntegerNumberTheoryFunctions(): Exports == Implementation where
 I ==> Integer
 RN ==> Fraction I
 SUP ==> SparseUnivariatePolynomial
 NNI ==> NonNegativeInteger

 Exports ==> with
  bernoulli : I -> RN
    ++ \spad{bernoulli(n)} returns the nth Bernoulli number.
    ++ this is \spad{B(n,0)}, where \spad{B(n,x)} is the \spad{n}th Bernoulli
    ++ polynomial.
  chineseRemainder: (I,I,I,I) -> I
    ++ \spad{chineseRemainder(x1,m1,x2,m2)} returns w, where w is such that
    ++ \spad{w = x1 mod m1} and \spad{w = x2 mod m2}. Note: \spad{m1} and
    ++ \spad{m2} must be relatively prime.
  divisors : I -> List I
    ++ \spad{divisors(n)} returns a list of the divisors of n.
  euler : I -> I
    ++ \spad{euler(n)} returns the \spad{n}th Euler number. This is
    ++ \spad{2^n E(n,1/2)}, where \spad{E(n,x)} is the nth Euler polynomial.
  eulerPhi : I -> I
    ++ \spad{eulerPhi(n)} returns the number of integers between 1 and n
    ++ (including 1) which are relatively prime to n. This is the Euler phi
    ++ function \spad{\phi(n)} is also called the totient function.
  fibonacci : I -> I
    ++ \spad{fibonacci(n)} returns the nth Fibonacci number. the Fibonacci
    ++ numbers \spad{F[n]} are defined by \spad{F[0] = F[1] = 1} and
    ++ \spad{F[n] = F[n-1] + F[n-2]}.
    ++ The algorithm has running time \spad{O(log(n)^3)}.
    ++ Reference: Knuth, The Art of Computer Programming
    ++ Vol 2, Semi-Numerical Algorithms.
  harmonic : I -> RN
    ++ \spad{harmonic(n)} returns the nth harmonic number. This is
    ++ \spad{H[n] = sum(1/k,k=1..n)}.
  jacobi : (I,I) -> I
    ++ \spad{jacobi(a,b)} returns the Jacobi symbol \spad{J(a/b)}.
    ++ When b is odd, \spad{J(a/b) = product(L(a/p) for p in factor b )}.
    ++ Note: by convention, 0 is returned if \spad{gcd(a,b) ^= 1}.
    ++ Iterative \spad{O(log(b)^2)} version coded by Michael Monagan June 1987.
  legendre : (I,I) -> I
    ++ \spad{legendre(a,p)} returns the Legendre symbol \spad{L(a/p)}.
    ++ \spad{L(a/p) = (-1)**((p-1)/2) mod p} (p prime), which is 0 if \spad{a}
    ++ is 0, 1 if \spad{a} is a quadratic residue \spad{mod p} and -1 otherwise.
    ++ Note: because the primality test is expensive,
    ++ if it is known that p is prime then use \spad{jacobi(a,p)}.
  moebiusMu : I -> I
    ++ \spad{moebiusMu(n)} returns the Moebius function \spad{mu(n)}.
    ++ \spad{mu(n)} is either -1,0 or 1 as follows:
    ++ \spad{mu(n) = 0} if n is divisible by a square > 1,
    ++ \spad{mu(n) = (-1)^k} if n is square-free and has k distinct
    ++ prime divisors.
  numberOfDivisors: I -> I
    ++ \spad{numberOfDivisors(n)} returns the number of integers between 1 and n
    ++ (inclusive) which divide n. The number of divisors of n is often
    ++ denoted by \spad{tau(n)}.
  sumOfDivisors : I -> I
    ++ \spad{sumOfDivisors(n)} returns the sum of the integers between 1 and n
    ++ (inclusive) which divide n. The sum of the divisors of n is often
    ++ denoted by \spad{sigma(n)}.
  sumOfKthPowerDivisors: (I,NNI) -> I
    ++ \spad{sumOfKthPowerDivisors(n,k)} returns the sum of the \spad{k}th
    ++ powers of the integers between 1 and n (inclusive) which divide n.
    ++ the sum of the \spad{k}th powers of the divisors of n is often denoted
    ++ by \spad{sigma_k(n)}.
 Implementation ==> add
  import IntegerPrimesPackage(I)

  -- we store the euler and bernoulli numbers computed so far in
  -- a Vector because they are computed from an n-term recurrence
  E: IndexedFlexibleArray(I,0)   := new(1, 1)
  B: IndexedFlexibleArray(RN,0)  := new(1, 1)
  H: Record(Hn:I,Hv:RN) := [1, 1]

  harmonic n ==
    s:I; h:RN
    n < 0 => error("harmonic not defined for negative integers")
    if n >= H.Hn then (s,h) := H else (s := 0; h := 0)
    for k in s+1..n repeat h := h + 1/k
    H.Hn := n
    H.Hv := h
    h

  fibonacci n ==
    n = 0 => 0
    n < 0 => (odd? n => 1; -1) * fibonacci(-n)
    f1, f2 : I
    (f1,f2) := (0,1)
    for k in length(n)-2 .. 0 by -1 repeat
      t := f2**2
      (f1,f2) := (t+f1**2,t+2*f1*f2)
      if bit?(n,k) then (f1,f2) := (f2,f1+f2)
    f2

  euler n ==
    n < 0 => error "euler not defined for negative integers"
    odd? n => 0
    l := (#E) :: I
    n < l => E(n)
    concat_!(E, new((n+1-l)::NNI, 0)$IndexedFlexibleArray(I,0))
    for i in 1 .. l by 2 repeat E(i) := 0
    -- compute E(i) i = l+2,l+4,...,n given E(j) j = 0,2,...,i-2
    t,e : I
    for i in l+1 .. n by 2 repeat
      t := e := 1
      for j in 2 .. i-2 by 2 repeat
        t := (t*(i-j+1)*(i-j+2)) quo (j*(j-1))
        e := e + t*E(j)
      E(i) := -e
    E(n)

  bernoulli n ==
    n < 0 => error "bernoulli not defined for negative integers"
    odd? n =>
      n = 1 => -1/2
      0
    l := (#B) :: I
    n < l => B(n)
    concat_!(B, new((n+1-l)::NNI, 0)$IndexedFlexibleArray(RN,0))
    for i in 1 .. l by 2 repeat B(i) := 0
    -- compute B(i) i = l+2,l+4,...,n given B(j) j = 0,2,...,i-2
    for i in l+1 .. n by 2 repeat
      t:I := 1
      b := (1-i)/2
      for j in 2 .. i-2 by 2 repeat
        t := (t*(i-j+2)*(i-j+3)) quo (j*(j-1))
        b := b + (t::RN) * B(j)
      B(i) := -b/((i+1)::RN)
    B(n)

  inverse : (I,I) -> I

  inverse(a,b) ==
    borg:I:=b
    c1:I := 1
    d1:I := 0
    while b ^= 0 repeat
      q:I := a quo b
      r:I := a-q*b
      (a,b):=(b,r)
      (c1,d1):=(d1,c1-q*d1)
    a ^= 1 => error("moduli are not relatively prime")
    positiveRemainder(c1,borg)

  chineseRemainder(x1,m1,x2,m2) ==
    m1 < 0 or m2 < 0 => error "moduli must be positive"
    x1 := positiveRemainder(x1,m1)
    x2 := positiveRemainder(x2,m2)
    x1 + m1 * positiveRemainder(((x2-x1) * inverse(m1,m2)),m2)

  jacobi(a,b) ==
    -- Revised by Clifton Williamson January 1989.
    -- Previous version returned incorrect answers when b was even.
    -- The formula J(a/b) = product ( L(a/p) for p in factor b) is only
    -- valid when b is odd (the Legendre symbol L(a/p) is not defined
    -- for p = 2).  When b is even, the Jacobi symbol J(a/b) is only
    -- defined for a = 0 or 1 (mod 4).  When a = 1 (mod 8),
    -- J(a/2) = +1 and when a = 5 (mod 8), we define J(a/2) = -1.
    -- Extending by multiplicativity, we have J(a/b) for even b and
    -- appropriate a.
    -- We also define J(a/1) = 1.
    -- The point of this is the following: if d is the discriminant of
    -- a quadratic field K and chi is the quadratic character for K,
    -- then J(d/n) = chi(n) for n > 0.
    -- Reference: Hecke, Vorlesungen ueber die Theorie der Algebraischen
    -- Zahlen.
    if b < 0 then b := -b
    b = 0 => error "second argument of jacobi may not be 0"
    b = 1 => 1
    even? b and positiveRemainder(a,4) > 1 =>
      error "J(a/b) not defined for b even and a = 2 or 3 (mod 4)"
    even? b and even? a => 0
    for k in 0.. while even? b repeat b := b quo 2
    j:I := (odd? k and positiveRemainder(a,8) = 5 => -1; 1)
    b = 1 => j
    a := positiveRemainder(a,b)
    -- assertion: 0 < a < b and odd? b
    while a > 1 repeat
      if odd? a then
        -- J(a/b) = J(b/a) (-1) ** (a-1)/2 (b-1)/2
        if a rem 4 = 3 and b rem 4 = 3 then j := -j
        (a,b) := (b rem a,a)
      else
        -- J(2*a/b) = J(a/b) (-1) (b**2-1)/8
        for k in 0.. until odd? a repeat a := a quo 2
        if odd? k and (b+2) rem 8 > 4 then j := -j
    a = 0 => 0
    j

  legendre(a,p) ==
    prime? p => jacobi(a,p)
    error "characteristic of legendre must be prime"

  eulerPhi n ==
    n = 0 => 0
    r : RN := 1
    for entry in factors factor n repeat
      r := ((entry.factor - 1) /$RN entry.factor) * r
    numer(n * r)

  divisors n ==
    oldList : List Integer := concat(1,nil())
    for f in factors factor n repeat
      newList : List Integer := nil()
      for k in 0..f.exponent repeat
        pow := f.factor ** k
        for m in oldList repeat
          newList := concat(pow * m,newList)
      oldList := newList
    sort(#1 < #2,newList)

  numberOfDivisors n ==
    n = 0 => 0
    */[1+entry.exponent for entry in factors factor n]

  sumOfDivisors n ==
    n = 0 => 0
    r : RN := */[(entry.factor**(entry.exponent::NNI + 1)-1)/
      (entry.factor-1) for entry in factors factor n]
    numer r

  sumOfKthPowerDivisors(n,k) ==
    n = 0 => 0
    r : RN := */[(entry.factor**(k*entry.exponent::NNI+k)-1)/
      (entry.factor**k-1) for entry in factors factor n]
    numer r

  moebiusMu n ==
    n = 1 => 1
    t := factor n
    for k in factors t repeat
      k.exponent > 1 => return 0
    odd? numberOfFactors t => -1
    1

@
<<INTHEORY.dotabb>>=
"INTHEORY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTHEORY"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"INTHEORY" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PRIMES IntegerPrimesPackage}
We've expanded the list of small primes to include those between 1 and 10000.
\pagehead{IntegerPrimesPackage}{PRIMES}
\pagepic{ps/v104integerprimespackage.ps}{PRIMES}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PRIMES IntegerPrimesPackage>>=
)abbrev package PRIMES IntegerPrimesPackage
++ Author: Michael Monagan
++ Date Created: August 1987
++ Date Last Updated: 31 May 1993
++ Updated by: James Davenport
++ Updated Because: of problems with strong pseudo-primes
++   and for some efficiency reasons.
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: integer, prime
++ Examples:
++ References: Davenport's paper in ISSAC 1992
++             AXIOM Technical Report ATR/6
++ Description:
++   The \spadtype{IntegerPrimesPackage} implements a modification of
++   Rabin's probabilistic
++   primality test and the utility functions \spadfun{nextPrime},
++   \spadfun{prevPrime} and \spadfun{primes}.
IntegerPrimesPackage(I:IntegerNumberSystem): with
   prime?: I -> Boolean
     ++ \spad{prime?(n)} returns true if n is prime and false if not.
     ++ The algorithm used is Rabin's probabilistic primality test
     ++ (reference: Knuth Volume 2 Semi Numerical Algorithms).
     ++ If \spad{prime? n} returns false, n is proven composite.
     ++ If \spad{prime? n} returns true, prime? may be in error
     ++ however, the probability of error is very low.
     ++ and is zero below 25*10**9 (due to a result of Pomerance et al),
     ++ below 10**12 and 10**13 due to results of Pinch,
     ++ and below 341550071728321 due to a result of Jaeschke.
     ++ Specifically, this implementation does at least 10 pseudo prime
     ++ tests and so the probability of error is \spad{< 4**(-10)}.
     ++ The running time of this method is cubic in the length
     ++ of the input n, that is \spad{O( (log n)**3 )}, for n<10**20.
     ++ beyond that, the algorithm is quartic, \spad{O( (log n)**4 )}.
     ++ Two improvements due to Davenport have been incorporated
     ++ which catches some trivial strong pseudo-primes, such as
     ++ [Jaeschke, 1991] 1377161253229053 * 413148375987157, which
     ++ the original algorithm regards as prime
   nextPrime: I -> I
     ++ \spad{nextPrime(n)} returns the smallest prime strictly larger than n
   prevPrime: I -> I
     ++ \spad{prevPrime(n)} returns the largest prime strictly smaller than n
   primes: (I,I) -> List I
     ++ \spad{primes(a,b)} returns a list of all primes p with
     ++ \spad{a <= p <= b}
 == add
@
\subsection{smallPrimes}
This is a table of all of the primes in [2..10000]. It is used by the
prime? function to check for primality. It is used by the primes function
to generate arrays of primes in a given range. Changing the range included
in this table implies changing the value of the nextSmallPrime variable.
There is a constant in the function squareFree from IntegerFactorizationPackage
that is the square of the upper bound of the table range, in this case
10000000. 
<<package PRIMES IntegerPrimesPackage>>=
   smallPrimes: List I := 
     [2::I, 3::I, 5::I, 7::I, 11::I, 13::I, 17::I, 19::I,_
      23::I, 29::I, 31::I, 37::I, 41::I, 43::I, 47::I, 53::I,_
      59::I, 61::I, 67::I, 71::I, 73::I, 79::I, 83::I, 89::I,_
      97::I, 101::I, 103::I, 107::I, 109::I, 113::I, 127::I,_
      131::I, 137::I, 139::I, 149::I, 151::I, 157::I, 163::I,_
      167::I, 173::I, 179::I, 181::I, 191::I, 193::I, 197::I,_
      199::I, 211::I, 223::I, 227::I, 229::I, 233::I, 239::I,_
      241::I, 251::I, 257::I, 263::I, 269::I, 271::I, 277::I,_
      281::I, 283::I, 293::I, 307::I, 311::I, 313::I, 317::I,_
      331::I, 337::I, 347::I, 349::I, 353::I, 359::I, 367::I,_
      373::I, 379::I, 383::I, 389::I, 397::I, 401::I, 409::I,_
      419::I, 421::I, 431::I, 433::I, 439::I, 443::I, 449::I,_
      457::I, 461::I, 463::I, 467::I, 479::I, 487::I, 491::I,_
      499::I, 503::I, 509::I, 521::I, 523::I, 541::I, 547::I,_
      557::I, 563::I, 569::I, 571::I, 577::I, 587::I, 593::I,_
      599::I, 601::I, 607::I, 613::I, 617::I, 619::I, 631::I,_
      641::I, 643::I, 647::I, 653::I, 659::I, 661::I, 673::I,_
      677::I, 683::I, 691::I, 701::I, 709::I, 719::I, 727::I,_
      733::I, 739::I, 743::I, 751::I, 757::I, 761::I, 769::I,_
      773::I, 787::I, 797::I, 809::I, 811::I, 821::I, 823::I,_
      827::I, 829::I, 839::I, 853::I, 857::I, 859::I, 863::I,_
      877::I, 881::I, 883::I, 887::I, 907::I, 911::I, 919::I,_
      929::I, 937::I, 941::I, 947::I, 953::I, 967::I, 971::I,_
      977::I, 983::I, 991::I, 997::I, 1009::I, 1013::I,_
      1019::I, 1021::I, 1031::I, 1033::I, 1039::I, 1049::I,_
      1051::I, 1061::I, 1063::I, 1069::I, 1087::I, 1091::I,_
      1093::I, 1097::I, 1103::I, 1109::I, 1117::I, 1123::I,_
      1129::I, 1151::I, 1153::I, 1163::I, 1171::I, 1181::I,_
      1187::I, 1193::I, 1201::I, 1213::I, 1217::I, 1223::I,_
      1229::I, 1231::I, 1237::I, 1249::I, 1259::I, 1277::I,_
      1279::I, 1283::I, 1289::I, 1291::I, 1297::I, 1301::I,_
      1303::I, 1307::I, 1319::I, 1321::I, 1327::I, 1361::I,_
      1367::I, 1373::I, 1381::I, 1399::I, 1409::I, 1423::I,_
      1427::I, 1429::I, 1433::I, 1439::I, 1447::I, 1451::I,_
      1453::I, 1459::I, 1471::I, 1481::I, 1483::I, 1487::I,_
      1489::I, 1493::I, 1499::I, 1511::I, 1523::I, 1531::I,_
      1543::I, 1549::I, 1553::I, 1559::I, 1567::I, 1571::I,_
      1579::I, 1583::I, 1597::I, 1601::I, 1607::I, 1609::I,_
      1613::I, 1619::I, 1621::I, 1627::I, 1637::I, 1657::I,_
      1663::I, 1667::I, 1669::I, 1693::I, 1697::I, 1699::I,_
      1709::I, 1721::I, 1723::I, 1733::I, 1741::I, 1747::I,_
      1753::I, 1759::I, 1777::I, 1783::I, 1787::I, 1789::I,_
      1801::I, 1811::I, 1823::I, 1831::I, 1847::I, 1861::I,_
      1867::I, 1871::I, 1873::I, 1877::I, 1879::I, 1889::I,_
      1901::I, 1907::I, 1913::I, 1931::I, 1933::I, 1949::I,_
      1951::I, 1973::I, 1979::I, 1987::I, 1993::I, 1997::I,_
      1999::I, 2003::I, 2011::I, 2017::I, 2027::I, 2029::I,_
      2039::I, 2053::I, 2063::I, 2069::I, 2081::I, 2083::I,_
      2087::I, 2089::I, 2099::I, 2111::I, 2113::I, 2129::I,_
      2131::I, 2137::I, 2141::I, 2143::I, 2153::I, 2161::I,_
      2179::I, 2203::I, 2207::I, 2213::I, 2221::I, 2237::I,_
      2239::I, 2243::I, 2251::I, 2267::I, 2269::I, 2273::I,_
      2281::I, 2287::I, 2293::I, 2297::I, 2309::I, 2311::I,_
      2333::I, 2339::I, 2341::I, 2347::I, 2351::I, 2357::I,_
      2371::I, 2377::I, 2381::I, 2383::I, 2389::I, 2393::I,_
      2399::I, 2411::I, 2417::I, 2423::I, 2437::I, 2441::I,_
      2447::I, 2459::I, 2467::I, 2473::I, 2477::I, 2503::I,_
      2521::I, 2531::I, 2539::I, 2543::I, 2549::I, 2551::I,_
      2557::I, 2579::I, 2591::I, 2593::I, 2609::I, 2617::I,_
      2621::I, 2633::I, 2647::I, 2657::I, 2659::I, 2663::I,_
      2671::I, 2677::I, 2683::I, 2687::I, 2689::I, 2693::I,_
      2699::I, 2707::I, 2711::I, 2713::I, 2719::I, 2729::I,_
      2731::I, 2741::I, 2749::I, 2753::I, 2767::I, 2777::I,_
      2789::I, 2791::I, 2797::I, 2801::I, 2803::I, 2819::I,_
      2833::I, 2837::I, 2843::I, 2851::I, 2857::I, 2861::I,_
      2879::I, 2887::I, 2897::I, 2903::I, 2909::I, 2917::I,_
      2927::I, 2939::I, 2953::I, 2957::I, 2963::I, 2969::I,_
      2971::I, 2999::I, 3001::I, 3011::I, 3019::I, 3023::I,_
      3037::I, 3041::I, 3049::I, 3061::I, 3067::I, 3079::I,_
      3083::I, 3089::I, 3109::I, 3119::I, 3121::I, 3137::I,_
      3163::I, 3167::I, 3169::I, 3181::I, 3187::I, 3191::I,_
      3203::I, 3209::I, 3217::I, 3221::I, 3229::I, 3251::I,_
      3253::I, 3257::I, 3259::I, 3271::I, 3299::I, 3301::I,_
      3307::I, 3313::I, 3319::I, 3323::I, 3329::I, 3331::I,_
      3343::I, 3347::I, 3359::I, 3361::I, 3371::I, 3373::I,_
      3389::I, 3391::I, 3407::I, 3413::I, 3433::I, 3449::I,_
      3457::I, 3461::I, 3463::I, 3467::I, 3469::I, 3491::I,_
      3499::I, 3511::I, 3517::I, 3527::I, 3529::I, 3533::I,_
      3539::I, 3541::I, 3547::I, 3557::I, 3559::I, 3571::I,_
      3581::I, 3583::I, 3593::I, 3607::I, 3613::I, 3617::I,_
      3623::I, 3631::I, 3637::I, 3643::I, 3659::I, 3671::I,_
      3673::I, 3677::I, 3691::I, 3697::I, 3701::I, 3709::I,_
      3719::I, 3727::I, 3733::I, 3739::I, 3761::I, 3767::I,_
      3769::I, 3779::I, 3793::I, 3797::I, 3803::I, 3821::I,_
      3823::I, 3833::I, 3847::I, 3851::I, 3853::I, 3863::I,_
      3877::I, 3881::I, 3889::I, 3907::I, 3911::I, 3917::I,_
      3919::I, 3923::I, 3929::I, 3931::I, 3943::I, 3947::I,_
      3967::I, 3989::I, 4001::I, 4003::I, 4007::I, 4013::I,_
      4019::I, 4021::I, 4027::I, 4049::I, 4051::I, 4057::I,_
      4073::I, 4079::I, 4091::I, 4093::I, 4099::I, 4111::I,_
      4127::I, 4129::I, 4133::I, 4139::I, 4153::I, 4157::I,_
      4159::I, 4177::I, 4201::I, 4211::I, 4217::I, 4219::I,_
      4229::I, 4231::I, 4241::I, 4243::I, 4253::I, 4259::I,_
      4261::I, 4271::I, 4273::I, 4283::I, 4289::I, 4297::I,_
      4327::I, 4337::I, 4339::I, 4349::I, 4357::I, 4363::I,_
      4373::I, 4391::I, 4397::I, 4409::I, 4421::I, 4423::I,_
      4441::I, 4447::I, 4451::I, 4457::I, 4463::I, 4481::I,_
      4483::I, 4493::I, 4507::I, 4513::I, 4517::I, 4519::I,_
      4523::I, 4547::I, 4549::I, 4561::I, 4567::I, 4583::I,_
      4591::I, 4597::I, 4603::I, 4621::I, 4637::I, 4639::I,_
      4643::I, 4649::I, 4651::I, 4657::I, 4663::I, 4673::I,_
      4679::I, 4691::I, 4703::I, 4721::I, 4723::I, 4729::I,_
      4733::I, 4751::I, 4759::I, 4783::I, 4787::I, 4789::I,_
      4793::I, 4799::I, 4801::I, 4813::I, 4817::I, 4831::I,_
      4861::I, 4871::I, 4877::I, 4889::I, 4903::I, 4909::I,_
      4919::I, 4931::I, 4933::I, 4937::I, 4943::I, 4951::I,_
      4957::I, 4967::I, 4969::I, 4973::I, 4987::I, 4993::I,_
      4999::I, 5003::I, 5009::I, 5011::I, 5021::I, 5023::I,_
      5039::I, 5051::I, 5059::I, 5077::I, 5081::I, 5087::I,_
      5099::I, 5101::I, 5107::I, 5113::I, 5119::I, 5147::I,_
      5153::I, 5167::I, 5171::I, 5179::I, 5189::I, 5197::I,_
      5209::I, 5227::I, 5231::I, 5233::I, 5237::I, 5261::I,_
      5273::I, 5279::I, 5281::I, 5297::I, 5303::I, 5309::I,_
      5323::I, 5333::I, 5347::I, 5351::I, 5381::I, 5387::I,_
      5393::I, 5399::I, 5407::I, 5413::I, 5417::I, 5419::I,_
      5431::I, 5437::I, 5441::I, 5443::I, 5449::I, 5471::I,_
      5477::I, 5479::I, 5483::I, 5501::I, 5503::I, 5507::I,_
      5519::I, 5521::I, 5527::I, 5531::I, 5557::I, 5563::I,_
      5569::I, 5573::I, 5581::I, 5591::I, 5623::I, 5639::I,_
      5641::I, 5647::I, 5651::I, 5653::I, 5657::I, 5659::I,_
      5669::I, 5683::I, 5689::I, 5693::I, 5701::I, 5711::I,_
      5717::I, 5737::I, 5741::I, 5743::I, 5749::I, 5779::I,_
      5783::I, 5791::I, 5801::I, 5807::I, 5813::I, 5821::I,_
      5827::I, 5839::I, 5843::I, 5849::I, 5851::I, 5857::I,_
      5861::I, 5867::I, 5869::I, 5879::I, 5881::I, 5897::I,_
      5903::I, 5923::I, 5927::I, 5939::I, 5953::I, 5981::I,_
      5987::I, 6007::I, 6011::I, 6029::I, 6037::I, 6043::I,_
      6047::I, 6053::I, 6067::I, 6073::I, 6079::I, 6089::I,_
      6091::I, 6101::I, 6113::I, 6121::I, 6131::I, 6133::I,_
      6143::I, 6151::I, 6163::I, 6173::I, 6197::I, 6199::I,_
      6203::I, 6211::I, 6217::I, 6221::I, 6229::I, 6247::I,_
      6257::I, 6263::I, 6269::I, 6271::I, 6277::I, 6287::I,_
      6299::I, 6301::I, 6311::I, 6317::I, 6323::I, 6329::I,_
      6337::I, 6343::I, 6353::I, 6359::I, 6361::I, 6367::I,_
      6373::I, 6379::I, 6389::I, 6397::I, 6421::I, 6427::I,_
      6449::I, 6451::I, 6469::I, 6473::I, 6481::I, 6491::I,_
      6521::I, 6529::I, 6547::I, 6551::I, 6553::I, 6563::I,_
      6569::I, 6571::I, 6577::I, 6581::I, 6599::I, 6607::I,_
      6619::I, 6637::I, 6653::I, 6659::I, 6661::I, 6673::I,_
      6679::I, 6689::I, 6691::I, 6701::I, 6703::I, 6709::I,_
      6719::I, 6733::I, 6737::I, 6761::I, 6763::I, 6779::I,_
      6781::I, 6791::I, 6793::I, 6803::I, 6823::I, 6827::I,_
      6829::I, 6833::I, 6841::I, 6857::I, 6863::I, 6869::I,_
      6871::I, 6883::I, 6899::I, 6907::I, 6911::I, 6917::I,_
      6947::I, 6949::I, 6959::I, 6961::I, 6967::I, 6971::I,_
      6977::I, 6983::I, 6991::I, 6997::I, 7001::I, 7013::I,_
      7019::I, 7027::I, 7039::I, 7043::I, 7057::I, 7069::I,_
      7079::I, 7103::I, 7109::I, 7121::I, 7127::I, 7129::I,_
      7151::I, 7159::I, 7177::I, 7187::I, 7193::I, 7207::I,_
      7211::I, 7213::I, 7219::I, 7229::I, 7237::I, 7243::I,_
      7247::I, 7253::I, 7283::I, 7297::I, 7307::I, 7309::I,_
      7321::I, 7331::I, 7333::I, 7349::I, 7351::I, 7369::I,_
      7393::I, 7411::I, 7417::I, 7433::I, 7451::I, 7457::I,_
      7459::I, 7477::I, 7481::I, 7487::I, 7489::I, 7499::I,_
      7507::I, 7517::I, 7523::I, 7529::I, 7537::I, 7541::I,_
      7547::I, 7549::I, 7559::I, 7561::I, 7573::I, 7577::I,_
      7583::I, 7589::I, 7591::I, 7603::I, 7607::I, 7621::I,_
      7639::I, 7643::I, 7649::I, 7669::I, 7673::I, 7681::I,_
      7687::I, 7691::I, 7699::I, 7703::I, 7717::I, 7723::I,_
      7727::I, 7741::I, 7753::I, 7757::I, 7759::I, 7789::I,_
      7793::I, 7817::I, 7823::I, 7829::I, 7841::I, 7853::I,_
      7867::I, 7873::I, 7877::I, 7879::I, 7883::I, 7901::I,_
      7907::I, 7919::I, 7927::I, 7933::I, 7937::I, 7949::I,_
      7951::I, 7963::I, 7993::I, 8009::I, 8011::I, 8017::I,_
      8039::I, 8053::I, 8059::I, 8069::I, 8081::I, 8087::I,_
      8089::I, 8093::I, 8101::I, 8111::I, 8117::I, 8123::I,_
      8147::I, 8161::I, 8167::I, 8171::I, 8179::I, 8191::I,_
      8209::I, 8219::I, 8221::I, 8231::I, 8233::I, 8237::I,_
      8243::I, 8263::I, 8269::I, 8273::I, 8287::I, 8291::I,_
      8293::I, 8297::I, 8311::I, 8317::I, 8329::I, 8353::I,_
      8363::I, 8369::I, 8377::I, 8387::I, 8389::I, 8419::I,_
      8423::I, 8429::I, 8431::I, 8443::I, 8447::I, 8461::I,_
      8467::I, 8501::I, 8513::I, 8521::I, 8527::I, 8537::I,_
      8539::I, 8543::I, 8563::I, 8573::I, 8581::I, 8597::I,_
      8599::I, 8609::I, 8623::I, 8627::I, 8629::I, 8641::I,_
      8647::I, 8663::I, 8669::I, 8677::I, 8681::I, 8689::I,_
      8693::I, 8699::I, 8707::I, 8713::I, 8719::I, 8731::I,_
      8737::I, 8741::I, 8747::I, 8753::I, 8761::I, 8779::I,_
      8783::I, 8803::I, 8807::I, 8819::I, 8821::I, 8831::I,_
      8837::I, 8839::I, 8849::I, 8861::I, 8863::I, 8867::I,_
      8887::I, 8893::I, 8923::I, 8929::I, 8933::I, 8941::I,_
      8951::I, 8963::I, 8969::I, 8971::I, 8999::I, 9001::I,_
      9007::I, 9011::I, 9013::I, 9029::I, 9041::I, 9043::I,_
      9049::I, 9059::I, 9067::I, 9091::I, 9103::I, 9109::I,_
      9127::I, 9133::I, 9137::I, 9151::I, 9157::I, 9161::I,_
      9173::I, 9181::I, 9187::I, 9199::I, 9203::I, 9209::I,_
      9221::I, 9227::I, 9239::I, 9241::I, 9257::I, 9277::I,_
      9281::I, 9283::I, 9293::I, 9311::I, 9319::I, 9323::I,_
      9337::I, 9341::I, 9343::I, 9349::I, 9371::I, 9377::I,_
      9391::I, 9397::I, 9403::I, 9413::I, 9419::I, 9421::I,_
      9431::I, 9433::I, 9437::I, 9439::I, 9461::I, 9463::I,_
      9467::I, 9473::I, 9479::I, 9491::I, 9497::I, 9511::I,_
      9521::I, 9533::I, 9539::I, 9547::I, 9551::I, 9587::I,_
      9601::I, 9613::I, 9619::I, 9623::I, 9629::I, 9631::I,_
      9643::I, 9649::I, 9661::I, 9677::I, 9679::I, 9689::I,_
      9697::I, 9719::I, 9721::I, 9733::I, 9739::I, 9743::I,_
      9749::I, 9767::I, 9769::I, 9781::I, 9787::I, 9791::I,_
      9803::I, 9811::I, 9817::I, 9829::I, 9833::I, 9839::I,_
      9851::I, 9857::I, 9859::I, 9871::I, 9883::I, 9887::I,_
      9901::I, 9907::I, 9923::I, 9929::I, 9931::I, 9941::I,_
      9949::I, 9967::I, 9973::I]

   productSmallPrimes    := */smallPrimes
   nextSmallPrime        := 10007::I
   nextSmallPrimeSquared := nextSmallPrime**2
   two                   := 2::I
   tenPowerTwenty:=(10::I)**20
   PomeranceList:= [25326001::I, 161304001::I, 960946321::I, 1157839381::I,
                     -- 3215031751::I, -- has a factor of 151
                     3697278427::I, 5764643587::I, 6770862367::I,
                      14386156093::I, 15579919981::I, 18459366157::I,
                       19887974881::I, 21276028621::I ]::(List I)
   PomeranceLimit:=27716349961::I  -- replaces (25*10**9) due to Pinch
   PinchList:= _
     [3215031751::I, 118670087467::I, 128282461501::I, 354864744877::I,
      546348519181::I, 602248359169::I, 669094855201::I ]
   PinchLimit:= (10**12)::I
   PinchList2:= [2152302898747::I, 3474749660383::I]
   PinchLimit2:= (10**13)::I
   JaeschkeLimit:=341550071728321::I
   rootsMinus1:Set I := empty()
   -- used to check whether we detect too many roots of -1
   count2Order:Vector NonNegativeInteger := new(1,0)
   -- used to check whether we observe an element of maximal two-order

@
\subsection{primes}
<<package PRIMES IntegerPrimesPackage>>=
   primes(m, n) ==
      -- computes primes from m to n inclusive using prime?
      l:List(I) :=
        m <= two => [two]
        empty()
      n < two or n < m => empty()
      if even? m then m := m + 1
      ll:List(I) := [k::I for k in
             convert(m)@Integer..convert(n)@Integer by 2 | prime?(k::I)]
      reverse_! concat_!(ll, l)

   rabinProvesComposite : (I,I,I,I,NonNegativeInteger) -> Boolean
   rabinProvesCompositeSmall : (I,I,I,I,NonNegativeInteger) -> Boolean


@
\subsection{rabinProvesCompositeSmall}
<<package PRIMES IntegerPrimesPackage>>=
   rabinProvesCompositeSmall(p,n,nm1,q,k) ==
         -- probability n prime is > 3/4 for each iteration
         -- for most n this probability is much greater than 3/4
         t := powmod(p, q, n)
         -- neither of these cases tells us anything
         if not ((t = 1) or t = nm1) then
            for j in 1..k-1 repeat
               oldt := t
               t := mulmod(t, t, n)
               (t = 1) => return true
               -- we have squared someting not -1 and got 1
               t = nm1 =>
                   leave
            not (t = nm1) => return true
         false

@
\subsection{rabinProvesComposite}
<<package PRIMES IntegerPrimesPackage>>=
   rabinProvesComposite(p,n,nm1,q,k) ==
         -- probability n prime is > 3/4 for each iteration
         -- for most n this probability is much greater than 3/4
         t := powmod(p, q, n)
         -- neither of these cases tells us anything
         if t=nm1 then count2Order(1):=count2Order(1)+1
         if not ((t = 1) or t = nm1) then
            for j in 1..k-1 repeat
               oldt := t
               t := mulmod(t, t, n)
               (t = 1) => return true
               -- we have squared someting not -1 and got 1
               t = nm1 =>
                   rootsMinus1:=union(rootsMinus1,oldt)
                   count2Order(j+1):=count2Order(j+1)+1
                   leave
            not (t = nm1) => return true
         # rootsMinus1 > 2 => true  -- Z/nZ can't be a field
         false

@
\subsection{prime?}
<<package PRIMES IntegerPrimesPackage>>=
   prime? n ==
      n < two => false
      n < nextSmallPrime => member?(n, smallPrimes)
      not (gcd(n, productSmallPrimes) = 1) => false
      n < nextSmallPrimeSquared => true

      nm1 := n-1
      q := (nm1) quo two
      for k in 1.. while not odd? q repeat q := q quo two
      -- q = (n-1) quo 2**k for largest possible k

      n < JaeschkeLimit =>
          rabinProvesCompositeSmall(2::I,n,nm1,q,k) => return false
          rabinProvesCompositeSmall(3::I,n,nm1,q,k) => return false

          n < PomeranceLimit =>
              rabinProvesCompositeSmall(5::I,n,nm1,q,k) => return false
              member?(n,PomeranceList) => return false
              true

          rabinProvesCompositeSmall(7::I,n,nm1,q,k) => return false
          n < PinchLimit =>
              rabinProvesCompositeSmall(10::I,n,nm1,q,k) => return false
              member?(n,PinchList) => return false
              true

          rabinProvesCompositeSmall(5::I,n,nm1,q,k) => return false
          rabinProvesCompositeSmall(11::I,n,nm1,q,k) => return false
          n < PinchLimit2 =>
              member?(n,PinchList2) => return false
              true

          rabinProvesCompositeSmall(13::I,n,nm1,q,k) => return false
          rabinProvesCompositeSmall(17::I,n,nm1,q,k) => return false
          true

      rootsMinus1:= empty()
      count2Order := new(k,0) -- vector of k zeroes

      mn := minIndex smallPrimes
      for i in mn+1..mn+10 repeat
          rabinProvesComposite(smallPrimes i,n,nm1,q,k) => return false
      import IntegerRoots(I)
      q > 1 and perfectSquare?(3*n+1) => false
      ((n9:=n rem (9::I))=1 or n9 = -1) and perfectSquare?(8*n+1) => false
      -- Both previous tests from Damgard & Landrock
      currPrime:=smallPrimes(mn+10)
      probablySafe:=tenPowerTwenty
      while count2Order(k) = 0 or n > probablySafe repeat
          currPrime := nextPrime currPrime
          probablySafe:=probablySafe*(100::I)
          rabinProvesComposite(currPrime,n,nm1,q,k) => return false
      true

@
\subsection{nextPrime}
<<package PRIMES IntegerPrimesPackage>>=
   nextPrime n ==
      -- computes the first prime after n
      n < two => two
      if odd? n then n := n + two else n := n + 1
      while not prime? n repeat n := n + two
      n

@
\subsection{prevPrime}
<<package PRIMES IntegerPrimesPackage>>=
   prevPrime n ==
      -- computes the first prime before n
      n < 3::I => error "no primes less than 2"
      n = 3::I => two
      if odd? n then n := n - two else n := n - 1
      while not prime? n repeat n := n - two
      n

@
<<PRIMES.dotabb>>=
"PRIMES" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PRIMES"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"PRIMES" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IROOT IntegerRoots}
\pagehead{IntegerRoots}{IROOT}
\pagepic{ps/v104integerroots.ps}{IROOT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IROOT IntegerRoots>>=
)abbrev package IROOT IntegerRoots
++ Author: Michael Monagan
++ Date Created: November 1987
++ Date Last Updated:
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: integer roots
++ Examples:
++ References:
++ Description: The \spadtype{IntegerRoots} package computes square roots and
++   nth roots of integers efficiently.
IntegerRoots(I:IntegerNumberSystem): Exports == Implementation where
  NNI ==> NonNegativeInteger

  Exports ==> with
    perfectNthPower?: (I, NNI) -> Boolean
      ++ \spad{perfectNthPower?(n,r)} returns true if n is an \spad{r}th
      ++ power and false otherwise
    perfectNthRoot: (I,NNI) -> Union(I,"failed")
      ++ \spad{perfectNthRoot(n,r)} returns the \spad{r}th root of n if n
      ++ is an \spad{r}th power and returns "failed" otherwise
    perfectNthRoot: I -> Record(base:I, exponent:NNI)
      ++ \spad{perfectNthRoot(n)} returns \spad{[x,r]}, where \spad{n = x\^r}
      ++ and r is the largest integer such that n is a perfect \spad{r}th power
    approxNthRoot: (I,NNI) -> I
      ++ \spad{approxRoot(n,r)} returns an approximation x
      ++ to \spad{n**(1/r)} such that \spad{-1 < x - n**(1/r) < 1}
    perfectSquare?: I -> Boolean
      ++ \spad{perfectSquare?(n)} returns true if n is a perfect square
      ++ and false otherwise
    perfectSqrt: I -> Union(I,"failed")
      ++ \spad{perfectSqrt(n)} returns the square root of n if n is a
      ++ perfect square and returns "failed" otherwise
    approxSqrt: I -> I
      ++ \spad{approxSqrt(n)} returns an approximation x
      ++ to \spad{sqrt(n)} such that \spad{-1 < x - sqrt(n) < 1}.
      ++ Compute an approximation s to \spad{sqrt(n)} such that
      ++           \spad{-1 < s - sqrt(n) < 1}
      ++ A variable precision Newton iteration is used.
      ++ The running time is \spad{O( log(n)**2 )}.

  Implementation ==> add
    import IntegerPrimesPackage(I)

    resMod144: List I := [0::I,1::I,4::I,9::I,16::I,25::I,36::I,49::I,_
                     52::I,64::I,73::I,81::I,97::I,100::I,112::I,121::I]
    two := 2::I

@
\subsection{perfectSquare?}
<<package IROOT IntegerRoots>>=
    perfectSquare? a       == (perfectSqrt a) case I

@
\subsection{perfectNthPower?}
<<package IROOT IntegerRoots>>=
    perfectNthPower?(b, n) == perfectNthRoot(b, n) case I

@
\subsection{perfectNthRoot}
<<package IROOT IntegerRoots>>=
    perfectNthRoot n ==  -- complexity (log log n)**2 (log n)**2
      m:NNI
      (n = 1) or zero? n or n = -1 => [n, 1]
      e:NNI := 1
      p:NNI := 2
      while p::I <= length(n) + 1 repeat
         for m in 0.. while (r := perfectNthRoot(n, p)) case I repeat
            n := r::I
         e := e * p ** m
         p := convert(nextPrime(p::I))@Integer :: NNI
      [n, e]

@
\subsection{approxNthRoot}
<<package IROOT IntegerRoots>>=
    approxNthRoot(a, n) ==   -- complexity (log log n) (log n)**2
      zero? n => error "invalid arguments"
      (n = 1) => a
      n=2 => approxSqrt a
      negative? a =>
        odd? n => - approxNthRoot(-a, n)
        0
      zero? a => 0
      (a = 1) => 1
      -- quick check for case of large n
      ((3*n) quo 2)::I >= (l := length a) => two
      -- the initial approximation must be >= the root
      y := max(two, shift(1, (n::I+l-1) quo (n::I)))
      z:I := 1
      n1:= (n-1)::NNI
      while z > 0 repeat
        x := y
        xn:= x**n1
        y := (n1*x*xn+a) quo (n*xn)
        z := x-y
      x

@
\subsection{perfectNthRoot}
<<package IROOT IntegerRoots>>=
    perfectNthRoot(b, n) ==
      (r := approxNthRoot(b, n)) ** n = b => r
      "failed"

@
\subsection{perfectSqrt}
<<package IROOT IntegerRoots>>=
    perfectSqrt a ==
      a < 0 or not member?(a rem (144::I), resMod144) => "failed"
      (s := approxSqrt a) * s = a => s
      "failed"

@
\subsection{approxSqrt}
<<package IROOT IntegerRoots>>=
    approxSqrt a ==
      a < 1 => 0
      if (n := length a) > (100::I) then
         -- variable precision newton iteration
         n := n quo (4::I)
         s := approxSqrt shift(a, -2 * n)
         s := shift(s, n)
         return ((1 + s + a quo s) quo two)
      -- initial approximation for the root is within a factor of 2
      (new, old) := (shift(1, n quo two), 1)
      while new ^= old repeat
         (new, old) := ((1 + new + a quo new) quo two, new)
      new

@
<<IROOT.dotabb>>=
"IROOT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IROOT"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"IROOT" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTSLPE IntegerSolveLinearPolynomialEquation}
\pagehead{IntegerSolveLinearPolynomialEquation}{INTSLPE}
\pagepic{ps/v104integersolvelinearpolynomialequation.ps}{INTSLPE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTSLPE IntegerSolveLinearPolynomialEquation>>=
)abbrev package INTSLPE IntegerSolveLinearPolynomialEquation
++ Author: Davenport
++ Date Created: 1991
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package provides the implementation for the
++ \spadfun{solveLinearPolynomialEquation}
++ operation over the integers. It uses a lifting technique
++ from the package GenExEuclid
IntegerSolveLinearPolynomialEquation(): C ==T
 where
  ZP ==> SparseUnivariatePolynomial Integer
  C == with
      solveLinearPolynomialEquation: (List ZP,ZP) -> Union(List ZP,"failed")
           ++ solveLinearPolynomialEquation([f1, ..., fn], g)
           ++ (where the fi are relatively prime to each other)
           ++ returns a list of ai such that
           ++ \spad{g/prod fi = sum ai/fi}
           ++ or returns "failed" if no such list of ai's exists.
  T == add
      oldlp:List ZP := []
      slpePrime:Integer:=(2::Integer)
      oldtable:Vector List ZP := empty()
      solveLinearPolynomialEquation(lp,p) ==
         if (oldlp ^= lp) then
            -- we have to generate a new table
            deg:= _+/[degree u for u in lp]
            ans:Union(Vector List ZP,"failed"):="failed"
            slpePrime:=2147483647::Integer   -- 2**31 -1 : a prime
                 -- a good test case for this package is
                 --  ([x**31-1,x-2],2)
            while (ans case "failed") repeat
              ans:=tablePow(deg,slpePrime,lp)$GenExEuclid(Integer,ZP)
              if (ans case "failed") then
                 slpePrime:= prevPrime(slpePrime)$IntegerPrimesPackage(Integer)
            oldtable:=(ans:: Vector List ZP)
         answer:=solveid(p,slpePrime,oldtable)
         answer

@
<<INTSLPE.dotabb>>=
"INTSLPE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTSLPE"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INTSLPE" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IBATOOL IntegralBasisTools}
\pagehead{IntegralBasisTools}{IBATOOL}
\pagepic{ps/v104integralbasistools.ps}{IBATOOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IBATOOL IntegralBasisTools>>=
)abbrev package IBATOOL IntegralBasisTools
++ Functions common to both integral basis packages
++ Author: Victor Miller, Barry Trager, Clifton Williamson
++ Date Created: 11 April 1990
++ Date Last Updated: 20 September 1994
++ Keywords: integral basis, function field, number field
++ Examples:
++ References:
++ Description:
++ This package contains functions used in the packages
++ FunctionFieldIntegralBasis and NumberFieldIntegralBasis.

IntegralBasisTools(R,UP,F): Exports == Implementation where
  R  : EuclideanDomain with 
	squareFree: $ -> Factored $
		++ squareFree(x) returns a square-free factorisation of x 
  UP : UnivariatePolynomialCategory R
  F  : FramedAlgebra(R,UP)
  Mat ==> Matrix R
  NNI ==> NonNegativeInteger
  Ans ==> Record(basis: Mat, basisDen: R, basisInv:Mat)

  Exports ==> with

    diagonalProduct: Mat -> R
      ++ diagonalProduct(m) returns the product of the elements on the
      ++ diagonal of the matrix m
    matrixGcd: (Mat,R,NNI) -> R
      ++ matrixGcd(mat,sing,n) is \spad{gcd(sing,g)} where \spad{g} is the
      ++ gcd of the entries of the \spad{n}-by-\spad{n} upper-triangular
      ++ matrix \spad{mat}.
    divideIfCan_!: (Matrix R,Matrix R,R,Integer) -> R
      ++ divideIfCan!(matrix,matrixOut,prime,n) attempts to divide the
      ++ entries of \spad{matrix} by \spad{prime} and store the result in
      ++ \spad{matrixOut}.  If it is successful, 1 is returned and if not,
      ++ \spad{prime} is returned.  Here both \spad{matrix} and
      ++ \spad{matrixOut} are \spad{n}-by-\spad{n} upper triangular matrices.
    leastPower: (NNI,NNI) -> NNI
      ++ leastPower(p,n) returns e, where e is the smallest integer
      ++ such that \spad{p **e >= n}
    idealiser: (Mat,Mat) -> Mat
      ++ idealiser(m1,m2) computes the order of an ideal defined by m1 and m2
    idealiser: (Mat,Mat,R) -> Mat
      ++ idealiser(m1,m2,d) computes the order of an ideal defined by m1 and m2
      ++ where d is the known part of the denominator
    idealiserMatrix: (Mat, Mat) -> Mat
      ++ idealiserMatrix(m1, m2) returns the matrix representing the linear
      ++ conditions on the Ring associatied with an ideal defined by m1 and m2.
    moduleSum: (Ans,Ans) -> Ans
      ++ moduleSum(m1,m2) returns the sum of two modules in the framed
      ++ algebra \spad{F}.  Each module \spad{mi} is represented as follows:
      ++ F is a framed algebra with R-module basis \spad{w1,w2,...,wn} and
      ++ \spad{mi} is a record \spad{[basis,basisDen,basisInv]}.  If
      ++ \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ a basis \spad{v1,...,vn} for \spad{mi} is given by
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of 'basis' contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.

  Implementation ==> add
    import ModularHermitianRowReduction(R)
    import TriangularMatrixOperations(R, Vector R, Vector R, Matrix R)

    diagonalProduct m ==
      ans : R := 1
      for i in minRowIndex m .. maxRowIndex m
        for j in minColIndex m .. maxColIndex m repeat
          ans := ans * qelt(m, i, j)
      ans

    matrixGcd(mat,sing,n) ==
      -- note: 'matrix' is upper triangular;
      -- no need to do anything below the diagonal
      d := sing
      for i in 1..n repeat
        for j in i..n repeat
          if not zero?(mij := qelt(mat,i,j)) then d := gcd(d,mij)
--          one? d => return d
          (d = 1) => return d
      d

    divideIfCan_!(matrix,matrixOut,prime,n) ==
    -- note: both 'matrix' and 'matrixOut' will be upper triangular;
    -- no need to do anything below the diagonal
      for i in 1..n repeat
        for j in i..n repeat
          (a := (qelt(matrix,i,j) exquo prime)) case "failed" => return prime
          qsetelt_!(matrixOut,i,j,a :: R)
      1

    leastPower(p,n) ==
      -- efficiency is not an issue here
      e : NNI := 1; q := p
      while q < n repeat (e := e + 1; q := q * p)
      e

    idealiserMatrix(ideal,idealinv) ==
      -- computes the Order of the ideal
      n  := rank()$F
      bigm := zero(n * n,n)$Mat
      mr := minRowIndex bigm; mc := minColIndex bigm
      v := basis()$F
      for i in 0..n-1 repeat
        r := regularRepresentation qelt(v,i + minIndex v)
        m := ideal * r * idealinv
        for j in 0..n-1 repeat
          for k in 0..n-1 repeat
            bigm(j * n + k + mr,i + mc) := qelt(m,j + mr,k + mc)
      bigm

    idealiser(ideal,idealinv) ==
      bigm := idealiserMatrix(ideal, idealinv)
      transpose squareTop rowEch bigm

    idealiser(ideal,idealinv,denom) ==
      bigm := (idealiserMatrix(ideal, idealinv) exquo denom)::Mat
      transpose squareTop rowEchelon(bigm,denom)

    moduleSum(mod1,mod2) ==
      rb1 := mod1.basis; rbden1 := mod1.basisDen; rbinv1 := mod1.basisInv
      rb2 := mod2.basis; rbden2 := mod2.basisDen; rbinv2 := mod2.basisInv
      -- compatibility check: doesn't take much computation time
      (not square? rb1) or (not square? rbinv1) or (not square? rb2) _
        or (not square? rbinv2) =>
        error "moduleSum: matrices must be square"
      ((n := nrows rb1) ^= (nrows rbinv1)) or (n ^= (nrows rb2)) _
        or (n ^= (nrows rbinv2)) =>
        error "moduleSum: matrices of imcompatible dimensions"
      (zero? rbden1) or (zero? rbden2) =>
        error "moduleSum: denominator must be non-zero"
      den := lcm(rbden1,rbden2); c1 := den quo rbden1; c2 := den quo rbden2
      rb := squareTop rowEchelon(vertConcat(c1 * rb1,c2 * rb2),den)
      rbinv := UpTriBddDenomInv(rb,den)
      [rb,den,rbinv]

@
<<IBATOOL.dotabb>>=
"IBATOOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IBATOOL"]
"FRAMALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRAMALG"]
"IBATOOL" -> "FRAMALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IR2 IntegrationResultFunctions2}
\pagehead{IntegrationResultFunctions2}{IR2}
\pagepic{ps/v104integrationresultfunctions2.ps}{IR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IR2 IntegrationResultFunctions2>>=
)abbrev package IR2 IntegrationResultFunctions2
++ Internally used by the integration packages
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 12 August 1992
++ Keywords: integration.
IntegrationResultFunctions2(E, F): Exports == Implementation where
  E : Field
  F : Field

  SE  ==> Symbol
  Q   ==> Fraction Integer
  IRE ==> IntegrationResult E
  IRF ==> IntegrationResult F
  UPE ==> SparseUnivariatePolynomial E
  UPF ==> SparseUnivariatePolynomial F
  NEE ==> Record(integrand:E, intvar:E)
  NEF ==> Record(integrand:F, intvar:F)
  LGE ==> Record(scalar:Q, coeff:UPE, logand:UPE)
  LGF ==> Record(scalar:Q, coeff:UPF, logand:UPF)
  NLE ==> Record(coeff:E, logand:E)
  NLF ==> Record(coeff:F, logand:F)
  UFE ==> Union(Record(mainpart:E, limitedlogs:List NLE), "failed")
  URE ==> Union(Record(ratpart:E, coeff:E), "failed")
  UE  ==> Union(E, "failed")

  Exports ==> with
    map: (E -> F, IRE) -> IRF
	++ map(f,ire) \undocumented
    map: (E -> F, URE) -> Union(Record(ratpart:F, coeff:F), "failed")
	++ map(f,ure) \undocumented
    map: (E -> F,  UE) -> Union(F, "failed")
	++ map(f,ue) \undocumented
    map: (E -> F, UFE) ->
               Union(Record(mainpart:F, limitedlogs:List NLF), "failed")
	++ map(f,ufe) \undocumented

  Implementation ==> add
    import SparseUnivariatePolynomialFunctions2(E, F)

    NEE2F: (E -> F, NEE) -> NEF
    LGE2F: (E -> F, LGE) -> LGF
    NLE2F: (E -> F, NLE) -> NLF

    NLE2F(func, r)         == [func(r.coeff), func(r.logand)]
    NEE2F(func, n)         == [func(n.integrand), func(n.intvar)]
    map(func:E -> F, u:UE) == (u case "failed" => "failed"; func(u::E))

    map(func:E -> F, ir:IRE) ==
      mkAnswer(func ratpart ir, [LGE2F(func, f) for f in logpart ir],
                                   [NEE2F(func, g) for g in notelem ir])

    map(func:E -> F, u:URE) ==
      u case "failed" => "failed"
      [func(u.ratpart), func(u.coeff)]

    map(func:E -> F, u:UFE) ==
      u case "failed" => "failed"
      [func(u.mainpart), [NLE2F(func, f) for f in u.limitedlogs]]

    LGE2F(func, lg) ==
      [lg.scalar, map(func, lg.coeff), map(func, lg.logand)]

@
<<IR2.dotabb>>=
"IR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IR2"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"IR2" -> "FIELD"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IRRF2F IntegrationResultRFToFunction}
\pagehead{IntegrationResultRFToFunction}{IRRF2F}
\pagepic{ps/v104integrationresultrftofunction.ps}{IRRF2F}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IRRF2F IntegrationResultRFToFunction>>=
)abbrev package IRRF2F IntegrationResultRFToFunction
++ Conversion of integration results to top-level expressions
++ Author: Manuel Bronstein
++ Description:
++   This package allows a sum of logs over the roots of a polynomial
++   to be expressed as explicit logarithms and arc tangents, provided
++   that the indexing polynomial can be factored into quadratics.
++ Date Created: 21 August 1988
++ Date Last Updated: 4 October 1993
IntegrationResultRFToFunction(R): Exports == Implementation where
  R: Join(GcdDomain, RetractableTo Integer, OrderedSet,
           LinearlyExplicitRingOver Integer)

  RF  ==> Fraction Polynomial R
  F   ==> Expression R
  IR  ==> IntegrationResult RF

  Exports ==> with
    split           : IR -> IR
       ++ split(u(x) + sum_{P(a)=0} Q(a,x)) returns
       ++ \spad{u(x) + sum_{P1(a)=0} Q(a,x) + ... + sum_{Pn(a)=0} Q(a,x)}
       ++ where P1,...,Pn are the factors of P.
    expand          : IR -> List F
       ++ expand(i) returns the list of possible real functions
       ++ corresponding to i.
    complexExpand   : IR -> F
       ++ complexExpand(i) returns the expanded complex function
       ++ corresponding to i.
    if R has CharacteristicZero then
      integrate       : (RF, Symbol) -> Union(F, List F)
        ++ integrate(f, x) returns the integral of \spad{f(x)dx}
        ++ where x is viewed as a real variable..
      complexIntegrate: (RF, Symbol) -> F
        ++ complexIntegrate(f, x) returns the integral of \spad{f(x)dx}
        ++ where x is viewed as a complex variable.

  Implementation ==> add
    import IntegrationTools(R, F)
    import TrigonometricManipulations(R, F)
    import IntegrationResultToFunction(R, F)

    toEF: IR -> IntegrationResult F

    toEF i          == map(#1::F, i)$IntegrationResultFunctions2(RF, F)
    expand i        == expand toEF i
    complexExpand i == complexExpand toEF i

    split i ==
      map(retract, split toEF i)$IntegrationResultFunctions2(F, RF)

    if R has CharacteristicZero then
      import RationalFunctionIntegration(R)

      complexIntegrate(f, x) == complexExpand internalIntegrate(f, x)

-- do not use real integration if R is complex
      if R has imaginary: () -> R then integrate(f, x) == complexIntegrate(f, x)
      else
        integrate(f, x) ==
          l := [mkPrim(real g, x) for g in expand internalIntegrate(f, x)]
          empty? rest l => first l
          l

@
<<IRRF2F.dotabb>>=
"IRRF2F" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IRRF2F"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"IRRF2F" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IR2F IntegrationResultToFunction}
\pagehead{IntegrationResultToFunction}{IR2F}
\pagepic{ps/v104integrationresulttofunction.ps}{IR2F}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IR2F IntegrationResultToFunction>>=
)abbrev package IR2F IntegrationResultToFunction
++ Conversion of integration results to top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 4 February 1988
++ Date Last Updated: 9 October 1991
++ Description:
++   This package allows a sum of logs over the roots of a polynomial
++   to be expressed as explicit logarithms and arc tangents, provided
++   that the indexing polynomial can be factored into quadratics.
++ Keywords: integration, expansion, function.
IntegrationResultToFunction(R, F): Exports == Implementation where
  R: Join(GcdDomain, RetractableTo Integer, OrderedSet,
          LinearlyExplicitRingOver Integer)
  F: Join(AlgebraicallyClosedFunctionSpace R,
          TranscendentalFunctionCategory)

  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Z
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  IR  ==> IntegrationResult F
  REC ==> Record(ans1:F, ans2:F)
  LOG ==> Record(scalar:Q, coeff:UP, logand:UP)

  Exports ==> with
    split        : IR -> IR
       ++ split(u(x) + sum_{P(a)=0} Q(a,x)) returns
       ++ \spad{u(x) + sum_{P1(a)=0} Q(a,x) + ... + sum_{Pn(a)=0} Q(a,x)}
       ++ where P1,...,Pn are the factors of P.
    expand       : IR -> List F
       ++ expand(i) returns the list of possible real functions
       ++ corresponding to i.
    complexExpand: IR -> F
       ++ complexExpand(i) returns the expanded complex function
       ++ corresponding to i.

  Implementation ==> add
    import AlgebraicManipulations(R, F)
    import ElementaryFunctionSign(R, F)

    IR2F       : IR -> F
    insqrt     : F  -> Record(sqrt:REC, sgn:Z)
    pairsum    : (List F, List F) -> List F
    pairprod   : (F, List F) -> List F
    quadeval   : (UP, F, F, F) -> REC
    linear     : (UP, UP) -> F
    tantrick   : (F, F) -> F
    ilog       : (F, F, List K) -> F
    ilog0      : (F, F, UP, UP, F) -> F
    nlogs      : LOG -> List LOG
    lg2func    : LOG -> List F
    quadratic  : (UP, UP) -> List F
    mkRealFunc : List LOG -> List F
    lg2cfunc   : LOG -> F
    loglist    : (Q, UP, UP) -> List LOG
    cmplex     : (F, UP) -> F
    evenRoots  : F -> List F
    compatible?: (List F, List F) -> Boolean

    cmplex(alpha, p) == alpha * log p alpha
    IR2F i           == retract mkAnswer(ratpart i, empty(), notelem i)
    pairprod(x, l)   == [x * y for y in l]

    evenRoots x ==
      [first argument k for k in tower x |
       is?(k,"nthRoot"::Symbol) and even?(retract(second argument k)@Z)
         and (not empty? variables first argument k)]

    expand i ==
      j := split i
      pairsum([IR2F j], mkRealFunc logpart j)

    split i ==
      mkAnswer(ratpart i,concat [nlogs l for l in logpart i],notelem i)

    complexExpand i ==
      j := split i
      IR2F j + +/[lg.scalar::F * lg2cfunc lg for lg in logpart j]

-- p = a t^2 + b t + c
-- Expands sum_{p(t) = 0} t log(lg(t))
    quadratic(p, lg) ==
      zero?(delta := (b := coefficient(p, 1))**2 - 4 *
       (a := coefficient(p,2)) * (p0 := coefficient(p, 0))) =>
         [linear(monomial(1, 1) + (b / a)::UP, lg)]
      e := (q := quadeval(lg, c := - b * (d := inv(2*a)),d, delta)).ans1
      lgp  := c * log(nrm := (e**2 - delta * (f := q.ans2)**2))
      s    := (sqr := insqrt delta).sqrt
      pp := nn := 0$F
      if sqr.sgn >= 0 then
        sqrp := s.ans1 * rootSimp sqrt(s.ans2)
        pp := lgp + d * sqrp * log(((2 * e * f) / nrm) * sqrp
                                          + (e**2 + delta * f**2) / nrm)
      if sqr.sgn <= 0 then
        sqrn := s.ans1 * rootSimp sqrt(-s.ans2)
        nn := lgp + d * sqrn * ilog(e, f * sqrn,
                   setUnion(setUnion(kernels a, kernels b), kernels p0))
      sqr.sgn > 0 => [pp]
      sqr.sgn < 0 => [nn]
      [pp, nn]

-- returns 2 atan(a/b) or 2 atan(-b/a) whichever looks better
-- they differ by a constant so it's ok to do it from an IR
    tantrick(a, b) ==
      retractIfCan(a)@Union(Q, "failed") case Q => 2 * atan(-b/a)
      2 * atan(a/b)

-- transforms i log((a + i b) / (a - i b)) into a sum of real
-- arc-tangents using Rioboo's algorithm
-- lk is a list of kernels which are parameters for the integral
    ilog(a, b, lk) ==
      l := setDifference(setUnion(variables numer a, variables numer b),
           setUnion(lk, setUnion(variables denom a, variables denom b)))
      empty? l => tantrick(a, b)
      k := "max"/l
      ilog0(a, b, numer univariate(a, k), numer univariate(b, k), k::F)

-- transforms i log((a + i b) / (a - i b)) into a sum of real
-- arc-tangents using Rioboo's algorithm
-- the arc-tangents will not have k in the denominator
-- we always keep upa(k) = a  and upb(k) = b
    ilog0(a, b, upa, upb, k) ==
      if degree(upa) < degree(upb) then
        (upa, upb) := (-upb, upa)
        (a, b) := (-b, a)
      zero? degree upb => tantrick(a, b)
      r := extendedEuclidean(upa, upb)
      (g:= retractIfCan(r.generator)@Union(F,"failed")) case "failed" =>
        tantrick(a, b)
      if degree(r.coef1) >= degree upb then
        qr := divide(r.coef1, upb)
        r.coef1 := qr.remainder
        r.coef2 := r.coef2 + qr.quotient * upa
      aa := (r.coef2) k
      bb := -(r.coef1) k
      tantrick(aa * a + bb * b, g::F) + ilog0(aa,bb,r.coef2,-r.coef1,k)

    lg2func lg ==
      zero?(d := degree(p := lg.coeff)) => error "poly has degree 0"
--      one? d => [linear(p, lg.logand)]
      (d = 1) => [linear(p, lg.logand)]
      d = 2  => quadratic(p, lg.logand)
      odd? d and
        ((r := retractIfCan(reductum p)@Union(F, "failed")) case F) =>
            pairsum([cmplex(alpha := rootSimp zeroOf p, lg.logand)],
                    lg2func [lg.scalar,
                     (p exquo (monomial(1, 1)$UP - alpha::UP))::UP,
                      lg.logand])
      [lg2cfunc lg]

    lg2cfunc lg ==
      +/[cmplex(alpha, lg.logand) for alpha in zerosOf(lg.coeff)]

    mkRealFunc l ==
      ans := empty()$List(F)
      for lg in l repeat
        ans := pairsum(ans, pairprod(lg.scalar::F, lg2func lg))
      ans

-- returns a log(b)
    linear(p, lg) ==
      alpha := - coefficient(p, 0) / coefficient(p, 1)
      alpha * log lg alpha

-- returns (c, d) s.t. p(a + b t) = c + d t, where t^2 = delta
    quadeval(p, a, b, delta) ==
      zero? p => [0, 0]
      bi := c := d := 0$F
      ai := 1$F
      v  := vectorise(p, 1 + degree p)
      for i in minIndex v .. maxIndex v repeat
        c    := c + qelt(v, i) * ai
        d    := d + qelt(v, i) * bi
        temp := a * ai + b * bi * delta
        bi   := a * bi + b * ai
        ai   := temp
      [c, d]

    compatible?(lx, ly) ==
      empty? ly => true
      for x in lx repeat
        for y in ly repeat
          ((s := sign(x*y)) case Z) and (s::Z < 0) => return false
      true

    pairsum(lx, ly) ==
      empty? lx => ly
      empty? ly => lx
      l := empty()$List(F)
      for x in lx repeat
        ls := evenRoots x
        if not empty?(ln :=
          [x + y for y in ly | compatible?(ls, evenRoots y)]) then
            l := removeDuplicates concat(l, ln)
      l

-- returns [[a, b], s] where sqrt(y) = a sqrt(b) and
-- s = 1 if b > 0, -1 if b < 0, 0 if the sign of b cannot be determined
    insqrt y ==
      rec := froot(y, 2)$PolynomialRoots(IndexedExponents K, K, R, P, F)
--      one?(rec.exponent) => [[rec.coef * rec.radicand, 1], 1]
      ((rec.exponent) = 1) => [[rec.coef * rec.radicand, 1], 1]
      rec.exponent ^=2 => error "Should not happen"
      [[rec.coef, rec.radicand],
          ((s := sign(rec.radicand)) case "failed" => 0; s::Z)]

    nlogs lg ==
      [[f.exponent * lg.scalar, f.factor, lg.logand] for f in factors
         ffactor(primitivePart(lg.coeff)
                    )$FunctionSpaceUnivariatePolynomialFactor(R, F, UP)]

@
<<IR2F.dotabb>>=
"IR2F" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IR2F"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"IR2F" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IPRNTPK InternalPrintPackage}
\pagehead{InternalPrintPackage}{IPRNTPK}
\pagepic{ps/v104internalprintpackage.ps}{IPRNTPK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IPRNTPK InternalPrintPackage>>=
)abbrev package IPRNTPK InternalPrintPackage
++ Author: Themos Tsikas
++ Date Created: 09/09/1998
++ Date Last Updated: 09/09/1998
++ Basic Functions:
++ Related Constructors:
++ Also See: 
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: A package to print strings without line-feed 
++ nor carriage-return.

InternalPrintPackage(): Exports == Implementation where

  Exports ==  with
     iprint: String -> Void
       ++ \axiom{iprint(s)} prints \axiom{s} at the current position 
       ++ of the cursor.

  Implementation == add
     iprint(s:String) == 
          PRINC(coerce(s)@Symbol)$Lisp
          FORCE_-OUTPUT()$Lisp

@
<<IPRNTPK.dotabb>>=
"IPRNTPK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IPRNTPK"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"IPRNTPK" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IRREDFFX IrredPolyOverFiniteField}
\pagehead{IrredPolyOverFiniteField}{IRREDFFX}
\pagepic{ps/v104irredpolyoverfinitefield.ps}{IRREDFFX}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IRREDFFX IrredPolyOverFiniteField>>=
)abbrev package IRREDFFX IrredPolyOverFiniteField
++ Author: Robert S. Sutor (original)
++ Date Created: ???
++ Date Last Updated: 29 May 1990
++ Description:
++ This package exports the function generateIrredPoly that computes
++ a monic irreducible polynomial of degree n over a finite field.

IrredPolyOverFiniteField(GF:FiniteFieldCategory): Exports == Impl where
  N    ==> PositiveInteger
  Z    ==> Integer
  SUP  ==> SparseUnivariatePolynomial GF
  QR   ==> Record(quotient: Z, remainder: Z)

  Exports ==> with
    generateIrredPoly: N -> SUP
      ++ generateIrredPoly(n) generates an irreducible univariate
      ++ polynomial of the given degree n over the finite field.

  Impl ==> add
    import DistinctDegreeFactorize(GF, SUP)

    getIrredPoly  : (Z, N) -> SUP
    qAdicExpansion: Z -> SUP

    p := characteristic()$GF :: N
    q := size()$GF :: N

    qAdicExpansion(z : Z): SUP ==
      -- expands z as a sum of powers of q, with coefficients in GF
      -- z = HornerEval(qAdicExpansion z,q)
      qr := divide(z, q)
      zero?(qr.remainder) => monomial(1, 1) * qAdicExpansion(qr.quotient)
      r := index(qr.remainder pretend N)$GF :: SUP
      zero?(qr.quotient) => r
      r + monomial(1, 1) * qAdicExpansion(qr.quotient)

    getIrredPoly(start : Z, n : N) : SUP ==
      -- idea is to iterate over possibly irreducible monic polynomials
      -- until we find an irreducible one. The obviously reducible ones
      -- are avoided.
      mon := monomial(1, n)$SUP
      pol: SUP := 0
      found: Boolean := false
      end: Z := q**n - 1
      while not ((end < start) or found) repeat
        if gcd(start, p) = 1 then
          if irreducible?(pol := mon + qAdicExpansion(start)) then
            found := true
        start := start + 1
      zero? pol => error "no irreducible poly found"
      pol

    generateIrredPoly(n : N) : SUP ==
      -- want same poly every time
--      one?(n) => monomial(1, 1)$SUP
      (n = 1) => monomial(1, 1)$SUP
--      one?(gcd(p, n)) or (n < q) =>
      (gcd(p, n) = 1) or (n < q) =>
        odd?(n) => getIrredPoly(2, n)
        getIrredPoly(1, n)
      getIrredPoly(q + 1, n)

@
<<IRREDFFX.dotabb>>=
"IRREDFFX" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IRREDFFX"]
"FPC" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FPC"]
"IRREDFFX" -> "FPC"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IRSN IrrRepSymNatPackage}
\pagehead{IrrRepSymNatPackage}{IRSN}
\pagepic{ps/v104irrrepsymnatpackage.ps}{IRSN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IRSN IrrRepSymNatPackage>>=
)abbrev package IRSN IrrRepSymNatPackage
++ Authors: Johannes Grabmeier, Thorsten Werther
++ Date Created: 04 August 1988
++ Date Last Updated: 24 May 1991
++ Basic Operations: dimensionOfIrreducibleRepresentation
++   irreducibleRepresentation
++ Related Constructors: RepresentationTheoryPackage1
++   RepresentationTheoryPackage2
++ Also See: SymmetricGroupCombinatoricFunctions
++ AMS Classifications:
++ Keywords:
++ References:
++   G. James, A. Kerber: The Representation Theory of the Symmetric
++    Group. Encycl. of Math. and its Appl. Vol 16., Cambr. Univ Press 1981;
++   J. Grabmeier, A. Kerber: The Evaluation of Irreducible
++    Polynomial Representations of the General Linear Groups
++    and of the Unitary Groups over Fields of Characteristic 0,
++    Acta Appl. Math. 8 (1987), 271-291;
++   H. Gollan, J. Grabmeier: Algorithms in Representation Theory and
++    their Realization in the Computer Algebra System Scratchpad,
++    Bayreuther Mathematische Schriften, Heft 33, 1990, 1-23
++ Description:
++   IrrRepSymNatPackage contains functions for computing
++   the ordinary irreducible representations of symmetric groups on
++   n letters {\em {1,2,...,n}} in Young's natural form and their dimensions.
++   These representations can be labelled by number partitions of n,
++   i.e. a weakly decreasing sequence of integers summing up to n, e.g.
++   {\em [3,3,3,1]} labels an irreducible representation for n equals 10.
++   Note: whenever a \spadtype{List Integer} appears in a signature,
++   a partition required.
--   NOT TRUE in current system, but should:
--   also could be an element of \spadtype(Partition)

IrrRepSymNatPackage(): public == private where
  NNI   ==> NonNegativeInteger
  I     ==> Integer
  L     ==> List
  M     ==> Matrix
  V     ==> Vector
  B     ==> Boolean
  SGCF  ==> SymmetricGroupCombinatoricFunctions
  ICF   ==> IntegerCombinatoricFunctions Integer
  PP    ==> PartitionsAndPermutations
  PERM  ==> Permutation

  public ==> with

    dimensionOfIrreducibleRepresentation  : L I -> NNI
      ++ dimensionOfIrreducibleRepresentation(lambda) is the dimension
      ++ of the ordinary irreducible representation of the symmetric group
      ++ corresponding to {\em lambda}.
      ++ Note: the Robinson-Thrall hook formula is implemented.
    irreducibleRepresentation : (L I, PERM I) -> M I
      ++ irreducibleRepresentation(lambda,pi) is the irreducible representation
      ++ corresponding to partition {\em lambda} in Young's natural form of the
      ++ permutation {\em pi} in the symmetric group, whose elements permute
      ++ {\em {1,2,...,n}}.
    irreducibleRepresentation : L I -> L M I
      ++ irreducibleRepresentation(lambda) is the list of the two
      ++ irreducible representations corresponding to the partition {\em lambda}
      ++ in Young's natural form for the following two generators
      ++ of the symmetric group, whose elements permute
      ++ {\em {1,2,...,n}}, namely {\em (1 2)} (2-cycle) and
      ++ {\em (1 2 ... n)} (n-cycle).
    irreducibleRepresentation : (L I, L PERM I)  -> L M I
      ++ irreducibleRepresentation(lambda,listOfPerm) is the list of the
      ++ irreducible representations corresponding to {\em lambda}
      ++ in Young's natural form for the list of permutations
      ++ given by {\em listOfPerm}.

  private ==> add

    -- local variables
    oldlambda : L I  := nil$(L I)
    flambda   : NNI := 0           -- dimension of the irreducible repr.
    younglist : L M I := nil$(L M I)     -- list of all standard tableaus
    lprime    : L I  := nil$(L I)      -- conjugated partition of lambda
    n         : NNI := 0           -- concerning symmetric group S_n
    rows      : NNI := 0           -- # of rows of standard tableau
    columns   : NNI := 0           -- # of columns of standard tableau
    aId       : M I  := new(1,1,0)

    -- declaration of local functions

    aIdInverse : () -> Void
      -- computes aId, the inverse of the matrix
      -- (signum(k,l,id))_1 <= k,l <= flambda, where id
      -- denotes the identity permutation

    alreadyComputed? : L I -> Void
      -- test if the last calling of an exported function concerns
      -- the same partition lambda as the previous call

    listPermutation : PERM I -> L I   -- should be in Permutation
      -- converts a permutation pi into the list
      -- [pi(1),pi(2),..,pi(n)]

    signum : (NNI, NNI, L I) -> I
      -- if there exists a vertical permutation v of the tableau
      -- tl := pi o younglist(l) (l-th standard tableau)
      -- and a horizontal permutation h of the tableau
      -- tk := younglist(k) (k-th standard tableau)  such that
      --                v o tl = h o tk,
      -- then
      --            signum(k,l,pi) = sign(v),
      -- otherwise
      --            signum(k,l,pi) = 0.

    sumPartition : L I -> NNI
      -- checks if lambda is a proper partition and results in
      -- the sum of the entries

    testPermutation : L I -> NNI
      -- testPermutation(pi) checks if pi is an element of S_n,
      -- the set of permutations of the set {1,2,...,n}.
      -- If not, an error message will occur, if yes it replies n.


    -- definition of local functions


    aIdInverse() ==

      aId := new(flambda,flambda,0)
      for k in 1..flambda repeat
        aId(k,k) := 1
      if n < 5 then return aId

      idperm      : L I  := nil$(L I)
      for k in n..1 by -1 repeat
        idperm := cons(k,idperm)
      for k in 1..(flambda-1) repeat
        for l in (k+1)..flambda repeat
          aId(k::NNI,l::NNI) := signum(k::NNI,l::NNI,idperm)

      -- invert the upper triangular matrix aId
      for j in flambda..2 by -1 repeat
        for i in (j-1)..1 by -1 repeat
          aId(i::NNI,j:NNI) := -aId(i::NNI,j::NNI)
        for k in (j+1)..flambda repeat
          for i in (j-1)..1 by -1 repeat
            aId(i::NNI,k:NNI) := aId(i::NNI,k::NNI) +
                aId(i::NNI,j:NNI) * aId(j::NNI,k::NNI)


    alreadyComputed?(lambda) ==
      if not(lambda = oldlambda) then
        oldlambda := lambda
        lprime    := conjugate(lambda)$PP
        rows      := (first(lprime)$(L I))::NNI
        columns   := (first(lambda)$(L I))::NNI
        n         := (+/lambda)::NNI
        younglist := listYoungTableaus(lambda)$SGCF
        flambda   := #younglist
        aIdInverse()        -- side effect: creates actual aId

    listPermutation(pi) ==
      li : L I := nil$(L I)
      for k in n..1 by -1 repeat
        li := cons(eval(pi,k)$(PERM I),li)
      li

    signum(numberOfRowTableau, numberOfColumnTableau,pi) ==

      rowtab : M I  := copy younglist numberOfRowTableau
      columntab : M I  := copy younglist numberOfColumnTableau
      swap : I
      sign : I   := 1
      end  : B   := false
      endk : B
      ctrl : B

      -- k-loop for all rows of tableau rowtab
      k    : NNI := 1
      while (k <= rows) and (not end) repeat
        -- l-loop along the k-th row of rowtab
        l : NNI := 1
        while (l <= oldlambda(k)) and (not end) repeat
          z : NNI := l
          endk := false
          -- z-loop for k-th row of rowtab beginning at column l.
          -- test wether the entry rowtab(k,z) occurs in the l-th column
          -- beginning at row k of pi o columntab
          while (z <= oldlambda(k)) and (not endk) repeat
            s : NNI := k
            ctrl := true
            while ctrl repeat
              if (s <= lprime(l))
                then
                  if (1+rowtab(k,z) = pi(1+columntab(s,l)))
                  -- if entries in the tableaus were from 1,..,n, then
                  -- it should be ..columntab(s,l)... .
                    then ctrl := false
                    else s := s + 1
                else ctrl := false
            -- end of ctrl-loop
            endk := (s <= lprime(l)) -- same entry found ?
            if not endk
              then       -- try next entry
                z := z + 1
              else
                if k < s
                  then     -- verticalpermutation
                    sign := -sign
                    swap := columntab(s,l)
                    columntab(s,l) := columntab(k,l)
                    columntab(k,l) := swap
                if l < z
                  then     -- horizontalpermutation
                    swap := rowtab(k,z)
                    rowtab(k,z) := rowtab(k,l)
                    rowtab(k,l) := swap
              -- end of else
          -- end of z-loop
          if (z > oldlambda(k))  -- no coresponding entry found
            then
              sign := 0
              end := true
          l := l + 1
        -- end of l-loop
        k := k + 1
      -- end of k-loop

      sign


    sumPartition(lambda) ==
      ok   : B := true
      prev : I := first lambda
      sum  : I := 0
      for x in lambda repeat
        sum := sum + x
        ok := ok and (prev >= x)
        prev := x
      if not ok then
        error("No proper partition ")
      sum::NNI


    testPermutation(pi : L I) : NNI ==
      ok : B := true
      n  : I := 0
      for i in pi repeat
        if i > n then n  := i     -- find the largest entry n in pi
        if i < 1 then ok := false -- check whether there are entries < 1
      -- now n should be the number of permuted objects
      if (not (n=#pi)) or (not ok) then
        error("No permutation of 1,2,..,n")
      -- now we know that pi has n Elements ranging from 1 to n
      test : Vector(B) := new((n)::NNI,false)
      for i in pi repeat
        test(i) := true   -- this means that i occurs in pi
      if member?(false,test) then error("No permutation")  -- pi not surjective
      n::NNI


    -- definitions of exported functions


    dimensionOfIrreducibleRepresentation(lambda) ==
      nn : I :=  sumPartition(lambda)::I --also checks whether lambda
      dd : I := 1                        --is a partition
      lambdaprime : L I := conjugate(lambda)$PP
      -- run through all rows of the Youngtableau corr. to lambda
      for i in 1..lambdaprime.1 repeat
        -- run through all nodes in row i of the Youngtableau
        for j in 1..lambda.i repeat
            -- the hooklength of node (i,j) of the Youngtableau
            -- is the new factor, remember counting starts with 1
            dd := dd * (lambda.i + lambdaprime.j - i - j + 1)
      (factorial(nn)$ICF quo dd)::NNI


    irreducibleRepresentation(lambda:(L I),pi:(PERM I)) ==
      nn : NNI := sumPartition(lambda)
      alreadyComputed?(lambda)
      piList : L I := listPermutation pi
      if not (nn = testPermutation(piList)) then
        error("Partition and permutation are not consistent")
      aPi : M I := new(flambda,flambda,0)
      for k in 1..flambda repeat
        for l in 1..flambda repeat
          aPi(k,l) := signum(k,l,piList)
      aId * aPi


    irreducibleRepresentation(lambda) ==
      listperm : L PERM I := nil$(L PERM I)
      li       : L I  := nil$(L I)
      sumPartition(lambda)
      alreadyComputed?(lambda)
      listperm :=
        n = 1 =>  cons(1$(PERM I),listperm)
        n = 2 =>  cons(cycle([1,2])$(PERM I),listperm)
        -- the n-cycle (1,2,..,n) and the 2-cycle (1,2) generate S_n
        for k in n..1 by -1 repeat
          li := cons(k,li)  -- becomes n-cycle (1,2,..,n)
        listperm := cons(cycle(li)$(PERM I),listperm)
        -- 2-cycle (1,2)
        cons(cycle([1,2])$(PERM I),listperm)
      irreducibleRepresentation(lambda,listperm)


    irreducibleRepresentation(lambda:(L I),listperm:(L PERM I)) ==
      sumPartition(lambda)
      alreadyComputed?(lambda)
      [irreducibleRepresentation(lambda, pi) for pi in listperm]

@
<<IRSN.dotabb>>=
"IRSN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IRSN"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"IRSN" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INVLAPLA InverseLaplaceTransform}
\pagehead{InverseLaplaceTransform}{INVLAPLA}
\pagepic{ps/v104inverselaplacetransform.ps}{INVLAPLA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INVLAPLA InverseLaplaceTransform>>=
)abbrev package INVLAPLA InverseLaplaceTransform
++ Inverse Laplace transform
++ Author: Barry Trager
++ Date Created: 3 Sept 1991
++ Date Last Updated: 3 Sept 1991
++ Description: This package computes the inverse Laplace Transform.
InverseLaplaceTransform(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory, PrimitiveFunctionCategory,
           SpecialFunctionCategory, AlgebraicallyClosedFunctionSpace R)

  SE  ==> Symbol
  PI  ==> PositiveInteger
  N   ==> NonNegativeInteger
  K   ==> Kernel F
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP

  Exports ==> with
    inverseLaplace: (F, SE, SE) -> Union(F,"failed")
      ++ inverseLaplace(f, s, t) returns the Inverse
      ++ Laplace transform of \spad{f(s)}
      ++ using t as the new variable or "failed" if unable to find
      ++ a closed form.
      ++ Handles only rational \spad{f(s)}.

  Implementation ==> add

    -- local ops --
    ilt : (F,Symbol,Symbol) -> Union(F,"failed")
    ilt1 : (RF,F) -> F
    iltsqfr : (RF,F) -> F
    iltirred: (UP,UP,F) -> F
    freeOf?: (UP,Symbol) -> Boolean

    inverseLaplace(expr,ivar,ovar) == ilt(expr,ivar,ovar)

    freeOf?(p:UP,v:Symbol) ==
      "and"/[freeOf?(c,v) for c in coefficients p]

    ilt(expr,var,t) ==
      expr = 0 => 0
      r := univariate(expr,kernel(var))

      -- Check that r is a rational function such that degree of
      -- the numarator is lower that degree of denominator
      not(numer(r) quo denom(r) = 0) => "failed"
      not( freeOf?(numer r,var) and freeOf?(denom r,var)) => "failed"

      ilt1(r,t::F)

    hintpac := TranscendentalHermiteIntegration(F, UP)

    ilt1(r,t) ==
      r = 0 => 0
      rsplit := HermiteIntegrate(r, differentiate)$hintpac
      -t*ilt1(rsplit.answer,t) + iltsqfr(rsplit.logpart,t)

    iltsqfr(r,t) ==
       r = 0 => 0
       p:=numer r
       q:=denom r
     --  ql := [qq.factor for qq in factors factor q]
       ql := [qq.factor for qq in factors squareFree q]
       # ql = 1 => iltirred(p,q,t)
       nl := multiEuclidean(ql,p)::List(UP)
       +/[iltirred(a,b,t) for a in nl for b in ql]

    -- q is irreducible, monic, degree p < degree q
    iltirred(p,q,t) ==
      degree q = 1 =>
        cp := coefficient(p,0)
        (c:=coefficient(q,0))=0 => cp
        cp*exp(-c*t)
      degree q = 2 =>
        a := coefficient(p,1)
        b := coefficient(p,0)
        c:=(-1/2)*coefficient(q,1)
        d:= coefficient(q,0)
        e := exp(c*t)
        b := b+a*c
        d := d-c**2
        d > 0 =>
            alpha:F := sqrt d
            e*(a*cos(t*alpha) + b*sin(t*alpha)/alpha)
        alpha :F := sqrt(-d)
        e*(a*cosh(t*alpha) + b*sinh(t*alpha)/alpha)
      roots:List F := zerosOf q
      q1 := differentiate q
      +/[p(root)/q1(root)*exp(root*t) for root in roots]

@
<<INVLAPLA.dotabb>>=
"INVLAPLA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INVLAPLA"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"INVLAPLA" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter J}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter K}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package KERNEL2 KernelFunctions2}
\pagehead{KernelFunctions2}{KERNEL2}
\pagepic{ps/v104kernelfunctions2.ps}{KERNEL2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package KERNEL2 KernelFunctions2>>=
)abbrev package KERNEL2 KernelFunctions2
++ Description:
++ This package exports some auxiliary functions on kernels
KernelFunctions2(R:OrderedSet, S:OrderedSet): with
  constantKernel: R -> Kernel S
	++ constantKernel(r) \undocumented
  constantIfCan : Kernel S -> Union(R, "failed")
	++ constantIfCan(k) \undocumented

 == add
  import BasicOperatorFunctions1(R)

  constantKernel r == kernel(constantOperator r, nil(), 1)
  constantIfCan k  == constantOpIfCan operator k

@
<<KERNEL2.dotabb>>=
"KERNEL2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=KERNEL2"]
"ORDSET" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ORDSET"]
"KERNEL2" -> "ORDSET"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package KOVACIC Kovacic}
\pagehead{Kovacic}{KOVACIC}
\pagepic{ps/v104kovacic.ps}{KOVACIC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package KOVACIC Kovacic>>=
)abbrev package KOVACIC Kovacic
++ Author: Manuel Bronstein
++ Date Created: 14 January 1992
++ Date Last Updated: 3 February 1994
++ Description:
++ \spadtype{Kovacic} provides a modified Kovacic's algorithm for
++ solving explicitely irreducible 2nd order linear ordinary
++ differential equations.
++ Keywords: differential equation, ODE
Kovacic(F, UP): Exports == Impl where
  F  : Join(CharacteristicZero, AlgebraicallyClosedField,
            RetractableTo Integer, RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F
 
  RF  ==> Fraction UP
  SUP ==> SparseUnivariatePolynomial RF
  LF  ==> List Record(factor:UP, exponent:Integer)
  LODO==> LinearOrdinaryDifferentialOperator1 RF
 
  Exports ==> with
    kovacic: (RF, RF, RF) -> Union(SUP, "failed")
      ++ kovacic(a_0,a_1,a_2) returns either "failed" or P(u) such that
      ++ \spad{$e^{\int(-a_1/2a_2)} e^{\int u}$} is a solution of
      ++      \spad{a_2 y'' + a_1 y' + a0 y = 0}
      ++ whenever \spad{u} is a solution of \spad{P u = 0}.
      ++ The equation must be already irreducible over the rational functions.
    kovacic: (RF, RF, RF, UP -> Factored UP) -> Union(SUP, "failed")
      ++ kovacic(a_0,a_1,a_2,ezfactor) returns either "failed" or P(u) such
      ++ that \spad{$e^{\int(-a_1/2a_2)} e^{\int u}$} is a solution of
      ++      \spad{$a_2 y'' + a_1 y' + a0 y = 0$}
      ++ whenever \spad{u} is a solution of \spad{P u = 0}.
      ++ The equation must be already irreducible over the rational functions.
      ++ Argument \spad{ezfactor} is a factorisation in \spad{UP},
      ++ not necessarily into irreducibles.
 
  Impl ==> add
    import RationalRicDE(F, UP)
 
    case2       : (RF, LF, UP -> Factored UP) -> Union(SUP, "failed")
    cannotCase2?: LF -> Boolean
 
    kovacic(a0, a1, a2) == kovacic(a0, a1, a2, squareFree)
 
    -- it is assumed here that a2 y'' + a1 y' + a0 y is already irreducible
    -- over the rational functions, i.e. that the associated Riccati equation
    -- does NOT have rational solutions (so we don't check case 1 of Kovacic's
    -- algorithm)
    -- currently only check case 2, not 3
    kovacic(a0, a1, a2, ezfactor) ==
      -- transform first the equation to the form y'' = r y
      -- which makes the Galois group unimodular
      -- this does not change irreducibility over the rational functions
    -- the following is split into 5 lines in order to save a couple of
    -- hours of compile time.
      r:RF := a1**2 
      r := r + 2 * a2 * differentiate a1
      r := r - 2 * a1 * differentiate a2
      r := r - 4 * a0 * a2
      r := r  / (4 * a2**2)
      lf := factors squareFree denom r
      case2(r, lf, ezfactor)
 
    -- this is case 2 of Kovacic's algorithm, i.e. look for a solution
    -- of the associated Riccati equation in a quadratic extension
    -- lf is the squarefree factorisation of denom(r) and is used to
    -- check the necessary condition
    case2(r, lf, ezfactor) ==
      cannotCase2? lf => "failed"
      -- build the symmetric square of the operator L = y'' - r y
      -- which is L2 = y''' - 4 r y' - 2 r' y
      l2:LODO := monomial(1, 3) - monomial(4*r, 1) - 2 * differentiate(r)::LODO
      -- no solution in this case if L2 has no rational solution
      empty?(sol := ricDsolve(l2, ezfactor)) => "failed"
      -- otherwise the defining polynomial for an algebraic solution
      -- of the Ricatti equation associated with L is
      -- u^2 - b u + (1/2 b' + 1/2 b^2 - r) = 0
      -- where b is a rational solution of the Ricatti of L2
      b := first sol
      monomial(1, 2)$SUP - monomial(b, 1)$SUP
                         + ((differentiate(b) + b**2 - 2 * r) / (2::RF))::SUP
 
    -- checks the necessary condition for case 2
    -- returns true if case 2 cannot have solutions
    -- the necessary condition is that there is either a factor with
    -- exponent 2 or odd exponent > 2
    cannotCase2? lf ==
      for rec in lf repeat
        rec.exponent = 2 or (odd?(rec.exponent) and rec.exponent > 2) =>
          return false
      true

@
<<KOVACIC.dotabb>>=
"KOVACIC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=KOVACIC"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"KOVACIC" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter L}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LAPLACE LaplaceTransform}
\pagehead{LaplaceTransform}{LAPLACE}
\pagepic{ps/v104laplacetransform.ps}{LAPLACE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LAPLACE LaplaceTransform>>=
)abbrev package LAPLACE LaplaceTransform
++ Laplace transform
++ Author: Manuel Bronstein
++ Date Created: 30 May 1990
++ Date Last Updated: 13 December 1995
++ Description: This package computes the forward Laplace Transform.
LaplaceTransform(R, F): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)
  F : Join(TranscendentalFunctionCategory, PrimitiveFunctionCategory,
           AlgebraicallyClosedFunctionSpace R)

  SE  ==> Symbol
  PI  ==> PositiveInteger
  N   ==> NonNegativeInteger
  K   ==> Kernel F
  OFE ==> OrderedCompletion F
  EQ  ==> Equation OFE

  ALGOP       ==> "%alg"
  SPECIALDIFF ==> "%specialDiff"

  Exports ==> with
    laplace: (F, SE, SE) -> F
      ++ laplace(f, t, s) returns the Laplace transform of \spad{f(t)}
      ++ using \spad{s} as the new variable.
      ++ This is \spad{integral(exp(-s*t)*f(t), t = 0..%plusInfinity)}.
      ++ Returns the formal object \spad{laplace(f, t, s)} if it cannot
      ++ compute the transform.

  Implementation ==> add
    import IntegrationTools(R, F)
    import ElementaryIntegration(R, F)
    import PatternMatchIntegration(R, F)
    import PowerSeriesLimitPackage(R, F)
    import FunctionSpaceIntegration(R, F)
    import TrigonometricManipulations(R, F)

    locallaplace : (F, SE, F, SE, F) -> F
    lapkernel    : (F, SE, F, F) -> Union(F, "failed")
    intlaplace   : (F, F, F, SE, F) -> Union(F, "failed")
    isLinear     : (F, SE) -> Union(Record(const:F, nconst:F), "failed")
    mkPlus       : F -> Union(List F, "failed")
    dvlap        : (List F, SE) -> F
    tdenom       : (F, F) -> Union(F, "failed")
    atn          : (F, SE) -> Union(Record(coef:F, deg:PI), "failed")
    aexp         : (F, SE) -> Union(Record(coef:F, coef1:F, coef0:F), "failed")
    algebraic?   : (F, SE) -> Boolean

    oplap := operator("laplace"::Symbol, 3)$BasicOperator

    laplace(f,t,s) == locallaplace(complexElementary(f,t),t,t::F,s,s::F)

-- returns true if the highest kernel of f is algebraic over something
    algebraic?(f, t) ==
      l := varselect(kernels f, t)
      m:N := reduce(max, [height k for k in l], 0)$List(N)
      for k in l repeat
         height k = m and has?(operator k, ALGOP) => return true
      false

-- differentiate a kernel of the form  laplace(l.1,l.2,l.3) w.r.t x.
-- note that x is not necessarily l.3
-- if x = l.3, then there is no use recomputing the laplace transform,
-- it will remain formal anyways
    dvlap(l, x) ==
      l1 := first l
      l2 := second l
      x = (v := retract(l3 := third l)@SE) => - oplap(l2 * l1, l2, l3)
      e := exp(- l3 * l2)
      locallaplace(differentiate(e * l1, x) / e, retract(l2)@SE, l2, v, l3)

-- returns [b, c] iff f = c * t + b
-- and b and c do not involve t
    isLinear(f, t) ==
      ff := univariate(f, kernel(t)@K)
      ((d := retractIfCan(denom ff)@Union(F, "failed")) case "failed")
        or (degree(numer ff) > 1) => "failed"
      freeOf?(b := coefficient(numer ff, 0) / d, t) and
        freeOf?(c := coefficient(numer ff, 1) / d, t) => [b, c]
      "failed"

-- returns [a, n] iff f = a * t**n
    atn(f, t) ==
      if ((v := isExpt f) case Record(var:K, exponent:Integer)) then
        w := v::Record(var:K, exponent:Integer)
        (w.exponent > 0) and
          ((vv := symbolIfCan(w.var)) case SE) and (vv::SE = t) =>
            return [1, w.exponent::PI]
      (u := isTimes f) case List(F) =>
        c:F  := 1
        d:N  := 0
        for g in u::List(F) repeat
          if (rec := atn(g, t)) case Record(coef:F, deg:PI) then
            r := rec::Record(coef:F, deg:PI)
            c := c * r.coef
            d := d + r.deg
          else c := c * g
        zero? d => "failed"
        [c, d::PI]
      "failed"

-- returns [a, c, b] iff f = a * exp(c * t + b)
-- and b and c do not involve t
    aexp(f, t) ==
      is?(f, "exp"::SE) =>
        (v := isLinear(first argument(retract(f)@K),t)) case "failed" =>
           "failed"
        [1, v.nconst, v.const]
      (u := isTimes f) case List(F) =>
        c:F := 1
        c1 := c0 := 0$F
        for g in u::List(F) repeat
          if (r := aexp(g,t)) case Record(coef:F,coef1:F,coef0:F) then
            rec := r::Record(coef:F, coef1:F, coef0:F)
            c   := c * rec.coef
            c0  := c0 + rec.coef0
            c1  := c1 + rec.coef1
          else c := c * g
        zero? c0 and zero? c1 => "failed"
        [c, c1, c0]
      if (v := isPower f) case Record(val:F, exponent:Integer) then
        w := v::Record(val:F, exponent:Integer)
        (w.exponent ^= 1) and
          ((r := aexp(w.val, t)) case Record(coef:F,coef1:F,coef0:F)) =>
            rec := r::Record(coef:F, coef1:F, coef0:F)
            return [rec.coef ** w.exponent, w.exponent * rec.coef1,
                                            w.exponent * rec.coef0]
      "failed"

    mkPlus f ==
      (u := isPlus numer f) case "failed" => "failed"
      d := denom f
      [p / d for p in u::List(SparseMultivariatePolynomial(R, K))]

-- returns g if f = g/t
    tdenom(f, t) ==
      (denom f exquo numer t) case "failed" => "failed"
      t * f

    intlaplace(f, ss, g, v, vv) ==
      is?(g, oplap) or ((i := integrate(g, v)) case List(F)) => "failed"
      (u:=limit(i::F,equation(vv::OFE,plusInfinity()$OFE)$EQ)) case OFE =>
        (l := limit(i::F, equation(vv::OFE, ss::OFE)$EQ)) case OFE =>
          retractIfCan(u::OFE - l::OFE)@Union(F, "failed")
        "failed"
      "failed"

    lapkernel(f, t, tt, ss) ==
      (k := retractIfCan(f)@Union(K, "failed")) case "failed" => "failed"
      empty?(arg := argument(k::K)) => "failed"
      is?(op := operator k, "%diff"::SE) =>
        not( #arg = 3) => "failed"
        not(is?(arg.3, t)) => "failed"
        fint := eval(arg.1, arg.2, tt)
        s := name operator (kernels(ss).1)
        ss * locallaplace(fint, t, tt, s, ss) - eval(fint, tt = 0)
      not (empty?(rest arg)) => "failed"
      member?(t, variables(a := first(arg) / tt)) => "failed"
      is?(op := operator k, "Si"::SE) => atan(a / ss) / ss
      is?(op, "Ci"::SE) => log((ss**2 + a**2) / a**2) / (2 * ss)
      is?(op, "Ei"::SE) => log((ss + a) / a) / ss
      -- digamma (or Gamma) needs SpecialFunctionCategory
      -- which we do not have here
      -- is?(op, "log"::SE) => (digamma(1) - log(a) - log(ss)) / ss
      "failed"

    -- Below we try to apply one of the texbook rules for computing
    -- Laplace transforms, either reducing problem to simpler cases
    -- or using one of known base cases
    locallaplace(f, t, tt, s, ss) ==
      zero? f => 0
--      one? f  => inv ss
      (f = 1)  => inv ss

      -- laplace(f(t)/t,t,s) 
      --              = integrate(laplace(f(t),t,v), v = s..%plusInfinity)
      (x := tdenom(f, tt)) case F =>
        g := locallaplace(x::F, t, tt, vv := new()$SE, vvv := vv::F)
        (x := intlaplace(f, ss, g, vv, vvv)) case F => x::F
        oplap(f, tt, ss)

      -- Use linearity
      (u := mkPlus f) case List(F) =>
        +/[locallaplace(g, t, tt, s, ss) for g in u::List(F)]
      (rec := splitConstant(f, t)).const ^= 1 =>
        rec.const * locallaplace(rec.nconst, t, tt, s, ss)

      -- laplace(t^n*f(t),t,s) = (-1)^n*D(laplace(f(t),t,s), s, n))
      (v := atn(f, t)) case Record(coef:F, deg:PI) =>
        vv := v::Record(coef:F, deg:PI)
        is?(la := locallaplace(vv.coef, t, tt, s, ss), oplap) => oplap(f,tt,ss)
        (-1$Integer)**(vv.deg) * differentiate(la, s, vv.deg)

      -- Complex shift rule
      (w := aexp(f, t)) case Record(coef:F, coef1:F, coef0:F) =>
        ww := w::Record(coef:F, coef1:F, coef0:F)
        exp(ww.coef0) * locallaplace(ww.coef,t,tt,s,ss - ww.coef1)

      -- Try base cases
      (x := lapkernel(f, t, tt, ss)) case F => x::F

--    -- The following does not seem to help computing transforms, but
--    -- quite frequently leads to loops, so I (wh) disabled it for now
--    -- last chance option: try to use the fact that
--    --    laplace(f(t),t,s) = s laplace(g(t),t,s) - g(0)  where dg/dt = f(t)
--    elem?(int := lfintegrate(f, t)) and (rint := retractIfCan int) case F =>
--        fint := rint :: F
--        -- to avoid infinite loops, we don't call laplace recursively
--        -- if the integral has no new logs and f is an algebraic function
--        empty?(logpart int) and algebraic?(f, t) => oplap(fint, tt, ss)
--        ss * locallaplace(fint, t, tt, s, ss) - eval(fint, tt = 0)
      oplap(f, tt, ss)

    setProperty(oplap,SPECIALDIFF,dvlap@((List F,SE)->F) pretend None)

@
<<LAPLACE.dotabb>>=
"LAPLACE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LAPLACE"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"LAPLACE" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LAZM3PK LazardSetSolvingPackage}
\pagehead{LazardSetSolvingPackage}{LAZM3PK}
\pagepic{ps/v104lazardsetsolvingpackage.ps}{LAZM3PK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LAZM3PK LazardSetSolvingPackage>>=
)abbrev package LAZM3PK LazardSetSolvingPackage
++ Author: Marc Moreno Maza
++ Date Created: 10/02/1998
++ Date Last Updated: 12/16/1998
++ Basic Functions:
++ Related Constructors:
++ Also See: 
++ AMS Classifications:
++ Keywords:
++ Description: 
++ A package for solving polynomial systems by means of Lazard triangular
++ sets [1]. 
++ This package provides two operations. One for solving in the sense
++ of the regular zeros, and the other for solving in the sense of
++ the Zariski closure. Both produce square-free regular sets. 
++ Moreover, the decompositions do not contain any redundant component.
++ However, only zero-dimensional regular sets are normalized, since
++ normalization may be time consumming in positive dimension.
++ The decomposition process is that of [2].\newline
++ References :
++  [1] D. LAZARD "A new method for solving algebraic systems of 
++      positive dimension" Discr. App. Math. 33:147-160,1991
++  [2] M. MORENO MAZA "A new algorithm for computing triangular
++      decomposition of algebraic varieties" NAG Tech. Rep. 4/98.
++ Version: 1. 

LazardSetSolvingPackage(R,E,V,P,TS,ST): Exports == Implementation where

  R : GcdDomain
  E : OrderedAbelianMonoidSup
  V : OrderedSet
  P : RecursivePolynomialCategory(R,E,V)
  TS: RegularTriangularSetCategory(R,E,V,P)
  ST : SquareFreeRegularTriangularSetCategory(R,E,V,P)
  N ==> NonNegativeInteger
  Z ==> Integer
  B ==> Boolean
  S ==> String
  K ==> Fraction R
  LP ==> List P
  PWT ==> Record(val : P, tower : TS)
  BWT ==> Record(val : Boolean, tower : TS)
  LpWT ==> Record(val : (List P), tower : TS)
  Split ==> List TS
  --KeyGcd ==> Record(arg1: P, arg2: P, arg3: TS, arg4: B)
  --EntryGcd ==> List PWT
  --HGcd ==> TabulatedComputationPackage(KeyGcd, EntryGcd)
  --KeyInvSet ==> Record(arg1: P, arg3: TS)
  --EntryInvSet ==> List TS
  --HInvSet ==> TabulatedComputationPackage(KeyInvSet, EntryInvSet)
  polsetpack ==> PolynomialSetUtilitiesPackage(R,E,V,P)
  regsetgcdpack ==> SquareFreeRegularTriangularSetGcdPackage(R,E,V,P,ST)
  quasicomppack ==> SquareFreeQuasiComponentPackage(R,E,V,P,ST)
  normalizpack ==> NormalizationPackage(R,E,V,P,ST)

  Exports ==  with

     normalizeIfCan: ST -> ST
       ++ \axiom{normalizeIfCan(ts)} returns \axiom{ts} in an normalized shape
       ++ if \axiom{ts} is zero-dimensional.
     zeroSetSplit: (LP, B) -> List ST
       ++ \axiom{zeroSetSplit(lp,clos?)} has the same specifications as
       ++ \axiomOpFrom{zeroSetSplit(lp,clos?)}{RegularTriangularSetCategory}.

  Implementation == add

     convert(st: ST): TS ==
       ts: TS := empty()
       lp: LP := members(st)$ST
       lp := sort(infRittWu?,lp)
       for p in lp repeat
         ts := internalAugment(p,ts)$TS
       ts

     squareFree(ts: TS): List ST ==
       empty? ts => [empty()$ST]
       lp: LP := members(ts)$TS
       lp := sort(infRittWu?,lp)
       newts: ST := empty()$ST
       toSee: List ST := [newts]
       toSave: List ST
       for p in lp repeat
         toSave := []
         while (not empty? toSee) repeat
           us := first toSee; toSee := rest toSee
           lpwt := stoseSquareFreePart(p,us)$regsetgcdpack
           for pwt in lpwt repeat
             newus := internalAugment(pwt.val,pwt.tower)$ST
             toSave := cons(newus,toSave)
         toSee := toSave
       toSave

     normalizeIfCan(ts: ST): ST ==
       empty? ts => ts
       lp: LP := members(ts)$ST
       lp := sort(infRittWu?,lp)
       p: P := first lp
       not univariate?(p)$polsetpack => ts
       lp := rest lp
       newts: ST := empty()$ST
       newts := internalAugment(p,newts)$ST
       while (not empty? lp) repeat
         p := first lp
         lv := variables(p)
         for v in lv repeat
           v = mvar(p) => "leave"
           not algebraic?(v,newts) => return internalAugment(lp,newts)$ST
         lp := rest lp
         p := normalizedAssociate(p,newts)$normalizpack
         newts := internalAugment(p,newts)$ST
       newts

     zeroSetSplit(lp:List(P), clos?:B): List ST ==
       -- if clos? then SOLVE in the closure sense 
       toSee: Split := zeroSetSplit(lp, clos?)$TS
       toSave: List ST := []
       for ts in toSee repeat 
         toSave := concat(squareFree(ts),toSave)
       toSave := removeSuperfluousQuasiComponents(toSave)$quasicomppack
       [normalizeIfCan(ts) for ts in toSave]

@
<<LAZM3PK.dotabb>>=
"LAZM3PK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LAZM3PK"]
"SFRTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=SFRTCAT"]
"LAZM3PK" -> "SFRTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LEADCDET LeadingCoefDetermination}
\pagehead{LeadingCoefDetermination}{LEADCDET}
\pagepic{ps/v104leadingcoefdetermination.ps}{LEADCDET}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LEADCDET LeadingCoefDetermination>>=
)abbrev package LEADCDET LeadingCoefDetermination
++ Author : P.Gianni, May 1990
++ Description:
++ Package for leading coefficient determination in the lifting step.
++ Package working for every R euclidean with property "F".
LeadingCoefDetermination(OV,E,Z,P) : C == T
 where
  OV    :   OrderedSet
  E     :   OrderedAbelianMonoidSup
  Z     :   EuclideanDomain
  BP        ==> SparseUnivariatePolynomial Z
  P         :   PolynomialCategory(Z,E,OV)
  NNI       ==> NonNegativeInteger
  LeadFact  ==> Record(polfac:List(P),correct:Z,corrfact:List(BP))
  ParFact   ==> Record(irr:P,pow:Integer)
  FinalFact ==> Record(contp:Z,factors:List(ParFact))
 
  C == with
   polCase  : (Z,NNI,List(Z)) -> Boolean
     ++ polCase(contprod, numFacts, evallcs), where contprod is the
     ++ product of the content of the leading coefficient of
     ++ the polynomial to be factored with the content of the
     ++ evaluated polynomial, numFacts is the number of factors
     ++ of the leadingCoefficient, and evallcs is the list of
     ++ the evaluated factors of the leadingCoefficient, returns
     ++ true if the factors of the leading Coefficient can be
     ++ distributed with this valuation.
   distFact : (Z,List(BP),FinalFact,List(Z),List(OV),List(Z)) ->
                                              Union(LeadFact,"failed")
     ++ distFact(contm,unilist,plead,vl,lvar,lval), where contm is
     ++ the content of the evaluated polynomial, unilist is the list
     ++ of factors of the evaluated polynomial, plead is the complete
     ++ factorization of the leading coefficient, vl is the list
     ++ of factors of the leading coefficient evaluated, lvar is the
     ++ list of variables, lval is the list of values, returns a record
     ++ giving the list of leading coefficients to impose on the univariate
     ++ factors, 
 
  T == add
    distribute: (Z,List(BP),List(P),List(Z),List(OV),List(Z)) -> LeadFact
    checkpow  : (Z,Z) -> NNI
 
    polCase(d:Z,nk:NNI,lval:List(Z)):Boolean ==
      -- d is the product of the content lc m (case polynomial)
      -- and the cont of the polynomial evaluated
      q:Z
      distlist:List(Z) := [d]
      for i in 1..nk repeat
        q := unitNormal(lval.i).canonical
        for j in 0..(i-1)::NNI repeat
          y := distlist.((i-j)::NNI)
          while y^=1  repeat
            y := gcd(y,q)
            q := q quo y
          if q=1 then return false
        distlist := append(distlist,[q])
      true
 
    checkpow(a:Z,b:Z) : NonNegativeInteger ==
      qt: Union(Z,"failed")
      for i in 0.. repeat
        qt:= b exquo a
        if qt case "failed" then return i
        b:=qt::Z
 
    distribute(contm:Z,unilist:List(BP),pl:List(P),vl:List(Z),
                              lvar:List(OV),lval:List(Z)): LeadFact ==
      d,lcp : Z
      nf:NNI:=#unilist
      for i in 1..nf repeat
          lcp := leadingCoefficient (unilist.i)
          d:= gcd(lcp,vl.i)
          pl.i := (lcp quo d)*pl.i
          d := vl.i quo d
          unilist.i := d*unilist.i
          contm := contm quo d
      if contm ^=1 then for i in 1..nf repeat pl.i := contm*pl.i
      [pl,contm,unilist]$LeadFact
 
    distFact(contm:Z,unilist:List(BP),plead:FinalFact,
             vl:List(Z),lvar:List(OV),lval:List(Z)):Union(LeadFact,"failed") ==
      h:NonNegativeInteger
      c,d : Z
      lpol:List(P):=[]
      lexp:List(Integer):=[]
      nf:NNI := #unilist
      vl := reverse vl --lpol and vl reversed so test from right to left
      for fpl in plead.factors repeat
       lpol:=[fpl.irr,:lpol]
       lexp:=[fpl.pow,:lexp]
      vlp:List(Z):= [1$Z for i in 1..nf]
      aux : List(P) := [1$P for i in 1..nf]
      for i in 1..nf repeat
        c := contm*leadingCoefficient unilist.i
        c=1 or c=-1  => "next i"
        for k in 1..(# lpol) repeat
          lexp.k=0 => "next factor"
          h:= checkpow(vl.k,c)
          if h ^=0 then
           if h>lexp.k then return "failed"
           lexp.k:=lexp.k-h
           aux.i := aux.i*(lpol.k ** h)
           d:= vl.k**h
           vlp.i:= vlp.i*d
           c:= c quo d
        if contm=1 then vlp.i:=c
      for k in 1..(# lpol) repeat if lexp.k ^= 0 then return "failed"
      contm =1 => [[vlp.i*aux.i for i in 1..nf],1,unilist]$LeadFact
      distribute(contm,unilist,aux,vlp,lvar,lval)

@
<<LEADCDET.dotabb>>=
"LEADCDET" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LEADCDET"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"LEADCDET" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LINDEP LinearDependence}
\pagehead{LinearDependence}{LINDEP}
\pagepic{ps/v104lineardependence.ps}{LINDEP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LINDEP LinearDependence>>=
)abbrev package LINDEP LinearDependence
++ Test for linear dependence
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: 14 May 1991
++ Description: Test for linear dependence.
LinearDependence(S, R): Exports == Implementation where
  S: IntegralDomain
  R: LinearlyExplicitRingOver S

  Q ==> Fraction S

  Exports ==> with
    linearlyDependent?: Vector R -> Boolean
      ++ \spad{linearlyDependent?([v1,...,vn])} returns true if
      ++ the vi's are linearly dependent over S, false otherwise.
    linearDependence  : Vector R -> Union(Vector S, "failed")
      ++ \spad{linearDependence([v1,...,vn])} returns \spad{[c1,...,cn]} if
      ++ \spad{c1*v1 + ... + cn*vn = 0} and not all the ci's are 0,
      ++ "failed" if the vi's are linearly independent over S.
    if S has Field then
      solveLinear: (Vector R, R) -> Union(Vector S, "failed")
        ++ \spad{solveLinear([v1,...,vn], u)} returns \spad{[c1,...,cn]}
        ++ such that \spad{c1*v1 + ... + cn*vn = u},
        ++ "failed" if no such ci's exist in S.
    else
      solveLinear: (Vector R, R) -> Union(Vector Q, "failed")
        ++ \spad{solveLinear([v1,...,vn], u)} returns \spad{[c1,...,cn]}
        ++ such that \spad{c1*v1 + ... + cn*vn = u},
        ++ "failed" if no such ci's exist in the quotient field of S.

  Implementation ==> add
    aNonZeroSolution: Matrix S -> Union(Vector S, "failed")

    aNonZeroSolution m ==
      every?(zero?, v := first nullSpace m) => "failed"
      v

    linearlyDependent? v ==
      zero?(n := #v) => true
--      one? n => zero?(v(minIndex v))
      (n = 1) => zero?(v(minIndex v))
      positive? nullity reducedSystem transpose v

    linearDependence v ==
      zero?(n := #v) => empty()
--      one? n =>
      (n = 1) =>
        zero?(v(minIndex v)) => new(1, 1)
        "failed"
      aNonZeroSolution reducedSystem transpose v

    if S has Field then
      solveLinear(v:Vector R, c:R):Union(Vector S, "failed") ==
        zero? c => new(#v, 0)
        empty? v => "failed"
        sys := reducedSystem(transpose v, new(1, c))
        particularSolution(sys.mat, sys.vec)$LinearSystemMatrixPackage(S,
                                           Vector S, Vector S, Matrix S)

    else
      solveLinear(v:Vector R, c:R):Union(Vector Q, "failed") ==
        zero? c => new(#v, 0)
        empty? v => "failed"
        sys := reducedSystem(transpose v, new(1, c))
        particularSolution(map(#1::Q, sys.mat)$MatrixCategoryFunctions2(S,
               Vector S,Vector S,Matrix S,Q,Vector Q,Vector Q,Matrix Q),
                  map(#1::Q, sys.vec)$VectorFunctions2(S, Q)
                                    )$LinearSystemMatrixPackage(Q,
                                           Vector Q, Vector Q, Matrix Q)

@
<<LINDEP.dotabb>>=
"LINDEP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LINDEP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"LINDEP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LODOF LinearOrdinaryDifferentialOperatorFactorizer}
\pagehead{LinearOrdinaryDifferentialOperatorFactorizer}{LODOF}
\pagepic{ps/v104linearordinarydifferentialoperatorfactorizer.ps}{LODOF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LODOF LinearOrdinaryDifferentialOperatorFactorizer>>=
)abbrev package LODOF LinearOrdinaryDifferentialOperatorFactorizer
++ Author: Fritz Schwarz, Manuel Bronstein
++ Date Created: 1988
++ Date Last Updated: 3 February 1994
++ Description:
++ \spadtype{LinearOrdinaryDifferentialOperatorFactorizer} provides a
++ factorizer for linear ordinary differential operators whose coefficients
++ are rational functions.
++ Keywords: differential equation, ODE, LODO, factoring
LinearOrdinaryDifferentialOperatorFactorizer(F, UP): Exports == Impl where
  F : Join(Field, CharacteristicZero,
           RetractableTo Integer, RetractableTo Fraction Integer)
  UP: UnivariatePolynomialCategory F
 
  RF ==> Fraction UP
  L  ==> LinearOrdinaryDifferentialOperator1 RF
 
  Exports ==> with
    factor: (L, UP -> List F) -> List L
      ++ factor(a, zeros) returns the factorisation of a.
      ++ \spad{zeros} is a zero finder in \spad{UP}.
    if F has AlgebraicallyClosedField then
      factor: L -> List L
        ++ factor(a) returns the factorisation of a.
      factor1: L -> List L
        ++ factor1(a) returns the factorisation of a,
        ++ assuming that a has no first-order right factor.
 
  Impl ==> add
    import RationalLODE(F, UP)
    import RationalRicDE(F, UP)
--  import AssociatedEquations RF
 
    dd := D()$L
 
    expsol     : (L, UP -> List F, UP -> Factored UP) -> Union(RF, "failed")
    expsols    : (L, UP -> List F, UP -> Factored UP, Boolean) -> List RF
    opeval     : (L, L) -> L
    recurfactor: (L, L, UP -> List F, UP -> Factored UP, Boolean) -> List L
    rfactor    : (L, L, UP -> List F, UP -> Factored UP, Boolean) -> List L
    rightFactor: (L, NonNegativeInteger, UP -> List F, UP -> Factored UP)
                                                          -> Union(L, "failed")
    innerFactor: (L, UP -> List F, UP -> Factored UP, Boolean) -> List L
 
    factor(l, zeros) == innerFactor(l, zeros, squareFree, true)
 
    expsol(l, zeros, ezfactor) ==
      empty?(sol := expsols(l, zeros, ezfactor, false)) => "failed"
      first sol
 
    expsols(l, zeros, ezfactor, all?) ==
      sol := [differentiate(f)/f for f in ratDsolve(l, 0).basis | f ^= 0]
      not(all? or empty? sol) => sol
      concat(sol, ricDsolve(l, zeros, ezfactor))
 
-- opeval(l1, l2) returns l1(l2)
    opeval(l1, l2) ==
      ans:L := 0
      l2n:L := 1
      for i in 0..degree l1 repeat
        ans := ans + coefficient(l1, i) * l2n
        l2n := l2 * l2n
      ans
      
    recurfactor(l, r, zeros, ezfactor, adj?) ==
      q := rightExactQuotient(l, r)::L
      if adj? then q := adjoint q
      innerFactor(q, zeros, ezfactor, true)
 
    rfactor(op, r, zeros, ezfactor, adj?) ==
--      degree r > 1 or not one? leadingCoefficient r =>
      degree r > 1 or not ((leadingCoefficient r) = 1) =>
        recurfactor(op, r, zeros, ezfactor, adj?)
      op1 := opeval(op, dd - coefficient(r, 0)::L)
      map_!(opeval(#1, r), recurfactor(op1, dd, zeros, ezfactor, adj?))
 
-- r1? is true means look for 1st-order right-factor also
    innerFactor(l, zeros, ezfactor, r1?) ==
      (n := degree l) <= 1 => [l]
      ll := adjoint l
      for i in 1..(n quo 2) repeat
        (r1? or (i > 1)) and ((u := rightFactor(l,i,zeros,ezfactor)) case L) =>
           return concat_!(rfactor(l, u::L, zeros, ezfactor, false), u::L)
        (2 * i < n) and ((u := rightFactor(ll, i, zeros, ezfactor)) case L) =>
           return concat(adjoint(u::L), rfactor(ll, u::L, zeros,ezfactor,true))
      [l]
 
    rightFactor(l, n, zeros, ezfactor) ==
--      one? n =>
      (n = 1) =>
        (u := expsol(l, zeros, ezfactor)) case "failed" => "failed"
        D() - u::RF::L
--    rec := associatedEquations(l, n::PositiveInteger)
--    empty?(sol := expsols(rec.eq, zeros, ezfactor, true)) => "failed"
      "failed"
 
    if F has AlgebraicallyClosedField then
      zro1: UP -> List F
      zro : (UP, UP -> Factored UP) -> List F
 
      zro(p, ezfactor) ==
        concat [zro1(r.factor) for r in factors ezfactor p]
 
      zro1 p ==
        [zeroOf(map(#1, p)$UnivariatePolynomialCategoryFunctions2(F, UP,
                                             F, SparseUnivariatePolynomial F))]
 
      if F is AlgebraicNumber then
        import AlgFactor UP
 
        factor l  == innerFactor(l, zro(#1, factor), factor, true)
        factor1 l == innerFactor(l, zro(#1, factor), factor, false)
 
      else
        factor l  == innerFactor(l, zro(#1, squareFree), squareFree, true)
        factor1 l == innerFactor(l, zro(#1, squareFree), squareFree, false)

@
<<LODOF.dotabb>>=
"LODOF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LODOF"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"LODOF" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LODOOPS LinearOrdinaryDifferentialOperatorsOps}
\pagehead{LinearOrdinaryDifferentialOperatorsOps}{LODOOPS}
\pagepic{ps/v104linearordinarydifferentialoperatorsops.ps}{LODOOPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LODOOPS LinearOrdinaryDifferentialOperatorsOps>>=
)abbrev package LODOOPS LinearOrdinaryDifferentialOperatorsOps
++ Author: Manuel Bronstein
++ Date Created: 18 January 1994
++ Date Last Updated: 15 April 1994
++ Description:
++   \spad{LinearOrdinaryDifferentialOperatorsOps} provides symmetric
++   products and sums for linear ordinary differential operators.
-- Putting those operations here rather than defaults in LODOCAT allows
-- LODOCAT to be defined independently of the derivative used.
-- MB 1/94
LinearOrdinaryDifferentialOperatorsOps(A, L): Exports == Implementation where
    A: Field
    L: LinearOrdinaryDifferentialOperatorCategory A

    N  ==> NonNegativeInteger
    V  ==> OrderlyDifferentialVariable Symbol
    P  ==> DifferentialSparseMultivariatePolynomial(A, Symbol, V)

    Exports ==> with
          symmetricProduct: (L, L, A -> A) -> L
            ++ symmetricProduct(a,b,D) computes an operator \spad{c} of
            ++ minimal order such that the nullspace of \spad{c} is
            ++ generated by all the products of a solution of \spad{a} by
            ++ a solution of \spad{b}.
            ++ D is the derivation to use.
          symmetricPower: (L, N, A -> A) -> L
            ++ symmetricPower(a,n,D) computes an operator \spad{c} of
            ++ minimal order such that the nullspace of \spad{c} is
            ++ generated by all the products of \spad{n} solutions
            ++ of \spad{a}.
            ++ D is the derivation to use.
          directSum: (L, L, A -> A) -> L
            ++ directSum(a,b,D) computes an operator \spad{c} of
            ++ minimal order such that the nullspace of \spad{c} is
            ++ generated by all the sums of a solution of \spad{a} by
            ++ a solution of \spad{b}.
            ++ D is the derivation to use.

    Implementation ==> add
          import IntegerCombinatoricFunctions

          var1 := new()$Symbol
          var2 := new()$Symbol

          nonTrivial?: Vector A -> Boolean
          applyLODO  : (L, V) -> P
          killer     : (P, N, List V, List P, A -> A) -> L
          vec2LODO   : Vector A -> L

          nonTrivial? v == any?(#1 ^= 0, v)$Vector(A)
          vec2LODO v    == +/[monomial(v.i, (i-1)::N) for i in 1..#v]

          symmetricPower(l, m, diff) ==
            u := var1::V; n := degree l
            un := differentiate(u, n)
            a  := applyLODO(inv(- leadingCoefficient l) * reductum l, u)
            killer(u::P ** m, binomial(n + m - 1, n - 1)::N, [un], [a], diff)

-- returns an operator L such that L(u) = 0, for a given differential
-- polynomial u, given that the differential variables appearing in u
-- satisfy some linear ode's
-- m is a bound on the order of the operator searched.
-- lvar, lval describe the substitution(s) to perform when differentiating
--     the expression u (they encode the fact the the differential variables
--     satisfy some differential equations, which can be seen as the rewrite
--     rules   lvar --> lval)
-- diff is the derivation to use
          killer(u, m, lvar, lval, diff) ==
            lu:List P := [u]
            for q in 0..m repeat
              mat := reducedSystem(matrix([lu])@Matrix(P))@Matrix(A)
              (sol := find(nonTrivial?, l := nullSpace mat)) case Vector(A) =>
                return vec2LODO(sol::Vector(A))
              u := eval(differentiate(u, diff), lvar, lval)
              lu := concat_!(lu, [u])
            error "killer: no linear dependence found"

          symmetricProduct(l1, l2, diff) ==
            u  := var1::V;   v  := var2::V
            n1 := degree l1; n2 := degree l2
            un := differentiate(u, n1); vn := differentiate(v, n2)
            a  := applyLODO(inv(- leadingCoefficient l1) * reductum l1, u)
            b  := applyLODO(inv(- leadingCoefficient l2) * reductum l2, v)
            killer(u::P * v::P, n1 * n2, [un, vn], [a, b], diff)

          directSum(l1, l2, diff) ==
            u  := var1::V;   v  := var2::V
            n1 := degree l1; n2 := degree l2
            un := differentiate(u, n1); vn := differentiate(v, n2)
            a  := applyLODO(inv(- leadingCoefficient l1) * reductum l1, u)
            b  := applyLODO(inv(- leadingCoefficient l2) * reductum l2, v)
            killer(u::P + v::P, n1 + n2, [un, vn], [a, b], diff)

          applyLODO(l, v) ==
            p:P := 0
            while l ^= 0 repeat
              p := p + monomial(leadingCoefficient(l)::P,
                                  differentiate(v, degree l), 1)
              l := reductum l
            p

@
<<LODOOPS.dotabb>>=
"LODOOPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LODOOPS"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"LODOOPS" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LPEFRAC LinearPolynomialEquationByFractions}
\pagehead{LinearPolynomialEquationByFractions}{LPEFRAC}
\pagepic{ps/v104linearpolynomialequationbyfractions.ps}{LPEFRAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LPEFRAC LinearPolynomialEquationByFractions>>=
)abbrev package LPEFRAC LinearPolynomialEquationByFractions
++ Author: James Davenport
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ Given a PolynomialFactorizationExplicit ring, this package
++ provides a defaulting rule for the \spad{solveLinearPolynomialEquation}
++ operation, by moving into the field of fractions, and solving it there
++ via the \spad{multiEuclidean} operation.
LinearPolynomialEquationByFractions(R:PolynomialFactorizationExplicit): with
  solveLinearPolynomialEquationByFractions: ( _
           List SparseUnivariatePolynomial R, _
           SparseUnivariatePolynomial R) ->   _
           Union(List SparseUnivariatePolynomial R, "failed")
        ++ solveLinearPolynomialEquationByFractions([f1, ..., fn], g)
        ++ (where the fi are relatively prime to each other)
        ++ returns a list of ai such that
        ++ \spad{g/prod fi = sum ai/fi}
        ++ or returns "failed" if no such exists.
 == add
  SupR ==> SparseUnivariatePolynomial R
  F ==> Fraction R
  SupF ==> SparseUnivariatePolynomial F
  import UnivariatePolynomialCategoryFunctions2(R,SupR,F,SupF)
  lp : List SupR
  pp: SupR
  pF: SupF
  pullback : SupF -> Union(SupR,"failed")
  pullback(pF) ==
    pF = 0 => 0
    c:=retractIfCan leadingCoefficient pF
    c case "failed" => "failed"
    r:=pullback reductum pF
    r case "failed" => "failed"
    monomial(c,degree pF) + r
  solveLinearPolynomialEquationByFractions(lp,pp) ==
    lpF:List SupF:=[map(#1@R::F,u) for u in lp]
    pF:SupF:=map(#1@R::F,pp)
    ans:= solveLinearPolynomialEquation(lpF,pF)$F
    ans case "failed" => "failed"
    [(vv:= pullback v;
      vv case "failed" => return "failed";
       vv)
        for v in ans]

@
<<LPEFRAC.dotabb>>=
"LPEFRAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LPEFRAC"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"LPEFRAC" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LGROBP LinGroebnerPackage}
\pagehead{LinGroebnerPackage}{LGROBP}
\pagepic{ps/v104lingroebnerpackage.ps}{LGROBP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LGROBP LinGroebnerPackage>>=
)abbrev package LGROBP LinGroebnerPackage
++  Given a Groebner basis B with respect to the total degree ordering for
++  a zero-dimensional ideal I, compute
++  a Groebner basis with respect to the lexicographical ordering by using
++  linear algebra.
LinGroebnerPackage(lv,F) : C == T

 where
  Z      ==>  Integer
  lv     :    List Symbol
  F      :    GcdDomain

  DP     ==>  DirectProduct(#lv,NonNegativeInteger)
  DPoly  ==>  DistributedMultivariatePolynomial(lv,F)

  HDP    ==>  HomogeneousDirectProduct(#lv,NonNegativeInteger)
  HDPoly ==>  HomogeneousDistributedMultivariatePolynomial(lv,F)

  OV     ==>  OrderedVariableList(lv)
  NNI    ==>  NonNegativeInteger
  LVals  ==>  Record(gblist : List DPoly,gvlist : List Z)
  VF     ==>  Vector F
  VV     ==>  Vector NNI
  MF     ==>  Matrix F
  cLVars ==>  Record(glbase:List DPoly,glval:List Z)

  C == with

     linGenPos    :           List HDPoly      -> LVals
	++ linGenPos \undocumented
     groebgen     :           List DPoly       -> cLVars
	++ groebgen \undocumented
     totolex      :           List HDPoly      -> List DPoly
	++ totolex \undocumented
     minPol       : (List HDPoly,List HDPoly,OV) -> HDPoly
	++ minPol \undocumented
     minPol       :        (List HDPoly,OV)     -> HDPoly
	++ minPol \undocumented


     computeBasis :        List HDPoly           -> List HDPoly
	++ computeBasis \undocumented
     coord        : (HDPoly,List HDPoly)         -> VF
	++ coord \undocumented
     anticoord    : (List F,DPoly,List DPoly)    -> DPoly
	++ anticoord \undocumented
     intcompBasis : (OV,List HDPoly,List HDPoly) -> List HDPoly
	++ intcompBasis \undocumented
     choosemon    :     (DPoly,List  DPoly)      -> DPoly
	++ choosemon \undocumented
     transform    :           DPoly              -> HDPoly
	++ transform \undocumented


  T == add

    import GroebnerPackage(F,DP,OV,DPoly)
    import GroebnerPackage(F,HDP,OV,HDPoly)
    import GroebnerInternalPackage(F,HDP,OV,HDPoly)
    import GroebnerInternalPackage(F,DP,OV,DPoly)

    lvar :=[variable(yx)::OV for yx in lv]

    reduceRow(M:MF, v : VF, lastRow: Integer, pivots: Vector(Integer)) : VF ==
      a1:F := 1
      b:F := 0
      dim := #v
      for j in 1..lastRow repeat -- scan over rows
         mj := row(M,j)
         k:=pivots(j)
         b:=mj.k
         vk := v.k
         for kk in 1..(k-1) repeat
            v(kk) := ((-b*v(kk)) exquo a1) :: F
         for kk in k..dim repeat
            v(kk) := ((vk*mj(kk)-b*v(kk)) exquo a1)::F
         a1 := b
      v

    rRedPol(f:HDPoly, B:List HDPoly):Record(poly:HDPoly, mult:F) ==
      gm := redPo(f,B)
      gm.poly = 0 => gm
      gg := reductum(gm.poly)
      ggm := rRedPol(gg,B)
      [ggm.mult*(gm.poly - gg) + ggm.poly, ggm.mult*gm.mult]

----- transform the total basis B in lex basis -----
    totolex(B : List HDPoly) : List DPoly ==
      result:List DPoly :=[]
      ltresult:List DPoly :=[]
      vBasis:= computeBasis B
      nBasis:List DPoly :=[1$DPoly]
      ndim:=(#vBasis)::PositiveInteger
      ndim1:NNI:=ndim+1
      lm:VF
      linmat:MF:=zero(ndim,2*ndim+1)
      linmat(1,1):=1$F
      linmat(1,ndim1):=1
      pivots:Vector Integer := new(ndim,0)
      pivots(1) := 1
      firstmon:DPoly:=1$DPoly
      ofirstmon:DPoly:=1$DPoly
      orecfmon:Record(poly:HDPoly, mult:F) := [1,1]
      i:NNI:=2
      while (firstmon:=choosemon(firstmon,ltresult))^=1 repeat
        if (v:=firstmon exquo ofirstmon) case "failed" then
          recfmon:=rRedPol(transform firstmon,B)
        else
          recfmon:=rRedPol(transform(v::DPoly) *orecfmon.poly,B)
          recfmon.mult := recfmon.mult * orecfmon.mult
        cc := gcd(content recfmon.poly, recfmon.mult)
        recfmon.poly := (recfmon.poly exquo cc)::HDPoly
        recfmon.mult := (recfmon.mult exquo cc)::F
        veccoef:VF:=coord(recfmon.poly,vBasis)
        ofirstmon:=firstmon
        orecfmon := recfmon
        lm:=zero(2*ndim+1)
        for j in 1..ndim repeat lm(j):=veccoef(j)
        lm(ndim+i):=recfmon.mult
        lm := reduceRow(linmat, lm, i-1, pivots)
        if i=ndim1 then j:=ndim1
        else
          j:=1
          while lm(j) = 0 and j< ndim1 repeat j:=j+1
        if j=ndim1 then
          cordlist:List F:=[lm(k) for k in ndim1..ndim1+(#nBasis)]
          antc:=+/[c*b for c in reverse cordlist
                       for b in concat(firstmon,nBasis)]
          antc:=primitivePart antc
          result:=concat(antc,result)
          ltresult:=concat(antc-reductum antc,ltresult)
        else
          pivots(i) := j
          setRow_!(linmat,i,lm)
          i:=i+1
          nBasis:=cons(firstmon,nBasis)
      result

---- Compute the univariate polynomial for x
----oldBasis is a total degree Groebner basis
    minPol(oldBasis:List HDPoly,x:OV) :HDPoly ==
      algBasis:= computeBasis oldBasis
      minPol(oldBasis,algBasis,x)

---- Compute the univariate polynomial for x
---- oldBasis is total Groebner, algBasis is the basis as algebra
    minPol(oldBasis:List HDPoly,algBasis:List HDPoly,x:OV) :HDPoly ==
      nvp:HDPoly:=x::HDPoly
      f:=1$HDPoly
      omult:F :=1
      ndim:=(#algBasis)::PositiveInteger
      ndim1:NNI:=ndim+1
      lm:VF
      linmat:MF:=zero(ndim,2*ndim+1)
      linmat(1,1):=1$F
      linmat(1,ndim1):=1
      pivots:Vector Integer := new(ndim,0)
      pivots(1) := 1
      for i in 2..ndim1 repeat
        recf:=rRedPol(f*nvp,oldBasis)
        omult := recf.mult * omult
        f := recf.poly
        cc := gcd(content f, omult)
        f := (f exquo cc)::HDPoly
        omult := (omult exquo cc)::F
        veccoef:VF:=coord(f,algBasis)
        lm:=zero(2*ndim+1)
        for j in 1..ndim repeat lm(j) := veccoef(j)
        lm(ndim+i):=omult
        lm := reduceRow(linmat, lm, i-1, pivots)
        j:=1
        while lm(j)=0 and j<ndim1 repeat j:=j+1
        if j=ndim1 then return
          g:HDPoly:=0
          for k in ndim1..2*ndim+1 repeat
            g:=g+lm(k) * nvp**((k-ndim1):NNI)
          primitivePart g
        pivots(i) := j
        setRow_!(linmat,i,lm)

----- transform a DPoly in a HDPoly -----
    transform(dpol:DPoly) : HDPoly ==
      dpol=0 => 0$HDPoly
      monomial(leadingCoefficient dpol,
               directProduct(degree(dpol)::VV)$HDP)$HDPoly +
                                      transform(reductum dpol)

----- compute the basis for the vector space determined by B -----
    computeBasis(B:List HDPoly) : List HDPoly ==
      mB:List HDPoly:=[monomial(1$F,degree f)$HDPoly for f in B]
      result:List HDPoly := [1$HDPoly]
      for var in lvar repeat
        part:=intcompBasis(var,result,mB)
        result:=concat(result,part)
      result

----- internal function for computeBasis -----
    intcompBasis(x:OV,lr:List HDPoly,mB : List HDPoly):List HDPoly ==
      lr=[] => lr
      part:List HDPoly :=[]
      for f in lr repeat
        g:=x::HDPoly * f
        if redPo(g,mB).poly^=0 then part:=concat(g,part)
      concat(part,intcompBasis(x,part,mB))

----- coordinate of f with respect to the basis B -----
----- f is a reduced polynomial -----
    coord(f:HDPoly,B:List HDPoly) : VF ==
      ndim := #B
      vv:VF:=new(ndim,0$F)$VF
      while f^=0 repeat
        rf := reductum f
        lf := f-rf
        lcf := leadingCoefficient f
        i:Z:=position(monomial(1$F,degree lf),B)
        vv.i:=lcf
        f := rf
      vv

----- reconstruct the polynomial from its coordinate -----
    anticoord(vv:List F,mf:DPoly,B:List DPoly) : DPoly ==
      for f in B for c in vv repeat (mf:=mf-c*f)
      mf

----- choose the next monom -----
    choosemon(mf:DPoly,nB:List DPoly) : DPoly ==
      nB = [] => ((lvar.last)::DPoly)*mf
      for x in reverse lvar repeat
        xx:=x ::DPoly
        mf:=xx*mf
        if redPo(mf,nB).poly ^= 0 then return mf
        dx := degree(mf,x)
        mf := (mf exquo (xx ** dx))::DPoly
      mf

----- put B in general position, B is Groebner -----
    linGenPos(B : List HDPoly) : LVals ==
      result:List DPoly :=[]
      ltresult:List DPoly :=[]
      vBasis:= computeBasis B
      nBasis:List DPoly :=[1$DPoly]
      ndim:=#vBasis : PositiveInteger
      ndim1:NNI:=ndim+1
      lm:VF
      linmat:MF:=zero(ndim,2*ndim+1)
      linmat(1,1):=1$F
      linmat(1,ndim1):=1
      pivots:Vector Integer := new(ndim,0)
      pivots(1) := 1
      i:NNI:=2
      rval:List Z :=[]
      for ii in 1..(#lvar-1) repeat
        c:Z:=0
        while c=0 repeat c:=random()$Z rem 11
        rval:=concat(c,rval)
      nval:DPoly := (last.lvar)::DPoly -
                (+/[r*(vv)::DPoly for r in rval for vv in lvar])
      firstmon:DPoly:=1$DPoly
      ofirstmon:DPoly:=1$DPoly
      orecfmon:Record(poly:HDPoly, mult:F) := [1,1]
      lx:= lvar.last
      while (firstmon:=choosemon(firstmon,ltresult))^=1 repeat
        if (v:=firstmon exquo ofirstmon) case "failed" then
          recfmon:=rRedPol(transform(eval(firstmon,lx,nval)),B)
        else
          recfmon:=rRedPol(transform(eval(v,lx,nval))*orecfmon.poly,B)
          recfmon.mult := recfmon.mult * orecfmon.mult
        cc := gcd(content recfmon.poly, recfmon.mult)
        recfmon.poly := (recfmon.poly exquo cc)::HDPoly
        recfmon.mult := (recfmon.mult exquo cc)::F
        veccoef:VF:=coord(recfmon.poly,vBasis)
        ofirstmon:=firstmon
        orecfmon := recfmon
        lm:=zero(2*ndim+1)
        for j in 1..ndim repeat lm(j):=veccoef(j)
        lm(ndim+i):=recfmon.mult
        lm := reduceRow(linmat, lm, i-1, pivots)
        j:=1
        while lm(j) = 0 and j<ndim1 repeat j:=j+1
        if j=ndim1 then
          cordlist:List F:=[lm(j) for j in ndim1..ndim1+(#nBasis)]
          antc:=+/[c*b for c in reverse cordlist
                       for b in concat(firstmon,nBasis)]
          result:=concat(primitivePart antc,result)
          ltresult:=concat(antc-reductum antc,ltresult)
        else
          pivots(i) := j
          setRow_!(linmat,i,lm)
          i:=i+1
          nBasis:=concat(firstmon,nBasis)
      [result,rval]$LVals

----- given a basis of a zero-dimensional ideal,
----- performs a random change of coordinates
----- computes a Groebner basis for the lex ordering
    groebgen(L:List DPoly) : cLVars ==
      xn:=lvar.last
      val := xn::DPoly
      nvar1:NNI:=(#lvar-1):NNI
      ll: List Z :=[random()$Z rem 11 for i in 1..nvar1]
      val:=val+ +/[ll.i*(lvar.i)::DPoly for i in 1..nvar1]
      LL:=[elt(univariate(f,xn),val) for f in L]
      LL:=  groebner(LL)
      [LL,ll]$cLVars

@
<<LGROBP.dotabb>>=
"LGROBP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LGROBP"]
"DIRPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=DIRPCAT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"LGROBP" -> "DIRPCAT"
"LGROBP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LF LiouvillianFunction}
\pagehead{LiouvillianFunction}{LF}
\pagepic{ps/v104liouvillianfunction.ps}{LF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LF LiouvillianFunction>>=
)abbrev package LF LiouvillianFunction
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 10 August 1994
++ Keywords: liouvillian, function, primitive, exponential.
++ Examples:  )r LF INPUT
++ Description:
++   This package provides liouvillian functions over an integral domain.
LiouvillianFunction(R, F): Exports == Implementation where
  R:Join(OrderedSet, IntegralDomain)
  F:Join(FunctionSpace R,RadicalCategory,TranscendentalFunctionCategory)

  OP  ==> BasicOperator
  PR  ==> Polynomial R
  K   ==> Kernel F
  SE  ==> Symbol
  O   ==> OutputForm
  INP ==> InputForm
  INV ==> error "Invalid argument"

  SPECIALDIFF ==> "%specialDiff"
  SPECIALDISP ==> "%specialDisp"
  SPECIALINPUT ==> "%specialInput"
  SPECIALEQUAL ==> "%specialEqual"

  Exports ==> with
    belong? : OP -> Boolean
      ++ belong?(op) checks if op is Liouvillian
    operator: OP -> OP
      ++ operator(op) returns the Liouvillian operator based on op
    Ei      : F  -> F
      ++ Ei(f) denotes the exponential integral
    Si      : F  -> F
      ++ Si(f) denotes the sine integral
    Ci      : F  -> F
      ++ Ci(f) denotes the cosine integral
    li      : F  -> F
      ++ li(f) denotes the logarithmic integral
    erf     : F  -> F
      ++ erf(f) denotes the error function
    dilog   : F  -> F
      ++ dilog(f) denotes the dilogarithm
    integral: (F, SE) -> F
      ++ integral(f,x) indefinite integral of f with respect to x.
    integral: (F, SegmentBinding F) -> F
      ++ integral(f,x = a..b) denotes the definite integral of f with
      ++ respect to x from \spad{a} to b.

  Implementation ==> add
    iei        : F  -> F
    isi        : F  -> F
    ici        : F  -> F
    ierf       : F  -> F
    ili        : F  -> F
    ili2       : F  -> F
    iint       : List F -> F
    eqint      : (K,K) -> Boolean
    dvint      : (List F, SE) -> F
    dvdint     : (List F, SE) -> F
    ddint      : List F -> O
    integrand  : List F -> F

    dummy := new()$SE :: F

    opint  := operator("integral"::Symbol)$CommonOperators
    opdint := operator("%defint"::Symbol)$CommonOperators
    opei   := operator("Ei"::Symbol)$CommonOperators
    opli   := operator("li"::Symbol)$CommonOperators
    opsi   := operator("Si"::Symbol)$CommonOperators
    opci   := operator("Ci"::Symbol)$CommonOperators
    opli2  := operator("dilog"::Symbol)$CommonOperators
    operf  := operator("erf"::Symbol)$CommonOperators

    Si x                == opsi x
    Ci x                == opci x
    Ei x                == opei x
    erf x               == operf x
    li  x               == opli x
    dilog x             == opli2 x

    belong? op     == has?(op, "prim")
    isi x          == kernel(opsi, x)
    ici x          == kernel(opci, x)
    ierf x         == (zero? x => 0; kernel(operf, x))
--    ili2 x         == (one? x => INV; kernel(opli2, x))
    ili2 x         == ((x = 1) => INV; kernel(opli2, x))
    integrand l    == eval(first l, retract(second l)@K, third l)
    integral(f:F, x:SE) == opint [eval(f, k:=kernel(x)$K, dummy), dummy, k::F]

    iint l ==
      zero? first l => 0
      kernel(opint, l)

    ddint l ==
      int(integrand(l)::O * hconcat("d"::SE::O, third(l)::O),
                                    third(rest l)::O, third(rest rest l)::O)

    eqint(k1,k2) == 
      a1:=argument k1
      a2:=argument k2
      res:=operator k1 = operator k2
      if not res then return res
      res:= a1 = a2
      if res then return res
      res:= (a1.3 = a2.3) and (subst(a1.1,[retract(a1.2)@K],[a2.2]) = a2.1)

    dvint(l, x) ==
      k  := retract(second l)@K
      differentiate(third l, x) * integrand l
          + opint [differentiate(first l, x), second l, third l]


    dvdint(l, x) ==
      x = retract(y := third l)@SE => 0
      k := retract(d := second l)@K
      differentiate(h := third rest rest l,x) * eval(f := first l, k, h)
        - differentiate(g := third rest l, x) * eval(f, k, g)
             + opdint [differentiate(f, x), d, y, g, h]

    integral(f:F, s: SegmentBinding F) ==
      x := kernel(variable s)$K
      opdint [eval(f,x,dummy), dummy, x::F, lo segment s, hi segment s]

    ili x ==
      x = 1 => INV
      is?(x, "exp"::Symbol) => Ei first argument(retract(x)@K)
      kernel(opli, x)

    iei x ==
      x = 0 => INV
      is?(x, "log"::Symbol) => li first argument(retract(x)@K)
      kernel(opei, x)

    operator op ==
      is?(op, "integral"::Symbol)   => opint
      is?(op, "%defint"::Symbol)    => opdint
      is?(op, "Ei"::Symbol)         => opei
      is?(op, "Si"::Symbol)         => opsi
      is?(op, "Ci"::Symbol)         => opci
      is?(op, "li"::Symbol)         => opli
      is?(op, "erf"::Symbol)        => operf
      is?(op, "dilog"::Symbol)      => opli2
      error "Not a Liouvillian operator"

    evaluate(opei,   iei)$BasicOperatorFunctions1(F)
    evaluate(opli,   ili)
    evaluate(opsi,   isi)
    evaluate(opci,   ici)
    evaluate(operf,  ierf)
    evaluate(opli2,  ili2)
    evaluate(opint,  iint)
    derivative(opsi, sin(#1) / #1)
    derivative(opci, cos(#1) / #1)
    derivative(opei, exp(#1) / #1)
    derivative(opli, inv log(#1))
    derivative(operf, 2 * exp(-(#1**2)) / sqrt(pi()))
    derivative(opli2, log(#1) / (1 - #1))
    setProperty(opint,SPECIALEQUAL,eqint@((K,K) -> Boolean) pretend None)
    setProperty(opint,SPECIALDIFF,dvint@((List F,SE) -> F) pretend None)
    setProperty(opdint,SPECIALDIFF,dvdint@((List F,SE)->F) pretend None)
    setProperty(opdint, SPECIALDISP, ddint@(List F -> O) pretend None)

    if R has ConvertibleTo INP then
      inint : List F -> INP
      indint: List F -> INP
      pint  : List INP -> INP


      pint l  == convert concat(convert("integral"::SE)@INP, l)
      inint l == 
        r2:= convert([convert("::"::SE)@INP,convert(third l)@INP,convert("Symbol"::SE)@INP]@List INP)@INP
        pint [convert(integrand l)@INP, r2]

      indint l ==
        pint [convert(integrand l)@INP,
              convert concat(convert("="::SE)@INP,
                            [convert(third l)@INP,
                             convert concat(convert("SEGMENT"::SE)@INP,
                                            [convert(third rest l)@INP,
                                             convert(third rest rest l)@INP])])]

      setProperty(opint, SPECIALINPUT, inint@(List F -> INP) pretend None)
      setProperty(opdint, SPECIALINPUT, indint@(List F -> INP) pretend None)

@
<<LF.dotabb>>=
"LF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"LF" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LIST2 ListFunctions2}
\pagehead{ListFunctions2}{LIST2}
\pagepic{ps/v104listfunctions2.ps}{LIST2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LIST2 ListFunctions2>>=
)abbrev package LIST2 ListFunctions2
++ Author:
++ Date Created:
++ Change History:
++ Basic Operations: map, reduce, scan
++ Related Constructors: List
++ Also See: ListFunctions3
++ AMS Classification:
++ Keywords: list, aggregate, map, reduce
++ Description:
++   \spadtype{ListFunctions2} implements utility functions that
++   operate on two kinds of lists, each with a possibly different
++   type of element.
ListFunctions2(A:Type, B:Type): public == private where
  LA     ==> List A
  LB     ==> List B
  O2     ==> FiniteLinearAggregateFunctions2(A, LA, B, LB)

  public ==> with
    scan:    ((A, B) -> B, LA, B) -> LB
      ++ scan(fn,u,ident) successively uses the binary function
      ++ \spad{fn} to reduce more and more of list \spad{u}.
      ++ \spad{ident} is returned if the \spad{u} is empty.
      ++ The result is a list of the reductions at each step. See
      ++ \spadfun{reduce} for more information. Examples:
      ++ \spad{scan(fn,[1,2],0) = [fn(2,fn(1,0)),fn(1,0)]} and
      ++ \spad{scan(*,[2,3],1) = [2 * 1, 3 * (2 * 1)]}.
    reduce:  ((A, B) -> B, LA, B) -> B
      ++ reduce(fn,u,ident) successively uses the binary function
      ++ \spad{fn} on the elements of list \spad{u} and the result
      ++ of previous applications. \spad{ident} is returned if the
      ++ \spad{u} is empty. Note the order of application in
      ++ the following examples:
      ++ \spad{reduce(fn,[1,2,3],0) = fn(3,fn(2,fn(1,0)))} and
      ++ \spad{reduce(*,[2,3],1) = 3 * (2 * 1)}.
    map:      (A -> B, LA) -> LB
      ++ map(fn,u) applies \spad{fn} to each element of
      ++ list \spad{u} and returns a new list with the results.
      ++ For example \spad{map(square,[1,2,3]) = [1,4,9]}.

  private ==> add
    map(f, l)       == map(f, l)$O2
    scan(f, l, b)   == scan(f, l, b)$O2
    reduce(f, l, b) == reduce(f, l, b)$O2

@
<<LIST2.dotabb>>=
"LIST2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LIST2"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"LIST2" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LIST3 ListFunctions3}
\pagehead{ListFunctions3}{LIST3}
\pagepic{ps/v104listfunctions3.ps}{LIST3}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LIST3 ListFunctions3>>=
)abbrev package LIST3 ListFunctions3
++ Author:
++ Date Created:
++ Change History:
++ Basic Operations: map
++ Related Constructors: List
++ Also See: ListFunctions2
++ AMS Classification:
++ Keywords: list, aggregate, map
++ Description:
++   \spadtype{ListFunctions3} implements utility functions that
++   operate on three kinds of lists, each with a possibly different
++   type of element.
ListFunctions3(A:Type, B:Type, C:Type): public == private where
  LA     ==> List A
  LB     ==> List B
  LC     ==> List C

  public ==> with
    map: ( (A,B)->C, LA, LB) -> LC
      ++ map(fn,list1, u2) applies the binary function \spad{fn}
      ++ to corresponding elements of lists \spad{u1} and \spad{u2}
      ++ and returns a list of the results (in the same order). Thus
      ++ \spad{map(/,[1,2,3],[4,5,6]) = [1/4,2/4,1/2]}. The computation
      ++ terminates when the end of either list is reached. That is,
      ++ the length of the result list is equal to the minimum of the
      ++ lengths of \spad{u1} and \spad{u2}.

  private ==> add
    map(fn : (A,B) -> C, la : LA, lb : LB): LC ==
      empty?(la) or empty?(lb) => empty()$LC
      concat(fn(first la, first lb), map(fn, rest la, rest lb))

@
<<LIST3.dotabb>>=
"LIST3" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LIST3"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"LIST3" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LIST2MAP ListToMap}
\pagehead{ListToMap}{LIST2MAP}
\pagepic{ps/v104listtomap.ps}{LIST2MAP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LIST2MAP ListToMap>>=
)abbrev package LIST2MAP ListToMap
++ Author: Manuel Bronstein
++ Date Created: 22 Mar 1988
++ Change History:
++   11 Oct 1989   MB   ?
++ Basic Operations: match
++ Related Constructors: List
++ Also See:
++ AMS Classification:
++ Keywords: mapping, list
++ Description:
++   \spadtype{ListToMap} allows mappings to be described by a pair of
++   lists of equal lengths.  The image of an element \spad{x},
++   which appears in position \spad{n} in the first list, is then
++   the \spad{n}th element of the second list.  A default value or
++   default function can be specified to be used when \spad{x}
++   does not appear in the first list.  In the absence of defaults,
++   an error will occur in that case.
ListToMap(A:SetCategory, B:Type): Exports == Implementation where
  LA  ==> List A
  LB  ==> List B
  AB  ==> (A -> B)

  Exports ==> with
    match: (LA, LB   ) -> AB
      ++ match(la, lb) creates a map with no default source or target values
      ++ defined by lists la and lb of equal length.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Error: if la and lb are not of equal length.
      ++ Note: when this map is applied, an error occurs when
      ++ applied to a value missing from la.
    match: (LA, LB, A) -> B
      ++ match(la, lb, a) creates a map
      ++ defined by lists la and lb of equal length, where \spad{a} is used
      ++ as the default source value if the given one is not in \spad{la}.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Error: if la and lb are not of equal length.
    match: (LA, LB, B)    -> AB
      ++ match(la, lb, b) creates a map
      ++ defined by lists la and lb of equal length, where \spad{b} is used
      ++ as the default target value if the given function argument is
      ++ not in \spad{la}.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Error: if la and lb are not of equal length.
    match: (LA, LB, A, B) -> B
      ++ match(la, lb, a, b) creates a map
      ++ defined by lists la and lb of equal length.
      ++ and applies this map to a.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Argument b is the default target value if a is not in la.
      ++ Error: if la and lb are not of equal length.
    match: (LA, LB, AB)    -> AB
      ++ match(la, lb, f) creates a map
      ++ defined by lists la and lb of equal length.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Argument \spad{f} is used as the
      ++ function to call when the given function argument is not in
      ++ \spad{la}.
      ++ The value returned is f applied to that argument.
    match: (LA, LB, A, AB) -> B
      ++ match(la, lb, a, f) creates a map
      ++ defined by lists la and lb of equal length.
      ++ and applies this map to a.
      ++ The target of a source value \spad{x} in la is the
      ++ value y with the same index lb.
      ++ Argument \spad{f} is a default function to call if a is not in la.
      ++ The value returned is then obtained by applying f to argument a.

  Implementation ==> add
    match(la, lb)             == match(la, lb, #1)
    match(la:LA, lb:LB, a:A)  == lb.position(a, la)
    match(la:LA, lb:LB, b:B)  == match(la, lb, #1, b)
    match(la:LA, lb:LB, f:AB) == match(la, lb, #1, f)

    match(la:LA, lb:LB, a:A, b:B) ==
      (p := position(a, la)) < minIndex(la) => b
      lb.p

    match(la:LA, lb:LB, a:A, f:AB) ==
      (p := position(a, la)) < minIndex(la) => f a
      lb.p

@
<<LIST2MAP.dotabb>>=
"LIST2MAP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LIST2MAP"]
"FLAGG-" [color="#88FF44",href="bookvol10.3.pdf#nameddest=FLAGG"]
"LIST2MAP" -> "FLAGG-"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter M}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MKBCFUNC MakeBinaryCompiledFunction}
\pagehead{MakeBinaryCompiledFunction}{MKBCFUNC}
\pagepic{ps/v104makebinarycompiledfunction.ps}{MKBCFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MKBCFUNC MakeBinaryCompiledFunction>>=
)abbrev package MKBCFUNC MakeBinaryCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 1 Dec 1988
++ Date Last Updated: 5 Mar 1990
++ Description: transforms top-level objects into compiled functions.
MakeBinaryCompiledFunction(S, D1, D2, I):Exports == Implementation where
  S: ConvertibleTo InputForm
  D1, D2, I: Type

  SY  ==> Symbol
  DI  ==> devaluate((D1, D2) -> I)$Lisp

  Exports ==> with
    binaryFunction  : SY -> ((D1, D2) -> I)
      ++ binaryFunction(s) is a local function
    compiledFunction: (S, SY, SY) -> ((D1, D2) -> I)
      ++ compiledFunction(expr,x,y) returns a function \spad{f: (D1, D2) -> I}
      ++ defined by \spad{f(x, y) == expr}.
      ++ Function f is compiled and directly
      ++ applicable to objects of type \spad{(D1, D2)}

  Implementation ==> add
    import MakeFunction(S)

    func: (SY, D1, D2) -> I

    func(name, x, y)   == FUNCALL(name, x, y, NIL$Lisp)$Lisp
    binaryFunction name == func(name, #1, #2)

    compiledFunction(e, x, y) ==
      t := [devaluate(D1)$Lisp, devaluate(D2)$Lisp]$List(InputForm)
      binaryFunction compile(function(e, declare DI, x, y), t)

@
<<MKBCFUNC.dotabb>>=
"MKBCFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MKBCFUNC"]
"KONVERT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KONVERT"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"MKBCFUNC" -> "KONVERT"
"MKBCFUNC" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MKFLCFN MakeFloatCompiledFunction}
\pagehead{MakeFloatCompiledFunction}{MKFLCFN}
\pagepic{ps/v104makefloatcompiledfunction.ps}{MKFLCFN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MKFLCFN MakeFloatCompiledFunction>>=
)abbrev package MKFLCFN MakeFloatCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 2 Mar 1990
++ Date Last Updated: 2 Dec 1996 (MCD)
++ Description:
++ MakeFloatCompiledFunction transforms top-level objects into
++ compiled Lisp functions whose arguments are Lisp floats.
++ This by-passes the \Language{} compiler and interpreter,
++ thereby gaining several orders of magnitude.
MakeFloatCompiledFunction(S): Exports == Implementation where
  S: ConvertibleTo InputForm

  INF ==> InputForm
  SF  ==> DoubleFloat
  DI1 ==> devaluate(SF -> SF)$Lisp
  DI2 ==> devaluate((SF, SF) -> SF)$Lisp

  Exports ==> with
    makeFloatFunction: (S, Symbol)         -> (SF -> SF)
      ++ makeFloatFunction(expr, x) returns a Lisp function
      ++ \spad{f: \axiomType{DoubleFloat} -> \axiomType{DoubleFloat}}
      ++ defined by \spad{f(x) == expr}. 
      ++ Function f is compiled and directly
      ++ applicable to objects of type \axiomType{DoubleFloat}.
    makeFloatFunction: (S, Symbol, Symbol) -> ((SF, SF) -> SF)
      ++ makeFloatFunction(expr, x, y) returns a Lisp function
      ++ \spad{f: (\axiomType{DoubleFloat}, 
      ++ \axiomType{DoubleFloat}) -> \axiomType{DoubleFloat}}
      ++ defined by \spad{f(x, y) == expr}.
      ++ Function f is compiled and directly
      ++ applicable to objects of type \spad{(\axiomType{DoubleFloat}, 
      ++ \axiomType{DoubleFloat})}.

  Implementation ==> add
    import MakeUnaryCompiledFunction(S, SF, SF)
    import MakeBinaryCompiledFunction(S, SF, SF, SF)

    streq?    : (INF, String) -> Boolean
    streqlist?: (INF, List String) -> Boolean
    gencode   : (String, List INF) -> INF
    mkLisp    : INF -> Union(INF, "failed")
    mkLispList: List INF -> Union(List INF, "failed")
    mkDefun   : (INF, List INF) -> INF
    mkLispCall: INF -> INF
    mkPretend : INF -> INF
    mkCTOR : INF -> INF

    lsf := convert([convert("DoubleFloat"::Symbol)@INF]$List(INF))@INF

    streq?(s, st)    == s = convert(st::Symbol)@INF
    gencode(s, l)    == convert(concat(convert(s::Symbol)@INF, l))@INF
    streqlist?(s, l) == member?(string symbol s, l)

    mkPretend form ==
      convert([convert("pretend"::Symbol), form, lsf]$List(INF))@INF

    mkCTOR form ==
      convert([convert("C-TO-R"::Symbol), form]$List(INF))@INF


    mkLispCall name ==
      convert([convert("$elt"::Symbol),
                           convert("Lisp"::Symbol), name]$List(INF))@INF

    mkDefun(s, lv) ==
      name := convert(new()$Symbol)@INF
      fun  := convert([convert("DEFUN"::Symbol), name, convert lv,
              gencode("DECLARE",[gencode("FLOAT",lv)]),mkCTOR s]$List(INF))@INF
      EVAL(fun)$Lisp
      if _$compileDontDefineFunctions$Lisp then COMPILE(name)$Lisp
      name

    makeFloatFunction(f, x, y) ==
      (u := mkLisp(convert(f)@INF)) case "failed" =>
        compiledFunction(f, x, y)
      name := mkDefun(u::INF, [ix := convert x, iy := convert y])
      t    := [lsf, lsf]$List(INF)
      spadname := declare DI2
      spadform:=mkPretend convert([mkLispCall name,ix,iy]$List(INF))@INF
      interpret function(spadform, [x, y], spadname)
      binaryFunction compile(spadname, t)

    makeFloatFunction(f, var) ==
      (u := mkLisp(convert(f)@INF)) case "failed" =>
        compiledFunction(f, var)
      name := mkDefun(u::INF, [ivar := convert var])
      t    := [lsf]$List(INF)
      spadname := declare DI1
      spadform:= mkPretend convert([mkLispCall name,ivar]$List(INF))@INF
      interpret function(spadform, [var], spadname)
      unaryFunction compile(spadname, t)

    mkLispList l ==
      ans := nil()$List(INF)
      for s in l repeat
        (u := mkLisp s) case "failed" => return "failed"
        ans := concat(u::INF, ans)
      reverse_! ans
    

    mkLisp s ==
      atom? s => s
      op := first(l := destruct s)
      (u := mkLispList rest l) case "failed" => "failed"
      ll := u::List(INF)
      streqlist?(op, ["+","*","/","-"]) => convert(concat(op, ll))@INF
      streq?(op, "**") => gencode("EXPT", ll)
      streqlist?(op, ["exp","sin","cos","tan","atan", 
         "log", "sinh","cosh","tanh","asinh","acosh","atanh","sqrt"]) =>
            gencode(upperCase string symbol op, ll)
      streq?(op, "nthRoot") =>
        second ll = convert(2::Integer)@INF =>gencode("SQRT",[first ll])
        gencode("EXPT", concat(first ll, [1$INF / second ll]))
      streq?(op, "float") =>
        a := ll.1
        e := ll.2
        b := ll.3
        _*(a, EXPT(b, e)$Lisp)$Lisp pretend INF
      "failed"

@
<<MKFLCFN.dotabb>>=
"MKFLCFN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MKFLCFN"]
"KONVERT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KONVERT"]
"MKFUNC" -> "KONVERT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MKFUNC MakeFunction}
<<MakeFunction.input>>=
-- mkfunc.spad.pamphlet MakeFunction.input
)spool MakeFunction.output
)set message test on
)set message auto off
)clear all
--S 1 of 9
expr := (x - exp x + 1)^2 * (sin(x^2) * x + 1)^3
--R 
--R
--R   (1)
--R       3   x 2        4     3   x    5     4    3      2 3
--R     (x (%e )  + (- 2x  - 2x )%e  + x  + 2x  + x )sin(x )
--R   + 
--R        2   x 2        3     2   x     4     3     2      2 2
--R     (3x (%e )  + (- 6x  - 6x )%e  + 3x  + 6x  + 3x )sin(x )
--R   + 
--R            x 2        2        x     3     2           2       x 2
--R     (3x (%e )  + (- 6x  - 6x)%e  + 3x  + 6x  + 3x)sin(x ) + (%e )
--R   + 
--R                 x    2
--R     (- 2x - 2)%e  + x  + 2x + 1
--R                                                     Type: Expression Integer
--E 1

--S 2 of 9
function(expr, f, x)
--R 
--R
--R   (2)  f
--R                                                                 Type: Symbol
--E 2

--S 3 of 9
tbl := [f(0.1 * i - 1) for i in 0..20]
--R 
--R   Compiling function f with type Float -> Float 
--R
--R   (3)
--R   [0.0005391844 0362701574, 0.0039657551 1844206653,
--R    0.0088545187 4833983689 2, 0.0116524883 0907069695,
--R    0.0108618220 9245751364 5, 0.0076366823 2120869965 06,
--R    0.0040584985 7597822062 55, 0.0015349542 8910500836 48,
--R    0.0003424903 1549879905 716, 0.0000233304 8276098819 6001, 0.0,
--R    0.0000268186 8782862599 4229, 0.0004691571 3720051642 621,
--R    0.0026924576 5968519586 08, 0.0101486881 7369135148 8,
--R    0.0313833725 8543810564 3, 0.0876991144 5154615297 9,
--R    0.2313019789 3439968362, 0.5843743955 958098772, 1.4114930171 992819197,
--R    3.2216948276 75164252]
--R                                                             Type: List Float
--E 3

--S 4 of 9
e := (x - y + 1)^2 * (x^2 * y + 1)^2 
--R 
--R
--R   (4)
--R      4 4        5     4     2  3     6     5    4     3     2      2
--R     x y  + (- 2x  - 2x  + 2x )y  + (x  + 2x  + x  - 4x  - 4x  + 1)y
--R   + 
--R        4     3     2               2
--R     (2x  + 4x  + 2x  - 2x - 2)y + x  + 2x + 1
--R                                                     Type: Polynomial Integer
--E 4

--S 5 of 9
function(e, g, [x, y])
--R 
--R
--R   (5)  g
--R                                                                 Type: Symbol
--E 5

--S 6 of 9
function(e, h, x, y)
--R 
--R
--R   (6)  h
--R                                                                 Type: Symbol
--E 6

--S 7 of 9
m1 := squareMatrix [ [1, 2], [3, 4] ]
--R 
--R
--R        +1  2+
--R   (7)  |    |
--R        +3  4+
--R                                                Type: SquareMatrix(2,Integer)
--E 7

--S 8 of 9
m2 := squareMatrix [ [1, 0], [-1, 1] ]
--R 
--R
--R        + 1   0+
--R   (8)  |      |
--R        +- 1  1+
--R                                                Type: SquareMatrix(2,Integer)
--E 8

--S 9 of 9
h(m1, m2)
--R 
--R   Compiling function h with type (SquareMatrix(2,Integer),SquareMatrix
--R      (2,Integer)) -> SquareMatrix(2,Integer) 
--R
--R        +- 7836   8960 +
--R   (9)  |              |
--R        +- 17132  19588+
--R                                                Type: SquareMatrix(2,Integer)
--E 9
)spool
)lisp (bye)
@
<<MakeFunction.help>>=
====================================================================
MakeFunction examples
====================================================================

It is sometimes useful to be able to define a function given by
the result of a calculation.

Suppose that you have obtained the following expression after several
computations and that you now want to tabulate the numerical values of
f for x between -1 and +1 with increment 0.1.

  expr := (x - exp x + 1)^2 * (sin(x^2) * x + 1)^3
       3   x 2        4     3   x    5     4    3      2 3
     (x (%e )  + (- 2x  - 2x )%e  + x  + 2x  + x )sin(x )
   + 
        2   x 2        3     2   x     4     3     2      2 2
     (3x (%e )  + (- 6x  - 6x )%e  + 3x  + 6x  + 3x )sin(x )
   + 
            x 2        2        x     3     2           2       x 2
     (3x (%e )  + (- 6x  - 6x)%e  + 3x  + 6x  + 3x)sin(x ) + (%e )
   + 
                 x    2
     (- 2x - 2)%e  + x  + 2x + 1
                               Type: Expression Integer

You could, of course, use the function eval within a loop and evaluate
expr twenty-one times, but this would be quite slow.  A better way is
to create a numerical function f such that f(x) is defined by the
expression expr above, but without retyping expr!  The package
MakeFunction provides the operation function which does exactly this.

Issue this to create the function f(x) given by expr.

  function(expr, f, x)
    f
                               Type: Symbol

To tabulate expr, we can now quickly evaluate f 21 times.

  tbl := [f(0.1 * i - 1) for i in 0..20];
                               Type: List Float

Use the list [x1,...,xn] as the third argument to function to create a
multivariate function f(x1,...,xn).

  e := (x - y + 1)^2 * (x^2 * y + 1)^2 
      4 4        5     4     2  3     6     5    4     3     2      2
     x y  + (- 2x  - 2x  + 2x )y  + (x  + 2x  + x  - 4x  - 4x  + 1)y
   + 
        4     3     2               2
     (2x  + 4x  + 2x  - 2x - 2)y + x  + 2x + 1
                                Type: Polynomial Integer

  function(e, g, [x, y])
    g
                               Type: Symbol

In the case of just two variables, they can be given as arguments
without making them into a list.

  function(e, h, x, y)
    h
                               Type: Symbol

Note that the functions created by function are not limited to
floating point numbers, but can be applied to any type for which they
are defined.

  m1 := squareMatrix [ [1, 2], [3, 4] ]
    +1  2+
    |    |
    +3  4+
                               Type: SquareMatrix(2,Integer)

  m2 := squareMatrix [ [1, 0], [-1, 1] ]
    + 1   0+
    |      |
    +- 1  1+
                               Type: SquareMatrix(2,Integer)

  h(m1, m2)
    +- 7836   8960 +
    |              |
    +- 17132  19588+
                               Type: SquareMatrix(2,Integer)

See Also:
o )show MakeFunction

@
\pagehead{MakeFunction}{MKFUNC}
\pagepic{ps/v104makefunction.ps}{MKFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MKFUNC MakeFunction>>=
)abbrev package MKFUNC MakeFunction
++ Tools for making interpreter functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 22 Nov 1988
++ Date Last Updated: 8 Jan 1990
++ Description: transforms top-level objects into interpreter functions.
MakeFunction(S:ConvertibleTo InputForm): Exports == Implementation where
  SY ==> Symbol

  Exports ==> with
    function: (S, SY         ) -> SY
      ++ function(e, foo) creates a function \spad{foo() == e}.
    function: (S, SY,      SY) -> SY
      ++ function(e, foo, x) creates a function \spad{foo(x) == e}.
    function: (S, SY, SY,  SY) -> SY
      ++ function(e, foo, x, y) creates a function \spad{foo(x, y) = e}.
    function: (S, SY, List SY) -> SY
      ++ \spad{function(e, foo, [x1,...,xn])} creates a function
      ++ \spad{foo(x1,...,xn) == e}.

  Implementation ==> add
    function(s, name)            == function(s, name, nil())
    function(s:S, name:SY, x:SY) == function(s, name, [x])
    function(s, name, x, y)      == function(s, name, [x, y])

    function(s:S, name:SY, args:List SY) ==
      interpret function(convert s, args, name)$InputForm
      name

@
<<MKFUNC.dotabb>>=
"MKFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MKFUNC"]
"KONVERT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KONVERT"]
"MKFUNC" -> "KONVERT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MKRECORD MakeRecord}
\pagehead{MakeRecord}{MKRECORD}
\pagepic{ps/v104makerecord.ps}{MKRECORD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MKRECORD MakeRecord>>=
)abbrev package MKRECORD MakeRecord
++ Description:
++  MakeRecord is used internally by the interpreter to create record
++  types which are used for doing parallel iterations on streams.
MakeRecord(S: Type, T: Type): public == private where
  public == with
    makeRecord: (S,T) -> Record(part1: S, part2: T)
      ++ makeRecord(a,b) creates a record object with type 
      ++ Record(part1:S, part2:R), 
      ++ where part1 is \spad{a} and part2 is \spad{b}.
  private == add
    makeRecord(s: S, t: T)  ==
      [s,t]$Record(part1: S, part2: T)

@
<<MKRECORD.dotabb>>=
"MKRECORD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MKRECORD"]
"KONVERT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KONVERT"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"MKUCFUNC" -> "KONVERT"
"MKUCFUNC" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MKUCFUNC MakeUnaryCompiledFunction}
\pagehead{MakeUnaryCompiledFunction}{MKUCFUNC}
\pagepic{ps/v104makeunarycompiledfunction.ps}{MKUCFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MKUCFUNC MakeUnaryCompiledFunction>>=
)abbrev package MKUCFUNC MakeUnaryCompiledFunction
++ Tools for making compiled functions from top-level expressions
++ Author: Manuel Bronstein
++ Date Created: 1 Dec 1988
++ Date Last Updated: 5 Mar 1990
++ Description: transforms top-level objects into compiled functions.
MakeUnaryCompiledFunction(S, D, I): Exports == Implementation where
  S: ConvertibleTo InputForm
  D, I: Type

  SY  ==> Symbol
  DI  ==> devaluate(D -> I)$Lisp

  Exports ==> with
    unaryFunction   : SY -> (D -> I)
      ++ unaryFunction(a) is a local function
    compiledFunction: (S, SY) -> (D -> I)
      ++ compiledFunction(expr, x) returns a function \spad{f: D -> I}
      ++ defined by \spad{f(x) == expr}. 
      ++ Function f is compiled and directly
      ++ applicable to objects of type D.

  Implementation ==> add
    import MakeFunction(S)

    func: (SY, D) -> I

    func(name, x)       == FUNCALL(name, x, NIL$Lisp)$Lisp
    unaryFunction name  == func(name, #1)

    compiledFunction(e:S, x:SY) ==
      t := [convert([devaluate(D)$Lisp]$List(InputForm))
           ]$List(InputForm)
      unaryFunction compile(function(e, declare DI, x), t)

@
<<MKUCFUNC.dotabb>>=
"MKUCFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MKUCFUNC"]
"KONVERT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KONVERT"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"MKUCFUNC" -> "KONVERT"
"MKUCFUNC" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPHACK1 MappingPackageInternalHacks1}
\pagehead{MappingPackageInternalHacks1}{MAPHACK1}
\pagepic{ps/v104mappingpackageinternalhacks1.ps}{MAPHACK1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPHACK1 MappingPackageInternalHacks1>>=
)abbrev package MAPHACK1 MappingPackageInternalHacks1
++ Author: S.M.Watt and W.H.Burge
++ Date Created:Jan 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: various Currying operations.
MappingPackageInternalHacks1(A: SetCategory): MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        iter:  ((A -> A), NNI, A) -> A
          ++\spad{iter(f,n,x)} applies \spad{f n} times to \spad{x}.
        recur: ((NNI, A)->A, NNI, A) -> A
          ++\spad{recur(n,g,x)} is \spad{g(n,g(n-1,..g(1,x)..))}.
 
    MPdef == add
        iter(g,n,x)  ==
            for i in 1..n repeat x := g x     -- g(g(..(x)..))
            x
        recur(g,n,x) ==
            for i in 1..n repeat x := g(i,x)  -- g(n,g(n-1,..g(1,x)..))
            x

@
<<MAPHACK1.dotabb>>=
"MAPHACK1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPHACK1"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPHACK1" -> "BASTYPE"
"MAPHACK1" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPHACK2 MappingPackageInternalHacks2}
\pagehead{MappingPackageInternalHacks2}{MAPHACK2}
\pagepic{ps/v104mappingpackageinternalhacks2.ps}{MAPHACK2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPHACK2 MappingPackageInternalHacks2>>=
)abbrev package MAPHACK2 MappingPackageInternalHacks2
++ Description: various Currying operations.
MappingPackageInternalHacks2(A: SetCategory, C: SetCategory):_
  MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        arg1:  (A, C) -> A
          ++\spad{arg1(a,c)} selects its first argument.
        arg2:  (A, C) -> C
          ++\spad{arg2(a,c)} selects its second argument.
 
    MPdef == add
        arg1(a, c)   == a
        arg2(a, c)   == c

@
<<MAPHACK2.dotabb>>=
"MAPHACK2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPHACK2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPHACK2" -> "BASTYPE"
"MAPHACK2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPHACK3 MappingPackageInternalHacks3}
\pagehead{MappingPackageInternalHacks3}{MAPHACK3}
\pagepic{ps/v104mappingpackageinternalhacks3.ps}{MAPHACK3}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPHACK3 MappingPackageInternalHacks3>>=
)abbrev package MAPHACK3 MappingPackageInternalHacks3
++ Description: various Currying operations.
MappingPackageInternalHacks3(A: SetCategory, B: SetCategory, C: SetCategory):_
  MPcat == MPdef where
    NNI ==> NonNegativeInteger
 
    MPcat == with
        comp:  (B->C, A->B, A) -> C
          ++\spad{comp(f,g,x)} is \spad{f(g x)}.
 
    MPdef == add
        comp(g,h,x)  == g h x

@
<<MAPHACK3.dotabb>>=
"MAPHACK3" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPHACK3"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPHACK3" -> "BASTYPE"
"MAPHACK3" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPPKG1 MappingPackage1}
<<MappingPackage1.input>>=
-- mappkg.spad.pamphlet MappingPackage1.input
)spool MappingPackage1.output
)set message test on
)set message auto off
)clear all

--S 1 of 26
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2 of 26
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3 of 26
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4 of 26
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5 of 26
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6 of 26
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7 of 26
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8 of 26
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9 of 26
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10 of 26
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11 of 26
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12 of 26
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13 of 26
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14 of 26
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15 of 26
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16 of 26
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17 of 26
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18 of 26
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19 of 26
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20 of 26
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21 of 26
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22 of 26
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23 of 26
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24 of 26
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25 of 26
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26 of 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
 
)spool 
)lisp (bye)
 
@
<<MappingPackage1.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )show MappingPackage1
o )help MappingPackage2
o )help MappingPackage3
o )help MappingPackage4

@
\pagehead{MappingPackage1}{MAPPKG1}
\pagepic{ps/v104mappingpackage1.ps}{MAPPKG1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPPKG1 MappingPackage1>>=
)abbrev package MAPPKG1 MappingPackage1
++ Author: S.M.Watt and W.H.Burge
++ Date Created:Jan 87
++ Date Last Updated:Feb 92
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: various Currying operations.
MappingPackage1(A:SetCategory): MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        nullary: A           -> (()->A)
          ++\spad{nullary A} changes its argument into a
          ++ nullary function.
        coerce:  A           -> (()->A)
          ++\spad{coerce A} changes its argument into a
          ++ nullary function.
 
        fixedPoint: (A->A) -> A
          ++\spad{fixedPoint f} is the fixed point of function \spad{f}.
          ++ i.e. such that \spad{fixedPoint f = f(fixedPoint f)}.
        fixedPoint: (List A->List A, Integer) -> List A
          ++\spad{fixedPoint(f,n)} is the fixed point of function
          ++ \spad{f} which is assumed to transform a list of length
          ++ \spad{n}.
 
 
        id:    A -> A
          ++\spad{id x} is \spad{x}.
        "**":  (A->A, NNI)  -> (A->A)
          ++\spad{f**n} is the  function which is the n-fold application
          ++ of \spad{f}.
 
        recur: ((NNI, A)->A) -> ((NNI, A)->A)
          ++\spad{recur(g)} is the function \spad{h} such that
          ++ \spad{h(n,x)= g(n,g(n-1,..g(1,x)..))}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks1(A)
 
        a: A
        faa:  A -> A
        f0a:  ()-> A
 
        nullary a   == a
        coerce  a   == nullary a
        fixedPoint faa ==
            g0 := GENSYM()$Lisp
            g1 := faa g0
            EQ(g0, g1)$Lisp => error "All points are fixed points"
            GEQNSUBSTLIST([g0]$Lisp, [g1]$Lisp, g1)$Lisp
 
        fixedPoint(fll, n) ==
            g0 := [(GENSYM()$Lisp):A for i in 1..n]
            g1 := fll g0
            or/[EQ(e0,e1)$Lisp for e0 in g0 for e1 in g1] =>
                error "All points are fixed points"
            GEQNSUBSTLIST(g0, g1, g1)$Lisp
 
        -- Composition and recursion.
        id a        == a
        g**n        == iter(g, n, #1)
 
        recur fnaa  == recur(fnaa, #1, #2)

@
<<MAPPKG1.dotabb>>=
"MAPPKG1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPPKG1"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPPKG1" -> "BASTYPE"
"MAPPKG1" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPPKG2 MappingPackage2}
<<MappingPackage2.input>>=
-- mappkg.spad.pamphlet MappingPackage2.input
)spool MappingPackage2.output
)set message test on
)set message auto off
)clear all
--S 1
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
)spool
)lisp (bye)
@
<<MappingPackage2.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )help MappingPackage1
o )show MappingPackage2
o )help MappingPackage3
o )help MappingPackage4

@
\pagehead{MappingPackage2}{MAPPKG2}
\pagepic{ps/v104mappingpackage2.ps}{MAPPKG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPPKG2 MappingPackage2>>=
)abbrev package MAPPKG2 MappingPackage2
++ Description: various Currying operations.
MappingPackage2(A:SetCategory, C:SetCategory): MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        const:   C           -> (A ->C)
          ++\spad{const c} is a function which produces \spad{c} when
          ++ applied to its argument.
 
        curry:    (A ->C, A)    -> (()->C)
          ++\spad{cu(f,a)} is the function \spad{g}
          ++ such that \spad{g ()= f a}.
        constant:    (()->C)       -> (A ->C)
          ++\spad{vu(f)} is the function \spad{g}
          ++ such that \spad{g a= f ()}.
 
        diag:  ((A,A)->C)    -> (A->C)
          ++\spad{diag(f)} is the function \spad{g}
          ++ such that \spad{g a = f(a,a)}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks2(A, C)
 
        a: A
        c: C
        faa:  A -> A
        f0c:  ()-> C
        fac:  A -> C
        faac: (A,A)->C
 
        const c     == arg2(#1, c)
        curry(fac, a)  == fac a
        constant f0c      == arg2(#1, f0c())
 
        diag  faac  == faac(#1, #1)

@
<<MAPPKG2.dotabb>>=
"MAPPKG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPPKG2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPPKG2" -> "BASTYPE"
"MAPPKG2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPPKG3 MappingPackage3}
<<MappingPackage3.input>>=
-- mappkg.spad.pamphlet MappingPackage3.input
)spool MappingPackage3.output
)set message test on
)set message auto off
)clear all
--S 1
power(q: FRAC INT, n: INT): FRAC INT == q**n
--R 
--R   Function declaration power : (Fraction Integer,Integer) -> Fraction 
--R      Integer has been added to workspace.
--R                                                                   Type: Void
--E 1

--S 2
power(2,3)
--R 
--R   Compiling function power with type (Fraction Integer,Integer) -> 
--R      Fraction Integer 
--R
--R   (2)  8
--R                                                       Type: Fraction Integer
--E 2

--S 3
rewop := twist power
--R 
--R
--I   (3)  theMap(MAPPKG3;twist;MM;5!0)
--R                       Type: ((Integer,Fraction Integer) -> Fraction Integer)
--E 3

--S 4
rewop(3, 2)
--R 
--R
--R   (4)  8
--R                                                       Type: Fraction Integer
--E 4

--S 5
square: FRAC INT -> FRAC INT
--R 
--R                                                                   Type: Void
--E 5

--S 6
square:= curryRight(power, 2)
--R 
--R
--I   (6)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 6

--S 7
square 4
--R 
--R
--R   (7)  16
--R                                                       Type: Fraction Integer
--E 7

--S 8
squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
--R 
--R
--I   (8)  theMap(MAPPKG3;constantRight;MM;3!0)
--R              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)
--E 8

--S 9
squirrel(1/2, 1/3)
--R 
--R
--R        1
--R   (9)  -
--R        4
--R                                                       Type: Fraction Integer
--E 9

--S 10
sixteen := curry(square, 4/1)
--R 
--R
--I   (10)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                               Type: (() -> Fraction Integer)
--E 10

--S 11
sixteen()
--R 
--R
--R   (11)  16
--R                                                       Type: Fraction Integer
--E 11

--S 12
square2:=square*square
--R 
--R
--I   (12)  theMap(MAPPKG3;*;MMM;6!0,0)
--R                                 Type: (Fraction Integer -> Fraction Integer)
--E 12

--S 13
square2 3
--R 
--R
--R   (13)  81
--R                                                       Type: Fraction Integer
--E 13

--S 14
sc(x: FRAC INT): FRAC INT == x + 1
--R 
--R   Function declaration sc : Fraction Integer -> Fraction Integer has 
--R      been added to workspace.
--R                                                                   Type: Void
--E 14

--S 15
incfns := [sc**i for i in 0..10]
--R 
--R   Compiling function sc with type Fraction Integer -> Fraction Integer
--R      
--R
--R   (15)
--I   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
--I    theMap(MAPPKG1;**;MNniM;6!0,0)]
--R                            Type: List (Fraction Integer -> Fraction Integer)
--E 15

--S 16
[f 4 for f in incfns]
--R 
--R
--R   (16)  [4,5,6,7,8,9,10,11,12,13,14]
--R                                                  Type: List Fraction Integer
--E 16

--S 17
times(n:NNI, i:INT):INT == n*i
--R 
--R   Function declaration times : (NonNegativeInteger,Integer) -> Integer
--R      has been added to workspace.
--R                                                                   Type: Void
--E 17

--S 18
r := recur(times)
--R 
--R   Compiling function times with type (NonNegativeInteger,Integer) -> 
--R      Integer 
--R
--I   (18)  theMap(MAPPKG1;recur;2M;7!0,0)
--R                              Type: ((NonNegativeInteger,Integer) -> Integer)
--E 18

--S 19
fact := curryRight(r, 1)
--R 
--R
--I   (19)  theMap(MAPPKG3;curryRight;MBM;1!0,0)
--R                                        Type: (NonNegativeInteger -> Integer)
--E 19

--S 20
fact 4
--R 
--R
--R   (20)  24
--R                                                        Type: PositiveInteger
--E 20

--S 21
mto2ton(m, n) ==
  raiser := square^n
  raiser m
--R 
--R                                                                   Type: Void
--E 21

--S 22
mto2ton(3, 3)
--R 
--R   Compiling function mto2ton with type (PositiveInteger,
--R      PositiveInteger) -> Fraction Integer 
--R
--R   (22)  6561
--R                                                       Type: Fraction Integer
--E 22

--S 23
shiftfib(r: List INT) : INT ==
  t := r.1
  r.1 := r.2
  r.2 := r.2 + t
  t
--R 
--R   Function declaration shiftfib : List Integer -> Integer has been 
--R      added to workspace.
--R                                                                   Type: Void
--E 23

--S 24
fibinit: List INT := [0, 1]
--R 
--R
--R   (24)  [0,1]
--R                                                           Type: List Integer
--E 24

--S 25
fibs := curry(shiftfib, fibinit)
--R 
--R   Compiling function shiftfib with type List Integer -> Integer 
--R
--I   (25)  theMap(MAPPKG2;curry;MAM;2!0,0)
--R                                                        Type: (() -> Integer)
--E 25

--S 26
[fibs() for i in 0..30]
--R 
--R
--R   (26)
--R   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
--R    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
--R    317811, 514229, 832040]
--R                                                           Type: List Integer
--E 26
)spool
)lisp (bye)
@
<<MappingPackage3.help>>=
====================================================================
MappingPackage examples
====================================================================

Function are objects of type Mapping.  In this section we demonstrate
some library operations from the packages MappingPackage1, MappingPackage2, 
and MappingPackage3 that manipulate and create functions. Some terminology: 
a nullary function takes no arguments, a unary function takes one argument, 
and a binary function takes two arguments.

We begin by creating an example function that raises a rational number
to an integer exponent.

  power(q: FRAC INT, n: INT): FRAC INT == q**n
                      Type: Void

  power(2,3)
    8
                       Type: Fraction Integer

The twist operation transposes the arguments of a binary function.
Here rewop(a, b) is power(b, a).

  rewop := twist power
    theMap(MAPPKG3;twist;MM;5!0)
                       Type: ((Integer,Fraction Integer) -> Fraction Integer)

This is 2^3.

  rewop(3, 2)
    8
                       Type: Fraction Integer

Now we define square in terms of power.

  square: FRAC INT -> FRAC INT
                       Type: Void
The curryRight operation creates a unary function from a binary one by
providing a constant argument on the right.

  square:= curryRight(power, 2)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

Likewise, the curryLeft operation provides a constant argument on the
left.

  square 4
    16
                       Type: Fraction Integer

The constantRight operation creates (in a trivial way) a binary
function from a unary one: constantRight(f) is the function g such
that g(a,b)= f(a).

  squirrel:= constantRight(square)$MAPPKG3(FRAC INT,FRAC INT,FRAC INT)
    theMap(MAPPKG3;constantRight;MM;3!0)
              Type: ((Fraction Integer,Fraction Integer) -> Fraction Integer)

Likewise, constantLeft(f) is the function g such that g(a,b)= f(b).

  squirrel(1/2, 1/3)
    1
    -
    4
                       Type: Fraction Integer

The curry operation makes a unary function nullary.

  sixteen := curry(square, 4/1)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Fraction Integer)

  sixteen()
    16
                       Type: Fraction Integer

The * operation constructs composed functions.

  square2:=square*square
    theMap(MAPPKG3;*;MMM;6!0,0)
                       Type: (Fraction Integer -> Fraction Integer)

  square2 3
    81
                       Type: Fraction Integer

Use the ** operation to create functions that are n-fold iterations of
other functions.

  sc(x: FRAC INT): FRAC INT == x + 1
                       Type: Void

This is a list of Mapping objects.

  incfns := [sc**i for i in 0..10]
   [theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0), theMap(MAPPKG1;**;MNniM;6!0,0),
    theMap(MAPPKG1;**;MNniM;6!0,0)]
                       Type: List (Fraction Integer -> Fraction Integer)

This is a list of applications of those functions.

  [f 4 for f in incfns]
    [4,5,6,7,8,9,10,11,12,13,14]
                       Type: List Fraction Integer

Use the recur operation for recursion:

  g := recur f means g(n,x) == f(n,f(n-1,...f(1,x))).

  times(n:NNI, i:INT):INT == n*i
                       Type: Void

  r := recur(times)
    theMap(MAPPKG1;recur;2M;7!0,0)
                       Type: ((NonNegativeInteger,Integer) -> Integer)

This is a factorial function.

  fact := curryRight(r, 1)
    theMap(MAPPKG3;curryRight;MBM;1!0,0)
                       Type: (NonNegativeInteger -> Integer)

  fact 4
    24
                       Type: PositiveInteger

Constructed functions can be used within other functions.

  mto2ton(m, n) ==
    raiser := square^n
    raiser m
                       Type: Void

This is 3^(2^3).

  mto2ton(3, 3)
    6561
                       Type: Fraction Integer

Here shiftfib is a unary function that modifies its argument.

  shiftfib(r: List INT) : INT ==
    t := r.1
    r.1 := r.2
    r.2 := r.2 + t
    t
                       Type: Void

By currying over the argument we get a function with private state.

  fibinit: List INT := [0, 1]
    [0,1]
                       Type: List Integer

  fibs := curry(shiftfib, fibinit)
    theMap(MAPPKG2;curry;MAM;2!0,0)
                       Type: (() -> Integer)

  [fibs() for i in 0..30]
   [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597,
    2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418,
    317811, 514229, 832040]
                       Type: List Integer

See Also:
o )help MappingPackage1
o )help MappingPackage2
o )show MappingPackage3
o )help MappingPackage4

@
\pagehead{MappingPackage3}{MAPPKG3}
\pagepic{ps/v104MappingPackage3.ps}{MAPPKG3}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPPKG3 MappingPackage3>>=
)abbrev package MAPPKG3 MappingPackage3
++ Description: various Currying operations.
MappingPackage3(A:SetCategory, B:SetCategory, C:SetCategory):_
  MPcat == MPdef where
    NNI   ==>  NonNegativeInteger
 
    MPcat ==  with
        curryRight:   ((A,B)->C, B) -> (A ->C)
          ++\spad{curryRight(f,b)} is the function \spad{g} such that
          ++ \spad{g a = f(a,b)}.
        curryLeft:   ((A,B)->C, A) -> (B ->C)
          ++\spad{curryLeft(f,a)} is the function \spad{g}
          ++ such that \spad{g b = f(a,b)}.
 
        constantRight:   (A -> C)      -> ((A,B)->C)
          ++\spad{constantRight(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f a}.
        constantLeft:   (B -> C)      -> ((A,B)->C)
          ++\spad{constantLeft(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f b}.
 
        twist: ((A,B)->C)    -> ((B,A)->C)
          ++\spad{twist(f)} is the function \spad{g}
          ++ such that \spad{g (a,b)= f(b,a)}.
 
        "*":   (B->C, A->B) -> (A->C)
          ++\spad{f*g} is the function \spad{h}
          ++ such that \spad{h x= f(g x)}.
 
 
    MPdef == add
 
        MappingPackageInternalHacks3(A, B, C)
 
        a: A
        b: B
        c: C
        faa:  A -> A
        f0c:  ()-> C
        fac:  A -> C
        fbc:  B -> C
        fab:  A -> B
        fabc: (A,B)->C
        faac: (A,A)->C
 
        -- Fix left and right arguments as constants.
        curryRight(fabc,b) == fabc(#1,b)
        curryLeft(fabc,a) == fabc(a, #1)
 
        -- Add left and right arguments which are ignored.
        constantRight fac     == fac #1
        constantLeft fbc     == fbc #2
 
        -- Combinators to rearrange arguments.
        twist fabc  == fabc(#2, #1)
        -- Functional composition
        fbc*fab == comp(fbc,fab,#1)

@
<<MAPPKG3.dotabb>>=
"MAPPKG3" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPPKG3"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"MAPPKG3" -> "BASTYPE"
"MAPPKG3" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MAPPKG4 MappingPackage4}
<<MappingPackage4.input>>=
-- mappkg.spad.pamphlet MappingPackage4.input
)spool MappingPackage4.output
)set message test on
)set message auto off
)clear all

--S 1 of 21
p:=(x:EXPR(INT)):EXPR(INT)+->3*x
--R 
--R
--R   (1)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 1

--S 2 of 21
q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
--R 
--R
--R   (2)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 2

--S 3 of 21
(p+q)(4)-(p(4)+q(4))
--R 
--R
--R   (3)  0
--R                                                     Type: Expression Integer
--E 3

--S 4 of 21
(p+q)(x)-(p(x)+q(x))
--R 
--R
--R   (4)  0
--R                                                     Type: Expression Integer
--E 4

--S 5 of 21
(p-q)(4)-(p(4)-q(4))
--R 
--R
--R   (5)  0
--R                                                     Type: Expression Integer
--E 5

--S 6 of 21
(p-q)(x)-(p(x)-q(x))
--R 
--R
--R   (6)  0
--R                                                     Type: Expression Integer
--E 6

--S 7 of 21
(p*q)(4)-(p(4)*q(4))
--R 
--R
--R   (7)  0
--R                                                     Type: Expression Integer
--E 7

--S 8 of 21
(p*q)(x)-(p(x)*q(x))
--R 
--R
--R   (8)  0
--R                                                     Type: Expression Integer
--E 8

--S 9 of 21
(p/q)(4)-(p(4)/q(4))
--R 
--R
--R   (9)  0
--R                                                     Type: Expression Integer
--E 9

--S 10 of 21
(p/q)(x)-(p(x)/q(x))
--R 
--R
--R   (10)  0
--R                                                     Type: Expression Integer
--E 10

--S 11 of 21
r:=(x:INT):INT+-> (x*x*x)
--R 
--R
--R   (11)  theMap(Closure)
--R                                                   Type: (Integer -> Integer)
--E 11

--S 12 of 21
s:=(y:INT):INT+-> (y*y+3)
--R 
--R
--R   (12)  theMap(Closure)
--R                                                   Type: (Integer -> Integer)
--E 12

--S 13 of 21
(r+s)(4)-(r(4)+s(4))
--R 
--R
--R   (13)  0
--R                                                     Type: NonNegativeInteger
--E 13

--S 14 of 21
(r-s)(4)-(r(4)-s(4))
--R 
--R
--R   (14)  0
--R                                                     Type: NonNegativeInteger
--E 14

--S 15 of 21
(r*s)(4)-(r(4)*s(4))
--R 
--R
--R   (15)  0
--R                                                     Type: NonNegativeInteger
--E 15

--S 16 of 21
t:=(x:INT):EXPR(INT)+-> (x*x*x)
--R 
--R
--R   (16)  theMap(Closure)
--R                                        Type: (Integer -> Expression Integer)
--E 16

--S 17 of 21
u:=(y:INT):EXPR(INT)+-> (y*y+3)
--R 
--R
--R   (17)  theMap(Closure)
--R                                        Type: (Integer -> Expression Integer)
--E 17

--S 18 of 21
(t/u)(4)-(t(4)/u(4))
--R 
--R
--R   (18)  0
--R                                                     Type: Expression Integer
--E 18

--S 19 of 21
h:=(x:EXPR(INT)):EXPR(INT)+->1
--R
--R   (19)  theMap(Closure)
--R                             Type: (Expression Integer -> Expression Integer)
--E 19

--S 20 of 21
(p/h)(x)
--R
--R   (20)  3x
--R                                                     Type: Expression Integer
--E 20

--S 21 of 21
(q/h)(x)
--R
--R   (21)  2x + 3
--R                                                     Type: Expression Integer
--E 21

)spool 
)lisp (bye)
 
@
<<MappingPackage4.help>>=
====================================================================
MappingPackage examples
====================================================================

We can construct some simple maps that take a variable x
into an equation:

  p:=(x:EXPR(INT)):EXPR(INT)+->3*x
  q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3

Now we can do the four arithmetic operations, +, -, *, / on these
newly constructed mappings. Since the maps are from the domain
Expression Integer to the same domain we can also use symbolic
values for the argument. All of the following will return 0,
showing that function composition is equivalent to the result
of doing the operations individually.

  (p+q)(4)-(p(4)+q(4))
  (p+q)(x)-(p(x)+q(x))
  
  (p-q)(4)-(p(4)-q(4))
  (p-q)(x)-(p(x)-q(x))

  (p*q)(4)-(p(4)*q(4))
  (p*q)(x)-(p(x)*q(x))

  (p/q)(4)-(p(4)/q(4))
  (p/q)(x)-(p(x)/q(x))

We can construct simple maps from Integer to Integer but this
limits our ability to do division.

  r:=(x:INT):INT+-> (x*x*x)
  s:=(y:INT):INT+-> (y*y+3)

Again, all of these will return 0:

  (r+s)(4)-(r(4)+s(4))
  (r-s)(4)-(r(4)-s(4))
  (r*s)(4)-(r(4)*s(4))

If we want to do division with Integer inputs we create the
appropriate map:

  t:=(x:INT):EXPR(INT)+-> (x*x*x)
  u:=(y:INT):EXPR(INT)+-> (y*y+3)

  (t/u)(4)-(t(4)/u(4))

We can even recover the original functions if we make a map
that always returns the constant 1:

  h:=(x:EXPR(INT)):EXPR(INT)+->1

    theMap(Closure)
             Type: (Expression Integer -> Expression Integer)

  (p/h)(x)

     3x
                                     Type: Expression Integer
  (q/h)(x)

    2x + 3
                                     Type: Expression Integer

See Also:
o )show MappingPackage1
o )help MappingPackage2
o )help MappingPackage3
o )help MappingPackage4

@
\pagehead{MappingPackage4}{MAPPKG4}
\pagepic{ps/v104mappingpackage4.ps}{MAPPKG4}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MAPPKG4 MappingPackage4>>=
)abbrev package MAPPKG4 MappingPackage4
++ Author: Timothy Daly
++ Description: Functional Composition
++ Given functions f and g, returns the applicable closure
MappingPackage4(A:SetCategory, B:Ring):
 with
   "+": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f+g)(4)
   "-": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f-g)(4)
   "*": (A->B, A->B) -> (A->B) 
        ++ \spad(+) does functional addition
        ++
        ++X f:=(x:INT):INT +-> 3*x
        ++X g:=(x:INT):INT +-> 2*x+3
        ++X (f*g)(4)
   "/": (A->Expression(Integer), A->Expression(Integer)) -> (A->Expression(Integer))
        ++ \spad(+) does functional addition
        ++
        ++X p:=(x:EXPR(INT)):EXPR(INT)+->3*x
        ++X q:=(x:EXPR(INT)):EXPR(INT)+->2*x+3
        ++X (p/q)(4)
        ++X (p/q)(x)
  == add
    fab ==> (A -> B)
    faei ==> (A -> Expression(Integer))

    funcAdd(g:fab,h:fab,x:A):B == ((g x) + (h x))$B

    (a:fab)+(b:fab) == funcAdd(a,b,#1)

    funcSub(g:fab,h:fab,x:A):B == ((g x) - (h x))$B

    (a:fab)-(b:fab) == funcSub(a,b,#1)

    funcMul(g:fab,h:fab,x:A):B == ((g x) * (h x))$B

    (a:fab)*(b:fab) == funcMul(a,b,#1)

    funcDiv(g:faei,h:faei,x:A):Expression(Integer)
           == ((g x) / (h x))$Expression(Integer)

    (a:faei)/(b:faei) == funcDiv(a,b,#1)

@
<<MAPPKG4.dotabb>>=
"MAPPKG4" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MAPPKG4"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"MAPPKG4" -> "PID"
"MAPPKG4" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MMLFORM MathMLFormat}

Both this code and documentation are still under development and
I don't pretend they are anywhere close to perfect or even finished.
However the code does work and I hope it might be useful to somebody
both for it's ability to output MathML from Axiom and as an example
of how to write a new output form.

\subsection{Introduction to Mathematical Markup Language}

MathML exists in two forms: presentation and content.
At this time (2007-02-11) the package only has a presentation
package.  A content package is in the
works however it is more difficult.  Unfortunately Axiom does
not make its semantics easily available.  The \spadtype{OutputForm}
domain mediates between the individual Axiom domains and the
user visible output but \spadtype{OutputForm} does not provide full
semantic information.  From my currently incomplete understanding
of Axiom it appears that remedying this would entail going back
to the individual domains and rewriting a lot of code.
However some semantics are conveyed directly by \spadtype{OutputForm} and other
things can be deduced from \spadtype{OutputForm} or from the original
user command.

\subsection{Displaying MathML}

The MathML string produced by ")set output mathml on" can be pasted
directly into an appropriate xhtml page and then viewed in Firefox
or some other MathML aware browser. The boiler plate code needed for
a test page, testmathml.xml, is:

\begin{verbatim}
<?xml version="1.0" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
                      "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd" [
<!ENTITY mathml "http://www.w3.org/1998/Math/MathML">
]>

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xlink="http://www.w3.org/1999/xlink" >


  <head>
    <title>MathML Test </title>
  </head>

  <body>

  </body>
</html>
\end{verbatim}


Paste the MathML string into the body element and it should display
nicely in Firefox.

\subsection{Test Cases}

Here's a list of test cases that currently format correctly:

1. (x+y)**2

2. integrate(x**x,x)

3. integral(x**x,x)

4. (5 + sqrt 63 + sqrt 847)**(1/3)

5. set $[$1,2,3$]$

6. multiset $[$x rem 5 for x in primes(2,1000)$]$

7. series(sin(a*x),x=0)

8. matrix $[$ $[$x**i + y**j for i in 1..10$]$ for j in 1..10$]$

9. y := operator 'y
   a. D(y(x,z),$[$x,x,z,x$]$)
   b. D(y x,x,2)

10. x := series 'x
    a. sin(1+x)

11. series(1/log(y),y=1)

12. y:UTS(FLOAT,'z,0) := exp(z)

13. a. c := continuedFraction(314159/100000)
    b. c := continuedFraction(314159/100000)

The \spadtype{TexFormat} domain has the capability to format an object with
subscripts, superscripts, presubscripts and presuperscripts however
I don't know of any Axiom command that produces such an object. In
fact at present I see the case of "SUPERSUB" being used for putting
primes in the superscript position to denote ordinary differentiation.
I also only see the "SUB" case being used to denote partial
derivatives.

\subsection{)set output mathml on}


Making mathml appear as output during a normal Axiom session
by invoking ")set output mathml on" proved to be a bit tedious
and seems to be undocumented.  I document my experience here
in case it proves useful to somebody else trying to get a new
output format from Axiom.

In \spadtype{MathMLFormat} the functions 
\spadfun{coerce(expr : OutputForm) : String} and
\spadfun{display(s : String) : Void} provide the desired mathml output.
Note that this package was constructed by close examination of
Robert Sutor's \spadtype{TexFormat} domain and much remains from that source.
To have mathml displayed as output we need to get Axiom to 
call display(coerce(expr)) at the appropriate place.  Here's what
I did to get that to happen. Note that my starting point here was
an attempt by Andrey Grozin to do the same.  To figure things out
I searched through files for "tex" to see what was done for the
\spadtype{TexFormat} domain, and used grep to find which files had mention of
\spadtype{TexFormat}.

\subsection{File src/interp/setvars.boot.pamphlet}


  Create an output mathml section by analogy to the tex section.
Remember to add the code chunk "outputmathmlCode" at the end.

setvars.boot is a bootstrap file which means that it has to be
precompiled into lisp code and then that code has to be inserted
back into setvars.boot. To do this extract the boot code by running
"notangle" on it.  I did this from the "tmp" directory.
From inside axiom run ")lisp (boottran::boottocl "tmp/setvars.boot")
which put "setvars.clisp" into "int/interp/setvars.clisp".  Then
replace the lisp in "setvars.boot.pamphlet" with that in the newly
generated "setvars.clisp".

The relevant code chunks appearing in "setvars.boot.pamphlet" are:
\begin{verbatim}
    outputmathmlCode
    setOutputMathml
    describeSetOutputMathml
\end{verbatim}
and the relevant variables are:
\begin{verbatim}
    setOutputMathml
    $mathmlOutputStream
    $mathmlOutputFile
    $mathmlFormat
    describeSetOutputMathml
\end{verbatim}

\subsection{File setvart.boot.pamphlet}


Create an output mathml section in "setvart.boot.pamphlet" again
patterned after the tex section.  I changed the default file 
extension from ".stex" to ".smml".

To the "section{output}" table I added the line
\begin{verbatim}
   mathml		   created output in MathML style	Off:CONSOLE
\end{verbatim}
Added the code chunk "outputmathml" to the code chunk "output"
in "section{output}".

Relevant code chunks:
\begin{verbatim}
	 outputmathml
\end{verbatim}
Relevant variables:
\begin{verbatim}
	 setOutputMathml
	 $mathmlFormat
	 $mathmlOutputFile
\end{verbatim}

Note when copying the tex stuff I changed occurrences of "tex"
to "mathml", "Tex" to "Mathml" and "TeX" to "MathML".

\subsection{File src/algebra/Makefile.pamphlet}


The file "src/algebra/tex.spad.pamphlet" contains
the domain \spadtype{TexFormat} (TEX) and the package 
\spadtype{TexFormat1} (TEX1).
However the sole function of \spadtype{TexFormat1} is to \spadfun{coerce}
objects from a domain into \spadtype{OutputForm} and then apply 
\spadtype{TexFormat}
to them.  It is to save programmers the trouble of doing
the coercion themselves from inside spad code.  It does
not appear to be used for the main purpose of delivering
Axiom output in TeX format.  In order to keep the mathml
package as simple as possible, and because I didn't see much
use for this, I didn't copy the \spadtype{TexFormat1} package.  So
no analog of the TEX1 entries in "Makefile.pamphlet" were
needed.  One curiosity I don't understand is why TEX1
appears in layer 4 when it seems to depend on TEX which
appears in layer 14.

Initially I added "\${OUT}/MMLFORM.o" to layer 14 and
"mathml.spad.pamphlet" to completed spad files in layer 14.
When trying to compile the build failed at MMLFORM.  It left
"MMLFORM.erlib" in "int/algebra" instead of "MMLFORM.NRLIB"
which confused me at first because mathml.spad compiled
under a running axiom.  By examining the file "obj/tmp/trace"
I saw that a new dependency had been introduced, compared
to TexFormat, with the function eltName depending on the
domain FSAGG in layer 16.  So the lines had to be moved 
from layer 14 to layer 17.

Added appropriate lines to "SPADFILES" and "DOCFILES".

\subsection{File src/algebra/exposed.lsp.pamphlet}

Add the line "($\vert{}$MathMLFormat$\vert$ . MMLFORM)"

\subsection{File src/algebra/Lattice.pamphlet}

I don't see that this file is used anywhere but I made
the appropriate changes anyway by searching for "TEX" and
mimicing everything for MMLFORM.

\subsection{File src/doc/axiom.bib.pamphlet}

Added mathml.spad subsection to "src/doc/axiom.bib.pamphlet".

\subsection{File interp/i-output.boot.pamphlet}


This is where the \spadfun{coerce} and \spadfun{display} functions 
from MathMLFormat
actually get called.  The following was added:

\begin{verbatim}
mathmlFormat expr ==
  mml := '(MathMLFormat)
  mmlrep := '(String)
  formatFn := getFunctionFromDomain("coerce",mml,[$OutputForm])
  displayFn := getFunctionFromDomain("display",mml,[mmlrep])
  SPADCALL(SPADCALL(expr,formatFn),displayFn)
  TERPRI $mathmlOutputStream
  FORCE_-OUTPUT $mathmlOutputStream
  NIL
\end{verbatim}

Note that compared to the texFormat function there are a couple
of differences.  Since \spadtype{MathMLFormat} is currently a package rather
than a domain there is the "mmlrep" variable whereas in texFormat
the argument of the "display" function is an instance of the 
domain.  Also the \spadfun{coerce} function here only has one argument,
namely "\$OutputForm".

Also for the function "output(expr,domain)" add lines for mathml,
e.g. "if \$mathmlFormat then mathmlFormat expr".

After these changes Axiom compiled with mathml enabled under
)set output.

\subsection{Public Declarations}

The declarations
\begin{verbatim}
  E      ==> OutputForm
  I      ==> Integer
  L      ==> List
  S      ==> String
  US     ==> UniversalSegment(Integer)
\end{verbatim}
provide abbreviations for domains used heavily in the code.
The publicly exposed functions are:

    \spadfun{coerce: E -$>$ S}  This function is the main one for converting
an expression in domain OutputForm into a MathML string.

    \spadfun{coerceS: E -$>$ S} This function is for use from the command line.
It converts an OutputForm expression into a MathML string and does
some formatting so that the output is not one long line.  If you take
the output from this function, stick it in an emacs buffer in
nxml-mode and then indent according to mode, you'll get something that's
nicer to look at than what comes from coerce. Note that coerceS returns
the same value as coerce but invokes a display function as well so that
the result will be printed twice in different formats.  The need for this
is that the output from coerce is automatically formatted with line breaks
by Axiom's output routine that are not in the right place.

    \spadfun{coerceL: E -$>$ S}  Similar to coerceS except that the displayed result
is the MathML string in one long line.  These functions can be used,
for instance, to get the MathML for the previous result by typing
coerceL(%)\$MMLFORM.

    \spadfun{exprex: E -$>$ S}  Converts \spadtype{OutputForm} to 
\spadtype{String} with
the structure preserved with braces.  This is useful in developing this
package. Actually this is not quite accurate.  The function
\spadfun{precondition} is first applied to the \spadtype{OutputForm}
expression before \spadfun{exprex}.   Raw \spadtype{OutputForm} and the nature
of the \spadfun{precondition} function is still obscure to me at the time of
this writing (2007-02-14), however I probably need to understand it to make
sure I'm not missing any semantics.  The spad function \spadfun{precondition}
is just a wrapper for the lisp function outputTran\$Lisp, which I guess is
compiled from boot.

    \spadfun{display: S -$>$ Void}  This one prints the string returned by coerce as one
long line, adding "math" tags: $<$math ...$>$ ... $<$/math$>$.  Thus the output
from this can be stuck directly into an appropriate html/xhtml page and will
be displayed nicely by a MathML aware browser.

    \spadfun{displayF: S -$>$ Void}  This function doesn't exist 
yet but it would be nice
to have a humanly readable formatted output as well.  The basics do exist in
the coerceS function however the formatting still needs some work to be 
really good.

<<public declarations>>=
)abbrev domain MMLFORM MathMLFormat
++ Author: Arthur C. Ralfs
++ Date: January 2007
++ This package is based on the TeXFormat domain by Robert S. Sutor
++ without which I wouldn't have known where to start.
++ Basic Operations: coerce, coerceS, coerceL, exprex, display
++ Description:
++    \spadtype{MathMLFormat} provides a coercion from \spadtype{OutputForm}
++    to MathML format.

MathMLFormat(): public == private where
  E      ==> OutputForm
  I      ==> Integer
  L      ==> List
  S      ==> String
  US     ==> UniversalSegment(Integer)

  public == SetCategory with
    coerce:    E -> S
      ++ coerceS(o) changes o in the standard output format to MathML
      ++ format.
    coerceS:   E -> S
      ++ coerceS(o) changes o in the standard output format to MathML
      ++ format and displays formatted result.
    coerceL:   E -> S
      ++ coerceS(o) changes o in the standard output format to MathML
      ++ format and displays result as one long string.
    exprex:    E -> S
      ++ coverts \spadtype{OutputForm} to \spadtype{String} with the
      ++ structure preserved with braces.  Actually this is not quite
      ++ accurate.  The function \spadfun{precondition} is first 
      ++ applied to the
      ++ \spadtype{OutputForm} expression before \spadfun{exprex}.  
      ++ The raw \spadtype{OutputForm} and
      ++ the nature of the \spadfun{precondition} function is 
      ++ still obscure to me
      ++ at the time of this writing (2007-02-14).
    display:   S -> Void
      ++ prints the string returned by coerce, adding <math ...> tags.

@
\subsection{Private Constant Declarations}
<<private constant declarations>>=
  private == add
    import OutputForm
    import Character
    import Integer
    import List OutputForm
    import List String

    -- local variable declarations and definitions

    expr: E
    prec,opPrec: I
    str:  S
    blank         : S := " \  "

    maxPrec       : I   := 1000000
    minPrec       : I   := 0

    unaryOps      : L S := ["-","^"]$(L S)
    unaryPrecs    : L I := [700,260]$(L I)

    -- the precedence of / in the following is relatively low because
    -- the bar obviates the need for parentheses.
    binaryOps     : L S := ["+->","|","**","/","<",">","=","OVER"]$(L S)
    binaryPrecs   : L I := [0,0,900, 700,400,400,400,   700]$(L I)

    naryOps       : L S := ["-","+","*",blank,",",";"," ","ROW","",
       " \cr ","&","</mtd></mtr><mtr><mtd>"]$(L S)
    naryPrecs     : L I := [700,700,800,  800,110,110,  0,    0, 0,
             0,  0,   0]$(L I)
    naryNGOps     : L S := ["ROW","&"]$(L S)

    plexOps       : L S := ["SIGMA","SIGMA2","PI","PI2","INTSIGN","INDEFINTEGRAL"]$(L S)
    plexPrecs     : L I := [    700, 800,     700, 800 , 700,      700]$(L I)

    specialOps    : L S := ["MATRIX","BRACKET","BRACE","CONCATB","VCONCAT",  _
                            "AGGLST","CONCAT","OVERBAR","ROOT","SUB","TAG", _
                            "SUPERSUB","ZAG","AGGSET","SC","PAREN", _
                            "SEGMENT","QUOTE","theMap" ]

    -- the next two lists provide translations for some strings for
    -- which MML provides special macros.

    specialStrings : L S :=
      ["cos", "cot", "csc", "log", "sec", "sin", "tan",
        "cosh", "coth", "csch", "sech", "sinh", "tanh",
          "acos","asin","atan","erf","...","$","infinity"]
    specialStringsInMML : L S :=
      ["<mo>cos</mo>","<mo>cot</mo>","<mo>csc</mo>","<mo>log</mo>","<mo>sec</mo>","<mo>sin</mo>","<mo>tan</mo>",
        "<mo>cosh</mo>","<mo>coth</mo>","<mo>csch</mo>","<mo>sech</mo>","<mo>sinh</mo>","<mo>tanh</mo>",
          "<mo>arccos</mo>","<mo>arcsin</mo>","<mo>arctan</mo>","<mo>erf</mo>","<mo>&#x2026;</mo>","<mo>$</mo>","<mo>&#x221E;</mo>"]

@
\subsection{Private Function Declarations}

These are the local functions:

    addBraces:S -$>$ S

    addBrackets:S -$>$ S

    atomize:E -$>$ L E

    displayElt:S -$>$ Void
      function for recursively displaying mathml nicely formatted

    eltLimit:(S,I,S) -$>$ I
      demarcates end postion of mathml element with name:S starting at
      position i:I in mathml string s:S and returns end of end tag as
      i:I position in mathml string, i.e. find start and end of
      substring:  $<$name ...$>$...$<$/name$>$

    eltName:(I,S) -$>$ S
      find name of mathml element starting at position i:I in string s:S

    group:S -$>$ S

    formatBinary:(S,L E, I) -$>$ S

    formatFunction:(S,L E, I) -$>$ S

    formatMatrix:L E -$>$ S

    formatNary:(S,L E, I) -$>$ S

    formatNaryNoGroup:(S,L E, I) -$>$ S

    formatNullary:S -$>$ S

    formatPlex:(S,L E, I) -$>$ S

    formatSpecial:(S,L E, I) -$>$ S

    formatUnary:(S,  E, I) -$>$ S

    formatMml:(E,I) -$>$ S

    newWithNum:I -$>$ \$
      this is a relic from tex.spad and is not used here so far.  I'll
      probably remove it.

    parenthesize:S -$>$ S

    precondition:E -$>$ E
      this function is applied to the OutputForm expression before
      doing anything else.

    postcondition:S -$>$ S
      this function is applied after all other OutputForm -$>$ MathML
      transformations.  In the TexFormat domain the ungroup function
      first peels off the outermost set of braces however I have 
      replaced braces with $<$mrow$>$s here and sometimes the outermost set
      of $<$mrow$>$s is necessary to get proper display in Firefox.  
      For instance with getting the correct size of brackets on a matrix 
      the whole expression needs to be enclosed in a mrow element.  
      It also checks for $+-$ and removes the $+$.

    stringify:E -$>$ S

    tagEnd:(S,I,S) -$>$ I
      finds closing "$>$" of start or end tag for mathML element for formatting
      MathML string for human readability.  No analog in TexFormat.

    ungroup:S -$>$ S

<<private function declarations>>=
    -- local function signatures

    addBraces:      S -> S
    addBrackets:    S -> S
    atomize:        E -> L E
    displayElt:     S -> Void
      ++ function for recursively displaying mathml nicely formatted
    eltLimit:       (S,I,S) -> I
      ++ demarcates end postion of mathml element with name:S starting at
      ++ position i:I in mathml string s:S and returns end of end tag as
      ++  i:I position in mathml string, i.e. find start and end of
      ++  substring:  <name ...>...</name>
    eltName:        (I,S) -> S
      ++ find name of mathml element starting at position i:I in string s:S
    group:          S -> S
    formatBinary:   (S,L E, I) -> S
    formatFunction: (S,L E, I) -> S
    formatIntSign:  (L E, I) -> S
    formatMatrix:   L E -> S
    formatNary:     (S,L E, I) -> S
    formatNaryNoGroup: (S,L E, I) -> S
    formatNullary:  S -> S
    formatPlex:     (S,L E, I) -> S
    formatSpecial:  (S,L E, I) -> S
    formatSub:      (E, L E, I) -> S
    formatSuperSub: (E, L E, I) -> S
    formatSuperSub1: (E, L E, I) -> S
    formatUnary:    (S,  E, I) -> S
    formatMml:      (E,I) -> S
    formatZag:      L E -> S
    formatZag1:     L E -> S
    newWithNum:     I -> $
    parenthesize:   S -> S
    precondition:   E -> E
    postcondition:  S -> S
    stringify:      E -> S
    tagEnd:         (S,I,S) -> I
      ++  finds closing ">" of start or end tag for mathML element
    ungroup:        S -> S

@
\subsection{Public Function Definitions}

Note that I use the function sayTeX\$Lisp much as I would printf in a
C program.  I've noticed in grepping the code that there are other "say"
functions, sayBrightly and sayMessage for instance, but I have no idea
what the difference is between them at this point.  sayTeX\$Lisp does the
job so for the time being I'll use that until I learn more.

The functions coerceS and coerceL should probably be changed to display
functions, {\it i.e.}\/ \spadfun{displayS} and \spadfun{display L}, 
returning Void.  I really only need the one coerce function.

<<public function definitions>>=
    -- public function definitions

    coerce(expr : E): S ==
      s : S := postcondition formatMml(precondition expr, minPrec)
      s

    coerceS(expr : E): S ==
      s : S := postcondition formatMml(precondition expr, minPrec)
      sayTeX$Lisp "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
      displayElt(s)
      sayTeX$Lisp "</math>"
      s

    coerceL(expr : E): S ==
      s : S := postcondition formatMml(precondition expr, minPrec)
      sayTeX$Lisp "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
      sayTeX$Lisp s
      sayTeX$Lisp "</math>"
      s

    display(mathml : S): Void ==
      sayTeX$Lisp "<math xmlns=_"http://www.w3.org/1998/Math/MathML_" mathsize=_"big_" display=_"block_">"
      sayTeX$Lisp mathml
      sayTeX$Lisp "</math>"
      void()$Void

      

    exprex(expr : E): S ==
      -- This breaks down an expression into atoms and returns it as
      -- a string.  It's for developmental purposes to help understand
      -- the expressions.
      a : E
      expr := precondition expr
--      sayTeX$Lisp "0: "stringify expr
      (ATOM(expr)$Lisp@Boolean) or (stringify expr = "NOTHING") => 
        concat ["{",stringify expr,"}"]      
      le : L E := (expr pretend L E)
      op := first le
      sop : S := exprex op
      args : L E := rest le
      nargs : I := #args
--      sayTeX$Lisp concat ["1: ",stringify first le," : ",string(nargs)$S]
      s : S := concat ["{",sop]
      if nargs > 0  then
        for a in args repeat
--	  sayTeX$Lisp concat ["2: ",stringify a]
	  s1 : S := exprex a
	  s := concat [s,s1]
      s := concat [s,"}"]

@
\subsection{Private Function Definitions}

\subsubsection{Display Functions}

    displayElt(mathml:S):Void

    eltName(pos:I,mathml:S):S

    eltLimit(name:S,pos:I,mathml:S):I

    tagEnd(name:S,pos:I,mathml:S):I

<<display functions>>=

    displayElt(mathML:S): Void ==
      -- Takes a string of syntactically complete mathML
      -- and formats it for display.
--      sayTeX$Lisp "****displayElt1****"
--      sayTeX$Lisp mathML
      enT:I -- marks end of tag, e.g. "<name>"
      enE:I -- marks end of element, e.g. "<name> ... </name>"
      end:I -- marks end of mathML string
      u:US
      end := #mathML
      length:I := 60
--      sayTeX$Lisp "****displayElt1.1****"
      name:S := eltName(1,mathML)
--      sayTeX$Lisp name
--      sayTeX$Lisp concat("****displayElt1.2****",name)
      enE := eltLimit(name,2+#name,mathML)
--      sayTeX$Lisp "****displayElt2****"
      if enE < length then
--        sayTeX$Lisp "****displayElt3****"
        u := segment(1,enE)$US
	sayTeX$Lisp mathML.u
      else
--        sayTeX$Lisp "****displayElt4****"
        enT := tagEnd(name,1,mathML)
	u := segment(1,enT)$US
	sayTeX$Lisp mathML.u
	u := segment(enT+1,enE-#name-3)$US
	displayElt(mathML.u)
	u := segment(enE-#name-2,enE)$US
	sayTeX$Lisp mathML.u
      if end > enE then
--        sayTeX$Lisp "****displayElt5****"
        u := segment(enE+1,end)$US
        displayElt(mathML.u)

      void()$Void

    eltName(pos:I,mathML:S): S ==
      -- Assuming pos is the position of "<" for a start tag of a mathML
      -- element finds and returns the element's name.
      i:I := pos+1
      --sayTeX$Lisp "eltName:mathmML string: "mathML
      while member?(mathML.i,lowerCase()$CharacterClass)$CharacterClass repeat
         i := i+1
      u:US := segment(pos+1,i-1)
      name:S := mathML.u

    eltLimit(name:S,pos:I,mathML:S): I ==
      -- Finds the end of a mathML element like "<name ...> ... </name>"
      -- where pos is the position of the space after name in the start tag
      -- although it could point to the closing ">".  Returns the position
      -- of the ">" in the end tag.
      pI:I := pos
      startI:I
      endI:I
      startS:S := concat ["<",name]
      endS:S := concat ["</",name,">"]
      level:I := 1
      --sayTeX$Lisp "eltLimit: element name: "name
      while (level > 0) repeat
        startI := position(startS,mathML,pI)$String

	endI := position(endS,mathML,pI)$String

	if (startI = 0) then
	  level := level-1
          --sayTeX$Lisp "****eltLimit 1******"
	  pI := tagEnd(name,endI,mathML)
	else
	  if (startI < endI) then
	    level := level+1
	    pI := tagEnd(name,startI,mathML)
	  else
	    level := level-1
	    pI := tagEnd(name,endI,mathML)
      pI


    tagEnd(name:S,pos:I,mathML:S):I ==
      -- Finds the closing ">" for either a start or end tag of a mathML
      -- element, so the return value is the position of ">" in mathML.
      pI:I := pos
      while  (mathML.pI ^= char ">") repeat
        pI := pI+1
      u:US := segment(pos,pI)$US
      --sayTeX$Lisp "tagEnd: "mathML.u
      pI

@
\subsubsection{Formatting Functions}

Still need to format \verb+\zag+ in formatSpecial!

In formatPlex the case op = "INTSIGN" is now passed off to
formatIntSign which is a change from the TexFormat domain.
This is done here for presentation mark up to replace the
ugly bound variable that Axiom delivers.  For content mark up
this has to be done anyway.  

The formatPlex function also allows for op = "INDEFINTEGRAL".
However I don't know what Axiom command gives rise to this case.
The INTSIGN case already allows for both definite and indefinite
integrals.

In the function formatSpecial various cases are handled including
SUB and SUPERSUB.  These cases are now caught in formatMml and so
the code in formatSpecial doesn't get executed.  The only cases
I know of using these are partial derivatives for SUB and ordinary
derivatives or SUPERSUB however in TexFormat the capability is there
to handle multiscripts, i.e. an object with subscripts, superscripts,
pre-subscripts and pre-superscripts but I am so far unaware of any
Axiom command that produces such a multiscripted object.

Another question is how to represent derivatives.  At present I have
differential notation for partials and prime notation for ordinary 
derivatives, 
but it would be nice to allow for different derivative notations in 
different circumstances, maybe some options to )set output mathml on.

Ordinary derivatives are formatted in formatSuperSub and there are
2 versions, formatSuperSub and formatSuperSub1, which at this point
have to be switched by swapping names.

<<formatting functions>>=

    atomize(expr : E): L E ==
      -- This breaks down an expression into a flat list of atomic expressions.
      -- expr should be preconditioned.
      le : L E := nil()
      a : E
      letmp : L E
      (ATOM(expr)$Lisp@Boolean) or (stringify expr = "NOTHING") => 
        le := append(le,list(expr))
      letmp := expr pretend L E
      for a in letmp repeat
        le := append(le,atomize a)
      le
      	

    ungroup(str: S): S ==
      len : I := #str
      len < 14 => str
      lrow : S :=  "<mrow>"
      rrow : S :=  "</mrow>"
      -- drop leading and trailing mrows
      u1 : US := segment(1,6)$US
      u2 : US := segment(len-6,len)$US
      if (str.u1 =$S lrow) and (str.u2 =$S rrow) then
        u : US := segment(7,len-7)$US
        str := str.u
      str

    postcondition(str: S): S ==
--      str := ungroup str
      len : I := #str
      plusminus : S := "<mo>+</mo><mo>-</mo>"
      pos : I := position(plusminus,str,1)
      if pos > 0 then
        ustart:US := segment(1,pos-1)$US
	uend:US := segment(pos+20,len)$US
        str := concat [str.ustart,"<mo>-</mo>",str.uend]
	if pos < len-18 then
	  str := postcondition(str)
      str

    stringify expr == (mathObject2String$Lisp expr)@S

    group str ==
      concat ["<mrow>",str,"</mrow>"]

    addBraces str ==
      concat ["<mo>{</mo>",str,"<mo>}</mo>"]

    addBrackets str ==
      concat ["<mo>[</mo>",str,"<mo>]</mo>"]

    parenthesize str ==
      concat ["<mo>(</mo>",str,"<mo>)</mo>"]

    precondition expr ==
      outputTran$Lisp expr

    formatSpecial(op : S, args : L E, prec : I) : S ==
      arg : E
      prescript : Boolean := false
      op = "theMap" => "<mtext>theMap(...)</mtext>"
      op = "AGGLST" =>
        formatNary(",",args,prec)
      op = "AGGSET" =>
        formatNary(";",args,prec)
      op = "TAG" =>
        group concat [formatMml(first args,prec),
                      "<mo>&#x02192;</mo>",
                        formatMml(second args,prec)]
			 --RightArrow
      op = "VCONCAT" =>
        group concat("<mtable><mtr>",
                     concat(concat([concat("<mtd>",concat(formatMml(u, minPrec),"</mtd>"))
                                    for u in args]::L S),
                            "</mtr></mtable>"))
      op = "CONCATB" =>
        formatNary(" ",args,prec)
      op = "CONCAT" =>
        formatNary("",args,minPrec)
      op = "QUOTE" =>
        group concat("<mo>'</mo>",formatMml(first args, minPrec))
      op = "BRACKET" =>
        group addBrackets ungroup formatMml(first args, minPrec)
      op = "BRACE" =>
        group addBraces ungroup formatMml(first args, minPrec)
      op = "PAREN" =>
        group parenthesize ungroup formatMml(first args, minPrec)
      op = "OVERBAR" =>
        null args => ""
        group concat ["<mover accent='true'><mrow>",formatMml(first args,minPrec),"</mrow><mo stretchy='true'>&#x000AF;</mo></mover>"]
	 --OverBar
      op = "ROOT" =>
        null args => ""
        tmp : S := group formatMml(first args, minPrec)
        null rest args => concat ["<msqrt>",tmp,"</msqrt>"]
        group concat
	  ["<mroot><mrow>",tmp,"</mrow>",formatMml(first rest args, minPrec),"</mroot>"]
      op = "SEGMENT" =>
        tmp : S := concat [formatMml(first args, minPrec),"<mo>..</mo>"]
        group
          null rest args =>  tmp
          concat [tmp,formatMml(first rest args, minPrec)]
      -- SUB should now be diverted in formatMml although I'll leave
      -- the code here for now.
      op = "SUB" =>
        group concat ["<msub>",formatMml(first args, minPrec),
          formatSpecial("AGGLST",rest args,minPrec),"</msub>"]
      -- SUPERSUB should now be diverted in formatMml although I'll leave
      -- the code here for now.
      op = "SUPERSUB" =>
        base:S := formatMml(first args, minPrec)
	args := rest args
	if #args = 1 then
	  "<msub><mrow>"base"</mrow><mrow>"formatMml(first args, minPrec)"</mrow></msub>"
	else if #args = 2 then
	-- it would be nice to substitue &#x2032; for , in the case of
	-- an ordinary derivative, it looks a lot better.
	  "<msubsup><mrow>"base"</mrow><mrow>"formatMml(first args,minPrec)"</mrow><mrow>"formatMml(first rest args, minPrec)"</mrow></msubsup>"
	else if #args = 3 then
	  "<mmultiscripts><mrow>"base"</mrow><mrow>"formatMml(first args,minPrec)"</mrow><mrow>"formatMml(first rest args,minPrec)"</mrow><mprescripts/><mrow>"formatMml(first rest rest args,minPrec)"</mrow><none/></mmultiscripts>"
	else if #args = 4 then
	  "<mmultiscripts><mrow>"base"</mrow><mrow>"formatMml(first args,minPrec)"</mrow><mrow>"formatMml(first rest args,minPrec)"</mrow><mprescripts/><mrow>"formatMml(first rest rest args,minPrec)"</mrow><mrow>"formatMml(first rest rest rest args,minPrec)"</mrow></mmultiscripts>"
	else
	  "<mtext>Problem with multiscript object</mtext>"
      op = "SC" =>
        -- need to handle indentation someday
        null args => ""
        tmp := formatNaryNoGroup("</mtd></mtr><mtr><mtd>", args, minPrec)
        group concat ["<mtable><mtr><mtd>",tmp,"</mtd></mtr></mtable>"]
      op = "MATRIX" => formatMatrix rest args
      op = "ZAG" =>
-- {{+}{3}{{ZAG}{1}{7}}{{ZAG}{1}{15}}{{ZAG}{1}{1}}{{ZAG}{1}{25}}{{ZAG}{1}{1}}{{ZAG}{1}{7}}{{ZAG}{1}{4}}}
-- to format continued fraction traditionally need to intercept it at the
-- formatNary of the "+"
        concat [" \zag{",formatMml(first args, minPrec),"}{",
          formatMml(first rest args,minPrec),"}"]
      concat ["<mtext>not done yet for: ",op,"</mtext>"]

    formatSub(expr : E, args : L E, opPrec : I) : S ==
      -- This one produces differential notation partial derivatives.
      -- It doesn't work in all cases and may not be workable, use
      -- formatSub1 below for now.
      -- At this time this is only to handle partial derivatives.
      -- If the SUB case handles anything else I'm not aware of it.
      -- This an example of the 4th partial of y(x,z) w.r.t. x,x,z,x
      -- {{{SUB}{y}{{CONCAT}{{CONCAT}{{CONCAT}{{CONCAT}{,}{1}}{{CONCAT}{,}{1}}}{{CONCAT}{,}{2}}}{{CONCAT}{,}{1}}}}{x}{z}}
      atomE : L E := atomize(expr)      
      op : S := stringify first atomE
      op ^= "SUB" => "<mtext>Mistake in formatSub: no SUB</mtext>"
      stringify first rest rest atomE ^= "CONCAT" => "<mtext>Mistake in formatSub: no CONCAT</mtext>"
      -- expecting form for atomE like
      --[{SUB}{func}{CONCAT}...{CONCAT}{,}{n}{CONCAT}{,}{n}...{CONCAT}{,}{n}],
      --counting the first CONCATs before the comma gives the number of
      --derivatives
      ndiffs : I := 0
      tmpLE : L E := rest rest atomE
      while stringify first tmpLE = "CONCAT" repeat
        ndiffs := ndiffs+1
	tmpLE := rest tmpLE
      numLS : L S := nil
      i : I := 1
      while i < ndiffs repeat
        numLS := append(numLS,list(stringify first rest tmpLE))
	tmpLE := rest rest rest tmpLE
	i := i+1
      numLS := append(numLS,list(stringify first rest tmpLE))
      -- numLS contains the numbers of the bound variables as strings
      -- for the differentiations, thus for the differentiation [x,x,z,x]
      -- for y(x,z) numLS = ["1","1","2","1"]
      posLS : L S := nil
      i := 0
 --     sayTeX$Lisp "formatSub: nargs = "string(#args)
      while i < #args repeat
        posLS := append(posLS,list(string(i+1)))
	i := i+1
      -- posLS contains the positions of the bound variables in args
      -- as a list of strings, e.g. for the above example ["1","2"]
      tmpS: S := stringify atomE.2
      if ndiffs = 1 then
        s : S := "<mfrac><mo>&#x02202;</mo><mi>"tmpS"</mi><mrow>"
      else        
        s : S := "<mfrac><mrow><msup><mo>&#x02202;</mo><mn>"string(ndiffs)"</mn></msup><mi>"tmpS"</mi></mrow><mrow>"
      -- need to find the order of the differentiation w.r.t. the i-th
      -- variable
      i := 1
      j : I
      k : I
      tmpS: S
      while i < #posLS+1 repeat
	j := 0
	k := 1
	while k < #numLS + 1 repeat
	  if numLS.k = string i then j := j + 1
	  k := k+1
        if j > 0 then
	  tmpS := stringify args.i
	  if j = 1 then
	    s := s"<mo>&#x02202;</mo><mi>"tmpS"</mi>"
	  else
	    s := s"<mo>&#x02202;</mo><msup><mi>"tmpS"</mi><mn>"string(j)"</mn></msup>"
        i := i + 1
      s := s"</mrow></mfrac><mo>(</mo>"
      i := 1
      while i < #posLS+1 repeat
        tmpS := stringify args.i
	s := s"<mi>"tmpS"</mi>"
	if i < #posLS then s := s"<mo>,</mo>"
	i := i+1
      s := s"<mo>)</mo>"

    formatSub1(expr : E, args : L E, opPrec : I) : S ==
      -- This one produces partial derivatives notated by ",n" as
      -- subscripts.
      -- At this time this is only to handle partial derivatives.
      -- If the SUB case handles anything else I'm not aware of it.
      -- This an example of the 4th partial of y(x,z) w.r.t. x,x,z,x
      -- {{{SUB}{y}{{CONCAT}{{CONCAT}{{CONCAT}{{CONCAT}{,}{1}}
      -- {{CONCAT}{,}{1}}}{{CONCAT}{,}{2}}}{{CONCAT}{,}{1}}}}{x}{z}},
      -- here expr is everything in the first set of braces and 
      -- args is {{x}{z}}
      atomE : L E := atomize(expr)      
      op : S := stringify first atomE
      op ^= "SUB" => "<mtext>Mistake in formatSub: no SUB</mtext>"
      stringify first rest rest atomE ^= "CONCAT" => "<mtext>Mistake in formatSub: no CONCAT</mtext>"
      -- expecting form for atomE like
      --[{SUB}{func}{CONCAT}...{CONCAT}{,}{n}{CONCAT}{,}{n}...{CONCAT}{,}{n}],
      --counting the first CONCATs before the comma gives the number of
      --derivatives
      ndiffs : I := 0
      tmpLE : L E := rest rest atomE
      while stringify first tmpLE = "CONCAT" repeat
        ndiffs := ndiffs+1
	tmpLE := rest tmpLE
      numLS : L S := nil
      i : I := 1
      while i < ndiffs repeat
        numLS := append(numLS,list(stringify first rest tmpLE))
	tmpLE := rest rest rest tmpLE
	i := i+1
      numLS := append(numLS,list(stringify first rest tmpLE))
      -- numLS contains the numbers of the bound variables as strings
      -- for the differentiations, thus for the differentiation [x,x,z,x]
      -- for y(x,z) numLS = ["1","1","2","1"]
      posLS : L S := nil
      i := 0
 --     sayTeX$Lisp "formatSub: nargs = "string(#args)
      while i < #args repeat
        posLS := append(posLS,list(string(i+1)))
	i := i+1
      -- posLS contains the positions of the bound variables in args
      -- as a list of strings, e.g. for the above example ["1","2"]
      funcS: S := stringify atomE.2
      s : S := "<msub><mi>"funcS"</mi><mrow>"
      i := 1
      while i < #numLS+1 repeat
        s := s"<mo>,</mo><mn>"numLS.i"</mn>"
	i := i + 1
      s := s"</mrow></msub><mo>(</mo>"
      i := 1
      while i < #posLS+1 repeat
--        tmpS := stringify args.i
	tmpS := formatMml(first args,minPrec)
	args := rest args
	s := s"<mi>"tmpS"</mi>"
	if i < #posLS then s := s"<mo>,</mo>"
	i := i+1
      s := s"<mo>)</mo>"

    formatSuperSub(expr : E, args : L E, opPrec : I) : S ==
      -- this produces prime notation ordinary derivatives.
      -- first have to divine the semantics, add cases as needed
--      WriteLine$Lisp "SuperSub1 begin"
      atomE : L E := atomize(expr)      
      op : S := stringify first atomE
--      WriteLine$Lisp "op: "op
      op ^= "SUPERSUB" => _
          "<mtext>Mistake in formatSuperSub: no SUPERSUB1</mtext>"
      #args ^= 1 => "<mtext>Mistake in SuperSub1: #args <> 1</mtext>"
      var : E := first args
      -- should be looking at something like {{SUPERSUB}{var}{ }{,,...,}} for
      -- example here's the second derivative of y w.r.t. x
      -- {{{SUPERSUB}{y}{ }{,,}}{x}}, expr is the first {} and args is the
      -- {x}
      funcS : S := stringify first rest atomE
--      WriteLine$Lisp "funcS: "funcS
      bvarS : S := stringify first args
--      WriteLine$Lisp "bvarS: "bvarS
      -- count the number of commas
      commaS : S := stringify first rest rest rest atomE
      commaTest : S := ","
      i : I := 0
      while position(commaTest,commaS,1) > 0 repeat
        i := i+1
	commaTest := commaTest","
      s : S := "<msup><mi>"funcS"</mi><mrow>"
--      WriteLine$Lisp "s: "s
      j : I := 0
      while j < i repeat
        s := s"<mo>&#x02032;</mo>"
	j := j + 1
      s := s"</mrow></msup><mo>&#x02061;</mo><mo>(</mo>"formatMml(first args,minPrec)"<mo>)</mo>"

    formatSuperSub1(expr : E, args : L E, opPrec : I) : S ==
      -- This one produces ordinary derivatives with differential notation,
      -- it needs a little more work yet.
      -- first have to divine the semantics, add cases as needed
--      WriteLine$Lisp "SuperSub begin"
      atomE : L E := atomize(expr)      
      op : S := stringify first atomE
      op ^= "SUPERSUB" => _
         "<mtext>Mistake in formatSuperSub: no SUPERSUB</mtext>"
      #args ^= 1 => "<mtext>Mistake in SuperSub: #args <> 1</mtext>"
      var : E := first args
      -- should be looking at something like {{SUPERSUB}{var}{ }{,,...,}} for
      -- example here's the second derivative of y w.r.t. x
      -- {{{SUPERSUB}{y}{ }{,,}}{x}}, expr is the first {} and args is the
      -- {x}
      funcS : S := stringify first rest atomE
      bvarS : S := stringify first args
      -- count the number of commas
      commaS : S := stringify first rest rest rest atomE
      commaTest : S := ","
      ndiffs : I := 0
      while position(commaTest,commaS,1) > 0 repeat
        ndiffs := ndiffs+1
	commaTest := commaTest","
      s : S := "<mfrac><mrow><msup><mo>&#x02146;</mo><mn>"string(ndiffs)"</mn></msup><mi>"funcS"</mi></mrow><mrow><mo>&#x02146;</mo><msup><mi>"formatMml(first args,minPrec)"</mi><mn>"string(ndiffs)"</mn></msup></mrow></mfrac><mo>&#x02061;</mo><mo>(</mo><mi>"formatMml(first args,minPrec)"</mi><mo>)</mo>"

    formatPlex(op : S, args : L E, prec : I) : S ==
      checkarg:Boolean := false
      hold : S
      p : I := position(op,plexOps)
      p < 1 => error "unknown plex op"
      op = "INTSIGN" => formatIntSign(args,minPrec)
      opPrec := plexPrecs.p
      n : I := #args
      (n ^= 2) and (n ^= 3) => error "wrong number of arguments for plex"
      s : S :=
        op = "SIGMA"   => 
         checkarg := true
         "<mo>&#x02211;</mo>"
	-- Sum
        op = "SIGMA2"   => 
         checkarg := true
         "<mo>&#x02211;</mo>"
	-- Sum
        op = "PI"      => 
         checkarg := true
         "<mo>&#x0220F;</mo>"
	-- Product
        op = "PI2"     => 
         checkarg := true
         "<mo>&#x0220F;</mo>"
	-- Product
--        op = "INTSIGN" => "<mo>&#x0222B;</mo>"
	-- Integral, int
        op = "INDEFINTEGRAL" => "<mo>&#x0222B;</mo>"
	-- Integral, int
        "????"
      hold := formatMml(first args,minPrec)
      args := rest args
      if op ^= "INDEFINTEGRAL" then
        if hold ^= "" then
          s := concat ["<munderover>",s,group hold]
	else
	  s := concat ["<munderover>",s,group " "]
        if not null rest args then
          hold := formatMml(first args,minPrec)
	  if hold ^= "" then
            s := concat [s,group hold,"</munderover>"]
	  else
	    s := concat [s,group " ","</munderover>"]
          args := rest args
	-- if checkarg true need to test op arg for "+" at least
	-- and wrap parentheses if so
	if checkarg then
          la : L E := (first args pretend L E)
          opa : S := stringify first la
	  if opa = "+" then
            s := concat [s,"<mo>(</mo>",formatMml(first args,minPrec),"<mo>)</mo>"]
          else s := concat [s,formatMml(first args,minPrec)]
        else s := concat [s,formatMml(first args,minPrec)]
      else
        hold := group concat [hold,formatMml(first args,minPrec)]
        s := concat [s,hold]
--      if opPrec < prec then s := parenthesize s
-- getting ugly parentheses on fractions
      group s

    formatIntSign(args : L E, opPrec : I) : S ==
      -- the original OutputForm expression looks something like this:
      -- {{INTSIGN}{NOTHING or lower limit?}
      -- {bvar or upper limit?}{{*}{integrand}{{CONCAT}{d}{axiom var}}}}
      -- the args list passed here consists of the rest of this list, i.e.
      -- starting at the NOTHING or ...
      (stringify first args) = "NOTHING" =>
        -- the bound variable is the second one in the argument list
	bvar : E := first rest args
	bvarS : S := stringify bvar
	tmpS : S
	i : I := 0
	u1 : US
	u2 : US
	-- this next one atomizes the integrand plus differential
	atomE : L E := atomize(first rest rest args)
	-- pick out the bound variable used by axiom
	varRS : S := stringify last(atomE)
	tmpLE : L E := ((first rest rest args) pretend L E)
        integrand : S := formatMml(first rest tmpLE,minPrec)
	-- replace the bound variable, i.e. axiom uses someting of the form
	-- %A for the bound variable and puts the original variable used
	-- in the input command as a superscript on the integral sign.
	-- I'm assuming that the axiom variable is 2 characters.
	while (i := position(varRS,integrand,i+1)) > 0 repeat
	  u1 := segment(1,i-1)$US
	  u2 := segment(i+2,#integrand)$US
	  integrand := concat [integrand.u1,bvarS,integrand.u2]
	concat ["<mrow><mo>&#x0222B;</mo>" integrand "<mo>&#x02146;</mo><mi>" bvarS "</mi></mrow>"]

      lowlim : S := stringify first args
      highlim : S := stringify first rest args
      bvar : E := last atomize(first rest rest args)
      bvarS : S := stringify bvar
      tmpLE : L E := ((first rest rest args) pretend L E)
      integrand : S := formatMml(first rest tmpLE,minPrec)
      concat ["<mrow><munderover><mo>&#x0222B;</mo><mi>" lowlim "</mi><mi>" highlim "</mi></munderover>" integrand "<mo>&#x02146;</mo><mi>" bvarS "</mi></mrow>"] 


    formatMatrix(args : L E) : S ==
      -- format for args is [[ROW ...],[ROW ...],[ROW ...]]
      -- generate string for formatting columns (centered)
      group addBrackets concat
        ["<mtable><mtr><mtd>",formatNaryNoGroup("</mtd></mtr><mtr><mtd>",args,minPrec),
          "</mtd></mtr></mtable>"]

    formatFunction(op : S, args : L E, prec : I) : S ==
      group concat ["<mo>",op,"</mo>",parenthesize formatNary(",",args,minPrec)]

    formatNullary(op : S) ==
      op = "NOTHING" => ""
      group concat ["<mo>",op,"</mo><mo>(</mo><mo>)</mo>"]

    formatUnary(op : S, arg : E, prec : I) ==
      p : I := position(op,unaryOps)
      p < 1 => error "unknown unary op"
      opPrec := unaryPrecs.p
      s : S := concat ["<mo>",op,"</mo>",formatMml(arg,opPrec)]
      opPrec < prec => group parenthesize s
      op = "-" => s
      group s

    formatBinary(op : S, args : L E, prec : I) : S ==
      p : I := position(op,binaryOps)
      p < 1 => error "unknown binary op"
      opPrec := binaryPrecs.p
      -- if base op is product or sum need to add parentheses
      if ATOM(first args)$Lisp@Boolean then
        opa:S := stringify first args
      else
        la : L E := (first args pretend L E)
        opa : S := stringify first la
      if (opa = "SIGMA" or opa = "SIGMA2" or opa = "PI" or opa = "PI2") _
         and op = "**" then
        s1:S:=concat ["<mo>(</mo>",formatMml(first args, opPrec),"<mo>)</mo>"]
      else
       s1 : S := formatMml(first args, opPrec)
      s2 : S := formatMml(first rest args, opPrec)
      op :=
        op = "|"     =>  s := concat ["<mrow>",s1,"</mrow><mo>",op,"</mo><mrow>",s2,"</mrow>"]
        op = "**"    =>  s := concat ["<msup><mrow>",s1,"</mrow><mrow>",s2,"</mrow></msup>"]
        op = "/"     =>  s := concat ["<mfrac><mrow>",s1,"</mrow><mrow>",s2,"</mrow></mfrac>"]
        op = "OVER"  =>  s := concat ["<mfrac><mrow>",s1,"</mrow><mrow>",s2,"</mrow></mfrac>"]
        op = "+->"   =>  s := concat ["<mrow>",s1,"</mrow><mo>",op,"</mo><mrow>",s2,"</mrow>"]
        s := concat ["<mrow>",s1,"</mrow><mo>",op,"</mo><mrow>",s2,"</mrow>"]
      group
        op = "OVER" => s
--        opPrec < prec => parenthesize s
-- ugly parentheses?
        s

    formatNary(op : S, args : L E, prec : I) : S ==
      group formatNaryNoGroup(op, args, prec)

    formatNaryNoGroup(op : S, args : L E, prec : I) : S ==
      checkargs:Boolean := false
      null args => ""
      p : I := position(op,naryOps)
      p < 1 => error "unknown nary op"
      -- need to test for "ZAG" case and divert it here
      -- ex 1. continuedFraction(314159/100000)
      -- {{+}{3}{{ZAG}{1}{7}}{{ZAG}{1}{15}}{{ZAG}{1}{1}}{{ZAG}{1}{25}}
      -- {{ZAG}{1}{1}}{{ZAG}{1}{7}}{{ZAG}{1}{4}}}
      -- this is the preconditioned output form
      -- including "op", the args list would be the rest of this
      -- i.e op = '+' and args = {{3}{{ZAG}{1}{7}}{{ZAG}{1}{15}}
      -- {{ZAG}{1}{1}}{{ZAG}{1}{25}}{{ZAG}{1}{1}}{{ZAG}{1}{7}}{{ZAG}{1}{4}}}
      -- ex 2. continuedFraction(14159/100000)
      -- this one doesn't have the leading integer
      -- {{+}{{ZAG}{1}{7}}{{ZAG}{1}{15}}{{ZAG}{1}{1}}{{ZAG}{1}{25}}
      -- {{ZAG}{1}{1}}{{ZAG}{1}{7}}{{ZAG}{1}{4}}}
      --
      -- ex 3. continuedFraction(3,repeating [1], repeating [3,6])
      -- {{+}{3}{{ZAG}{1}{3}}{{ZAG}{1}{6}}{{ZAG}{1}{3}}{{ZAG}{1}{6}}
      -- {{ZAG}{1}{3}}{{ZAG}{1}{6}}{{ZAG}{1}{3}}{{ZAG}{1}{6}}
      -- {{ZAG}{1}{3}}{{ZAG}{1}{6}}{...}}
      -- In each of these examples the args list consists of the terms
      -- following the '+' op
      -- so the first arg could be a "ZAG" or something
      -- else, but the second arg looks like it has to be "ZAG", so maybe
      -- test for #args > 1 and args.2 contains "ZAG".
      -- Note that since the resulting MathML <mfrac>s are nested we need
      -- to handle the whole continued fraction at once, i.e. we can't
      -- just look for, e.g., {{ZAG}{1}{6}}
      (#args > 1) and (position("ZAG",stringify first rest args,1) > 0) =>
	   tmpS : S := stringify first args
	   position("ZAG",tmpS,1) > 0 => formatZag(args)
--	   position("ZAG",tmpS,1) > 0 => formatZag1(args)
	   concat [formatMml(first args,minPrec) "<mo>+</mo>" formatZag(rest args)]
      -- At least for the ops "*","+","-" we need to test to see if a sigma
      -- or pi is one of their arguments because we might need parentheses
      -- as indicated by the problem with 
      -- summation(operator(f)(i),i=1..n)+1 versus
      -- summation(operator(f)(i)+1,i=1..n) having identical displays as 
      -- of 2007-21-21
      op :=
        op = ","     => "<mo>,</mo>" --originally , \:
        op = ";"     => "<mo>;</mo>" --originally ; \: should figure these out
        op = "*"     => "<mspace width='0.3em'/>"
	-- InvisibleTimes
        op = " "     => "<mspace width='0.5em'/>"
        op = "ROW"   => "</mtd><mtd>"
	op = "+"     => 
            checkargs := true
            "<mo>+</mo>"
	op = "-"     => 
            checkargs := true
            "<mo>-</mo>"
        op
      l : L S := nil
      opPrec := naryPrecs.p
      -- if checkargs is true check each arg except last one to see if it's
      -- a sigma or pi and if so add parentheses. Other op's may have to be
      -- checked for in future
      count:I := 1
      for a in args repeat
--        WriteLine$Lisp "checking args"
        if checkargs then
	  if count < #args then
	    -- check here for sum or product
	    if ATOM(a)$Lisp@Boolean then
	      opa:S := stringify a
	    else
	      la : L E := (a pretend L E)
	      opa : S := stringify first la
	    if opa = "SIGMA" or opa = "SIGMA2" or _
               opa = "PI" or opa = "PI2" then
	      l := concat(op,concat(_
                    concat ["<mo>(</mo>",formatMml(a,opPrec),_
                            "<mo>)</mo>"],l)$L(S))$L(S)
	    else l := concat(op,concat(formatMml(a,opPrec),l)$L(S))$L(S)
	  else l := concat(op,concat(formatMml(a,opPrec),l)$L(S))$L(S)
	else l := concat(op,concat(formatMml(a,opPrec),l)$L(S))$L(S)
	count := count + 1
      s : S := concat reverse rest l
      opPrec < prec => parenthesize s
      s

    formatZag(args : L E) : S ==
    -- args will be a list of things like this {{ZAG}{1}{7}}, the ZAG
    -- must be there, the '1' and '7' could conceivably be more complex
    -- expressions
      tmpZag : L E := first args pretend L E
      -- may want to test that tmpZag contains 'ZAG'
      #args > 1 => "<mfrac>"formatMml(first rest tmpZag,minPrec)"<mrow><mn>"formatMml(first rest rest tmpZag,minPrec)"</mn><mo>+</mo>"formatZag(rest args)"</mrow></mfrac>"
      -- EQUAL(tmpZag, "...")$Lisp => "<mo>&#x2026;</mo>"
      (first args = "..."::E)@Boolean => "<mo>&#x2026;</mo>"
      position("ZAG",stringify first args,1) > 0 =>
          "<mfrac>"formatMml(first rest tmpZag,minPrec)formatMml(first rest rest tmpZag,minPrec)"</mfrac>"      
      "<mtext>formatZag: Unexpected kind of ZAG</mtext>"

      
    formatZag1(args : L E) : S ==
    -- make alternative ZAG format without diminishing fonts, maybe
    -- use a table
    -- {{ZAG}{1}{7}}
      tmpZag : L E := first args pretend L E
      #args > 1 => "<mfrac>"formatMml(first rest tmpZag,minPrec)"<mrow><mn>"formatMml(first rest rest tmpZag,minPrec)"</mn><mo>+</mo>"formatZag(rest args)"</mrow></mfrac>"
      (first args = "...":: E)@Boolean => "<mo>&#x2026;</mo>"
      error "formatZag1: Unexpected kind of ZAG"


    formatMml(expr : E,prec : I) ==
      i,len : Integer
      intSplitLen : Integer := 20
      ATOM(expr)$Lisp@Boolean =>
        str := stringify expr
        len := #str
	-- this bit seems to deal with integers
        FIXP$Lisp expr =>
          i := expr pretend Integer
          if (i < 0) or (i > 9)
            then
              group
                 nstr : String := ""
                 -- insert some blanks into the string, if too long
                 while ((len := #str) > intSplitLen) repeat
                   nstr := concat [nstr," ",
                     elt(str,segment(1,intSplitLen)$US)]
                   str := elt(str,segment(intSplitLen+1)$US)
                 empty? nstr => concat ["<mn>",str,"</mn>"]
                 nstr :=
                   empty? str => nstr
                   concat [nstr," ",str]
                 concat ["<mn>",elt(nstr,segment(2)$US),"</mn>"]
            else str := concat ["<mn>",str,"</mn>"]
        str = "%pi" => "<mi>&#x003C0;</mi>"
	-- pi
        str = "%e"  => "<mi>&#x02147;</mi>"
	-- ExponentialE
        str = "%i"  => "<mi>&#x02148;</mi>"
	-- ImaginaryI
        len > 0 and str.1 = char "%" => concat(concat("<mi>",str),"</mi>")
        len > 1 and digit? str.1 => concat ["<mn>",str,"</mn>"] -- should handle floats
	-- presumably this is a literal string
        len > 0 and str.1 = char "_"" =>
          concat(concat("<mtext>",str),"</mtext>")
        len = 1 and str.1 = char " " => " "
        (i := position(str,specialStrings)) > 0 =>
          specialStringsInMML.i
        (i := position(char " ",str)) > 0 =>
          -- We want to preserve spacing, so use a roman font.
	  -- What's this for?  Leave the \rm in for now so I can see
	  -- where it arises.  Removed 2007-02-14
          concat(concat("<mtext>",str),"</mtext>")
	-- if we get to here does that mean it's a variable?
        concat ["<mi>",str,"</mi>"]
      l : L E := (expr pretend L E)
      null l => blank
      op : S := stringify first l
      args : L E := rest l
      nargs : I := #args
      -- need to test here in case first l is SUPERSUB case and then
      -- pass first l and args to formatSuperSub.
      position("SUPERSUB",op,1) > 0 =>
        formatSuperSub(first l,args,minPrec)
      -- now test for SUB
      position("SUB",op,1) > 0 =>
        formatSub1(first l,args,minPrec)

      -- special cases
      member?(op, specialOps) => formatSpecial(op,args,prec)
      member?(op, plexOps)    => formatPlex(op,args,prec)

      -- nullary case
      0 = nargs => formatNullary op

      -- unary case
      (1 = nargs) and member?(op, unaryOps) =>
        formatUnary(op, first args, prec)

      -- binary case
      (2 = nargs) and member?(op, binaryOps) =>
        formatBinary(op, args, prec)

      -- nary case
      member?(op,naryNGOps) => formatNaryNoGroup(op,args, prec)
      member?(op,naryOps) => formatNary(op,args, prec)

      op := formatMml(first l,minPrec)
      formatFunction(op,args,prec)

@
\subsection{Mathematical Markup Language Form}
\pagehead{MathMLForm}{MMLFORM}
\pagepic{ps/v104mathmlform.ps}{MMLFORM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MMLFORM MathMLForm>>=
<<public declarations>>
<<private constant declarations>>
<<private function declarations>>
<<public function definitions>>
<<display functions>>
<<formatting functions>>

@
<<MMLFORM.dotabb>>=
"MMLFORM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MMLFORM"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"MMLFORM" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MATCAT2 MatrixCategoryFunctions2}
\pagehead{MatrixCategoryFunctions2}{MATCAT2}
\pagepic{ps/v104MatrixCategoryFunctions2.ps}{MATCAT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MATCAT2 MatrixCategoryFunctions2>>=
)abbrev package MATCAT2 MatrixCategoryFunctions2
++ Author: Clifton J. Williamson
++ Date Created: 21 November 1989
++ Date Last Updated: 21 March 1994
++ Basic Operations:
++ Related Domains: IndexedMatrix(R,minRow,minCol), Matrix(R),
++    RectangularMatrix(n,m,R), SquareMatrix(n,R)
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Keywords: matrix, map, reduce
++ Examples:
++ References:
++ Description:
++   \spadtype{MatrixCategoryFunctions2} provides functions between two matrix
++   domains.  The functions provided are \spadfun{map} and \spadfun{reduce}.
MatrixCategoryFunctions2(R1,Row1,Col1,M1,R2,Row2,Col2,M2):_
         Exports == Implementation where
  R1   : Ring
  Row1 : FiniteLinearAggregate R1
  Col1 : FiniteLinearAggregate R1
  M1   : MatrixCategory(R1,Row1,Col1)
  R2   : Ring
  Row2 : FiniteLinearAggregate R2
  Col2 : FiniteLinearAggregate R2
  M2   : MatrixCategory(R2,Row2,Col2)

  Exports ==> with
    map: (R1 -> R2,M1) -> M2
     ++ \spad{map(f,m)} applies the function f to the elements of the matrix m.
    map: (R1 -> Union(R2,"failed"),M1) -> Union(M2,"failed")
     ++ \spad{map(f,m)} applies the function f to the elements of the matrix m.
    reduce: ((R1,R2) -> R2,M1,R2) -> R2
     ++ \spad{reduce(f,m,r)} returns a matrix n where
     ++ \spad{n[i,j] = f(m[i,j],r)} for all indices i and j.

  Implementation ==> add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex

    map(f:(R1->R2),m:M1):M2 ==
      ans : M2 := new(nrows m,ncols m,0)
      for i in minr(m)..maxr(m) for k in minr(ans)..maxr(ans) repeat
        for j in minc(m)..maxc(m) for l in minc(ans)..maxc(ans) repeat
          qsetelt_!(ans,k,l,f qelt(m,i,j))
      ans

    map(f:(R1 -> (Union(R2,"failed"))),m:M1):Union(M2,"failed") ==
      ans : M2 := new(nrows m,ncols m,0)
      for i in minr(m)..maxr(m) for k in minr(ans)..maxr(ans) repeat
        for j in minc(m)..maxc(m) for l in minc(ans)..maxc(ans) repeat
          (r := f qelt(m,i,j)) = "failed" => return "failed"
          qsetelt_!(ans,k,l,r::R2)
      ans

    reduce(f,m,ident) ==
      s := ident
      for i in minr(m)..maxr(m) repeat
       for j in minc(m)..maxc(m) repeat
         s := f(qelt(m,i,j),s)
      s

@
<<MATCAT2.dotabb>>=
"MATCAT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MATCAT2"]
"MATCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MATCAT"]
"MATCAT2" -> "MATCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MCDEN MatrixCommonDenominator}
\pagehead{MatrixCommonDenominator}{MCDEN}
\pagepic{ps/v104matrixcommondenominator.ps}{MCDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MCDEN MatrixCommonDenominator>>=
)abbrev package MCDEN MatrixCommonDenominator
--% MatrixCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 20 Jul 1990
++ Description: MatrixCommonDenominator provides functions to
++ compute the common denominator of a matrix of elements of the
++ quotient field of an integral domain.
++ Keywords: gcd, quotient, matrix, common, denominator.
MatrixCommonDenominator(R, Q): Exports == Implementation where
  R: IntegralDomain
  Q: QuotientFieldCategory R
 
  VR ==> Vector R
  VQ ==> Vector Q
 
  Exports ==> with
    commonDenominator: Matrix Q -> R
      ++ commonDenominator(q) returns a common denominator d for
      ++ the elements of q.
    clearDenominator : Matrix Q -> Matrix R
      ++ clearDenominator(q) returns p such that \spad{q = p/d} where d is
      ++ a common denominator for the elements of q.
    splitDenominator : Matrix Q -> Record(num: Matrix R, den: R)
      ++ splitDenominator(q) returns \spad{[p, d]} such that \spad{q = p/d} and d
      ++ is a common denominator for the elements of q.
 
  Implementation ==> add
    import ListFunctions2(Q, R)
    import MatrixCategoryFunctions2(Q,VQ,VQ,Matrix Q,R,VR,VR,Matrix R)
 
    clearDenominator m ==
      d := commonDenominator m
      map(numer(d * #1), m)
 
    splitDenominator m ==
      d := commonDenominator m
      [map(numer(d * #1), m), d]
 
    if R has GcdDomain then
      commonDenominator m == lcm map(denom, parts m)
    else
      commonDenominator m == reduce("*",map(denom, parts m),1)$List(R)

@
<<MCDEN.dotabb>>=
"MCDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MCDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MCDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MATLIN MatrixLinearAlgebraFunctions}
\pagehead{MatrixLinearAlgebraFunctions}{MATLIN}
\pagepic{ps/v104matrixlinearalgebrafunctions.ps}{MATLIN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MATLIN MatrixLinearAlgebraFunctions>>=
)abbrev package MATLIN MatrixLinearAlgebraFunctions
++ Author: Clifton J. Williamson, P.Gianni
++ Date Created: 13 November 1989
++ Date Last Updated: December 1992
++ Basic Operations:
++ Related Domains: IndexedMatrix(R,minRow,minCol), Matrix(R),
++    RectangularMatrix(n,m,R), SquareMatrix(n,R)
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, canonical forms, linear algebra
++ Examples:
++ References:
++ Description:
++   \spadtype{MatrixLinearAlgebraFunctions} provides functions to compute
++   inverses and canonical forms.
MatrixLinearAlgebraFunctions(R,Row,Col,M):Exports == Implementation where
  R   : CommutativeRing
  Row : FiniteLinearAggregate R
  Col : FiniteLinearAggregate R
  M   : MatrixCategory(R,Row,Col)
  I ==> Integer

  Exports ==> with

    determinant: M -> R
      ++ \spad{determinant(m)} returns the determinant of the matrix m.
      ++ an error message is returned if the matrix is not square.
    minordet: M -> R
      ++ \spad{minordet(m)} computes the determinant of the matrix m using
      ++ minors. Error: if the matrix is not square.
    elRow1!       :   (M,I,I)         ->  M
      ++ elRow1!(m,i,j) swaps rows i and j of matrix m : elementary operation
      ++ of first kind
    elRow2!       :  (M,R,I,I)        ->  M
      ++ elRow2!(m,a,i,j)  adds to row i a*row(m,j) : elementary operation of
      ++ second kind. (i ^=j)
    elColumn2!    :  (M,R,I,I)        ->  M
      ++ elColumn2!(m,a,i,j)  adds to column i a*column(m,j) : elementary
      ++ operation of second kind. (i ^=j)

    if R has IntegralDomain then
      rank: M -> NonNegativeInteger
        ++ \spad{rank(m)} returns the rank of the matrix m.
      nullity: M -> NonNegativeInteger
        ++ \spad{nullity(m)} returns the mullity of the matrix m. This is
        ++ the dimension of the null space of the matrix m.
      nullSpace: M -> List Col
        ++ \spad{nullSpace(m)} returns a basis for the null space of the
        ++ matrix m.
      fractionFreeGauss! : M -> M
        ++ \spad{fractionFreeGauss(m)} performs the fraction
        ++ free gaussian  elimination on the matrix m.
      invertIfCan : M -> Union(M,"failed")
        ++ \spad{invertIfCan(m)} returns the inverse of m over R
      adjoint : M -> Record(adjMat:M, detMat:R)
        ++ \spad{adjoint(m)} returns the ajoint matrix of m (i.e. the matrix
        ++ n such that m*n = determinant(m)*id) and the detrminant of m.

    if R has EuclideanDomain then
      rowEchelon: M -> M
        ++ \spad{rowEchelon(m)} returns the row echelon form of the matrix m.

      normalizedDivide: (R, R) -> Record(quotient:R, remainder:R)
        ++ normalizedDivide(n,d) returns a normalized quotient and
        ++ remainder such that consistently unique representatives
        ++ for the residue class are chosen, e.g. positive remainders

    if R has Field then
      inverse: M -> Union(M,"failed")
        ++ \spad{inverse(m)} returns the inverse of the matrix.
        ++ If the matrix is not invertible, "failed" is returned.
        ++ Error: if the matrix is not square.

  Implementation ==> add

    rowAllZeroes?: (M,I) -> Boolean
    rowAllZeroes?(x,i) ==
      -- determines if the ith row of x consists only of zeroes
      -- internal function: no check on index i
      for j in minColIndex(x)..maxColIndex(x) repeat
        qelt(x,i,j) ^= 0 => return false
      true

    colAllZeroes?: (M,I) -> Boolean
    colAllZeroes?(x,j) ==
      -- determines if the ith column of x consists only of zeroes
      -- internal function: no check on index j
      for i in minRowIndex(x)..maxRowIndex(x) repeat
        qelt(x,i,j) ^= 0 => return false
      true

    minorDet:(M,I,List I,I,PrimitiveArray(Union(R,"uncomputed")))-> R
    minorDet(x,m,l,i,v) ==
      z := v.m
      z case R => z
      ans : R := 0; rl : List I := nil()
      j := first l; l := rest l; pos := true
      minR := minRowIndex x; minC := minColIndex x;
      repeat
        if qelt(x,j + minR,i + minC) ^= 0 then
          ans :=
            md := minorDet(x,m - 2**(j :: NonNegativeInteger),_
                           concat_!(reverse rl,l),i + 1,v) *_
                           qelt(x,j + minR,i + minC)
            pos => ans + md
            ans - md
        null l =>
          v.m := ans
          return ans
        pos := not pos; rl := cons(j,rl); j := first l; l := rest l

    minordet x ==
      (ndim := nrows x) ^= (ncols x) =>
        error "determinant: matrix must be square"
      -- minor expansion with (s---loads of) memory
      n1 : I := ndim - 1
      v : PrimitiveArray(Union(R,"uncomputed")) :=
           new((2**ndim - 1) :: NonNegativeInteger,"uncomputed")
      minR := minRowIndex x; maxC := maxColIndex x
      for i in 0..n1 repeat
        qsetelt_!(v,(2**i - 1),qelt(x,i + minR,maxC))
      minorDet(x, 2**ndim - 2, [i for i in 0..n1], 0, v)

       -- elementary operation of first kind: exchange two rows --
    elRow1!(m:M,i:I,j:I) : M ==
      vec:=row(m,i)
      setRow!(m,i,row(m,j))
      setRow!(m,j,vec)
      m

             -- elementary operation of second kind: add to row i--
                         -- a*row j  (i^=j) --
    elRow2!(m : M,a:R,i:I,j:I) : M ==
      vec:= map(a*#1,row(m,j))
      vec:=map("+",row(m,i),vec)
      setRow!(m,i,vec)
      m
             -- elementary operation of second kind: add to column i --
                           -- a*column j (i^=j) --
    elColumn2!(m : M,a:R,i:I,j:I) : M ==
      vec:= map(a*#1,column(m,j))
      vec:=map("+",column(m,i),vec)
      setColumn!(m,i,vec)
      m

    if R has IntegralDomain then
      -- Fraction-Free Gaussian Elimination
      fractionFreeGauss! x  ==
        (ndim := nrows x) = 1 => x
        ans := b := 1$R
        minR := minRowIndex x; maxR := maxRowIndex x
        minC := minColIndex x; maxC := maxColIndex x
        i := minR
        for j in minC..maxC repeat
          if qelt(x,i,j) = 0 then -- candidate for pivot = 0
            rown := minR - 1
            for k in (i+1)..maxR repeat
              if qelt(x,k,j) ^= 0 then
                 rown := k -- found a pivot
                 leave
            if rown > minR - 1 then
               swapRows_!(x,i,rown)
               ans := -ans
          (c := qelt(x,i,j)) = 0 =>  "next j" -- try next column
          for k in (i+1)..maxR repeat
            if qelt(x,k,j) = 0 then
              for l in (j+1)..maxC repeat
                qsetelt_!(x,k,l,(c * qelt(x,k,l) exquo b) :: R)
            else
              pv := qelt(x,k,j)
              qsetelt_!(x,k,j,0)
              for l in (j+1)..maxC repeat
                val := c * qelt(x,k,l) - pv * qelt(x,i,l)
                qsetelt_!(x,k,l,(val exquo b) :: R)
          b := c
          (i := i+1)>maxR => leave
        if ans=-1 then
          lasti := i-1
          for j in 1..maxC repeat x(lasti, j) := -x(lasti,j)
        x

      --
      lastStep(x:M)  : M ==
        ndim := nrows x
        minR := minRowIndex x; maxR := maxRowIndex x
        minC := minColIndex x; maxC := minC+ndim -1
        exCol:=maxColIndex x
        det:=x(maxR,maxC)
        maxR1:=maxR-1
        maxC1:=maxC+1
        minC1:=minC+1
        iRow:=maxR
        iCol:=maxC-1
        for i in maxR1..1 by -1 repeat
          for j in maxC1..exCol repeat
            ss:=+/[x(i,iCol+k)*x(i+k,j) for k in 1..(maxR-i)]
            x(i,j) := _exquo((det * x(i,j) - ss),x(i,iCol))::R
          iCol:=iCol-1
        subMatrix(x,minR,maxR,maxC1,exCol)

      invertIfCan(y) ==
        (nr:=nrows y) ^= (ncols y) =>
            error "invertIfCan: matrix must be square"
        adjRec := adjoint y
        (den:=recip(adjRec.detMat)) case "failed" => "failed"
        den::R * adjRec.adjMat

      adjoint(y) ==
        (nr:=nrows y) ^= (ncols y) => error "adjoint: matrix must be square"
        maxR := maxRowIndex y
        maxC := maxColIndex y
        x := horizConcat(copy y,scalarMatrix(nr,1$R))
        ffr:= fractionFreeGauss!(x)
        det:=ffr(maxR,maxC)
        [lastStep(ffr),det]


    if R has Field then

      VR      ==> Vector R
      IMATLIN ==> InnerMatrixLinearAlgebraFunctions(R,Row,Col,M)
      MMATLIN ==> InnerMatrixLinearAlgebraFunctions(R,VR,VR,Matrix R)
      FLA2    ==> FiniteLinearAggregateFunctions2(R, VR, R, Col)
      MAT2    ==> MatrixCategoryFunctions2(R,Row,Col,M,R,VR,VR,Matrix R)

      rowEchelon  y == rowEchelon(y)$IMATLIN
      rank        y == rank(y)$IMATLIN
      nullity     y == nullity(y)$IMATLIN
      determinant y == determinant(y)$IMATLIN
      inverse     y == inverse(y)$IMATLIN
      if Col has shallowlyMutable then
        nullSpace y == nullSpace(y)$IMATLIN
      else
        nullSpace y ==
          [map(#1, v)$FLA2 for v in nullSpace(map(#1, y)$MAT2)$MMATLIN]

    else if R has IntegralDomain then
      QF      ==> Fraction R
      Row2    ==> Vector QF
      Col2    ==> Vector QF
      M2      ==> Matrix QF
      IMATQF  ==> InnerMatrixQuotientFieldFunctions(R,Row,Col,M,QF,Row2,Col2,M2)

      nullSpace m == nullSpace(m)$IMATQF

      determinant y ==
        (nrows y) ^= (ncols y) => error "determinant: matrix must be square"
        fm:=fractionFreeGauss!(copy y)
        fm(maxRowIndex fm,maxColIndex fm)

      rank x ==
        y :=
          (rk := nrows x) > (rh := ncols x) =>
              rk := rh
              transpose x
          copy x
        y := fractionFreeGauss! y
        i := maxRowIndex y
        while rk > 0 and rowAllZeroes?(y,i) repeat
          i := i - 1
          rk := (rk - 1) :: NonNegativeInteger
        rk :: NonNegativeInteger

      nullity x == (ncols x - rank x) :: NonNegativeInteger

      if R has EuclideanDomain then

        if R has IntegerNumberSystem then
            normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
               qr := divide(n, d)
               qr.remainder >= 0 => qr
               d > 0 =>
                  qr.remainder := qr.remainder + d
                  qr.quotient := qr.quotient - 1
                  qr
               qr.remainder := qr.remainder - d
               qr.quotient := qr.quotient + 1
               qr
        else
            normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
               divide(n, d)

        rowEchelon y ==
          x := copy y
          minR := minRowIndex x; maxR := maxRowIndex x
          minC := minColIndex x; maxC := maxColIndex x
          n := minR - 1
          i := minR
          for j in minC..maxC repeat
            if i > maxR then leave x
            n := minR - 1
            xnj: R
            for k in i..maxR repeat
              if not zero?(xkj:=qelt(x,k,j)) and ((n = minR - 1) _
                     or sizeLess?(xkj,xnj)) then
                n := k
                xnj := xkj
            n = minR - 1 => "next j"
            swapRows_!(x,i,n)
            for k in (i+1)..maxR repeat
              qelt(x,k,j) = 0 => "next k"
              aa := extendedEuclidean(qelt(x,i,j),qelt(x,k,j))
              (a,b,d) := (aa.coef1,aa.coef2,aa.generator)
              b1 := (qelt(x,i,j) exquo d) :: R
              a1 := (qelt(x,k,j) exquo d) :: R
              -- a*b1+a1*b = 1
              for k1 in (j+1)..maxC repeat
                val1 := a * qelt(x,i,k1) + b * qelt(x,k,k1)
                val2 := -a1 * qelt(x,i,k1) + b1 * qelt(x,k,k1)
                qsetelt_!(x,i,k1,val1); qsetelt_!(x,k,k1,val2)
              qsetelt_!(x,i,j,d); qsetelt_!(x,k,j,0)

            un := unitNormal qelt(x,i,j)
            qsetelt_!(x,i,j,un.canonical)
            if un.associate ^= 1 then for jj in (j+1)..maxC repeat
                qsetelt_!(x,i,jj,un.associate * qelt(x,i,jj))

            xij := qelt(x,i,j)
            for k in minR..(i-1) repeat
              qelt(x,k,j) = 0 => "next k"
              qr := normalizedDivide(qelt(x,k,j), xij)
              qsetelt_!(x,k,j,qr.remainder)
              for k1 in (j+1)..maxC repeat
                qsetelt_!(x,k,k1,qelt(x,k,k1) - qr.quotient * qelt(x,i,k1))
            i := i + 1
          x

    else determinant x == minordet x

@
<<MATLIN.dotabb>>=
"MATLIN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MATLIN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MATLIN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MTHING MergeThing}
\pagehead{MergeThing}{MTHING}
\pagepic{ps/v104mergething.ps}{MTHING}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MTHING MergeThing>>=
)abbrev package MTHING MergeThing
++ This package exports tools for merging lists
MergeThing(S:OrderedSet): Exports == Implementation where
  Exports == with
    mergeDifference: (List(S),List(S)) -> List(S)
	++ mergeDifference(l1,l2) returns a list of elements in l1 not present
	++ in l2. Assumes lists are ordered and all x in l2 are also in l1.
  Implementation == add
    mergeDifference1: (List S,S,List S) -> List S
    mergeDifference(x,y) == 
      null x or null y => x
      mergeDifference1(x,y.first,y.rest)
      x.first=y.first => x.rest
      x
    mergeDifference1(x,fy,ry) ==  
      rx := x
      while not null rx repeat
        rx := rx.rest
        frx := rx.first
        while fy < frx repeat
          null ry => return x
          fy := first ry
          ry := rest ry
        frx = fy =>
          x.rest := rx.rest
          null ry => return x
          fy := ry.first
          ry := ry.rest
        x := rx

@
<<MTHING.dotabb>>=
"MTHING" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MTHING"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"MTHING" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MESH MeshCreationRoutinesForThreeDimensions}
\pagehead{MeshCreationRoutinesForThreeDimensions}{MESH}
\pagepic{ps/v104meshcreationroutinesforthreedimensions.ps}{MESH}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MESH MeshCreationRoutinesForThreeDimensions>>=
)abbrev package MESH MeshCreationRoutinesForThreeDimensions
++ <description of package>
++ Author: Jim Wen
++ Date Created: ??
++ Date Last Updated: October 1991 by Jon Steinbach
++ Keywords:
++ Examples:
++ References:
MeshCreationRoutinesForThreeDimensions():Exports == Implementation where

  I       ==> Integer
  PI      ==> PositiveInteger
  SF      ==> DoubleFloat
  L       ==> List
  SEG     ==> Segment
  S       ==> String
  Fn1     ==> SF -> SF
  Fn2     ==> (SF,SF) -> SF
  Fn3     ==> (SF,SF,SF) -> SF
  FnPt    ==> (SF,SF) -> Point(SF)
  FnU     ==> Union(Fn3,"undefined")
  EX      ==> Expression
  DROP    ==> DrawOption
  POINT   ==> Point(SF)
  SPACE3  ==> ThreeSpace(SF)
  COMPPROP ==> SubSpaceComponentProperty
  TUBE    ==> TubePlot

  Exports ==> with
    meshPar2Var: (Fn2,Fn2,Fn2,FnU,SEG SF,SEG SF,L DROP) -> SPACE3
	++ meshPar2Var(f,g,h,j,s1,s2,l) \undocumented
    meshPar2Var: (FnPt,SEG SF,SEG SF,L DROP) -> SPACE3
	++ meshPar2Var(f,s1,s2,l) \undocumented
    meshPar2Var: (SPACE3,FnPt,SEG SF,SEG SF,L DROP) -> SPACE3
	++ meshPar2Var(sp,f,s1,s2,l) \undocumented
    meshFun2Var: (Fn2,FnU,SEG SF,SEG SF,L DROP) -> SPACE3
	++ meshFun2Var(f,g,s1,s2,l) \undocumented
    meshPar1Var: (EX I,EX I,EX I,Fn1,SEG SF,L DROP) -> SPACE3
	++ meshPar1Var(s,t,u,f,s1,l) \undocumented
    ptFunc: (Fn2,Fn2,Fn2,Fn3) -> ((SF,SF) -> POINT)
      ++ ptFunc(a,b,c,d) is an internal function exported in
      ++ order to compile packages.

  Implementation ==> add
    import ViewDefaultsPackage()
    import SubSpaceComponentProperty()
    import DrawOptionFunctions0
    import SPACE3
    --import TUBE()

    -- local functions
    numberCheck(nums:Point SF):Void ==
      -- this function checks to see that the small floats are
      -- actually just that - rather than complex numbers or
      -- whatever (the whatever includes nothing presently
      -- since NaN, Not a Number, is not necessarily supported
      -- by common lisp). note that this function is dependent
      -- upon the fact that Common Lisp supports complex numbers.
      for i in minIndex(nums)..maxIndex(nums) repeat
        COMPLEXP(nums.(i::PositiveInteger))$Lisp => 
          error "An unexpected complex number was encountered in the calculations."
        
    makePt:(SF,SF,SF,SF) -> POINT
    makePt(x,y,z,c) == point(l : List SF := [x,y,z,c])
    ptFunc(f,g,h,c) ==
      x := f(#1,#2); y := g(#1,#2); z := h(#1,#2)
      makePt(x,y,z,c(x,y,z))

    -- parameterized equations of two variables
    meshPar2Var(sp,ptFun,uSeg,vSeg,opts) ==
      -- the issue of open and closed needs to be addressed, here, we are
      -- defaulting to open (which is probably the correct default)
      -- the user should be able to override that (optional argument?)
      llp : L L POINT := nil()
      uNum : PI  := var1Steps(opts,var1StepsDefault())
      vNum : PI  := var2Steps(opts,var2StepsDefault())
      ustep := (lo uSeg - hi uSeg)/uNum
      vstep := (lo vSeg - hi vSeg)/vNum
      someV := hi vSeg
      for iv in vNum..0 by -1 repeat
        if zero? iv then someV := lo vSeg  
        -- hack: get last number in segment within segment
        lp : L POINT := nil()
        someU := hi uSeg
        for iu in uNum..0 by -1 repeat
          if zero? iu then someU := lo uSeg  
          -- hack: get last number in segment within segment
          pt := ptFun(someU,someV)
          numberCheck pt
          lp := concat(pt,lp)
          someU := someU + ustep
        llp := concat(lp,llp)
        someV := someV + vstep
      -- now llp contains a list of lists of points
      -- for a surface that is a result of a function of 2 variables,
      -- the main component is open and each sublist is open as well
      lProp : L COMPPROP := [ new() for l in llp ]
      for aProp in lProp repeat
        close(aProp,false)
        solid(aProp,false)
      aProp : COMPPROP:= new()
      close(aProp,false)
      solid(aProp,false)
      space := sp
--      space := create3Space()
      mesh(space,llp,lProp,aProp)
      space 

    meshPar2Var(ptFun,uSeg,vSeg,opts) ==
      sp := create3Space()
      meshPar2Var(sp,ptFun,uSeg,vSeg,opts)

    zCoord: (SF,SF,SF) -> SF
    zCoord(x,y,z) == z

    meshPar2Var(xFun,yFun,zFun,colorFun,uSeg,vSeg,opts) ==
      -- the color function should be parameterized by (u,v) as well, 
      -- not (x,y,z) but we also want some sort of consistency and so 
      -- changing this over would mean possibly changing the explicit 
      -- stuff over and there, we probably do want the color function 
      -- to be parameterized by (x,y,z) - not just (x,y) (this being 
      -- for convinience only since z is also defined in terms of (x,y)).
      (colorFun case Fn3) =>
        meshPar2Var(ptFunc(xFun,yFun,zFun,colorFun :: Fn3),uSeg,vSeg,opts)
      meshPar2Var(ptFunc(xFun,yFun,zFun,zCoord),uSeg,vSeg,opts)

    -- explicit equations of two variables
    meshFun2Var(zFun,colorFun,xSeg,ySeg,opts) ==
      -- here, we construct the data for a function of two variables
      meshPar2Var(#1,#2,zFun,colorFun,xSeg,ySeg,opts)

@
<<MESH.dotabb>>=
"MESH" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MESH"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"MESH" -> "FIELD"
"MESH" -> "RADCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MDDFACT ModularDistinctDegreeFactorizer}
\pagehead{ModularDistinctDegreeFactorizer}{MDDFACT}
\pagepic{ps/v104modulardistinctdegreefactorizer.ps}{MDDFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MDDFACT ModularDistinctDegreeFactorizer>>=
)abbrev package MDDFACT ModularDistinctDegreeFactorizer
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated: 20.9.95 (JHD)
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package supports factorization and gcds
++ of univariate polynomials over the integers modulo different
++ primes. The inputs are given as polynomials over the integers
++ with the prime passed explicitly as an extra argument.

ModularDistinctDegreeFactorizer(U):C == T where
  U : UnivariatePolynomialCategory(Integer)
  I ==> Integer
  NNI ==> NonNegativeInteger
  PI ==> PositiveInteger
  V ==> Vector
  L ==> List
  DDRecord ==> Record(factor:EMR,degree:I)
  UDDRecord ==> Record(factor:U,degree:I)
  DDList ==> L DDRecord
  UDDList ==> L UDDRecord


  C == with
    gcd:(U,U,I) -> U
      ++ gcd(f1,f2,p) computes the gcd of the univariate polynomials
      ++ f1 and f2 modulo the integer prime p.
    linears: (U,I) -> U
      ++ linears(f,p) returns the product of all the linear factors
      ++ of f modulo p. Potentially incorrect result if f is not
      ++ square-free modulo p.
    factor:(U,I) -> L U
      ++ factor(f1,p) returns the list of factors of the univariate
      ++ polynomial f1 modulo the integer prime p.
      ++ Error: if f1 is not square-free modulo p.
    ddFact:(U,I) -> UDDList
      ++ ddFact(f,p) computes a distinct degree factorization of the
      ++ polynomial f modulo the prime p, i.e. such that each factor
      ++ is a product of irreducibles of the same degrees. The input
      ++ polynomial f is assumed to be square-free modulo p.
    separateFactors:(UDDList,I) -> L U
      ++ separateFactors(ddl, p) refines the distinct degree factorization
      ++ produced by \spadfunFrom{ddFact}{ModularDistinctDegreeFactorizer}
      ++ to give a complete list of factors.
    exptMod:(U,I,U,I) -> U
      ++ exptMod(f,n,g,p) raises the univariate polynomial f to the nth
      ++ power modulo the polynomial g and the prime p.

  T == add
    reduction(u:U,p:I):U ==
       zero? p => u
       map(positiveRemainder(#1,p),u)
    merge(p:I,q:I):Union(I,"failed") ==
       p = q => p
       p = 0 => q
       q = 0 => p
       "failed"
    modInverse(c:I,p:I):I ==
        (extendedEuclidean(c,p,1)::Record(coef1:I,coef2:I)).coef1
    exactquo(u:U,v:U,p:I):Union(U,"failed") ==
        invlcv:=modInverse(leadingCoefficient v,p)
        r:=monicDivide(u,reduction(invlcv*v,p))
        reduction(r.remainder,p) ^=0 => "failed"
        reduction(invlcv*r.quotient,p)
    EMR := EuclideanModularRing(Integer,U,Integer,
                                reduction,merge,exactquo)

    probSplit2:(EMR,EMR,I) -> Union(List EMR,"failed")
    trace:(EMR,I,EMR) -> EMR
    ddfactor:EMR -> L EMR
    ddfact:EMR -> DDList
    sepFact1:DDRecord -> L EMR
    sepfact:DDList -> L EMR
    probSplit:(EMR,EMR,I) -> Union(L EMR,"failed")
    makeMonic:EMR -> EMR
    exptmod:(EMR,I,EMR) -> EMR

    lc(u:EMR):I == leadingCoefficient(u::U)
    degree(u:EMR):I == degree(u::U)
    makeMonic(u) == modInverse(lc(u),modulus(u)) * u

    i:I

    exptmod(u1,i,u2) ==
      i < 0 => error("negative exponentiation not allowed for exptMod")
      ans:= 1$EMR
      while i > 0 repeat
        if odd?(i) then ans:= (ans * u1) rem u2
        i:= i quo 2
        u1:= (u1 * u1) rem u2
      ans

    exptMod(a,i,b,q) ==
      ans:= exptmod(reduce(a,q),i,reduce(b,q))
      ans::U

    ddfactor(u) ==
      if (c:= lc(u)) ^= 1$I then u:= makeMonic(u)
      ans:= sepfact(ddfact(u))
      cons(c::EMR,[makeMonic(f) for f in ans | degree(f) > 0])

    gcd(u,v,q) == gcd(reduce(u,q),reduce(v,q))::U

    factor(u,q) ==
      v:= reduce(u,q)
      dv:= reduce(differentiate(u),q)
      degree gcd(v,dv) > 0 =>
        error("Modular factor: polynomial must be squarefree")
      ans:= ddfactor v
      [f::U for f in ans]

    ddfact(u) ==
      p:=modulus u
      w:= reduce(monomial(1,1)$U,p)
      m:= w
      d:I:= 1
      if (c:= lc(u)) ^= 1$I then u:= makeMonic u
      ans:DDList:= []
      repeat
        w:= exptmod(w,p,u)
        g:= gcd(w - m,u)
        if degree g > 0 then
          g:= makeMonic(g)
          ans:= [[g,d],:ans]
          u:= (u quo g)
        degree(u) = 0 => return [[c::EMR,0$I],:ans]
        d:= d+1
        d > (degree(u):I quo 2) =>
               return [[c::EMR,0$I],[u,degree(u)],:ans]

    ddFact(u,q) ==
      ans:= ddfact(reduce(u,q))
      [[(dd.factor)::U,dd.degree]$UDDRecord for dd in ans]$UDDList

    linears(u,q) == 
       uu:=reduce(u,q)
       m:= reduce(monomial(1,1)$U,q)
       gcd(exptmod(m,q,uu)-m,uu)::U

    sepfact(factList) ==
      "append"/[sepFact1(f) for f in factList]

    separateFactors(uddList,q) ==
      ans:= sepfact [[reduce(udd.factor,q),udd.degree]$DDRecord for
        udd in uddList]$DDList
      [f::U for f in ans]

    decode(s:Integer, p:Integer, x:U):U ==
      s<p => s::U
      qr := divide(s,p)
      qr.remainder :: U + x*decode(qr.quotient, p, x)

    sepFact1(f) ==
      u:= f.factor
      p:=modulus u
      (d := f.degree) = 0 => [u]
      if (c:= lc(u)) ^= 1$I then u:= makeMonic(u)
      d = (du := degree(u)) => [u]
      ans:L EMR:= []
      x:U:= monomial(1,1)
      -- for small primes find linear factors by exhaustion
      d=1 and p < 1000  =>
        for i in 0.. while du > 0 repeat
          if u(i::U) = 0 then
            ans := cons(reduce(x-(i::U),p),ans)
            du := du-1
        ans 
      y:= x
      s:I:= 0
      ss:I := 1
      stack:L EMR:= [u]
      until null stack repeat
        t:= reduce(((s::U)+x),p)
        if not ((flist:= probSplit(first stack,t,d)) case "failed") then
          stack:= rest stack
          for fact in flist repeat
            f1:= makeMonic(fact)
            (df1:= degree(f1)) = 0 => nil
            df1 > d => stack:= [f1,:stack]
            ans:= [f1,:ans]
        p = 2 =>
          ss:= ss + 1
          x := y * decode(ss, p, y)
        s:= s+1
        s = p =>
          s:= 0
          ss := ss + 1
          x:= y * decode(ss, p, y)
--          not one? leadingCoefficient(x) =>
          not (leadingCoefficient(x) = 1) =>
              ss := p ** degree x
              x:= y ** (degree(x) + 1)
      [c * first(ans),:rest(ans)]

    probSplit(u,t,d) ==
      (p:=modulus(u)) = 2 => probSplit2(u,t,d)
      f1:= gcd(u,t)
      r:= ((p**(d:NNI)-1) quo 2):NNI
      n:= exptmod(t,r,u)
      f2:= gcd(u,n + 1)
      (g:= f1 * f2) = 1 => "failed"
      g = u => "failed"
      [f1,f2,(u quo g)]

    probSplit2(u,t,d) ==
      f:= gcd(u,trace(t,d,u))
      f = 1 => "failed"
      degree u = degree f => "failed"
      [1,f,u quo f]

    trace(t,d,u) ==
      p:=modulus(t)
      d:= d - 1
      tt:=t
      while d > 0 repeat
        tt:= (tt + (t:=exptmod(t,p,u))) rem u
        d:= d - 1
      tt

@
<<MDDFACT.dotabb>>=
"MDDFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MDDFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MDDFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MHROWRED ModularHermitianRowReduction}
\pagehead{ModularHermitianRowReduction}{MHROWRED}
\pagepic{ps/v104modularhermitianrowreduction.ps}{MHROWRED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MHROWRED ModularHermitianRowReduction>>=
)abbrev package MHROWRED ModularHermitianRowReduction
++ Modular hermitian row reduction.
++ Author: Manuel Bronstein
++ Date Created: 22 February 1989
++ Date Last Updated: 24 November 1993
++ Keywords: matrix, reduction.
-- should be moved into matrix whenever possible
ModularHermitianRowReduction(R): Exports == Implementation where
  R: EuclideanDomain

  Z   ==> Integer
  V   ==> Vector R
  M   ==> Matrix R
  REC ==> Record(val:R, cl:Z, rw:Z)

  Exports ==> with
    rowEch       : M -> M
      ++ rowEch(m) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus.
    rowEchelon   : (M, R) -> M
      ++ rowEchelon(m, d) computes a modular row-echelon form mod d of
      ++    [d     ]
      ++    [  d   ]
      ++    [    . ]
      ++    [     d]
      ++    [   M  ]
      ++ where \spad{M = m mod d}.
    rowEchLocal    : (M, R) -> M
      ++ rowEchLocal(m,p) computes a modular row-echelon form of m, finding
      ++ an appropriate modulus over a local ring where p is the only prime.
    rowEchelonLocal: (M, R, R) -> M
      ++ rowEchelonLocal(m, d, p) computes the row-echelon form of m
      ++ concatenated with d times the identity matrix
      ++ over a local ring where p is the only prime.
    normalizedDivide: (R, R) -> Record(quotient:R, remainder:R)
      ++ normalizedDivide(n,d) returns a normalized quotient and
      ++ remainder such that consistently unique representatives
      ++ for the residue class are chosen, e.g. positive remainders



  Implementation ==> add
    order   : (R, R) -> Z
    vconc   : (M, R) -> M
    non0    : (V, Z) -> Union(REC, "failed")
    nonzero?: V -> Boolean
    mkMat   : (M, List Z) -> M
    diagSubMatrix: M -> Union(Record(val:R, mat:M), "failed")
    determinantOfMinor: M -> R
    enumerateBinomial: (List Z, Z, Z) -> List Z

    nonzero? v == any?(#1 ^= 0, v)

-- returns [a, i, rown] if v = [0,...,0,a,0,...,0]
-- where a <> 0 and i is the index of a, "failed" otherwise.
    non0(v, rown) ==
      ans:REC
      allZero:Boolean := true
      for i in minIndex v .. maxIndex v repeat
        if qelt(v, i) ^= 0 then
          if allZero then
            allZero := false
            ans := [qelt(v, i), i, rown]
          else return "failed"
      allZero => "failed"
      ans

-- returns a matrix made from the non-zero rows of x whose row number
-- is not in l
    mkMat(x, l) ==
      empty?(ll := [parts row(x, i)
         for i in minRowIndex x .. maxRowIndex x |
           (not member?(i, l)) and nonzero? row(x, i)]$List(List R)) =>
              zero(1, ncols x)
      matrix ll

-- returns [m, d] where m = x with the zero rows and the rows of
-- the diagonal of d removed, if x has a diagonal submatrix of d's,
-- "failed" otherwise.
    diagSubMatrix x ==
      l  := [u::REC for i in minRowIndex x .. maxRowIndex x |
                                     (u := non0(row(x, i), i)) case REC]
      for a in removeDuplicates([r.val for r in l]$List(R)) repeat
        {[r.cl for r in l | r.val = a]$List(Z)}$Set(Z) =
          {[z for z in minColIndex x .. maxColIndex x]$List(Z)}$Set(Z)
            => return [a, mkMat(x, [r.rw for r in l | a = r.val])]
      "failed"

-- returns a non-zero determinant of a minor of x of rank equal to
-- the number of columns of x, if there is one, 0 otherwise
    determinantOfMinor x ==
-- do not compute a modulus for square matrices, since this is as expensive
-- as the Hermite reduction itself
      (nr := nrows x) <= (nc := ncols x) => 0
      lc := [i for i in minColIndex x .. maxColIndex x]$List(Integer)
      lr := [i for i in minRowIndex x .. maxRowIndex x]$List(Integer)
      for i in 1..(n := binomial(nr, nc)) repeat
        (d := determinant x(enumerateBinomial(lr, nc, i), lc)) ^= 0 =>
          j := i + 1 + (random()$Z rem (n - i))
          return gcd(d, determinant x(enumerateBinomial(lr, nc, j), lc))
      0

-- returns the i-th selection of m elements of l = (a1,...,an),
--                 /n\
-- where 1 <= i <= | |
--                 \m/
    enumerateBinomial(l, m, i) ==
      m1 := minIndex l - 1
      zero?(m := m - 1) => [l(m1 + i)]
      for j in 1..(n := #l) repeat
        i <= (b := binomial(n - j, m)) =>
          return concat(l(m1 + j), enumerateBinomial(rest(l, j), m, i))
        i := i - b
      error "Should not happen"

    rowEch x ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelon(x, d)
      rowEchelon(u.mat, u.val)

    vconc(y, m) ==
      vertConcat(diagonalMatrix new(ncols y, m)$V, map(#1 rem m, y))

    order(m, p) ==
      zero? m => -1
      for i in 0.. repeat
        (mm := m exquo p) case "failed" => return i
        m := mm::R

    if R has IntegerNumberSystem then
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            qr := divide(n, d)
            qr.remainder >= 0 => qr
            d > 0 =>
                qr.remainder := qr.remainder + d
                qr.quotient := qr.quotient - 1
                qr
            qr.remainder := qr.remainder - d
            qr.quotient := qr.quotient + 1
            qr
    else
        normalizedDivide(n:R, d:R):Record(quotient:R, remainder:R) ==
            divide(n, d)

    rowEchLocal(x,p) ==
      (u := diagSubMatrix x) case "failed" =>
        zero?(d := determinantOfMinor x) => rowEchelon x
        rowEchelonLocal(x, d, p)
      rowEchelonLocal(u.mat, u.val, p)

    rowEchelonLocal(y, m, p) ==
        m := p**(order(m,p)::NonNegativeInteger)
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave x
          rown := minr - 1
          pivord : Integer
          npivord : Integer
          for k in i .. nrows repeat
            qelt(x,k,j) = 0 => "next k"
            npivord := order(qelt(x,k,j),p)
            (rown = minr - 1) or (npivord  <  pivord) =>
                    rown := k
                    pivord := npivord
          rown = minr - 1 => "enuf"
          x := swapRows_!(x, i, rown)
          (a, b, d) := extendedEuclidean(qelt(x,i,j), m)
          qsetelt_!(x,i,j,d)
          pivot := d
          for k in j+1 .. ncols repeat
            qsetelt_!(x,i,k, a * qelt(x,i,k) rem m)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            q := (qelt(x,k,j) exquo pivot) :: R
            for k1 in j+1 .. ncols repeat
              v2 := (qelt(x,k,k1) - q * qelt(x,i,k1)) rem m
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, k, j, 0)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "enuf"
            qr    := normalizedDivide(qelt(x,k,j), pivot)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

    if R has Field then
      rowEchelon(y, m) == rowEchelon vconc(y, m)

    else

      rowEchelon(y, m) ==
        x     := vconc(y, m)
        nrows := maxRowIndex x
        ncols := maxColIndex x
        minr  := i := minRowIndex x
        for j in minColIndex x .. ncols repeat
          if i > nrows then leave
          rown := minr - 1
          for k in i .. nrows repeat
            if (qelt(x,k,j) ^= 0) and ((rown = minr - 1) or
                  sizeLess?(qelt(x,k,j), qelt(x,rown,j))) then rown := k
          rown = minr - 1 => "next j"
          x := swapRows_!(x, i, rown)
          for k in i+1 .. nrows repeat
            zero? qelt(x,k,j) => "next k"
            (a, b, d) := extendedEuclidean(qelt(x,i,j), qelt(x,k,j))
            (b1, a1) :=
               ((qelt(x,i,j) exquo d)::R, (qelt(x,k,j) exquo d)::R)
            -- a*b1+a1*b = 1
            for k1 in j+1 .. ncols repeat
              v1 := (a  * qelt(x,i,k1) +  b * qelt(x,k,k1)) rem m
              v2 := (b1 * qelt(x,k,k1) - a1 * qelt(x,i,k1)) rem m
              qsetelt_!(x, i, k1, v1)
              qsetelt_!(x, k, k1, v2)
            qsetelt_!(x, i, j, d)
            qsetelt_!(x, k, j, 0)
          un := unitNormal qelt(x,i,j)
          qsetelt_!(x,i,j,un.canonical)
          if un.associate ^= 1 then for jj in (j+1)..ncols repeat
              qsetelt_!(x,i,jj,un.associate * qelt(x,i,jj))

          xij := qelt(x,i,j)
          for k in minr .. i-1 repeat
            zero? qelt(x,k,j) => "next k"
            qr    := normalizedDivide(qelt(x,k,j), xij)
            qsetelt_!(x,k,j, qr.remainder)
            for k1 in j+1 .. ncols x repeat
              qsetelt_!(x,k,k1,
                     (qelt(x,k,k1) - qr.quotient * qelt(x,i,k1)) rem m)
          i := i+1
        x

@
<<MHROWRED.dotabb>>=
"MHROWRED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MHROWRED"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"MHROWRED" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MRF2 MonoidRingFunctions2}
\pagehead{MonoidRingFunctions2}{MRF2}
\pagepic{ps/v104monoidringfunctions2.ps}{MRF2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MRF2 MonoidRingFunctions2>>=
)abbrev package MRF2 MonoidRingFunctions2
++ Author: Johannes Grabmeier
++ Date Created: 14 May 1991
++ Date Last Updated: 14 May 1991
++ Basic Operations: map
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: monoid ring, group ring, change of coefficient domain
++ References:
++ Description:
++  MonoidRingFunctions2 implements functions between
++  two monoid rings defined with the same monoid over different rings.
MonoidRingFunctions2(R,S,M) : Exports == Implementation where
    R  : Ring
    S  : Ring
    M  : Monoid
    Exports ==> with
      map: (R -> S, MonoidRing(R,M)) -> MonoidRing(S,M)
        ++ map(f,u) maps f onto the coefficients f the element
        ++ u of the monoid ring to create an element of a monoid
        ++ ring with the same monoid b.
    Implementation ==> add
      map(fn, u) ==
        res : MonoidRing(S,M) := 0
        for te in terms u repeat
          res := res + monomial(fn(te.coef), te.monom)
        res

@
<<MRF2.dotabb>>=
"MRF2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MRF2"]
"LMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=LMODULE"]
"SGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=SGROUP"]
"MRF2" -> "LMODULE"
"MRF2" -> "SGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MONOTOOL MonomialExtensionTools}
\pagehead{MonomialExtensionTools}{MONOTOOL}
\pagepic{ps/v104monomialextensiontools.ps}{MONOTOOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MONOTOOL MonomialExtensionTools>>=
)abbrev package MONOTOOL MonomialExtensionTools
++ Tools for handling monomial extensions
++ Author: Manuel Bronstein
++ Date Created: 18 August 1992
++ Date Last Updated: 3 June 1993
++ Description: Tools for handling monomial extensions.
MonomialExtensionTools(F, UP): Exports == Implementation where
  F : Field
  UP: UnivariatePolynomialCategory F

  RF ==> Fraction UP
  FR ==> Factored UP

  Exports ==> with
    split      : (UP, UP -> UP) -> Record(normal:UP, special:UP)
      ++ split(p, D) returns \spad{[n,s]} such that \spad{p = n s},
      ++ all the squarefree factors of n are normal w.r.t. D,
      ++ and s is special w.r.t. D.
      ++ D is the derivation to use.
    splitSquarefree: (UP, UP -> UP) -> Record(normal:FR, special:FR)
      ++ splitSquarefree(p, D) returns
      ++ \spad{[n_1 n_2\^2 ... n_m\^m, s_1 s_2\^2 ... s_q\^q]} such that
      ++ \spad{p = n_1 n_2\^2 ... n_m\^m s_1 s_2\^2 ... s_q\^q}, each
      ++ \spad{n_i} is normal w.r.t. D and each \spad{s_i} is special
      ++ w.r.t D.
      ++ D is the derivation to use.
    normalDenom: (RF, UP -> UP) -> UP
      ++ normalDenom(f, D) returns the product of all the normal factors
      ++ of \spad{denom(f)}.
      ++ D is the derivation to use.
    decompose  : (RF, UP -> UP) -> Record(poly:UP, normal:RF, special:RF)
      ++ decompose(f, D) returns \spad{[p,n,s]} such that \spad{f = p+n+s},
      ++ all the squarefree factors of \spad{denom(n)} are normal w.r.t. D,
      ++ \spad{denom(s)} is special w.r.t. D,
      ++ and n and s are proper fractions (no pole at infinity).
      ++ D is the derivation to use.

  Implementation ==> add
    normalDenom(f, derivation) == split(denom f, derivation).normal

    split(p, derivation) ==
      pbar := (gcd(p, derivation p) exquo gcd(p, differentiate p))::UP
      zero? degree pbar => [p, 1]
      rec := split((p exquo pbar)::UP, derivation)
      [rec.normal, pbar * rec.special]

    splitSquarefree(p, derivation) ==
      s:Factored(UP) := 1
      n := s
      q := squareFree p
      for rec in factors q repeat
        r := rec.factor
        g := gcd(r, derivation r)
        if not ground? g then s := s * sqfrFactor(g, rec.exponent)
        h := (r exquo g)::UP
        if not ground? h then n := n * sqfrFactor(h, rec.exponent)
      [n, unit(q) * s]

    decompose(f, derivation) ==
      qr := divide(numer f, denom f)
-- rec.normal * rec.special = denom f
      rec := split(denom f, derivation)
-- eeu.coef1 * rec.normal + eeu.coef2 * rec.special = qr.remainder
-- and degree(eeu.coef1) < degree(rec.special)
-- and degree(eeu.coef2) < degree(rec.normal)
-- qr.remainder/denom(f) = eeu.coef1 / rec.special + eeu.coef2 / rec.normal
      eeu := extendedEuclidean(rec.normal, rec.special,
                               qr.remainder)::Record(coef1:UP, coef2:UP)
      [qr.quotient, eeu.coef2 / rec.normal, eeu.coef1 / rec.special]

@
<<MONOTOOL.dotabb>>=
"MONOTOOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MONOTOOL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MONOTOOL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPCPF MPolyCatPolyFactorizer}
\pagehead{MPolyCatPolyFactorizer}{MPCPF}
\pagepic{ps/v104mpolycatpolyfactorizer.ps}{MPCPF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPCPF MPolyCatPolyFactorizer>>=
)abbrev package MPCPF MPolyCatPolyFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are polynomials over
++ some ring R over which we can factor. It is used internally by packages
++ such as the solve package which need to work with polynomials in a specific
++ set of variables with coefficients which are polynomials in all the other
++ variables.

MPolyCatPolyFactorizer(E,OV,R,PPR) : C == T
 where
  R     :   EuclideanDomain
  E     :   OrderedAbelianMonoidSup
    -- following type is required by PushVariables
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  PR    ==> Polynomial R
  PPR   :   PolynomialCategory(PR,E,OV)
  NNI   ==> NonNegativeInteger
  ISY   ==> IndexedExponents Symbol
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial PR
  UPPR  ==> SparseUnivariatePolynomial PPR

  C  == with
     factor      :        PPR             ->   Factored PPR
       ++ factor(p) factors a polynomial with polynomial
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

     import PushVariables(R,E,OV,PPR)

        ----  factorization of p ----
     factor(p:PPR) : Factored PPR ==
       ground? p => nilFactor(p,1)
       c := content p
       p := (p exquo c)::PPR
       vars:List OV :=variables p
       g:PR:=retract pushdown(p, vars)
       flist := factor(g)$GeneralizedMultivariateFactorize(Symbol,ISY,R,R,PR)
       ffact : List(Record(irr:PPR,pow:Integer))
       ffact:=[[pushup(u.factor::PPR,vars),u.exponent] for u in factors flist]
       fcont:=(unit flist)::PPR
       nilFactor(c*fcont,1)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])

@
<<MPCPF.dotabb>>=
"MPCPF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPCPF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPCPF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPRFF MPolyCatRationalFunctionFactorizer}
\pagehead{MPolyCatRationalFunctionFactorizer}{MPRFF}
\pagepic{ps/v104mpolycatrationalfunctionfactorizer.ps}{MPRFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPRFF MPolyCatRationalFunctionFactorizer>>=
)abbrev package MPRFF MPolyCatRationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are rational functions over
++ some ring R over which we can factor. It is used internally by packages
++ such as primary decomposition which need to work with polynomials
++ with rational function coefficients, i.e. themselves fractions of
++ polynomials.

MPolyCatRationalFunctionFactorizer(E,OV,R,PRF) : C == T
 where
  R     :   IntegralDomain
  F     ==> Fraction Polynomial R
  RN    ==> Fraction Integer
  E     :   OrderedAbelianMonoidSup
  OV    :   OrderedSet  with 
                convert : % -> Symbol
                  ++ convert(x) converts x to a symbol
  PRF   :   PolynomialCategory(F,E,OV)
  NNI   ==> NonNegativeInteger
  P     ==> Polynomial R
  ISE   ==> IndexedExponents  SE
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial P
  UF    ==> SparseUnivariatePolynomial F
  UPRF  ==> SparseUnivariatePolynomial PRF
  QuoForm   ==> Record(sup:P,inf:P)

  C  == with
     totalfract  :        PRF             ->   QuoForm
       ++ totalfract(prf) takes a polynomial whose coefficients are
       ++ themselves fractions of polynomials and returns a record
       ++ containing the numerator and denominator resulting from
       ++ putting prf over a common denominator.
     pushdown    :      (PRF,OV)          ->   PRF
       ++ pushdown(prf,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the polynomial prf.
     pushdterm   :      (UPRF,OV)         ->   PRF
       ++ pushdterm(monom,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the monomial monom.
     pushup      :      (PRF,OV)          ->   PRF
       ++ pushup(prf,var) raises all occurences of the
       ++ variable var in the coefficients of the polynomial prf
       ++ back to the polynomial level.
     pushucoef   :       (UP,OV)          ->   PRF
       ++ pushucoef(upoly,var) converts the anonymous univariate
       ++ polynomial upoly to a polynomial in var over rational functions.
     pushuconst  :        (F,OV)          ->   PRF
       ++ pushuconst(r,var) takes a rational function and raises
       ++ all occurances of the variable var to the polynomial level.
     factor      :        PRF             ->   Factored PRF
       ++ factor(prf) factors a polynomial with rational function
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

        ----  factorization of p ----
     factor(p:PRF) : Factored PRF ==
       truelist:List OV :=variables p
       tp:=totalfract(p)
       nump:P:= tp.sup
       denp:F:=inv(tp.inf ::F)
       ffact : List(Record(irr:PRF,pow:Integer))
       flist:Factored P
       if R is Fraction Integer then
         flist:=
           ((factor nump)$MRationalFactorize(ISE,SE,Integer,P))
                          pretend (Factored P)
       else
         if R has FiniteFieldCategory  then
            flist:= ((factor nump)$MultFiniteFactorize(SE,ISE,R,P))
                    pretend (Factored P)

         else
            if R has Field then error "not done yet"

            else
              if R has CharacteristicZero then 
                flist:= ((factor nump)$MultivariateFactorize(SE,ISE,R,P))
                                                pretend (Factored P)
              else error "can't happen"  
       ffact:=[[u.factor::F::PRF,u.exponent] for u in factors flist]
       fcont:=(unit flist)::F::PRF
       for x in truelist repeat
         fcont:=pushup(fcont,x)
         ffact:=[[pushup(ff.irr,x),ff.pow] for ff in ffact]
       (denp*fcont)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])


-- the following functions are used to "push" x in the coefficient ring -

        ----  push x in the coefficient domain for a polynomial ----
     pushdown(g:PRF,x:OV) : PRF ==
       ground? g => g
       rf:PRF:=0$PRF
       ug:=univariate(g,x)
       while ug^=0 repeat
         rf:=rf+pushdterm(ug,x)
         ug := reductum ug
       rf

      ----  push x in the coefficient domain for a term ----
     pushdterm(t:UPRF,x:OV):PRF ==
       n:=degree(t)
       cf:=monomial(1,convert x,n)$P :: F
       cf * leadingCoefficient t

               ----  push back the variable  ----
     pushup(f:PRF,x:OV) :PRF ==
       ground? f => pushuconst(retract f,x)
       v:=mainVariable(f)::OV
       g:=univariate(f,v)
       multivariate(map(pushup(#1,x),g),v)

      ----  push x back from the coefficient domain ----
     pushuconst(r:F,x:OV):PRF ==
       xs:SE:=convert x
       degree(denom r,xs)>0 => error "bad polynomial form"
       inv((denom r)::F)*pushucoef(univariate(numer r,xs),x)


     pushucoef(c:UP,x:OV):PRF ==
       c = 0 => 0
       monomial((leadingCoefficient c)::F::PRF,x,degree c) +
                 pushucoef(reductum c,x)


           ----  write p with a common denominator  ----

     totalfract(p:PRF) : QuoForm ==
       p=0 => [0$P,1$P]$QuoForm
       for x in variables p repeat p:=pushdown(p,x)
       g:F:=retract p
       [numer g,denom g]$QuoForm

@
<<MPRFF.dotabb>>=
"MPRFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPRFF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPRFF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MRATFAC MRationalFactorize}
\pagehead{MRationalFactorize}{MRATFAC}
\pagepic{ps/v104mrationalfactorize.ps}{MRATFAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MRATFAC MRationalFactorize>>=
)abbrev package MRATFAC MRationalFactorize
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  MRationalFactorize contains the factor function for multivariate
++ polynomials over the quotient field of a ring R such that the package
++ MultivariateFactorize can factor multivariate polynomials over R.


MRationalFactorize(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   Join(EuclideanDomain, CharacteristicZero)  -- with factor over R[x]
  FR  ==> Fraction R
  P  :    PolynomialCategory(FR,E,OV)
  MPR ==> SparseMultivariatePolynomial(R,OV)
  SUP ==> SparseUnivariatePolynomial

  C  == with
     factor      : P   ->  Factored P
       ++ factor(p) factors the multivariate polynomial p with coefficients
       ++ which are fractions of elements of R.

  T  == add
     IE     ==> IndexedExponents OV
     PCLFRR ==> PolynomialCategoryLifting(E,OV,FR,P,MPR)
     PCLRFR ==> PolynomialCategoryLifting(IE,OV,R,MPR,P)
     MFACT  ==> MultivariateFactorize(OV,IE,R,MPR)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     numer1(c:FR): MPR   == (numer c) :: MPR
     numer2(pol:P) : MPR == map(coerce,numer1,pol)$PCLFRR
     coerce1(d:R) : P == (d::FR)::P
     coerce2(pp:MPR) :P == map(coerce,coerce1,pp)$PCLRFR 

     factor(p:P) : Factored P ==
       pden:R:=lcm([denom c for c in coefficients p])
       pol :P:= (pden::FR)*p
       ipol:MPR:= map(coerce,numer1,pol)$PCLFRR
       ffact:=(factor ipol)$MFACT
       (1/pden)*map(coerce,coerce1,(unit ffact))$PCLRFR *
           _*/[primeFactor(map(coerce,coerce1,u.factor)$PCLRFR,
                           u.exponent) for u in factors ffact]

@
<<MRATFAC.dotabb>>=
"MRATFAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MRATFAC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MFINFACT MultFiniteFactorize}
\pagehead{MultFiniteFactorize}{MFINFACT}
\pagepic{ps/v104multfinitefactorize.ps}{MFINFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MFINFACT MultFiniteFactorize>>=
)abbrev package MFINFACT MultFiniteFactorize
++ Author: P. Gianni
++ Date Created: Summer 1990
++ Date Last Updated: 19 March 1992
++ Basic Functions:
++ Related Constructors: PrimeField, FiniteField, Polynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: Package for factorization of multivariate polynomials
++ over finite fields.


MultFiniteFactorize(OV,E,F,PG) : C == T
 where
  F          :   FiniteFieldCategory
  OV         :   OrderedSet
  E          :   OrderedAbelianMonoidSup
  PG         :   PolynomialCategory(F,E,OV)
  SUP        ==> SparseUnivariatePolynomial
  R          ==> SUP F
  P          ==> SparseMultivariatePolynomial(R,OV)
  Z          ==> Integer
  FFPOLY     ==> FiniteFieldPolynomialPackage(F)
  MParFact   ==> Record(irr:P,pow:Z)
  MFinalFact ==> Record(contp:R,factors:List MParFact)
  SUParFact    ==> Record(irr:SUP P,pow:Z)
  SUPFinalFact ==> Record(contp:R,factors:List SUParFact)

                 --  contp   =  content,
                 --  factors =  List of irreducible factors with exponent

  C == with

    factor      : PG     ->  Factored PG
      ++ factor(p) produces the complete factorization of the multivariate
      ++ polynomial p over a finite field.
    factor      : SUP PG     ->  Factored SUP PG
      ++ factor(p) produces the complete factorization of the multivariate
      ++ polynomial p over a finite field. p is represented as a univariate
      ++ polynomial with multivariate coefficients over a finite field.

  T == add

    import LeadingCoefDetermination(OV,IndexedExponents OV,R,P)
    import MultivariateLifting(IndexedExponents OV,OV,R,P)
    import FactoringUtilities(IndexedExponents OV,OV,R,P)
    import FactoringUtilities(E,OV,F,PG)
    import GenExEuclid(R,SUP R)

    NNI       ==> NonNegativeInteger
    L         ==> List
    UPCF2     ==> UnivariatePolynomialCategoryFunctions2
    LeadFact  ==> Record(polfac:L P,correct:R,corrfact:L SUP R)
    ContPrim  ==> Record(cont:P,prim:P)
    ParFact   ==> Record(irr:SUP R,pow:Z)
    FinalFact ==> Record(contp:R,factors:L ParFact)
    NewOrd    ==> Record(npol:SUP P,nvar:L OV,newdeg:L NNI)
    Valuf     ==> Record(inval:L L R,unvfact:L SUP R,lu:R,complead:L R)

                   ----  Local Functions  ----
    ran       :                   Z              -> R
    mFactor   :                (P,Z)             -> MFinalFact
    supFactor :              (SUP P,Z)           -> SUPFinalFact
    mfconst   :        (SUP P,Z,L OV,L NNI)      -> L SUP P
    mfpol     :        (SUP P,Z,L OV,L NNI)      -> L SUP P
    varChoose :           (P,L OV,L NNI)         -> NewOrd
    simplify  :         (P,Z,L OV,L NNI)         -> MFinalFact
    intChoose :        (SUP P,L OV,R,L P,L L R)  -> Valuf
    pretest   :         (P,NNI,L OV,L R)         -> FinalFact
    checkzero :            (SUP P,SUP R)         -> Boolean
    pushdcoef :                  PG              -> P
    pushdown  :                (PG,OV)           -> P
    pushupconst :               (R,OV)           -> PG
    pushup    :                 (P,OV)           -> PG
    norm      :               L SUP R            -> Integer
    constantCase :        (P,L MParFact)         -> MFinalFact
    pM          :             L SUP R            -> R
    intfact     :     (SUP P,L OV,L NNI,MFinalFact,L L R) -> L SUP P

    basicVar:OV:=NIL$Lisp pretend OV  -- variable for the basic step


    convertPUP(lfg:MFinalFact): SUPFinalFact ==
      [lfg.contp,[[lff.irr ::SUP P,lff.pow]$SUParFact
                    for lff in lfg.factors]]$SUPFinalFact

    supFactor(um:SUP P,dx:Z) : SUPFinalFact ==
        degree(um)=0 => convertPUP(mFactor(ground um,dx))
        lvar:L OV:= "setUnion"/[variables cf for cf in coefficients um]
        lcont:SUP P
        lf:L SUP P

        flead : SUPFinalFact:=[0,empty()]$SUPFinalFact
        factorlist:L SUParFact :=empty()

        mdeg :=minimumDegree um     ---- is the Mindeg > 0? ----
        if mdeg>0 then
          f1:SUP P:=monomial(1,mdeg)
          um:=(um exquo f1)::SUP P
          factorlist:=cons([monomial(1,1),mdeg],factorlist)
          if degree um=0 then return
            lfg:=convertPUP mFactor(ground um, dx)
            [lfg.contp,append(factorlist,lfg.factors)]


        om:=map(pushup(#1,basicVar),um)$UPCF2(P,SUP P,PG,SUP PG)
        sqfacs:=squareFree(om)
        lcont:=map(pushdown(#1,basicVar),unit sqfacs)$UPCF2(PG,SUP PG,P,SUP P)

                                   ----   Factorize the content  ----
        if ground? lcont then
          flead:=convertPUP constantCase(ground lcont,empty())
        else
          flead:=supFactor(lcont,dx)

        factorlist:=flead.factors

                                 ----  Make the polynomial square-free  ----
        sqqfact:=[[map(pushdown(#1,basicVar),ff.factor),ff.exponent]
                      for ff in factors sqfacs]

                        ---  Factorize the primitive square-free terms ---
        for fact in sqqfact repeat
          ffactor:SUP P:=fact.irr
          ffexp:=fact.pow
          ffcont:=content ffactor
          coefs := coefficients ffactor
          ldeg:= ["max"/[degree(fc,xx) for fc in coefs] for xx in lvar]
          if ground?(leadingCoefficient ffactor) then
             lf:= mfconst(ffactor,dx,lvar,ldeg)
          else lf:=mfpol(ffactor,dx,lvar,ldeg)
          auxfl:=[[lfp,ffexp]$SUParFact  for lfp in lf]
          factorlist:=append(factorlist,auxfl)
        lcfacs := */[leadingCoefficient leadingCoefficient(f.irr)**((f.pow)::NNI)
                             for f in factorlist]
        [(leadingCoefficient leadingCoefficient(um) exquo lcfacs)::R,
                       factorlist]$SUPFinalFact

    factor(um:SUP PG):Factored SUP PG ==
        lv:List OV:=variables um
        ld:=degree(um,lv)
        dx:="min"/ld
        basicVar:=lv.position(dx,ld)
        cm:=map(pushdown(#1,basicVar),um)$UPCF2(PG,SUP PG,P,SUP P)
        flist := supFactor(cm,dx)
        pushupconst(flist.contp,basicVar)::SUP(PG) *
          (*/[primeFactor(map(pushup(#1,basicVar),u.irr)$UPCF2(P,SUP P,PG,SUP PG),
                 u.pow) for u in flist.factors])



    mFactor(m:P,dx:Z) : MFinalFact ==
      ground?(m) => constantCase(m,empty())
      lvar:L OV:= variables m
      lcont:P
      lf:L SUP P
      flead : MFinalFact:=[1,empty()]$MFinalFact
      factorlist:L MParFact :=empty()
                                  ---- is the Mindeg > 0? ----
      lmdeg :=minimumDegree(m,lvar)
      or/[n>0 for n in lmdeg] => simplify(m,dx,lvar,lmdeg)
                              ----  Make the polynomial square-free  ----
      om:=pushup(m,basicVar)
      sqfacs:=squareFree(om)
      lcont := pushdown(unit sqfacs,basicVar)

                                  ----  Factorize the content  ----
      if ground? lcont then
        flead:=constantCase(lcont,empty())
      else
        flead:=mFactor(lcont,dx)
      factorlist:=flead.factors
      sqqfact:List Record(factor:P,exponent:Integer)
      sqqfact:=[[pushdown(ff.factor,basicVar),ff.exponent]
                                              for ff in factors sqfacs]
                       ---  Factorize the primitive square-free terms ---
      for fact in sqqfact repeat
        ffactor:P:=fact.factor
        ffexp := fact.exponent
        ground? ffactor =>
          for lterm in constantCase(ffactor,empty()).factors repeat
            factorlist:=cons([lterm.irr,lterm.pow * ffexp], factorlist)
        lvar := variables ffactor
        x:OV:=lvar.1
        ldeg:=degree(ffactor,lvar)
             ---  Is the polynomial linear in one of the variables ? ---
        member?(1,ldeg) =>
          x:OV:=lvar.position(1,ldeg)
          lcont:= gcd coefficients(univariate(ffactor,x))
          ffactor:=(ffactor exquo lcont)::P
          factorlist:=cons([ffactor,ffexp]$MParFact,factorlist)
          for lcterm in mFactor(lcont,dx).factors repeat
           factorlist:=cons([lcterm.irr,lcterm.pow * ffexp], factorlist)

        varch:=varChoose(ffactor,lvar,ldeg)
        um:=varch.npol


        ldeg:=ldeg.rest
        lvar:=lvar.rest
        if varch.nvar.1 ^= x then
          lvar:= varch.nvar
          x := lvar.1
          lvar:=lvar.rest
          pc:= gcd coefficients um
          if pc^=1 then
            um:=(um exquo pc)::SUP P
            ffactor:=multivariate(um,x)
            for lcterm in mFactor(pc,dx).factors repeat
              factorlist:=cons([lcterm.irr,lcterm.pow*ffexp],factorlist)
          ldeg:= degree(ffactor,lvar)

        -- should be unitNormal if unified, but for now it is easier
        lcum:F:= leadingCoefficient leadingCoefficient
                leadingCoefficient um
        if lcum ^=1  then
          um:=((inv lcum)::R::P) * um
          flead.contp := (lcum::R) *flead.contp

        if ground?(leadingCoefficient um)
        then lf:= mfconst(um,dx,lvar,ldeg)
        else lf:=mfpol(um,dx,lvar,ldeg)
        auxfl:=[[multivariate(lfp,x),ffexp]$MParFact  for lfp in lf]
        factorlist:=append(factorlist,auxfl)
      flead.factors:= factorlist
      flead


    pM(lum:L SUP R) : R ==
      x := monomial(1,1)$R
      for i in 1..size()$F repeat
         p := x + (index(i::PositiveInteger)$F) ::R
         testModulus(p,lum) => return p
      for e in 2.. repeat
          p :=  (createIrreduciblePoly(e::PositiveInteger))$FFPOLY
          testModulus(p,lum) => return p
          while not((q := nextIrreduciblePoly(p)$FFPOLY) case "failed") repeat
             p := q::SUP F
             if testModulus(p, lum)$GenExEuclid(R, SUP R) then return p

      ----  push x in the coefficient domain for a term ----
    pushdcoef(t:PG):P ==
       map(coerce(#1)$R,t)$MPolyCatFunctions2(OV,E,
                                           IndexedExponents OV,F,R,PG,P)


              ----  internal function, for testing bad cases  ----
    intfact(um:SUP P,lvar: L OV,ldeg:L NNI,
            tleadpol:MFinalFact,ltry:L L R):  L SUP P ==
      polcase:Boolean:=(not empty? tleadpol.factors )
      vfchoo:Valuf:=
        polcase =>
          leadpol:L P:=[ff.irr for ff in tleadpol.factors]
          intChoose(um,lvar,tleadpol.contp,leadpol,ltry)
        intChoose(um,lvar,1,empty(),empty())
      unifact:List SUP R := vfchoo.unvfact
      nfact:NNI := #unifact
      nfact=1 => [um]
      ltry:L L R:= vfchoo.inval
      lval:L R:=first ltry
      dd:= vfchoo.lu
      lpol:List P:=empty()
      leadval:List R:=empty()
      if polcase then
        leadval := vfchoo.complead
        distf := distFact(vfchoo.lu,unifact,tleadpol,leadval,lvar,lval)
        distf case "failed" =>
             return intfact(um,lvar,ldeg,tleadpol,ltry)
        dist := distf :: LeadFact
          -- check the factorization of leading coefficient
        lpol:= dist.polfac
        dd := dist.correct
        unifact:=dist.corrfact
      if dd^=1 then
        unifact := [dd*unifact.i for i in 1..nfact]
        um := ((dd**(nfact-1)::NNI)::P)*um
      (ffin:= lifting(um,lvar,unifact,lval,lpol,ldeg,pM(unifact)))
           case "failed" => intfact(um,lvar,ldeg,tleadpol,ltry)
      factfin: L SUP P:=ffin :: L SUP P
      if dd^=1 then
        factfin:=[primitivePart ff  for ff in  factfin]
      factfin

-- the following functions are used to "push" x in the coefficient ring -
               ----  push back the variable  ----
    pushup(f:P,x:OV) :PG ==
       ground? f => pushupconst((retract f)@R,x)
       rr:PG:=0
       while f^=0 repeat
         lf:=leadingMonomial f
         cf:=pushupconst(leadingCoefficient f,x)
         lvf:=variables lf
         rr:=rr+monomial(cf,lvf, degree(lf,lvf))$PG
         f:=reductum f
       rr

        ----  push x in the coefficient domain for a polynomial ----
    pushdown(g:PG,x:OV) : P ==
       ground? g => ((retract g)@F)::R::P
       rf:P:=0$P
       ug:=univariate(g,x)
       while ug^=0 repeat
         cf:=monomial(1,degree ug)$R
         rf:=rf+cf*pushdcoef(leadingCoefficient ug)
         ug := reductum ug
       rf

      ----  push x back from the coefficient domain ----
    pushupconst(r:R,x:OV):PG ==
       ground? r => (retract r)@F ::PG
       rr:PG:=0
       while r^=0 repeat
         rr:=rr+monomial((leadingCoefficient r)::PG,x,degree r)$PG
         r:=reductum r
       rr

    -- This function has to be added to Eucliden domain
    ran(k1:Z) : R ==
      --if R case Integer then random()$R rem (2*k1)-k1
      --else
      +/[monomial(random()$F,i)$R for i in 0..k1]

    checkzero(u:SUP P,um:SUP R) : Boolean ==
      u=0 => um =0
      um = 0 => false
      degree u = degree um => checkzero(reductum u, reductum um)
      false

              ---  Choose the variable of least degree  ---
    varChoose(m:P,lvar:L OV,ldeg:L NNI) : NewOrd ==
      k:="min"/[d for d in ldeg]
      k=degree(m,first lvar) =>
                             [univariate(m,first lvar),lvar,ldeg]$NewOrd
      i:=position(k,ldeg)
      x:OV:=lvar.i
      ldeg:=cons(k,delete(ldeg,i))
      lvar:=cons(x,delete(lvar,i))
      [univariate(m,x),lvar,ldeg]$NewOrd


    norm(lum: L SUP R): Integer == "max"/[degree lup for lup in lum]

          ---  Choose the values to reduce to the univariate case  ---
    intChoose(um:SUP P,lvar:L OV,clc:R,plist:L P,ltry:L L R) : Valuf ==
      -- declarations
      degum:NNI := degree um
      nvar1:=#lvar
      range:NNI:=0
      unifact:L SUP R
      ctf1 : R := 1
      testp:Boolean :=             -- polynomial leading coefficient
        plist = empty() => false
        true
      leadcomp,leadcomp1 : L R
      leadcomp:=leadcomp1:=empty()
      nfatt:NNI := degum+1
      lffc:R:=1
      lffc1:=lffc
      newunifact : L SUP R:=empty()
      leadtest:=true --- the lc test with polCase has to be performed
      int:L R:=empty()

   --  New sets of values are chosen until we find twice the
   --  same number of "univariate" factors:the set smaller in modulo is
   --  is chosen.
      while true repeat
       lval := [ ran(range) for i in 1..nvar1]
       member?(lval,ltry) => range:=1+range
       ltry := cons(lval,ltry)
       leadcomp1:=[retract eval(pol,lvar,lval) for pol in plist]
       testp and or/[unit? epl for epl in leadcomp1] => range:=range+1
       newm:SUP R:=completeEval(um,lvar,lval)
       degum ^= degree newm or minimumDegree newm ^=0 => range:=range+1
       lffc1:=content newm
       newm:=(newm exquo lffc1)::SUP R
       testp and leadtest and ^ polCase(lffc1*clc,#plist,leadcomp1)
                           => range:=range+1
       Dnewm := differentiate newm
       D2newm := map(differentiate, newm)
       degree(gcd [newm,Dnewm,D2newm])^=0 => range:=range+1
      -- if R has Integer then luniv:=henselFact(newm,false)$
      -- else
       lcnm:F:=1
        -- should be unitNormal if unified, but for now it is easier
       if (lcnm:=leadingCoefficient leadingCoefficient newm)^=1 then
         newm:=((inv lcnm)::R)*newm
       dx:="max"/[degree uc  for uc in coefficients newm]
       luniv:=generalTwoFactor(newm)$TwoFactorize(F)
       lunivf:= factors luniv
       nf:= #lunivf

       nf=0 or nf>nfatt => "next values"      ---  pretest failed ---

                        --- the univariate polynomial is irreducible ---
       if nf=1 then leave (unifact:=[newm])

       lffc1:=lcnm * retract(unit luniv)@R * lffc1

   --  the new integer give the same number of factors
       nfatt = nf =>
       -- if this is the first univariate factorization with polCase=true
       -- or if the last factorization has smaller norm and satisfies
       -- polCase
         if leadtest or
           ((norm unifact > norm [ff.factor for ff in lunivf]) and
             (^testp or polCase(lffc1*clc,#plist,leadcomp1))) then
                unifact:=[uf.factor for uf in lunivf]
                int:=lval
                lffc:=lffc1
                if testp then leadcomp:=leadcomp1
         leave "foundit"

   --  the first univariate factorization, inizialize
       nfatt > degum =>
         unifact:=[uf.factor for uf in lunivf]
         lffc:=lffc1
         if testp then leadcomp:=leadcomp1
         int:=lval
         leadtest := false
         nfatt := nf

       nfatt>nf =>  -- for the previous values there were more factors
         if testp then leadtest:=^polCase(lffc*clc,#plist,leadcomp)
         else leadtest:= false
         -- if polCase=true we can consider the univariate decomposition
         if ^leadtest then
           unifact:=[uf.factor for uf in lunivf]
           lffc:=lffc1
           if testp then leadcomp:=leadcomp1
           int:=lval
         nfatt := nf
      [cons(int,ltry),unifact,lffc,leadcomp]$Valuf


    constantCase(m:P,factorlist:List MParFact) : MFinalFact ==
    --if R case Integer then [const m,factorlist]$MFinalFact
    --else
      lunm:=distdfact((retract m)@R,false)$DistinctDegreeFactorize(F,R)
      [(lunm.cont)::R, append(factorlist,
           [[(pp.irr)::P,pp.pow] for pp in lunm.factors])]$MFinalFact

                ----  The polynomial has mindeg>0   ----

    simplify(m:P,dm:Z,lvar:L OV,lmdeg:L NNI):MFinalFact ==
      factorlist:L MParFact:=empty()
      pol1:P:= 1$P
      for x in lvar repeat
        i := lmdeg.(position(x,lvar))
        i=0 => "next value"
        pol1:=pol1*monomial(1$P,x,i)
        factorlist:=cons([x::P,i]$MParFact,factorlist)
      m := (m exquo pol1)::P
      ground? m => constantCase(m,factorlist)
      flead:=mFactor(m,dm)
      flead.factors:=append(factorlist,flead.factors)
      flead

                ----  m square-free,primitive,lc constant  ----
    mfconst(um:SUP P,dm:Z,lvar:L OV,ldeg:L NNI):L SUP P ==
      nsign:Boolean
      factfin:L SUP P:=empty()
      empty? lvar =>
          um1:SUP R:=map(ground,
              um)$UPCF2(P,SUP P,R,SUP R)
          lum:= generalTwoFactor(um1)$TwoFactorize(F)
          [map(coerce,lumf.factor)$UPCF2(R,SUP R,P,SUP P)
                for lumf in factors lum]
      intfact(um,lvar,ldeg,[0,empty()]$MFinalFact,empty())

              --- m is square-free,primitive,lc is a polynomial  ---
    mfpol(um:SUP P,dm:Z,lvar:L OV,ldeg:L NNI):L SUP P ==
      dist : LeadFact
      tleadpol:=mFactor(leadingCoefficient um,dm)
      intfact(um,lvar,ldeg,tleadpol,empty())

    factor(m:PG):Factored PG ==
       lv:=variables m
       lv=empty() => makeFR(m,empty() )
    -- reduce to multivariate over SUP
       ld:=[degree(m,x) for x in lv]
       dx:="min"/ld
       basicVar:=lv(position(dx,ld))
       cm:=pushdown(m,basicVar)
       flist := mFactor(cm,dx)
       pushupconst(flist.contp,basicVar) *
          (*/[primeFactor(pushup(u.irr,basicVar),u.pow)
                                                 for u in flist.factors])

@
<<MFINFACT.dotabb>>=
"MFINFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MFINFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MFINFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MMAP MultipleMap}
\pagehead{MultipleMap}{MMAP}
\pagepic{ps/v104multiplemap.ps}{MMAP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MMAP MultipleMap>>=
)abbrev package MMAP MultipleMap
++ Lifting a map through 2 levels of polynomials
++ Author: Manuel Bronstein
++ Date Created: May 1988
++ Date Last Updated: 11 Jul 1990
++ Description: Lifting of a map through 2 levels of polynomials;
MultipleMap(R1,UP1,UPUP1,R2,UP2,UPUP2): Exports == Implementation where
  R1   : IntegralDomain
  UP1  : UnivariatePolynomialCategory R1
  UPUP1: UnivariatePolynomialCategory Fraction UP1
  R2   : IntegralDomain
  UP2  : UnivariatePolynomialCategory R2
  UPUP2: UnivariatePolynomialCategory Fraction UP2

  Q1 ==> Fraction UP1
  Q2 ==> Fraction UP2

  Exports ==> with
    map: (R1 -> R2, UPUP1) -> UPUP2
      ++ map(f, p) lifts f to the domain of p then applies it to p.

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R1, UP1, R2, UP2)

    rfmap: (R1 -> R2, Q1) -> Q2

    rfmap(f, q) == map(f, numer q) / map(f, denom q)

    map(f, p) ==
      map(rfmap(f, #1),
          p)$UnivariatePolynomialCategoryFunctions2(Q1, UPUP1, Q2, UPUP2)

@
<<MMAP.dotabb>>=
"MMAP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MMAP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MMAP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MCALCFN MultiVariableCalculusFunctions}
\pagehead{MultiVariableCalculusFunctions}{MCALCFN}
\pagepic{ps/v104multivariablecalculusfunctions.ps}{MCALCFN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MCALCFN MultiVariableCalculusFunctions>>=
)abbrev package MCALCFN MultiVariableCalculusFunctions
++ Author: Themos Tsikas, Grant Keady
++ Date Created: December 1992
++ Date Last Updated: June 1993
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++  \spadtype{MultiVariableCalculusFunctions} Package provides several
++  functions for multivariable calculus.
++ These include gradient, hessian and jacobian,
++ divergence and laplacian.
++ Various forms for banded and sparse storage of matrices are
++ included.
MultiVariableCalculusFunctions(S,F,FLAF,FLAS) : Exports == Implementation where
  PI ==> PositiveInteger
  NNI ==> NonNegativeInteger

  S: SetCategory
  F: PartialDifferentialRing(S)
  FLAS: FiniteLinearAggregate(S)
    with finiteAggregate
  FLAF: FiniteLinearAggregate(F)

  Exports ==> with
    gradient: (F,FLAS) -> Vector F
     ++ \spad{gradient(v,xlist)}
     ++ computes the gradient, the vector of first partial derivatives,
     ++ of the scalar field v,
     ++ v a function of the variables listed in xlist.
    divergence: (FLAF,FLAS) ->  F
     ++ \spad{divergence(vf,xlist)}
     ++ computes the divergence of the vector field vf,
     ++ vf a vector function of the variables listed in xlist.
    laplacian: (F,FLAS) -> F
     ++ \spad{laplacian(v,xlist)}
     ++ computes the laplacian of the scalar field v,
     ++ v a function of the variables listed in xlist.
    hessian: (F,FLAS) -> Matrix F
     ++ \spad{hessian(v,xlist)}
     ++ computes the hessian, the matrix of second partial derivatives,
     ++ of the scalar field v,
     ++ v a function of the variables listed in xlist.
    bandedHessian: (F,FLAS,NNI) -> Matrix F
     ++ \spad{bandedHessian(v,xlist,k)}
     ++ computes the hessian, the matrix of second partial derivatives,
     ++ of the scalar field v,
     ++ v a function of the variables listed in xlist,
     ++ k is the semi-bandwidth, the number of nonzero subdiagonals,
     ++ 2*k+1 being actual bandwidth.
     ++ Stores the nonzero band in lower triangle in a matrix, 
     ++ dimensions k+1 by #xlist,
     ++ whose rows are the vectors formed by diagonal, subdiagonal, etc.
     ++ of the real, full-matrix, hessian.
     ++ (The notation conforms to LAPACK/NAG-F07 conventions.)
    -- At one stage it seemed a good idea to help the ASP<n> domains
    -- with the types of their input arguments and this led to the
    -- standard Gradient|Hessian|Jacobian functions.
    --standardJacobian: (Vector(F),List(S)) -> Matrix F
    -- ++ \spad{jacobian(vf,xlist)}
    -- ++ computes the jacobian, the matrix of first partial derivatives,
    -- ++ of the vector field vf,
    -- ++ vf a vector function of the variables listed in xlist.
    jacobian: (FLAF,FLAS) -> Matrix F
     ++ \spad{jacobian(vf,xlist)}
     ++ computes the jacobian, the matrix of first partial derivatives,
     ++ of the vector field vf,
     ++ vf a vector function of the variables listed in xlist.
    bandedJacobian: (FLAF,FLAS,NNI,NNI) -> Matrix F
     ++ \spad{bandedJacobian(vf,xlist,kl,ku)}
     ++ computes the jacobian, the matrix of first partial derivatives,
     ++ of the vector field vf,
     ++ vf a vector function of the variables listed in xlist,
     ++ kl is the number of nonzero subdiagonals,
     ++ ku is the number of nonzero superdiagonals,
     ++ kl+ku+1 being actual bandwidth.
     ++ Stores the nonzero band in a matrix, 
     ++ dimensions kl+ku+1 by #xlist.
     ++ The upper triangle is in the top ku rows,
     ++ the diagonal is in row ku+1,
     ++ the lower triangle in the last kl rows.
     ++ Entries in a column in the band store correspond to entries
     ++ in same column of full store.
     ++ (The notation conforms to LAPACK/NAG-F07 conventions.)

  Implementation ==> add
    localGradient(v:F,xlist:List(S)):Vector(F) ==
       vector([D(v,x) for x in xlist])
    gradient(v,xflas) ==
       --xlist:List(S) := [xflas(i) for i in 1 .. maxIndex(xflas)]
       xlist:List(S) := parts(xflas)
       localGradient(v,xlist)
    localDivergence(vf:Vector(F),xlist:List(S)):F ==
       i: PI
       n: NNI
       ans: F
       -- Perhaps should report error if two args of min different
       n:= min(#(xlist),((maxIndex(vf))::NNI))$NNI
       ans:= 0
       for i in 1 .. n repeat ans := ans + D(vf(i),xlist(i)) 
       ans
    divergence(vf,xflas) ==
       xlist:List(S) := parts(xflas)
       i: PI
       n: NNI
       ans: F
       -- Perhaps should report error if two args of min different
       n:= min(#(xlist),((maxIndex(vf))::NNI))$NNI
       ans:= 0
       for i in 1 .. n repeat ans := ans + D(vf(i),xlist(i)) 
       ans
    laplacian(v,xflas) ==
       xlist:List(S) := parts(xflas)
       gv:Vector(F) := localGradient(v,xlist)
       localDivergence(gv,xlist)
    hessian(v,xflas) ==
       xlist:List(S) := parts(xflas)
       matrix([[D(v,[x,y]) for x in xlist] for y in xlist])
    --standardJacobian(vf,xlist) ==
    --   i: PI
    --   matrix([[D(vf(i),x) for x in xlist] for i in 1 .. maxIndex(vf)])
    jacobian(vf,xflas) ==
       xlist:List(S) := parts(xflas)
       i: PI
       matrix([[D(vf(i),x) for x in xlist] for i in 1 .. maxIndex(vf)])
    bandedHessian(v,xflas,k) ==
       xlist:List(S) := parts(xflas)
       j,iw: PI
       n: NNI
       bandM: Matrix F
       n:= #(xlist)
       bandM:= new(k+1,n,0)
       for j in 1 .. n repeat setelt(bandM,1,j,D(v,xlist(j),2))
       for iw in 2 .. (k+1) repeat (_
         for j in 1 .. (n-iw+1) repeat (_
           setelt(bandM,iw,j,D(v,[xlist(j),xlist(j+iw-1)])) ) )
       bandM
    jacobian(vf,xflas) ==
       xlist:List(S) := parts(xflas)
       i: PI
       matrix([[D(vf(i),x) for x in xlist] for i in 1 .. maxIndex(vf)])
    bandedJacobian(vf,xflas,kl,ku) ==
       xlist:List(S) := parts(xflas)
       j,iw: PI
       n: NNI
       bandM: Matrix F
       n:= #(xlist)
       bandM:= new(kl+ku+1,n,0)
       for j in 1 .. n repeat setelt(bandM,ku+1,j,D(vf(j),xlist(j)))
       for iw in (ku+2) .. (ku+kl+1) repeat (_
         for j in 1 .. (n-iw+ku+1) repeat (_
           setelt(bandM,iw,j,D(vf(j+iw-1-ku),xlist(j))) ) )
       for iw in 1 .. ku repeat (_
         for j in (ku+2-iw) .. n repeat (_
           setelt(bandM,iw,j,D(vf(j+iw-1-ku),xlist(j))) ) )
       bandM

@
<<MCALCFN.dotabb>>=
"MCALCFN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MCALCFN"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"MCALCFN" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MULTFACT MultivariateFactorize}
\pagehead{MultivariateFactorize}{MULTFACT}
\pagepic{ps/v104multivariatefactorize.ps}{MULTFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MULTFACT MultivariateFactorize>>=
)abbrev package MULTFACT MultivariateFactorize
++ Author: P. Gianni
++ Date Created: 1983
++ Date Last Updated: Sept. 1990
++ Basic Functions:
++ Related Constructors: MultFiniteFactorize, AlgebraicMultFact, UnivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This is the top level package for doing multivariate factorization
++ over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.

MultivariateFactorize(OV,E,R,P) : C == T
 where
  R          :   Join(EuclideanDomain, CharacteristicZero)
                    -- with factor on R[x]
  OV         :   OrderedSet
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(R,E,OV)
  Z            ==> Integer
  MParFact     ==> Record(irr:P,pow:Z)
  USP          ==> SparseUnivariatePolynomial P
  SUParFact    ==> Record(irr:USP,pow:Z)
  SUPFinalFact ==> Record(contp:R,factors:List SUParFact)
  MFinalFact   ==> Record(contp:R,factors:List MParFact)
 
                 --  contp   =  content,
                 --  factors =  List of irreducible factors with exponent
  L          ==> List

  C == with
    factor      :      P  ->  Factored P
      ++ factor(p) factors the multivariate polynomial p over its coefficient
      ++ domain
    factor      :      USP  ->  Factored USP
      ++ factor(p) factors the multivariate polynomial p over its coefficient
      ++ domain where p is represented as a univariate polynomial with
      ++ multivariate coefficients
  T == add
    factor(p:P) : Factored P ==
      R is Fraction Integer =>
         factor(p)$MRationalFactorize(E,OV,Integer,P)
      R is Fraction Complex Integer =>
         factor(p)$MRationalFactorize(E,OV,Complex Integer,P)
      R is Fraction Polynomial Integer and OV has convert: % -> Symbol =>
         factor(p)$MPolyCatRationalFunctionFactorizer(E,OV,Integer,P)
      factor(p,factor$GenUFactorize(R))$InnerMultFact(OV,E,R,P)

    factor(up:USP) : Factored USP ==
      factor(up,factor$GenUFactorize(R))$InnerMultFact(OV,E,R,P)

@
<<MULTFACT.dotabb>>=
"MULTFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MULTFACT"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"MULTFACT" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MLIFT MultivariateLifting}
<<package MLIFT MultivariateLifting>>=
)abbrev package MLIFT MultivariateLifting
++ Author : P.Gianni.
++ Description: 
++ This package provides the functions for the multivariate "lifting", using
++ an algorithm of Paul Wang.
++ This package will work for every euclidean domain R which has property
++ F, i.e. there exists a factor operation in \spad{R[x]}.
 
MultivariateLifting(E,OV,R,P) : C == T
 where
  OV        :   OrderedSet
  E         :   OrderedAbelianMonoidSup
  R         :   EuclideanDomain  -- with property "F"
  Z         ==> Integer
  BP        ==> SparseUnivariatePolynomial R
  P         :   PolynomialCategory(R,E,OV)
  SUP       ==> SparseUnivariatePolynomial P
  NNI       ==> NonNegativeInteger
  Term      ==> Record(expt:NNI,pcoef:P)
  VTerm     ==> List Term
  Table     ==> Vector List BP
  L         ==> List
 
  C == with
    corrPoly:      (SUP,L OV,L R,L NNI,L SUP,Table,R) -> Union(L SUP,"failed")
	++ corrPoly(u,lv,lr,ln,lu,t,r) \undocumented
    lifting:       (SUP,L OV,L BP,L R,L P,L NNI,R) -> Union(L SUP,"failed")
	++ lifting(u,lv,lu,lr,lp,ln,r) \undocumented
    lifting1:      (SUP,L OV,L SUP,L R,L P,L VTerm,L NNI,Table,R) ->
                                                Union(L SUP,"failed")
	++ lifting1(u,lv,lu,lr,lp,lt,ln,t,r) \undocumented
 
  T == add
    GenExEuclid(R,BP)
    NPCoef(BP,E,OV,R,P)
    IntegerCombinatoricFunctions(Z)

    SUPF2   ==> SparseUnivariatePolynomialFunctions2

    DetCoef ==> Record(deter:L SUP,dterm:L VTerm,nfacts:L BP,
                       nlead:L P)
 
              ---   local functions   ---
    normalDerivM    :    (P,Z,OV)     ->  P
    normalDeriv     :     (SUP,Z)     ->  SUP
    subslead        :     (SUP,P)     ->  SUP
    subscoef        :   (SUP,L Term)  ->  SUP
    maxDegree       :   (SUP,OV)      ->  NonNegativeInteger
 
 
    corrPoly(m:SUP,lvar:L OV,fval:L R,ld:L NNI,flist:L SUP,
             table:Table,pmod:R):Union(L SUP,"failed") ==
      --  The correction coefficients are evaluated recursively.
      --   Extended Euclidean algorithm for the multivariate case.
 
      -- the polynomial is univariate  --
      #lvar=0 =>
        lp:=solveid(map(ground,m)$SUPF2(P,R),pmod,table)
        if lp case "failed" then return "failed"
        lcoef:= [map(coerce,mp)$SUPF2(R,P) for mp in lp::L BP]
 
 
      diff,ddiff,pol,polc:SUP
      listpolv,listcong:L SUP
      deg1:NNI:= ld.first
      np:NNI:= #flist
      a:P:= fval.first ::P
      y:OV:=lvar.first
      lvar:=lvar.rest
      listpolv:L SUP := [map(eval(#1,y,a),f1) for f1 in flist]
      um:=map(eval(#1,y,a),m)
      flcoef:=corrPoly(um,lvar,fval.rest,ld.rest,listpolv,table,pmod)
      if flcoef case "failed" then return "failed"
      else lcoef:=flcoef :: L SUP
      listcong:=[*/[flist.i for i in 1..np | i^=l] for l in 1..np]
      polc:SUP:= (monomial(1,y,1) - a)::SUP
      pol := 1$SUP
      diff:=m- +/[lcoef.i*listcong.i for i in 1..np]
      for l in 1..deg1 repeat
        if diff=0 then return lcoef
        pol := pol*polc
        (ddiff:= map(eval(normalDerivM(#1,l,y),y,a),diff)) = 0 => "next l"
        fbeta := corrPoly(ddiff,lvar,fval.rest,ld.rest,listpolv,table,pmod)
        if fbeta case "failed" then return "failed"
        else beta:=fbeta :: L SUP
        lcoef := [lcoef.i+beta.i*pol  for i in 1..np]
        diff:=diff- +/[listcong.i*beta.i for i in 1..np]*pol
      lcoef
 
 
 
    lifting1(m:SUP,lvar:L OV,plist:L SUP,vlist:L R,tlist:L P,_
      coeflist:L VTerm,listdeg:L NNI,table:Table,pmod:R) :Union(L SUP,"failed") ==
    -- The factors of m (multivariate) are determined ,
    -- We suppose to know the true univariate factors
    -- some coefficients are determined
      conglist:L SUP:=empty()
      nvar : NNI:= #lvar
      pol,polc:P
      mc,mj:SUP
      testp:Boolean:= (not empty?(tlist))
      lalpha : L SUP := empty()
      tlv:L P:=empty()
      subsvar:L OV:=empty()
      subsval:L R:=empty()
      li:L OV := lvar
      ldeg:L NNI:=empty()
      clv:L VTerm:=empty()
      --j =#variables, i=#factors
      for j in 1..nvar repeat
        x  := li.first
        li := rest li
        conglist:= plist
        v := vlist.first
        vlist := rest vlist
        degj := listdeg.j
        ldeg := cons(degj,ldeg)
        subsvar:=cons(x,subsvar)
        subsval:=cons(v,subsval)
 
      --substitute the determined coefficients
        if testp then
          if j<nvar then
            tlv:=[eval(p,li,vlist) for p in tlist]
            clv:=[[[term.expt,eval(term.pcoef,li,vlist)]$Term
                   for term in clist] for clist  in coeflist]
          else (tlv,clv):=(tlist,coeflist)
          plist :=[subslead(p,lcp) for p in plist for lcp in tlv]
          if not(empty? coeflist) then
            plist:=[subscoef(tpol,clist)
                   for tpol in plist for clist in clv]
        mj := map(eval(#1,li,vlist),m)  --m(x1,..,xj,aj+1,..,an
        polc := x::P - v::P  --(xj-aj)
        pol:= 1$P
      --Construction of Rik, k in 1..right degree for xj+1
        for k in 1..degj repeat  --I can exit before
         pol := pol*polc
         mc := */[term for term in plist]-mj
         if mc=0 then leave "next var"
         --Modulus Dk
         mc:=map(normalDerivM(#1,k,x),mc)
         (mc := map(eval(#1,[x],[v]),mc))=0 => "next k"
         flalpha:=corrPoly(mc,subsvar.rest,subsval.rest,
                          ldeg.rest,conglist,table,pmod)
         if flalpha case "failed" then return "failed"
         else lalpha:=flalpha :: L SUP
         plist:=[term-alpha*pol for term in plist for alpha in lalpha]
        -- PGCD may call with a smaller valure of degj
        idegj:Integer:=maxDegree(m,x)
        for term in plist repeat idegj:=idegj -maxDegree(term,x)
        idegj < 0 => return "failed"
      plist
        --There are not extraneous factors
 
    maxDegree(um:SUP,x:OV):NonNegativeInteger ==
       ans:NonNegativeInteger:=0
       while um ^= 0 repeat  
          ans:=max(ans,degree(leadingCoefficient um,x))
          um:=reductum um    
       ans                   
                         
    lifting(um:SUP,lvar:L OV,plist:L BP,vlist:L R,
            tlist:L P,listdeg:L NNI,pmod:R):Union(L SUP,"failed") ==
    -- The factors of m (multivariate) are determined, when the
    --  univariate true factors are known and some coefficient determined
      nplist:List SUP:=[map(coerce,pp)$SUPF2(R,P) for pp in plist]
      empty? tlist =>
        table:=tablePow(degree um,pmod,plist)
        table case "failed" => error "Table construction failed in MLIFT"
        lifting1(um,lvar,nplist,vlist,tlist,empty(),listdeg,table,pmod)
      ldcoef:DetCoef:=npcoef(um,plist,tlist)
      if not empty?(listdet:=ldcoef.deter) then
        if #listdet = #plist  then return listdet
        plist:=ldcoef.nfacts
        nplist:=[map(coerce,pp)$SUPF2(R,P) for pp in plist]
        um:=(um exquo */[pol for pol in listdet])::SUP
        tlist:=ldcoef.nlead
        tab:=tablePow(degree um,pmod,plist.rest)
      else tab:=tablePow(degree um,pmod,plist)
      tab case "failed" => error "Table construction failed in MLIFT"
      table:Table:=tab
      ffl:=lifting1(um,lvar,nplist,vlist,tlist,ldcoef.dterm,listdeg,table,pmod)
      if ffl case "failed" then return "failed"
      append(listdet,ffl:: L SUP)

    -- normalDerivM(f,m,x) = the normalized (divided by m!) m-th
    -- derivative with respect to x of the multivariate polynomial f
    normalDerivM(g:P,m:Z,x:OV) : P ==
     multivariate(normalDeriv(univariate(g,x),m),x)

    normalDeriv(f:SUP,m:Z) : SUP ==
     (n1:Z:=degree f) < m => 0$SUP
     n1=m => leadingCoefficient f :: SUP
     k:=binomial(n1,m)
     ris:SUP:=0$SUP
     n:Z:=n1
     while n>= m repeat
       while n1>n repeat
         k:=(k*(n1-m)) quo n1
         n1:=n1-1
       ris:=ris+monomial(k*leadingCoefficient f,(n-m)::NNI)
       f:=reductum f
       n:=degree f
     ris

    subslead(m:SUP,pol:P):SUP ==
      dm:NNI:=degree m
      monomial(pol,dm)+reductum m
 
    subscoef(um:SUP,lterm:L Term):SUP ==
      dm:NNI:=degree um
      new:=monomial(leadingCoefficient um,dm)
      for k in dm-1..0 by -1 repeat
        i:NNI:=k::NNI
        empty?(lterm) or lterm.first.expt^=i =>
                                new:=new+monomial(coefficient(um,i),i)
        new:=new+monomial(lterm.first.pcoef,i)
        lterm:=lterm.rest
      new

@
<<MLIFT.dotabb>>=
"MLIFT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MLIFT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MLIFT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MULTSQFR MultivariateSquareFree}
\pagehead{MultivariateSquareFree}{MULTSQFR}
\pagepic{ps/v104multivariatesquarefree.ps}{MULTSQFR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MULTSQFR MultivariateSquareFree>>=
)abbrev package MULTSQFR MultivariateSquareFree
++ Author : P.Gianni
++ This package provides the functions for the computation of the square
++ free decomposition of a multivariate polynomial.
++ It uses the package GenExEuclid for the resolution of
++ the equation \spad{Af + Bg = h} and its generalization to n polynomials
++ over an integral domain and the package \spad{MultivariateLifting}
++ for the "multivariate" lifting.
 
MultivariateSquareFree (E,OV,R,P) : C == T where
 Z   ==> Integer
 NNI ==> NonNegativeInteger
 R   : EuclideanDomain
 OV  : OrderedSet
 E   : OrderedAbelianMonoidSup
 P   : PolynomialCategory(R,E,OV)
 SUP ==> SparseUnivariatePolynomial P
 
 BP          ==> SparseUnivariatePolynomial(R)
 fUnion      ==> Union("nil","sqfr","irred","prime")
 ffSUP       ==> Record(flg:fUnion,fctr:SUP,xpnt:Integer)
 ffP         ==> Record(flg:fUnion,fctr:P,xpnt:Integer)
 FFE         ==> Record(factor:BP,exponent:Z)
 FFEP        ==> Record(factor:P,exponent:Z)
 FFES        ==> Record(factor:SUP,exponent:Z)
 Choice      ==> Record(upol:BP,Lval:List(R),Lfact:List FFE,ctpol:R)
 squareForm  ==> Record(unitPart:P,suPart:List FFES)
 Twopol      ==> Record(pol:SUP,polval:BP)
 UPCF2       ==> UnivariatePolynomialCategoryFunctions2

 
 C == with
   squareFree      :      P     -> Factored P
     ++ squareFree(p) computes the square free 
     ++ decomposition of a multivariate polynomial p.
   squareFree      :      SUP     -> Factored SUP
     ++ squareFree(p) computes the square free 
     ++ decomposition of a multivariate polynomial p presented as
     ++ a univariate polynomial with multivariate coefficients.
   squareFreePrim :      P     -> Factored P
     ++ squareFreePrim(p) compute the square free decomposition 
     ++ of a primitive multivariate polynomial p.


 
                    ----  local functions  ----
   compdegd   :             List FFE                   -> Z
	++ compdegd should be local
   univcase   :              (P,OV)                    -> Factored(P)
	++ univcase should be local
   consnewpol :            (SUP,BP,Z)                  -> Twopol
	++ consnewpol should be local
   nsqfree    :           (SUP,List(OV), List List R)  -> squareForm
	++ nsqfree should be local
   intChoose  :           (SUP,List(OV),List List R)   -> Choice
	++ intChoose should be local
   coefChoose :           (Z,Factored P)               -> P
	++ coefChoose should be local
   check      :     (List(FFE),List(FFE))              -> Boolean
	++ check should be local
   lift       : (SUP,BP,BP,P,List(OV),List(NNI),List(R)) -> Union(List(SUP),"failed")
	++ lift should be local
   myDegree   :       (SUP,List OV,NNI)                -> List NNI
	++ myDegree should be local
   normDeriv2 :            (BP,Z)                      ->  BP
	++ normDeriv2 should be local


 
 T == add
 
   pmod:R   :=  (prevPrime(2**26)$IntegerPrimesPackage(Integer))::R
 
 
   import GenExEuclid()
   import MultivariateLifting(E,OV,R,P)
   import PolynomialGcdPackage(E,OV,R,P)
   import FactoringUtilities(E,OV,R,P)
   import IntegerCombinatoricFunctions(Z)
 
 
    ----  Are the univariate square-free decompositions consistent?  ----
 
     ----  new square-free algorithm for primitive polynomial  ----
   nsqfree(oldf:SUP,lvar:List(OV),ltry:List List R) : squareForm ==
     f:=oldf
     univPol := intChoose(f,lvar,ltry)
--     debug msg
--     if not empty? ltry then output("ltry =", (ltry::OutputForm))$OutputPackage
     f0:=univPol.upol
     --the polynomial is square-free
     f0=1$BP => [1$P,[[f,1]$FFES]]$squareForm
     lfact:List(FFE):=univPol.Lfact
     lval:=univPol.Lval
     ctf:=univPol.ctpol
     leadpol:Boolean:=false
     sqdec:List FFES := empty()
     exp0:Z:=0
     unitsq:P:=1
     lcf:P:=leadingCoefficient f
     if ctf^=1 then
       f0:=ctf*f0
       f:=(ctf::P)*f
       lcf:=ctf*lcf
     sqlead:List FFEP:= empty()
     sqlc:Factored P:=1
     if lcf^=1$P then
       leadpol:=true
       sqlc:=squareFree lcf
       unitsq:=unitsq*(unit sqlc)
       sqlead:= factors sqlc
     lfact:=sort(#1.exponent > #2.exponent,lfact)
     while lfact^=[] repeat
       pfact:=lfact.first
       (g0,exp0):=(pfact.factor,pfact.exponent)
       lfact:=lfact.rest
       lfact=[] and exp0 =1 =>
         f := (f exquo (ctf::P))::SUP
         gg := unitNormal leadingCoefficient f
         sqdec:=cons([gg.associate*f,exp0],sqdec)
         return  [gg.unit, sqdec]$squareForm
       if ctf^=1 then g0:=ctf*g0
       npol:=consnewpol(f,f0,exp0)
       (d,d0):=(npol.pol,npol.polval)
       if leadpol then lcoef:=coefChoose(exp0,sqlc)
       else lcoef:=1$P
       ldeg:=myDegree(f,lvar,exp0::NNI)
       result:=lift(d,g0,(d0 exquo g0)::BP,lcoef,lvar,ldeg,lval)
       result case "failed" => return nsqfree(oldf,lvar,ltry)
       result0:SUP:= (result::List SUP).1
       r1:SUP:=result0**(exp0:NNI)
       if (h:=f exquo r1) case "failed" then return nsqfree(oldf,lvar,empty())
       sqdec:=cons([result0,exp0],sqdec)
       f:=h::SUP
       f0:=completeEval(h,lvar,lval)
       lcr:P:=leadingCoefficient result0
       if leadpol and lcr^=1$P then
         for lpfact in sqlead  while lcr^=1 repeat
           ground? lcr =>
             unitsq:=(unitsq exquo lcr)::P
             lcr:=1$P
           (h1:=lcr exquo lpfact.factor) case "failed" => "next"
           lcr:=h1::P
           lpfact.exponent:=(lpfact.exponent)-exp0
     [((retract f) exquo ctf)::P,sqdec]$squareForm

 
   squareFree(f:SUP) : Factored SUP ==
     degree f =0 =>
       fu:=squareFree retract f
       makeFR((unit fu)::SUP,[["sqfr",ff.fctr::SUP,ff.xpnt]
               for ff in factorList fu])
     lvar:= "setUnion"/[variables cf for cf in coefficients f]
     empty? lvar =>  -- the polynomial is univariate
       upol:=map(ground,f)$UPCF2(P,SUP,R,BP)
       usqfr:=squareFree upol
       makeFR(map(coerce,unit usqfr)$UPCF2(R,BP,P,SUP),
              [["sqfr",map(coerce,ff.fctr)$UPCF2(R,BP,P,SUP),ff.xpnt]
                 for ff in factorList usqfr])

     lcf:=content f
     f:=(f exquo lcf) ::SUP
     lcSq:=squareFree lcf
     lfs:List ffSUP:=[["sqfr",ff.fctr ::SUP,ff.xpnt]
                        for ff in factorList lcSq]
     partSq:=nsqfree(f,lvar,empty())

     lfs:=append([["sqfr",fu.factor,fu.exponent]$ffSUP
                    for fu in partSq.suPart],lfs)
     makeFR((unit lcSq * partSq.unitPart) ::SUP,lfs)

   squareFree(f:P) : Factored P ==
     ground? f => makeFR(f,[])      ---   the polynomial is constant  ---
 
     lvar:List(OV):=variables(f)
     result1:List ffP:= empty()

     lmdeg :=minimumDegree(f,lvar)     ---       is the mindeg > 0 ? ---
     p:P:=1$P
     for im in 1..#lvar repeat
       (n:=lmdeg.im)=0 => "next im"
       y:=lvar.im
       p:=p*monomial(1$P,y,n)
       result1:=cons(["sqfr",y::P,n],result1)
     if p^=1$P then
       f := (f exquo p)::P
       if ground? f then return makeFR(f, result1)
       lvar:=variables(f)
 
 
     #lvar=1 =>                    ---  the polynomial is univariate ---
       result:=univcase(f,lvar.first)
       makeFR(unit result,append(result1,factorList result))
 
     ldeg:=degree(f,lvar)          ---  general case ---
     m:="min"/[j for j in ldeg|j^=0]
     i:Z:=1
     for j in ldeg while j>m repeat i:=i+1
     x:=lvar.i
     lvar:=delete(lvar,i)
     f0:=univariate (f,x)
     lcont:P:= content f0
     nsqfftot:=nsqfree((f0 exquo lcont)::SUP,lvar,empty())
     nsqff:List ffP:=[["sqfr",multivariate(fu.factor,x),fu.exponent]$ffP
                          for fu in nsqfftot.suPart]
     result1:=append(result1,nsqff)
     ground? lcont => makeFR(lcont*nsqfftot.unitPart,result1)
     sqlead:=squareFree(lcont)
     makeFR(unit sqlead*nsqfftot.unitPart,append(result1,factorList sqlead))
 
  -- Choose the integer for the evaluation.                        --
  -- If the polynomial is square-free the function returns upol=1. --
 
   intChoose(f:SUP,lvar:List(OV),ltry:List List R):Choice ==
     degf:= degree f
     try:NNI:=0
     nvr:=#lvar
     range:Z:=10
     lfact1:List(FFE):=[]
     lval1:List R := []
     lfact:List(FFE)
     ctf1:R:=1
     f1:BP:=1$BP
     d1:Z
     while range<10000000000 repeat
       range:=2*range
       lval:= [ran(range) for i in 1..nvr]
       member?(lval,ltry) => "new integer"
       ltry:=cons(lval,ltry)
       f0:=completeEval(f,lvar,lval)
       degree f0 ^=degf  => "new integer"
       ctf:=content f0
       lfact:List(FFE):=factors(squareFree((f0 exquo (ctf:R)::BP)::BP))
 
            ----  the univariate polynomial is square-free  ----
       if #lfact=1 and (lfact.1).exponent=1 then
         return [1$BP,lval,lfact,1$R]$Choice
 
       d0:=compdegd lfact
                 ----      inizialize lfact1      ----
       try=0 =>
         f1:=f0
         lfact1:=lfact
         ctf1:=ctf
         lval1:=lval
         d1:=d0
         try:=1
       d0=d1 =>
         return [f1,lval1,lfact1,ctf1]$Choice
       d0 < d1 =>
         try:=1
         f1:=f0
         lfact1:=lfact
         ctf1:=ctf
         lval1:=lval
         d1:=d0
 
 
        ----  Choose the leading coefficient for the lifting  ----
   coefChoose(exp:Z,sqlead:Factored(P)) : P ==
     lcoef:P:=unit(sqlead)
     for term in factors(sqlead) repeat
       texp:=term.exponent
       texp<exp => "next term"
       texp=exp => lcoef:=lcoef*term.factor
       lcoef:=lcoef*(term.factor)**((texp quo exp)::NNI)
     lcoef
 
        ----  Construction of the polynomials for the lifting  ----
   consnewpol(g:SUP,g0:BP,deg:Z):Twopol ==
     deg=1 => [g,g0]$Twopol
     deg:=deg-1
     [normalDeriv(g,deg),normDeriv2(g0,deg)]$Twopol
 
         ----  lift the univariate square-free factor  ----
   lift(ud:SUP,g0:BP,g1:BP,lcoef:P,lvar:List(OV),
                        ldeg:List(NNI),lval:List(R)) : Union(List SUP,"failed") ==
     leadpol:Boolean:=false
     lcd:P:=leadingCoefficient ud
     leadlist:List(P):=empty()
 
     if ^ground?(leadingCoefficient ud) then
       leadpol:=true
       ud:=lcoef*ud
       lcg0:R:=leadingCoefficient g0
       if ground? lcoef then g0:=retract(lcoef) quo lcg0 *g0
       else g0:=(retract(eval(lcoef,lvar,lval)) quo lcg0) * g0
       g1:=lcg0*g1
       leadlist:=[lcoef,lcd]
     plist:=lifting(ud,lvar,[g0,g1],lval,leadlist,ldeg,pmod)
     plist case "failed" => "failed" 
     (p0:SUP,p1:SUP):=((plist::List SUP).1,(plist::List SUP).2)
     if completeEval(p0,lvar,lval) ^= g0 then (p0,p1):=(p1,p0)
     [primitivePart p0,primitivePart p1]

                ----  the polynomial is univariate  ----
   univcase(f:P,x:OV) : Factored(P) ==
     uf := univariate f
     cf:=content uf
     uf :=(uf exquo cf)::BP
     result:Factored BP:=squareFree uf
     makeFR(multivariate(cf*unit result,x),
         [["sqfr",multivariate(term.factor,x),term.exponent]
           for term in factors result])

--   squareFreePrim(p:P) : Factored P ==
--     -- p is content free
--     ground? p => makeFR(p,[])      ---   the polynomial is constant  ---
-- 
--     lvar:List(OV):=variables p
--     #lvar=1 =>                    ---  the polynomial is univariate ---
--       univcase(p,lvar.first)
--     nsqfree(p,lvar,1)
 
   compdegd(lfact:List(FFE)) : Z ==
     ris:Z:=0
     for pfact in lfact repeat
       ris:=ris+(pfact.exponent -1)*degree pfact.factor
     ris
 
   normDeriv2(f:BP,m:Z) : BP ==
     (n1:Z:=degree f) < m => 0$BP
     n1=m => (leadingCoefficient f)::BP
     k:=binomial(n1,m)
     ris:BP:=0$BP
     n:Z:=n1
     while n>= m repeat
       while n1>n repeat
         k:=(k*(n1-m)) quo n1
         n1:=n1-1
       ris:=ris+monomial(k*leadingCoefficient f,(n-m)::NNI)
       f:=reductum f
       n:=degree f
     ris

   myDegree(f:SUP,lvar:List OV,exp:NNI) : List NNI==
     [n quo exp for n in degree(f,lvar)]

@
<<MULTSQFR.dotabb>>=
"MULTSQFR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MULTSQFR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MULTSQFR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter N}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGF02 NagEigenPackage}
\pagehead{NagEigenPackage}{NAGF02}
\pagepic{ps/v104nageigenpackage.ps}{NAGF02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGF02 NagEigenPackage>>=
)abbrev package NAGF02 NagEigenPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:20 1994
++ Description:
++ This package uses the NAG Library to compute
++ \begin{items}
++ \item eigenvalues and eigenvectors of a matrix
++ \item eigenvalues and eigenvectors of generalized matrix
++ eigenvalue problems
++ \item singular values and singular vectors of a matrix.
++ \end{items}
++ See \downlink{Manual Page}{manpageXXf02}. 

NagEigenPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    f02aaf : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ f02aaf(ia,n,a,ifail)
     ++ calculates all the eigenvalue.
     ++ See \downlink{Manual Page}{manpageXXf02aaf}.
    f02abf : (Matrix DoubleFloat,Integer,Integer,Integer,_
	Integer) -> Result 
     ++ f02abf(a,ia,n,iv,ifail)
     ++ calculates all the eigenvalues of a real 
     ++ symmetric matrix.
     ++ See \downlink{Manual Page}{manpageXXf02abf}.
    f02adf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ f02adf(ia,ib,n,a,b,ifail)
     ++ calculates all the eigenvalues of  Ax=(lambda)Bx,  where A
     ++ is a real symmetric matrix and B is a real symmetric positive-
     ++ definite matrix.
     ++ See \downlink{Manual Page}{manpageXXf02adf}.
    f02aef : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f02aef(ia,ib,n,iv,a,b,ifail)
     ++ calculates all the eigenvalues of  
     ++ Ax=(lambda)Bx,  where A is a real symmetric matrix and B is a 
     ++ real symmetric positive-definite matrix.
     ++ See \downlink{Manual Page}{manpageXXf02aef}.
    f02aff : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ f02aff(ia,n,a,ifail)
     ++ calculates all the eigenvalues of a real unsymmetric 
     ++ matrix.
     ++ See \downlink{Manual Page}{manpageXXf02aff}.
    f02agf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ f02agf(ia,n,ivr,ivi,a,ifail)
     ++ calculates all the eigenvalues of a real 
     ++ unsymmetric matrix.
     ++ See \downlink{Manual Page}{manpageXXf02agf}.
    f02ajf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ f02ajf(iar,iai,n,ar,ai,ifail)
     ++ calculates all the eigenvalue.
     ++ See \downlink{Manual Page}{manpageXXf02ajf}.
    f02akf : (Integer,Integer,Integer,Integer,_
	Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f02akf(iar,iai,n,ivr,ivi,ar,ai,ifail)
     ++ calculates all the eigenvalues of a 
     ++ complex matrix.
     ++ See \downlink{Manual Page}{manpageXXf02akf}.
    f02awf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ f02awf(iar,iai,n,ar,ai,ifail)
     ++ calculates all the eigenvalues of a complex Hermitian 
     ++ matrix.
     ++ See \downlink{Manual Page}{manpageXXf02awf}.
    f02axf : (Matrix DoubleFloat,Integer,Matrix DoubleFloat,Integer,_
	Integer,Integer,Integer,Integer) -> Result 
     ++ f02axf(ar,iar,ai,iai,n,ivr,ivi,ifail)
     ++ calculates all the eigenvalues of a 
     ++ complex Hermitian matrix.
     ++ See \downlink{Manual Page}{manpageXXf02axf}.
    f02bbf : (Integer,Integer,DoubleFloat,DoubleFloat,_
	Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ f02bbf(ia,n,alb,ub,m,iv,a,ifail)
     ++ calculates selected eigenvalues of a real
     ++ symmetric matrix by reduction to tridiagonal form, bisection and 
     ++ inverse iteration, where the selected eigenvalues lie within a 
     ++ given interval.
     ++ See \downlink{Manual Page}{manpageXXf02bbf}.
    f02bjf : (Integer,Integer,Integer,DoubleFloat,_
	Boolean,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f02bjf(n,ia,ib,eps1,matv,iv,a,b,ifail)
     ++ calculates all the eigenvalues and, if required, all the 
     ++ eigenvectors of the generalized eigenproblem  Ax=(lambda)Bx   
     ++ where A and B are real, square matrices, using the QZ algorithm.
     ++ See \downlink{Manual Page}{manpageXXf02bjf}.
    f02fjf : (Integer,Integer,DoubleFloat,Integer,_
	Integer,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp27(DOT)),Union(fn:FileName,fp:Asp28(IMAGE))) -> Result 
     ++ f02fjf(n,k,tol,novecs,nrx,lwork,lrwork,liwork,m,noits,x,ifail,dot,image)
     ++ finds eigenvalues of a real sparse symmetric 
     ++ or generalized symmetric eigenvalue problem.
     ++ See \downlink{Manual Page}{manpageXXf02fjf}.
    f02fjf : (Integer,Integer,DoubleFloat,Integer,_
	Integer,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp27(DOT)),Union(fn:FileName,fp:Asp28(IMAGE)),FileName) -> Result 
     ++ f02fjf(n,k,tol,novecs,nrx,lwork,lrwork,liwork,m,noits,x,ifail,dot,image,monit)
     ++ finds eigenvalues of a real sparse symmetric 
     ++ or generalized symmetric eigenvalue problem.
     ++ See \downlink{Manual Page}{manpageXXf02fjf}.
    f02wef : (Integer,Integer,Integer,Integer,_
	Integer,Boolean,Integer,Boolean,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f02wef(m,n,lda,ncolb,ldb,wantq,ldq,wantp,ldpt,a,b,ifail)
     ++ returns all, or part, of the singular value decomposition 
     ++ of a general real matrix.
     ++ See \downlink{Manual Page}{manpageXXf02wef}.
    f02xef : (Integer,Integer,Integer,Integer,_
	Integer,Boolean,Integer,Boolean,Integer,Matrix Complex DoubleFloat,Matrix Complex DoubleFloat,Integer) -> Result 
     ++ f02xef(m,n,lda,ncolb,ldb,wantq,ldq,wantp,ldph,a,b,ifail)
     ++ returns all, or part, of the singular value decomposition 
     ++ of a general complex matrix.
     ++ See \downlink{Manual Page}{manpageXXf02xef}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Boolean)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Complex DoubleFloat)
    import AnyFunctions1(DoubleFloat)


    f02aaf(iaArg:Integer,nArg:Integer,aArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02aaf",_
	["ia"::S,"n"::S,"ifail"::S,"r"::S,"a"::S,"e"::S]$Lisp,_
	["r"::S,"e"::S]$Lisp,_
	[["double"::S,["r"::S,"n"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp_
	,["e"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["r"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02abf(aArg:Matrix DoubleFloat,iaArg:Integer,nArg:Integer,_
	ivArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02abf",_
	["ia"::S,"n"::S,"iv"::S,"ifail"::S,"a"::S,"r"::S,"v"::S,"e"::S]$Lisp,_
	["r"::S,"v"::S,"e"::S]$Lisp,_
	[["double"::S,["a"::S,"ia"::S,"n"::S]$Lisp_
	,["r"::S,"n"::S]$Lisp,["v"::S,"iv"::S,"n"::S]$Lisp,["e"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"iv"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["r"::S,"v"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ivArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02adf(iaArg:Integer,ibArg:Integer,nArg:Integer,_
	aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02adf",_
	["ia"::S,"ib"::S,"n"::S,"ifail"::S,"r"::S,"a"::S,"b"::S,"de"::S]$Lisp,_
	["r"::S,"de"::S]$Lisp,_
	[["double"::S,["r"::S,"n"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp_
	,["b"::S,"ib"::S,"n"::S]$Lisp,["de"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"ib"::S,"n"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["r"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,ibArg::Any,nArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02aef(iaArg:Integer,ibArg:Integer,nArg:Integer,_
	ivArg:Integer,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02aef",_
	["ia"::S,"ib"::S,"n"::S,"iv"::S,"ifail"::S_
	,"r"::S,"v"::S,"a"::S,"b"::S,"dl"::S_
	,"e"::S]$Lisp,_
	["r"::S,"v"::S,"dl"::S,"e"::S]$Lisp,_
	[["double"::S,["r"::S,"n"::S]$Lisp,["v"::S,"iv"::S,"n"::S]$Lisp_
	,["a"::S,"ia"::S,"n"::S]$Lisp,["b"::S,"ib"::S,"n"::S]$Lisp,["dl"::S,"n"::S]$Lisp,["e"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"ia"::S,"ib"::S,"n"::S,"iv"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["r"::S,"v"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,ibArg::Any,nArg::Any,ivArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02aff(iaArg:Integer,nArg:Integer,aArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02aff",_
	["ia"::S,"n"::S,"ifail"::S,"rr"::S,"ri"::S,"intger"::S,"a"::S]$Lisp,_
	["rr"::S,"ri"::S,"intger"::S]$Lisp,_
	[["double"::S,["rr"::S,"n"::S]$Lisp,["ri"::S,"n"::S]$Lisp_
	,["a"::S,"ia"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,["intger"::S,"n"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["rr"::S,"ri"::S,"intger"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02agf(iaArg:Integer,nArg:Integer,ivrArg:Integer,_
	iviArg:Integer,aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02agf",_
	["ia"::S,"n"::S,"ivr"::S,"ivi"::S,"ifail"::S_
	,"rr"::S,"ri"::S,"vr"::S,"vi"::S,"intger"::S_
	,"a"::S]$Lisp,_
	["rr"::S,"ri"::S,"vr"::S,"vi"::S,"intger"::S]$Lisp,_
	[["double"::S,["rr"::S,"n"::S]$Lisp,["ri"::S,"n"::S]$Lisp_
	,["vr"::S,"ivr"::S,"n"::S]$Lisp,["vi"::S,"ivi"::S,"n"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"ivr"::S,"ivi"::S_
	,["intger"::S,"n"::S]$Lisp,"ifail"::S]$Lisp_
	]$Lisp,_
	["rr"::S,"ri"::S,"vr"::S,"vi"::S,"intger"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ivrArg::Any,iviArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02ajf(iarArg:Integer,iaiArg:Integer,nArg:Integer,_
	arArg:Matrix DoubleFloat,aiArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02ajf",_
	["iar"::S,"iai"::S,"n"::S,"ifail"::S,"rr"::S,"ri"::S,"ar"::S,"ai"::S,"intger"::S_
	]$Lisp,_
	["rr"::S,"ri"::S,"intger"::S]$Lisp,_
	[["double"::S,["rr"::S,"n"::S]$Lisp,["ri"::S,"n"::S]$Lisp_
	,["ar"::S,"iar"::S,"n"::S]$Lisp,["ai"::S,"iai"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"iar"::S,"iai"::S,"n"::S,"ifail"::S_
	,["intger"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp,_
	["rr"::S,"ri"::S,"ar"::S,"ai"::S,"ifail"::S]$Lisp,_
	[([iarArg::Any,iaiArg::Any,nArg::Any,ifailArg::Any,arArg::Any,aiArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02akf(iarArg:Integer,iaiArg:Integer,nArg:Integer,_
	ivrArg:Integer,iviArg:Integer,arArg:Matrix DoubleFloat,_
	aiArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02akf",_
	["iar"::S,"iai"::S,"n"::S,"ivr"::S,"ivi"::S_
	,"ifail"::S,"rr"::S,"ri"::S,"vr"::S,"vi"::S,"ar"::S_
	,"ai"::S,"intger"::S]$Lisp,_
	["rr"::S,"ri"::S,"vr"::S,"vi"::S,"intger"::S]$Lisp,_
	[["double"::S,["rr"::S,"n"::S]$Lisp,["ri"::S,"n"::S]$Lisp_
	,["vr"::S,"ivr"::S,"n"::S]$Lisp,["vi"::S,"ivi"::S,"n"::S]$Lisp,["ar"::S,"iar"::S,"n"::S]$Lisp,["ai"::S,"iai"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"iar"::S,"iai"::S,"n"::S,"ivr"::S_
	,"ivi"::S,"ifail"::S,["intger"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp,_
	["rr"::S,"ri"::S,"vr"::S,"vi"::S,"ar"::S,"ai"::S,"ifail"::S]$Lisp,_
	[([iarArg::Any,iaiArg::Any,nArg::Any,ivrArg::Any,iviArg::Any,ifailArg::Any,arArg::Any,aiArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02awf(iarArg:Integer,iaiArg:Integer,nArg:Integer,_
	arArg:Matrix DoubleFloat,aiArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02awf",_
	["iar"::S,"iai"::S,"n"::S,"ifail"::S,"r"::S,"ar"::S,"ai"::S,"wk1"::S,"wk2"::S_
	,"wk3"::S]$Lisp,_
	["r"::S,"wk1"::S,"wk2"::S,"wk3"::S]$Lisp,_
	[["double"::S,["r"::S,"n"::S]$Lisp,["ar"::S,"iar"::S,"n"::S]$Lisp_
	,["ai"::S,"iai"::S,"n"::S]$Lisp,["wk1"::S,"n"::S]$Lisp,["wk2"::S,"n"::S]$Lisp,["wk3"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"iar"::S,"iai"::S,"n"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["r"::S,"ar"::S,"ai"::S,"ifail"::S]$Lisp,_
	[([iarArg::Any,iaiArg::Any,nArg::Any,ifailArg::Any,arArg::Any,aiArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02axf(arArg:Matrix DoubleFloat,iarArg:Integer,aiArg:Matrix DoubleFloat,_
	iaiArg:Integer,nArg:Integer,ivrArg:Integer,_
	iviArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02axf",_
	["iar"::S,"iai"::S,"n"::S,"ivr"::S,"ivi"::S_
	,"ifail"::S,"ar"::S,"ai"::S,"r"::S,"vr"::S,"vi"::S_
	,"wk1"::S,"wk2"::S,"wk3"::S]$Lisp,_
	["r"::S,"vr"::S,"vi"::S,"wk1"::S,"wk2"::S,"wk3"::S]$Lisp,_
	[["double"::S,["ar"::S,"iar"::S,"n"::S]$Lisp_
	,["ai"::S,"iai"::S,"n"::S]$Lisp,["r"::S,"n"::S]$Lisp,["vr"::S,"ivr"::S,"n"::S]$Lisp,["vi"::S,"ivi"::S,"n"::S]$Lisp,["wk1"::S,"n"::S]$Lisp_
	,["wk2"::S,"n"::S]$Lisp,["wk3"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"iar"::S,"iai"::S,"n"::S,"ivr"::S_
	,"ivi"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["r"::S,"vr"::S,"vi"::S,"ifail"::S]$Lisp,_
	[([iarArg::Any,iaiArg::Any,nArg::Any,ivrArg::Any,iviArg::Any,ifailArg::Any,arArg::Any,aiArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02bbf(iaArg:Integer,nArg:Integer,albArg:DoubleFloat,_
	ubArg:DoubleFloat,mArg:Integer,ivArg:Integer,_
	aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02bbf",_
	["ia"::S,"n"::S,"alb"::S,"ub"::S,"m"::S_
	,"iv"::S,"mm"::S,"ifail"::S,"r"::S,"v"::S,"icount"::S,"a"::S,"d"::S_
	,"e"::S,"e2"::S,"x"::S,"g"::S,"c"::S_
	]$Lisp,_
	["mm"::S,"r"::S,"v"::S,"icount"::S,"d"::S,"e"::S,"e2"::S,"x"::S,"g"::S,"c"::S]$Lisp,_
	[["double"::S,"alb"::S,"ub"::S,["r"::S,"m"::S]$Lisp_
	,["v"::S,"iv"::S,"m"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp,["d"::S,"n"::S]$Lisp,["e"::S,"n"::S]$Lisp,["e2"::S,"n"::S]$Lisp_
	,["x"::S,"n"::S,7$Lisp]$Lisp,["g"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"m"::S,"iv"::S_
	,"mm"::S,["icount"::S,"m"::S]$Lisp,"ifail"::S]$Lisp_
	,["logical"::S,["c"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp,_
	["mm"::S,"r"::S,"v"::S,"icount"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,albArg::Any,ubArg::Any,mArg::Any,ivArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02bjf(nArg:Integer,iaArg:Integer,ibArg:Integer,_
	eps1Arg:DoubleFloat,matvArg:Boolean,ivArg:Integer,_
	aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f02bjf",_
	["n"::S,"ia"::S,"ib"::S,"eps1"::S,"matv"::S_
	,"iv"::S,"ifail"::S,"alfr"::S,"alfi"::S,"beta"::S,"v"::S,"iter"::S_
	,"a"::S,"b"::S]$Lisp,_
	["alfr"::S,"alfi"::S,"beta"::S,"v"::S,"iter"::S]$Lisp,_
	[["double"::S,"eps1"::S,["alfr"::S,"n"::S]$Lisp_
	,["alfi"::S,"n"::S]$Lisp,["beta"::S,"n"::S]$Lisp,["v"::S,"iv"::S,"n"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp,["b"::S,"ib"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"n"::S,"ia"::S,"ib"::S,"iv"::S_
	,["iter"::S,"n"::S]$Lisp,"ifail"::S]$Lisp_
	,["logical"::S,"matv"::S]$Lisp_
	]$Lisp,_
	["alfr"::S,"alfi"::S,"beta"::S,"v"::S,"iter"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,iaArg::Any,ibArg::Any,eps1Arg::Any,matvArg::Any,ivArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02fjf(nArg:Integer,kArg:Integer,tolArg:DoubleFloat,_
	novecsArg:Integer,nrxArg:Integer,lworkArg:Integer,_
	lrworkArg:Integer,liworkArg:Integer,mArg:Integer,_
	noitsArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	dotArg:Union(fn:FileName,fp:Asp27(DOT)),imageArg:Union(fn:FileName,fp:Asp28(IMAGE))): Result == 
	pushFortranOutputStack(dotFilename := aspFilename "dot")$FOP
	if dotArg case fn
		  then outputAsFortran(dotArg.fn)
		  else outputAsFortran(dotArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(imageFilename := aspFilename "image")$FOP
	if imageArg case fn
		  then outputAsFortran(imageArg.fn)
		  else outputAsFortran(imageArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran()$Asp29(MONIT)
	popFortranOutputStack()$FOP
	[(invokeNagman([dotFilename,imageFilename,monitFilename]$Lisp,_
	"f02fjf",_
	["n"::S,"k"::S,"tol"::S,"novecs"::S,"nrx"::S_
	,"lwork"::S,"lrwork"::S,"liwork"::S,"m"::S,"noits"::S_
	,"ifail"::S,"dot"::S,"image"::S,"monit"::S,"d"::S,"x"::S,"work"::S,"rwork"::S,"iwork"::S_
	]$Lisp,_
	["d"::S,"work"::S,"rwork"::S,"iwork"::S,"dot"::S,"image"::S,"monit"::S]$Lisp,_
	[["double"::S,"tol"::S,["d"::S,"k"::S]$Lisp_
	,["x"::S,"nrx"::S,"k"::S]$Lisp,["work"::S,"lwork"::S]$Lisp,["rwork"::S,"lrwork"::S]$Lisp,"dot"::S,"image"::S,"monit"::S_
	]$Lisp_
	,["integer"::S,"n"::S,"k"::S,"novecs"::S,"nrx"::S_
	,"lwork"::S,"lrwork"::S,"liwork"::S,"m"::S,"noits"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	]$Lisp,_
	["d"::S,"m"::S,"noits"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,kArg::Any,tolArg::Any,novecsArg::Any,nrxArg::Any,lworkArg::Any,lrworkArg::Any,liworkArg::Any,mArg::Any,noitsArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02fjf(nArg:Integer,kArg:Integer,tolArg:DoubleFloat,_
	novecsArg:Integer,nrxArg:Integer,lworkArg:Integer,_
	lrworkArg:Integer,liworkArg:Integer,mArg:Integer,_
	noitsArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	dotArg:Union(fn:FileName,fp:Asp27(DOT)),imageArg:Union(fn:FileName,fp:Asp28(IMAGE)),monitArg:FileName): Result == 
	pushFortranOutputStack(dotFilename := aspFilename "dot")$FOP
	if dotArg case fn
		  then outputAsFortran(dotArg.fn)
		  else outputAsFortran(dotArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(imageFilename := aspFilename "image")$FOP
	if imageArg case fn
		  then outputAsFortran(imageArg.fn)
		  else outputAsFortran(imageArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran(monitArg)
	[(invokeNagman([dotFilename,imageFilename,monitFilename]$Lisp,_
	"f02fjf",_
	["n"::S,"k"::S,"tol"::S,"novecs"::S,"nrx"::S_
	,"lwork"::S,"lrwork"::S,"liwork"::S,"m"::S,"noits"::S_
	,"ifail"::S,"dot"::S,"image"::S,"monit"::S,"d"::S,"x"::S,"work"::S,"rwork"::S,"iwork"::S_
	]$Lisp,_
	["d"::S,"work"::S,"rwork"::S,"iwork"::S,"dot"::S,"image"::S,"monit"::S]$Lisp,_
	[["double"::S,"tol"::S,["d"::S,"k"::S]$Lisp_
	,["x"::S,"nrx"::S,"k"::S]$Lisp,["work"::S,"lwork"::S]$Lisp,["rwork"::S,"lrwork"::S]$Lisp,"dot"::S,"image"::S,"monit"::S_
	]$Lisp_
	,["integer"::S,"n"::S,"k"::S,"novecs"::S,"nrx"::S_
	,"lwork"::S,"lrwork"::S,"liwork"::S,"m"::S,"noits"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	]$Lisp,_
	["d"::S,"m"::S,"noits"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,kArg::Any,tolArg::Any,novecsArg::Any,nrxArg::Any,lworkArg::Any,lrworkArg::Any,liworkArg::Any,mArg::Any,noitsArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02wef(mArg:Integer,nArg:Integer,ldaArg:Integer,_
	ncolbArg:Integer,ldbArg:Integer,wantqArg:Boolean,_
	ldqArg:Integer,wantpArg:Boolean,ldptArg:Integer,_
	aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
        workLength : Integer :=
          mArg >= nArg =>
            wantqArg and wantpArg =>
              max(max(nArg**2 + 5*(nArg - 1),nArg + ncolbArg),4)
            wantqArg =>
              max(max(nArg**2 + 4*(nArg - 1),nArg + ncolbArg),4)
            wantpArg =>
              zero? ncolbArg => max(3*(nArg - 1),2)
              max(5*(nArg - 1),2)
            zero? ncolbArg => max(2*(nArg - 1),2)
            max(3*(nArg - 1),2)
          wantqArg and wantpArg =>
            max(mArg**2 + 5*(mArg - 1),2)
          wantqArg =>
            max(3*(mArg - 1),1)
          wantpArg =>
            zero? ncolbArg => max(mArg**2+3*(mArg - 1),2)
            max(mArg**2+5*(mArg - 1),2)
          zero? ncolbArg => max(2*(mArg - 1),1)
          max(3*(mArg - 1),1)

	[(invokeNagman(NIL$Lisp,_
	"f02wef",_
	["m"::S,"n"::S,"lda"::S,"ncolb"::S,"ldb"::S_
	,"wantq"::S,"ldq"::S,"wantp"::S,"ldpt"::S,"ifail"::S_
	,"q"::S,"sv"::S,"pt"::S,"work"::S,"a"::S_
	,"b"::S]$Lisp,_
	["q"::S,"sv"::S,"pt"::S,"work"::S]$Lisp,_
	[["double"::S,["q"::S,"ldq"::S,"m"::S]$Lisp_
	,["sv"::S,"m"::S]$Lisp,["pt"::S,"ldpt"::S,"n"::S]$Lisp,["work"::S,workLength]$Lisp,["a"::S,"lda"::S,"n"::S]$Lisp,["b"::S,"ldb"::S,"ncolb"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"lda"::S,"ncolb"::S_
	,"ldb"::S,"ldq"::S,"ldpt"::S,"ifail"::S]$Lisp_
	,["logical"::S,"wantq"::S,"wantp"::S]$Lisp_
	]$Lisp,_
	["q"::S,"sv"::S,"pt"::S,"work"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ldaArg::Any,ncolbArg::Any,ldbArg::Any,wantqArg::Any,ldqArg::Any,wantpArg::Any,ldptArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f02xef(mArg:Integer,nArg:Integer,ldaArg:Integer,_
	ncolbArg:Integer,ldbArg:Integer,wantqArg:Boolean,_
	ldqArg:Integer,wantpArg:Boolean,ldphArg:Integer,_
	aArg:Matrix Complex DoubleFloat,bArg:Matrix Complex DoubleFloat,ifailArg:Integer): Result == 
        -- This segment added by hand, to deal with an assumed size array GDN
        tem : Integer := (min(mArg,nArg)-1)
	rLen : Integer := 
          zero? ncolbArg and not wantqArg and not wantpArg => 2*tem
          zero? ncolbArg and wantpArg and not wantqArg => 3*tem
          not wantpArg =>
            ncolbArg >0 or wantqArg => 3*tem
          5*tem
	cLen : Integer :=
          mArg >= nArg =>
            wantqArg and wantpArg => 2*(nArg + max(nArg**2,ncolbArg))
            wantqArg and not wantpArg => 2*(nArg + max(nArg**2+nArg,ncolbArg))
            2*(nArg + max(nArg,ncolbArg))
          wantpArg => 2*(mArg**2 + mArg)
          2*mArg          
	svLength : Integer :=
          min(mArg,nArg)
	[(invokeNagman(NIL$Lisp,_
	"f02xef",_
	["m"::S,"n"::S,"lda"::S,"ncolb"::S,"ldb"::S_
	,"wantq"::S,"ldq"::S,"wantp"::S,"ldph"::S,"ifail"::S_
	,"q"::S,"sv"::S,"ph"::S,"rwork"::S,"a"::S_
	,"b"::S,"cwork"::S]$Lisp,_
	["q"::S,"sv"::S,"ph"::S,"rwork"::S,"cwork"::S]$Lisp,_
	[["double"::S,["sv"::S,svLength]$Lisp,["rwork"::S,rLen]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"lda"::S,"ncolb"::S_
	,"ldb"::S,"ldq"::S,"ldph"::S,"ifail"::S]$Lisp_
	,["logical"::S,"wantq"::S,"wantp"::S]$Lisp_
	,["double complex"::S,["q"::S,"ldq"::S,"m"::S]$Lisp,["ph"::S,"ldph"::S,"n"::S]$Lisp,["a"::S,"lda"::S,"n"::S]$Lisp,["b"::S,"ldb"::S,"ncolb"::S]$Lisp,["cwork"::S,cLen]$Lisp]$Lisp_
	]$Lisp,_
	["q"::S,"sv"::S,"ph"::S,"rwork"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ldaArg::Any,ncolbArg::Any,ldbArg::Any,wantqArg::Any,ldqArg::Any,wantpArg::Any,ldphArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGF02.dotabb>>=
"NAGF02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGF02"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE02" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE02 NagFittingPackage}
\pagehead{NagFittingPackage}{NAGE02}
\pagepic{ps/v104nagfittingpackage.ps}{NAGE02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE02 NagFittingPackage>>=
)abbrev package NAGE02 NagFittingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:59 1994
++ Description:
++ This package uses the NAG Library to find a
++ function which approximates a set of data points. Typically the
++ data contain random errors, as of experimental measurement, which
++ need to be smoothed out. To seek an approximation to the data, it
++ is first necessary to specify for the approximating function a
++ mathematical form (a polynomial, for example) which contains a
++ number of unspecified coefficients: the appropriate fitting
++ routine then derives for the coefficients the values which
++ provide the best fit of that particular form. The package deals
++ mainly with curve and surface fitting (i.e., fitting with
++ functions of one and of two variables) when a polynomial or a
++ cubic spline is used as the fitting function, since these cover
++ the most common needs. However, fitting with other functions
++ and/or more variables can be undertaken by means of general
++ linear or nonlinear routines (some of which are contained in
++ other packages) depending on whether the coefficients in the
++ function occur linearly or nonlinearly. Cases where a graph
++ rather than a set of data points is given can be treated simply
++ by first reading a suitable set of points from the graph.
++ The package also contains routines for evaluating,
++ differentiating and integrating polynomial and spline curves and
++ surfaces, once the numerical values of their coefficients have
++ been determined.
++ See \downlink{Manual Page}{manpageXXe02}.


NagFittingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e02adf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02adf(m,kplus1,nrows,x,y,w,ifail)
     ++ computes weighted least-squares polynomial approximations 
     ++ to an arbitrary set of data points.
     ++ See \downlink{Manual Page}{manpageXXe02adf}.
    e02aef : (Integer,Matrix DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e02aef(nplus1,a,xcap,ifail)
     ++ evaluates a polynomial from its Chebyshev-series 
     ++ representation.
     ++ See \downlink{Manual Page}{manpageXXe02aef}.
    e02agf : (Integer,Integer,Integer,DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Matrix Integer,Integer,Integer,Integer) -> Result 
     ++ e02agf(m,kplus1,nrows,xmin,xmax,x,y,w,mf,xf,yf,lyf,ip,lwrk,liwrk,ifail)
     ++ computes constrained weighted least-squares polynomial 
     ++ approximations in Chebyshev-series form to an arbitrary set of 
     ++ data points. The values of the approximations and any number of 
     ++ their derivatives can be specified at selected points.
     ++ See \downlink{Manual Page}{manpageXXe02agf}.
    e02ahf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,Integer,Integer,Integer) -> Result 
     ++ e02ahf(np1,xmin,xmax,a,ia1,la,iadif1,ladif,ifail)
     ++ determines the coefficients in the Chebyshev-series 
     ++ representation of the derivative of a polynomial given in 
     ++ Chebyshev-series form.
     ++ See \downlink{Manual Page}{manpageXXe02ahf}.
    e02ajf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02ajf(np1,xmin,xmax,a,ia1,la,qatm1,iaint1,laint,ifail)
     ++ determines the coefficients in the Chebyshev-series 
     ++ representation of the indefinite integral of a polynomial given 
     ++ in Chebyshev-series form.
     ++ See \downlink{Manual Page}{manpageXXe02ajf}.
    e02akf : (Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,Integer) -> Result 
     ++ e02akf(np1,xmin,xmax,a,ia1,la,x,ifail)
     ++ evaluates a polynomial from its Chebyshev-series 
     ++ representation, allowing an arbitrary index increment for 
     ++ accessing the array of coefficients.
     ++ See \downlink{Manual Page}{manpageXXe02akf}.
    e02baf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02baf(m,ncap7,x,y,w,lamda,ifail)
     ++ computes a weighted least-squares approximation to an 
     ++ arbitrary set of data points by a cubic splines 
     ++ prescribed by the user. Cubic spline can also be 
     ++ carried out.
     ++ See \downlink{Manual Page}{manpageXXe02baf}.
    e02bbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,_
	Integer) -> Result 
     ++ e02bbf(ncap7,lamda,c,x,ifail)
     ++ evaluates a cubic spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bbf}.
    e02bcf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,_
	Integer,Integer) -> Result 
     ++ e02bcf(ncap7,lamda,c,x,left,ifail)
     ++ evaluates a cubic spline and its first three derivatives 
     ++ from its B-spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bcf}.
    e02bdf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02bdf(ncap7,lamda,c,ifail)
     ++ computes the definite integral from its 
     ++ B-spline representation.
     ++ See \downlink{Manual Page}{manpageXXe02bdf}.
    e02bef : (String,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix Integer) -> Result 
     ++ e02bef(start,m,x,y,w,s,nest,lwrk,n,lamda,ifail,wrk,iwrk)
     ++ computes a cubic spline approximation to an arbitrary set 
     ++ of data points. The knot are located 
     ++ automatically, but a single parameter must be specified to 
     ++ control the trade-off between closeness of fit and smoothness of 
     ++ fit.
     ++ See \downlink{Manual Page}{manpageXXe02bef}.
    e02daf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix Integer,Integer,Integer,Integer,DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02daf(m,px,py,x,y,f,w,mu,point,npoint,nc,nws,eps,lamda,ifail)
     ++ forms a minimal, weighted least-squares bicubic spline 
     ++ surface fit with prescribed knots to a given set of data points.
     ++ See \downlink{Manual Page}{manpageXXe02daf}.
    e02dcf : (String,Integer,Matrix DoubleFloat,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix Integer,Integer) -> Result 
     ++ e02dcf(start,mx,x,my,y,f,s,nxest,nyest,lwrk,liwrk,nx,lamda,ny,mu,wrk,iwrk,ifail)
     ++ computes a bicubic spline approximation to a set of data 
     ++ values, given on a rectangular grid in the x-y plane. The knots 
     ++ of the spline are located automatically, but a single parameter 
     ++ must be specified to control the trade-off between closeness of 
     ++ fit and smoothness of fit.
     ++ See \downlink{Manual Page}{manpageXXe02dcf}.
    e02ddf : (String,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02ddf(start,m,x,y,f,w,s,nxest,nyest,lwrk,liwrk,nx,lamda,ny,mu,wrk,ifail)
     ++ computes a bicubic spline approximation to a set of 
     ++ scattered data are located 
     ++ automatically, but a single parameter must be specified to 
     ++ control the trade-off between closeness of fit and smoothness of 
     ++ fit.
     ++ See \downlink{Manual Page}{manpageXXe02ddf}.
    e02def : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02def(m,px,py,x,y,lamda,mu,c,ifail)
     ++ calculates values of a bicubic spline 
     ++ representation.
     ++ See \downlink{Manual Page}{manpageXXe02def}.
    e02dff : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02dff(mx,my,px,py,x,y,lamda,mu,c,lwrk,liwrk,ifail)
     ++ calculates values of a bicubic spline 
     ++ representation. The spline is evaluated at all points on a 
     ++ rectangular grid.
     ++ See \downlink{Manual Page}{manpageXXe02dff}.
    e02gaf : (Integer,Integer,Integer,DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e02gaf(m,la,nplus2,toler,a,b,ifail)
     ++ calculates an l  solution to an over-determined system of 
     ++                       1                                         
     ++ linear equations.
     ++ See \downlink{Manual Page}{manpageXXe02gaf}.
    e02zaf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Integer) -> Result 
     ++ e02zaf(px,py,lamda,mu,m,x,y,npoint,nadres,ifail)
     ++ sorts two-dimensional data into rectangular panels.
     ++ See \downlink{Manual Page}{manpageXXe02zaf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix Integer)
    import AnyFunctions1(String)


    e02adf(mArg:Integer,kplus1Arg:Integer,nrowsArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02adf",_
	["m"::S,"kplus1"::S,"nrows"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"a"::S,"s"::S_
	,"work1"::S,"work2"::S]$Lisp,_
	["a"::S,"s"::S,"work1"::S,"work2"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,["a"::S,"nrows"::S,"kplus1"::S]$Lisp,["s"::S,"kplus1"::S]$Lisp,["work1"::S,["*"::S,3$Lisp,"m"::S]$Lisp]$Lisp_
	,["work2"::S,["*"::S,2$Lisp,"kplus1"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"kplus1"::S,"nrows"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["a"::S,"s"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kplus1Arg::Any,nrowsArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02aef(nplus1Arg:Integer,aArg:Matrix DoubleFloat,xcapArg:DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02aef",_
	["nplus1"::S,"xcap"::S,"p"::S,"ifail"::S,"a"::S]$Lisp,_
	["p"::S]$Lisp,_
	[["double"::S,["a"::S,"nplus1"::S]$Lisp,"xcap"::S_
	,"p"::S]$Lisp_
	,["integer"::S,"nplus1"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["p"::S,"ifail"::S]$Lisp,_
	[([nplus1Arg::Any,xcapArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02agf(mArg:Integer,kplus1Arg:Integer,nrowsArg:Integer,_
	xminArg:DoubleFloat,xmaxArg:DoubleFloat,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,mfArg:Integer,_
	xfArg:Matrix DoubleFloat,yfArg:Matrix DoubleFloat,lyfArg:Integer,_
	ipArg:Matrix Integer,lwrkArg:Integer,liwrkArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02agf",_
	["m"::S,"kplus1"::S,"nrows"::S,"xmin"::S,"xmax"::S_
	,"mf"::S,"lyf"::S,"lwrk"::S,"liwrk"::S,"np1"::S_
	,"ifail"::S,"x"::S,"y"::S,"w"::S,"xf"::S,"yf"::S_
	,"ip"::S,"a"::S,"s"::S,"wrk"::S,"iwrk"::S_
	]$Lisp,_
	["a"::S,"s"::S,"np1"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["x"::S,"m"::S]$Lisp_
	,["y"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,["xf"::S,"mf"::S]$Lisp,["yf"::S,"lyf"::S]$Lisp,["a"::S,"nrows"::S,"kplus1"::S]$Lisp_
	,["s"::S,"kplus1"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"kplus1"::S,"nrows"::S_
	,"mf"::S,"lyf"::S,["ip"::S,"mf"::S]$Lisp,"lwrk"::S,"liwrk"::S,"np1"::S,"ifail"::S,["iwrk"::S,"liwrk"::S]$Lisp]$Lisp_
	]$Lisp,_
	["a"::S,"s"::S,"np1"::S,"wrk"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kplus1Arg::Any,nrowsArg::Any,xminArg::Any,xmaxArg::Any,mfArg::Any,lyfArg::Any,lwrkArg::Any,liwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,xfArg::Any,yfArg::Any,ipArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ahf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	iadif1Arg:Integer,ladifArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ahf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"iadif1"::S,"ladif"::S,"patm1"::S,"ifail"::S,"a"::S,"adif"::S]$Lisp,_
	["patm1"::S,"adif"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"patm1"::S,["adif"::S,"ladif"::S]$Lisp]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"iadif1"::S_
	,"ladif"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["patm1"::S,"adif"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,iadif1Arg::Any,ladifArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ajf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	qatm1Arg:DoubleFloat,iaint1Arg:Integer,laintArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ajf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"qatm1"::S,"iaint1"::S,"laint"::S,"ifail"::S,"a"::S,"aint"::S]$Lisp,_
	["aint"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"qatm1"::S,["aint"::S,"laint"::S]$Lisp]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"iaint1"::S_
	,"laint"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["aint"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,qatm1Arg::Any,iaint1Arg::Any,laintArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02akf(np1Arg:Integer,xminArg:DoubleFloat,xmaxArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,ia1Arg:Integer,laArg:Integer,_
	xArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02akf",_
	["np1"::S,"xmin"::S,"xmax"::S,"ia1"::S,"la"::S_
	,"x"::S,"result"::S,"ifail"::S,"a"::S]$Lisp,_
	["result"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,["a"::S,"la"::S]$Lisp_
	,"x"::S,"result"::S]$Lisp_
	,["integer"::S,"np1"::S,"ia1"::S,"la"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["result"::S,"ifail"::S]$Lisp,_
	[([np1Arg::Any,xminArg::Any,xmaxArg::Any,ia1Arg::Any,laArg::Any,xArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02baf(mArg:Integer,ncap7Arg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,lamdaArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02baf",_
	["m"::S,"ncap7"::S,"ss"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"c"::S,"lamda"::S_
	,"work1"::S,"work2"::S]$Lisp,_
	["c"::S,"ss"::S,"work1"::S,"work2"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,["c"::S,"ncap7"::S]$Lisp,"ss"::S,["lamda"::S,"ncap7"::S]$Lisp,["work1"::S,"m"::S]$Lisp_
	,["work2"::S,["*"::S,4$Lisp,"ncap7"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"ncap7"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["c"::S,"ss"::S,"lamda"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,ncap7Arg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,lamdaArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bbf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	xArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bbf",_
	["ncap7"::S,"x"::S,"s"::S,"ifail"::S,"lamda"::S,"c"::S]$Lisp,_
	["s"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"x"::S,"s"::S]$Lisp_
	,["integer"::S,"ncap7"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["s"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,xArg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bcf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	xArg:DoubleFloat,leftArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bcf",_
	["ncap7"::S,"x"::S,"left"::S,"ifail"::S,"lamda"::S,"c"::S,"s"::S]$Lisp,_
	["s"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"x"::S,["s"::S,4$Lisp]$Lisp]$Lisp_
	,["integer"::S,"ncap7"::S,"left"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["s"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,xArg::Any,leftArg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bdf(ncap7Arg:Integer,lamdaArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bdf",_
	["ncap7"::S,"defint"::S,"ifail"::S,"lamda"::S,"c"::S]$Lisp,_
	["defint"::S]$Lisp,_
	[["double"::S,["lamda"::S,"ncap7"::S]$Lisp_
	,["c"::S,"ncap7"::S]$Lisp,"defint"::S]$Lisp_
	,["integer"::S,"ncap7"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["defint"::S,"ifail"::S]$Lisp,_
	[([ncap7Arg::Any,ifailArg::Any,lamdaArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02bef(startArg:String,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,sArg:DoubleFloat,_
	nestArg:Integer,lwrkArg:Integer,nArg:Integer,_
	lamdaArg:Matrix DoubleFloat,ifailArg:Integer,wrkArg:Matrix DoubleFloat,_
	iwrkArg:Matrix Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02bef",_
	["start"::S,"m"::S,"s"::S,"nest"::S,"lwrk"::S_
	,"fp"::S,"n"::S,"ifail"::S,"x"::S,"y"::S,"w"::S,"c"::S,"lamda"::S_
	,"wrk"::S,"iwrk"::S]$Lisp,_
	["c"::S,"fp"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["w"::S,"m"::S]$Lisp,"s"::S,["c"::S,"nest"::S]$Lisp,"fp"::S,["lamda"::S,"nest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nest"::S,"lwrk"::S,"n"::S_
	,"ifail"::S,["iwrk"::S,"nest"::S]$Lisp]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"n"::S,"lamda"::S,"ifail"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[([startArg::Any,mArg::Any,sArg::Any,nestArg::Any,lwrkArg::Any,nArg::Any,ifailArg::Any,xArg::Any,yArg::Any,wArg::Any,lamdaArg::Any,wrkArg::Any,iwrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02daf(mArg:Integer,pxArg:Integer,pyArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	wArg:Matrix DoubleFloat,muArg:Matrix DoubleFloat,pointArg:Matrix Integer,_
	npointArg:Integer,ncArg:Integer,nwsArg:Integer,_
	epsArg:DoubleFloat,lamdaArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02daf",_
	["m"::S,"px"::S,"py"::S,"npoint"::S,"nc"::S_
	,"nws"::S,"eps"::S,"sigma"::S,"rank"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"w"::S,"mu"::S_
	,"point"::S,"dl"::S,"c"::S,"lamda"::S,"ws"::S_
	]$Lisp,_
	["dl"::S,"c"::S,"sigma"::S,"rank"::S,"ws"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,["mu"::S,"py"::S]$Lisp,"eps"::S,["dl"::S,"nc"::S]$Lisp,["c"::S,"nc"::S]$Lisp_
	,"sigma"::S,["lamda"::S,"px"::S]$Lisp,["ws"::S,"nws"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"px"::S,"py"::S,["point"::S,"npoint"::S]$Lisp_
	,"npoint"::S,"nc"::S,"nws"::S,"rank"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["dl"::S,"c"::S,"sigma"::S,"rank"::S,"lamda"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,npointArg::Any,ncArg::Any,nwsArg::Any,epsArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,wArg::Any,muArg::Any,pointArg::Any,lamdaArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02dcf(startArg:String,mxArg:Integer,xArg:Matrix DoubleFloat,_
	myArg:Integer,yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	sArg:DoubleFloat,nxestArg:Integer,nyestArg:Integer,_
	lwrkArg:Integer,liwrkArg:Integer,nxArg:Integer,_
	lamdaArg:Matrix DoubleFloat,nyArg:Integer,muArg:Matrix DoubleFloat,_
	wrkArg:Matrix DoubleFloat,iwrkArg:Matrix Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02dcf",_
	["start"::S,"mx"::S,"my"::S,"s"::S,"nxest"::S_
	,"nyest"::S,"lwrk"::S,"liwrk"::S,"fp"::S,"nx"::S_
	,"ny"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"c"::S,"lamda"::S_
	,"mu"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["c"::S,"fp"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["f"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,"s"::S,["c"::S,["*"::S,["-"::S,"nxest"::S,4$Lisp]$Lisp,["-"::S,"nyest"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,"fp"::S,["lamda"::S,"nxest"::S]$Lisp,["mu"::S,"nyest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"nx"::S,"ny"::S,["iwrk"::S,"liwrk"::S]$Lisp,"ifail"::S]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"nx"::S,"lamda"::S,"ny"::S,"mu"::S,"wrk"::S,"iwrk"::S,"ifail"::S]$Lisp,_
	[([startArg::Any,mxArg::Any,myArg::Any,sArg::Any,nxestArg::Any,nyestArg::Any,lwrkArg::Any,liwrkArg::Any,nxArg::Any,nyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,lamdaArg::Any,muArg::Any,wrkArg::Any,iwrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02ddf(startArg:String,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,wArg:Matrix DoubleFloat,_
	sArg:DoubleFloat,nxestArg:Integer,nyestArg:Integer,_
	lwrkArg:Integer,liwrkArg:Integer,nxArg:Integer,_
	lamdaArg:Matrix DoubleFloat,nyArg:Integer,muArg:Matrix DoubleFloat,_
	wrkArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02ddf",_
	["start"::S,"m"::S,"s"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"fp"::S,"rank"::S,"nx"::S_
	,"ny"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"w"::S,"c"::S_
	,"iwrk"::S,"lamda"::S,"mu"::S,"wrk"::S]$Lisp,_
	["c"::S,"fp"::S,"rank"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["w"::S,"m"::S]$Lisp,"s"::S,["c"::S,["*"::S,["-"::S,"nxest"::S,4$Lisp]$Lisp,["-"::S,"nyest"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,"fp"::S,["lamda"::S,"nxest"::S]$Lisp,["mu"::S,"nyest"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nxest"::S,"nyest"::S_
	,"lwrk"::S,"liwrk"::S,"rank"::S,["iwrk"::S,"liwrk"::S]$Lisp,"nx"::S,"ny"::S,"ifail"::S]$Lisp_
	,["character"::S,"start"::S]$Lisp_
	]$Lisp,_
	["c"::S,"fp"::S,"rank"::S,"iwrk"::S,"nx"::S,"lamda"::S,"ny"::S,"mu"::S,"wrk"::S,"ifail"::S]$Lisp,_
	[([startArg::Any,mArg::Any,sArg::Any,nxestArg::Any,nyestArg::Any,lwrkArg::Any,liwrkArg::Any,nxArg::Any,nyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,wArg::Any,lamdaArg::Any,muArg::Any,wrkArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02def(mArg:Integer,pxArg:Integer,pyArg:Integer,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,lamdaArg:Matrix DoubleFloat,_
	muArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02def",_
	["m"::S,"px"::S,"py"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"mu"::S,"c"::S_
	,"ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp,["c"::S,["*"::S,["-"::S,"px"::S,4$Lisp]$Lisp,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["ff"::S,"m"::S]$Lisp,["wrk"::S,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"px"::S,"py"::S,"ifail"::S_
	,["iwrk"::S,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	]$Lisp,_
	["ff"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,lamdaArg::Any,muArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02dff(mxArg:Integer,myArg:Integer,pxArg:Integer,_
	pyArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	lamdaArg:Matrix DoubleFloat,muArg:Matrix DoubleFloat,cArg:Matrix DoubleFloat,_
	lwrkArg:Integer,liwrkArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02dff",_
	["mx"::S,"my"::S,"px"::S,"py"::S,"lwrk"::S_
	,"liwrk"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"mu"::S,"c"::S_
	,"ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	["ff"::S,"wrk"::S,"iwrk"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp,["c"::S,["*"::S,["-"::S,"px"::S,4$Lisp]$Lisp,["-"::S,"py"::S,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["ff"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"px"::S,"py"::S_
	,"lwrk"::S,"liwrk"::S,"ifail"::S,["iwrk"::S,"liwrk"::S]$Lisp]$Lisp_
	]$Lisp,_
	["ff"::S,"ifail"::S]$Lisp,_
	[([mxArg::Any,myArg::Any,pxArg::Any,pyArg::Any,lwrkArg::Any,liwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any,lamdaArg::Any,muArg::Any,cArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02gaf(mArg:Integer,laArg:Integer,nplus2Arg:Integer,_
	tolerArg:DoubleFloat,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02gaf",_
	["m"::S,"la"::S,"nplus2"::S,"toler"::S,"resid"::S_
	,"irank"::S,"iter"::S,"ifail"::S,"x"::S,"a"::S,"b"::S,"iwork"::S]$Lisp,_
	["x"::S,"resid"::S,"irank"::S,"iter"::S,"iwork"::S]$Lisp,_
	[["double"::S,"toler"::S,["x"::S,"nplus2"::S]$Lisp_
	,"resid"::S,["a"::S,"la"::S,"nplus2"::S]$Lisp,["b"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"la"::S,"nplus2"::S,"irank"::S_
	,"iter"::S,"ifail"::S,["iwork"::S,"m"::S]$Lisp]$Lisp_
	]$Lisp,_
	["x"::S,"resid"::S,"irank"::S,"iter"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,laArg::Any,nplus2Arg::Any,tolerArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e02zaf(pxArg:Integer,pyArg:Integer,lamdaArg:Matrix DoubleFloat,_
	muArg:Matrix DoubleFloat,mArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,npointArg:Integer,nadresArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e02zaf",_
	["px"::S,"py"::S,"m"::S,"npoint"::S,"nadres"::S_
	,"ifail"::S,"lamda"::S,"mu"::S,"x"::S,"y"::S,"point"::S_
	,"adres"::S]$Lisp,_
	["point"::S,"adres"::S]$Lisp,_
	[["double"::S,["lamda"::S,"px"::S]$Lisp,["mu"::S,"py"::S]$Lisp_
	,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"px"::S,"py"::S,"m"::S,"npoint"::S_
	,"nadres"::S,["point"::S,"npoint"::S]$Lisp,"ifail"::S,["adres"::S,"nadres"::S]$Lisp]$Lisp_
	]$Lisp,_
	["point"::S,"ifail"::S]$Lisp,_
	[([pxArg::Any,pyArg::Any,mArg::Any,npointArg::Any,nadresArg::Any,ifailArg::Any,lamdaArg::Any,muArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE02.dotabb>>=
"NAGE02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE02"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE02" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGF04 NagLinearEquationSolvingPackage}
\pagehead{NagLinearEquationSolvingPackage}{NAGF04}
\pagepic{ps/v104naglinearequationsolvingpackage.ps}{NAGF04}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGF04 NagLinearEquationSolvingPackage>>=
)abbrev package NAGF04 NagLinearEquationSolvingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:31 1994
++ Description:
++ This package uses the NAG Library to solve the matrix equation 
++ \axiom{AX=B}, where \axiom{B}
++ may be a single vector or a matrix of multiple right-hand sides.
++ The matrix \axiom{A} may be real, complex, symmetric, Hermitian positive-
++ definite, or sparse. It may also be rectangular, in which case a
++ least-squares solution is obtained.
++ See \downlink{Manual Page}{manpageXXf04}.
NagLinearEquationSolvingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    f04adf : (Integer,Matrix Complex DoubleFloat,Integer,Integer,_
	Integer,Integer,Matrix Complex DoubleFloat,Integer) -> Result 
     ++ f04adf(ia,b,ib,n,m,ic,a,ifail)
     ++ calculates the approximate solution of a set of complex 
     ++ linear equations with multiple right-hand sides, using an LU 
     ++ factorization with partial pivoting.
     ++ See \downlink{Manual Page}{manpageXXf04adf}.
    f04arf : (Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ f04arf(ia,b,n,a,ifail)
     ++ calculates the approximate solution of a set of real 
     ++ linear equations with a single right-hand side, using an LU 
     ++ factorization with partial pivoting.
     ++ See \downlink{Manual Page}{manpageXXf04arf}.
    f04asf : (Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ f04asf(ia,b,n,a,ifail)
     ++ calculates the accurate solution of a set of real 
     ++ symmetric positive-definite linear equations with a single right-
     ++ hand side,  Ax=b, using a Cholesky factorization and iterative 
     ++ refinement.
     ++ See \downlink{Manual Page}{manpageXXf04asf}.
    f04atf : (Matrix DoubleFloat,Integer,Matrix DoubleFloat,Integer,_
	Integer,Integer) -> Result 
     ++ f04atf(a,ia,b,n,iaa,ifail)
     ++ calculates the accurate solution of a set of real linear 
     ++ equations with a single right-hand side, using an LU 
     ++ factorization with partial pivoting, and iterative refinement.
     ++ See \downlink{Manual Page}{manpageXXf04atf}.
    f04axf : (Integer,Matrix DoubleFloat,Integer,Matrix Integer,_
	Matrix Integer,Integer,Matrix Integer,Matrix DoubleFloat) -> Result 
     ++ f04axf(n,a,licn,icn,ikeep,mtype,idisp,rhs)
     ++ calculates the approximate solution of a set of real 
     ++ sparse linear equations with a single right-hand side, Ax=b or  
     ++  T                                                    
     ++ A x=b, where A has been factorized by F01BRF or F01BSF.
     ++ See \downlink{Manual Page}{manpageXXf04axf}.
    f04faf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ f04faf(job,n,d,e,b,ifail)
     ++ calculates the approximate solution of a set of real 
     ++ symmetric positive-definite tridiagonal linear equations.
     ++ See \downlink{Manual Page}{manpageXXf04faf}.
    f04jgf : (Integer,Integer,Integer,DoubleFloat,_
	Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f04jgf(m,n,nra,tol,lwork,a,b,ifail)
     ++ finds the solution of a linear least-squares problem, Ax=b
     ++ , where A is a real m by n (m>=n) matrix and b is an m element 
     ++ vector. If the matrix of observations is not of full rank, then 
     ++ the minimal least-squares solution is returned.
     ++ See \downlink{Manual Page}{manpageXXf04jgf}.
    f04maf : (Integer,Integer,Matrix DoubleFloat,Integer,_
	Matrix Integer,Integer,Matrix Integer,Matrix DoubleFloat,Matrix Integer,Matrix Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix Integer,Integer) -> Result 
     ++ f04maf(n,nz,avals,licn,irn,lirn,icn,wkeep,ikeep,inform,b,acc,noits,ifail)
     ++ e a sparse symmetric positive-definite system of linear 
     ++ equations, Ax=b, using a pre-conditioned conjugate gradient 
     ++ method, where A has been factorized by F01MAF.
     ++ See \downlink{Manual Page}{manpageXXf04maf}.
    f04mbf : (Integer,Matrix DoubleFloat,Boolean,DoubleFloat,_
	Integer,Integer,Integer,Integer,DoubleFloat,Integer,Union(fn:FileName,fp:Asp28(APROD)),Union(fn:FileName,fp:Asp34(MSOLVE))) -> Result 
     ++ f04mbf(n,b,precon,shift,itnlim,msglvl,lrwork,liwork,rtol,ifail,aprod,msolve)
     ++ solves a system of real sparse symmetric linear equations 
     ++ using a Lanczos algorithm.
     ++ See \downlink{Manual Page}{manpageXXf04mbf}.
    f04mcf : (Integer,Matrix DoubleFloat,Integer,Matrix DoubleFloat,_
	Matrix Integer,Integer,Matrix DoubleFloat,Integer,Integer,Integer,Integer) -> Result 
     ++ f04mcf(n,al,lal,d,nrow,ir,b,nrb,iselct,nrx,ifail)
     ++ computes the approximate solution of a system of real 
     ++ linear equations with multiple right-hand sides,  AX=B,  where A 
     ++ is a symmetric positive-definite variable-bandwidth matrix, which
     ++ has previously been factorized by F01MCF. Related systems may 
     ++ also be solved.
     ++ See \downlink{Manual Page}{manpageXXf04mcf}.
    f04qaf : (Integer,Integer,DoubleFloat,DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp30(APROD))) -> Result 
     ++ f04qaf(m,n,damp,atol,btol,conlim,itnlim,msglvl,lrwork,liwork,b,ifail,aprod)
     ++ solves sparse unsymmetric equations, sparse linear least-
     ++ squares problems and sparse damped linear least-squares problems,
     ++ using a Lanczos algorithm.
     ++ See \downlink{Manual Page}{manpageXXf04qaf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Boolean)
    import AnyFunctions1(Matrix Complex DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Integer)


    f04adf(iaArg:Integer,bArg:Matrix Complex DoubleFloat,ibArg:Integer,_
	nArg:Integer,mArg:Integer,icArg:Integer,_
	aArg:Matrix Complex DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04adf",_
	["ia"::S,"ib"::S,"n"::S,"m"::S,"ic"::S_
	,"ifail"::S,"b"::S,"c"::S,"a"::S,"wkspce"::S]$Lisp,_
	["c"::S,"wkspce"::S]$Lisp,_
	[["double"::S,["wkspce"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"ib"::S,"n"::S,"m"::S_
	,"ic"::S,"ifail"::S]$Lisp_
	,["double complex"::S,["b"::S,"ib"::S,"m"::S]$Lisp,["c"::S,"ic"::S,"m"::S]$Lisp,["a"::S,"ia"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp,_
	["c"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,ibArg::Any,nArg::Any,mArg::Any,icArg::Any,ifailArg::Any,bArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04arf(iaArg:Integer,bArg:Matrix DoubleFloat,nArg:Integer,_
	aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04arf",_
	["ia"::S,"n"::S,"ifail"::S,"b"::S,"c"::S,"a"::S,"wkspce"::S]$Lisp,_
	["c"::S,"wkspce"::S]$Lisp,_
	[["double"::S,["b"::S,"n"::S]$Lisp,["c"::S,"n"::S]$Lisp_
	,["a"::S,"ia"::S,"n"::S]$Lisp,["wkspce"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["c"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ifailArg::Any,bArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04asf(iaArg:Integer,bArg:Matrix DoubleFloat,nArg:Integer,_
	aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04asf",_
	["ia"::S,"n"::S,"ifail"::S,"b"::S,"c"::S,"a"::S,"wk1"::S,"wk2"::S_
	]$Lisp,_
	["c"::S,"wk1"::S,"wk2"::S]$Lisp,_
	[["double"::S,["b"::S,"n"::S]$Lisp,["c"::S,"n"::S]$Lisp_
	,["a"::S,"ia"::S,"n"::S]$Lisp,["wk1"::S,"n"::S]$Lisp,["wk2"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["c"::S,"a"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,ifailArg::Any,bArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04atf(aArg:Matrix DoubleFloat,iaArg:Integer,bArg:Matrix DoubleFloat,_
	nArg:Integer,iaaArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04atf",_
	["ia"::S,"n"::S,"iaa"::S,"ifail"::S,"a"::S,"b"::S,"c"::S,"aa"::S,"wks1"::S_
	,"wks2"::S]$Lisp,_
	["c"::S,"aa"::S,"wks1"::S,"wks2"::S]$Lisp,_
	[["double"::S,["a"::S,"ia"::S,"n"::S]$Lisp_
	,["b"::S,"n"::S]$Lisp,["c"::S,"n"::S]$Lisp,["aa"::S,"iaa"::S,"n"::S]$Lisp,["wks1"::S,"n"::S]$Lisp,["wks2"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"ia"::S,"n"::S,"iaa"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["c"::S,"aa"::S,"ifail"::S]$Lisp,_
	[([iaArg::Any,nArg::Any,iaaArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04axf(nArg:Integer,aArg:Matrix DoubleFloat,licnArg:Integer,_
	icnArg:Matrix Integer,ikeepArg:Matrix Integer,mtypeArg:Integer,_
	idispArg:Matrix Integer,rhsArg:Matrix DoubleFloat): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04axf",_
	["n"::S,"licn"::S,"mtype"::S,"resid"::S,"a"::S,"icn"::S,"ikeep"::S,"idisp"::S,"rhs"::S_
	,"w"::S]$Lisp,_
	["resid"::S,"w"::S]$Lisp,_
	[["double"::S,["a"::S,"licn"::S]$Lisp,"resid"::S_
	,["rhs"::S,"n"::S]$Lisp,["w"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"licn"::S,["icn"::S,"licn"::S]$Lisp_
	,["ikeep"::S,["*"::S,"n"::S,5$Lisp]$Lisp]$Lisp,"mtype"::S,["idisp"::S,2$Lisp]$Lisp]$Lisp_
	]$Lisp,_
	["resid"::S,"rhs"::S]$Lisp,_
	[([nArg::Any,licnArg::Any,mtypeArg::Any,aArg::Any,icnArg::Any,ikeepArg::Any,idispArg::Any,rhsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04faf(jobArg:Integer,nArg:Integer,dArg:Matrix DoubleFloat,_
	eArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04faf",_
	["job"::S,"n"::S,"ifail"::S,"d"::S,"e"::S,"b"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["d"::S,"n"::S]$Lisp,["e"::S,"n"::S]$Lisp_
	,["b"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"job"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["d"::S,"e"::S,"b"::S,"ifail"::S]$Lisp,_
	[([jobArg::Any,nArg::Any,ifailArg::Any,dArg::Any,eArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04jgf(mArg:Integer,nArg:Integer,nraArg:Integer,_
	tolArg:DoubleFloat,lworkArg:Integer,aArg:Matrix DoubleFloat,_
	bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04jgf",_
	["m"::S,"n"::S,"nra"::S,"tol"::S,"lwork"::S_
	,"svd"::S,"sigma"::S,"irank"::S,"ifail"::S,"work"::S,"a"::S,"b"::S]$Lisp,_
	["svd"::S,"sigma"::S,"irank"::S,"work"::S]$Lisp,_
	[["double"::S,"tol"::S,"sigma"::S,["work"::S,"lwork"::S]$Lisp_
	,["a"::S,"nra"::S,"n"::S]$Lisp,["b"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"nra"::S,"lwork"::S_
	,"irank"::S,"ifail"::S]$Lisp_
	,["logical"::S,"svd"::S]$Lisp_
	]$Lisp,_
	["svd"::S,"sigma"::S,"irank"::S,"work"::S,"a"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,nraArg::Any,tolArg::Any,lworkArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04maf(nArg:Integer,nzArg:Integer,avalsArg:Matrix DoubleFloat,_
	licnArg:Integer,irnArg:Matrix Integer,lirnArg:Integer,_
	icnArg:Matrix Integer,wkeepArg:Matrix DoubleFloat,ikeepArg:Matrix Integer,_
	informArg:Matrix Integer,bArg:Matrix DoubleFloat,accArg:Matrix DoubleFloat,_
	noitsArg:Matrix Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04maf",_
	["n"::S,"nz"::S,"licn"::S,"lirn"::S,"ifail"::S_
	,"avals"::S,"irn"::S,"icn"::S,"wkeep"::S,"ikeep"::S_
	,"inform"::S,"work"::S,"b"::S,"acc"::S,"noits"::S_
	]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["avals"::S,"licn"::S]$Lisp,["wkeep"::S,["*"::S,3$Lisp,"n"::S]$Lisp]$Lisp_
	,["work"::S,["*"::S,3$Lisp,"n"::S]$Lisp]$Lisp,["b"::S,"n"::S]$Lisp,["acc"::S,2$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"n"::S,"nz"::S,"licn"::S,["irn"::S,"lirn"::S]$Lisp_
	,"lirn"::S,["icn"::S,"licn"::S]$Lisp,["ikeep"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["inform"::S,4$Lisp]$Lisp_
	,["noits"::S,2$Lisp]$Lisp,"ifail"::S]$Lisp_
	]$Lisp,_
	["work"::S,"b"::S,"acc"::S,"noits"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nzArg::Any,licnArg::Any,lirnArg::Any,ifailArg::Any,avalsArg::Any,irnArg::Any,icnArg::Any,wkeepArg::Any,ikeepArg::Any,informArg::Any,bArg::Any,accArg::Any,noitsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04mbf(nArg:Integer,bArg:Matrix DoubleFloat,preconArg:Boolean,_
	shiftArg:DoubleFloat,itnlimArg:Integer,msglvlArg:Integer,_
	lrworkArg:Integer,liworkArg:Integer,rtolArg:DoubleFloat,_
	ifailArg:Integer,aprodArg:Union(fn:FileName,fp:Asp28(APROD)),msolveArg:Union(fn:FileName,fp:Asp34(MSOLVE))): Result == 
-- if both asps are AXIOM generated we do not need lrwork liwork
--   and will set to 1.
-- else believe the user but check that they are >0.
        if (aprodArg case fp) and (msolveArg case fp)
		then
			lrworkArg:=1
			liworkArg:=1
		else 
			lrworkArg:=max(1,lrworkArg)
			liworkArg:=max(1,liworkArg)
	pushFortranOutputStack(aprodFilename := aspFilename "aprod")$FOP
	if aprodArg case fn
		  then outputAsFortran(aprodArg.fn)
		  else outputAsFortran(aprodArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(msolveFilename := aspFilename "msolve")$FOP
	if msolveArg case fn
		  then outputAsFortran(msolveArg.fn)
		  else outputAsFortran(msolveArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([aprodFilename,msolveFilename]$Lisp,_
	"f04mbf",_
	["n"::S,"precon"::S,"shift"::S,"itnlim"::S,"msglvl"::S_
	,"lrwork"::S,"liwork"::S,"itn"::S,"anorm"::S,"acond"::S_
	,"rnorm"::S,"xnorm"::S,"inform"::S,"rtol"::S,"ifail"::S_
	,"aprod"::S,"msolve"::S,"b"::S,"x"::S,"work"::S,"rwork"::S,"iwork"::S_
	]$Lisp,_
	["x"::S,"itn"::S,"anorm"::S,"acond"::S,"rnorm"::S,"xnorm"::S,"inform"::S,"work"::S,"rwork"::S,"iwork"::S,"aprod"::S,"msolve"::S]$Lisp,_
	[["double"::S,["b"::S,"n"::S]$Lisp,"shift"::S_
	,["x"::S,"n"::S]$Lisp,"anorm"::S,"acond"::S,"rnorm"::S,"xnorm"::S,"rtol"::S,["work"::S,"n"::S,5$Lisp]$Lisp,["rwork"::S,"lrwork"::S]$Lisp_
	,"aprod"::S,"msolve"::S]$Lisp_
	,["integer"::S,"n"::S,"itnlim"::S,"msglvl"::S_
	,"lrwork"::S,"liwork"::S,"itn"::S,"inform"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	,["logical"::S,"precon"::S]$Lisp_
	]$Lisp,_
	["x"::S,"itn"::S,"anorm"::S,"acond"::S,"rnorm"::S,"xnorm"::S,"inform"::S,"rtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,preconArg::Any,shiftArg::Any,itnlimArg::Any,msglvlArg::Any,lrworkArg::Any,liworkArg::Any,rtolArg::Any,ifailArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04mcf(nArg:Integer,alArg:Matrix DoubleFloat,lalArg:Integer,_
	dArg:Matrix DoubleFloat,nrowArg:Matrix Integer,irArg:Integer,_
	bArg:Matrix DoubleFloat,nrbArg:Integer,iselctArg:Integer,_
	nrxArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f04mcf",_
	["n"::S,"lal"::S,"ir"::S,"nrb"::S,"iselct"::S_
	,"nrx"::S,"ifail"::S,"al"::S,"d"::S,"nrow"::S,"b"::S,"x"::S_
	]$Lisp,_
	["x"::S]$Lisp,_
	[["double"::S,["al"::S,"lal"::S]$Lisp,["d"::S,"n"::S]$Lisp_
	,["b"::S,"nrb"::S,"ir"::S]$Lisp,["x"::S,"nrx"::S,"ir"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"lal"::S,["nrow"::S,"n"::S]$Lisp_
	,"ir"::S,"nrb"::S,"iselct"::S,"nrx"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,lalArg::Any,irArg::Any,nrbArg::Any,iselctArg::Any,nrxArg::Any,ifailArg::Any,alArg::Any,dArg::Any,nrowArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f04qaf(mArg:Integer,nArg:Integer,dampArg:DoubleFloat,_
	atolArg:DoubleFloat,btolArg:DoubleFloat,conlimArg:DoubleFloat,_
	itnlimArg:Integer,msglvlArg:Integer,lrworkArg:Integer,_
	liworkArg:Integer,bArg:Matrix DoubleFloat,ifailArg:Integer,_
	aprodArg:Union(fn:FileName,fp:Asp30(APROD))): Result == 
	pushFortranOutputStack(aprodFilename := aspFilename "aprod")$FOP
	if aprodArg case fn
		  then outputAsFortran(aprodArg.fn)
		  else outputAsFortran(aprodArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([aprodFilename]$Lisp,_
	"f04qaf",_
	["m"::S,"n"::S,"damp"::S,"atol"::S,"btol"::S_
	,"conlim"::S,"itnlim"::S,"msglvl"::S,"lrwork"::S,"liwork"::S_
	,"itn"::S,"anorm"::S,"acond"::S,"rnorm"::S,"arnorm"::S_
	,"xnorm"::S,"inform"::S,"ifail"::S,"aprod"::S,"x"::S,"se"::S,"b"::S,"work"::S,"rwork"::S_
	,"iwork"::S]$Lisp,_
	["x"::S,"se"::S,"itn"::S,"anorm"::S,"acond"::S,"rnorm"::S,"arnorm"::S,"xnorm"::S,"inform"::S,"work"::S,"rwork"::S,"iwork"::S,"aprod"::S]$Lisp,_
	[["double"::S,"damp"::S,"atol"::S,"btol"::S_
	,"conlim"::S,["x"::S,"n"::S]$Lisp,["se"::S,"n"::S]$Lisp,"anorm"::S,"acond"::S,"rnorm"::S,"arnorm"::S,"xnorm"::S,["b"::S,"m"::S]$Lisp_
	,["work"::S,"n"::S,2$Lisp]$Lisp,["rwork"::S,"lrwork"::S]$Lisp,"aprod"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"itnlim"::S,"msglvl"::S_
	,"lrwork"::S,"liwork"::S,"itn"::S,"inform"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	]$Lisp,_
	["x"::S,"se"::S,"itn"::S,"anorm"::S,"acond"::S,"rnorm"::S,"arnorm"::S,"xnorm"::S,"inform"::S,"b"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,dampArg::Any,atolArg::Any,btolArg::Any,conlimArg::Any,itnlimArg::Any,msglvlArg::Any,lrworkArg::Any,liworkArg::Any,ifailArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGF04.dotabb>>=
"NAGF04" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGF04"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"NAGF04" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGSP NAGLinkSupportPackage}
\pagehead{NAGLinkSupportPackage}{NAGSP}
\pagepic{ps/v104naglinksupportpackage.ps}{NAGSP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGSP NAGLinkSupportPackage>>=
)abbrev package NAGSP NAGLinkSupportPackage
++ Author: Mike Dewar and Godfrey Nolan
++ Date Created:  March 1993
++ Date Last Updated: March 4 1994
++                    October 6 1994
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: Support functions for the NAG Library Link functions
NAGLinkSupportPackage() : exports == implementation where

  exports ==> with
    fortranCompilerName : () -> String
      ++ fortranCompilerName() returns the name of the currently selected
      ++  Fortran compiler
    fortranLinkerArgs   : () -> String
      ++ fortranLinkerArgs() returns the current linker arguments
    aspFilename         : String -> String
      ++ aspFilename("f") returns a String consisting of "f" suffixed with
      ++  an extension identifying the current AXIOM session.
    dimensionsOf	: (Symbol, Matrix DoubleFloat) -> SExpression
	++ dimensionsOf(s,m) \undocumented{}
    dimensionsOf	: (Symbol, Matrix Integer) -> SExpression
	++ dimensionsOf(s,m) \undocumented{}
    checkPrecision      : () -> Boolean
	++ checkPrecision() \undocumented{}
    restorePrecision    : () -> Void
	++ restorePrecision() \undocumented{}

  implementation ==> add
    makeAs:                   (Symbol,Symbol) -> Symbol
    changeVariables:          (Expression Integer,Symbol) -> Expression Integer
    changeVariablesF:         (Expression Float,Symbol) -> Expression Float

    import String
    import Symbol

    checkPrecision():Boolean ==
      (_$fortranPrecision$Lisp = "single"::Symbol) and (_$nagEnforceDouble$Lisp)  =>
        systemCommand("set fortran precision double")$MoreSystemCommands
        if _$nagMessages$Lisp  then 
          print("*** Warning: Resetting fortran precision to double")$PrintPackage
        true
      false

    restorePrecision():Void ==
      systemCommand("set fortran precision single")$MoreSystemCommands
      if _$nagMessages$Lisp  then 
        print("** Warning: Restoring fortran precision to single")$PrintPackage
      void()$Void

    uniqueId : String := ""
    counter : Integer := 0
    getUniqueId():String ==
      if uniqueId = "" then
        uniqueId := concat(getEnv("HOST")$Lisp,getEnv("SPADNUM")$Lisp)
      concat(uniqueId,string (counter:=counter+1))

    fortranCompilerName() == string _$fortranCompilerName$Lisp
    fortranLinkerArgs() == string _$fortranLibraries$Lisp

    aspFilename(f:String):String == concat ["/tmp/",f,getUniqueId(),".f"]

    dimensionsOf(u:Symbol,m:Matrix DoubleFloat):SExpression ==
      [u,nrows m,ncols m]$Lisp
    dimensionsOf(u:Symbol,m:Matrix Integer):SExpression ==
      [u,nrows m,ncols m]$Lisp

@
<<NAGSP.dotabb>>=
"NAGSP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGSP"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGSP" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD01 NagIntegrationPackage}
\pagehead{NagIntegrationPackage}{NAGD01}
\pagepic{ps/v104nagintegrationpackage.ps}{NAGD01}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD01 NagIntegrationPackage>>=
)abbrev package NAGD01 NagIntegrationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:37 1994
++ Description:
++ This package uses the NAG Library to calculate the numerical value of
++ definite integrals in one or more dimensions and to evaluate
++ weights and abscissae of integration rules.
++ See \downlink{Manual Page}{manpageXXd01}.

NagIntegrationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d01ajf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01ajf(a,b,epsabs,epsrel,lw,liw,ifail,f)
     ++ is a general-purpose integrator which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01ajf}.
    d01akf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01akf(a,b,epsabs,epsrel,lw,liw,ifail,f)
     ++ is an adaptive integrator, especially suited to 
     ++ oscillating, non-singular integrands, which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01akf}.
    d01alf : (DoubleFloat,DoubleFloat,Integer,Matrix DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01alf(a,b,npts,points,epsabs,epsrel,lw,liw,ifail,f)
     ++ is a general purpose integrator which calculates an 
     ++ approximation to the integral of a function f(x) over a finite 
     ++ interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01alf}.
    d01amf : (DoubleFloat,Integer,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ d01amf(bound,inf,epsabs,epsrel,lw,liw,ifail,f)
     ++ calculates an approximation to the integral of a function 
     ++ f(x) over an infinite or semi-infinite interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01amf}.
    d01anf : (DoubleFloat,DoubleFloat,DoubleFloat,Integer,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01anf(a,b,omega,key,epsabs,epsrel,lw,liw,ifail,g)
     ++ calculates an approximation to the sine or the cosine 
     ++ transform of a function g over [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01anf}.
    d01apf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01apf(a,b,alfa,beta,key,epsabs,epsrel,lw,liw,ifail,g)
     ++ is an adaptive integrator which calculates an 
     ++ approximation to the integral of a function g(x)w(x) over a 
     ++ finite interval [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01apf}.
    d01aqf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01aqf(a,b,c,epsabs,epsrel,lw,liw,ifail,g)
     ++ calculates an approximation to the Hilbert transform of a 
     ++ function g(x) over [a,b]:
     ++ See \downlink{Manual Page}{manpageXXd01aqf}.
    d01asf : (DoubleFloat,DoubleFloat,Integer,DoubleFloat,_
	Integer,Integer,Integer,Integer,Union(fn:FileName,fp:Asp1(G))) -> Result 
     ++ d01asf(a,omega,key,epsabs,limlst,lw,liw,ifail,g)
     ++ calculates an approximation to the sine or the cosine 
     ++ transform of a function g over [a,infty):
     ++ See \downlink{Manual Page}{manpageXXd01asf}.
    d01bbf : (DoubleFloat,DoubleFloat,Integer,Integer,_
	Integer,Integer) -> Result 
     ++ d01bbf(a,b,itype,n,gtype,ifail)
     ++ returns the weight appropriate to a 
     ++ Gaussian quadrature.
     ++ The formulae provided are Gauss-Legendre, Gauss-Rational, Gauss-
     ++ Laguerre and Gauss-Hermite.
     ++ See \downlink{Manual Page}{manpageXXd01bbf}.
    d01fcf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	DoubleFloat,Integer,Integer,Integer,Union(fn:FileName,fp:Asp4(FUNCTN))) -> Result 
     ++ d01fcf(ndim,a,b,maxpts,eps,lenwrk,minpts,ifail,functn)
     ++ attempts to evaluate a multi-dimensional integral (up to 
     ++ 15 dimensions), with constant and finite limits, to a specified 
     ++ relative accuracy, using an adaptive subdivision strategy.
     ++ See \downlink{Manual Page}{manpageXXd01fcf}.
    d01gaf : (Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer) -> Result 
     ++ d01gaf(x,y,n,ifail)
     ++ integrates a function which is specified numerically at 
     ++ four or more points, over the whole of its specified range, using
     ++ third-order finite-difference formulae with error estimates, 
     ++ according to a method due to Gill and Miller.
     ++ See \downlink{Manual Page}{manpageXXd01gaf}.
    d01gbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	DoubleFloat,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp4(FUNCTN))) -> Result 
     ++ d01gbf(ndim,a,b,maxcls,eps,lenwrk,mincls,wrkstr,ifail,functn)
     ++ returns an approximation to the integral of a function 
     ++ over a hyper-rectangular region, using a Monte Carlo method. An 
     ++ approximate relative error estimate is also returned. This 
     ++ routine is suitable for low accuracy work.
     ++ See \downlink{Manual Page}{manpageXXd01gbf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp1(F))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)


    d01ajf(aArg:DoubleFloat,bArg:DoubleFloat,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01ajf",_
	["a"::S,"b"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01akf(aArg:DoubleFloat,bArg:DoubleFloat,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01akf",_
	["a"::S,"b"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01alf(aArg:DoubleFloat,bArg:DoubleFloat,nptsArg:Integer,_
	pointsArg:Matrix DoubleFloat,epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,_
	lwArg:Integer,liwArg:Integer,ifailArg:Integer,_
	fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01alf",_
	["a"::S,"b"::S,"npts"::S,"epsabs"::S,"epsrel"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"ifail"::S_
	,"f"::S,"points"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,["points"::S,"*"::S]$Lisp_
	,"epsabs"::S,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"npts"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,nptsArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any,pointsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01amf(boundArg:DoubleFloat,infArg:Integer,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"d01amf",_
	["bound"::S,"inf"::S,"epsabs"::S,"epsrel"::S,"lw"::S_
	,"liw"::S,"result"::S,"abserr"::S,"ifail"::S,"f"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"f"::S]$Lisp,_
	[["double"::S,"bound"::S,"epsabs"::S,"epsrel"::S_
	,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"f"::S]$Lisp_
	,["integer"::S,"inf"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([boundArg::Any,infArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01anf(aArg:DoubleFloat,bArg:DoubleFloat,omegaArg:DoubleFloat,_
	keyArg:Integer,epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,_
	lwArg:Integer,liwArg:Integer,ifailArg:Integer,_
	gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01anf",_
	["a"::S,"b"::S,"omega"::S,"key"::S,"epsabs"::S_
	,"epsrel"::S,"lw"::S,"liw"::S,"result"::S,"abserr"::S_
	,"ifail"::S,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"omega"::S,"epsabs"::S_
	,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,omegaArg::Any,keyArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01apf(aArg:DoubleFloat,bArg:DoubleFloat,alfaArg:DoubleFloat,_
	betaArg:DoubleFloat,keyArg:Integer,epsabsArg:DoubleFloat,_
	epsrelArg:DoubleFloat,lwArg:Integer,liwArg:Integer,_
	ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01apf",_
	["a"::S,"b"::S,"alfa"::S,"beta"::S,"key"::S_
	,"epsabs"::S,"epsrel"::S,"lw"::S,"liw"::S,"result"::S_
	,"abserr"::S,"ifail"::S,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"alfa"::S,"beta"::S_
	,"epsabs"::S,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,alfaArg::Any,betaArg::Any,keyArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01aqf(aArg:DoubleFloat,bArg:DoubleFloat,cArg:DoubleFloat,_
	epsabsArg:DoubleFloat,epsrelArg:DoubleFloat,lwArg:Integer,_
	liwArg:Integer,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01aqf",_
	["a"::S,"b"::S,"c"::S,"epsabs"::S,"epsrel"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"ifail"::S_
	,"g"::S,"w"::S,"iw"::S]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"c"::S,"epsabs"::S_
	,"epsrel"::S,"result"::S,"abserr"::S,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"lw"::S,"liw"::S,["iw"::S,"liw"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"w"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,cArg::Any,epsabsArg::Any,epsrelArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01asf(aArg:DoubleFloat,omegaArg:DoubleFloat,keyArg:Integer,_
	epsabsArg:DoubleFloat,limlstArg:Integer,lwArg:Integer,_
	liwArg:Integer,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp1(G))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename]$Lisp,_
	"d01asf",_
	["a"::S,"omega"::S,"key"::S,"epsabs"::S,"limlst"::S_
	,"lw"::S,"liw"::S,"result"::S,"abserr"::S,"lst"::S_
	,"ifail"::S,"g"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"w"::S_
	]$Lisp,_
	["result"::S,"abserr"::S,"lst"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"w"::S,"g"::S]$Lisp,_
	[["double"::S,"a"::S,"omega"::S,"epsabs"::S_
	,"result"::S,"abserr"::S,["erlst"::S,"limlst"::S]$Lisp,["rslst"::S,"limlst"::S]$Lisp,["w"::S,"lw"::S]$Lisp,"g"::S]$Lisp_
	,["integer"::S,"key"::S,"limlst"::S,"lw"::S_
	,"liw"::S,"lst"::S,["ierlst"::S,"limlst"::S]$Lisp,["iw"::S,"liw"::S]$Lisp,"ifail"::S]$Lisp_
	]$Lisp,_
	["result"::S,"abserr"::S,"lst"::S,"erlst"::S,"rslst"::S,"ierlst"::S,"iw"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,omegaArg::Any,keyArg::Any,epsabsArg::Any,limlstArg::Any,lwArg::Any,liwArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01bbf(aArg:DoubleFloat,bArg:DoubleFloat,itypeArg:Integer,_
	nArg:Integer,gtypeArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d01bbf",_
	["a"::S,"b"::S,"itype"::S,"n"::S,"gtype"::S_
	,"ifail"::S,"weight"::S,"abscis"::S]$Lisp,_
	["weight"::S,"abscis"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,["weight"::S,"n"::S]$Lisp_
	,["abscis"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"itype"::S,"n"::S,"gtype"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["weight"::S,"abscis"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,itypeArg::Any,nArg::Any,gtypeArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01fcf(ndimArg:Integer,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	maxptsArg:Integer,epsArg:DoubleFloat,lenwrkArg:Integer,_
	minptsArg:Integer,ifailArg:Integer,functnArg:Union(fn:FileName,fp:Asp4(FUNCTN))): Result == 
	pushFortranOutputStack(functnFilename := aspFilename "functn")$FOP
	if functnArg case fn
		  then outputAsFortran(functnArg.fn)
		  else outputAsFortran(functnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([functnFilename]$Lisp,_
	"d01fcf",_
	["ndim"::S,"maxpts"::S,"eps"::S,"lenwrk"::S,"acc"::S_
	,"finval"::S,"minpts"::S,"ifail"::S,"functn"::S,"a"::S,"b"::S,"wrkstr"::S]$Lisp,_
	["acc"::S,"finval"::S,"wrkstr"::S,"functn"::S]$Lisp,_
	[["double"::S,["a"::S,"ndim"::S]$Lisp,["b"::S,"ndim"::S]$Lisp_
	,"eps"::S,"acc"::S,"finval"::S,["wrkstr"::S,"lenwrk"::S]$Lisp,"functn"::S]$Lisp_
	,["integer"::S,"ndim"::S,"maxpts"::S,"lenwrk"::S_
	,"minpts"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["acc"::S,"finval"::S,"minpts"::S,"ifail"::S]$Lisp,_
	[([ndimArg::Any,maxptsArg::Any,epsArg::Any,lenwrkArg::Any,minptsArg::Any,ifailArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01gaf(xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,nArg:Integer,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d01gaf",_
	["n"::S,"ans"::S,"er"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	["ans"::S,"er"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	,"ans"::S,"er"::S]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["ans"::S,"er"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d01gbf(ndimArg:Integer,aArg:Matrix DoubleFloat,bArg:Matrix DoubleFloat,_
	maxclsArg:Integer,epsArg:DoubleFloat,lenwrkArg:Integer,_
	minclsArg:Integer,wrkstrArg:Matrix DoubleFloat,ifailArg:Integer,_
	functnArg:Union(fn:FileName,fp:Asp4(FUNCTN))): Result == 
	pushFortranOutputStack(functnFilename := aspFilename "functn")$FOP
	if functnArg case fn
		  then outputAsFortran(functnArg.fn)
		  else outputAsFortran(functnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([functnFilename]$Lisp,_
	"d01gbf",_
	["ndim"::S,"maxcls"::S,"eps"::S,"lenwrk"::S,"acc"::S_
	,"finest"::S,"mincls"::S,"ifail"::S,"functn"::S,"a"::S,"b"::S,"wrkstr"::S]$Lisp,_
	["acc"::S,"finest"::S,"functn"::S]$Lisp,_
	[["double"::S,["a"::S,"ndim"::S]$Lisp,["b"::S,"ndim"::S]$Lisp_
	,"eps"::S,"acc"::S,"finest"::S,["wrkstr"::S,"lenwrk"::S]$Lisp,"functn"::S]$Lisp_
	,["integer"::S,"ndim"::S,"maxcls"::S,"lenwrk"::S_
	,"mincls"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["acc"::S,"finest"::S,"mincls"::S,"wrkstr"::S,"ifail"::S]$Lisp,_
	[([ndimArg::Any,maxclsArg::Any,epsArg::Any,lenwrkArg::Any,minclsArg::Any,ifailArg::Any,aArg::Any,bArg::Any,wrkstrArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD01.dotabb>>=
"NAGD01" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD01"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD01" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE01 NagInterpolationPackage}
\pagehead{NagInterpolationPackage}{NAGE01}
\pagepic{ps/v104naginterpolationpackage.ps}{NAGE01}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE01 NagInterpolationPackage>>=
)abbrev package NAGE01 NagInterpolationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:53 1994
++ Description:
++ This package uses the NAG Library to calculate the interpolation of a 
++ function of one or two variables. When provided with the value of the
++ function (and possibly one or more of its lowest-order
++ derivatives) at each of a number of values of the variable(s),
++ the routines provide either an interpolating function or an
++ interpolated value. For some of the interpolating functions,
++ there are supporting routines to evaluate, differentiate or
++ integrate them.
++ See \downlink{Manual Page}{manpageXXe01}.


NagInterpolationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e01baf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer,_
	Integer,Integer) -> Result 
     ++ e01baf(m,x,y,lck,lwrk,ifail)
     ++ determines a cubic spline to a given set of 
     ++ data.
     ++ See \downlink{Manual Page}{manpageXXe01baf}.
    e01bef : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bef(n,x,f,ifail)
     ++ computes a monotonicity-preserving piecewise cubic Hermite
     ++ interpolant to a set of data points.
     ++ See \downlink{Manual Page}{manpageXXe01bef}.
    e01bff : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bff(n,x,f,d,m,px,ifail)
     ++ evaluates a piecewise cubic Hermite interpolant at a set 
     ++ of points.
     ++ See \downlink{Manual Page}{manpageXXe01bff}.
    e01bgf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e01bgf(n,x,f,d,m,px,ifail)
     ++ evaluates a piecewise cubic Hermite interpolant and its 
     ++ first derivative at a set of points.
     ++ See \downlink{Manual Page}{manpageXXe01bgf}.
    e01bhf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01bhf(n,x,f,d,a,b,ifail)
     ++ evaluates the definite integral of a piecewise cubic 
     ++ Hermite interpolant over the interval [a,b].
     ++ See \downlink{Manual Page}{manpageXXe01bhf}.
    e01daf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ e01daf(mx,my,x,y,f,ifail)
     ++ computes a bicubic spline interpolating surface through a 
     ++ set of data values, given on a rectangular grid in the x-y plane.
     ++ See \downlink{Manual Page}{manpageXXe01daf}.
    e01saf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ e01saf(m,x,y,f,ifail)
     ++ generates a two-dimensional surface interpolating a set of
     ++ scattered data points, using the method of Renka and Cline.
     ++ See \downlink{Manual Page}{manpageXXe01saf}.
    e01sbf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Matrix Integer,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sbf(m,x,y,f,triang,grads,px,py,ifail)
     ++ evaluates at a given point the two-dimensional interpolant
     ++ function computed by E01SAF.
     ++ See \downlink{Manual Page}{manpageXXe01sbf}.
    e01sef : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sef(m,x,y,f,nw,nq,rnw,rnq,ifail)
     ++ generates a two-dimensional surface interpolating a set of
     ++ scattered data points, using a modified Shepard method.
     ++ See \downlink{Manual Page}{manpageXXe01sef}.
    e01sff : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ e01sff(m,x,y,f,rnw,fnodes,px,py,ifail)
     ++ evaluates at a given point the two-dimensional 
     ++ interpolating function computed by E01SEF.
     ++ See \downlink{Manual Page}{manpageXXe01sff}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Integer)
    import AnyFunctions1(DoubleFloat)


    e01baf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	lckArg:Integer,lwrkArg:Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01baf",_
	["m"::S,"lck"::S,"lwrk"::S,"ifail"::S,"x"::S,"y"::S,"lamda"::S,"c"::S,"wrk"::S_
	]$Lisp,_
	["lamda"::S,"c"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["lamda"::S,"lck"::S]$Lisp,["c"::S,"lck"::S]$Lisp,["wrk"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"lck"::S,"lwrk"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["lamda"::S,"c"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,lckArg::Any,lwrkArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bef(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bef",_
	["n"::S,"ifail"::S,"x"::S,"f"::S,"d"::S]$Lisp,_
	["d"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["d"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bff(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,mArg:Integer,pxArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bff",_
	["n"::S,"m"::S,"ifail"::S,"x"::S,"f"::S,"d"::S,"px"::S,"pf"::S_
	]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,["px"::S,"m"::S]$Lisp,["pf"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any,pxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bgf(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,mArg:Integer,pxArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bgf",_
	["n"::S,"m"::S,"ifail"::S,"x"::S,"f"::S,"d"::S,"px"::S,"pf"::S_
	,"pd"::S]$Lisp,_
	["pf"::S,"pd"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,["px"::S,"m"::S]$Lisp,["pf"::S,"m"::S]$Lisp,["pd"::S,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"pd"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any,pxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01bhf(nArg:Integer,xArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,_
	dArg:Matrix DoubleFloat,aArg:DoubleFloat,bArg:DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01bhf",_
	["n"::S,"a"::S,"b"::S,"pint"::S,"ifail"::S_
	,"x"::S,"f"::S,"d"::S]$Lisp,_
	["pint"::S]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["f"::S,"n"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp,"a"::S,"b"::S,"pint"::S]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pint"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,aArg::Any,bArg::Any,ifailArg::Any,xArg::Any,fArg::Any,dArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01daf(mxArg:Integer,myArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,fArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01daf",_
	["mx"::S,"my"::S,"px"::S,"py"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"lamda"::S,"mu"::S_
	,"c"::S,"wrk"::S]$Lisp,_
	["px"::S,"py"::S,"lamda"::S,"mu"::S,"c"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"mx"::S]$Lisp,["y"::S,"my"::S]$Lisp_
	,["f"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["lamda"::S,["+"::S,"mx"::S,4$Lisp]$Lisp]$Lisp,["mu"::S,["+"::S,"mx"::S,4$Lisp]$Lisp]$Lisp_
	,["c"::S,["*"::S,"mx"::S,"my"::S]$Lisp]$Lisp,["wrk"::S,["*"::S,["+"::S,"mx"::S,6$Lisp]$Lisp,["+"::S,"my"::S,6$Lisp]$Lisp]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"mx"::S,"my"::S,"px"::S,"py"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["px"::S,"py"::S,"lamda"::S,"mu"::S,"c"::S,"ifail"::S]$Lisp,_
	[([mxArg::Any,myArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01saf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01saf",_
	["m"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"triang"::S,"grads"::S_
	]$Lisp,_
	["triang"::S,"grads"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["grads"::S,2$Lisp,"m"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,["triang"::S,["*"::S,7$Lisp,"m"::S]$Lisp]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["triang"::S,"grads"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sbf(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,triangArg:Matrix Integer,gradsArg:Matrix DoubleFloat,_
	pxArg:DoubleFloat,pyArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sbf",_
	["m"::S,"px"::S,"py"::S,"pf"::S,"ifail"::S_
	,"x"::S,"y"::S,"f"::S,"triang"::S,"grads"::S_
	]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["grads"::S,2$Lisp,"m"::S]$Lisp,"px"::S,"py"::S,"pf"::S]$Lisp_
	,["integer"::S,"m"::S,["triang"::S,["*"::S,7$Lisp,"m"::S]$Lisp]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,triangArg::Any,gradsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sef(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,nwArg:Integer,nqArg:Integer,_
	rnwArg:DoubleFloat,rnqArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sef",_
	["m"::S,"nw"::S,"nq"::S,"minnq"::S,"rnw"::S_
	,"rnq"::S,"ifail"::S,"x"::S,"y"::S,"f"::S,"fnodes"::S,"wrk"::S_
	]$Lisp,_
	["fnodes"::S,"minnq"::S,"wrk"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,["fnodes"::S,["*"::S,5$Lisp,"m"::S]$Lisp]$Lisp,"rnw"::S,"rnq"::S,["wrk"::S,["*"::S,6$Lisp,"m"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"nw"::S,"nq"::S,"minnq"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["fnodes"::S,"minnq"::S,"rnw"::S,"rnq"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nwArg::Any,nqArg::Any,rnwArg::Any,rnqArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e01sff(mArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	fArg:Matrix DoubleFloat,rnwArg:DoubleFloat,fnodesArg:Matrix DoubleFloat,_
	pxArg:DoubleFloat,pyArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e01sff",_
	["m"::S,"rnw"::S,"px"::S,"py"::S,"pf"::S_
	,"ifail"::S,"x"::S,"y"::S,"f"::S,"fnodes"::S]$Lisp,_
	["pf"::S]$Lisp,_
	[["double"::S,["x"::S,"m"::S]$Lisp,["y"::S,"m"::S]$Lisp_
	,["f"::S,"m"::S]$Lisp,"rnw"::S,["fnodes"::S,["*"::S,5$Lisp,"m"::S]$Lisp]$Lisp,"px"::S,"py"::S,"pf"::S]$Lisp_
	,["integer"::S,"m"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pf"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,rnwArg::Any,pxArg::Any,pyArg::Any,ifailArg::Any,xArg::Any,yArg::Any,fArg::Any,fnodesArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE01.dotabb>>=
"NAGE01" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE01"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE01" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGF07 NagLapack}
\pagehead{NagLapack}{NAGF07}
\pagepic{ps/v104naglapack.ps}{NAGF07}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGF07 NagLapack>>=
)abbrev package NAGF07 NagLapack
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:42 1994
++ Description:
++ This package uses the NAG Library to compute matrix
++ factorizations, and to solve systems of linear equations
++ following the matrix factorizations.
++ See \downlink{Manual Page}{manpageXXf07}.
NagLapack(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    f07adf : (Integer,Integer,Integer,Matrix DoubleFloat) -> Result 
     ++ f07adf(m,n,lda,a)
     ++ (DGETRF) computes the LU factorization of a real m by n 
     ++ matrix.
     ++ See \downlink{Manual Page}{manpageXXf07adf}.
    f07aef : (String,Integer,Integer,Matrix DoubleFloat,_
	Integer,Matrix Integer,Integer,Matrix DoubleFloat) -> Result 
     ++ f07aef(trans,n,nrhs,a,lda,ipiv,ldb,b)
     ++ (DGETRS) solves a real system of linear equations with 
     ++                                     T                     
     ++ multiple right-hand sides, AX=B or A X=B, where A has been 
     ++ factorized by F07ADF (DGETRF).
     ++ See \downlink{Manual Page}{manpageXXf07aef}.
    f07fdf : (String,Integer,Integer,Matrix DoubleFloat) -> Result 
     ++ f07fdf(uplo,n,lda,a)
     ++ (DPOTRF) computes the Cholesky factorization of a real 
     ++ symmetric positive-definite matrix.
     ++ See \downlink{Manual Page}{manpageXXf07fdf}.
    f07fef : (String,Integer,Integer,Matrix DoubleFloat,_
	Integer,Integer,Matrix DoubleFloat) -> Result 
     ++ f07fef(uplo,n,nrhs,a,lda,ldb,b)
     ++ (DPOTRS) solves a real symmetric positive-definite system 
     ++ of linear equations with multiple right-hand sides, AX=B, where A
     ++ has been factorized by F07FDF (DPOTRF).
     ++ See \downlink{Manual Page}{manpageXXf07fef}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(String)
    import AnyFunctions1(Matrix Integer)


    f07adf(mArg:Integer,nArg:Integer,ldaArg:Integer,_
	aArg:Matrix DoubleFloat): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f07adf",_
	["m"::S,"n"::S,"lda"::S,"info"::S,"ipiv"::S,"a"::S]$Lisp,_
	["ipiv"::S,"info"::S]$Lisp,_
	[["double"::S,["a"::S,"lda"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"lda"::S,["ipiv"::S,"m"::S]$Lisp_
	,"info"::S]$Lisp_
	]$Lisp,_
	["ipiv"::S,"info"::S,"a"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ldaArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f07aef(transArg:String,nArg:Integer,nrhsArg:Integer,_
	aArg:Matrix DoubleFloat,ldaArg:Integer,ipivArg:Matrix Integer,_
	ldbArg:Integer,bArg:Matrix DoubleFloat): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f07aef",_
	["trans"::S,"n"::S,"nrhs"::S,"lda"::S,"ldb"::S_
	,"info"::S,"a"::S,"ipiv"::S,"b"::S]$Lisp,_
	["info"::S]$Lisp,_
	[["double"::S,["a"::S,"lda"::S,"n"::S]$Lisp_
	,["b"::S,"ldb"::S,"nrhs"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"nrhs"::S,"lda"::S,["ipiv"::S,"n"::S]$Lisp_
	,"ldb"::S,"info"::S]$Lisp_
	,["character"::S,"trans"::S]$Lisp_
	]$Lisp,_
	["info"::S,"b"::S]$Lisp,_
	[([transArg::Any,nArg::Any,nrhsArg::Any,ldaArg::Any,ldbArg::Any,aArg::Any,ipivArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f07fdf(uploArg:String,nArg:Integer,ldaArg:Integer,_
	aArg:Matrix DoubleFloat): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f07fdf",_
	["uplo"::S,"n"::S,"lda"::S,"info"::S,"a"::S]$Lisp,_
	["info"::S]$Lisp,_
	[["double"::S,["a"::S,"lda"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"n"::S,"lda"::S,"info"::S]$Lisp_
	,["character"::S,"uplo"::S]$Lisp_
	]$Lisp,_
	["info"::S,"a"::S]$Lisp,_
	[([uploArg::Any,nArg::Any,ldaArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f07fef(uploArg:String,nArg:Integer,nrhsArg:Integer,_
	aArg:Matrix DoubleFloat,ldaArg:Integer,ldbArg:Integer,_
	bArg:Matrix DoubleFloat): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f07fef",_
	["uplo"::S,"n"::S,"nrhs"::S,"lda"::S,"ldb"::S_
	,"info"::S,"a"::S,"b"::S]$Lisp,_
	["info"::S]$Lisp,_
	[["double"::S,["a"::S,"lda"::S,"n"::S]$Lisp_
	,["b"::S,"ldb"::S,"nrhs"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"nrhs"::S,"lda"::S,"ldb"::S_
	,"info"::S]$Lisp_
	,["character"::S,"uplo"::S]$Lisp_
	]$Lisp,_
	["info"::S,"b"::S]$Lisp,_
	[([uploArg::Any,nArg::Any,nrhsArg::Any,ldaArg::Any,ldbArg::Any,aArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGF07.dotabb>>=
"NAGF07" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGF07"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGF07" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGF01 NagMatrixOperationsPackage}
\pagehead{NagMatrixOperationsPackage}{NAGF01}
\pagepic{ps/v104nagmatrixoperationspackage.ps}{NAGF01}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGF01 NagMatrixOperationsPackage>>=
)abbrev package NAGF01 NagMatrixOperationsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:15 1994
++ Description:
++ This package uses the NAG Library to provide facilities for matrix 
++ factorizations and associated transformations.
++ See \downlink{Manual Page}{manpageXXf01}.
NagMatrixOperationsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    f01brf : (Integer,Integer,Integer,Integer,_
	DoubleFloat,Boolean,Boolean,List Boolean,Matrix DoubleFloat,Matrix Integer,Matrix Integer,Integer) -> Result 
     ++ f01brf(n,nz,licn,lirn,pivot,lblock,grow,abort,a,irn,icn,ifail)
     ++ factorizes a real sparse matrix. The routine either forms 
     ++ the LU factorization of a permutation of the entire matrix, or, 
     ++ optionally, first permutes the matrix to block lower triangular 
     ++ form and then only factorizes the diagonal blocks.
     ++ See \downlink{Manual Page}{manpageXXf01brf}.
    f01bsf : (Integer,Integer,Integer,Matrix Integer,_
	Matrix Integer,Matrix Integer,Matrix Integer,Boolean,DoubleFloat,Boolean,Matrix Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ f01bsf(n,nz,licn,ivect,jvect,icn,ikeep,grow,eta,abort,idisp,avals,ifail)
     ++ factorizes a real sparse matrix using the pivotal sequence
     ++ previously obtained by F01BRF when a matrix of the same sparsity 
     ++ pattern was factorized.
     ++ See \downlink{Manual Page}{manpageXXf01bsf}.
    f01maf : (Integer,Integer,Integer,Integer,_
	List Boolean,Matrix DoubleFloat,Matrix Integer,Matrix Integer,DoubleFloat,DoubleFloat,Integer) -> Result 
     ++ f01maf(n,nz,licn,lirn,abort,avals,irn,icn,droptl,densw,ifail)
     ++ computes an incomplete Cholesky factorization of a real 
     ++ sparse symmetric positive-definite matrix A.
     ++ See \downlink{Manual Page}{manpageXXf01maf}.
    f01mcf : (Integer,Matrix DoubleFloat,Integer,Matrix Integer,_
	Integer) -> Result 
     ++ f01mcf(n,avals,lal,nrow,ifail)
     ++ computes the Cholesky factorization of a real symmetric 
     ++ positive-definite variable-bandwidth matrix.
     ++ See \downlink{Manual Page}{manpageXXf01mcf}.
    f01qcf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ f01qcf(m,n,lda,a,ifail)
     ++ finds the QR factorization of the real m by n matrix A, 
     ++ where m>=n.
     ++ See \downlink{Manual Page}{manpageXXf01qcf}.
    f01qdf : (String,String,Integer,Integer,_
	Matrix DoubleFloat,Integer,Matrix DoubleFloat,Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ f01qdf(trans,wheret,m,n,a,lda,zeta,ncolb,ldb,b,ifail)
     ++ performs one of the transformations
     ++ See \downlink{Manual Page}{manpageXXf01qdf}.
    f01qef : (String,Integer,Integer,Integer,_
	Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ f01qef(wheret,m,n,ncolq,lda,zeta,a,ifail)
     ++ returns the first ncolq columns of the real m by m 
     ++ orthogonal matrix Q, where Q is given as the product of 
     ++ Householder transformation matrices.
     ++ See \downlink{Manual Page}{manpageXXf01qef}.
    f01rcf : (Integer,Integer,Integer,Matrix Complex DoubleFloat,_
	Integer) -> Result 
     ++ f01rcf(m,n,lda,a,ifail)
     ++ finds the QR factorization of the complex m by n matrix A,
     ++ where m>=n.
     ++ See \downlink{Manual Page}{manpageXXf01rcf}.
    f01rdf : (String,String,Integer,Integer,_
	Matrix Complex DoubleFloat,Integer,Matrix Complex DoubleFloat,Integer,Integer,Matrix Complex DoubleFloat,Integer) -> Result 
     ++ f01rdf(trans,wheret,m,n,a,lda,theta,ncolb,ldb,b,ifail)
     ++ performs one of the transformations
     ++ See \downlink{Manual Page}{manpageXXf01rdf}.
    f01ref : (String,Integer,Integer,Integer,_
	Integer,Matrix Complex DoubleFloat,Matrix Complex DoubleFloat,Integer) -> Result 
     ++ f01ref(wheret,m,n,ncolq,lda,theta,a,ifail)
     ++ returns the first ncolq columns of the complex m by m 
     ++ unitary matrix Q, where Q is given as the product of Householder 
     ++ transformation matrices.
     ++ See \downlink{Manual Page}{manpageXXf01ref}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Boolean)
    import AnyFunctions1(String)
    import AnyFunctions1(List Boolean)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Complex DoubleFloat)
    import AnyFunctions1(Matrix Integer)


    f01brf(nArg:Integer,nzArg:Integer,licnArg:Integer,_
	lirnArg:Integer,pivotArg:DoubleFloat,lblockArg:Boolean,_
	growArg:Boolean,abortArg:List Boolean,aArg:Matrix DoubleFloat,_
	irnArg:Matrix Integer,icnArg:Matrix Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01brf",_
	["n"::S,"nz"::S,"licn"::S,"lirn"::S,"pivot"::S_
	,"lblock"::S,"grow"::S,"ifail"::S,"abort"::S,"ikeep"::S,"w"::S,"idisp"::S,"a"::S_
	,"irn"::S,"icn"::S,"iw"::S]$Lisp,_
	["ikeep"::S,"w"::S,"idisp"::S,"iw"::S]$Lisp,_
	[["double"::S,"pivot"::S,["w"::S,"n"::S]$Lisp_
	,["a"::S,"licn"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"nz"::S,"licn"::S,"lirn"::S_
	,["ikeep"::S,["*"::S,5$Lisp,"n"::S]$Lisp]$Lisp,["idisp"::S,10$Lisp]$Lisp,["irn"::S,"lirn"::S]$Lisp,["icn"::S,"licn"::S]$Lisp_
	,"ifail"::S,["iw"::S,["*"::S,8$Lisp,"n"::S]$Lisp]$Lisp]$Lisp_
	,["logical"::S,"lblock"::S,"grow"::S,["abort"::S,4$Lisp]$Lisp]$Lisp_
	]$Lisp,_
	["ikeep"::S,"w"::S,"idisp"::S,"a"::S,"irn"::S,"icn"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nzArg::Any,licnArg::Any,lirnArg::Any,pivotArg::Any,lblockArg::Any,growArg::Any,ifailArg::Any,abortArg::Any,aArg::Any,irnArg::Any,icnArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01bsf(nArg:Integer,nzArg:Integer,licnArg:Integer,_
	ivectArg:Matrix Integer,jvectArg:Matrix Integer,icnArg:Matrix Integer,_
	ikeepArg:Matrix Integer,growArg:Boolean,etaArg:DoubleFloat,_
	abortArg:Boolean,idispArg:Matrix Integer,avalsArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01bsf",_
	["n"::S,"nz"::S,"licn"::S,"grow"::S,"eta"::S_
	,"abort"::S,"rpmin"::S,"ifail"::S,"ivect"::S,"jvect"::S,"icn"::S,"ikeep"::S,"idisp"::S_
	,"w"::S,"avals"::S,"iw"::S]$Lisp,_
	["w"::S,"rpmin"::S,"iw"::S]$Lisp,_
	[["double"::S,"eta"::S,["w"::S,"n"::S]$Lisp_
	,"rpmin"::S,["avals"::S,"licn"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"nz"::S,"licn"::S,["ivect"::S,"nz"::S]$Lisp_
	,["jvect"::S,"nz"::S]$Lisp,["icn"::S,"licn"::S]$Lisp,["ikeep"::S,["*"::S,5$Lisp,"n"::S]$Lisp]$Lisp_
	,["idisp"::S,2$Lisp]$Lisp,"ifail"::S,["iw"::S,["*"::S,8$Lisp,"n"::S]$Lisp]$Lisp]$Lisp_
	,["logical"::S,"grow"::S,"abort"::S]$Lisp_
	]$Lisp,_
	["w"::S,"rpmin"::S,"avals"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nzArg::Any,licnArg::Any,growArg::Any,etaArg::Any,abortArg::Any,ifailArg::Any,ivectArg::Any,jvectArg::Any,icnArg::Any,ikeepArg::Any,idispArg::Any,avalsArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01maf(nArg:Integer,nzArg:Integer,licnArg:Integer,_
	lirnArg:Integer,abortArg:List Boolean,avalsArg:Matrix DoubleFloat,_
	irnArg:Matrix Integer,icnArg:Matrix Integer,droptlArg:DoubleFloat,_
	denswArg:DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01maf",_
	["n"::S,"nz"::S,"licn"::S,"lirn"::S,"droptl"::S_
	,"densw"::S,"ifail"::S,"abort"::S,"wkeep"::S,"ikeep"::S,"inform"::S,"avals"::S_
	,"irn"::S,"icn"::S,"iwork"::S]$Lisp,_
	["wkeep"::S,"ikeep"::S,"inform"::S,"iwork"::S]$Lisp,_
	[["double"::S,["wkeep"::S,["*"::S,3$Lisp,"n"::S]$Lisp]$Lisp_
	,["avals"::S,"licn"::S]$Lisp,"droptl"::S,"densw"::S]$Lisp_
	,["integer"::S,"n"::S,"nz"::S,"licn"::S,"lirn"::S_
	,["ikeep"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["inform"::S,4$Lisp]$Lisp,["irn"::S,"lirn"::S]$Lisp,["icn"::S,"licn"::S]$Lisp_
	,"ifail"::S,["iwork"::S,["*"::S,6$Lisp,"n"::S]$Lisp]$Lisp]$Lisp_
	,["logical"::S,["abort"::S,3$Lisp]$Lisp]$Lisp_
	]$Lisp,_
	["wkeep"::S,"ikeep"::S,"inform"::S,"avals"::S,"irn"::S,"icn"::S,"droptl"::S,"densw"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nzArg::Any,licnArg::Any,lirnArg::Any,droptlArg::Any,denswArg::Any,ifailArg::Any,abortArg::Any,avalsArg::Any,irnArg::Any,icnArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01mcf(nArg:Integer,avalsArg:Matrix DoubleFloat,lalArg:Integer,_
	nrowArg:Matrix Integer,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01mcf",_
	["n"::S,"lal"::S,"ifail"::S,"avals"::S,"nrow"::S,"al"::S,"d"::S]$Lisp,_
	["al"::S,"d"::S]$Lisp,_
	[["double"::S,["avals"::S,"lal"::S]$Lisp,["al"::S,"lal"::S]$Lisp_
	,["d"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"lal"::S,["nrow"::S,"n"::S]$Lisp_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["al"::S,"d"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,lalArg::Any,ifailArg::Any,avalsArg::Any,nrowArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01qcf(mArg:Integer,nArg:Integer,ldaArg:Integer,_
	aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01qcf",_
	["m"::S,"n"::S,"lda"::S,"ifail"::S,"zeta"::S,"a"::S]$Lisp,_
	["zeta"::S]$Lisp,_
	[["double"::S,["zeta"::S,"n"::S]$Lisp,["a"::S,"lda"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"lda"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["zeta"::S,"a"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ldaArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01qdf(transArg:String,wheretArg:String,mArg:Integer,_
	nArg:Integer,aArg:Matrix DoubleFloat,ldaArg:Integer,_
	zetaArg:Matrix DoubleFloat,ncolbArg:Integer,ldbArg:Integer,_
	bArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01qdf",_
	["trans"::S,"wheret"::S,"m"::S,"n"::S,"lda"::S_
	,"ncolb"::S,"ldb"::S,"ifail"::S,"a"::S,"zeta"::S,"b"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["a"::S,"lda"::S,"n"::S]$Lisp_
	,["zeta"::S,"n"::S]$Lisp,["b"::S,"ldb"::S,"ncolb"::S]$Lisp,["work"::S,"ncolb"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"lda"::S,"ncolb"::S_
	,"ldb"::S,"ifail"::S]$Lisp_
	,["character"::S,"trans"::S,"wheret"::S]$Lisp_
	]$Lisp,_
	["b"::S,"ifail"::S]$Lisp,_
	[([transArg::Any,wheretArg::Any,mArg::Any,nArg::Any,ldaArg::Any,ncolbArg::Any,ldbArg::Any,ifailArg::Any,aArg::Any,zetaArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01qef(wheretArg:String,mArg:Integer,nArg:Integer,_
	ncolqArg:Integer,ldaArg:Integer,zetaArg:Matrix DoubleFloat,_
	aArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01qef",_
	["wheret"::S,"m"::S,"n"::S,"ncolq"::S,"lda"::S_
	,"ifail"::S,"zeta"::S,"a"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["zeta"::S,"n"::S]$Lisp,["a"::S,"lda"::S,"ncolq"::S]$Lisp_
	,["work"::S,"ncolq"::S]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ncolq"::S,"lda"::S_
	,"ifail"::S]$Lisp_
	,["character"::S,"wheret"::S]$Lisp_
	]$Lisp,_
	["a"::S,"ifail"::S]$Lisp,_
	[([wheretArg::Any,mArg::Any,nArg::Any,ncolqArg::Any,ldaArg::Any,ifailArg::Any,zetaArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01rcf(mArg:Integer,nArg:Integer,ldaArg:Integer,_
	aArg:Matrix Complex DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01rcf",_
	["m"::S,"n"::S,"lda"::S,"ifail"::S,"theta"::S,"a"::S]$Lisp,_
	["theta"::S]$Lisp,_
	[["integer"::S,"m"::S,"n"::S,"lda"::S,"ifail"::S_
	]$Lisp_
	,["double complex"::S,["theta"::S,"n"::S]$Lisp,["a"::S,"lda"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp,_
	["theta"::S,"a"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ldaArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01rdf(transArg:String,wheretArg:String,mArg:Integer,_
	nArg:Integer,aArg:Matrix Complex DoubleFloat,ldaArg:Integer,_
	thetaArg:Matrix Complex DoubleFloat,ncolbArg:Integer,ldbArg:Integer,_
	bArg:Matrix Complex DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01rdf",_
	["trans"::S,"wheret"::S,"m"::S,"n"::S,"lda"::S_
	,"ncolb"::S,"ldb"::S,"ifail"::S,"a"::S,"theta"::S,"b"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["integer"::S,"m"::S,"n"::S,"lda"::S,"ncolb"::S_
	,"ldb"::S,"ifail"::S]$Lisp_
	,["character"::S,"trans"::S,"wheret"::S]$Lisp_
	,["double complex"::S,["a"::S,"lda"::S,"n"::S]$Lisp,["theta"::S,"n"::S]$Lisp,["b"::S,"ldb"::S,"ncolb"::S]$Lisp,["work"::S,"ncolb"::S]$Lisp]$Lisp_
	]$Lisp,_
	["b"::S,"ifail"::S]$Lisp,_
	[([transArg::Any,wheretArg::Any,mArg::Any,nArg::Any,ldaArg::Any,ncolbArg::Any,ldbArg::Any,ifailArg::Any,aArg::Any,thetaArg::Any,bArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    f01ref(wheretArg:String,mArg:Integer,nArg:Integer,_
	ncolqArg:Integer,ldaArg:Integer,thetaArg:Matrix Complex DoubleFloat,_
	aArg:Matrix Complex DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"f01ref",_
	["wheret"::S,"m"::S,"n"::S,"ncolq"::S,"lda"::S_
	,"ifail"::S,"theta"::S,"a"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["integer"::S,"m"::S,"n"::S,"ncolq"::S,"lda"::S_
	,"ifail"::S]$Lisp_
	,["character"::S,"wheret"::S]$Lisp_
	,["double complex"::S,["theta"::S,"n"::S]$Lisp,["a"::S,"lda"::S,"n"::S]$Lisp,["work"::S,"ncolq"::S]$Lisp]$Lisp_
	]$Lisp,_
	["a"::S,"ifail"::S]$Lisp,_
	[([wheretArg::Any,mArg::Any,nArg::Any,ncolqArg::Any,ldaArg::Any,ifailArg::Any,thetaArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGF01.dotabb>>=
"NAGF01" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGF01"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"NAGF01" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGE04 NagOptimisationPackage}
\pagehead{NagOptimisationPackage}{NAGE04}
\pagepic{ps/v104nagoptimisationpackage.ps}{NAGE04}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGE04 NagOptimisationPackage>>=
)abbrev package NAGE04 NagOptimisationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:45:09 1994
++ Description:
++ This package uses the NAG Library to perform optimization.
++ An optimization problem involves minimizing a function (called
++ the objective function) of several variables, possibly subject to
++ restrictions on the values of the variables defined by a set of
++ constraint functions. The routines in the NAG Foundation Library
++ are concerned with function minimization only, since the problem
++ of maximizing a given function can be transformed into a
++ minimization problem simply by multiplying the function by -1.
++ See \downlink{Manual Page}{manpageXXe04}.
NagOptimisationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    e04dgf : (Integer,DoubleFloat,DoubleFloat,Integer,_
	DoubleFloat,Boolean,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp49(OBJFUN))) -> Result 
     ++ e04dgf(n,es,fu,it,lin,list,ma,op,pr,sta,sto,ve,x,ifail,objfun)
     ++ minimizes an unconstrained nonlinear function of several 
     ++ variables using a pre-conditioned, limited memory quasi-Newton 
     ++ conjugate gradient method. First derivatives are required. The 
     ++ routine is intended for use on large scale problems.
     ++ See \downlink{Manual Page}{manpageXXe04dgf}.
    e04fdf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp50(LSFUN1))) -> Result 
     ++ e04fdf(m,n,liw,lw,x,ifail,lsfun1)
     ++ is an easy-to-use algorithm for finding an unconstrained 
     ++ minimum of a sum of squares of m nonlinear functions in n 
     ++ variables (m>=n). No derivatives are required.
     ++ See \downlink{Manual Page}{manpageXXe04fdf}.
    e04gcf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp19(LSFUN2))) -> Result 
     ++ e04gcf(m,n,liw,lw,x,ifail,lsfun2)
     ++ is an easy-to-use quasi-Newton algorithm for finding an 
     ++ unconstrained minimum of m nonlinear 
     ++ functions in n variables (m>=n). First derivatives are required.
     ++ See \downlink{Manual Page}{manpageXXe04gcf}.
    e04jaf : (Integer,Integer,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp24(FUNCT1))) -> Result 
     ++ e04jaf(n,ibound,liw,lw,bl,bu,x,ifail,funct1)
     ++ is an easy-to-use quasi-Newton algorithm for finding a 
     ++ minimum of a function F(x ,x ,...,x ), subject to fixed upper and
     ++                          1  2      n                          
     ++ lower bounds of the independent variables x ,x ,...,x , using 
     ++                                            1  2      n       
     ++ function values only.
     ++ See \downlink{Manual Page}{manpageXXe04jaf}.
    e04mbf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Boolean,Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e04mbf(itmax,msglvl,n,nclin,nctotl,nrowa,a,bl,bu,cvec,linobj,liwork,lwork,x,ifail)
     ++ is an easy-to-use routine for solving linear programming 
     ++ problems, or for finding a feasible point for such problems. It 
     ++ is not intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04mbf}.
    e04naf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Integer,Integer,DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Boolean,Boolean,Boolean,Integer,Integer,Matrix DoubleFloat,Matrix Integer,Integer,Union(fn:FileName,fp:Asp20(QPHESS))) -> Result 
     ++ e04naf(itmax,msglvl,n,nclin,nctotl,nrowa,nrowh,ncolh,bigbnd,a,bl,bu,cvec,featol,hess,cold,lpp,orthog,liwork,lwork,x,istate,ifail,qphess)
     ++ is a comprehensive 
     ++ programming (QP) or linear programming (LP) problems. It is not 
     ++ intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04naf}.
    e04ucf : (Integer,Integer,Integer,Integer,_
	Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Boolean,DoubleFloat,Integer,DoubleFloat,DoubleFloat,Boolean,DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,Boolean,Integer,Integer,Integer,Integer,Integer,DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Integer,Integer,Integer,Matrix Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp55(CONFUN)),Union(fn:FileName,fp:Asp49(OBJFUN))) -> Result 
     ++ e04ucf(n,nclin,ncnln,nrowa,nrowj,nrowr,a,bl,bu,liwork,lwork,sta,cra,der,fea,fun,hes,infb,infs,linf,lint,list,maji,majp,mini,minp,mon,nonf,opt,ste,stao,stac,stoo,stoc,ve,istate,cjac,clamda,r,x,ifail,confun,objfun)
     ++ is designed to minimize an arbitrary smooth function 
     ++ subject to constraints on the 
     ++ variables, linear constraints.  
     ++ (E04UCF  may be used for unconstrained, bound-constrained and 
     ++ linearly constrained optimization.) The user must provide 
     ++ subroutines that define the objective and constraint functions 
     ++ and as many of their first partial derivatives as possible. 
     ++ Unspecified derivatives are approximated by finite differences. 
     ++ All matrices are treated as dense, and hence E04UCF is not 
     ++ intended for large sparse problems.
     ++ See \downlink{Manual Page}{manpageXXe04ucf}.
    e04ycf : (Integer,Integer,Integer,DoubleFloat,_
	Matrix DoubleFloat,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ e04ycf(job,m,n,fsumsq,s,lv,v,ifail)
     ++ returns estimates of elements of the variance 
     ++ matrix of the estimated regression coefficients for a nonlinear 
     ++ least squares problem. The estimates are derived from the 
     ++ Jacobian of the function f(x) at the solution.
     ++ See \downlink{Manual Page}{manpageXXe04ycf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp49(OBJFUN))
    import AnyFunctions1(Integer)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Boolean)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Matrix Integer)


    e04dgf(nArg:Integer,esArg:DoubleFloat,fuArg:DoubleFloat,_
	itArg:Integer,linArg:DoubleFloat,listArg:Boolean,_
	maArg:DoubleFloat,opArg:DoubleFloat,prArg:Integer,_
	staArg:Integer,stoArg:Integer,veArg:Integer,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,objfunArg:Union(fn:FileName,fp:Asp49(OBJFUN))): Result == 
	pushFortranOutputStack(objfunFilename := aspFilename "objfun")$FOP
	if objfunArg case fn
		  then outputAsFortran(objfunArg.fn)
		  else outputAsFortran(objfunArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([objfunFilename]$Lisp,_
	"e04dgf",_
	["n"::S,"es"::S,"fu"::S,"it"::S,"lin"::S_
	,"list"::S,"ma"::S,"op"::S,"pr"::S,"sta"::S_
	,"sto"::S,"ve"::S,"iter"::S,"objf"::S,"ifail"::S_
	,"objfun"::S,"objgrd"::S,"x"::S,"iwork"::S,"work"::S,"iuser"::S_
	,"user"::S]$Lisp,_
	["iter"::S,"objf"::S,"objgrd"::S,"iwork"::S,"work"::S,"iuser"::S,"user"::S,"objfun"::S]$Lisp,_
	[["double"::S,"es"::S,"fu"::S,"lin"::S,"ma"::S_
	,"op"::S,"objf"::S,["objgrd"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,["*"::S,13$Lisp,"n"::S]$Lisp]$Lisp,["user"::S,"*"::S]$Lisp_
	,"objfun"::S]$Lisp_
	,["integer"::S,"n"::S,"it"::S,"pr"::S,"sta"::S_
	,"sto"::S,"ve"::S,"iter"::S,"ifail"::S,["iwork"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,["iuser"::S,"*"::S]$Lisp]$Lisp_
	,["logical"::S,"list"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"objf"::S,"objgrd"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,esArg::Any,fuArg::Any,itArg::Any,linArg::Any,listArg::Any,maArg::Any,opArg::Any,prArg::Any,staArg::Any,stoArg::Any,veArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04fdf(mArg:Integer,nArg:Integer,liwArg:Integer,_
	lwArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	lsfun1Arg:Union(fn:FileName,fp:Asp50(LSFUN1))): Result == 
	pushFortranOutputStack(lsfun1Filename := aspFilename "lsfun1")$FOP
	if lsfun1Arg case fn
		  then outputAsFortran(lsfun1Arg.fn)
		  else outputAsFortran(lsfun1Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([lsfun1Filename]$Lisp,_
	"e04fdf",_
	["m"::S,"n"::S,"liw"::S,"lw"::S,"fsumsq"::S_
	,"ifail"::S,"lsfun1"::S,"w"::S,"x"::S,"iw"::S]$Lisp,_
	["fsumsq"::S,"w"::S,"iw"::S,"lsfun1"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["w"::S,"lw"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"lsfun1"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"liw"::S,"lw"::S_
	,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["fsumsq"::S,"w"::S,"x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04gcf(mArg:Integer,nArg:Integer,liwArg:Integer,_
	lwArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer,_
	lsfun2Arg:Union(fn:FileName,fp:Asp19(LSFUN2))): Result == 
	pushFortranOutputStack(lsfun2Filename := aspFilename "lsfun2")$FOP
	if lsfun2Arg case fn
		  then outputAsFortran(lsfun2Arg.fn)
		  else outputAsFortran(lsfun2Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([lsfun2Filename]$Lisp,_
	"e04gcf",_
	["m"::S,"n"::S,"liw"::S,"lw"::S,"fsumsq"::S_
	,"ifail"::S,"lsfun2"::S,"w"::S,"x"::S,"iw"::S]$Lisp,_
	["fsumsq"::S,"w"::S,"iw"::S,"lsfun2"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["w"::S,"lw"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"lsfun2"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"liw"::S,"lw"::S_
	,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["fsumsq"::S,"w"::S,"x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04jaf(nArg:Integer,iboundArg:Integer,liwArg:Integer,_
	lwArg:Integer,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,funct1Arg:Union(fn:FileName,fp:Asp24(FUNCT1))): Result == 
	pushFortranOutputStack(funct1Filename := aspFilename "funct1")$FOP
	if funct1Arg case fn
		  then outputAsFortran(funct1Arg.fn)
		  else outputAsFortran(funct1Arg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([funct1Filename]$Lisp,_
	"e04jaf",_
	["n"::S,"ibound"::S,"liw"::S,"lw"::S,"f"::S_
	,"ifail"::S,"funct1"::S,"bl"::S,"bu"::S,"x"::S,"iw"::S,"w"::S_
	]$Lisp,_
	["f"::S,"iw"::S,"w"::S,"funct1"::S]$Lisp,_
	[["double"::S,"f"::S,["bl"::S,"n"::S]$Lisp_
	,["bu"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["w"::S,"lw"::S]$Lisp,"funct1"::S]$Lisp_
	,["integer"::S,"n"::S,"ibound"::S,"liw"::S_
	,"lw"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["f"::S,"bl"::S,"bu"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,iboundArg::Any,liwArg::Any,lwArg::Any,ifailArg::Any,blArg::Any,buArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04mbf(itmaxArg:Integer,msglvlArg:Integer,nArg:Integer,_
	nclinArg:Integer,nctotlArg:Integer,nrowaArg:Integer,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	cvecArg:Matrix DoubleFloat,linobjArg:Boolean,liworkArg:Integer,_
	lworkArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e04mbf",_
	["itmax"::S,"msglvl"::S,"n"::S,"nclin"::S,"nctotl"::S_
	,"nrowa"::S,"linobj"::S,"liwork"::S,"lwork"::S,"objlp"::S_
	,"ifail"::S,"a"::S,"bl"::S,"bu"::S,"cvec"::S,"istate"::S_
	,"clamda"::S,"x"::S,"iwork"::S,"work"::S]$Lisp,_
	["istate"::S,"objlp"::S,"clamda"::S,"iwork"::S,"work"::S]$Lisp,_
	[["double"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,"nctotl"::S]$Lisp,["bu"::S,"nctotl"::S]$Lisp,["cvec"::S,"n"::S]$Lisp,"objlp"::S,["clamda"::S,"nctotl"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp]$Lisp_
	,["integer"::S,"itmax"::S,"msglvl"::S,"n"::S_
	,"nclin"::S,"nctotl"::S,"nrowa"::S,"liwork"::S,"lwork"::S,["istate"::S,"nctotl"::S]$Lisp,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp_
	]$Lisp_
	,["logical"::S,"linobj"::S]$Lisp_
	]$Lisp,_
	["istate"::S,"objlp"::S,"clamda"::S,"x"::S,"ifail"::S]$Lisp,_
	[([itmaxArg::Any,msglvlArg::Any,nArg::Any,nclinArg::Any,nctotlArg::Any,nrowaArg::Any,linobjArg::Any,liworkArg::Any,lworkArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,cvecArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04naf(itmaxArg:Integer,msglvlArg:Integer,nArg:Integer,_
	nclinArg:Integer,nctotlArg:Integer,nrowaArg:Integer,_
	nrowhArg:Integer,ncolhArg:Integer,bigbndArg:DoubleFloat,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	cvecArg:Matrix DoubleFloat,featolArg:Matrix DoubleFloat,hessArg:Matrix DoubleFloat,_
	coldArg:Boolean,lppArg:Boolean,orthogArg:Boolean,_
	liworkArg:Integer,lworkArg:Integer,xArg:Matrix DoubleFloat,_
	istateArg:Matrix Integer,ifailArg:Integer,qphessArg:Union(fn:FileName,fp:Asp20(QPHESS))): Result == 
	pushFortranOutputStack(qphessFilename := aspFilename "qphess")$FOP
	if qphessArg case fn
		  then outputAsFortran(qphessArg.fn)
		  else outputAsFortran(qphessArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([qphessFilename]$Lisp,_
	"e04naf",_
	["itmax"::S,"msglvl"::S,"n"::S,"nclin"::S,"nctotl"::S_
	,"nrowa"::S,"nrowh"::S,"ncolh"::S,"bigbnd"::S,"cold"::S_
	,"lpp"::S,"orthog"::S,"liwork"::S,"lwork"::S,"iter"::S_
	,"obj"::S,"ifail"::S,"qphess"::S,"a"::S,"bl"::S,"bu"::S,"cvec"::S,"featol"::S_
	,"hess"::S,"clamda"::S,"x"::S,"istate"::S,"iwork"::S_
	,"work"::S]$Lisp,_
	["iter"::S,"obj"::S,"clamda"::S,"iwork"::S,"work"::S,"qphess"::S]$Lisp,_
	[["double"::S,"bigbnd"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,"nctotl"::S]$Lisp,["bu"::S,"nctotl"::S]$Lisp,["cvec"::S,"n"::S]$Lisp,["featol"::S,"nctotl"::S]$Lisp_
	,["hess"::S,"nrowh"::S,"ncolh"::S]$Lisp,"obj"::S,["clamda"::S,"nctotl"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp_
	,"qphess"::S]$Lisp_
	,["integer"::S,"itmax"::S,"msglvl"::S,"n"::S_
	,"nclin"::S,"nctotl"::S,"nrowa"::S,"nrowh"::S,"ncolh"::S,"liwork"::S,"lwork"::S,"iter"::S,["istate"::S,"nctotl"::S]$Lisp_
	,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	,["logical"::S,"cold"::S,"lpp"::S,"orthog"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"obj"::S,"clamda"::S,"x"::S,"istate"::S,"ifail"::S]$Lisp,_
	[([itmaxArg::Any,msglvlArg::Any,nArg::Any,nclinArg::Any,nctotlArg::Any,nrowaArg::Any,nrowhArg::Any,ncolhArg::Any,bigbndArg::Any,coldArg::Any,lppArg::Any,orthogArg::Any,liworkArg::Any,lworkArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,cvecArg::Any,featolArg::Any,hessArg::Any,xArg::Any,istateArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04ucf(nArg:Integer,nclinArg:Integer,ncnlnArg:Integer,_
	nrowaArg:Integer,nrowjArg:Integer,nrowrArg:Integer,_
	aArg:Matrix DoubleFloat,blArg:Matrix DoubleFloat,buArg:Matrix DoubleFloat,_
	liworkArg:Integer,lworkArg:Integer,staArg:Boolean,_
	craArg:DoubleFloat,derArg:Integer,feaArg:DoubleFloat,_
	funArg:DoubleFloat,hesArg:Boolean,infbArg:DoubleFloat,_
	infsArg:DoubleFloat,linfArg:DoubleFloat,lintArg:DoubleFloat,_
	listArg:Boolean,majiArg:Integer,majpArg:Integer,_
	miniArg:Integer,minpArg:Integer,monArg:Integer,_
	nonfArg:DoubleFloat,optArg:DoubleFloat,steArg:DoubleFloat,_
	staoArg:Integer,stacArg:Integer,stooArg:Integer,_
	stocArg:Integer,veArg:Integer,istateArg:Matrix Integer,_
	cjacArg:Matrix DoubleFloat,clamdaArg:Matrix DoubleFloat,rArg:Matrix DoubleFloat,_
	xArg:Matrix DoubleFloat,ifailArg:Integer,confunArg:Union(fn:FileName,fp:Asp55(CONFUN)),_
	objfunArg:Union(fn:FileName,fp:Asp49(OBJFUN))): Result == 
	pushFortranOutputStack(confunFilename := aspFilename "confun")$FOP
	if confunArg case fn
		  then outputAsFortran(confunArg.fn)
		  else outputAsFortran(confunArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(objfunFilename := aspFilename "objfun")$FOP
	if objfunArg case fn
		  then outputAsFortran(objfunArg.fn)
		  else outputAsFortran(objfunArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([confunFilename,objfunFilename]$Lisp,_
	"e04ucf",_
	["n"::S,"nclin"::S,"ncnln"::S,"nrowa"::S,"nrowj"::S_
	,"nrowr"::S,"liwork"::S,"lwork"::S,"sta"::S,"cra"::S_
	,"der"::S,"fea"::S,"fun"::S,"hes"::S,"infb"::S_
	,"infs"::S,"linf"::S,"lint"::S,"list"::S,"maji"::S_
	,"majp"::S,"mini"::S,"minp"::S,"mon"::S,"nonf"::S_
	,"opt"::S,"ste"::S,"stao"::S,"stac"::S,"stoo"::S_
	,"stoc"::S,"ve"::S,"iter"::S,"objf"::S,"ifail"::S_
	,"confun"::S,"objfun"::S,"a"::S,"bl"::S,"bu"::S,"c"::S,"objgrd"::S_
	,"istate"::S,"cjac"::S,"clamda"::S,"r"::S,"x"::S_
	,"iwork"::S,"work"::S,"iuser"::S,"user"::S]$Lisp,_
	["iter"::S,"c"::S,"objf"::S,"objgrd"::S,"iwork"::S,"work"::S,"iuser"::S,"user"::S,"confun"::S,"objfun"::S]$Lisp,_
	[["double"::S,["a"::S,"nrowa"::S,"n"::S]$Lisp_
	,["bl"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp,["bu"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,"cra"::S,"fea"::S,"fun"::S,"infb"::S,"infs"::S,"linf"::S,"lint"::S,"nonf"::S,"opt"::S,"ste"::S_
	,["c"::S,"ncnln"::S]$Lisp,"objf"::S,["objgrd"::S,"n"::S]$Lisp,["cjac"::S,"nrowj"::S,"n"::S]$Lisp,["clamda"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,["r"::S,"nrowr"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp,["work"::S,"lwork"::S]$Lisp_
	,["user"::S,1$Lisp]$Lisp,"confun"::S,"objfun"::S]$Lisp_
	,["integer"::S,"n"::S,"nclin"::S,"ncnln"::S_
	,"nrowa"::S,"nrowj"::S,"nrowr"::S,"liwork"::S,"lwork"::S,"der"::S,"maji"::S,"majp"::S,"mini"::S,"minp"::S,"mon"::S,"stao"::S_
	,"stac"::S,"stoo"::S,"stoc"::S,"ve"::S,"iter"::S,["istate"::S,["+"::S,["+"::S,"nclin"::S,"ncnln"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp,["iuser"::S,1$Lisp]$Lisp]$Lisp_
	,["logical"::S,"sta"::S,"hes"::S,"list"::S]$Lisp_
	]$Lisp,_
	["iter"::S,"c"::S,"objf"::S,"objgrd"::S,"istate"::S,"cjac"::S,"clamda"::S,"r"::S,"x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,nclinArg::Any,ncnlnArg::Any,nrowaArg::Any,nrowjArg::Any,nrowrArg::Any,liworkArg::Any,lworkArg::Any,staArg::Any,craArg::Any,derArg::Any,feaArg::Any,funArg::Any,hesArg::Any,infbArg::Any,infsArg::Any,linfArg::Any,lintArg::Any,listArg::Any,majiArg::Any,majpArg::Any,miniArg::Any,minpArg::Any,monArg::Any,nonfArg::Any,optArg::Any,steArg::Any,staoArg::Any,stacArg::Any,stooArg::Any,stocArg::Any,veArg::Any,ifailArg::Any,aArg::Any,blArg::Any,buArg::Any,istateArg::Any,cjacArg::Any,clamdaArg::Any,rArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    e04ycf(jobArg:Integer,mArg:Integer,nArg:Integer,_
	fsumsqArg:DoubleFloat,sArg:Matrix DoubleFloat,lvArg:Integer,_
	vArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"e04ycf",_
	["job"::S,"m"::S,"n"::S,"fsumsq"::S,"lv"::S_
	,"ifail"::S,"s"::S,"cj"::S,"v"::S,"work"::S]$Lisp,_
	["cj"::S,"work"::S]$Lisp,_
	[["double"::S,"fsumsq"::S,["s"::S,"n"::S]$Lisp_
	,["cj"::S,"n"::S]$Lisp,["v"::S,"lv"::S,"n"::S]$Lisp,["work"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"job"::S,"m"::S,"n"::S,"lv"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["cj"::S,"v"::S,"ifail"::S]$Lisp,_
	[([jobArg::Any,mArg::Any,nArg::Any,fsumsqArg::Any,lvArg::Any,ifailArg::Any,sArg::Any,vArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGE04.dotabb>>=
"NAGE04" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGE04"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGE04" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD02 NagOrdinaryDifferentialEquationsPackage}
\pagehead{NagOrdinaryDifferentialEquationsPackage}{NAGD02}
\pagepic{ps/v104nagordinarydifferentialequationspackage.ps}{NAGD02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD02 NagOrdinaryDifferentialEquationsPackage>>=
)abbrev package NAGD02 NagOrdinaryDifferentialEquationsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Mon Jun 20 17:56:33 1994
++ Description:
++ This package uses the NAG Library to calculate the numerical solution of 
++ ordinary differential equations. There are two main types of problem,
++ those in which all boundary conditions are specified at one point
++ (initial-value problems), and those in which the boundary
++ conditions are distributed between two or more points (boundary-
++ value problems and eigenvalue problems). Routines are available
++ for initial-value problems, two-point boundary-value problems and
++ Sturm-Liouville eigenvalue problems.
++ See \downlink{Manual Page}{manpageXXd02}.
NagOrdinaryDifferentialEquationsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d02bbf : (DoubleFloat,Integer,Integer,Integer,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02bbf(xend,m,n,irelab,x,y,tol,ifail,fcn,output)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over an interval with suitable initial conditions, 
     ++ using a Runge-Kutta-Merson method, and returns the solution at 
     ++ points specified by the user.
     ++ See \downlink{Manual Page}{manpageXXd02bbf}.
    d02bhf : (DoubleFloat,Integer,Integer,DoubleFloat,_
	DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN))) -> Result 
     ++ d02bhf(xend,n,irelab,hmax,x,y,tol,ifail,g,fcn)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over an interval with suitable initial conditions, 
     ++ using a Runge-Kutta-Merson method, until a user-specified 
     ++ function of the solution is zero.
     ++ See \downlink{Manual Page}{manpageXXd02bhf}.
    d02cjf : (DoubleFloat,Integer,Integer,DoubleFloat,_
	String,DoubleFloat,Matrix DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02cjf(xend,m,n,tol,relabs,x,y,ifail,g,fcn,output)
     ++ integrates a system of first-order ordinary differential 
     ++ equations over a range with suitable initial conditions, using a 
     ++ variable-order, variable-step Adams method until a user-specified
     ++ function, if supplied, of the solution is zero, and returns the 
     ++ solution at points specified by the user, if desired.
     ++ See \downlink{Manual Page}{manpageXXd02cjf}.
    d02ejf : (DoubleFloat,Integer,Integer,String,_
	Integer,DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp9(G)),Union(fn:FileName,fp:Asp7(FCN)),Union(fn:FileName,fp:Asp31(PEDERV)),Union(fn:FileName,fp:Asp8(OUTPUT))) -> Result 
     ++ d02ejf(xend,m,n,relabs,iw,x,y,tol,ifail,g,fcn,pederv,output)
     ++ integrates a stiff system of first-order ordinary 
     ++ differential equations over an interval with suitable initial 
     ++ conditions, using a variable-order, variable-step method 
     ++ implementing the Backward Differentiation Formulae (BDF), until a
     ++ user-specified function, if supplied, of the solution is zero, 
     ++ and returns the solution at points specified by the user, if 
     ++ desired.
     ++ See \downlink{Manual Page}{manpageXXd02ejf}.
    d02gaf : (Matrix DoubleFloat,Matrix DoubleFloat,Integer,DoubleFloat,_
	DoubleFloat,DoubleFloat,Integer,Integer,Integer,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp7(FCN))) -> Result 
     ++ d02gaf(u,v,n,a,b,tol,mnp,lw,liw,x,np,ifail,fcn)
     ++ solves the two-point boundary-value problem with assigned 
     ++ boundary values for a system of ordinary differential equations, 
     ++ using a deferred correction technique and a Newton iteration.
     ++ See \downlink{Manual Page}{manpageXXd02gaf}.
    d02gbf : (DoubleFloat,DoubleFloat,Integer,DoubleFloat,_
	Integer,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp77(FCNF)),Union(fn:FileName,fp:Asp78(FCNG))) -> Result 
     ++ d02gbf(a,b,n,tol,mnp,lw,liw,c,d,gam,x,np,ifail,fcnf,fcng)
     ++ solves a general linear two-point boundary value problem 
     ++ for a system of ordinary differential equations using a deferred 
     ++ correction technique.
     ++ See \downlink{Manual Page}{manpageXXd02gbf}.
    d02kef : (Matrix DoubleFloat,Integer,Integer,DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp10(COEFFN)),Union(fn:FileName,fp:Asp80(BDYVAL))) -> Result 
     ++ d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,hmax,maxit,ifail,coeffn,bdyval)
     ++ finds a specified eigenvalue of a regular singular second-
     ++ order Sturm-Liouville system on a finite or infinite range, using
     ++ a Pruefer transformation and a shooting method. It also reports 
     ++ values of the eigenfunction and its derivatives. Provision is 
     ++ made for discontinuities in the coefficient functions or their 
     ++ derivatives.
     ++ See \downlink{Manual Page}{manpageXXd02kef}.
     ++ ASP domains Asp12 and Asp33 are used to supply default
     ++ subroutines for the MONIT and REPORT arguments via their \axiomOp{outputAsFortran} operation.
    d02kef : (Matrix DoubleFloat,Integer,Integer,DoubleFloat,_
	Integer,Integer,DoubleFloat,DoubleFloat,Matrix DoubleFloat,Integer,Integer,Union(fn:FileName,fp:Asp10(COEFFN)),Union(fn:FileName,fp:Asp80(BDYVAL)),FileName,FileName) -> Result 
     ++ d02kef(xpoint,m,k,tol,maxfun,match,elam,delam,hmax,maxit,ifail,coeffn,bdyval,monit,report)
     ++ finds a specified eigenvalue of a regular singular second-
     ++ order Sturm-Liouville system on a finite or infinite range, using
     ++ a Pruefer transformation and a shooting method. It also reports 
     ++ values of the eigenfunction and its derivatives. Provision is 
     ++ made for discontinuities in the coefficient functions or their 
     ++ derivatives.
     ++ See \downlink{Manual Page}{manpageXXd02kef}.
     ++ Files \spad{monit} and \spad{report} will be used to define the subroutines for the
     ++ MONIT and REPORT arguments.
     ++ See \downlink{Manual Page}{manpageXXd02gbf}.
    d02raf : (Integer,Integer,Integer,Integer,_
	DoubleFloat,Integer,Integer,Integer,Integer,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Union(fn:FileName,fp:Asp41(FCN,JACOBF,JACEPS)),Union(fn:FileName,fp:Asp42(G,JACOBG,JACGEP))) -> Result 
     ++ d02raf(n,mnp,numbeg,nummix,tol,init,iy,ijac,lwork,liwork,np,x,y,deleps,ifail,fcn,g)
     ++ solves the two-point boundary-value problem with general 
     ++ boundary conditions for a system of ordinary differential 
     ++ equations, using a deferred correction technique and Newton 
     ++ iteration.
     ++ See \downlink{Manual Page}{manpageXXd02raf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp7(FCN))
    import Union(fn:FileName,fp:Asp8(OUTPUT))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(Matrix DoubleFloat)


    d02bbf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	irelabArg:Integer,xArg:DoubleFloat,yArg:Matrix DoubleFloat,_
	tolArg:DoubleFloat,ifailArg:Integer,fcnArg:Union(fn:FileName,fp:Asp7(FCN)),_
	outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename, outputFilename]$Lisp,_
	"d02bbf",_
	["xend"::S,"m"::S,"n"::S,"irelab"::S,"x"::S_
	,"tol"::S,"ifail"::S,"fcn"::S,"output"::S,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"fcn"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,"tol"::S,["w"::S,"n"::S,7$Lisp]$Lisp,"fcn"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"irelab"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,irelabArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02bhf(xendArg:DoubleFloat,nArg:Integer,irelabArg:Integer,_
	hmaxArg:DoubleFloat,xArg:DoubleFloat,yArg:Matrix DoubleFloat,_
	tolArg:DoubleFloat,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp9(G)),_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename]$Lisp,_
	"d02bhf",_
	["xend"::S,"n"::S,"irelab"::S,"hmax"::S,"x"::S_
	,"tol"::S,"ifail"::S,"g"::S,"fcn"::S,"y"::S,"w"::S]$Lisp,_
	["w"::S,"g"::S,"fcn"::S]$Lisp,_
	[["double"::S,"xend"::S,"hmax"::S,"x"::S,["y"::S,"n"::S]$Lisp_
	,"tol"::S,["w"::S,"n"::S,7$Lisp]$Lisp,"g"::S,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"irelab"::S,"ifail"::S_
	]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,nArg::Any,irelabArg::Any,hmaxArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02cjf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	tolArg:DoubleFloat,relabsArg:String,xArg:DoubleFloat,_
	yArg:Matrix DoubleFloat,ifailArg:Integer,gArg:Union(fn:FileName,fp:Asp9(G)),_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN)),outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename,outputFilename]$Lisp,_
	"d02cjf",_
	["xend"::S,"m"::S,"n"::S,"tol"::S,"relabs"::S_
	,"x"::S,"ifail"::S,"g"::S,"fcn"::S,"output"::S_
	,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"g"::S,"fcn"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,"tol"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,["w"::S,["+"::S,["*"::S,21$Lisp,"n"::S]$Lisp,28$Lisp]$Lisp]$Lisp,"g"::S_
	,"fcn"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"relabs"::S]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,tolArg::Any,relabsArg::Any,xArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02ejf(xendArg:DoubleFloat,mArg:Integer,nArg:Integer,_
	relabsArg:String,iwArg:Integer,xArg:DoubleFloat,_
	yArg:Matrix DoubleFloat,tolArg:DoubleFloat,ifailArg:Integer,_
	gArg:Union(fn:FileName,fp:Asp9(G)),fcnArg:Union(fn:FileName,fp:Asp7(FCN)),pedervArg:Union(fn:FileName,fp:Asp31(PEDERV)),_
	outputArg:Union(fn:FileName,fp:Asp8(OUTPUT))): Result == 
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(pedervFilename := aspFilename "pederv")$FOP
	if pedervArg case fn
		  then outputAsFortran(pedervArg.fn)
		  else outputAsFortran(pedervArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(outputFilename := aspFilename "output")$FOP
	if outputArg case fn
		  then outputAsFortran(outputArg.fn)
		  else outputAsFortran(outputArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([gFilename,fcnFilename,pedervFilename,outputFilename]$Lisp,_
	"d02ejf",_
	["xend"::S,"m"::S,"n"::S,"relabs"::S,"iw"::S_
	,"x"::S,"tol"::S,"ifail"::S,"g"::S,"fcn"::S_
	,"pederv"::S,"output"::S,"result"::S,"y"::S,"w"::S]$Lisp,_
	["result"::S,"w"::S,"g"::S,"fcn"::S,"pederv"::S,"output"::S]$Lisp,_
	[["double"::S,"xend"::S,["result"::S,"m"::S,"n"::S]$Lisp_
	,"x"::S,["y"::S,"n"::S]$Lisp,"tol"::S,["w"::S,"iw"::S]$Lisp,"g"::S,"fcn"::S,"pederv"::S,"output"::S]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"iw"::S,"ifail"::S_
	]$Lisp_
	,["character"::S,"relabs"::S]$Lisp_
	]$Lisp,_
	["result"::S,"x"::S,"y"::S,"tol"::S,"ifail"::S]$Lisp,_
	[([xendArg::Any,mArg::Any,nArg::Any,relabsArg::Any,iwArg::Any,xArg::Any,tolArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02gaf(uArg:Matrix DoubleFloat,vArg:Matrix DoubleFloat,nArg:Integer,_
	aArg:DoubleFloat,bArg:DoubleFloat,tolArg:DoubleFloat,_
	mnpArg:Integer,lwArg:Integer,liwArg:Integer,_
	xArg:Matrix DoubleFloat,npArg:Integer,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp7(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"d02gaf",_
	["n"::S,"a"::S,"b"::S,"tol"::S,"mnp"::S_
	,"lw"::S,"liw"::S,"np"::S,"ifail"::S,"fcn"::S_
	,"u"::S,"v"::S,"y"::S,"x"::S,"w"::S_
	,"iw"::S]$Lisp,_
	["y"::S,"w"::S,"iw"::S,"fcn"::S]$Lisp,_
	[["double"::S,["u"::S,"n"::S,2$Lisp]$Lisp,["v"::S,"n"::S,2$Lisp]$Lisp_
	,"a"::S,"b"::S,"tol"::S,["y"::S,"n"::S,"mnp"::S]$Lisp,["x"::S,"mnp"::S]$Lisp,["w"::S,"lw"::S]$Lisp_
	,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"lw"::S,"liw"::S_
	,"np"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["y"::S,"x"::S,"np"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,aArg::Any,bArg::Any,tolArg::Any,mnpArg::Any,lwArg::Any,liwArg::Any,npArg::Any,ifailArg::Any,uArg::Any,vArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02gbf(aArg:DoubleFloat,bArg:DoubleFloat,nArg:Integer,_
	tolArg:DoubleFloat,mnpArg:Integer,lwArg:Integer,_
	liwArg:Integer,cArg:Matrix DoubleFloat,dArg:Matrix DoubleFloat,_
	gamArg:Matrix DoubleFloat,xArg:Matrix DoubleFloat,npArg:Integer,_
	ifailArg:Integer,fcnfArg:Union(fn:FileName,fp:Asp77(FCNF)),fcngArg:Union(fn:FileName,fp:Asp78(FCNG))): Result == 
	pushFortranOutputStack(fcnfFilename := aspFilename "fcnf")$FOP
	if fcnfArg case fn
		  then outputAsFortran(fcnfArg.fn)
		  else outputAsFortran(fcnfArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(fcngFilename := aspFilename "fcng")$FOP
	if fcngArg case fn
		  then outputAsFortran(fcngArg.fn)
		  else outputAsFortran(fcngArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnfFilename,fcngFilename]$Lisp,_
	"d02gbf",_
	["a"::S,"b"::S,"n"::S,"tol"::S,"mnp"::S_
	,"lw"::S,"liw"::S,"np"::S,"ifail"::S,"fcnf"::S_
	,"fcng"::S,"y"::S,"c"::S,"d"::S,"gam"::S,"x"::S_
	,"w"::S,"iw"::S]$Lisp,_
	["y"::S,"w"::S,"iw"::S,"fcnf"::S,"fcng"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"tol"::S,["y"::S,"n"::S,"mnp"::S]$Lisp_
	,["c"::S,"n"::S,"n"::S]$Lisp,["d"::S,"n"::S,"n"::S]$Lisp,["gam"::S,"n"::S]$Lisp,["x"::S,"mnp"::S]$Lisp_
	,["w"::S,"lw"::S]$Lisp,"fcnf"::S,"fcng"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"lw"::S,"liw"::S_
	,"np"::S,"ifail"::S,["iw"::S,"liw"::S]$Lisp]$Lisp_
	]$Lisp,_
	["y"::S,"c"::S,"d"::S,"gam"::S,"x"::S,"np"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,nArg::Any,tolArg::Any,mnpArg::Any,lwArg::Any,liwArg::Any,npArg::Any,ifailArg::Any,cArg::Any,dArg::Any,gamArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02kef(xpointArg:Matrix DoubleFloat,mArg:Integer,kArg:Integer,_
	tolArg:DoubleFloat,maxfunArg:Integer,matchArg:Integer,_
	elamArg:DoubleFloat,delamArg:DoubleFloat,hmaxArg:Matrix DoubleFloat,_
	maxitArg:Integer,ifailArg:Integer,coeffnArg:Union(fn:FileName,fp:Asp10(COEFFN)),_
	bdyvalArg:Union(fn:FileName,fp:Asp80(BDYVAL))): Result == 
	pushFortranOutputStack(coeffnFilename := aspFilename "coeffn")$FOP
	if coeffnArg case fn
		  then outputAsFortran(coeffnArg.fn)
		  else outputAsFortran(coeffnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bdyvalFilename := aspFilename "bdyval")$FOP
	if bdyvalArg case fn
		  then outputAsFortran(bdyvalArg.fn)
		  else outputAsFortran(bdyvalArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran()$Asp12(MONIT)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(reportFilename := aspFilename "report")$FOP
	outputAsFortran()$Asp33(REPORT)
	popFortranOutputStack()$FOP
	[(invokeNagman([coeffnFilename,bdyvalFilename,monitFilename,reportFilename]$Lisp,_
	"d02kef",_
	["m"::S,"k"::S,"tol"::S,"maxfun"::S,"match"::S_
	,"elam"::S,"delam"::S,"maxit"::S,"ifail"::S,"coeffn"::S_
	,"bdyval"::S,"monit"::S,"report"::S,"xpoint"::S,"hmax"::S]$Lisp,_
	["coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp,_
	[["double"::S,["xpoint"::S,"m"::S]$Lisp,"tol"::S_
	,"elam"::S,"delam"::S,["hmax"::S,2$Lisp,"m"::S]$Lisp,"coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp_
	,["integer"::S,"m"::S,"k"::S,"maxfun"::S,"match"::S_
	,"maxit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["match"::S,"elam"::S,"delam"::S,"hmax"::S,"maxit"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kArg::Any,tolArg::Any,maxfunArg::Any,matchArg::Any,elamArg::Any,delamArg::Any,maxitArg::Any,ifailArg::Any,xpointArg::Any,hmaxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02kef(xpointArg:Matrix DoubleFloat,mArg:Integer,kArg:Integer,_
	tolArg:DoubleFloat,maxfunArg:Integer,matchArg:Integer,_
	elamArg:DoubleFloat,delamArg:DoubleFloat,hmaxArg:Matrix DoubleFloat,_
	maxitArg:Integer,ifailArg:Integer,coeffnArg:Union(fn:FileName,fp:Asp10(COEFFN)),_
	bdyvalArg:Union(fn:FileName,fp:Asp80(BDYVAL)),monitArg:FileName,reportArg:FileName): Result == 
	pushFortranOutputStack(coeffnFilename := aspFilename "coeffn")$FOP
	if coeffnArg case fn
		  then outputAsFortran(coeffnArg.fn)
		  else outputAsFortran(coeffnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bdyvalFilename := aspFilename "bdyval")$FOP
	if bdyvalArg case fn
		  then outputAsFortran(bdyvalArg.fn)
		  else outputAsFortran(bdyvalArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(monitFilename := aspFilename "monit")$FOP
	outputAsFortran(monitArg)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(reportFilename := aspFilename "report")$FOP
	outputAsFortran(reportArg)
	popFortranOutputStack()$FOP
	[(invokeNagman([coeffnFilename,bdyvalFilename,monitFilename,reportFilename]$Lisp,_
	"d02kef",_
	["m"::S,"k"::S,"tol"::S,"maxfun"::S,"match"::S_
	,"elam"::S,"delam"::S,"maxit"::S,"ifail"::S,"coeffn"::S_
	,"bdyval"::S,"monit"::S,"report"::S,"xpoint"::S,"hmax"::S]$Lisp,_
	["coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp,_
	[["double"::S,["xpoint"::S,"m"::S]$Lisp,"tol"::S_
	,"elam"::S,"delam"::S,["hmax"::S,2$Lisp,"m"::S]$Lisp,"coeffn"::S,"bdyval"::S,"monit"::S,"report"::S]$Lisp_
	,["integer"::S,"m"::S,"k"::S,"maxfun"::S,"match"::S_
	,"maxit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["match"::S,"elam"::S,"delam"::S,"hmax"::S,"maxit"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,kArg::Any,tolArg::Any,maxfunArg::Any,matchArg::Any,elamArg::Any,delamArg::Any,maxitArg::Any,ifailArg::Any,xpointArg::Any,hmaxArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d02raf(nArg:Integer,mnpArg:Integer,numbegArg:Integer,_
	nummixArg:Integer,tolArg:DoubleFloat,initArg:Integer,_
	iyArg:Integer,ijacArg:Integer,lworkArg:Integer,_
	liworkArg:Integer,npArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,delepsArg:DoubleFloat,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp41(FCN,JACOBF,JACEPS)),gArg:Union(fn:FileName,fp:Asp42(G,JACOBG,JACGEP))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(gFilename := aspFilename "g")$FOP
	if gArg case fn
		  then outputAsFortran(gArg.fn)
		  else outputAsFortran(gArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename,gFilename]$Lisp,_
	"d02raf",_
	["n"::S,"mnp"::S,"numbeg"::S,"nummix"::S,"tol"::S_
	,"init"::S,"iy"::S,"ijac"::S,"lwork"::S,"liwork"::S_
	,"np"::S,"deleps"::S,"ifail"::S,"fcn"::S,"g"::S_
	,"abt"::S,"x"::S,"y"::S,"work"::S,"iwork"::S_
	]$Lisp,_
	["abt"::S,"work"::S,"iwork"::S,"fcn"::S,"g"::S]$Lisp,_
	[["double"::S,"tol"::S,["abt"::S,"n"::S]$Lisp_
	,["x"::S,"mnp"::S]$Lisp,["y"::S,"iy"::S,"mnp"::S]$Lisp,"deleps"::S,["work"::S,"lwork"::S]$Lisp,"fcn"::S,"g"::S]$Lisp_
	,["integer"::S,"n"::S,"mnp"::S,"numbeg"::S_
	,"nummix"::S,"init"::S,"iy"::S,"ijac"::S,"lwork"::S,"liwork"::S,"np"::S,"ifail"::S,["iwork"::S,"liwork"::S]$Lisp]$Lisp_
	]$Lisp,_
	["abt"::S,"np"::S,"x"::S,"y"::S,"deleps"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,mnpArg::Any,numbegArg::Any,nummixArg::Any,tolArg::Any,initArg::Any,iyArg::Any,ijacArg::Any,lworkArg::Any,liworkArg::Any,npArg::Any,delepsArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD02.dotabb>>=
"NAGD02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD02"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD02" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGD03 NagPartialDifferentialEquationsPackage}
\pagehead{NagPartialDifferentialEquationsPackage}{NAGD03}
\pagepic{ps/v104nagpartialdifferentialequationspackage.ps}{NAGD03}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGD03 NagPartialDifferentialEquationsPackage>>=
)abbrev package NAGD03 NagPartialDifferentialEquationsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:51 1994
++ Description:
++ This package uses the NAG Library to solve partial
++ differential equations.
++ See \downlink{Manual Page}{manpageXXd03}.
NagPartialDifferentialEquationsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    d03edf : (Integer,Integer,Integer,Integer,_
	DoubleFloat,Integer,Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ d03edf(ngx,ngy,lda,maxit,acc,iout,a,rhs,ub,ifail)
     ++ solves seven-diagonal systems of linear equations which 
     ++ arise from the discretization of an elliptic partial differential
     ++ equation on a rectangular region. This routine uses a multigrid 
     ++ technique.
     ++ See \downlink{Manual Page}{manpageXXd03edf}.
    d03eef : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Integer,Integer,String,Integer,Union(fn:FileName,fp:Asp73(PDEF)),Union(fn:FileName,fp:Asp74(BNDY))) -> Result 
     ++ d03eef(xmin,xmax,ymin,ymax,ngx,ngy,lda,scheme,ifail,pdef,bndy)
     ++ discretizes a second order elliptic partial differential 
     ++ equation (PDE) on a rectangular region.
     ++ See \downlink{Manual Page}{manpageXXd03eef}.
    d03faf : (DoubleFloat,DoubleFloat,Integer,Integer,_
	Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,DoubleFloat,Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,DoubleFloat,Integer,Integer,Integer,ThreeDimensionalMatrix DoubleFloat,Integer) -> Result 
     ++ d03faf(xs,xf,l,lbdcnd,bdxs,bdxf,ys,yf,m,mbdcnd,bdys,bdyf,zs,zf,n,nbdcnd,bdzs,bdzf,lambda,ldimf,mdimf,lwrk,f,ifail)
     ++ solves the Helmholtz equation in Cartesian co-ordinates in
     ++ three dimensions using the standard seven-point finite difference
     ++ approximation. This routine is designed to be particularly 
     ++ efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXd03faf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(ThreeDimensionalMatrix DoubleFloat)
    import FortranPackage
    import Union(fn:FileName,fp:Asp73(PDEF))
    import Union(fn:FileName,fp:Asp74(BNDY))




    d03edf(ngxArg:Integer,ngyArg:Integer,ldaArg:Integer,_
	maxitArg:Integer,accArg:DoubleFloat,ioutArg:Integer,_
	aArg:Matrix DoubleFloat,rhsArg:Matrix DoubleFloat,ubArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d03edf",_
	["ngx"::S,"ngy"::S,"lda"::S,"maxit"::S,"acc"::S_
	,"iout"::S,"numit"::S,"ifail"::S,"us"::S,"u"::S,"a"::S,"rhs"::S,"ub"::S_
	]$Lisp,_
	["us"::S,"u"::S,"numit"::S]$Lisp,_
	[["double"::S,"acc"::S,["us"::S,"lda"::S]$Lisp_
	,["u"::S,"lda"::S]$Lisp,["a"::S,"lda"::S,7$Lisp]$Lisp,["rhs"::S,"lda"::S]$Lisp,["ub"::S,["*"::S,"ngx"::S,"ngy"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"ngx"::S,"ngy"::S,"lda"::S,"maxit"::S_
	,"iout"::S,"numit"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["us"::S,"u"::S,"numit"::S,"a"::S,"rhs"::S,"ub"::S,"ifail"::S]$Lisp,_
	[([ngxArg::Any,ngyArg::Any,ldaArg::Any,maxitArg::Any,accArg::Any,ioutArg::Any,ifailArg::Any,aArg::Any,rhsArg::Any,ubArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d03eef(xminArg:DoubleFloat,xmaxArg:DoubleFloat,yminArg:DoubleFloat,_
	ymaxArg:DoubleFloat,ngxArg:Integer,ngyArg:Integer,_
	ldaArg:Integer,schemeArg:String,ifailArg:Integer,_
	pdefArg:Union(fn:FileName,fp:Asp73(PDEF)),bndyArg:Union(fn:FileName,fp:Asp74(BNDY))): Result == 
	pushFortranOutputStack(pdefFilename := aspFilename "pdef")$FOP
	if pdefArg case fn
		  then outputAsFortran(pdefArg.fn)
		  else outputAsFortran(pdefArg.fp)
	popFortranOutputStack()$FOP
	pushFortranOutputStack(bndyFilename := aspFilename "bndy")$FOP
	if bndyArg case fn
		  then outputAsFortran(bndyArg.fn)
		  else outputAsFortran(bndyArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([pdefFilename,bndyFilename]$Lisp,_
	"d03eef",_
	["xmin"::S,"xmax"::S,"ymin"::S,"ymax"::S,"ngx"::S_
	,"ngy"::S,"lda"::S,"scheme"::S,"ifail"::S,"pdef"::S_
	,"bndy"::S,"a"::S,"rhs"::S]$Lisp,_
	["a"::S,"rhs"::S,"pdef"::S,"bndy"::S]$Lisp,_
	[["double"::S,"xmin"::S,"xmax"::S,"ymin"::S_
	,"ymax"::S,["a"::S,"lda"::S,7$Lisp]$Lisp,["rhs"::S,"lda"::S]$Lisp,"pdef"::S,"bndy"::S]$Lisp_
	,["integer"::S,"ngx"::S,"ngy"::S,"lda"::S,"ifail"::S_
	]$Lisp_
	,["character"::S,"scheme"::S]$Lisp_
	]$Lisp,_
	["a"::S,"rhs"::S,"ifail"::S]$Lisp,_
	[([xminArg::Any,xmaxArg::Any,yminArg::Any,ymaxArg::Any,ngxArg::Any,ngyArg::Any,ldaArg::Any,schemeArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    d03faf(xsArg:DoubleFloat,xfArg:DoubleFloat,lArg:Integer,_
	lbdcndArg:Integer,bdxsArg:Matrix DoubleFloat,bdxfArg:Matrix DoubleFloat,_
	ysArg:DoubleFloat,yfArg:DoubleFloat,mArg:Integer,_
	mbdcndArg:Integer,bdysArg:Matrix DoubleFloat,bdyfArg:Matrix DoubleFloat,_
	zsArg:DoubleFloat,zfArg:DoubleFloat,nArg:Integer,_
	nbdcndArg:Integer,bdzsArg:Matrix DoubleFloat,bdzfArg:Matrix DoubleFloat,_
	lambdaArg:DoubleFloat,ldimfArg:Integer,mdimfArg:Integer,_
	lwrkArg:Integer,fArg:ThreeDimensionalMatrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"d03faf",_
	["xs"::S,"xf"::S,"l"::S,"lbdcnd"::S,"ys"::S_
	,"yf"::S,"m"::S,"mbdcnd"::S,"zs"::S,"zf"::S_
	,"n"::S,"nbdcnd"::S,"lambda"::S,"ldimf"::S,"mdimf"::S_
	,"lwrk"::S,"pertrb"::S,"ifail"::S,"bdxs"::S,"bdxf"::S,"bdys"::S,"bdyf"::S,"bdzs"::S_
	,"bdzf"::S,"f"::S,"w"::S]$Lisp,_
	["pertrb"::S,"w"::S]$Lisp,_
	[["double"::S,"xs"::S,"xf"::S,["bdxs"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["bdxf"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,"ys"::S,"yf"::S,["bdys"::S,"ldimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["bdyf"::S,"ldimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,"zs"::S_
	,"zf"::S,["bdzs"::S,"ldimf"::S,["+"::S,"m"::S,1$Lisp]$Lisp]$Lisp,["bdzf"::S,"ldimf"::S,["+"::S,"m"::S,1$Lisp]$Lisp]$Lisp_
	,"lambda"::S,"pertrb"::S,["f"::S,"ldimf"::S,"mdimf"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp,["w"::S,"lwrk"::S]$Lisp]$Lisp_
	,["integer"::S,"l"::S,"lbdcnd"::S,"m"::S,"mbdcnd"::S_
	,"n"::S,"nbdcnd"::S,"ldimf"::S,"mdimf"::S,"lwrk"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["pertrb"::S,"f"::S,"ifail"::S]$Lisp,_
	[([xsArg::Any,xfArg::Any,lArg::Any,lbdcndArg::Any,ysArg::Any,yfArg::Any,mArg::Any,mbdcndArg::Any,zsArg::Any,zfArg::Any,nArg::Any,nbdcndArg::Any,lambdaArg::Any,ldimfArg::Any,mdimfArg::Any,lwrkArg::Any,ifailArg::Any,bdxsArg::Any,bdxfArg::Any,bdysArg::Any,bdyfArg::Any,bdzsArg::Any,bdzfArg::Any,fArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGD03.dotabb>>=
"NAGD03" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGD03"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NAGD03" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC02 NagPolynomialRootsPackage}
\pagehead{NagPolynomialRootsPackage}{NAGC02}
\pagepic{ps/v104nagpolynomialrootspackage.ps}{NAGC02}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC02 NagPolynomialRootsPackage>>=
)abbrev package NAGC02 NagPolynomialRootsPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:27 1994
++ Description:
++ This package uses the NAG Library to compute the zeros of a
++ polynomial with real or complex coefficients.
++ See \downlink{Manual Page}{manpageXXc02}.

NagPolynomialRootsPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c02aff : (Matrix DoubleFloat,Integer,Boolean,Integer) -> Result 
     ++ c02aff(a,n,scale,ifail)
     ++ finds all the roots of a complex polynomial equation, 
     ++ using a variant of Laguerre's Method.
     ++ See \downlink{Manual Page}{manpageXXc02aff}.
    c02agf : (Matrix DoubleFloat,Integer,Boolean,Integer) -> Result 
     ++ c02agf(a,n,scale,ifail)
     ++ finds all the roots of a real polynomial equation, using a
     ++ variant of Laguerre's Method.
     ++ See \downlink{Manual Page}{manpageXXc02agf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Matrix DoubleFloat
    import Any
    import Record
    import Integer
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Integer)
    import AnyFunctions1(Boolean)


    c02aff(aArg:Matrix DoubleFloat,nArg:Integer,scaleArg:Boolean,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c02aff",_
	["n"::S,"scale"::S,"ifail"::S,"a"::S,"z"::S,"w"::S]$Lisp,_
	["z"::S,"w"::S]$Lisp,_
	[["double"::S,["a"::S,2$Lisp,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["z"::S,2$Lisp,"n"::S]$Lisp,["w"::S,["*"::S,["+"::S,"n"::S,1$Lisp]$Lisp,4$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	,["logical"::S,"scale"::S]$Lisp_
	]$Lisp,_
	["z"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,scaleArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result



    c02agf(aArg:Matrix DoubleFloat,nArg:Integer,scaleArg:Boolean,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c02agf",_
	["n"::S,"scale"::S,"ifail"::S,"a"::S,"z"::S,"w"::S]$Lisp,_
	["z"::S,"w"::S]$Lisp,_
	[["double"::S,["a"::S,["+"::S,"n"::S,1$Lisp]$Lisp]$Lisp_
	,["z"::S,2$Lisp,"n"::S]$Lisp,["w"::S,["*"::S,["+"::S,"n"::S,1$Lisp]$Lisp,2$Lisp]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	,["logical"::S,"scale"::S]$Lisp_
	]$Lisp,_
	["z"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,scaleArg::Any,ifailArg::Any,aArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC02.dotabb>>=
"NAGC02" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC02"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC05 NagRootFindingPackage}
\pagehead{NagRootFindingPackage}{NAGC05}
\pagepic{ps/v104nagrootfindingpackage.ps}{NAGC05}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC05 NagRootFindingPackage>>=
)abbrev package NAGC05 NagRootFindingPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:28 1994
++ Description: 
++ This package uses the NAG Library to calculate real zeros of
++ continuous real functions of one or more variables. (Complex
++ equations must be expressed in terms of the equivalent larger
++ system of real equations.)
++ See \downlink{Manual Page}{manpageXXc05}.

NagRootFindingPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c05adf : (DoubleFloat,DoubleFloat,DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp1(F))) -> Result 
     ++ c05adf(a,b,eps,eta,ifail,f)
     ++ locates a zero of a continuous function in a given 
     ++ interval by a combination of the methods of linear interpolation,
     ++ extrapolation and bisection.
     ++ See \downlink{Manual Page}{manpageXXc05adf}.
    c05nbf : (Integer,Integer,Matrix DoubleFloat,DoubleFloat,_
	Integer,Union(fn:FileName,fp:Asp6(FCN))) -> Result 
     ++ c05nbf(n,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method.
     ++ See \downlink{Manual Page}{manpageXXc05nbf}.
    c05pbf : (Integer,Integer,Integer,Matrix DoubleFloat,_
	DoubleFloat,Integer,Union(fn:FileName,fp:Asp35(FCN))) -> Result 
     ++ c05pbf(n,ldfjac,lwa,x,xtol,ifail,fcn)
     ++ is an easy-to-use routine to find a solution of a system 
     ++ of nonlinear equations by a modification of the Powell hybrid 
     ++ method. The user must provide the Jacobian.
     ++ See \downlink{Manual Page}{manpageXXc05pbf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import FortranPackage
    import Union(fn:FileName,fp:Asp1(F))
    import AnyFunctions1(DoubleFloat)
    import AnyFunctions1(Matrix DoubleFloat)
    import AnyFunctions1(Integer)


    c05adf(aArg:DoubleFloat,bArg:DoubleFloat,epsArg:DoubleFloat,_
	etaArg:DoubleFloat,ifailArg:Integer,fArg:Union(fn:FileName,fp:Asp1(F))): Result == 
	pushFortranOutputStack(fFilename := aspFilename "f")$FOP
	if fArg case fn
		  then outputAsFortran(fArg.fn)
		  else outputAsFortran(fArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fFilename]$Lisp,_
	"c05adf",_
	["a"::S,"b"::S,"eps"::S,"eta"::S,"x"::S_
	,"ifail"::S,"f"::S]$Lisp,_
	["x"::S,"f"::S]$Lisp,_
	[["double"::S,"a"::S,"b"::S,"eps"::S,"eta"::S_
	,"x"::S,"f"::S]$Lisp_
	,["integer"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([aArg::Any,bArg::Any,epsArg::Any,etaArg::Any,ifailArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05nbf(nArg:Integer,lwaArg:Integer,xArg:Matrix DoubleFloat,_
	xtolArg:DoubleFloat,ifailArg:Integer,fcnArg:Union(fn:FileName,fp:Asp6(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05nbf",_
	["n"::S,"lwa"::S,"xtol"::S,"ifail"::S,"fcn"::S_
	,"fvec"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["x"::S,"n"::S]$Lisp_
	,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"lwa"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c05pbf(nArg:Integer,ldfjacArg:Integer,lwaArg:Integer,_
	xArg:Matrix DoubleFloat,xtolArg:DoubleFloat,ifailArg:Integer,_
	fcnArg:Union(fn:FileName,fp:Asp35(FCN))): Result == 
	pushFortranOutputStack(fcnFilename := aspFilename "fcn")$FOP
	if fcnArg case fn
		  then outputAsFortran(fcnArg.fn)
		  else outputAsFortran(fcnArg.fp)
	popFortranOutputStack()$FOP
	[(invokeNagman([fcnFilename]$Lisp,_
	"c05pbf",_
	["n"::S,"ldfjac"::S,"lwa"::S,"xtol"::S,"ifail"::S_
	,"fcn"::S,"fvec"::S,"fjac"::S,"x"::S,"wa"::S]$Lisp,_
	["fvec"::S,"fjac"::S,"wa"::S,"fcn"::S]$Lisp,_
	[["double"::S,["fvec"::S,"n"::S]$Lisp,["fjac"::S,"ldfjac"::S,"n"::S]$Lisp_
	,["x"::S,"n"::S]$Lisp,"xtol"::S,["wa"::S,"lwa"::S]$Lisp,"fcn"::S]$Lisp_
	,["integer"::S,"n"::S,"ldfjac"::S,"lwa"::S_
	,"ifail"::S]$Lisp_
	]$Lisp,_
	["fvec"::S,"fjac"::S,"x"::S,"xtol"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ldfjacArg::Any,lwaArg::Any,xtolArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC05.dotabb>>=
"NAGC05" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC05"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NAGC06 NagSeriesSummationPackage}
\pagehead{NagSeriesSummationPackage}{NAGC06}
\pagepic{ps/v104nagseriessummationpackage.ps}{NAGC06}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NAGC06 NagSeriesSummationPackage>>=
)abbrev package NAGC06 NagSeriesSummationPackage
++ Author: Godfrey Nolan and Mike Dewar
++ Date Created: Jan 1994
++ Date Last Updated: Thu May 12 17:44:30 1994
++ Description:
++ This package uses the NAG Library to calculate the discrete Fourier
++ transform of a sequence of real or complex data values, and
++ applies it to calculate convolutions and correlations.
++ See \downlink{Manual Page}{manpageXXc06}.

NagSeriesSummationPackage(): Exports == Implementation where
  S ==> Symbol
  FOP ==> FortranOutputStackPackage

  Exports ==> with
    c06eaf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06eaf(n,x,ifail)
     ++ calculates the discrete Fourier transform of a sequence of
     ++ n real data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06eaf}.
    c06ebf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06ebf(n,x,ifail)
     ++ calculates the discrete Fourier transform of a Hermitian 
     ++ sequence of n complex data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06ebf}.
    c06ecf : (Integer,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06ecf(n,x,y,ifail)
     ++ calculates the discrete Fourier transform of a sequence of
     ++ n complex data values. (No extra workspace required.)
     ++ See \downlink{Manual Page}{manpageXXc06ecf}.
    c06ekf : (Integer,Integer,Matrix DoubleFloat,Matrix DoubleFloat,_
	Integer) -> Result 
     ++ c06ekf(job,n,x,y,ifail)
     ++ calculates the circular convolution of two 
     ++ real vectors of period n. No extra workspace is required.
     ++ See \downlink{Manual Page}{manpageXXc06ekf}.
    c06fpf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ c06fpf(m,n,init,x,trig,ifail)
     ++ computes the discrete Fourier transforms of m sequences, 
     ++ each containing n real data values. This routine is designed to 
     ++ be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fpf}.
    c06fqf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Integer) -> Result 
     ++ c06fqf(m,n,init,x,trig,ifail)
     ++ computes the discrete Fourier transforms of m Hermitian 
     ++ sequences, each containing n complex data values. This routine is
     ++ designed to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fqf}.
    c06frf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06frf(m,n,init,x,y,trig,ifail)
     ++ computes the discrete Fourier transforms of m sequences, 
     ++ each containing n complex data values. This routine is designed 
     ++ to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06frf}.
    c06fuf : (Integer,Integer,String,Matrix DoubleFloat,_
	Matrix DoubleFloat,Matrix DoubleFloat,Matrix DoubleFloat,Integer) -> Result 
     ++ c06fuf(m,n,init,x,y,trigm,trign,ifail)
     ++ computes the two-dimensional discrete Fourier transform of
     ++ a bivariate sequence of complex data values. This routine is 
     ++ designed to be particularly efficient on vector processors.
     ++ See \downlink{Manual Page}{manpageXXc06fuf}.
    c06gbf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gbf(n,x,ifail)
     ++ forms the complex conjugate of n 
     ++ data values.
     ++ See \downlink{Manual Page}{manpageXXc06gbf}.
    c06gcf : (Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gcf(n,y,ifail)
     ++ forms the complex conjugate of a sequence of n data 
     ++ values.
     ++ See \downlink{Manual Page}{manpageXXc06gcf}.
    c06gqf : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gqf(m,n,x,ifail)
     ++ forms the complex conjugates, 
     ++ each containing n data values.
     ++ See \downlink{Manual Page}{manpageXXc06gqf}.
    c06gsf : (Integer,Integer,Matrix DoubleFloat,Integer) -> Result 
     ++ c06gsf(m,n,x,ifail)
     ++ takes m Hermitian sequences, each containing n data 
     ++ values, and forms the real and imaginary parts of the m 
     ++ corresponding complex sequences.
     ++ See \downlink{Manual Page}{manpageXXc06gsf}.
  Implementation ==> add

    import Lisp
    import DoubleFloat
    import Any
    import Record
    import Integer
    import Matrix DoubleFloat
    import Boolean
    import NAGLinkSupportPackage
    import AnyFunctions1(Integer)
    import AnyFunctions1(String)
    import AnyFunctions1(Matrix DoubleFloat)


    c06eaf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06eaf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result


    c06ebf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ebf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06ecf(nArg:Integer,xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ecf",_
	["n"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06ekf(jobArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	yArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06ekf",_
	["job"::S,"n"::S,"ifail"::S,"x"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp,["y"::S,"n"::S]$Lisp_
	]$Lisp_
	,["integer"::S,"job"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"ifail"::S]$Lisp,_
	[([jobArg::Any,nArg::Any,ifailArg::Any,xArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fpf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fpf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fqf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fqf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06frf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,trigArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06frf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"y"::S,"trig"::S,"work"::S]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["y"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["trig"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp,["work"::S,["*"::S,["*"::S,2$Lisp,"m"::S]$Lisp,"n"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"trig"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,yArg::Any,trigArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06fuf(mArg:Integer,nArg:Integer,initArg:String,_
	xArg:Matrix DoubleFloat,yArg:Matrix DoubleFloat,trigmArg:Matrix DoubleFloat,_
	trignArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06fuf",_
	["m"::S,"n"::S,"init"::S,"ifail"::S,"x"::S,"y"::S,"trigm"::S,"trign"::S,"work"::S_
	]$Lisp,_
	["work"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["y"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["trigm"::S,["*"::S,2$Lisp,"m"::S]$Lisp]$Lisp,["trign"::S,["*"::S,2$Lisp,"n"::S]$Lisp]$Lisp_
	,["work"::S,["*"::S,["*"::S,2$Lisp,"m"::S]$Lisp,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	,["character"::S,"init"::S]$Lisp_
	]$Lisp,_
	["x"::S,"y"::S,"trigm"::S,"trign"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,initArg::Any,ifailArg::Any,xArg::Any,yArg::Any,trigmArg::Any,trignArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gbf(nArg:Integer,xArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gbf",_
	["n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gcf(nArg:Integer,yArg:Matrix DoubleFloat,ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gcf",_
	["n"::S,"ifail"::S,"y"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["y"::S,"n"::S]$Lisp]$Lisp_
	,["integer"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["y"::S,"ifail"::S]$Lisp,_
	[([nArg::Any,ifailArg::Any,yArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gqf(mArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gqf",_
	["m"::S,"n"::S,"ifail"::S,"x"::S]$Lisp,_
	[]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["x"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

    c06gsf(mArg:Integer,nArg:Integer,xArg:Matrix DoubleFloat,_
	ifailArg:Integer): Result == 
	[(invokeNagman(NIL$Lisp,_
	"c06gsf",_
	["m"::S,"n"::S,"ifail"::S,"x"::S,"u"::S,"v"::S]$Lisp,_
	["u"::S,"v"::S]$Lisp,_
	[["double"::S,["x"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp_
	,["u"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp,["v"::S,["*"::S,"m"::S,"n"::S]$Lisp]$Lisp]$Lisp_
	,["integer"::S,"m"::S,"n"::S,"ifail"::S]$Lisp_
	]$Lisp,_
	["u"::S,"v"::S,"ifail"::S]$Lisp,_
	[([mArg::Any,nArg::Any,ifailArg::Any,xArg::Any ])_
	@List Any]$Lisp)$Lisp)_
	pretend List (Record(key:Symbol,entry:Any))]$Result

@
<<NAGC06.dotabb>>=
"NAGC06" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NAGC06"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NSUP2 NewSparseUnivariatePolynomialFunctions2}
\pagehead{NewSparseUnivariatePolynomialFunctions2}{NSUP2}
\pagepic{ps/v104newsparseunivariatepolynomialfunctions2.ps}{NSUP2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NSUP2 NewSparseUnivariatePolynomialFunctions2>>=
)abbrev package NSUP2 NewSparseUnivariatePolynomialFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package lifts a mapping from coefficient rings R to S to
++ a mapping from sparse univariate polynomial over R to
++ a sparse univariate polynomial over S.
++ Note that the mapping is assumed
++ to send zero to zero, since it will only be applied to the non-zero
++ coefficients of the polynomial.

NewSparseUnivariatePolynomialFunctions2(R:Ring, S:Ring): with
  map:(R->S,NewSparseUnivariatePolynomial R) -> NewSparseUnivariatePolynomial S
    ++ \axiom{map(func, poly)} creates a new polynomial by applying func to
    ++ every non-zero coefficient of the polynomial poly.
 == add
  map(f, p) == map(f, p)$UnivariatePolynomialCategoryFunctions2(R,
           NewSparseUnivariatePolynomial R, S, NewSparseUnivariatePolynomial S)

@
<<NSUP2.dotabb>>=
"NSUP2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NSUP2"]
"LMODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=LMODULE"]
"SGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=SGROUP"]
"NSUP2" -> "LMODULE"
"NSUP2" -> "SGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NEWTON NewtonInterpolation}
\pagehead{NewtonInterpolation}{NEWTON}
\pagepic{ps/v104newtoninterpolation.ps}{NEWTON}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NEWTON NewtonInterpolation>>=
)abbrev package NEWTON NewtonInterpolation
++ Description:
++ This package exports Newton interpolation for the special case where the
++ result is known to be in the original integral domain
++ The packages defined in this file provide fast fraction free rational
++ interpolation algorithms. (see FAMR2, FFFG, FFFGF, NEWTON)
NewtonInterpolation F: Exports == Implementation where
    F: IntegralDomain
    Exports == with

      newton: List F -> SparseUnivariatePolynomial F

      ++ \spad{newton}(l) returns the interpolating polynomial for the values
      ++ l, where the x-coordinates are assumed to be [1,2,3,...,n] and the
      ++ coefficients of the interpolating polynomial are known to be in the
      ++ domain F. I.e., it is a very streamlined version for a special case of
      ++ interpolation. 

    Implementation == add

      differences(yl: List F): List F == 
        [y2-y1 for y1 in yl for y2 in rest yl]

      z: SparseUnivariatePolynomial(F) := monomial(1,1)

-- we assume x=[1,2,3,...,n]
      newtonAux(k: F, fact: F, yl: List F): SparseUnivariatePolynomial(F) ==
        if empty? rest yl 
        then ((yl.1) exquo fact)::F::SparseUnivariatePolynomial(F)
        else ((yl.1) exquo fact)::F::SparseUnivariatePolynomial(F) 
             + (z-k::SparseUnivariatePolynomial(F)) _
               * newtonAux(k+1$F, fact*k, differences yl)


      newton yl == newtonAux(1$F, 1$F, yl)

@
<<NEWTON.dotabb>>=
"NEWTON" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NEWTON"]
"ALGEBRA" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ALGEBRA"]
"NEWTON" -> "ALGEBRA"

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NCODIV NonCommutativeOperatorDivision}
\pagehead{NonCommutativeOperatorDivision}{NCODIV}
\pagepic{ps/v104noncommutativeoperatordivision.ps}{NCODIV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NCODIV NonCommutativeOperatorDivision>>=
)abbrev package NCODIV NonCommutativeOperatorDivision
++ Author: Jean Della Dora, Stephen M. Watt
++ Date Created: 1986
++ Date Last Updated: May 30, 1991
++ Basic Operations:
++ Related Domains: LinearOrdinaryDifferentialOperator
++ Also See:
++ AMS Classifications:
++ Keywords: gcd, lcm, division, non-commutative
++ Examples:
++ References:
++ Description:
++   This package provides a division and related operations for
++   \spadtype{MonogenicLinearOperator}s over a \spadtype{Field}.
++   Since the multiplication is in general non-commutative,
++   these operations all have left- and right-hand versions.
++   This package provides the operations based on left-division.
            -- [q,r] = leftDivide(a,b) means a=b*q+r

NonCommutativeOperatorDivision(P, F): PDcat == PDdef  where
    P: MonogenicLinearOperator(F)
    F: Field

    PDcat == with
        leftDivide:   (P, P) -> Record(quotient: P, remainder: P)
            ++ leftDivide(a,b) returns the pair \spad{[q,r]} such that
            ++ \spad{a = b*q + r} and the degree of \spad{r} is
            ++ less than the degree of \spad{b}.
            ++ This process is called ``left division''.
        leftQuotient:  (P, P) -> P
            ++ leftQuotient(a,b) computes the pair \spad{[q,r]} such that
            ++ \spad{a = b*q + r} and the degree of \spad{r} is
            ++ less than the degree of \spad{b}.
            ++ The value \spad{q} is returned.
        leftRemainder:  (P, P) -> P
            ++ leftRemainder(a,b) computes the pair \spad{[q,r]} such that
            ++ \spad{a = b*q + r} and the degree of \spad{r} is
            ++ less than the degree of \spad{b}.
            ++ The value \spad{r} is returned.
        leftExactQuotient:(P, P) -> Union(P, "failed")
            ++ leftExactQuotient(a,b) computes the value \spad{q}, if it exists,
            ++  such that \spad{a = b*q}.

        leftGcd:   (P, P) -> P
            ++ leftGcd(a,b) computes the value \spad{g} of highest degree
            ++ such that
            ++    \spad{a = aa*g}
            ++    \spad{b = bb*g}
            ++ for some values \spad{aa} and \spad{bb}.
            ++ The value \spad{g} is computed using left-division.
        leftLcm:   (P, P) -> P
            ++ leftLcm(a,b) computes the value \spad{m} of lowest degree
            ++ such that \spad{m = a*aa = b*bb} for some values
            ++ \spad{aa} and \spad{bb}.  The value \spad{m} is
            ++ computed using left-division.

    PDdef == add
        leftDivide(a, b) ==
            q: P := 0
            r: P := a
            iv:F := inv leadingCoefficient b
            while degree r >= degree b and r ^= 0 repeat
                h := monomial(iv*leadingCoefficient r,
              	                 (degree r - degree b)::NonNegativeInteger)$P
                r := r - b*h
                q := q + h
            [q,r]

        -- leftQuotient(a,b) is the quotient from left division, etc.
        leftQuotient(a,b)   == leftDivide(a,b).quotient
        leftRemainder(a,b)   == leftDivide(a,b).remainder
        leftExactQuotient(a,b) ==
             qr := leftDivide(a,b)
             if qr.remainder = 0 then qr.quotient else "failed"
        -- l = leftGcd(a,b) means  a = aa*l  b = bb*l.  Uses leftDivide.
        leftGcd(a,b) ==
             a = 0 =>b
             b = 0 =>a
             while degree b > 0 repeat (a,b) := (b, leftRemainder(a,b))
             if b=0 then a else b
        -- l = leftLcm(a,b) means  l = a*aa  l = b*bb   Uses leftDivide.
        leftLcm(a,b) ==
            a = 0 =>b
            b = 0 =>a
            b0 := b
            u  := monomial(1,0)$P
            v  := 0
            while leadingCoefficient b ^= 0 repeat
                qr     := leftDivide(a,b)
                (a, b) := (b, qr.remainder)
                (u, v) := (u*qr.quotient+v, u)
            b0*u

@
<<NCODIV.dotabb>>=
"NCODIV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NCODIV"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"NCODIV" -> "FIELD"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NONE1 NoneFunctions1}
\pagehead{NoneFunctions1}{NONE1}
\pagepic{ps/v104nonefunctions1.ps}{NONE1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NONE1 NoneFunctions1>>=
)abbrev package NONE1 NoneFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions: coerce
++ Related Constructors: None
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{NoneFunctions1} implements functions on \spadtype{None}.
++   It particular it includes a particulary dangerous coercion from
++   any other type to \spadtype{None}.

NoneFunctions1(S:Type): Exports == Implementation where
  Exports ==> with
    coerce: S -> None
      ++ coerce(x) changes \spad{x} into an object of type
      ++ \spadtype{None}.

  Implementation ==> add
    coerce(s:S):None == s pretend None

@
<<NONE1.dotabb>>=
"NONE1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NONE1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"NONE1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NODE1 NonLinearFirstOrderODESolver}
\pagehead{NonLinearFirstOrderODESolver}{NODE1}
\pagepic{ps/v104nonlinearfirstorderodesolver.ps}{NODE1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NODE1 NonLinearFirstOrderODESolver>>=
)abbrev package NODE1 NonLinearFirstOrderODESolver
++ Author: Manuel Bronstein
++ Date Created: 2 September 1991
++ Date Last Updated: 14 October 1994
++ Description: NonLinearFirstOrderODESolver provides a function
++ for finding closed form first integrals of nonlinear ordinary
++ differential equations of order 1.
++ Keywords: differential equation, ODE
NonLinearFirstOrderODESolver(R, F): Exports == Implementation where
  R: Join(OrderedSet, EuclideanDomain, RetractableTo Integer,
          LinearlyExplicitRingOver Integer, CharacteristicZero)
  F: Join(AlgebraicallyClosedFunctionSpace R, TranscendentalFunctionCategory,
          PrimitiveFunctionCategory)

  N   ==> NonNegativeInteger
  Q   ==> Fraction Integer
  UQ  ==> Union(Q, "failed")
  OP  ==> BasicOperator
  SY  ==> Symbol
  K   ==> Kernel F
  U   ==> Union(F, "failed")
  P   ==> SparseMultivariatePolynomial(R, K)
  REC ==> Record(coef:Q, logand:F)
  SOL ==> Record(particular: F,basis: List F)
  BER ==> Record(coef1:F, coefn:F, exponent:N)

  Exports ==> with
    solve: (F, F, OP, SY) -> U
      ++ solve(M(x,y), N(x,y), y, x) returns \spad{F(x,y)} such that
      ++ \spad{F(x,y) = c} for a constant \spad{c} is a first integral
      ++ of the equation \spad{M(x,y) dx + N(x,y) dy  = 0}, or
      ++ "failed" if no first-integral can be found.

  Implementation ==> add
    import ODEIntegration(R, F)
    import ElementaryFunctionODESolver(R, F)    -- recursive dependency!

    checkBernoulli   : (F, F, K) -> Union(BER, "failed")
    solveBernoulli   : (BER, OP, SY, F) -> Union(F, "failed")
    checkRiccati     : (F, F, K) -> Union(List F, "failed")
    solveRiccati     : (List F, OP, SY, F) -> Union(F, "failed")
    partSolRiccati   : (List F, OP, SY, F) -> Union(F, "failed")
    integratingFactor: (F, F, SY, SY) -> U

    unk    := new()$SY
    kunk:K := kernel unk

    solve(m, n, y, x) ==
-- first replace the operator y(x) by a new symbol z in m(x,y) and n(x,y)
      lk:List(K) := [retract(yx := y(x::F))@K]
      lv:List(F) := [kunk::F]
      mm := eval(m, lk, lv)
      nn := eval(n, lk, lv)
-- put over a common denominator (to balance m and n)
      d := lcm(denom mm, denom nn)::F
      mm := d * mm
      nn := d * nn
-- look for an integrating factor mu
      (u := integratingFactor(mm, nn, unk, x)) case F =>
        mu := u::F
        mm := mm * mu
        nn := nn * mu
        eval(int(mm,x) + int(nn-int(differentiate(mm,unk),x), unk),[kunk],[yx])
-- check for Bernoulli equation
      (w := checkBernoulli(m, n, k1 := first lk)) case BER =>
        solveBernoulli(w::BER, y, x, yx)
-- check for Riccati equation
      (v := checkRiccati(m, n, k1)) case List(F) =>
        solveRiccati(v::List(F), y, x, yx)
      "failed"

-- look for an integrating factor
    integratingFactor(m, n, y, x) ==
-- check first for exactness
      zero?(d := differentiate(m, y) - differentiate(n, x)) => 1
-- look for an integrating factor involving x only
      not member?(y, variables(f := d / n)) => expint(f, x)
-- look for an integrating factor involving y only
      not member?(x, variables(f := - d / m)) => expint(f, y)
-- room for more techniques later on (e.g. Prelle-Singer etc...)
      "failed"

-- check whether the equation is of the form
--    dy/dx + p(x)y + q(x)y^N = 0   with N > 1
-- i.e. whether m/n is of the form  p(x) y + q(x) y^N
-- returns [p, q, N] if the equation is in that form
    checkBernoulli(m, n, ky) ==
      r := denom(f := m / n)::F
      (not freeOf?(r, y := ky::F))
          or (d := degree(p := univariate(numer f, ky))) < 2
            or degree(pp := reductum p) ^= 1 or reductum(pp) ^= 0
              or (not freeOf?(a := (leadingCoefficient(pp)::F), y))
                or (not freeOf?(b := (leadingCoefficient(p)::F), y)) => "failed"
      [a / r, b / r, d]

-- solves the equation dy/dx + rec.coef1 y + rec.coefn y^rec.exponent = 0
-- the change of variable v = y^{1-n} transforms the above equation to
--  dv/dx + (1 - n) p v + (1 - n) q = 0
    solveBernoulli(rec, y, x, yx) ==
      n1 := 1 - rec.exponent::Integer
      deq := differentiate(yx, x) + n1 * rec.coef1 * yx + n1 * rec.coefn
      sol := solve(deq, y, x)::SOL          -- can always solve for order 1
-- if v = vp + c v0 is the general solution of the linear equation, then
-- the general first integral for the Bernoulli equation is
-- (y^{1-n} - vp) / v0  =   c   for any constant c
      (yx**n1 - sol.particular) / first(sol.basis)

-- check whether the equation is of the form
--    dy/dx + q0(x) + q1(x)y + q2(x)y^2 = 0
-- i.e. whether m/n is a quadratic polynomial in y.
-- returns the list [q0, q1, q2] if the equation is in that form
    checkRiccati(m, n, ky) ==
      q := denom(f := m / n)::F
      (not freeOf?(q, y := ky::F)) or degree(p := univariate(numer f, ky)) > 2
         or (not freeOf?(a0 := (coefficient(p, 0)::F), y))
           or (not freeOf?(a1 := (coefficient(p, 1)::F), y))
             or (not freeOf?(a2 := (coefficient(p, 2)::F), y)) => "failed"
      [a0 / q, a1 / q, a2 / q]

-- solves the equation dy/dx + l.1 + l.2 y + l.3 y^2 = 0
    solveRiccati(l, y, x, yx) ==
-- get first a particular solution
      (u := partSolRiccati(l, y, x, yx)) case "failed" => "failed"
-- once a particular solution yp is known, the general solution is of the
-- form  y = yp + 1/v  where v satisfies the linear 1st order equation
-- v' - (l.2 + 2 l.3 yp) v = l.3
      deq := differentiate(yx, x) - (l.2 + 2 * l.3 * u::F) * yx - l.3
      gsol := solve(deq, y, x)::SOL         -- can always solve for order 1
-- if v = vp + c v0 is the general solution of the above equation, then
-- the general first integral for the Riccati equation is
--  (1/(y - yp) - vp) / v0  =   c   for any constant c
      (inv(yx - u::F) - gsol.particular) / first(gsol.basis)

-- looks for a particular solution of dy/dx + l.1 + l.2 y + l.3 y^2 = 0
    partSolRiccati(l, y, x, yx) ==
-- we first do the change of variable y = z / l.3, which transforms
-- the equation into  dz/dx + l.1 l.3 + (l.2 - l.3'/l.3) z + z^2 = 0
      q0 := l.1 * (l3 := l.3)
      q1 := l.2 - differentiate(l3, x) / l3
-- the equation dz/dx + q0 + q1 z + z^2 = 0 is transformed by the change
-- of variable z = w'/w into the linear equation w'' + q1 w' + q0 w = 0
      lineq := differentiate(yx, x, 2) + q1 * differentiate(yx, x) + q0 * yx
-- should be made faster by requesting a particular nonzero solution only
      (not((gsol := solve(lineq, y, x)) case SOL))
                              or empty?(bas := (gsol::SOL).basis) => "failed"
      differentiate(first bas, x) / (l3 * first bas)

@
<<NODE1.dotabb>>=
"NODE1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NODE1"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"NODE1" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NLINSOL NonLinearSolvePackage}
\pagehead{NonLinearSolvePackage}{NLINSOL}
\pagepic{ps/v104nonlinearsolvepackage.ps}{NLINSOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NLINSOL NonLinearSolvePackage>>=
)abbrev package NLINSOL NonLinearSolvePackage
++ Author: Manuel Bronstein
++ Date Created: 31 October 1991
++ Date Last Updated: 26 June 1992
++ Description:
++ NonLinearSolvePackage is an interface to \spadtype{SystemSolvePackage}
++ that attempts to retract the coefficients of the equations before
++ solving. The solutions are given in the algebraic closure of R whenever
++ possible.

NonLinearSolvePackage(R:IntegralDomain): Exports == Implementation where
  Z   ==> Integer
  Q   ==> Fraction Z
  SY  ==> Symbol
  P   ==> Polynomial R
  F   ==> Fraction P
  EQ  ==> Equation F
  SSP ==> SystemSolvePackage
  SOL ==> RetractSolvePackage

  Exports ==> with
    solveInField:    (List P, List SY) -> List List EQ
      ++ solveInField(lp,lv) finds the solutions of the list lp of
      ++ rational functions with respect to the list of symbols lv.
    solveInField:     List P       -> List List EQ
      ++ solveInField(lp) finds the solution of the list lp of rational
      ++ functions with respect to all the symbols appearing in lp.
    solve:           (List P, List SY) -> List List EQ
      ++ solve(lp,lv) finds the solutions in the algebraic closure of R
      ++ of the list lp of
      ++ rational functions with respect to the list of symbols lv.
    solve:            List P       -> List List EQ
      ++ solve(lp) finds the solution in the algebraic closure of R
      ++ of the list lp of rational
      ++ functions with respect to all the symbols appearing in lp.

  Implementation ==> add
    solveInField l == solveInField(l, "setUnion"/[variables p for p in l])

    if R has AlgebraicallyClosedField then
      import RationalFunction(R)

      expandSol: List EQ -> List List EQ
      RIfCan   : F -> Union(R, "failed")
      addRoot  : (EQ, List List EQ) -> List List EQ
      allRoots : List P -> List List EQ
      evalSol  : (List EQ, List EQ) -> List EQ

      solve l        == solve(l, "setUnion"/[variables p for p in l])
      solve(lp, lv)  == concat([expandSol sol for sol in solveInField(lp, lv)])
      addRoot(eq, l) == [concat(eq, sol) for sol in l]
      evalSol(ls, l) == [equation(lhs eq, eval(rhs eq, l)) for eq in ls]

-- converts [p1(a1),...,pn(an)] to
-- [[a1=v1,...,an=vn]] where vi ranges over all the zeros of pi
      allRoots l ==
        empty? l => [empty()$List(EQ)]
        z := allRoots rest l
        s := mainVariable(p := first l)::SY::P::F
        concat [addRoot(equation(s, a::P::F), z) for a in zerosOf univariate p]

      expandSol l ==
        lassign := lsubs := empty()$List(EQ)
        luniv := empty()$List(P)
        for eq in l repeat
          if retractIfCan(lhs eq)@Union(SY, "failed") case SY then
            if RIfCan(rhs eq) case R then lassign := concat(eq, lassign)
                                     else lsubs := concat(eq, lsubs)
          else
            if ((u := retractIfCan(lhs eq)@Union(P, "failed")) case P) and
--               one?(# variables(u::P)) and ((r := RIfCan rhs eq) case R) then
               ((# variables(u::P)) = 1) and ((r := RIfCan rhs eq) case R) then
                 luniv := concat(u::P - r::R::P, luniv)
            else return [l]
        empty? luniv => [l]
        [concat(z, concat(evalSol(lsubs,z), lassign)) for z in allRoots luniv]

      RIfCan f ==
        ((n := retractIfCan(numer f)@Union(R,"failed")) case R) and
          ((d := retractIfCan(denom f)@Union(R,"failed")) case R) => n::R / d::R
        "failed"
    else
      solve l       == solveInField l
      solve(lp, lv) == solveInField(lp, lv)

 -- 'else if' is doubtful with this compiler so all 3 conditions are explicit
    if (not(R is Q)) and (R has RetractableTo Q) then
      solveInField(lp, lv) == solveRetract(lp, lv)$SOL(Q, R)

    if (not(R is Z)) and (not(R has RetractableTo Q)) and
      (R has RetractableTo Z) then
        solveInField(lp, lv) == solveRetract(lp, lv)$SOL(Z, R)

    if (not(R is Z)) and (not(R has RetractableTo Q)) and
      (not(R has RetractableTo Z)) then
        solveInField(lp, lv) == solve([p::F for p in lp]$List(F), lv)$SSP(R)

@
<<NLINSOL.dotabb>>=
"NLINSOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NLINSOL"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"NLINSOL" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NORMPK NormalizationPackage}
\pagehead{NormalizationPackage}{NORMPK}
\pagepic{ps/v104normalizationpackage.ps}{NORMPK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NORMPK NormalizationPackage>>=
)abbrev package NORMPK NormalizationPackage
++ Author: Marc Moreno Maza
++ Date Created: 09/23/1998
++ Date Last Updated: 12/16/1998
++ Basic Functions:
++ Related Constructors:
++ Also See: 
++ AMS Classifications:
++ Keywords:
++ Description: 
++ A package for computing normalized assocites of univariate polynomials
++ with coefficients in a tower of simple extensions of a field.\newline
++ References :
++  [1] D. LAZARD "A new method for solving algebraic systems of 
++      positive dimension" Discr. App. Math. 33:147-160,1991
++  [2] M. MORENO MAZA and R. RIOBOO "Computations of gcd over
++      algebraic towers of simple extensions" In proceedings of AAECC11
++      Paris, 1995.
++  [3] M. MORENO MAZA "Calculs de pgcd au-dessus des tours
++      d'extensions simples et resolution des systemes d'equations
++      algebriques" These, Universite P.etM. Curie, Paris, 1997.
++ Version: 1. 

NormalizationPackage(R,E,V,P,TS): Exports == Implementation where

  R : GcdDomain
  E : OrderedAbelianMonoidSup
  V : OrderedSet
  P : RecursivePolynomialCategory(R,E,V)
  TS : RegularTriangularSetCategory(R,E,V,P)
  N ==> NonNegativeInteger
  Z ==> Integer
  B ==> Boolean
  S ==> String
  K ==> Fraction R
  LP ==> List P
  PWT ==> Record(val : P, tower : TS)

  BWT ==> Record(val : Boolean, tower : TS)
  LpWT ==> Record(val : (List P), tower : TS)
  Split ==> List TS
  --KeyGcd ==> Record(arg1: P, arg2: P, arg3: TS, arg4: B)
  --EntryGcd ==> List PWT
  --HGcd ==> TabulatedComputationPackage(KeyGcd, EntryGcd)
  --KeyInvSet ==> Record(arg1: P, arg3: TS)
  --EntryInvSet ==> List TS
  --HInvSet ==> TabulatedComputationPackage(KeyInvSet, EntryInvSet)
  polsetpack ==> PolynomialSetUtilitiesPackage(R,E,V,P)
  regsetgcdpack ==> SquareFreeRegularTriangularSetGcdPackage(R,E,V,P,TS)

  Exports ==  with

     recip: (P, TS) -> Record(num:P,den:P)
       ++ \axiom{recip(p,ts)} returns the inverse of \axiom{p} w.r.t \spad{ts}
       ++ assuming that \axiom{p} is invertible w.r.t \spad{ts}.
     normalizedAssociate: (P, TS) -> P
       ++ \axiom{normalizedAssociate(p,ts)} returns a normalized polynomial 
       ++ \axiom{n} w.r.t. \spad{ts} such that \axiom{n} and \axiom{p} are
       ++ associates w.r.t \spad{ts} and assuming that \axiom{p} is invertible 
       ++ w.r.t \spad{ts}.
     normalize: (P, TS) -> List PWT
       ++ \axiom{normalize(p,ts)} normalizes \axiom{p} w.r.t \spad{ts}.
     outputArgs: (S, S, P, TS) -> Void
       ++ \axiom{outputArgs(s1,s2,p,ts)} 
       ++ is an internal subroutine, exported only for developement.
     normInvertible?: (P, TS) -> List BWT
       ++ \axiom{normInvertible?(p,ts)} 
       ++ is an internal subroutine, exported only for developement.

  Implementation == add

     if TS has SquareFreeRegularTriangularSetCategory(R,E,V,P)
     then

       normInvertible?(p:P, ts:TS): List BWT ==
         stoseInvertible?_sqfreg(p,ts)$regsetgcdpack

     else

       normInvertible?(p:P, ts:TS): List BWT ==
         stoseInvertible?_reg(p,ts)$regsetgcdpack

     if (R has RetractableTo(Integer)) and (V has ConvertibleTo(Symbol))
     then 

       outputArgs(s1:S, s2: S, p:P,ts:TS): Void ==
         if not empty? s1 then output(s1, p::OutputForm)$OutputPackage
         if not empty? s1 then _
              output(s1,(convert(p)@String)::OutputForm)$OutputPackage
         output(" ")$OutputPackage
         if not empty? s2 then output(s2, ts::OutputForm)$OutputPackage       
         empty? s2 => void()
         output(s2,("[")::OutputForm)$OutputPackage
         lp: List P := members(ts)
         for q in lp repeat
            output((convert(q)@String)::OutputForm)$OutputPackage
         output("]")$OutputPackage
         output(" ")$OutputPackage

     else

       outputArgs(s1:S, s2: S, p:P,ts:TS): Void ==
         if not empty? s1 then output(s1, p::OutputForm)$OutputPackage
         output(" ")$OutputPackage
         if not empty? s2 then output(s2, ts::OutputForm)$OutputPackage       
         output(" ")$OutputPackage

     recip(p:P,ts:TS): Record(num:P, den:P) ==
     -- ASSUME p is invertible w.r.t. ts
     -- ASSUME mvar(p) is algebraic w.r.t. ts
       v := mvar(p)
       ts_v := select(ts,v)::P
       if mdeg(p) < mdeg(ts_v)
         then
           hesrg: Record (gcd : P, coef2 : P)  := _
                    halfExtendedSubResultantGcd2(ts_v,p)$P
           d: P :=  hesrg.gcd; n: P := hesrg.coef2
         else
           hesrg: Record (gcd : P, coef1 : P) := _
                    halfExtendedSubResultantGcd1(p,ts_v)$P
           d: P :=  hesrg.gcd; n: P := hesrg.coef1
       g := gcd(n,d)
       (n, d) := ((n exquo g)::P, (d exquo g)::P)
       remn, remd: Record(rnum:R,polnum:P,den:R)
       remn := remainder(n,ts); remd := remainder(d,ts)
       cn := remn.rnum; pn := remn.polnum; dn := remn.den
       cd := remd.rnum; pd := remd.polnum; dp := remd.den
       k: K := (cn / cd) * (dp / dn)
       pn := removeZero(pn,ts)
       pd := removeZero(pd,ts)
       [numer(k) * pn, denom(k) * pd]$Record(num:P, den:P)

     normalizedAssociate(p:P,ts:TS): P ==
     -- ASSUME p is invertible or zero w.r.t. ts
       empty? ts => p
       zero?(p) => p
       ground?(p) => 1
       zero? initiallyReduce(init(p),ts) =>
         error "in normalizedAssociate$NORMPK: bad #1"
       vp := mvar(p)
       ip: P := p
       mp: P := 1
       tp: P := 0
       while not ground?(ip) repeat
         v := mvar(ip)
         if algebraic?(v,ts)
           then
             if v = vp
               then
                 ts_v := select(ts,v)::P
                 ip := lastSubResultant(ip,ts_v)$P
                 ip := remainder(ip,ts).polnum
                 -- ip := primitivePart stronglyReduce(ip,ts)
                 ip := primitivePart initiallyReduce(ip,ts)
               else
                 qr := recip(ip,ts)
                 ip := qr.den
                 tp := qr.num * tp
                 zero? ip =>
                     outputArgs("p = ", " ts = ",p,ts)
                     error _
                       "in normalizedAssociate$NORMPK: should never happen !"
           else
             tp := tail(ip) * mp + tp
             mp := mainMonomial(ip) * mp
             ip := init(ip)
       r := ip * mp + tp
       r := remainder(r,ts).polnum
       -- primitivePart stronglyReduce(r,ts)
       primitivePart initiallyReduce(r,ts)

     normalize(p: P, ts: TS): List PWT ==
       zero? p => [[p,ts]$PWT]
       ground? p => [[1,ts]$PWT]
       zero? initiallyReduce(init(p),ts) =>
         error "in normalize$NORMPK: init(#1) reduces to 0 w.r.t. #2"
       --output("Entering  normalize")$OutputPackage
       --outputArgs("p = ", " ts = ",p,ts)
       --output("Calling  normInvertible?")$OutputPackage
       lbwt: List BWT := normInvertible?(p,ts)
       --output("Result is: ")$OutputPackage
       --output(lbwt::OutputForm)$OutputPackage
       lpwt: List PWT := []
       for bwt in lbwt repeat
         us := bwt.tower
         q := remainder(p,us).polnum
         q := removeZero(q,us)
         bwt.val =>
           --output("Calling  normalizedAssociate")$OutputPackage
           --outputArgs("q = ", " us = ",q,us)
           lpwt := cons([normalizedAssociate(q,us)@P,us]$PWT, lpwt)
           --output("Leaving  normalizedAssociate")$OutputPackage
         zero? q => lpwt := cons([0$P,us]$PWT, lpwt)
         lpwt := concat(normalize(q,us)@(List PWT),lpwt)
       lpwt

@
<<NORMPK.dotabb>>=
"NORMPK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NORMPK"]
"SFRTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=SFRTCAT"]
"NORMPK" -> "SFRTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NORMMA NormInMonogenicAlgebra}
\pagehead{NormInMonogenicAlgebra}{NORMMA}
\pagepic{ps/v104norminmonogenicalgebra.ps}{NORMMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NORMMA NormInMonogenicAlgebra>>=
)abbrev package NORMMA NormInMonogenicAlgebra
++ Author: Manuel Bronstein
++ Date Created: 23 February 1995
++ Date Last Updated: 23 February 1995
++ Basic Functions: norm
++ Description:
++ This package implements the norm of a polynomial with coefficients
++ in a monogenic algebra (using resultants)

NormInMonogenicAlgebra(R, PolR, E, PolE): Exports == Implementation where
  R: GcdDomain
  PolR: UnivariatePolynomialCategory R
  E: MonogenicAlgebra(R, PolR)
  PolE: UnivariatePolynomialCategory E

  SUP ==> SparseUnivariatePolynomial

  Exports ==> with
    norm: PolE -> PolR
      ++ norm q returns the norm of q,
      ++ i.e. the product of all the conjugates of q.

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, SUP PolR)

    PolR2SUP: PolR -> SUP PolR
    PolR2SUP q == map(#1::PolR, q)

    defpol := PolR2SUP(definingPolynomial()$E)

    norm q ==
      p:SUP PolR := 0
      while q ~= 0 repeat
        p := p + monomial(1,degree q)$PolR * PolR2SUP lift leadingCoefficient q
        q := reductum q
      primitivePart resultant(p, defpol)

@
<<NORMMA.dotabb>>=
"NORMMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NORMMA"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NPCOEF NPCoef}
\pagehead{NPCoef}{NPCOEF}
\pagepic{ps/v104npcoef.ps}{NPCOEF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NPCOEF NPCoef>>=
)abbrev package NPCOEF NPCoef
++ Author : P.Gianni, revised May 1990
++ Description: 
++ Package for the determination of the coefficients in the lifting
++ process. Used by \spadtype{MultivariateLifting}.
++ This package will work for every euclidean domain R which has property
++ F, i.e. there exists a factor operation in \spad{R[x]}.
NPCoef(BP,E,OV,R,P) : C == T where
 
 OV   :   OrderedSet
 E    :   OrderedAbelianMonoidSup
 R    :   EuclideanDomain  -- with property "F"
 BP   :   UnivariatePolynomialCategory R
 P    :   PolynomialCategory(R,E,OV)
 
 Z       ==> Integer
 NNI     ==> NonNegativeInteger
 USP     ==> SparseUnivariatePolynomial(P)
 Term    ==> Record(expt:NNI,pcoef:P)
 Detc    ==> Record(valexp:NNI,valcoef:P,posit:NNI)
 VTerm   ==> List(Term)
 DetCoef ==> Record(deter:List(USP),dterm:List(VTerm),
                    nfacts:List(BP),nlead:List(P))
 TermC   ==> Record(coefu:P,detfacts:List(VTerm))
 TCoef   ==> List(TermC)
 
 C == with
      npcoef   :    (USP,List(BP),List(P))      ->   DetCoef
	++ npcoef \undocumented
      listexp  :              BP                ->   List(NNI)
	++ listexp \undocumented
 T == add
 
                 ----   Local  Functions  ----
  check      : (TermC,Vector P) -> Union(Detc,"failed")
  buildvect  : (List(VTerm),NNI) -> Vector(List(VTerm))
  buildtable : (Vector(P),List(List NNI),List P) -> TCoef
  modify : (TCoef,Detc) -> TCoef 
  constructp : VTerm -> USP

  npcoef(u:USP,factlist:List(BP),leadlist:List(P)) :DetCoef ==
    detcoef:List(VTerm):=empty();detufact:List(USP):=empty()
    lexp:List(List(NNI)):=[listexp(v) for v in factlist]
    ulist :Vector(P):=vector [coefficient(u,i) for i in 0..degree u]
    tablecoef:=buildtable(ulist,lexp,leadlist)
    detcoef:=[[[ep.first,lcu]$Term]  for ep in lexp for lcu in leadlist]
    ldtcf:=detcoef
    lexp:=[ep.rest for ep in lexp]
    ndet:NNI:=#factlist
    changed:Boolean:=true
    ltochange:List(NNI):=empty()
    ltodel:List(NNI):=empty()
    while changed and ndet^=1 repeat
      changed :=false
      dt:=#tablecoef
      for i in 1..dt while ^changed repeat
        (cf:=check(tablecoef.i,ulist)) case "failed" => "next i"
        ltochange:=cons(i,ltochange)
        celtf:Detc:=cf::Detc
        tablecoef:=modify(tablecoef,celtf)
        vpos:=celtf.posit
        vexp:=celtf.valexp
        nterm:=[vexp,celtf.valcoef]$Term
        detcoef.vpos:=cons(nterm,detcoef.vpos)
        lexp.vpos:=delete(lexp.vpos,position(vexp,lexp.vpos))
        if lexp.vpos=[] then
         ltodel:=cons(vpos,ltodel)
         ndet:=(ndet-1):NNI
         detufact:=cons(constructp(detcoef.vpos),detufact)
        changed:=true
      for i in ltochange repeat tablecoef:=delete(tablecoef,i)
      ltochange:=[]
    if ndet=1 then
     uu:=u exquo */[pol for pol in detufact]
     if uu case "failed" then return
       [empty(),ldtcf,factlist,leadlist]$DetCoef
     else  detufact:=cons(uu::USP,detufact)
    else
      ltodel:=sort(#1>#2,ltodel)
      for i in ltodel repeat
        detcoef:=delete(detcoef,i)
        factlist:=delete(factlist,i)
        leadlist:=delete(leadlist,i)
    [detufact,detcoef,factlist,leadlist]$DetCoef
 
 
  check(tterm:TermC,ulist:Vector(P)) : Union(Detc,"failed") ==
    cfu:P:=1$P;doit:NNI:=0;poselt:NNI:=0;pp:Union(P,"failed")
    termlist:List(VTerm):=tterm.detfacts
    vterm:VTerm:=empty()
    #termlist=1 =>
      vterm:=termlist.first
      for elterm in vterm while doit<2 repeat
        (cu1:=elterm.pcoef)^=0 => cfu:=cu1*cfu
        doit:=doit+1
        poselt:=position(elterm,vterm):NNI
      doit=2  or (pp:=tterm.coefu exquo cfu) case "failed" => "failed"
      [vterm.poselt.expt,pp::P,poselt]$Detc
    "failed"
 
  buildvect(lvterm:List(VTerm),n:NNI) : Vector(List(VTerm)) ==
    vtable:Vector(List(VTerm)):=new(n,empty())
    (#lvterm)=1 =>
      for term in lvterm.first repeat vtable.(term.expt+1):=[[term]]
      vtable
 
    vtable:=buildvect(lvterm.rest,n)
    ntable:Vector(List(VTerm)):=new(n,empty())
    for term in lvterm.first repeat
      nexp:=term.expt
      for i in 1..n while (nexp+i)<(n+1) repeat
        ntable.(nexp+i):=append(
                            [cons(term,lvterm) for lvterm in vtable.i],
                               ntable.(nexp+i))
    ntable
 
  buildtable(vu:Vector(P),lvect:List(List(NNI)),leadlist:List(P)):TCoef==
    nfact:NNI:=#leadlist
    table:TCoef:=empty()
    degu:=(#vu-1)::NNI
    prelim:List(VTerm):=[[[e,0$P]$Term for e in lv] for lv in lvect]
    for i in 1..nfact repeat prelim.i.first.pcoef:=leadlist.i
    partialv:Vector(List(VTerm)):=new(nfact,empty())
    partialv:=buildvect(prelim,degu)
    for i in 1..degu repeat
      empty? partialv.i => "next i"
      table:=cons([vu.i,partialv.i]$TermC, table)
    table
 
  modify(tablecoef:TCoef,cfter:Detc) : TCoef ==
    cfexp:=cfter.valexp;cfcoef:=cfter.valcoef;cfpos:=cfter.posit
    lterase:List(NNI):=empty()
    for cterm in tablecoef | ^empty?(ctdet:=cterm.detfacts) repeat
      (+/[term.expt for term in ctdet.first])<cfexp => "next term"
      for celt in ctdet repeat
        if celt.cfpos.expt=cfexp then
          celt.cfpos.pcoef:=cfcoef
          if (and/[cc.pcoef ^=0 for cc in celt]) then
            k:=position(celt,ctdet):NNI
            lterase:=cons(k,lterase)
            cterm.coefu:=(cterm.coefu - */[cc.pcoef for cc in celt])
      if not empty? lterase then
        lterase:=sort(#1>#2,lterase)
        for i in lterase repeat ctdet:=delete(ctdet,i)
        cterm.detfacts:=ctdet
        lterase:=empty()
    tablecoef
 
  listexp(up:BP) :List(NNI) ==
    degree up=0 => [0]
    [degree up,:listexp(reductum up)]
 
  constructp(lterm:VTerm):USP ==
    +/[monomial(term.pcoef,term.expt) for term in lterm]

@
<<NPCOEF.dotabb>>=
"NPCOEF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NPCOEF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"NPCOEF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NFINTBAS NumberFieldIntegralBasis}
\pagehead{NumberFieldIntegralBasis}{NFINTBAS}
\pagepic{ps/v104numberfieldintegralbasis.ps}{NFINTBAS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NFINTBAS NumberFieldIntegralBasis>>=
)abbrev package NFINTBAS NumberFieldIntegralBasis
++ Author: Victor Miller, Clifton Williamson
++ Date Created: 9 April 1990
++ Date Last Updated: 20 September 1994
++ Basic Operations: discriminant, integralBasis
++ Related Domains: IntegralBasisTools, TriangularMatrixOperations
++ Also See: FunctionFieldIntegralBasis, WildFunctionFieldIntegralBasis
++ AMS Classifications:
++ Keywords: number field, integral basis, discriminant
++ Examples:
++ References:
++ Description:
++   In this package F is a framed algebra over the integers (typically
++   \spad{F = Z[a]} for some algebraic integer a).  The package provides
++   functions to compute the integral closure of Z in the quotient
++   quotient field of F.
NumberFieldIntegralBasis(UP,F): Exports == Implementation where
  UP : UnivariatePolynomialCategory Integer
  F  : FramedAlgebra(Integer,UP)

  FR  ==> Factored Integer
  I   ==> Integer
  Mat ==> Matrix I
  NNI ==> NonNegativeInteger
  Ans ==> Record(basis: Mat, basisDen: I, basisInv:Mat,discr: I)

  Exports ==> with
    discriminant: () -> Integer
      ++ \spad{discriminant()} returns the discriminant of the integral
      ++ closure of Z in the quotient field of the framed algebra F.
    integralBasis : () -> Record(basis: Mat, basisDen: I, basisInv:Mat)
      ++ \spad{integralBasis()} returns a record
      ++ \spad{[basis,basisDen,basisInv]}
      ++ containing information regarding the integral closure of Z in the
      ++ quotient field of F, where F is a framed algebra with Z-module
      ++ basis \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.
    localIntegralBasis : I -> Record(basis: Mat, basisDen: I, basisInv:Mat)
      ++ \spad{integralBasis(p)} returns a record
      ++ \spad{[basis,basisDen,basisInv]} containing information regarding
      ++ the local integral closure of Z at the prime \spad{p} in the quotient
      ++ field of F, where F is a framed algebra with Z-module basis
      ++ \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.

  Implementation ==> add
    import IntegralBasisTools(I, UP, F)
    import ModularHermitianRowReduction(I)
    import TriangularMatrixOperations(I, Vector I, Vector I, Matrix I)

    frobMatrix              : (Mat,Mat,I,NNI) -> Mat
    wildPrimes              : (FR,I) -> List I
    tameProduct             : (FR,I) -> I
    iTameLocalIntegralBasis : (Mat,I,I) -> Ans
    iWildLocalIntegralBasis : (Mat,I,I) -> Ans

    frobMatrix(rb,rbinv,rbden,p) ==
      n := rank()$F; b := basis()$F
      v : Vector F := new(n,0)
      for i in minIndex(v)..maxIndex(v)
        for ii in minRowIndex(rb)..maxRowIndex(rb) repeat
          a : F := 0
          for j in minIndex(b)..maxIndex(b)
            for jj in minColIndex(rb)..maxColIndex(rb) repeat
              a := a + qelt(rb,ii,jj) * qelt(b,j)
          qsetelt_!(v,i,a**p)
      mat := transpose coordinates v
      ((transpose(rbinv) * mat) exquo (rbden ** p)) :: Mat

    wildPrimes(factoredDisc,n) ==
      -- returns a list of the primes <=n which divide factoredDisc to a
      -- power greater than 1
      ans : List I := empty()
      for f in factors(factoredDisc) repeat
        if f.exponent > 1 and f.factor <= n then ans := concat(f.factor,ans)
      ans

    tameProduct(factoredDisc,n) ==
      -- returns the product of the primes > n which divide factoredDisc
      -- to a power greater than 1
      ans : I := 1
      for f in factors(factoredDisc) repeat
        if f.exponent > 1 and f.factor > n then ans := f.factor * ans
      ans

    integralBasis() ==
      traceMat := traceMatrix()$F; n := rank()$F
      disc := determinant traceMat  -- discriminant of current order
      disc0 := disc                 -- this is disc(F)
      factoredDisc := factor(disc0)$IntegerFactorizationPackage(Integer)
      wilds := wildPrimes(factoredDisc,n)
      sing := tameProduct(factoredDisc,n)
      runningRb := scalarMatrix(n, 1); runningRbinv := scalarMatrix(n, 1)
      -- runningRb    = basis matrix of current order
      -- runningRbinv = inverse basis matrix of current order
      -- these are wrt the original basis for F
      runningRbden : I := 1
      -- runningRbden = denominator for current basis matrix
--      one? sing and empty? wilds => [runningRb, runningRbden, runningRbinv]
      (sing = 1) and empty? wilds => [runningRb, runningRbden, runningRbinv]
      -- id = basis matrix of the ideal (p-radical) wrt current basis
      matrixOut : Mat := scalarMatrix(n,0)
      for p in wilds repeat
        lb := iWildLocalIntegralBasis(matrixOut,disc,p)
        rb := lb.basis; rbinv := lb.basisInv; rbden := lb.basisDen
        disc := lb.discr
        -- update 'running integral basis' if newly computed
        -- local integral basis is non-trivial
        if sizeLess?(1,rbden) then
          mat := vertConcat(rbden * runningRb,runningRbden * rb)
          runningRbden := runningRbden * rbden
          runningRb := squareTop rowEchelon(mat,runningRbden)
          runningRbinv := UpTriBddDenomInv(runningRb,runningRbden)
      lb := iTameLocalIntegralBasis(traceMat,disc,sing)
      rb := lb.basis; rbinv := lb.basisInv; rbden := lb.basisDen
      disc := lb.discr
      -- update 'running integral basis' if newly computed
      -- local integral basis is non-trivial
      if sizeLess?(1,rbden) then
        mat := vertConcat(rbden * runningRb,runningRbden * rb)
        runningRbden := runningRbden * rbden
        runningRb := squareTop rowEchelon(mat,runningRbden)
        runningRbinv := UpTriBddDenomInv(runningRb,runningRbden)
      [runningRb,runningRbden,runningRbinv]

    localIntegralBasis p ==
      traceMat := traceMatrix()$F; n := rank()$F
      disc := determinant traceMat  -- discriminant of current order
      (disc exquo (p*p)) case "failed" =>
        [scalarMatrix(n, 1), 1, scalarMatrix(n, 1)]
      lb :=
        p > rank()$F =>
          iTameLocalIntegralBasis(traceMat,disc,p)
        iWildLocalIntegralBasis(scalarMatrix(n,0),disc,p)
      [lb.basis,lb.basisDen,lb.basisInv]

    iTameLocalIntegralBasis(traceMat,disc,sing) ==
      n := rank()$F; disc0 := disc
      rb := scalarMatrix(n, 1); rbinv := scalarMatrix(n, 1)
      -- rb    = basis matrix of current order
      -- rbinv = inverse basis matrix of current order
      -- these are wrt the original basis for F
      rbden : I := 1; index : I := 1; oldIndex : I := 1
      -- rbden = denominator for current basis matrix
      -- id = basis matrix of the ideal (p-radical) wrt current basis
      tfm := traceMat
      repeat
        -- compute the p-radical = p-trace-radical
        idinv := transpose squareTop rowEchelon(tfm,sing)
        -- [u1,..,un] are the coordinates of an element of the p-radical
        -- iff [u1,..,un] * idinv is in p * Z^n
        id := rowEchelon LowTriBddDenomInv(idinv, sing)
        -- id = basis matrix of the p-radical
        idinv := UpTriBddDenomInv(id, sing)
        -- id * idinv = sing * identity
        -- no need to check for inseparability in this case
        rbinv := idealiser(id * rb, rbinv * idinv, sing * rbden)
        index := diagonalProduct rbinv
        rb := rowEchelon LowTriBddDenomInv(rbinv, sing * rbden)
        g := matrixGcd(rb,sing,n)
        if sizeLess?(1,g) then rb := (rb exquo g) :: Mat
        rbden := rbden * (sing quo g)
        rbinv := UpTriBddDenomInv(rb, rbden)
        disc := disc0 quo (index * index)
        indexChange := index quo oldIndex; oldIndex := index
--        one? indexChange => return [rb, rbden, rbinv, disc]
        (indexChange = 1) => return [rb, rbden, rbinv, disc]
        tfm := ((rb * traceMat * transpose rb) exquo (rbden * rbden)) :: Mat

    iWildLocalIntegralBasis(matrixOut,disc,p) ==
      n := rank()$F; disc0 := disc
      rb := scalarMatrix(n, 1); rbinv := scalarMatrix(n, 1)
      -- rb    = basis matrix of current order
      -- rbinv = inverse basis matrix of current order
      -- these are wrt the original basis for F
      rbden : I := 1; index : I := 1; oldIndex : I := 1
      -- rbden = denominator for current basis matrix
      -- id = basis matrix of the ideal (p-radical) wrt current basis
      p2 := p * p; lp := leastPower(p::NNI,n)
      repeat
        tfm := frobMatrix(rb,rbinv,rbden,p::NNI) ** lp
        -- compute Rp = p-radical
        idinv := transpose squareTop rowEchelon(tfm, p)
        -- [u1,..,un] are the coordinates of an element of Rp
        -- iff [u1,..,un] * idinv is in p * Z^n
        id := rowEchelon LowTriBddDenomInv(idinv,p)
        -- id = basis matrix of the p-radical
        idinv := UpTriBddDenomInv(id,p)
        -- id * idinv = p * identity
        -- no need to check for inseparability in this case
        rbinv := idealiser(id * rb, rbinv * idinv, p * rbden)
        index := diagonalProduct rbinv
        rb := rowEchelon LowTriBddDenomInv(rbinv, p * rbden)
        if divideIfCan_!(rb,matrixOut,p,n) = 1
          then rb := matrixOut
          else rbden := p * rbden
        rbinv := UpTriBddDenomInv(rb, rbden)
        indexChange := index quo oldIndex; oldIndex := index
        disc := disc quo (indexChange * indexChange)
--        one? indexChange or gcd(p2,disc) ^= p2 =>
        (indexChange = 1) or gcd(p2,disc) ^= p2 =>
          return [rb, rbden, rbinv, disc]

    discriminant() ==
      disc := determinant traceMatrix()$F
      intBas := integralBasis()
      rb := intBas.basis; rbden := intBas.basisDen
      index := ((rbden ** rank()$F) exquo (determinant rb)) :: Integer
      (disc exquo (index * index)) :: Integer

@
<<NFINTBAS.dotabb>>=
"NFINTBAS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NFINTBAS"]
"FRAMALG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FRAMALG"]
"NFINTBAS" -> "FRAMALG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NUMFMT NumberFormats}
\pagehead{NumberFormats}{NUMFMT}
\pagepic{ps/v104numberformats.ps}{NUMFMT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NUMFMT NumberFormats>>=
)abbrev package NUMFMT NumberFormats
++ SMW March 88
++ Keywords: string manipulation, roman numerals, format
++ Description:
++ NumberFormats provides function to format and read arabic and
++ roman numbers, to convert numbers to strings and to read
++ floating-point numbers.

NumberFormats(): NFexports == NFimplementation where
    PI ==> PositiveInteger
    I  ==> Integer
    C  ==> Character
    F  ==> Float
    S  ==> String
    V  ==> PrimitiveArray

    NFexports ==> with
        FormatArabic: PI -> S
            ++ FormatArabic(n) forms an Arabic numeral
            ++ string from an integer n.
        ScanArabic:   S -> PI
            ++ ScanArabic(s) forms an integer from an Arabic numeral string s.
        FormatRoman:  PI -> S
            ++ FormatRoman(n) forms a Roman numeral string from an integer n.
        ScanRoman:    S -> PI
            ++ ScanRoman(s) forms an integer from a Roman numeral string s.
        ScanFloatIgnoreSpaces: S -> F
            ++ ScanFloatIgnoreSpaces(s) forms a floating point number from
            ++ the string s ignoring any spaces. Error is generated if the
            ++ string is not recognised as a floating point number.
        ScanFloatIgnoreSpacesIfCan: S -> Union(F, "failed")
            ++ ScanFloatIgnoreSpacesIfCan(s) tries to form a floating point
            ++ number from the string s ignoring any spaces.


    NFimplementation ==> add
        import SExpression
        import Symbol
        replaceD: C -> C
        replaced: C -> C
        contract: S -> S
        check: S ->Boolean
        replaceD c ==
          if c = char "D" then char "E" else c
        replaced c ==
          if c = char "d" then char "E" else c
        contract s ==
          s:= map(replaceD,s)
          s:= map(replaced,s)
          ls:List S := split(s,char " ")$String
          s:= concat ls
        check s ==
          NUMBERP(READ_-FROM_-STRING(s)$Lisp)$Lisp and
           -- if there is an "E" then there must be a "."
           -- this is not caught by code above
           -- also if the exponent is v.big the above returns false
           not (any?(#1=char "E",s) and not any?(#1=char ".",s) )

--        Original interpreter function:
--        )lis (defun scanstr(x) (spadcomp::|parseFromString| x))
        sexfloat:SExpression:=convert(coerce("Float")@Symbol)$SExpression
        ScanFloatIgnoreSpaces s ==
          s := contract s
          not check s => error "Non-numeric value"
          sex := interpret(packageTran(ncParseFromString(s)$Lisp)$Lisp)$Lisp
          sCheck := car(car(sex))
          if (sCheck=sexfloat) = true then
             f := (cdr cdr sex) pretend Float
          else
             if integer?(cdr sex) = true then
                f := (cdr sex) pretend Integer
                f::F
             else
                error "Non-numeric value"

        ScanFloatIgnoreSpacesIfCan s ==
          s := contract s
	  not check s => "failed"
          sex := interpret(packageTran(ncParseFromString(s)$Lisp)$Lisp)$Lisp
          sCheck := car(car(sex))
          if (sCheck=sexfloat) = true then
             f := (cdr cdr sex) pretend Float
          else
             if integer?(cdr sex) = true then
                f := (cdr sex) pretend Integer
                f::F
             else
                "failed"

        units:V S :=
           construct ["","I","II","III","IV","V","VI","VII","VIII","IX"]
        tens :V S :=
           construct ["","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"]
        hunds:V S :=
           construct ["","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"]
        umin := minIndex units
        tmin := minIndex tens
        hmin := minIndex hunds
        romval:V I := new(256, -1)
        romval ord char(" ")$C := 0
        romval ord char("I")$C := 1
        romval ord char("V")$C := 5
        romval ord char("X")$C := 10
        romval ord char("L")$C := 50
        romval ord char("C")$C := 100
        romval ord char("D")$C := 500
        romval ord char("M")$C := 1000
        thou:C  := char "M"
        plen:C  := char "("
        pren:C  := char ")"
        ichar:C := char "I"

        FormatArabic n == STRINGIMAGE(n)$Lisp
        ScanArabic   s == PARSE_-INTEGER(s)$Lisp

        FormatRoman pn ==
            n := pn::Integer
            -- Units
            d := (n rem 10) + umin
            n := n quo 10
            s := units.d
            zero? n => s
            -- Tens
            d := (n rem 10) + tmin
            n := n quo 10
            s := concat(tens.d, s)
            zero? n => s
            -- Hundreds
            d := (n rem 10) + hmin
            n := n quo 10
            s := concat(hunds.d, s)
            zero? n => s
            -- Thousands
            d := n rem 10
            n := n quo 10
            s := concat(new(d::NonNegativeInteger, thou), s)
            zero? n => s
            -- Ten thousand and higher
            for i in 2.. while not zero? n repeat
                -- Coefficient of 10**(i+2)
                d := n rem 10
                n := n quo 10
                zero? d => "iterate"
                m0:String := concat(new(i,plen),concat("I",new(i,pren)))
                mm := concat([m0 for j in 1..d]$List(String))
                -- strictly speaking the blank is gratuitous
                if #s > 0 then s := concat(" ", s)
                s  := concat(mm, s)
            s

        -- ScanRoman
        --
        -- The Algorithm:
        --    Read number from right to left.  When the current
        --    numeral is lower in magnitude than the previous maximum
        --    then subtract otherwise add.
        --    Shift left and repeat until done.

        ScanRoman s ==
            s      := upperCase s
            tot: I := 0
            Max: I := 0
            i:   I := maxIndex s
            while i >= minIndex s repeat
                -- Read a single roman digit
                c := s.i; i := i-1
                n := romval ord c
                -- (I)=1000, ((I))=10000, (((I)))=100000, etc
                if n < 0 then
                    c ^= pren =>
                       error ["Improper character in Roman numeral: ",c]
                    nprens: PI := 1
                    while c = pren and i >= minIndex s repeat
                       c := s.i; i := i-1
                       if c = pren then nprens := nprens+1
                    c ^= ichar =>
                       error "Improper Roman numeral: (x)"
                    for k in 1..nprens while i >= minIndex s repeat
                       c := s.i; i := i-1
                       c ^= plen =>
                          error "Improper Roman numeral: unbalanced ')'"
                    n := 10**(nprens + 2)
                if n < Max then
                    tot := tot - n
                else
                    tot := tot + n
                    Max := n
            tot < 0 => error ["Improper Roman numeral: ", tot]
            tot::PI

@
<<NUMFMT.dotabb>>=
"NUMFMT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NUMFMT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NUMFMT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NUMERIC Numeric}
\pagehead{Numeric}{NUMERIC}
\pagepic{ps/v104numeric.ps}{NUMERIC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NUMERIC Numeric>>=
)abbrev package NUMERIC Numeric
++ Author: Manuel Bronstein
++ Date Created: 21 Feb 1990
++ Date Last Updated: 17 August 1995, Mike Dewar
++                    24 January 1997, Miked Dewar (added partial operators)
++ Basic Operations: numeric, complexNumeric, numericIfCan, complexNumericIfCan
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords: 
++ References:
++ Description: Numeric provides real and complex numerical evaluation
++ functions for various symbolic types.
 
Numeric(S:ConvertibleTo Float): with
  numeric: S -> Float
    ++ numeric(x) returns a real approximation of x.
  numeric: (S, PositiveInteger) -> Float
    ++ numeric(x, n) returns a real approximation of x up to n decimal
    ++ places.
  complexNumeric: S -> Complex Float
    ++ complexNumeric(x) returns a complex approximation of x.
  complexNumeric: (S, PositiveInteger) -> Complex Float
    ++ complexNumeric(x, n) returns a complex approximation of x up
    ++ to n decimal places.
  if S has CommutativeRing then
    complexNumeric: Complex S -> Complex Float
      ++ complexNumeric(x) returns a complex approximation of x.
    complexNumeric: (Complex S, PositiveInteger) -> Complex Float
      ++ complexNumeric(x, n) returns a complex approximation of x up
      ++ to n decimal places.
    complexNumeric: Polynomial Complex S -> Complex Float
      ++ complexNumeric(x) returns a complex approximation of x.
    complexNumeric: (Polynomial Complex S, PositiveInteger) -> Complex Float
      ++ complexNumeric(x, n) returns a complex approximation of x up
      ++ to n decimal places.
  if S has Ring then
    numeric: Polynomial S -> Float
      ++ numeric(x) returns a real approximation of x.
    numeric: (Polynomial S, PositiveInteger) -> Float
      ++ numeric(x,n) returns a real approximation of x up to n decimal
      ++ places.
    complexNumeric: Polynomial S -> Complex Float
      ++ complexNumeric(x) returns a complex approximation of x.
    complexNumeric: (Polynomial S, PositiveInteger) -> Complex Float
      ++ complexNumeric(x, n) returns a complex approximation of x
      ++ up to n decimal places.
  if S has IntegralDomain then
    numeric: Fraction Polynomial S -> Float
      ++ numeric(x) returns a real approximation of x.
    numeric: (Fraction Polynomial S, PositiveInteger) -> Float
      ++ numeric(x,n) returns a real approximation of x up to n decimal
      ++ places.
    complexNumeric: Fraction Polynomial S -> Complex Float
      ++ complexNumeric(x) returns a complex approximation of x.
    complexNumeric: (Fraction Polynomial S, PositiveInteger) -> Complex Float
      ++ complexNumeric(x, n) returns a complex approximation of x
    complexNumeric: Fraction Polynomial Complex S -> Complex Float
      ++ complexNumeric(x) returns a complex approximation of x.
    complexNumeric: (Fraction Polynomial Complex S, PositiveInteger) -> 
                                                                Complex Float
      ++ complexNumeric(x, n) returns a complex approximation of x
      ++ up to n decimal places.
    if S has OrderedSet then
      numeric: Expression S -> Float
        ++ numeric(x) returns a real approximation of x.
      numeric: (Expression S, PositiveInteger) -> Float
        ++ numeric(x, n) returns a real approximation of x up to n
        ++ decimal places.
      complexNumeric: Expression S -> Complex Float
        ++ complexNumeric(x) returns a complex approximation of x.
      complexNumeric: (Expression S, PositiveInteger) -> Complex Float
        ++ complexNumeric(x, n) returns a complex approximation of x
        ++ up to n decimal places.
      complexNumeric: Expression Complex S -> Complex Float
        ++ complexNumeric(x) returns a complex approximation of x.
      complexNumeric: (Expression Complex S, PositiveInteger) -> Complex Float
        ++ complexNumeric(x, n) returns a complex approximation of x
        ++ up to n decimal places.
  if S has CommutativeRing then
    complexNumericIfCan: Polynomial Complex S -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x) returns a complex approximation of x,
      ++ or "failed" if \axiom{x} is not constant.
    complexNumericIfCan: (Polynomial Complex S, PositiveInteger) -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x, n) returns a complex approximation of x up
      ++ to n decimal places, or "failed" if \axiom{x} is not a constant.
  if S has Ring then
    numericIfCan: Polynomial S -> Union(Float,"failed")
      ++ numericIfCan(x) returns a real approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    numericIfCan: (Polynomial S, PositiveInteger) -> Union(Float,"failed")
      ++ numericIfCan(x,n) returns a real approximation of x up to n decimal
      ++ places, or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: Polynomial S -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x) returns a complex approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: (Polynomial S, PositiveInteger) -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x, n) returns a complex approximation of x
      ++ up to n decimal places, or "failed" if \axiom{x} is not a constant.
  if S has IntegralDomain then
    numericIfCan: Fraction Polynomial S -> Union(Float,"failed")
      ++ numericIfCan(x) returns a real approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    numericIfCan: (Fraction Polynomial S, PositiveInteger) -> Union(Float,"failed")
      ++ numericIfCan(x,n) returns a real approximation of x up to n decimal
      ++ places, or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: Fraction Polynomial S -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x) returns a complex approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: (Fraction Polynomial S, PositiveInteger) -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x, n) returns a complex approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: Fraction Polynomial Complex S -> Union(Complex Float,"failed")
      ++ complexNumericIfCan(x) returns a complex approximation of x,
      ++ or "failed" if \axiom{x} is not a constant.
    complexNumericIfCan: (Fraction Polynomial Complex S, PositiveInteger) -> 
                                                  Union(Complex Float,"failed")
      ++ complexNumericIfCan(x, n) returns a complex approximation of x
      ++ up to n decimal places, or "failed" if \axiom{x} is not a constant.
    if S has OrderedSet then
      numericIfCan: Expression S -> Union(Float,"failed")
        ++ numericIfCan(x) returns a real approximation of x,
        ++ or "failed" if \axiom{x} is not a constant.
      numericIfCan: (Expression S, PositiveInteger) -> Union(Float,"failed")
        ++ numericIfCan(x, n) returns a real approximation of x up to n
        ++ decimal places, or "failed" if \axiom{x} is not a constant.
      complexNumericIfCan: Expression S -> Union(Complex Float,"failed")
        ++ complexNumericIfCan(x) returns a complex approximation of x,
        ++ or "failed" if \axiom{x} is not a constant.
      complexNumericIfCan: (Expression S, PositiveInteger) ->
                                                  Union(Complex Float,"failed")
        ++ complexNumericIfCan(x, n) returns a complex approximation of x
        ++ up to n decimal places, or "failed" if \axiom{x} is not a constant.
      complexNumericIfCan: Expression Complex S -> Union(Complex Float,"failed")
        ++ complexNumericIfCan(x) returns a complex approximation of x,
        ++ or "failed" if \axiom{x} is not a constant.
      complexNumericIfCan: (Expression Complex S, PositiveInteger) ->
                                                   Union(Complex Float,"failed")
        ++ complexNumericIfCan(x, n) returns a complex approximation of x
        ++ up to n decimal places, or "failed" if \axiom{x} is not a constant.
 == add
 
  if S has CommutativeRing then
    complexNumericIfCan(p:Polynomial Complex S) ==
      p' : Union(Complex(S),"failed") := retractIfCan p
      p' case "failed" => "failed"
      complexNumeric(p')

    complexNumericIfCan(p:Polynomial Complex S,n:PositiveInteger) ==
      p' : Union(Complex(S),"failed") := retractIfCan p
      p' case "failed" => "failed"
      complexNumeric(p',n)
 
  if S has Ring then
    numericIfCan(p:Polynomial S) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => "failed"
      numeric(p')

    complexNumericIfCan(p:Polynomial S) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => "failed"
      complexNumeric(p')
 
    complexNumericIfCan(p:Polynomial S, n:PositiveInteger) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => "failed"
      complexNumeric(p', n)
 
    numericIfCan(p:Polynomial S, n:PositiveInteger) ==
      old := digits(n)$Float
      ans := numericIfCan p
      digits(old)$Float
      ans
 
  if S has IntegralDomain then
    numericIfCan(f:Fraction Polynomial S)==
      num := numericIfCan(numer(f))
      num case "failed" => "failed"
      den := numericIfCan(denom f)
      den case "failed" => "failed"
      num/den
 
    complexNumericIfCan(f:Fraction Polynomial S) ==
      num := complexNumericIfCan(numer f)
      num case "failed" => "failed"
      den := complexNumericIfCan(denom f)
      den case "failed" => "failed"
      num/den
 
    complexNumericIfCan(f:Fraction Polynomial S, n:PositiveInteger) ==
      num := complexNumericIfCan(numer f, n)
      num case "failed" => "failed"
      den := complexNumericIfCan(denom f, n)
      den case "failed" => "failed"
      num/den
 
    numericIfCan(f:Fraction Polynomial S, n:PositiveInteger) ==
      old := digits(n)$Float
      ans := numericIfCan f
      digits(old)$Float
      ans

    complexNumericIfCan(f:Fraction Polynomial Complex S) ==
      num := complexNumericIfCan(numer f)
      num case "failed" => "failed"
      den := complexNumericIfCan(denom f)
      den case "failed" => "failed"
      num/den
 
    complexNumericIfCan(f:Fraction Polynomial Complex S, n:PositiveInteger) ==
      num := complexNumericIfCan(numer f, n)
      num case "failed" => "failed"
      den := complexNumericIfCan(denom f, n)
      den case "failed" => "failed"
      num/den
 
    if S has OrderedSet then
      numericIfCan(x:Expression S) ==
        retractIfCan(map(convert, x)$ExpressionFunctions2(S, Float))
 
      --s2cs(u:S):Complex(S) == complex(u,0)

      complexNumericIfCan(x:Expression S) ==
         complexNumericIfCan map(coerce, x)$ExpressionFunctions2(S,Complex S)
 
      numericIfCan(x:Expression S, n:PositiveInteger) ==
        old := digits(n)$Float
        x' : Expression Float := map(convert, x)$ExpressionFunctions2(S, Float)
        ans : Union(Float,"failed") := retractIfCan x'
        digits(old)$Float
        ans
 
      complexNumericIfCan(x:Expression S, n:PositiveInteger) ==
        old := digits(n)$Float
        x' : Expression Complex S := map(coerce, x)$ExpressionFunctions2(S, Complex S)
        ans : Union(Complex Float,"failed") := complexNumericIfCan(x')
        digits(old)$Float
        ans

      if S has RealConstant then
        complexNumericIfCan(x:Expression Complex S) ==
          retractIfCan(map(convert, x)$ExpressionFunctions2(Complex S,Complex Float))
 
        complexNumericIfCan(x:Expression Complex S, n:PositiveInteger) ==
          old := digits(n)$Float
          x' : Expression Complex Float :=
           map(convert, x)$ExpressionFunctions2(Complex S,Complex Float)
          ans : Union(Complex Float,"failed") := retractIfCan x'
          digits(old)$Float
          ans
      else
        convert(x:Complex S):Complex(Float)==map(convert,x)$ComplexFunctions2(S,Float)

        complexNumericIfCan(x:Expression Complex S) ==
          retractIfCan(map(convert, x)$ExpressionFunctions2(Complex S,Complex Float))
 
        complexNumericIfCan(x:Expression Complex S, n:PositiveInteger) ==
          old := digits(n)$Float
          x' : Expression Complex Float :=
           map(convert, x)$ExpressionFunctions2(Complex S,Complex Float)
          ans : Union(Complex Float,"failed") := retractIfCan x'
          digits(old)$Float
          ans
  numeric(s:S) == convert(s)@Float
 
  if S has ConvertibleTo Complex Float then
    complexNumeric(s:S) == convert(s)@Complex(Float)
 
    complexNumeric(s:S, n:PositiveInteger) ==
      old := digits(n)$Float
      ans := complexNumeric s
      digits(old)$Float
      ans
 
  else
    complexNumeric(s:S) == convert(s)@Float :: Complex(Float)
 
    complexNumeric(s:S,n:PositiveInteger) ==
      numeric(s, n)::Complex(Float)

  if S has CommutativeRing then
    complexNumeric(p:Polynomial Complex S) ==
      p' : Union(Complex(S),"failed") := retractIfCan p
      p' case "failed" => 
        error "Cannot compute the numerical value of a non-constant polynomial"
      complexNumeric(p')

    complexNumeric(p:Polynomial Complex S,n:PositiveInteger) ==
      p' : Union(Complex(S),"failed") := retractIfCan p
      p' case "failed" => 
        error "Cannot compute the numerical value of a non-constant polynomial"
      complexNumeric(p',n)

    if S has RealConstant then
      complexNumeric(s:Complex S) == convert(s)$Complex(S)
  
      complexNumeric(s:Complex S, n:PositiveInteger) ==
        old := digits(n)$Float
        ans := complexNumeric s
        digits(old)$Float
        ans

    else if Complex(S) has ConvertibleTo(Complex Float) then
      complexNumeric(s:Complex S) == convert(s)@Complex(Float)
  
      complexNumeric(s:Complex S, n:PositiveInteger) ==
        old := digits(n)$Float
        ans := complexNumeric s
        digits(old)$Float
        ans

    else
      complexNumeric(s:Complex S) ==
        s' : Union(S,"failed") := retractIfCan s
        s' case "failed" =>
          error "Cannot compute the numerical value of a non-constant object"
        complexNumeric(s')
  
      complexNumeric(s:Complex S, n:PositiveInteger) ==
        s' : Union(S,"failed") := retractIfCan s
        s' case "failed" =>
          error "Cannot compute the numerical value of a non-constant object"
        old := digits(n)$Float
        ans := complexNumeric s'
        digits(old)$Float
        ans
 
  numeric(s:S, n:PositiveInteger) ==
    old := digits(n)$Float
    ans := numeric s
    digits(old)$Float
    ans
 
  if S has Ring then
    numeric(p:Polynomial S) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => error
       "Can only compute the numerical value of a constant, real-valued polynomial"
      numeric(p')

    complexNumeric(p:Polynomial S) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => 
        error "Cannot compute the numerical value of a non-constant polynomial"
      complexNumeric(p')
 
    complexNumeric(p:Polynomial S, n:PositiveInteger) ==
      p' : Union(S,"failed") := retractIfCan p
      p' case "failed" => 
        error "Cannot compute the numerical value of a non-constant polynomial"
      complexNumeric(p', n)
 
    numeric(p:Polynomial S, n:PositiveInteger) ==
      old := digits(n)$Float
      ans := numeric p
      digits(old)$Float
      ans
 
  if S has IntegralDomain then
    numeric(f:Fraction Polynomial S)==
        numeric(numer(f)) / numeric(denom f)
 
    complexNumeric(f:Fraction Polynomial S) ==
      complexNumeric(numer f)/complexNumeric(denom f)
 
    complexNumeric(f:Fraction Polynomial S, n:PositiveInteger) ==
      complexNumeric(numer f, n)/complexNumeric(denom f, n)
 
    numeric(f:Fraction Polynomial S, n:PositiveInteger) ==
      old := digits(n)$Float
      ans := numeric f
      digits(old)$Float
      ans

    complexNumeric(f:Fraction Polynomial Complex S) ==
      complexNumeric(numer f)/complexNumeric(denom f)
 
    complexNumeric(f:Fraction Polynomial Complex S, n:PositiveInteger) ==
      complexNumeric(numer f, n)/complexNumeric(denom f, n)
 
    if S has OrderedSet then
      numeric(x:Expression S) ==
        x' : Union(Float,"failed") := 
         retractIfCan(map(convert, x)$ExpressionFunctions2(S, Float))
        x' case "failed" => error
         "Can only compute the numerical value of a constant, real-valued Expression"
        x'
 
      complexNumeric(x:Expression S) ==
        x' : Union(Complex Float,"failed") := retractIfCan(
         map(complexNumeric, x)$ExpressionFunctions2(S,Complex Float))
        x' case "failed" =>
         error "Cannot compute the numerical value of a non-constant expression"
        x'
 
      numeric(x:Expression S, n:PositiveInteger) ==
        old := digits(n)$Float
        x' : Expression Float := map(convert, x)$ExpressionFunctions2(S, Float)
        ans : Union(Float,"failed") := retractIfCan x'
        digits(old)$Float
        ans case "failed" => error
         "Can only compute the numerical value of a constant, real-valued Expression"
        ans
 
      complexNumeric(x:Expression S, n:PositiveInteger) ==
        old := digits(n)$Float
        x' : Expression Complex Float :=
         map(complexNumeric, x)$ExpressionFunctions2(S,Complex Float)
        ans : Union(Complex Float,"failed") := retractIfCan x'
        digits(old)$Float
        ans case "failed" =>
         error "Cannot compute the numerical value of a non-constant expression"
        ans

      complexNumeric(x:Expression Complex S) ==
        x' : Union(Complex Float,"failed") := retractIfCan(
         map(complexNumeric, x)$ExpressionFunctions2(Complex S,Complex Float))
        x' case "failed" =>
         error "Cannot compute the numerical value of a non-constant expression"
        x'
 
      complexNumeric(x:Expression Complex S, n:PositiveInteger) ==
        old := digits(n)$Float
        x' : Expression Complex Float :=
         map(complexNumeric, x)$ExpressionFunctions2(Complex S,Complex Float)
        ans : Union(Complex Float,"failed") := retractIfCan x'
        digits(old)$Float
        ans case "failed" =>
         error "Cannot compute the numerical value of a non-constant expression"
        ans

@
<<NUMERIC.dotabb>>=
"NUMERIC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NUMERIC"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"NUMERIC" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NUMODE NumericalOrdinaryDifferentialEquations}
\pagehead{NumericalOrdinaryDifferentialEquations}{NUMODE}
\pagepic{ps/v104numericalordinarydifferentialequations.ps}{NUMODE}{1.00}
{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NUMODE NumericalOrdinaryDifferentialEquations>>=
)abbrev package NUMODE NumericalOrdinaryDifferentialEquations
++ Author: Yurij Baransky
++ Date Created: October 90
++ Date Last Updated: October 90
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package is a suite of functions for the numerical integration of an
++ ordinary differential equation of n variables:
++
++         \center{dy/dx = f(y,x)\space{5}y is an n-vector}
++
++ \par All the routines are based on a 4-th order Runge-Kutta kernel.
++ These routines generally have as arguments:
++ n, the number of dependent variables;
++ x1, the initial point;
++ h, the step size;
++ y, a vector of initial conditions of length n which upon exit contains the solution at \spad{x1 + h};
++ \spad{derivs}, a function which computes the right hand side of the
++ ordinary differential equation: \spad{derivs(dydx,y,x)} computes \spad{dydx},
++ a vector which contains the derivative information.
++
++ \par In order of increasing complexity:\begin{items}
++
++ \item \spad{rk4(y,n,x1,h,derivs)} advances the solution vector to
++ \spad{x1 + h} and return the values in y.
++
++ \item \spad{rk4(y,n,x1,h,derivs,t1,t2,t3,t4)} is the same as
++ \spad{rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch
++ arrays t1-t4 of size n.
++
++ \item Starting with y at x1, \spad{rk4f(y,n,x1,x2,ns,derivs)}
++ uses \spad{ns} fixed
++ steps of a 4-th order Runge-Kutta integrator to advance the
++ solution vector to x2 and return the values in y.
++ Argument x2, is the final point, and
++ \spad{ns}, the number of steps to take.
++
++ \item \spad{rk4qc(y,n,x1,step,eps,yscal,derivs)} takes a 5-th order
++ Runge-Kutta step with monitoring
++ of local truncation to ensure accuracy and adjust stepsize.
++ The function takes two half steps and one full step and scales
++ the difference in solutions at the final point. If the error is
++ within \spad{eps}, the step is taken and the result is returned.
++ If the error is not within \spad{eps}, the stepsize if decreased
++ and the procedure is tried again until the desired accuracy is
++ reached. Upon input, an trial step size must be given and upon
++ return, an estimate of the next step size to use is returned as
++ well as the step size which produced the desired accuracy.
++ The scaled error is computed as
++ \center{\spad{error = MAX(ABS((y2steps(i) - y1step(i))/yscal(i)))}}
++ and this is compared against \spad{eps}. If this is greater
++ than \spad{eps}, the step size is reduced accordingly to
++ \center{\spad{hnew = 0.9 * hdid * (error/eps)**(-1/4)}}
++ If the error criterion is satisfied, then we check if the
++ step size was too fine and return a more efficient one. If
++ \spad{error > \spad{eps} * (6.0E-04)} then the next step size should be
++ \center{\spad{hnext = 0.9 * hdid * (error/\spad{eps})**(-1/5)}}
++ Otherwise \spad{hnext = 4.0 * hdid} is returned.
++ A more detailed discussion of this and related topics can be
++ found in the book "Numerical Recipies" by W.Press, B.P. Flannery, 
++ S.A. Teukolsky, W.T. Vetterling published by Cambridge University Press.
++ Argument \spad{step} is a record of 3 floating point
++ numbers \spad{(try , did , next)},
++ \spad{eps} is the required accuracy,
++ \spad{yscal} is the scaling vector for the difference in solutions.
++ On input, \spad{step.try} should be the guess at a step
++ size to achieve the accuracy.
++ On output, \spad{step.did} contains the step size which achieved the
++ accuracy and \spad{step.next} is the next step size to use.
++
++ \item \spad{rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7)} is the
++ same as \spad{rk4qc(y,n,x1,step,eps,yscal,derivs)} except that the user
++ must provide the 7 scratch arrays \spad{t1-t7} of size n.
++
++ \item \spad{rk4a(y,n,x1,x2,eps,h,ns,derivs)}
++ is a driver program which uses \spad{rk4qc} to integrate n ordinary
++ differential equations starting at x1 to x2, keeping the local
++ truncation error to within \spad{eps} by changing the local step size.
++ The scaling vector is defined as
++ \center{\spad{yscal(i) = abs(y(i)) + abs(h*dydx(i)) + tiny}}
++ where \spad{y(i)} is the solution at location x, \spad{dydx} is the
++ ordinary differential equation's right hand side, h is the current
++ step size and \spad{tiny} is 10 times the
++ smallest positive number representable.
++ The user must supply an estimate for a trial step size and
++ the maximum number of calls to \spad{rk4qc} to use.
++ Argument x2 is the final point,
++ \spad{eps} is local truncation,
++ \spad{ns} is the maximum number of call to \spad{rk4qc} to use.
++ \end{items}
NumericalOrdinaryDifferentialEquations(): Exports == Implementation where
  L     ==> List
  V     ==> Vector
  B     ==> Boolean
  I     ==> Integer
  E     ==> OutputForm
  NF    ==> Float
  NNI   ==> NonNegativeInteger
  VOID  ==> Void
  OFORM ==> OutputForm
  RK4STEP ==> Record(try:NF, did:NF, next:NF)

  Exports ==> with
--header definitions here
   rk4   : (V NF,I,NF,NF,  (V NF,V NF,NF) -> VOID) -> VOID
    ++ rk4(y,n,x1,h,derivs) uses a 4-th order Runge-Kutta method
    ++ to numerically integrate the ordinary differential equation
    ++ {\em dy/dx = f(y,x)} of n variables, where y is an n-vector.
    ++ Argument y is a vector of initial conditions of length n which upon exit
    ++ contains the solution at \spad{x1 + h}, n is the number of dependent
    ++ variables, x1 is the initial point, h is the step size, and
    ++ \spad{derivs} is a function which computes the right hand side of the
    ++ ordinary differential equation.
    ++ For details, see \spadtype{NumericalOrdinaryDifferentialEquations}.
   rk4   : (V NF,I,NF,NF,  (V NF,V NF,NF) -> VOID
           ,V NF,V NF,V NF,V NF) -> VOID
    ++ rk4(y,n,x1,h,derivs,t1,t2,t3,t4) is the same as
    ++ \spad{rk4(y,n,x1,h,derivs)} except that you must provide 4 scratch
    ++ arrays t1-t4 of size n.
    ++ For details, see \con{NumericalOrdinaryDifferentialEquations}.
   rk4a  : (V NF,I,NF,NF,NF,NF,I,(V NF,V NF,NF) -> VOID ) -> VOID
    ++ rk4a(y,n,x1,x2,eps,h,ns,derivs) is a driver function for the
    ++ numerical integration of an ordinary differential equation
    ++ {\em dy/dx = f(y,x)} of n variables, where y is an n-vector
    ++ using a 4-th order Runge-Kutta method.
    ++ For details, see \con{NumericalOrdinaryDifferentialEquations}.
   rk4qc : (V NF,I,NF,RK4STEP,NF,V NF,(V NF,V NF,NF) -> VOID) -> VOID
    ++ rk4qc(y,n,x1,step,eps,yscal,derivs) is a subfunction for the
    ++ numerical integration of an ordinary differential equation
    ++ {\em dy/dx = f(y,x)} of n variables, where y is an n-vector
    ++ using a 4-th order Runge-Kutta method.
    ++ This function takes a 5-th order Runge-Kutta step with monitoring
    ++ of local truncation to ensure accuracy and adjust stepsize.
    ++ For details, see \con{NumericalOrdinaryDifferentialEquations}.
   rk4qc : (V NF,I,NF,RK4STEP,NF,V NF,(V NF,V NF,NF) -> VOID
           ,V NF,V NF,V NF,V NF,V NF,V NF,V NF) -> VOID
    ++ rk4qc(y,n,x1,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,t7) is a 
    ++ subfunction for the numerical integration of an ordinary differential
    ++ equation {\em dy/dx = f(y,x)} of n variables, where y is an n-vector
    ++ using a 4-th order Runge-Kutta method.
    ++ This function takes a 5-th order Runge-Kutta step with monitoring
    ++ of local truncation to ensure accuracy and adjust stepsize.
    ++ For details, see \con{NumericalOrdinaryDifferentialEquations}.
   rk4f  : (V NF,I,NF,NF,I,(V NF,V NF,NF) -> VOID ) -> VOID
    ++ rk4f(y,n,x1,x2,ns,derivs) uses a 4-th order Runge-Kutta method
    ++ to numerically integrate the ordinary differential equation
    ++ {\em dy/dx = f(y,x)} of n variables, where y is an n-vector.
    ++ Starting with y at x1, this function uses \spad{ns} fixed
    ++ steps of a 4-th order Runge-Kutta integrator to advance the
    ++ solution vector to x2 and return the values in y.
    ++ For details, see \con{NumericalOrdinaryDifferentialEquations}.

  Implementation ==>  add
  --some local function definitions here
   rk4qclocal : (V NF,V NF,I,NF,RK4STEP,NF,V NF,(V NF,V NF,NF) -> VOID
                ,V NF,V NF,V NF,V NF,V NF,V NF) -> VOID
   rk4local   : (V NF,V NF,I,NF,NF,V NF,(V NF,V NF,NF) -> VOID
                ,V NF,V NF,V NF) -> VOID
   import OutputPackage

------------------------------------------------------------

   rk4a(ystart,nvar,x1,x2,eps,htry,nstep,derivs) ==
      y       : V NF := new(nvar::NNI,0.0)
      yscal   : V NF := new(nvar::NNI,1.0)
      dydx    : V NF := new(nvar::NNI,0.0)
      t1      : V NF := new(nvar::NNI,0.0)
      t2      : V NF := new(nvar::NNI,0.0)
      t3      : V NF := new(nvar::NNI,0.0)
      t4      : V NF := new(nvar::NNI,0.0)
      t5      : V NF := new(nvar::NNI,0.0)
      t6      : V NF := new(nvar::NNI,0.0)
      step    : RK4STEP := [htry,0.0,0.0]
      x       : NF   := x1
      tiny    : NF   := 10.0**(-(digits()+1)::I)
      m       : I    := nvar
      outlist : L OFORM := [x::E,x::E,x::E]
      i       : I
      iter    : I

      eps  := 1.0/eps
      for i in 1..m repeat
         y(i)  := ystart(i)
      for iter in 1..nstep repeat
--compute the derivative
         derivs(dydx,y,x)
--if overshoot, the set h accordingly
         if (x + step.try - x2) > 0.0 then
            step.try := x2 - x
--find the correct scaling
         for i in 1..m repeat
            yscal(i) := abs(y(i)) + abs(step.try * dydx(i)) + tiny
--take a quality controlled runge-kutta step
         rk4qclocal(y,dydx,nvar,x,step,eps,yscal,derivs
                   ,t1,t2,t3,t4,t5,t6)
         x         := x + step.did
--       outlist.0 := x::E
--       outlist.1 := y(0)::E
--       outlist.2 := y(1)::E
--       output(blankSeparate(outlist)::E)
--check to see if done
         if (x-x2) >= 0.0 then
            leave
--next stepsize to use
         step.try := step.next
--end nstep repeat
      if iter = (nstep+1) then
         output("ode: ERROR ")
         outlist.1 := nstep::E
         outlist.2 := " steps to small, last h = "::E
         outlist.3 := step.did::E
         output(blankSeparate(outlist))
         output(" y= ",y::E)
      for i in 1..m repeat
         ystart(i) := y(i)

----------------------------------------------------------------

   rk4qc(y,n,x,step,eps,yscal,derivs) ==
      t1 : V NF := new(n::NNI,0.0)
      t2 : V NF := new(n::NNI,0.0)
      t3 : V NF := new(n::NNI,0.0)
      t4 : V NF := new(n::NNI,0.0)
      t5 : V NF := new(n::NNI,0.0)
      t6 : V NF := new(n::NNI,0.0)
      t7 : V NF := new(n::NNI,0.0)
      derivs(t7,y,x)
      eps := 1.0/eps
      rk4qclocal(y,t7,n,x,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6)

--------------------------------------------------------

   rk4qc(y,n,x,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6,dydx) ==
      derivs(dydx,y,x)
      eps := 1.0/eps
      rk4qclocal(y,dydx,n,x,step,eps,yscal,derivs,t1,t2,t3,t4,t5,t6)

--------------------------------------------------------

   rk4qclocal(y,dydx,n,x,step,eps,yscal,derivs
             ,t1,t2,t3,ysav,dysav,ytemp) ==
      xsav   : NF := x
      h      : NF := step.try
      fcor   : NF := 1.0/15.0
      safety : NF := 0.9
      grow   : NF := -0.20
      shrink : NF := -0.25
      errcon : NF := 0.6E-04  --(this is 4/safety)**(1/grow)
      hh     : NF
      errmax : NF
      i      : I
      m      : I  := n
--
      for i in 1..m repeat
         dysav(i) := dydx(i)
         ysav(i)  := y(i)
--cut down step size till error criterion is met
      repeat
--take two little steps to get to x + h
         hh := 0.5 * h
         rk4local(ysav,dysav,n,xsav,hh,ytemp,derivs,t1,t2,t3)
         x  := xsav + hh
         derivs(dydx,ytemp,x)
         rk4local(ytemp,dydx,n,x,hh,y,derivs,t1,t2,t3)
         x  := xsav + h
--take one big step get to x + h
         rk4local(ysav,dysav,n,xsav,h,ytemp,derivs,t1,t2,t3)

--compute the maximum scaled difference
         errmax := 0.0
         for i in 1..m repeat
            ytemp(i) := y(i) - ytemp(i)
            errmax   := max(errmax,abs(ytemp(i)/yscal(i)))
--scale relative to required accuracy
         errmax := errmax * eps
--update integration stepsize
         if (errmax > 1.0) then
            h := safety * h * (errmax ** shrink)
         else
            step.did := h
            if errmax > errcon then
               step.next := safety * h * (errmax ** grow)
            else
               step.next := 4 * h
            leave
--make fifth order with 4-th order error estimate
      for i in 1..m repeat
         y(i) := y(i) + ytemp(i) * fcor

--------------------------------------------

   rk4f(y,nvar,x1,x2,nstep,derivs) ==
     yt   : V NF := new(nvar::NNI,0.0)
     dyt  : V NF := new(nvar::NNI,0.0)
     dym  : V NF := new(nvar::NNI,0.0)
     dydx : V NF := new(nvar::NNI,0.0)
     ynew : V NF := new(nvar::NNI,0.0)
     h    : NF := (x2-x1) / (nstep::NF)
     x    : NF := x1
     i    : I
     j    : I
-- start integrating
     for i in 1..nstep repeat
        derivs(dydx,y,x)
        rk4local(y,dydx,nvar,x,h,y,derivs,yt,dyt,dym)
        x := x + h

--------------------------------------------------------

   rk4(y,n,x,h,derivs) ==
      t1 : V NF := new(n::NNI,0.0)
      t2 : V NF := new(n::NNI,0.0)
      t3 : V NF := new(n::NNI,0.0)
      t4 : V NF := new(n::NNI,0.0)
      derivs(t1,y,x)
      rk4local(y,t1,n,x,h,y,derivs,t2,t3,t4)

------------------------------------------------------------

   rk4(y,n,x,h,derivs,t1,t2,t3,t4) ==
      derivs(t1,y,x)
      rk4local(y,t1,n,x,h,y,derivs,t2,t3,t4)

------------------------------------------------------------

   rk4local(y,dydx,n,x,h,yout,derivs,yt,dyt,dym) ==
      hh : NF := h*0.5
      h6 : NF := h/6.0
      xh : NF := x+hh
      m  : I  := n
      i  : I
-- first step
      for i in 1..m repeat
         yt(i) := y(i) + hh*dydx(i)
-- second step
      derivs(dyt,yt,xh)
      for i in 1..m repeat
         yt(i) := y(i) + hh*dyt(i)
-- third step
      derivs(dym,yt,xh)
      for i in 1..m repeat
         yt(i)  := y(i)   + h*dym(i)
         dym(i) := dyt(i) + dym(i)
-- fourth step
      derivs(dyt,yt,x+h)
      for i in 1..m repeat
         yout(i) := y(i) + h6*( dydx(i) + 2.0*dym(i) + dyt(i) )

@
<<NUMODE.dotabb>>=
"NUMODE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NUMODE"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"NUMODE" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NUMQUAD NumericalQuadrature}
\pagehead{NumericalQuadrature}{NUMQUAD}
\pagepic{ps/v104numericalquadrature.ps}{NUMQUAD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NUMQUAD NumericalQuadrature>>=
)abbrev package NUMQUAD NumericalQuadrature
++ Author: Yurij A. Baransky
++ Date Created: October 90
++ Date Last Updated: October 90
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This suite of routines performs numerical quadrature using
++ algorithms derived from the basic trapezoidal rule. Because
++ the error term of this rule contains only even powers of the
++ step size (for open and closed versions), fast convergence
++ can be obtained if the integrand is sufficiently smooth.
++
++ Each routine returns a Record of type TrapAns, which contains\indent{3}
++ \newline value (\spadtype{Float}):\tab{20}  estimate of the integral
++ \newline error (\spadtype{Float}):\tab{20}  estimate of the error in the computation
++ \newline totalpts (\spadtype{Integer}):\tab{20} total number of function evaluations
++ \newline success (\spadtype{Boolean}):\tab{20} if the integral was computed within the user specified error criterion
++ \indent{0}\indent{0}
++ To produce this estimate, each routine generates an internal
++ sequence of sub-estimates, denoted by {\em S(i)}, depending on the
++ routine, to which the various convergence criteria are applied.
++ The user must supply a relative accuracy, \spad{eps_r}, and an absolute
++ accuracy, \spad{eps_a}. Convergence is obtained when either
++ \center{\spad{ABS(S(i) - S(i-1)) < eps_r * ABS(S(i-1))}}
++ \center{or    \spad{ABS(S(i) - S(i-1)) < eps_a}}
++ are true statements.
++
++ The routines come in three families and three flavors:
++ \newline\tab{3} closed:\tab{20}romberg,\tab{30}simpson,\tab{42}trapezoidal
++ \newline\tab{3} open:  \tab{20}rombergo,\tab{30}simpsono,\tab{42}trapezoidalo
++ \newline\tab{3} adaptive closed:\tab{20}aromberg,\tab{30}asimpson,\tab{42}atrapezoidal
++ \par
++ The {\em S(i)} for the trapezoidal family is the value of the
++ integral using an equally spaced absicca trapezoidal rule for
++ that level of refinement.
++ \par
++ The {\em S(i)} for the simpson family is the value of the integral
++ using an equally spaced absicca simpson rule for that level of
++ refinement.
++ \par
++ The {\em S(i)} for the romberg family is the estimate of the integral
++ using an equally spaced absicca romberg method. For
++ the \spad{i}-th level, this is an appropriate combination of all the
++ previous trapezodial estimates so that the error term starts
++ with the \spad{2*(i+1)} power only.
++ \par
++ The three families come in a closed version, where the formulas
++ include the endpoints, an open version where the formulas do not
++ include the endpoints and an adaptive version, where the user
++ is required to input the number of subintervals over which the
++ appropriate closed family integrator will apply with the usual
++ convergence parmeters for each subinterval. This is useful
++ where a large number of points are needed only in a small fraction
++ of the entire domain.
++ \par
++ Each routine takes as arguments:
++ \newline f\tab{10} integrand
++ \newline a\tab{10} starting point
++ \newline b\tab{10} ending point
++ \newline \spad{eps_r}\tab{10} relative error
++ \newline \spad{eps_a}\tab{10} absolute error
++ \newline \spad{nmin} \tab{10} refinement level when to start checking for convergence (> 1)
++ \newline \spad{nmax} \tab{10} maximum level of refinement
++ \par
++ The adaptive routines take as an additional parameter
++ \newline \spad{nint}\tab{10} the number of independent intervals to apply a closed
++  family integrator of the same name.
++ \par Notes:
++ \newline Closed family level i uses \spad{1 + 2**i} points.
++ \newline Open family level i uses \spad{1 + 3**i} points.
NumericalQuadrature(): Exports == Implementation where
  L        ==> List
  V        ==> Vector
  I        ==> Integer
  B        ==> Boolean
  E        ==> OutputForm
  F       ==> Float
  PI       ==> PositiveInteger
  OFORM    ==> OutputForm
  TrapAns  ==> Record(value:F, error:F, totalpts:I, success:B )

  Exports ==> with
   aromberg     : (F -> F,F,F,F,F,I,I,I) -> TrapAns
     ++ aromberg(fn,a,b,epsrel,epsabs,nmin,nmax,nint)
     ++ uses the adaptive romberg method to numerically integrate function
     ++ \spad{fn} over the closed interval from \spad{a} to \spad{b},
     ++ with relative accuracy \spad{epsrel} and absolute accuracy
     ++ \spad{epsabs}, with the refinement levels for convergence checking
     ++ vary from \spad{nmin} to \spad{nmax}, and where \spad{nint}
     ++ is the number of independent intervals to apply the integrator.
     ++ The value returned is a record containing the value of the integral,
     ++ the estimate of the error in the computation, the total number of
     ++ function evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   asimpson     : (F -> F,F,F,F,F,I,I,I) -> TrapAns
     ++ asimpson(fn,a,b,epsrel,epsabs,nmin,nmax,nint) uses the
     ++ adaptive simpson method to numerically integrate function \spad{fn}
     ++ over the closed interval from \spad{a} to \spad{b}, with relative
     ++ accuracy \spad{epsrel} and absolute accuracy \spad{epsabs}, with the
     ++ refinement levels for convergence checking vary from \spad{nmin}
     ++ to \spad{nmax}, and where \spad{nint} is the number of independent
     ++ intervals to apply the integrator. The value returned is a record
     ++ containing the value of the integral, the estimate of the error in
     ++ the computation, the total number of function evaluations, and
     ++ either a boolean value which is true if the integral was computed
     ++ within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   atrapezoidal : (F -> F,F,F,F,F,I,I,I) -> TrapAns
     ++ atrapezoidal(fn,a,b,epsrel,epsabs,nmin,nmax,nint) uses the
     ++ adaptive trapezoidal method to numerically integrate function
     ++ \spad{fn} over the closed interval from \spad{a} to \spad{b}, with
     ++ relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},
     ++ with the refinement levels for convergence checking vary from
     ++ \spad{nmin} to \spad{nmax}, and where \spad{nint} is the number
     ++ of independent intervals to apply the integrator. The value returned
     ++ is a record containing the value of the integral, the estimate of
     ++ the error in the computation, the total number of function
     ++ evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   romberg      : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ romberg(fn,a,b,epsrel,epsabs,nmin,nmax) uses the romberg
     ++ method to numerically integrate function \spadvar{fn} over the closed
     ++ interval \spad{a} to \spad{b}, with relative accuracy \spad{epsrel}
     ++ and absolute accuracy \spad{epsabs}, with the refinement levels
     ++ for convergence checking vary from \spad{nmin} to \spad{nmax}.
     ++ The value returned is a record containing the value
     ++ of the integral, the estimate of the error in the computation, the
     ++ total number of function evaluations, and either a boolean value
     ++ which is true if the integral was computed within the user specified
     ++ error criterion. See \spadtype{NumericalQuadrature} for details.
   simpson      : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ simpson(fn,a,b,epsrel,epsabs,nmin,nmax) uses the simpson
     ++ method to numerically integrate function \spad{fn} over the closed
     ++ interval \spad{a} to \spad{b}, with
     ++ relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},
     ++ with the refinement levels for convergence checking vary from
     ++ \spad{nmin} to \spad{nmax}. The value returned
     ++ is a record containing the value of the integral, the estimate of
     ++ the error in the computation, the total number of function
     ++ evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   trapezoidal  : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ trapezoidal(fn,a,b,epsrel,epsabs,nmin,nmax) uses the
     ++ trapezoidal method to numerically integrate function \spadvar{fn} over
     ++ the closed interval \spad{a} to \spad{b}, with relative accuracy
     ++ \spad{epsrel} and absolute accuracy \spad{epsabs}, with the
     ++ refinement levels for convergence checking vary
     ++ from \spad{nmin} to \spad{nmax}. The value
     ++ returned is a record containing the value of the integral, the
     ++ estimate of the error in the computation, the total number of
     ++ function evaluations, and either a boolean value which is true
     ++ if the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   rombergo     : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ rombergo(fn,a,b,epsrel,epsabs,nmin,nmax) uses the romberg
     ++ method to numerically integrate function \spad{fn} over
     ++ the open interval from \spad{a} to \spad{b}, with
     ++ relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},
     ++ with the refinement levels for convergence checking vary from
     ++ \spad{nmin} to \spad{nmax}. The value returned
     ++ is a record containing the value of the integral, the estimate of
     ++ the error in the computation, the total number of function
     ++ evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   simpsono     : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ simpsono(fn,a,b,epsrel,epsabs,nmin,nmax) uses the
     ++ simpson method to numerically integrate function \spad{fn} over
     ++ the open interval from \spad{a} to \spad{b}, with
     ++ relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},
     ++ with the refinement levels for convergence checking vary from
     ++ \spad{nmin} to \spad{nmax}. The value returned
     ++ is a record containing the value of the integral, the estimate of
     ++ the error in the computation, the total number of function
     ++ evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.
   trapezoidalo : (F -> F,F,F,F,F,I,I) -> TrapAns
     ++ trapezoidalo(fn,a,b,epsrel,epsabs,nmin,nmax) uses the
     ++ trapezoidal method to numerically integrate function \spad{fn}
     ++ over the open interval from \spad{a} to \spad{b}, with
     ++ relative accuracy \spad{epsrel} and absolute accuracy \spad{epsabs},
     ++ with the refinement levels for convergence checking vary from
     ++ \spad{nmin} to \spad{nmax}. The value returned
     ++ is a record containing the value of the integral, the estimate of
     ++ the error in the computation, the total number of function
     ++ evaluations, and either a boolean value which is true if
     ++ the integral was computed within the user specified error criterion.
     ++ See \spadtype{NumericalQuadrature} for details.

  Implementation ==> add
   trapclosed : (F -> F,F,F,F,I) -> F
   trapopen   : (F -> F,F,F,F,I) -> F
   import OutputPackage

---------------------------------------------------

   aromberg(func,a,b,epsrel,epsabs,nmin,nmax,nint) ==
      ans  : TrapAns
      sum  : F := 0.0
      err  : F := 0.0
      pts  : I  := 1
      done : B  := true
      hh   : F := (b-a) / nint
      x1   : F := a
      x2   : F := a + hh
      io   : L OFORM := [x1::E,x2::E]
      i    : I
      for i in 1..nint repeat
         ans := romberg(func,x1,x2,epsrel,epsabs,nmin,nmax)
         if (not ans.success) then
           io.1 := x1::E
           io.2 := x2::E
           print blankSeparate cons("accuracy not reached in interval"::E,io)
         sum  := sum + ans.value
         err  := err + abs(ans.error)
         pts  := pts + ans.totalpts-1
         done := (done and ans.success)
         x1   := x2
         x2   := x2 + hh
      return( [sum , err , pts , done] )

---------------------------------------------------

   asimpson(func,a,b,epsrel,epsabs,nmin,nmax,nint) ==
      ans  : TrapAns
      sum  : F := 0.0
      err  : F := 0.0
      pts  : I  := 1
      done : B  := true
      hh   : F := (b-a) / nint
      x1   : F := a
      x2   : F := a + hh
      io   : L OFORM := [x1::E,x2::E]
      i    : I
      for i in 1..nint repeat
         ans := simpson(func,x1,x2,epsrel,epsabs,nmin,nmax)
         if (not ans.success) then
           io.1 := x1::E
           io.2 := x2::E
           print blankSeparate cons("accuracy not reached in interval"::E,io)
         sum  := sum + ans.value
         err  := err + abs(ans.error)
         pts  := pts + ans.totalpts-1
         done := (done and ans.success)
         x1   := x2
         x2   := x2 + hh
      return( [sum , err , pts , done] )

---------------------------------------------------

   atrapezoidal(func,a,b,epsrel,epsabs,nmin,nmax,nint) ==
      ans  : TrapAns
      sum  : F := 0.0
      err  : F := 0.0
      pts  : I  := 1
      i    : I
      done : B := true
      hh   : F := (b-a) / nint
      x1   : F := a
      x2   : F := a + hh
      io   : L OFORM := [x1::E,x2::E]
      for i in 1..nint repeat
         ans := trapezoidal(func,x1,x2,epsrel,epsabs,nmin,nmax)
         if (not ans.success) then
           io.1 := x1::E
           io.2 := x2::E
           print blankSeparate cons("accuracy not reached in interval"::E,io)
         sum  := sum + ans.value
         err  := err + abs(ans.error)
         pts  := pts + ans.totalpts-1
         done := (done and ans.success)
         x1   := x2
         x2   := x2 + hh
      return( [sum , err , pts , done] )

---------------------------------------------------

   romberg(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length
      newsum : F := 0.5 * length * (func(a)+func(b))
      newest : F := 0.0
      oldsum : F := 0.0
      oldest : F := 0.0
      change : F := 0.0
      qx1    : F := newsum
      table  : V F := new((nmax+1)::PI,0.0)
      n      : I  := 1
      pts    : I  := 1
      four   : I
      j      : I
      i      : I
      if (nmin < 2) then
         output("romberg: nmin to small (nmin > 1) nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (nmax < nmin) then
         output("romberg: nmax < nmin : nmax = ",nmax::E)
         output("                       nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (a = b) then
         output("romberg: integration limits are equal  = ",a::E)
         return([0.0,0.0,1,true])
      if (epsrel < 0.0) then
         output("romberg: eps_r < 0.0            eps_r  = ",epsrel::E)
         return([0.0,0.0,0,false])
      if (epsabs < 0.0) then
         output("romberg: eps_a < 0.0            eps_a  = ",epsabs::E)
         return([0.0,0.0,0,false])
      for n in 1..nmax repeat
         oldsum := newsum
         newsum := trapclosed(func,a,delta,oldsum,pts)
         newest := (4.0 * newsum - oldsum) / 3.0
         four   := 4
         table(n) := newest
         for j in 2..n repeat
            i        := n+1-j
            four     := four * 4
            table(i) := table(i+1) + (table(i+1)-table(i)) / (four-1)
         if n > nmin then
            change := abs(table(1) - qx1)
            if change < abs(epsrel*qx1) then
               return( [table(1) , change , 2*pts+1 , true] )
            if change < epsabs then
               return( [table(1) , change , 2*pts+1 , true] )
         oldsum := newsum
         oldest := newest
         delta  := 0.5*delta
         pts    := 2*pts
         qx1    := table(1)
      return( [table(1) , 1.25*change , pts+1 ,false] )

---------------------------------------------------

   simpson(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length
      newsum : F := 0.5*(b-a)*(func(a)+func(b))
      newest : F := 0.0
      oldsum : F := 0.0
      oldest : F := 0.0
      change : F := 0.0
      n      : I  := 1
      pts    : I  := 1
      if (nmin < 2) then
         output("simpson: nmin to small (nmin > 1) nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (nmax < nmin) then
         output("simpson: nmax < nmin : nmax = ",nmax::E)
         output("                       nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (a = b) then
         output("simpson: integration limits are equal  = ",a::E)
         return([0.0,0.0,1,true])
      if (epsrel < 0.0) then
         output("simpson: eps_r < 0.0 : eps_r = ",epsrel::E)
         return([0.0,0.0,0,false])
      if (epsabs < 0.0) then
         output("simpson: eps_a < 0.0 : eps_a = ",epsabs::E)
         return([0.0,0.0,0,false])
      for n in 1..nmax repeat
         oldsum := newsum
         newsum := trapclosed(func,a,delta,oldsum,pts)
         newest := (4.0 * newsum - oldsum) / 3.0
         if n > nmin then
            change := abs(newest-oldest)
            if change < abs(epsrel*oldest) then
               return( [newest , 1.25*change , 2*pts+1 , true] )
            if change < epsabs then
               return( [newest , 1.25*change , 2*pts+1 , true] )
         oldsum := newsum
         oldest := newest
         delta  := 0.5*delta
         pts    := 2*pts
      return( [newest , 1.25*change , pts+1 ,false] )

---------------------------------------------------

   trapezoidal(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length
      newsum : F := 0.5*(b-a)*(func(a)+func(b))
      change : F := 0.0
      oldsum : F
      n      : I  := 1
      pts    : I  := 1
      if (nmin < 2) then
         output("trapezoidal: nmin to small (nmin > 1) nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (nmax < nmin) then
         output("trapezoidal: nmax < nmin : nmax = ",nmax::E)
         output("                           nmin = ",nmin::E)
         return([0.0,0.0,0,false])
      if (a = b) then
         output("trapezoidal: integration limits are equal  = ",a::E)
         return([0.0,0.0,1,true])
      if (epsrel < 0.0) then
         output("trapezoidal: eps_r < 0.0 : eps_r = ",epsrel::E)
         return([0.0,0.0,0,false])
      if (epsabs < 0.0) then
         output("trapezoidal: eps_a < 0.0 : eps_a = ",epsabs::E)
         return([0.0,0.0,0,false])
      for n in 1..nmax repeat
         oldsum := newsum
         newsum := trapclosed(func,a,delta,oldsum,pts)
         if n > nmin then
            change := abs(newsum-oldsum)
            if change < abs(epsrel*oldsum) then
               return( [newsum , 1.25*change , 2*pts+1 , true] )
            if change < epsabs then
               return( [newsum , 1.25*change , 2*pts+1 , true] )
         delta := 0.5*delta
         pts   := 2*pts
      return( [newsum , 1.25*change , pts+1 ,false] )

---------------------------------------------------

   rombergo(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length / 3.0
      newsum : F := length * func( 0.5*(a+b) )
      newest : F := 0.0
      oldsum : F := 0.0
      oldest : F := 0.0
      change : F := 0.0
      qx1    : F := newsum
      table  : V F := new((nmax+1)::PI,0.0)
      four   : I
      j      : I
      i      : I
      n      : I  := 1
      pts    : I  := 1
      for n in 1..nmax repeat
         oldsum   := newsum
         newsum   := trapopen(func,a,delta,oldsum,pts)
         newest   := (9.0 * newsum - oldsum) / 8.0
         table(n) := newest
         nine     := 9
         output(newest::E)
         for j in 2..n repeat
            i        := n+1-j
            nine     := nine * 9
            table(i) := table(i+1) + (table(i+1)-table(i)) / (nine-1)
         if n > nmin then
            change := abs(table(1) - qx1)
            if change < abs(epsrel*qx1) then
               return( [table(1) , 1.5*change , 3*pts , true] )
            if change < epsabs then
               return( [table(1) , 1.5*change , 3*pts , true] )
         output(table::E)
         oldsum := newsum
         oldest := newest
         delta  := delta / 3.0
         pts    := 3*pts
         qx1    := table(1)
      return( [table(1) , 1.5*change , pts ,false] )

---------------------------------------------------

   simpsono(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length / 3.0
      newsum : F := length * func( 0.5*(a+b) )
      newest : F := 0.0
      oldsum : F := 0.0
      oldest : F := 0.0
      change : F := 0.0
      n      : I  := 1
      pts    : I  := 1
      for n in 1..nmax repeat
         oldsum := newsum
         newsum := trapopen(func,a,delta,oldsum,pts)
         newest := (9.0 * newsum - oldsum) / 8.0
         output(newest::E)
         if n > nmin then
            change := abs(newest - oldest)
            if change < abs(epsrel*oldest) then
               return( [newest , 1.5*change , 3*pts , true] )
            if change < epsabs then
               return( [newest , 1.5*change , 3*pts , true] )
         oldsum := newsum
         oldest := newest
         delta  := delta / 3.0
         pts    := 3*pts
      return( [newest , 1.5*change , pts ,false] )

---------------------------------------------------

   trapezoidalo(func,a,b,epsrel,epsabs,nmin,nmax) ==
      length : F := (b-a)
      delta  : F := length/3.0
      newsum : F := length*func( 0.5*(a+b) )
      change : F := 0.0
      pts    : I  := 1
      oldsum : F
      n      : I
      for n in 1..nmax repeat
         oldsum := newsum
         newsum := trapopen(func,a,delta,oldsum,pts)
         output(newsum::E)
         if n > nmin then
            change := abs(newsum-oldsum)
            if change < abs(epsrel*oldsum) then
               return([newsum , 1.5*change , 3*pts , true] )
            if change < epsabs then
               return([newsum , 1.5*change , 3*pts , true] )
         delta := delta / 3.0
         pts   := 3*pts
      return([newsum , 1.5*change , pts ,false] )

---------------------------------------------------

   trapclosed(func,start,h,oldsum,numpoints) ==
      x   : F := start + 0.5*h
      sum : F := 0.0
      i   : I
      for i in 1..numpoints repeat
          sum := sum + func(x)
          x   := x + h
      return( 0.5*(oldsum + sum*h) )

---------------------------------------------------

   trapopen(func,start,del,oldsum,numpoints) ==
      ddel : F := 2.0*del
      x   : F := start + 0.5*del
      sum : F := 0.0
      i   : I
      for i in 1..numpoints repeat
          sum := sum + func(x)
          x   := x + ddel
          sum := sum + func(x)
          x   := x + del
      return( (oldsum/3.0 + sum*del) )

@
<<NUMQUAD.dotabb>>=
"NUMQUAD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NUMQUAD"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"NUMQUAD" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NCEP NumericComplexEigenPackage}
\pagehead{NumericComplexEigenPackage}{NCEP}
\pagepic{ps/v104numericcomplexeigenpackage.ps}{NCEP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

\pagehead{NumericComplexEigenPackage}{NCEP}
\pagepic{ps/v104numericcomplexeigenpackage.ps}{NCEP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NCEP NumericComplexEigenPackage>>=
)abbrev package NCEP NumericComplexEigenPackage
++ Author: P. Gianni
++ Date Created: Summer 1990
++ Date Last Updated: Spring 1991
++ Basic Functions:
++ Related Constructors: FloatingComplexPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package computes explicitly eigenvalues and eigenvectors of
++ matrices with entries over the complex rational numbers.
++ The results are expressed either as complex floating numbers or as
++ complex rational numbers
++ depending on the type of the precision parameter.
NumericComplexEigenPackage(Par) : C == T
 where
   Par   :   Join(Field,OrderedRing)   -- Float or RationalNumber

   SE    ==> Symbol()
   RN    ==> Fraction Integer
   I     ==> Integer
   NF    ==> Float
   CF    ==> Complex Float
   GRN   ==> Complex RN
   GI    ==> Complex Integer
   PI    ==> PositiveInteger
   NNI   ==> NonNegativeInteger
   MRN   ==> Matrix RN

   MCF        ==> Matrix CF
   MGRN       ==> Matrix GRN
   MCPar      ==> Matrix Complex Par
   SUPGRN     ==> SparseUnivariatePolynomial GRN
   outForm    ==> Record(outval:Complex Par,outmult:Integer,outvect:List MCPar)

   C == with
     characteristicPolynomial :   MGRN    -> Polynomial GRN
       ++ characteristicPolynomial(m) returns the characteristic polynomial
       ++ of the matrix m expressed as polynomial
       ++ over complex rationals with a new symbol as variable.
       -- while the function in EigenPackage returns Fraction P GRN.
     characteristicPolynomial : (MGRN,SE) -> Polynomial GRN
       ++ characteristicPolynomial(m,x) returns the characteristic polynomial
       ++ of the matrix m expressed as polynomial
       ++ over Complex Rationals with variable x.
       -- while the function in EigenPackage returns Fraction P GRN.
     complexEigenvalues  :   (MGRN,Par)   ->  List Complex Par
       ++ complexEigenvalues(m,eps) computes the eigenvalues of the matrix
       ++ m to precision eps. The eigenvalues are expressed as complex 
       ++ floats or complex rational numbers depending on the type of 
       ++ eps (float or rational).
     complexEigenvectors    : (MGRN,Par)   ->  List(outForm)
       ++ complexEigenvectors(m,eps)  returns a list of
       ++ records each one containing
       ++ a complex eigenvalue, its algebraic multiplicity, and a list of
       ++ associated eigenvectors. All these results
       ++ are computed to precision eps and are expressed as complex floats
       ++ or complex rational numbers depending on the type of 
       ++ eps (float or rational).
   T == add

     import InnerNumericEigenPackage(GRN,Complex Par,Par)

     characteristicPolynomial(m:MGRN) : Polynomial GRN  ==
       x:SE:=new()$SE
       multivariate(charpol m, x)

            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:MGRN,x:SE):Polynomial GRN ==
       multivariate(charpol A, x)

     complexEigenvalues(m:MGRN,eps:Par) : List Complex Par  ==
       solve1(charpol m, eps)

     complexEigenvectors(m:MGRN,eps:Par) :List outForm ==
       innerEigenvectors(m,eps,factor$ComplexFactorization(RN,SUPGRN))

@
<<NCEP.dotabb>>=
"NCEP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NCEP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"NCEP" -> "COMPCAT"

@
<<NCEP.dotabb>>=
"NCEP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NCEP"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"NCEP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NCNTFRAC NumericContinuedFraction}
\pagehead{NumericContinuedFraction}{NCNTFRAC}
\pagepic{ps/v104numericcontinuedfraction.ps}{NCNTFRAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NCNTFRAC NumericContinuedFraction>>=
)abbrev package NCNTFRAC NumericContinuedFraction
++ Author: Clifton J. Williamson
++ Date Created: 12 April 1990
++ Change History:
++ Basic Operations: continuedFraction
++ Related Constructors: ContinuedFraction, Float
++ Also See: Fraction
++ AMS Classifications: 11J70 11A55 11K50 11Y65 30B70 40A15
++ Keywords: continued fraction
++ References:
++ Description: \spadtype{NumericContinuedFraction} provides functions
++   for converting floating point numbers to continued fractions.

NumericContinuedFraction(F): Exports == Implementation where
  F :     FloatingPointSystem
  CFC ==> ContinuedFraction Integer
  I   ==> Integer
  ST  ==> Stream I

  Exports ==> with
    continuedFraction: F -> CFC
      ++ continuedFraction(f) converts the floating point number
      ++ \spad{f} to a reduced continued fraction.

  Implementation ==> add

    cfc: F -> ST
    cfc(a) == delay
      aa := wholePart a
      zero?(b := a - (aa :: F)) => concat(aa,empty()$ST)
      concat(aa,cfc inv b)

    continuedFraction a ==
      aa := wholePart a
      zero?(b := a - (aa :: F)) =>
        reducedContinuedFraction(aa,empty()$ST) 
      if negative? b then (aa := aa - 1; b := b + 1)
      reducedContinuedFraction(aa,cfc inv b) 

@
<<NCNTFRAC.dotabb>>=
"NCNTFRAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NCNTFRAC"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"NCNTFRAC" -> "FIELD"
"NCNTFRAC" -> "RADCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NREP NumericRealEigenPackage}
\pagehead{NumericRealEigenPackage}{NREP}
\pagepic{ps/v104numericrealeigenpackage.ps}{NREP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NREP NumericRealEigenPackage>>=
)abbrev package NREP NumericRealEigenPackage
++ Author:P. Gianni
++ Date Created:Summer 1990
++ Date Last Updated:Spring 1991
++ Basic Functions:
++ Related Constructors: FloatingRealPackage
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package computes explicitly eigenvalues and eigenvectors of
++ matrices with entries over the Rational Numbers.
++ The results are expressed as floating numbers or as rational numbers
++ depending on the type of the parameter Par.
NumericRealEigenPackage(Par) : C == T
 where
   Par   :   Join(Field,OrderedRing) -- Float or RationalNumber

   SE    ==> Symbol()
   RN    ==> Fraction Integer
   I     ==> Integer
   NF    ==> Float
   CF    ==> Complex Float
   GRN   ==> Complex RN
   GI    ==> Complex Integer
   PI    ==> PositiveInteger
   NNI   ==> NonNegativeInteger
   MRN   ==> Matrix RN

   MPar        ==> Matrix Par
   outForm     ==> Record(outval:Par,outmult:Integer,outvect:List MPar)

   C == with
     characteristicPolynomial :   MRN    -> Polynomial RN
       ++ characteristicPolynomial(m) returns the characteristic polynomial
       ++ of the matrix m expressed as polynomial
       ++ over RN with a new symbol as variable.
       -- while the function in EigenPackage returns Fraction P RN.
     characteristicPolynomial : (MRN,SE) -> Polynomial RN
       ++ characteristicPolynomial(m,x) returns the characteristic polynomial
       ++ of the matrix m expressed as polynomial
       ++ over RN with variable x.
       -- while the function in EigenPackage returns
       ++ Fraction P RN.
     realEigenvalues  :   (MRN,Par)   ->  List Par
       ++ realEigenvalues(m,eps) computes the eigenvalues of the matrix
       ++ m to precision eps. The eigenvalues are expressed as floats or
       ++ rational numbers depending on the type of eps (float or rational).
     realEigenvectors    : (MRN,Par)   ->  List(outForm)
       ++ realEigenvectors(m,eps)  returns a list of
       ++ records each one containing
       ++ a real eigenvalue, its algebraic multiplicity, and a list of
       ++ associated eigenvectors. All these results
       ++ are computed to precision eps as floats or rational
       ++ numbers depending on the type of eps .


   T == add

     import InnerNumericEigenPackage(RN, Par, Par)

     characteristicPolynomial(m:MRN) : Polynomial RN ==
       x:SE:=new()$SE
       multivariate(charpol(m),x)

            ----  characteristic polynomial of a matrix A ----
     characteristicPolynomial(A:MRN,x:SE):Polynomial RN ==
       multivariate(charpol(A),x)

     realEigenvalues(m:MRN,eps:Par) : List Par  ==
       solve1(charpol m, eps)

     realEigenvectors(m:MRN,eps:Par) :List outForm ==
       innerEigenvectors(m,eps,factor$GenUFactorize(RN))

@
<<NREP.dotabb>>=
"NREP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NREP"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"NREP" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter O}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OCTCT2 OctonionCategoryFunctions2}
\pagehead{OctonionCategoryFunctions2}{OCTCT2}
\pagepic{ps/v104octonioncategoryfunctions2.ps}{OCTCT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OCTCT2 OctonionCategoryFunctions2>>=
)abbrev package OCTCT2 OctonionCategoryFunctions2
--% OctonionCategoryFunctions2
++ Author: Johannes Grabmeier
++ Date Created: 10 September 1990
++ Date Last Updated: 10 September 1990
++ Basic Operations: map
++ Related Constructors: 
++ Also See: 
++ AMS Classifications:
++ Keywords: octonion, non-associative algebra, Cayley-Dixon  
++ References:
++ Description:
++  OctonionCategoryFunctions2 implements functions between
++  two octonion domains defined over different rings. 
++  The function map is used 
++  to coerce between octonion types.
 
OctonionCategoryFunctions2(OR,R,OS,S) : Exports ==
  Implementation where
    R  : CommutativeRing
    S  : CommutativeRing
    OR : OctonionCategory R
    OS : OctonionCategory S
    Exports == with
      map:     (R -> S, OR) -> OS
        ++ map(f,u) maps f onto the component parts of the octonion
        ++ u.
    Implementation == add
      map(fn : R -> S, u : OR): OS ==
        octon(fn real u, fn imagi u, fn imagj u, fn imagk u,_
        fn imagE u, fn imagI u, fn imagJ u, fn imagK u)$OS

@
<<OCTCT2.dotabb>>=
"OCTCT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OCTCT2"]
"OC" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OC"]
"OCTCT2" -> "OC"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEINT ODEIntegration}
\pagehead{ODEIntegration}{ODEINT}
\pagepic{ps/v104odeintegration.ps}{ODEINT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEINT ODEIntegration>>=
)abbrev package ODEINT ODEIntegration
++ Author: Manuel Bronstein
++ Date Created: 4 November 1991
++ Date Last Updated: 2 February 1994
++ Description:
++ \spadtype{ODEIntegration} provides an interface to the integrator.
++ This package is intended for use
++ by the differential equations solver but not at top-level.
ODEIntegration(R, F): Exports == Implementation where
  R: Join(OrderedSet, EuclideanDomain, RetractableTo Integer,
          LinearlyExplicitRingOver Integer, CharacteristicZero)
  F: Join(AlgebraicallyClosedFunctionSpace R, TranscendentalFunctionCategory,
                                              PrimitiveFunctionCategory)

  Q   ==> Fraction Integer
  UQ  ==> Union(Q, "failed")
  SY  ==> Symbol
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  REC ==> Record(coef:Q, logand:F)

  Exports ==> with
    int   : (F, SY) -> F
      ++ int(f, x) returns the integral of f with respect to x.
    expint: (F, SY) -> F
      ++ expint(f, x) returns e^{the integral of f with respect to x}.
    diff  : SY -> (F -> F)
      ++ diff(x) returns the derivation with respect to x.

  Implementation ==> add
    import FunctionSpaceIntegration(R, F)
    import ElementaryFunctionStructurePackage(R, F)

    isQ   : List F -> UQ
    isQlog: F -> Union(REC, "failed")
    mkprod: List REC -> F

    diff x == differentiate(#1, x)

-- This is the integration function to be used for quadratures
    int(f, x) ==
      (u := integrate(f, x)) case F => u::F
      first(u::List(F))

-- mkprod([q1, f1],...,[qn,fn]) returns */(fi^qi) but groups the
-- qi having the same denominator together
    mkprod l ==
      empty? l => 1
      rec := first l
      d := denom(rec.coef)
      ll := select(denom(#1.coef) = d, l)
      nthRoot(*/[r.logand ** numer(r.coef) for r in ll], d) *
        mkprod setDifference(l, ll)

-- computes exp(int(f,x)) in a non-naive way
    expint(f, x) ==
      a := int(f, x)
      (u := validExponential(tower a, a, x)) case F => u::F
      da := denom a
      l :=
        (v := isPlus(na := numer a)) case List(P) => v::List(P)
        [na]
      exponent:P := 0
      lrec:List(REC) := empty()
      for term in l repeat
        if (w := isQlog(term / da)) case REC then
          lrec := concat(w::REC, lrec)
        else
          exponent := exponent + term
      mkprod(lrec) * exp(exponent / da)

-- checks if all the elements of l are rational numbers, returns their product
    isQ l ==
      prod:Q := 1
      for x in l repeat
        (u := retractIfCan(x)@UQ) case "failed" => return "failed"
        prod := prod * u::Q
      prod

-- checks if a non-sum expr is of the form c * log(g) for a rational number c
    isQlog f ==
      is?(f, "log"::SY) => [1, first argument(retract(f)@K)]
      (v := isTimes f) case List(F) and (#(l := v::List(F)) <= 3) =>
          l := reverse_! sort_! l
          is?(first l, "log"::SY) and ((u := isQ rest l) case Q) =>
              [u::Q, first argument(retract(first(l))@K)]
          "failed"
      "failed"

@
<<ODEINT.dotabb>>=
"ODEINT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEINT"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"ODEINT" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODETOOLS ODETools}
\pagehead{ODETools}{ODETOOLS}
\pagepic{ps/v104odetools.ps}{ODETOOLS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODETOOLS ODETools>>=
)abbrev package ODETOOLS ODETools
++ Author: Manuel Bronstein
++ Date Created: 20 March 1991
++ Date Last Updated: 2 February 1994
++ Description:
++   \spad{ODETools} provides tools for the linear ODE solver.
ODETools(F, LODO): Exports == Implementation where
  N ==> NonNegativeInteger
  L ==> List F
  V ==> Vector F
  M ==> Matrix F

  F:    Field
  LODO: LinearOrdinaryDifferentialOperatorCategory F

  Exports ==> with
    wronskianMatrix: L -> M
      ++ wronskianMatrix([f1,...,fn]) returns the \spad{n x n} matrix m
      ++ whose i^th row is \spad{[f1^(i-1),...,fn^(i-1)]}.
    wronskianMatrix: (L, N) -> M
      ++ wronskianMatrix([f1,...,fn], q, D) returns the \spad{q x n} matrix m
      ++ whose i^th row is \spad{[f1^(i-1),...,fn^(i-1)]}.
    variationOfParameters: (LODO, F, L) -> Union(V, "failed")
      ++ variationOfParameters(op, g, [f1,...,fm])
      ++ returns \spad{[u1,...,um]} such that a particular solution of the
      ++ equation \spad{op y = g} is \spad{f1 int(u1) + ... + fm int(um)}
      ++ where \spad{[f1,...,fm]} are linearly independent and \spad{op(fi)=0}.
      ++ The value "failed" is returned if \spad{m < n} and no particular
      ++ solution is found.
    particularSolution: (LODO, F, L, F -> F) -> Union(F, "failed")
      ++ particularSolution(op, g, [f1,...,fm], I) returns a particular
      ++ solution h of the equation \spad{op y = g} where \spad{[f1,...,fm]}
      ++ are linearly independent and \spad{op(fi)=0}.
      ++ The value "failed" is returned if no particular solution is found.
      ++ Note: the method of variations of parameters is used.

  Implementation ==> add
    import LinearSystemMatrixPackage(F, V, V, M)

    diff := D()$LODO

    wronskianMatrix l == wronskianMatrix(l, #l)

    wronskianMatrix(l, q) ==
      v:V := vector l
      m:M := zero(q, #v)
      for i in minRowIndex m .. maxRowIndex m repeat
        setRow_!(m, i, v)
        v := map_!(diff #1, v)
      m

    variationOfParameters(op, g, b) ==
      empty? b => "failed"
      v:V := new(n := degree op, 0)
      qsetelt_!(v, maxIndex v, g / leadingCoefficient op)
      particularSolution(wronskianMatrix(b, n), v)

    particularSolution(op, g, b, integration) ==
      zero? g => 0
      (sol := variationOfParameters(op, g, b)) case "failed" => "failed"
      ans:F := 0
      for f in b for i in minIndex(s := sol::V) .. repeat
        ans := ans + integration(qelt(s, i)) * f
      ans

@
<<ODETOOLS.dotabb>>=
"ODETOOLS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODETOOLS"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"ODETOOLS" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ARRAY12 OneDimensionalArrayFunctions2}
\pagehead{OneDimensionalArrayFunctions2}{ARRAY12}
\pagepic{ps/v104onedimensionalarrayfunctions2.ps}{ARRAY12}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ARRAY12 OneDimensionalArrayFunctions2>>=
)abbrev package ARRAY12 OneDimensionalArrayFunctions2
++ This package provides tools for operating on one-dimensional arrays
++ with unary and binary functions involving different underlying types
OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> OneDimensionalArray A
  VB ==> OneDimensionalArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)

  Exports ==> with
   scan   : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of one-dimensional array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1

   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ one-dimensional array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of one-dimensional array
    ++ \spad{a} resulting in a new one-dimensional array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<ARRAY12.dotabb>>=
"ARRAY12" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ARRAY12"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ONECOMP2 OnePointCompletionFunctions2}
\pagehead{OnePointCompletionFunctions2}{ONECOMP2}
\pagepic{ps/v104onepointcompletionfunctions2.ps}{ONECOMP2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ONECOMP2 OnePointCompletionFunctions2>>=
)abbrev package ONECOMP2 OnePointCompletionFunctions2
++ Lifting of maps to one-point completions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to one-point completions.
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
OnePointCompletionFunctions2(R, S): Exports == Implementation where
  R, S: SetCategory

  OPR ==> OnePointCompletion R
  OPS ==> OnePointCompletion S

  Exports ==> with
    map: (R -> S, OPR) -> OPS
      ++ map(f, r) lifts f and applies it to r, assuming that
      ++ f(infinity) = infinity.
    map: (R -> S, OPR, OPS) -> OPS
      ++ map(f, r, i) lifts f and applies it to r, assuming that
      ++ f(infinity) = i.

  Implementation ==> add
    map(f, r) == map(f, r, infinity())

    map(f, r, i) ==
      (u := retractIfCan r) case R => (f(u::R))::OPS
      i

@
<<ONECOMP2.dotabb>>=
"ONECOMP2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ONECOMP2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"ONECOMP2" -> "BASTYPE"
"ONECOMP2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OMPKG OpenMathPackage}
\pagehead{OpenMathPackage}{OMPKG}
\pagepic{ps/v104openmathpackage.ps}{OMPKG}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OMPKG OpenMathPackage>>=
)abbrev package OMPKG OpenMathPackage
++ Author: Vilya Harvey
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: \spadtype{OpenMathPackage} provides some simple utilities 
++ to make reading OpenMath objects easier.

OpenMathPackage(): with
  OMread            : OpenMathDevice -> Any
  ++ OMread(dev) reads an OpenMath object from \axiom{dev} and passes it
  ++ to AXIOM.
  OMreadFile        : String -> Any
  ++ OMreadFile(f) reads an OpenMath object from \axiom{f} and passes it
  ++ to AXIOM.
  OMreadStr         : String -> Any
  ++ OMreadStr(f) reads an OpenMath object from \axiom{f} and passes it
  ++ to AXIOM.
  OMlistCDs         : () -> List(String)
  ++ OMlistCDs() lists all the CDs supported by AXIOM.
  OMlistSymbols     : String -> List(String)
  ++ OMlistSymbols(cd) lists all the symbols in \axiom{cd}.
  OMsupportsCD?      : String -> Boolean
  ++ OMsupportsCD?(cd) returns true if AXIOM supports \axiom{cd}, false 
  ++ otherwise.
  OMsupportsSymbol? : (String, String) -> Boolean
  ++ OMsupportsSymbol?(s,cd) returns true if AXIOM supports symbol \axiom{s}
  ++ from CD \axiom{cd}, false otherwise.
  OMunhandledSymbol : (String, String) -> Exit
  ++ OMunhandledSymbol(s,cd) raises an error if AXIOM reads a symbol which it
  ++ is unable to handle.  Note that this is different from an unexpected
  ++ symbol.
 == add
  import OpenMathEncoding
  import OpenMathDevice
  import String

  OMunhandledSymbol(u,v) ==
    error concat ["AXIOM is unable to process the symbol ",u," from CD ",v,"."]

  OMread(dev: OpenMathDevice): Any ==
    interpret(OM_-READ(dev)$Lisp :: InputForm)

  OMreadFile(filename: String): Any ==
    dev := OMopenFile(filename, "r", OMencodingUnknown())
    res: Any := interpret(OM_-READ(dev)$Lisp :: InputForm)
    OMclose(dev)
    res

  OMreadStr(str: String): Any ==
    strp := OM_-STRINGTOSTRINGPTR(str)$Lisp
    dev := OMopenString(strp pretend String, OMencodingUnknown())
    res: Any := interpret(OM_-READ(dev)$Lisp :: InputForm)
    OMclose(dev)
    res

  OMlistCDs(): List(String) ==
    OM_-LISTCDS()$Lisp pretend List(String)

  OMlistSymbols(cd: String): List(String) ==
    OM_-LISTSYMBOLS(cd)$Lisp pretend List(String)

  import SExpression

  OMsupportsCD?(cd: String): Boolean ==
    not null? OM_-SUPPORTSCD(cd)$Lisp 

  OMsupportsSymbol?(cd: String, name: String): Boolean ==
    not null? OM_-SUPPORTSSYMBOL(cd, name)$Lisp

@
<<OMPKG.dotabb>>=
"OMPKG" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OMPKG"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"OMPKG" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OMSERVER OpenMathServerPackage}
\pagehead{OpenMathServerPackage}{OMSERVER}
\pagepic{ps/v104openmathserverpackage.ps}{OMSERVER}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OMSERVER OpenMathServerPackage>>=
)abbrev package OMSERVER OpenMathServerPackage
++ Author: Vilya Harvey
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: \spadtype{OpenMathServerPackage} provides the necessary
++ operations to run AXIOM as an OpenMath server, reading/writing objects
++ to/from a port.  Please note the facilities available here are very basic.
++ The idea is that a user calls e.g. \axiom{Omserve(4000,60)} and then
++ another process sends OpenMath objects to port 4000 and reads the result.

OpenMathServerPackage(): with
  OMreceive : OpenMathConnection -> Any
  ++ OMreceive(c) reads an OpenMath object from connection \axiom{c} and
  ++ returns the appropriate AXIOM object.
  OMsend    : (OpenMathConnection, Any) -> Void
  ++ OMsend(c,u) attempts to output \axiom{u} on \axiom{c} in OpenMath.
  OMserve   : (SingleInteger, SingleInteger) -> Void
  ++ OMserve(portnum,timeout) puts AXIOM into server mode on port number
  ++ \axiom{portnum}.  The parameter \axiom{timeout} specifies the timeout
  ++ period for the connection.
 == add
  import OpenMathDevice
  import OpenMathConnection
  import OpenMathPackage
  import OpenMath



  OMreceive(conn: OpenMathConnection): Any ==
    dev: OpenMathDevice := OMconnInDevice(conn)
    OMsetEncoding(dev, OMencodingUnknown);
    OMread(dev)

  OMsend(conn: OpenMathConnection, value: Any): Void ==
    dev: OpenMathDevice := OMconnOutDevice(conn)
    OMsetEncoding(dev, OMencodingXML);
    --retractable?(value)$AnyFunctions1(Expression Integer) =>
    --  OMwrite(dev, retract(value)$AnyFunctions1(Expression Integer), true)
    retractable?(value)$AnyFunctions1(Integer) =>
      OMwrite(dev, retract(value)$AnyFunctions1(Integer), true)
    retractable?(value)$AnyFunctions1(Float) =>
      OMwrite(dev, retract(value)$AnyFunctions1(Float), true)
    retractable?(value)$AnyFunctions1(SingleInteger) =>
      OMwrite(dev, retract(value)$AnyFunctions1(SingleInteger), true)
    retractable?(value)$AnyFunctions1(DoubleFloat) =>
      OMwrite(dev, retract(value)$AnyFunctions1(DoubleFloat), true)
    retractable?(value)$AnyFunctions1(String) =>
      OMwrite(dev, retract(value)$AnyFunctions1(String), true)

  OMserve(portNum: SingleInteger, timeout: SingleInteger): Void ==
    conn: OpenMathConnection := OMmakeConn(timeout)
    OMbindTCP(conn, portNum)
    val: Any
    while true repeat
      val := OMreceive(conn)
      OMsend(conn, val)

@
<<OMSERVER.dotabb>>=
"OMSERVER" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OMSERVER"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"OMSERVER" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ORDCOMP2 OrderedCompletionFunctions2}
\pagehead{OrderedCompletionFunctions2}{ORDCOMP2}
\pagepic{ps/v104orderedcompletionfunctions2.ps}{ORDCOMP2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ORDCOMP2 OrderedCompletionFunctions2>>=
)abbrev package ORDCOMP2 OrderedCompletionFunctions2
++ Lifting of maps to ordered completions
++ Author: Manuel Bronstein
++ Description: Lifting of maps to ordered completions.
++ Date Created: 4 Oct 1989
++ Date Last Updated: 4 Oct 1989
OrderedCompletionFunctions2(R, S): Exports == Implementation where
  R, S: SetCategory

  ORR ==> OrderedCompletion R
  ORS ==> OrderedCompletion S

  Exports ==> with
    map: (R -> S, ORR) -> ORS
      ++ map(f, r) lifts f and applies it to r, assuming that
      ++ f(plusInfinity) = plusInfinity and that
      ++ f(minusInfinity) = minusInfinity.
    map: (R -> S, ORR, ORS, ORS) -> ORS
      ++ map(f, r, p, m) lifts f and applies it to r, assuming that
      ++ f(plusInfinity) = p and that f(minusInfinity) = m.

  Implementation ==> add
    map(f, r) == map(f, r, plusInfinity(), minusInfinity())

    map(f, r, p, m) ==
      zero?(n := whatInfinity r) => (f retract r)::ORS
--      one? n => p
      (n = 1) => p
      m

@
<<ORDCOMP2.dotabb>>=
"ORDCOMP2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ORDCOMP2"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"ORDCOMP2" -> "BASTYPE"
"ORDCOMP2" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ORDFUNS OrderingFunctions}
\pagehead{OrderingFunctions}{ORDFUNS}
\pagepic{ps/v104orderingfunctions.ps}{ORDFUNS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ORDFUNS OrderingFunctions>>=
)abbrev package ORDFUNS OrderingFunctions
++ Author: Barry Trager
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: OrderedDirectProduct
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package provides ordering functions on vectors which
++ are suitable parameters for OrderedDirectProduct.

OrderingFunctions(dim,S) : T == C  where
  dim : NonNegativeInteger
  S         : OrderedAbelianMonoid
  VS       == Vector S

  T ==  with
     pureLex    :  (VS,VS)  -> Boolean
       ++ pureLex(v1,v2) return true if the vector v1 is less than the
       ++ vector v2 in the lexicographic ordering.
     totalLex   :  (VS,VS)  -> Boolean
       ++ totalLex(v1,v2) return true if the vector v1 is less than the
       ++ vector v2 in the ordering which is total degree refined by
       ++ lexicographic ordering.
     reverseLex :  (VS,VS)  -> Boolean
       ++ reverseLex(v1,v2) return true if the vector v1 is less than the
       ++ vector v2 in the ordering which is total degree refined by
       ++ the reverse lexicographic ordering.

  C == add
    n:NonNegativeInteger:=dim

 -- pure lexicographical ordering
    pureLex(v1:VS,v2:VS) : Boolean ==
      for i in 1..n repeat
        if qelt(v1,i) < qelt(v2,i) then return true
        if qelt(v2,i) < qelt(v1,i) then return false
      false

 -- total ordering refined with lex
    totalLex(v1:VS,v2:VS) :Boolean ==
      n1:S:=0
      n2:S:=0
      for i in 1..n repeat
        n1:= n1+qelt(v1,i)
        n2:=n2+qelt(v2,i)
      n1<n2 => true
      n2<n1 => false
      for i in 1..n repeat
        if qelt(v1,i) < qelt(v2,i) then return true
        if qelt(v2,i) < qelt(v1,i) then return false
      false

 -- reverse lexicographical ordering
    reverseLex(v1:VS,v2:VS) :Boolean ==
      n1:S:=0
      n2:S:=0
      for i in 1..n repeat
        n1:= n1+qelt(v1,i)
        n2:=n2+qelt(v2,i)
      n1<n2 => true
      n2<n1 => false
      for i in reverse(1..n) repeat
        if qelt(v2,i) < qelt(v1,i) then return true
        if qelt(v1,i) < qelt(v2,i) then return false
      false

@
<<ORDFUNS.dotabb>>=
"ORDFUNS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ORDFUNS"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"ORDFUNS" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OPQUERY OperationsQuery}
\pagehead{OperationsQuery}{OPQUERY}
\pagepic{ps/v104operationsquery.ps}{OPQUERY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OPQUERY OperationsQuery>>=
)abbrev package OPQUERY OperationsQuery
++ This package exports tools to create AXIOM Library information databases.
OperationsQuery(): Exports == Implementation where
  Exports == with
    getDatabase: String -> Database(IndexCard)
      ++ getDatabase("char") returns a list of appropriate entries in the
      ++ browser database.  The legal values for "char" are "o" (operations),
      ++ "k" (constructors), "d" (domains), "c" (categories) or "p" (packages).
  Implementation == add
    getDatabase(s) == getBrowseDatabase(s)$Lisp

@
<<OPQUERY.dotabb>>=
"OPQUERY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OPQUERY"]
"ORDSET" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ORDSET"]
"OPQUERY" -> "ORDSET"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OUT OutputPackage}
\pagehead{OutputPackage}{OUT}
\pagepic{ps/v104outputpackage.ps}{OUT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OUT OutputPackage>>=
)abbrev package OUT OutputPackage
++ Author: Stephen M. Watt
++ Date Created: February 1986
++ Date Last Updated: October 27 1995 (MCD)
++ Basic Operations: output
++ Related Constructors: OutputForm
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: OutPackage allows pretty-printing from programs.

OutputPackage: with
        output: String -> Void
            ++ output(s) displays the string s on the ``algebra output''
            ++ stream, as defined by \spadsyscom{set output algebra}.
        output: OutputForm -> Void
            ++ output(x) displays the output form x on the
            ++ ``algebra output'' stream, as defined by
            ++ \spadsyscom{set output algebra}.
        output: (String, OutputForm) -> Void
            ++ output(s,x) displays the string s followed by the form x
            ++ on the ``algebra output'' stream, as defined by
            ++ \spadsyscom{set output algebra}.
        outputList: (List Any) -> Void
            ++ outputList(l) displays the concatenated components of the
            ++ list l on the ``algebra output'' stream, as defined by
            ++ \spadsyscom{set output algebra}; quotes are stripped
	    ++ from strings.

    == add
        --ExpressionPackage()
        E      ==> OutputForm
        putout ==> mathprint$Lisp

        s: String
        e: OutputForm
        l: List Any

        output e ==
            mathprint(e)$Lisp
            void()
        output s ==
            output(s:E)
        output(s,e) ==
            output blankSeparate [s:E, e]
        outputList(l) ==                                -- MGR
	  output hconcat
	    [if retractable?(x)$AnyFunctions1(String) then
                message(retract(x)$AnyFunctions1(String))$OutputForm
              else
                x::OutputForm
             for x in l]

@
<<OUT.dotabb>>=
"OUT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OUT"]
"Package" [color="#FF4488"]
"OUT" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter P}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PMASS PatternMatchAssertions}
\pagehead{PatternMatchAssertions}{PMASS}
\pagepic{ps/v104patternmatchassertions.ps}{PMASS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PMASS PatternMatchAssertions>>=
)abbrev package PMASS PatternMatchAssertions
++ Assertions for pattern-matching
++ Author: Manuel Bronstein
++ Description: Attaching assertions to symbols for pattern matching.
++ Date Created: 21 Mar 1989
++ Date Last Updated: 23 May 1990
++ Keywords: pattern, matching.
PatternMatchAssertions(): Exports == Implementation where
  FE ==> Expression Integer

  Exports ==> with
    assert  : (Symbol, String) -> FE
      ++ assert(x, s) makes the assertion s about x.
    constant: Symbol -> FE
      ++ constant(x) tells the pattern matcher that x should
      ++ match only the symbol 'x and no other quantity.
    optional: Symbol -> FE
      ++ optional(x) tells the pattern matcher that x can match
      ++ an identity (0 in a sum, 1 in a product or exponentiation).;
    multiple: Symbol -> FE
      ++ multiple(x) tells the pattern matcher that x should
      ++ preferably match a multi-term quantity in a sum or product.
      ++ For matching on lists, multiple(x) tells the pattern matcher
      ++ that x should match a list instead of an element of a list.

  Implementation ==> add
    import FunctionSpaceAssertions(Integer, FE)

    constant x   == constant(x::FE)
    multiple x   == multiple(x::FE)
    optional x   == optional(x::FE)
    assert(x, s) == assert(x::FE, s)

@
<<PMASS.dotabb>>=
"PMASS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PMASS"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"PMASS" -> "PID"
"PMASS" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTPM PatternMatchIntegration}
\pagehead{PatternMatchIntegration}{INTPM}
\pagepic{ps/v104patternmatchintegration.ps}{INTPM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTPM PatternMatchIntegration>>=
)abbrev package INTPM PatternMatchIntegration
++ Author: Manuel Bronstein
++ Date Created: 5 May 1992
++ Date Last Updated: 27 September 1995
++ Description:
++ \spadtype{PatternMatchIntegration} provides functions that use
++ the pattern matcher to find some indefinite and definite integrals
++ involving special functions and found in the litterature.
PatternMatchIntegration(R, F): Exports == Implementation where
  R : Join(OrderedSet, RetractableTo Integer, GcdDomain,
           LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  N   ==> NonNegativeInteger
  Z   ==> Integer
  SY  ==> Symbol
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  SUP ==> SparseUnivariatePolynomial F
  PAT ==> Pattern Z
  RES ==> PatternMatchResult(Z, F)
  OFE ==> OrderedCompletion F
  REC ==> Record(which: Z, exponent: F, coeff: F)
  ANS ==> Record(special:F, integrand:F)
  NONE ==> 0
  EI   ==> 1
  ERF  ==> 2
  SI   ==> 3
  CI   ==> 4
  GAM2 ==> 5
  CI0  ==> 6

  Exports ==> with
    splitConstant: (F, SY) -> Record(const:F, nconst:F)
      ++ splitConstant(f, x) returns \spad{[c, g]} such that
      ++ \spad{f = c * g} and \spad{c} does not involve \spad{t}.
    if R has ConvertibleTo Pattern Integer and
       R has PatternMatchable Integer then
         if F has LiouvillianFunctionCategory then
           pmComplexintegrate: (F, SY) -> Union(ANS, "failed")
             ++ pmComplexintegrate(f, x) returns either "failed" or
             ++ \spad{[g,h]} such that
             ++ \spad{integrate(f,x) = g + integrate(h,x)}.
             ++ It only looks for special complex integrals that pmintegrate
             ++ does not return.
           pmintegrate: (F, SY) -> Union(ANS, "failed")
             ++ pmintegrate(f, x) returns either "failed" or \spad{[g,h]} such
             ++ that \spad{integrate(f,x) = g + integrate(h,x)}.
         if F has SpecialFunctionCategory then
           pmintegrate: (F, SY, OFE, OFE) -> Union(F, "failed")
             ++ pmintegrate(f, x = a..b) returns the integral of
             ++ \spad{f(x)dx} from a to b
             ++ if it can be found by the built-in pattern matching rules.

  Implementation ==> add
    import PatternMatch(Z, F, F)
    import ElementaryFunctionSign(R, F)
    import FunctionSpaceAssertions(R, F)
    import TrigonometricManipulations(R, F)
    import FunctionSpaceAttachPredicates(R, F, F)

    mkalist   : RES -> AssociationList(SY, F)

    pm := new()$SY
    pmw := new pm
    pmm := new pm
    pms := new pm
    pmc := new pm
    pma := new pm
    pmb := new pm

    c := optional(pmc::F)
    w := suchThat(optional(pmw::F), empty? variables #1)
    s := suchThat(optional(pms::F), empty? variables #1 and real? #1)
    m := suchThat(optional(pmm::F),
                    (retractIfCan(#1)@Union(Z,"failed") case Z) and #1 >= 0)

    spi := sqrt(pi()$F)

    half := 1::F / 2::F

    mkalist res == construct destruct res

    splitConstant(f, x) ==
      not member?(x, variables f) => [f, 1]
      (retractIfCan(f)@Union(K, "failed")) case K => [1, f]
      (u := isTimes f) case List(F) =>
        cc := nc := 1$F
        for g in u::List(F) repeat
          rec := splitConstant(g, x)
          cc  := cc * rec.const
          nc  := nc * rec.nconst
        [cc, nc]
      (u := isPlus f) case List(F) =>
        rec := splitConstant(first(u::List(F)), x)
        cc  := rec.const
        nc  := rec.nconst
        for g in rest(u::List(F)) repeat
          rec := splitConstant(g, x)
          if rec.nconst = nc then cc := cc + rec.const
          else if rec.nconst = -nc then cc := cc - rec.const
          else return [1, f]
        [cc, nc]
      if (v := isPower f) case Record(val:F, exponent:Z) then
        vv := v::Record(val:F, exponent:Z)
        (vv.exponent ^= 1) =>
          rec := splitConstant(vv.val, x)
          return [rec.const ** vv.exponent, rec.nconst ** vv.exponent]
      error "splitConstant: should not happen"

    if R has ConvertibleTo Pattern Integer and
       R has PatternMatchable Integer then
         if F has LiouvillianFunctionCategory then
           import ElementaryFunctionSign(R, F)

           insqrt     : F -> F
           matchei    : (F, SY) -> REC
           matcherfei : (F, SY, Boolean) -> REC
           matchsici  : (F, SY) -> REC
           matchli    : (F, SY) -> List F
           matchli0   : (F, K, SY) -> List F
           matchdilog : (F, SY) -> List F
           matchdilog0: (F, K, SY, P, F) -> List F
           goodlilog? : (K, P) -> Boolean
           gooddilog? : (K, P, P) -> Boolean

--           goodlilog?(k, p) == is?(k, "log"::SY) and one? minimumDegree(p, k)
           goodlilog?(k, p) == is?(k, "log"::SY) and (minimumDegree(p, k) = 1)

           gooddilog?(k, p, q) ==
--             is?(k, "log"::SY) and one? degree(p, k) and zero? degree(q, k)
             is?(k, "log"::SY) and (degree(p, k) = 1) and zero? degree(q, k)

-- matches the integral to a result of the form d * erf(u) or d * ei(u)
-- returns [case, u, d]
           matcherfei(f, x, comp?) ==
             res0 := new()$RES
             pat := c * exp(pma::F)
             failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               comp? => [NONE, 0,0]
               matchei(f,x)
             l := mkalist res
             da := differentiate(a := l.pma, x)
             d := a * (cc := l.pmc) / da
             zero? differentiate(d, x) => [EI, a, d]
             comp? or (((u := sign a) case Z) and (u::Z) < 0) =>
               d := cc * (sa := insqrt(- a)) / da
               zero? differentiate(d, x) => [ERF, sa, - d * spi]
               [NONE, 0, 0]
             [NONE, 0, 0]

-- matches the integral to a result of the form d * ei(k * log u)
-- returns [case, k * log u, d]
           matchei(f, x) ==
             res0 := new()$RES
             a := pma::F
             pat := c * a**w / log a
             failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               [NONE, 0, 0]
             l := mkalist res
             da := differentiate(a := l.pma, x)
             d := (cc := l.pmc) / da
             zero? differentiate(d, x) => [EI, (1 + l.pmw) * log a, d]
             [NONE, 0, 0]

-- matches the integral to a result of the form d * dilog(u) + int(v),
-- returns [u,d,v] or []
           matchdilog(f, x) ==
             n := numer f
             df := (d := denom f)::F
             for k in select_!(gooddilog?(#1, n, d), variables n)$List(K) repeat
               not empty?(l := matchdilog0(f, k, x, n, df)) => return l
             empty()

-- matches the integral to a result of the form d * dilog(a) + int(v)
-- where k = log(a)
-- returns [a,d,v] or []
           matchdilog0(f, k, x, p, q) ==
             zero?(da := differentiate(a := first argument k, x)) => empty()
             a1 := 1 - a
             d := coefficient(univariate(p, k), 1)::F * a1 / (q * da)
             zero? differentiate(d, x) => [a, d, f - d * da * (k::F) / a1]
             empty()

-- matches the integral to a result of the form d * li(u) + int(v),
-- returns [u,d,v] or []
           matchli(f, x) ==
             d := denom f
             for k in select_!(goodlilog?(#1, d), variables d)$List(K) repeat
               not empty?(l := matchli0(f, k, x)) => return l
             empty()

-- matches the integral to a result of the form d * li(a) + int(v)
-- where k = log(a)
-- returns [a,d,v] or []
           matchli0(f, k, x) ==
             g := (lg := k::F) * f
             zero?(da := differentiate(a := first argument k, x)) => empty()
             zero? differentiate(d := g / da, x) => [a, d, 0]
             ug := univariate(g, k)
             (u:=retractIfCan(ug)@Union(SUP,"failed")) case "failed" => empty()
             degree(p := u::SUP) > 1 => empty()
             zero? differentiate(d := coefficient(p, 0) / da, x) =>
               [a, d, leadingCoefficient p]
             empty()

-- matches the integral to a result of the form d * Si(u) or d * Ci(u)
-- returns [case, u, d]
           matchsici(f, x) ==
             res0 := new()$RES
             b := pmb::F
             t := tan(a := pma::F)
             patsi := c * t / (patden := b + b * t**2)
             patci := (c - c * t**2) / patden
             patci0 := c / patden
             ci0?:Boolean
             (ci? := failed?(res := patternMatch(f, convert(patsi)@PAT, res0)))
               and (ci0?:=failed?(res:=patternMatch(f,convert(patci)@PAT,res0)))
                 and failed?(res := patternMatch(f,convert(patci0)@PAT,res0)) =>
                   [NONE, 0, 0]
             l := mkalist res
             (b := l.pmb) ^= 2 * (a := l.pma) => [NONE, 0, 0]
             db := differentiate(b, x)
             d := (cc := l.pmc) / db
             zero? differentiate(d, x) =>
               ci? =>
                  ci0? => [CI0, b, d / (2::F)]
                  [CI, b, d]
               [SI, b, d / (2::F)]
             [NONE, 0, 0]

-- returns a simplified sqrt(y)
           insqrt y ==
             rec := froot(y, 2)$PolynomialRoots(IndexedExponents K, K, R, P, F)
--             one?(rec.exponent) => rec.coef * rec.radicand
             ((rec.exponent) = 1) => rec.coef * rec.radicand
             rec.exponent ^=2 => error "insqrt: hould not happen"
             rec.coef * sqrt(rec.radicand)

           pmintegrate(f, x) ==
             (rc := splitConstant(f, x)).const ^= 1 =>
               (u := pmintegrate(rc.nconst, x)) case "failed" => "failed"
               rec := u::ANS
               [rc.const * rec.special, rc.const * rec.integrand]
             not empty?(l := matchli(f, x)) => [second l * li first l, third l]
             not empty?(l := matchdilog(f, x)) =>
                                            [second l * dilog first l, third l]
             cse := (rec := matcherfei(f, x, false)).which
             cse = EI   => [rec.coeff * Ei(rec.exponent), 0]
             cse = ERF  => [rec.coeff * erf(rec.exponent), 0]
             cse := (rec := matchsici(f, x)).which
             cse = SI => [rec.coeff * Si(rec.exponent), 0]
             cse = CI => [rec.coeff * Ci(rec.exponent), 0]
             cse = CI0 => [rec.coeff * Ci(rec.exponent)
                           + rec.coeff * log(rec.exponent), 0]
             "failed"

           pmComplexintegrate(f, x) ==
             (rc := splitConstant(f, x)).const ^= 1 =>
               (u := pmintegrate(rc.nconst, x)) case "failed" => "failed"
               rec := u::ANS
               [rc.const * rec.special, rc.const * rec.integrand]
             cse := (rec := matcherfei(f, x, true)).which
             cse = ERF  => [rec.coeff * erf(rec.exponent), 0]
             "failed"

         if F has SpecialFunctionCategory then
           match1    : (F, SY, F, F) -> List F
           formula1  : (F, SY, F, F) -> Union(F, "failed")

-- tries only formula (1) of the Geddes & al, AAECC 1 (1990) paper
           formula1(f, x, t, cc) ==
             empty?(l := match1(f, x, t, cc)) => "failed"
             mw := first l
             zero?(ms := third l) or ((sgs := sign ms) case "failed")=> "failed"
             ((sgz := sign(z := (mw + 1) / ms)) case "failed") or (sgz::Z < 0)
                => "failed"
             mmi := retract(mm := second l)@Z
             sgs * (last l) * ms**(- mmi - 1) *
                 eval(differentiate(Gamma(x::F), x, mmi::N), [kernel(x)@K], [z])

-- returns [w, m, s, c] or []
-- matches only formula (1) of the Geddes & al, AAECC 1 (1990) paper
           match1(f, x, t, cc) ==
             res0 := new()$RES
             pat := cc * log(t)**m * exp(-t**s)
             not failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               l := mkalist res
               [0, l.pmm, l.pms, l.pmc]
             pat := cc * t**w * exp(-t**s)
             not failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               l := mkalist res
               [l.pmw, 0, l.pms, l.pmc]
             pat := cc / t**w * exp(-t**s)
             not failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               l := mkalist res
               [- l.pmw, 0, l.pms, l.pmc]
             pat := cc * t**w * log(t)**m * exp(-t**s)
             not failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               l := mkalist res
               [l.pmw, l.pmm, l.pms, l.pmc]
             pat := cc / t**w * log(t)**m * exp(-t**s)
             not failed?(res := patternMatch(f, convert(pat)@PAT, res0)) =>
               l := mkalist res
               [- l.pmw, l.pmm, l.pms, l.pmc]
             empty()

           pmintegrate(f, x, a, b) ==
--             zero? a and one? whatInfinity b =>
             zero? a and ((whatInfinity b) = 1) =>
               formula1(f, x, constant(x::F), suchThat(c, freeOf?(#1, x)))
             "failed"

@
<<INTPM.dotabb>>=
"INTPM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTPM"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"INTPM" -> "ACF"
"INTPM" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PICOERCE PiCoercions}
\pagehead{PiCoercions}{PICOERCE}
\pagepic{ps/v104picoercions.ps}{PICOERCE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PICOERCE PiCoercions>>=
)abbrev package PICOERCE PiCoercions
++ Coercions from %pi to symbolic or numeric domains
++ Author: Manuel Bronstein
++ Description:
++  Provides a coercion from the symbolic fractions in %pi with
++ integer coefficients to any Expression type.
++ Date Created: 21 Feb 1990
++ Date Last Updated: 21 Feb 1990
PiCoercions(R:Join(OrderedSet, IntegralDomain)): with
  coerce: Pi -> Expression R
    ++ coerce(f) returns f as an Expression(R).
 == add
  p2e: SparseUnivariatePolynomial Integer -> Expression R

  coerce(x:Pi):Expression(R) ==
    f := convert(x)@Fraction(SparseUnivariatePolynomial Integer)
    p2e(numer f) / p2e(denom f)

  p2e p ==
    map(#1::Expression(R), p)$SparseUnivariatePolynomialFunctions2(
        Integer, Expression R) (pi()$Expression(R))

@
<<PICOERCE.dotabb>>=
"PICOERCE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PICOERCE"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PICOERCE" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PTFUNC2 PointFunctions2}
\pagehead{PointFunctions2}{PTFUNC2}
\pagepic{ps/v104pointfunctions2.ps}{PTFUNC2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PTFUNC2 PointFunctions2>>=
)abbrev package PTFUNC2 PointFunctions2
++ Description:
++ This package \undocumented 
PointFunctions2(R1:Ring,R2:Ring):Exports == Implementation where
 
  Exports == with
    map : ((R1->R2),Point(R1)) -> Point(R2)
	++ map(f,p) \undocumented
 
  Implementation ==> add
    import Point(R1)
    import Point(R2)
 
    map(mapping,p) ==
      point([mapping p.(i::PositiveInteger) for i in minIndex(p)..maxIndex(p)])$Point(R2)

@
<<PTFUNC2.dotabb>>=
"PTFUNC2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PTFUNC2"]
"PID" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PID"]
"OAGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OAGROUP"]
"PTFUNC2" -> "PID"
"PTFUNC2" -> "OAGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PTPACK PointPackage}
\pagehead{PointPackage}{PTPACK}
\pagepic{ps/v104pointpackage.ps}{PTPACK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PTPACK PointPackage>>=
)abbrev package PTPACK PointPackage
++ Description:
++ This package \undocumented
PointPackage(R:Ring):Exports == Implementation where
 
  POINT ==> Point(R)
  I    ==> Integer
  PI   ==> PositiveInteger
  NNI  ==> NonNegativeInteger
  L    ==> List
  B    ==> Boolean
 
  Exports == with
    xCoord       : POINT -> R
      ++ xCoord(pt) returns the first element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a Cartesian
      ++ coordinate system.
    yCoord       : POINT -> R
      ++ yCoord(pt) returns the second element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a Cartesian
      ++ coordinate system.
    zCoord       : POINT -> R
      ++ zCoord(pt) returns the third element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a Cartesian
      ++ or a cylindrical coordinate system.
    rCoord       : POINT -> R
      ++ rCoord(pt) returns the first element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a spherical
      ++ or a cylindrical coordinate system.
    thetaCoord   : POINT -> R
      ++ thetaCoord(pt) returns the second element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a spherical
      ++ or a cylindrical coordinate system.
    phiCoord     : POINT -> R
      ++ phiCoord(pt) returns the third element of the point, pt,
      ++ although no assumptions are made as to the coordinate
      ++ system being used.  This function is defined for the
      ++ convenience of the user dealing with a spherical
      ++ coordinate system.
    color        : POINT -> R
      ++ color(pt) returns the fourth element of the point, pt, 
      ++ although no assumptions are made with regards as to
      ++ how the components of higher dimensional points are
      ++ interpreted.  This function is defined for the
      ++ convenience of the user using specifically, color
      ++ to express a fourth dimension.
    hue : POINT -> R
      ++ hue(pt) returns the third element of the two dimensional point, pt,
      ++ although no assumptions are made with regards as to how the 
      ++ components of higher dimensional points are interpreted. This 
      ++ function is defined for the convenience of the user using 
      ++ specifically, hue to express a third dimension.
    shade : POINT -> R
      ++ shade(pt) returns the fourth element of the two dimensional 
      ++ point, pt, although no assumptions are made with regards as to 
      ++ how the components of higher dimensional points are interpreted.
      ++ This function is defined for the convenience of the user using 
      ++ specifically, shade to express a fourth dimension.
 
      -- 2D and 3D extraction of data
  Implementation ==> add
 
    xCoord p == elt(p,1)
    yCoord p == elt(p,2)
    zCoord p == elt(p,3)
    rCoord p == elt(p,1)
    thetaCoord p == elt(p,2)
    phiCoord p == elt(p,3)
    color p == 
      #p > 3 => p.4
      p.3
    hue p == elt(p,3)       -- 4D points in 2D using extra dimensions for palette information
    shade p == elt(p,4)     -- 4D points in 2D using extra dimensions for palette information

@
<<PTPACK.dotabb>>=
"PTPACK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PTPACK"]
"PTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PTCAT"]
"PTPACK" -> "PTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PAN2EXPR PolynomialAN2Expression}
\pagehead{PolynomialAN2Expression}{PAN2EXPR}
\pagepic{ps/v104polynomialan2expression.ps}{PAN2EXPR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PAN2EXPR PolynomialAN2Expression>>=
)abbrev package PAN2EXPR PolynomialAN2Expression
++ Author: Barry Trager
++ Date Created: 8 Oct 1991
++ Description: This package provides a coerce from polynomials over
++ algebraic numbers to \spadtype{Expression AlgebraicNumber}.
PolynomialAN2Expression():Target == Implementation where
  EXPR ==> Expression(Integer)
  AN ==> AlgebraicNumber
  PAN ==> Polynomial AN
  SY ==> Symbol
  Target ==> with
      coerce: Polynomial AlgebraicNumber -> Expression(Integer)
        ++ coerce(p) converts the polynomial \spad{p} with algebraic number
        ++ coefficients to \spadtype{Expression Integer}.
      coerce: Fraction Polynomial AlgebraicNumber -> Expression(Integer)
        ++ coerce(rf) converts \spad{rf}, a fraction of polynomial 
        ++ \spad{p} with
        ++ algebraic number coefficients to \spadtype{Expression Integer}.
  Implementation ==> add
    coerce(p:PAN):EXPR ==
        map(#1::EXPR, #1::EXPR, p)$PolynomialCategoryLifting(
                                  IndexedExponents SY, SY, AN, PAN, EXPR)
    coerce(rf:Fraction PAN):EXPR ==
        numer(rf)::EXPR / denom(rf)::EXPR

@
<<PAN2EXPR.dotabb>>=
"PAN2EXPR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PAN2EXPR"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"PAN2EXPR" -> "ACF"
"PAN2EXPR" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package POLY2 PolynomialFunctions2}
\pagehead{PolynomialFunctions2}{POLY2}
\pagepic{ps/v104polynomialfunctions2.ps}{POLY2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package POLY2 PolynomialFunctions2>>=
)abbrev package POLY2 PolynomialFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This package takes a mapping between coefficient rings, and lifts
++ it to a mapping between polynomials over those rings.

PolynomialFunctions2(R:Ring, S:Ring): with
  map: (R -> S, Polynomial R) -> Polynomial S
    ++ map(f, p) produces a new polynomial as a result of applying
    ++ the function f to every coefficient of the polynomial p.
 == add
  map(f, p) == map(#1::Polynomial(S), f(#1)::Polynomial(S),
                   p)$PolynomialCategoryLifting(IndexedExponents Symbol,
                                   Symbol, R, Polynomial R, Polynomial S)


@
<<POLY2.dotabb>>=
"POLY2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=POLY2"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"POLY2" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PNTHEORY PolynomialNumberTheoryFunctions}
\pagehead{PolynomialNumberTheoryFunctions}{PNTHEORY}
\pagepic{ps/v104polynomialnumbertheoryfunctions.ps}{PNTHEORY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PNTHEORY PolynomialNumberTheoryFunctions>>=
)abbrev package PNTHEORY PolynomialNumberTheoryFunctions
++ Author: Michael Monagan, Clifton J. Williamson
++ Date Created: June 1987
++ Date Last Updated: 10 November 1996 (Claude Quitte)
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: polynomial, number theory
++ Examples:
++ References: Knuth, The Art of Computer Programming Vol.2
++ Description:
++ This package provides various polynomial number theoretic functions
++ over the integers.
PolynomialNumberTheoryFunctions(): Exports == Implementation where
 I ==> Integer
 RN ==> Fraction I
 SUP ==> SparseUnivariatePolynomial
 NNI ==> NonNegativeInteger

 Exports ==> with
  bernoulli : I -> SUP RN
    ++ bernoulli(n) returns the nth Bernoulli polynomial \spad{B[n](x)}.
    ++ Note: Bernoulli polynomials denoted \spad{B(n,x)} computed by solving the
    ++ differential equation  \spad{differentiate(B(n,x),x) = n B(n-1,x)} where
    ++ \spad{B(0,x) = 1} and initial condition comes from \spad{B(n) = B(n,0)}.
  chebyshevT: I -> SUP I
    ++ chebyshevT(n) returns the nth Chebyshev polynomial \spad{T[n](x)}.
    ++ Note: Chebyshev polynomials of the first kind, denoted \spad{T[n](x)},
    ++ computed from the two term recurrence.  The generating function
    ++ \spad{(1-t*x)/(1-2*t*x+t**2) = sum(T[n](x)*t**n, n=0..infinity)}.
  chebyshevU: I -> SUP I
    ++ chebyshevU(n) returns the nth Chebyshev polynomial \spad{U[n](x)}.
    ++ Note: Chebyshev polynomials of the second kind, denoted \spad{U[n](x)},
    ++ computed from the two term recurrence.  The generating function
    ++ \spad{1/(1-2*t*x+t**2) = sum(T[n](x)*t**n, n=0..infinity)}.
  cyclotomic: I -> SUP I
    ++ cyclotomic(n) returns the nth cyclotomic polynomial \spad{phi[n](x)}.
    ++ Note: \spad{phi[n](x)} is the factor of \spad{x**n - 1} whose roots
    ++ are the primitive nth roots of unity.
  euler     : I -> SUP RN
    ++ euler(n) returns the nth Euler polynomial \spad{E[n](x)}.
    ++ Note: Euler polynomials denoted \spad{E(n,x)} computed by solving the
    ++ differential equation  \spad{differentiate(E(n,x),x) = n E(n-1,x)} where
    ++ \spad{E(0,x) = 1} and initial condition comes from \spad{E(n) = 2**n E(n,1/2)}.
  fixedDivisor: SUP I -> I
    ++ fixedDivisor(a) for \spad{a(x)} in \spad{Z[x]} is the largest integer
    ++ f such that f divides \spad{a(x=k)} for all integers k.
    ++ Note: fixed divisor of \spad{a} is
    ++ \spad{reduce(gcd,[a(x=k) for k in 0..degree(a)])}.
  hermite   : I -> SUP I
    ++ hermite(n) returns the nth Hermite polynomial \spad{H[n](x)}.
    ++ Note: Hermite polynomials, denoted \spad{H[n](x)}, are computed from
    ++ the two term recurrence.  The generating function is:
    ++ \spad{exp(2*t*x-t**2) = sum(H[n](x)*t**n/n!, n=0..infinity)}.
  laguerre  : I -> SUP I
    ++ laguerre(n) returns the nth Laguerre polynomial \spad{L[n](x)}.
    ++ Note: Laguerre polynomials, denoted \spad{L[n](x)}, are computed from
    ++ the two term recurrence.  The generating function is:
    ++ \spad{exp(x*t/(t-1))/(1-t) = sum(L[n](x)*t**n/n!, n=0..infinity)}.
  legendre  : I -> SUP RN
    ++ legendre(n) returns the nth Legendre polynomial \spad{P[n](x)}.
    ++ Note: Legendre polynomials, denoted \spad{P[n](x)}, are computed from
    ++ the two term recurrence.  The generating function is:
    ++ \spad{1/sqrt(1-2*t*x+t**2) = sum(P[n](x)*t**n, n=0..infinity)}.
 Implementation ==> add
  import IntegerPrimesPackage(I)

  x := monomial(1,1)$SUP(I)
  y := monomial(1,1)$SUP(RN)

  -- For functions computed via a fixed term recurrence we record
  -- previous values so that the next value can be computed directly

  E : Record(En:I, Ev:SUP(RN)) := [0,1]
  B : Record( Bn:I, Bv:SUP(RN) ) := [0,1]
  H : Record( Hn:I, H1:SUP(I), H2:SUP(I) ) := [0,1,x]
  L : Record( Ln:I, L1:SUP(I), L2:SUP(I) ) := [0,1,x]
  P : Record( Pn:I, P1:SUP(RN), P2:SUP(RN) ) := [0,1,y]
  CT : Record( Tn:I, T1:SUP(I), T2:SUP(I) ) := [0,1,x]
  U : Record( Un:I, U1:SUP(I), U2:SUP(I) ) := [0,1,0]

  MonicQuotient: (SUP(I),SUP(I)) -> SUP(I)
  MonicQuotient (a,b) ==
    leadingCoefficient(b) ^= 1 => error "divisor must be monic"
    b = 1 => a
    da := degree a
    db := degree b            -- assertion: degree b > 0
    q:SUP(I) := 0
    while da >= db repeat
      t := monomial(leadingCoefficient a, (da-db)::NNI)
      a := a - b * t
      q := q + t
      da := degree a
    q

  cyclotomic n ==
    --++ cyclotomic polynomial denoted phi[n](x)
    p:I; q:I; r:I; s:I; m:NNI; c:SUP(I); t:SUP(I)
    n < 0 => error "cyclotomic not defined for negative integers"
    n = 0 => x
    k := n; s := p := 1
    c := x - 1
    while k > 1 repeat
      p := nextPrime p
      (q,r) := divide(k, p)
      if r = 0 then
        while r = 0 repeat (k := q; (q,r) := divide(k,p))
        t := multiplyExponents(c,p::NNI)
        c := MonicQuotient(t,c)
        s := s * p
    m := (n quo s) :: NNI
    multiplyExponents(c,m)

  euler n ==
    p : SUP(RN); t : SUP(RN); c : RN; s : I
    n < 0 => error "euler not defined for negative integers"
    if n < E.En then (s,p) := (0$I,1$SUP(RN)) else (s,p) := E
    -- (s,p) := if n < E.En then (0,1) else E
    for i in s+1 .. n repeat
      t := (i::RN) * integrate p
      c := euler(i)$IntegerNumberTheoryFunctions / 2**(i::NNI) - t(1/2)
      p := t + c::SUP(RN)
    E.En := n
    E.Ev := p
    p

  bernoulli n ==
    p : SUP RN; t : SUP RN; c : RN; s : I
    n < 0 => error "bernoulli not defined for negative integers"
    if n < B.Bn then (s,p) := (0$I,1$SUP(RN)) else (s,p) := B
    -- (s,p) := if n < B.Bn then (0,1) else B
    for i in s+1 .. n repeat
      t := (i::RN) * integrate p
      c := bernoulli(i)$IntegerNumberTheoryFunctions
      p := t + c::SUP(RN)
    B.Bn := n
    B.Bv := p
    p

  fixedDivisor a ==
    g:I; d:NNI; SUP(I)
    d := degree a
    g := coefficient(a, minimumDegree a)
    for k in 1..d while g > 1 repeat g := gcd(g,a k)
    g

  hermite n ==
    s : I; p : SUP(I); q : SUP(I)
    n < 0 => error "hermite not defined for negative integers"
    -- (s,p,q) := if n < H.Hn then (0,1,x) else H
    if n < H.Hn then (s := 0; p := 1; q := x) else (s,p,q) := H
    for k in s+1 .. n repeat (p,q) := (2*x*p-2*(k-1)*q,p)
    H.Hn := n
    H.H1 := p
    H.H2 := q
    p

  legendre n ==
    s:I; t:I; p:SUP(RN); q:SUP(RN)
    n < 0 => error "legendre not defined for negative integers"
    -- (s,p,q) := if n < P.Pn then (0,1,y) else P
    if n < P.Pn then (s := 0; p := 1; q := y) else (s,p,q) := P
    for k in s+1 .. n repeat
      t := k-1
      (p,q) := ((k+t)$I/k*y*p - t/k*q,p)
    P.Pn := n
    P.P1 := p
    P.P2 := q
    p

  laguerre n ==
    k:I; s:I; t:I; p:SUP(I); q:SUP(I)
    n < 0 => error "laguerre not defined for negative integers"
    -- (s,p,q) := if n < L.Ln then (0,1,x) else L
    if n < L.Ln then (s := 0; p := 1; q := x) else (s,p,q) := L
    for k in s+1 .. n repeat
      t := k-1
      (p,q) := ((((k+t)$I)::SUP(I)-x)*p-t**2*q,p)
    L.Ln := n
    L.L1 := p
    L.L2 := q
    p

  chebyshevT n ==
    s : I; p : SUP(I); q : SUP(I)
    n < 0 => error "chebyshevT not defined for negative integers"
    -- (s,p,q) := if n < CT.Tn then (0,1,x) else CT
    if n < CT.Tn then (s := 0; p := 1; q := x) else (s,p,q) := CT
    for k in s+1 .. n repeat (p,q) := ((2*x*p - q),p)
    CT.Tn := n
    CT.T1 := p
    CT.T2 := q
    p

  chebyshevU n ==
    s : I; p : SUP(I); q : SUP(I)
    n < 0 => error "chebyshevU not defined for negative integers"
    if n < U.Un then (s := 0; p := 1; q := 0) else (s,p,q) := U
    for k in s+1 .. n repeat (p,q) := ((2*x*p - q),p)
    U.Un := n
    U.U1 := p
    U.U2 := q
    p

@
<<PNTHEORY.dotabb>>=
"PNTHEORY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PNTHEORY"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"PNTHEORY" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package POLYROOT PolynomialRoots}
\pagehead{PolynomialRoots}{POLYROOT}
\pagepic{ps/v104polynomialroots.ps}{POLYROOT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package POLYROOT PolynomialRoots>>=
)abbrev package POLYROOT PolynomialRoots
++ Author: Manuel Bronstein
++ Date Created: 15 July 1988
++ Date Last Updated: 10 November 1993
++ Description: computes n-th roots of quotients of
++ multivariate polynomials
-- not visible to the user
PolynomialRoots(E, V, R, P, F):Exports == Implementation where
  E: OrderedAbelianMonoidSup
  V: OrderedSet
  R: IntegralDomain
  P: PolynomialCategory(R, E, V)
  F: Field with
    numer : $ -> P
	++ numer(x) \undocumented
    denom : $ -> P
	++ denom(x) \undocumented
    coerce: P -> $
	++ coerce(p) \undocumented

  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Z
  REC ==> Record(exponent:N, coef:F, radicand:F)

  Exports ==> with
    rroot: (R, N) -> REC
      ++ rroot(f, n) returns \spad{[m,c,r]} such
      ++ that \spad{f**(1/n) = c * r**(1/m)}.
    qroot : (Q, N) -> REC
      ++ qroot(f, n) returns \spad{[m,c,r]} such
      ++ that \spad{f**(1/n) = c * r**(1/m)}.
    if R has GcdDomain then froot: (F, N) -> REC
      ++ froot(f, n) returns \spad{[m,c,r]} such
      ++ that \spad{f**(1/n) = c * r**(1/m)}.
    nthr: (P, N) -> Record(exponent:N,coef:P,radicand:List P)
	++ nthr(p,n) should be local but conditional

  Implementation ==> add
    import FactoredFunctions Z
    import FactoredFunctions P

    rsplit: List P -> Record(coef:R, poly:P)
    zroot : (Z, N) -> Record(exponent:N, coef:Z, radicand:Z)

    zroot(x, n) ==
--      zero? x or one? x => [1, x, 1]
      zero? x or (x = 1) => [1, x, 1]
      s := nthRoot(squareFree x, n)
      [s.exponent, s.coef, */s.radicand]

    if R has imaginary: () -> R then
      czroot: (Z, N) -> REC

      czroot(x, n) ==
        rec := zroot(x, n)
        rec.exponent = 2 and rec.radicand < 0 =>
          [rec.exponent, rec.coef * imaginary()::P::F, (-rec.radicand)::F]
        [rec.exponent, rec.coef::F, rec.radicand::F]

      qroot(x, n) ==
        sn := czroot(numer x, n)
        sd := czroot(denom x, n)
        m  := lcm(sn.exponent, sd.exponent)::N
        [m, sn.coef / sd.coef,
                    (sn.radicand ** (m quo sn.exponent)) /
                                (sd.radicand ** (m quo sd.exponent))]
    else
      qroot(x, n) ==
        sn := zroot(numer x, n)
        sd := zroot(denom x, n)
        m  := lcm(sn.exponent, sd.exponent)::N
        [m, sn.coef::F / sd.coef::F,
                    (sn.radicand ** (m quo sn.exponent))::F /
                                (sd.radicand ** (m quo sd.exponent))::F]

    if R has RetractableTo Fraction Z then
      rroot(x, n) ==
        (r := retractIfCan(x)@Union(Fraction Z,"failed")) case "failed"
          => [n, 1, x::P::F]
        qroot(r::Q, n)

    else
      if R has RetractableTo Z then
        rroot(x, n) ==
          (r := retractIfCan(x)@Union(Z,"failed")) case "failed"
            => [n, 1, x::P::F]
          qroot(r::Z::Q, n)
      else
        rroot(x, n) == [n, 1, x::P::F]

    rsplit l ==
      r := 1$R
      p := 1$P
      for q in l repeat
        if (u := retractIfCan(q)@Union(R, "failed")) case "failed"
          then p := p * q
          else r := r * u::R
      [r, p]

    if R has GcdDomain then
      if R has RetractableTo Z then
        nthr(x, n) ==
          (r := retractIfCan(x)@Union(Z,"failed")) case "failed"
             => nthRoot(squareFree x, n)
          rec := zroot(r::Z, n)
          [rec.exponent, rec.coef::P, [rec.radicand::P]]
      else nthr(x, n) == nthRoot(squareFree x, n)

      froot(x, n) ==
--        zero? x or one? x => [1, x, 1]
        zero? x or (x = 1) => [1, x, 1]
        sn := nthr(numer x, n)
        sd := nthr(denom x, n)
        pn := rsplit(sn.radicand)
        pd := rsplit(sd.radicand)
        rn := rroot(pn.coef, sn.exponent)
        rd := rroot(pd.coef, sd.exponent)
        m := lcm([rn.exponent, rd.exponent, sn.exponent, sd.exponent])::N
        [m, (sn.coef::F / sd.coef::F) * (rn.coef / rd.coef),
             ((rn.radicand ** (m quo rn.exponent)) /
                    (rd.radicand ** (m quo rd.exponent))) *
                           (pn.poly ** (m quo sn.exponent))::F /
                                    (pd.poly ** (m quo sd.exponent))::F]


@
<<POLYROOT.dotabb>>=
"POLYROOT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=POLYROOT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"POLYROOT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package LIMITPS PowerSeriesLimitPackage}
\pagehead{PowerSeriesLimitPackage}{LIMITPS}
\pagepic{ps/v104powerserieslimitpackage.ps}{LIMITPS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package LIMITPS PowerSeriesLimitPackage>>=
)abbrev package LIMITPS PowerSeriesLimitPackage
++ Author: Clifton J. Williamson
++ Date Created: 21 March 1989
++ Date Last Updated: 30 March 1994
++ Basic Operations:
++ Related Domains: UnivariateLaurentSeries(FE,x,a),
++   UnivariatePuiseuxSeries(FE,x,a),ExponentialExpansion(R,FE,x,a)
++ Also See:
++ AMS Classifications:
++ Keywords: limit, functional expression, power series
++ Examples:
++ References:
++ Description:
++   PowerSeriesLimitPackage implements limits of expressions
++   in one or more variables as one of the variables approaches a
++   limiting value.  Included are two-sided limits, left- and right-
++   hand limits, and limits at plus or minus infinity.
PowerSeriesLimitPackage(R,FE): Exports == Implementation where
  R  : Join(GcdDomain,OrderedSet,RetractableTo Integer,_
            LinearlyExplicitRingOver Integer)
  FE : Join(AlgebraicallyClosedField,TranscendentalFunctionCategory,_
            FunctionSpace R)
  Z       ==> Integer
  RN      ==> Fraction Integer
  RF      ==> Fraction Polynomial R
  OFE     ==> OrderedCompletion FE
  OPF     ==> OnePointCompletion FE
  SY      ==> Symbol
  EQ      ==> Equation
  LF      ==> LiouvillianFunction
  UTS     ==> UnivariateTaylorSeries
  ULS     ==> UnivariateLaurentSeries
  UPXS    ==> UnivariatePuiseuxSeries
  EFULS   ==> ElementaryFunctionsUnivariateLaurentSeries
  EFUPXS  ==> ElementaryFunctionsUnivariatePuiseuxSeries
  FS2UPS  ==> FunctionSpaceToUnivariatePowerSeries
  FS2EXPXP ==> FunctionSpaceToExponentialExpansion
  Problem ==> Record(func:String,prob:String)
  RESULT  ==> Union(OFE,"failed")
  TwoSide ==> Record(leftHandLimit:RESULT,rightHandLimit:RESULT)
  U       ==> Union(OFE,TwoSide,"failed")
  SIGNEF  ==> ElementaryFunctionSign(R,FE)

  Exports ==> with

    limit: (FE,EQ OFE) -> U
      ++ limit(f(x),x = a) computes the real limit \spad{lim(x -> a,f(x))}.

    complexLimit: (FE,EQ OPF) -> Union(OPF, "failed")
      ++ complexLimit(f(x),x = a) computes the complex limit
      ++ \spad{lim(x -> a,f(x))}.

    limit: (FE,EQ FE,String) -> RESULT
      ++ limit(f(x),x=a,"left") computes the left hand real limit
      ++ \spad{lim(x -> a-,f(x))};
      ++ \spad{limit(f(x),x=a,"right")} computes the right hand real limit
      ++ \spad{lim(x -> a+,f(x))}.

  Implementation ==> add
    import ToolsForSign(R)
    import ElementaryFunctionStructurePackage(R,FE)

    zeroFE:FE := 0
    anyRootsOrAtrigs?   : FE -> Boolean
    complLimit  : (FE,SY) -> Union(OPF,"failed")
    okProblem?  : (String,String) -> Boolean
    realLimit   : (FE,SY) -> U
    xxpLimit    : (FE,SY) -> RESULT
    limitPlus   : (FE,SY) -> RESULT
    localsubst  : (FE,Kernel FE,Z,FE) -> FE
    locallimit  : (FE,SY,OFE) -> U
    locallimitcomplex : (FE,SY,OPF) -> Union(OPF,"failed")
    poleLimit:(RN,FE,SY) -> U
    poleLimitPlus:(RN,FE,SY) -> RESULT

    noX?: (FE,SY) -> Boolean
    noX?(fcn,x) == not member?(x,variables fcn)

    constant?: FE -> Boolean
    constant? fcn == empty? variables fcn

    firstNonLogPtr: (FE,SY) -> List Kernel FE
    firstNonLogPtr(fcn,x) ==
      -- returns a pointer to the first element of kernels(fcn) which
      -- has 'x' as a variable, which is not a logarithm, and which is
      -- not simply 'x'
      list := kernels fcn
      while not empty? list repeat
        ker := first list
        not is?(ker,"log" :: Symbol) and member?(x,variables(ker::FE)) _
               and not(x = name(ker)) =>
          return list
        list := rest list
      empty()

    finiteValueAtInfinity?: Kernel FE -> Boolean
    finiteValueAtInfinity? ker ==
      is?(ker,"erf" :: Symbol) => true
      is?(ker,"sech" :: Symbol) => true
      is?(ker,"csch" :: Symbol) => true
      is?(ker,"tanh" :: Symbol) => true
      is?(ker,"coth" :: Symbol) => true
      is?(ker,"atan" :: Symbol) => true
      is?(ker,"acot" :: Symbol) => true
      is?(ker,"asec" :: Symbol) => true
      is?(ker,"acsc" :: Symbol) => true
      is?(ker,"acsch" :: Symbol) => true
      is?(ker,"acoth" :: Symbol) => true
      false

    knownValueAtInfinity?: Kernel FE -> Boolean
    knownValueAtInfinity? ker ==
      is?(ker,"exp" :: Symbol) => true
      is?(ker,"sinh" :: Symbol) => true
      is?(ker,"cosh" :: Symbol) => true
      false

    leftOrRight: (FE,SY,FE) -> SingleInteger
    leftOrRight(fcn,x,limVal) ==
      -- function is called when limitPlus(fcn,x) = limVal
      -- determines whether the limiting value is approached
      -- from the left or from the right
      (value := limitPlus(inv(fcn - limVal),x)) case "failed" => 0
      (inf := whatInfinity(val := value :: OFE)) = 0 =>
         error "limit package: internal error"
      inf

    specialLimit1: (FE,SY) -> RESULT
    specialLimitKernel: (Kernel FE,SY) -> RESULT
    specialLimitNormalize: (FE,SY) -> RESULT
    specialLimit: (FE, SY) -> RESULT

    specialLimit(fcn, x) ==
      xkers := [k for k in kernels fcn | member?(x,variables(k::FE))]
      #xkers = 1 => specialLimit1(fcn,x)
      num := numerator fcn
      den := denominator fcn
      for k in xkers repeat
        (fval := limitPlus(k::FE,x)) case "failed" =>
            return specialLimitNormalize(fcn,x)
        whatInfinity(val := fval::OFE) ^= 0 =>
            return specialLimitNormalize(fcn,x)
        (valu := retractIfCan(val)@Union(FE,"failed")) case "failed" =>
            return specialLimitNormalize(fcn,x)
        finVal := valu :: FE
        num := eval(num, k, finVal)
        den := eval(den, k, finVal)
        den = 0 => return specialLimitNormalize(fcn,x)
      (num/den) :: OFE :: RESULT

    specialLimitNormalize(fcn,x) == -- tries to normalize result first
      nfcn := normalize(fcn)
      fcn ^= nfcn => limitPlus(nfcn,x)
      xkers := [k for k in tower fcn | member?(x,variables(k::FE))]
      # xkers ^= 2 => "failed"
      expKers := [k for k in xkers | is?(k, "exp" :: Symbol)]
      # expKers ^= 1 => "failed"
    -- fcn is a rational function of x and exp(g(x)) for some rational function g
      expKer := first expKers
      (fval := limitPlus(expKer::FE,x)) case "failed" => "failed"
      vv := new()$SY; eq : EQ FE := equation(expKer :: FE,vv :: FE)
      cc := eval(fcn,eq)
      expKerLim := fval :: OFE
        -- following test for "failed" is needed due to compiler bug
        -- limVal case OFE generates EQCAR(limVal, 1) which fails on atom "failed"
      (limVal := locallimit(cc,vv,expKerLim)) case "failed" => "failed"
      limVal case OFE =>
         limm := limVal :: OFE
         (lim := retractIfCan(limm)@Union(FE,"failed")) case "failed" =>
               "failed" -- need special handling for directions at infinity
         limitPlus(lim, x)
      "failed"

    -- limit of expression having only 1 kernel involving x
    specialLimit1(fcn,x) ==
      -- find the first interesting kernel in tower(fcn)
      xkers := [k for k in kernels fcn | member?(x,variables(k::FE))]
      #xkers ^= 1 => "failed"
      ker := first xkers
      vv := new()$SY; eq : EQ FE := equation(ker :: FE,vv :: FE)
      cc := eval(fcn,eq)
      member?(x,variables cc) => "failed"
      (lim := specialLimitKernel(ker, x)) case "failed" => lim
      argLim : OFE := lim :: OFE
      (limVal := locallimit(cc,vv,argLim)) case "failed" => "failed"
      limVal case OFE => limVal :: OFE
      "failed"

    -- limit of single kernel involving x
    specialLimitKernel(ker,x) ==
      is?(ker,"log" :: Symbol) =>
          args := argument ker
          empty? args => "failed" -- error "No argument"
          not empty? rest args => "failed" -- error "Too many arugments"
          arg := first args
          -- compute limit(x -> 0+,arg)
          (limm := limitPlus(arg,x)) case "failed" => "failed"
          lim := limm :: OFE
          (inf := whatInfinity lim) = -1 => "failed"
          argLim : OFE :=
            -- log(+infinity) = +infinity
            inf = 1 => lim
            -- now 'lim' must be finite
            (li := retractIfCan(lim)@Union(FE,"failed") :: FE) = 0 =>
              -- log(0) = -infinity
              leftOrRight(arg,x,0) = 1 => minusInfinity()
              return "failed"
            log(li) :: OFE
      -- kernel should be a function of one argument f(arg)
      args := argument(ker)
      empty? args => "failed"  -- error "No argument"
      not empty? rest args => "failed" -- error "Too many arugments"
      arg := first args
      -- compute limit(x -> 0+,arg)
      (limm := limitPlus(arg,x)) case "failed" => "failed"
      lim := limm :: OFE
      f := elt(operator ker,(var := new()$SY) :: FE)
      -- compute limit(x -> 0+,f(arg))
      -- case where 'lim' is finite
      (inf := whatInfinity lim) = 0 =>
         is?(ker,"erf" :: Symbol) => erf(retract(lim)@FE)$LF(R,FE) :: OFE
         (kerValue := locallimit(f,var,lim)) case "failed" => "failed"
         kerValue case OFE => kerValue :: OFE
         "failed"
      -- case where 'lim' is plus infinity
      inf = 1 =>
        finiteValueAtInfinity? ker =>
          val : FE :=
            is?(ker,"erf" :: Symbol) => 1
            is?(ker,"sech" :: Symbol) => 0
            is?(ker,"csch" :: Symbol) => 0
            is?(ker,"tanh" :: Symbol) => 0
            is?(ker,"coth" :: Symbol) => 0
            is?(ker,"atan" :: Symbol) => pi()/(2 :: FE)
            is?(ker,"acot" :: Symbol) => 0
            is?(ker,"asec" :: Symbol) => pi()/(2 :: FE)
            is?(ker,"acsc" :: Symbol) => 0
            is?(ker,"acsch" :: Symbol) => 0
            -- ker must be acoth
            0
          val :: OFE
        knownValueAtInfinity? ker =>
          lim -- limit(exp, cosh, sinh ,x=inf) = inf
        "failed"
      -- case where 'lim' is minus infinity
      finiteValueAtInfinity? ker =>
        val : FE :=
          is?(ker,"erf" :: Symbol) => -1
          is?(ker,"sech" :: Symbol) => 0
          is?(ker,"csch" :: Symbol) => 0
          is?(ker,"tanh" :: Symbol) => 0
          is?(ker,"coth" :: Symbol) => 0
          is?(ker,"atan" :: Symbol) => -pi()/(2 :: FE)
          is?(ker,"acot" :: Symbol) => pi()
          is?(ker,"asec" :: Symbol) => -pi()/(2 :: FE)
          is?(ker,"acsc" :: Symbol) => -pi()
          is?(ker,"acsch" :: Symbol) => 0
          -- ker must be acoth
          0
        val :: OFE
      knownValueAtInfinity? ker =>
        is?(ker,"exp" :: Symbol) => (0@FE) :: OFE
        is?(ker,"sinh" :: Symbol) => lim
        is?(ker,"cosh" :: Symbol) => plusInfinity()
        "failed"
      "failed"

    logOnlyLimit: (FE,SY) -> RESULT
    logOnlyLimit(coef,x) ==
      -- this function is called when the 'constant' coefficient involves
      -- the variable 'x'. Its purpose is to compute a right hand limit
      -- of an expression involving log x. Here log x is replaced by -1/v,
      -- where v is a new variable. If the new expression no longer involves
      -- x, then take the right hand limit as v -> 0+
      vv := new()$SY
      eq : EQ FE := equation(log(x :: FE),-inv(vv :: FE))
      member?(x,variables(cc := eval(coef,eq))) => "failed"
      limitPlus(cc,vv)

    locallimit(fcn,x,a) ==
      -- Here 'fcn' is a function f(x) = f(x,...) in 'x' and possibly
      -- other variables, and 'a' is a limiting value.  The function
      -- computes lim(x -> a,f(x)).
      xK := retract(x::FE)@Kernel(FE)
      (n := whatInfinity a) = 0 =>
        realLimit(localsubst(fcn,xK,1,retract(a)@FE),x)
      (u := limitPlus(eval(fcn,xK,n * inv(xK::FE)),x))
                                                case "failed" => "failed"
      u::OFE

    localsubst(fcn, k, n, a) ==
      a = 0 and n = 1 => fcn
      eval(fcn,k,n * (k::FE) + a)

    locallimitcomplex(fcn,x,a) ==
      xK := retract(x::FE)@Kernel(FE)
      (g := retractIfCan(a)@Union(FE,"failed")) case FE =>
        complLimit(localsubst(fcn,xK,1,g::FE),x)
      complLimit(eval(fcn,xK,inv(xK::FE)),x)

    limit(fcn,eq,str) ==
      (xx := retractIfCan(lhs eq)@Union(SY,"failed")) case "failed" =>
        error "limit:left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      xK := retract(x::FE)@Kernel(FE)
      limitPlus(localsubst(fcn,xK,direction str,a),x)

    anyRootsOrAtrigs? fcn ==
      -- determines if 'fcn' has any kernels which are roots
      -- or if 'fcn' has any kernels which are inverse trig functions
      -- which could produce series expansions with fractional exponents
      for kernel in tower fcn repeat
        is?(kernel,"nthRoot" :: Symbol) => return true
        is?(kernel,"asin" :: Symbol) => return true
        is?(kernel,"acos" :: Symbol) => return true
        is?(kernel,"asec" :: Symbol) => return true
        is?(kernel,"acsc" :: Symbol) => return true
      false

    complLimit(fcn,x) ==
      -- computes lim(x -> 0,fcn) using a Puiseux expansion of fcn,
      -- if fcn is an expression involving roots, and using a Laurent
      -- expansion of fcn otherwise
      lim : FE :=
        anyRootsOrAtrigs? fcn =>
          ppack := FS2UPS(R,FE,RN,_
              UPXS(FE,x,zeroFE),EFUPXS(FE,ULS(FE,x,zeroFE),UPXS(FE,x,zeroFE),_
              EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE))),x)
          pseries := exprToUPS(fcn,false,"complex")$ppack
          pseries case %problem => return "failed"
          if pole?(upxs := pseries.%series) then upxs := map(normalize,upxs)
          pole? upxs => return infinity()
          coefficient(upxs,0)
        lpack := FS2UPS(R,FE,Z,ULS(FE,x,zeroFE),_
                 EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE)),x)
        lseries := exprToUPS(fcn,false,"complex")$lpack
        lseries case %problem => return "failed"
        if pole?(uls := lseries.%series) then uls := map(normalize,uls)
        pole? uls => return infinity()
        coefficient(uls,0)
      -- can the following happen?
      member?(x,variables lim) =>
        member?(x,variables(answer := normalize lim)) =>
          error "limit: can't evaluate limit"
        answer :: OPF
      lim :: FE :: OPF

    okProblem?(function,problem) ==
      (function = "log") or (function = "nth root") =>
        (problem = "series of non-zero order") or _
               (problem = "negative leading coefficient")
      (function = "atan") => problem = "branch problem"
      (function = "erf") => problem = "unknown kernel"
      problem = "essential singularity"

    poleLimit(order,coef,x) ==
      -- compute limit for function with pole
      not member?(x,variables coef) =>
        (s := sign(coef)$SIGNEF) case Integer =>
          rtLim := (s :: Integer) * plusInfinity()
          even? numer order => rtLim
          even? denom order => ["failed",rtLim]$TwoSide
          [-rtLim,rtLim]$TwoSide
        -- infinite limit, but cannot determine sign
        "failed"
      error "limit: can't evaluate limit"

    poleLimitPlus(order,coef,x) ==
      -- compute right hand limit for function with pole
      not member?(x,variables coef) =>
        (s := sign(coef)$SIGNEF) case Integer =>
          (s :: Integer) * plusInfinity()
        -- infinite limit, but cannot determine sign
        "failed"
      (clim := specialLimit(coef,x)) case "failed" => "failed"
      zero? (lim := clim :: OFE) =>
        -- in this event, we need to determine if the limit of
        -- the coef is 0+ or 0-
        (cclim := specialLimit(inv coef,x)) case "failed" => "failed"
        ss := whatInfinity(cclim :: OFE) :: Z
        zero? ss =>
          error "limit: internal error"
        ss * plusInfinity()
      t := whatInfinity(lim :: OFE) :: Z
      zero? t =>
        (tt := sign(coef)$SIGNEF) case Integer =>
          (tt :: Integer) * plusInfinity()
        -- infinite limit, but cannot determine sign
        "failed"
      t * plusInfinity()

    realLimit(fcn,x) ==
      -- computes lim(x -> 0,fcn) using a Puiseux expansion of fcn,
      -- if fcn is an expression involving roots, and using a Laurent
      -- expansion of fcn otherwise
      lim : Union(FE,"failed") :=
        anyRootsOrAtrigs? fcn =>
          ppack := FS2UPS(R,FE,RN,_
               UPXS(FE,x,zeroFE),EFUPXS(FE,ULS(FE,x,zeroFE),UPXS(FE,x,zeroFE),_
               EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE))),x)
          pseries := exprToUPS(fcn,true,"real: two sides")$ppack
          pseries case %problem =>
            trouble := pseries.%problem
            function := trouble.func; problem := trouble.prob
            okProblem?(function,problem) =>
              left :=
                xK : Kernel FE := kernel x
                fcn0 := eval(fcn,xK,-(xK :: FE))
                limitPlus(fcn0,x)
              right := limitPlus(fcn,x)
              (left case "failed") and (right case "failed") =>
                return "failed"
              if (left case OFE) and (right case OFE) then
                (left :: OFE) = (right :: OFE) => return (left :: OFE)
              return([left,right]$TwoSide)
            return "failed"
          if pole?(upxs := pseries.%series) then upxs := map(normalize,upxs)
          pole? upxs =>
            cp := coefficient(upxs,ordp := order upxs)
            return poleLimit(ordp,cp,x)
          coefficient(upxs,0)
        lpack := FS2UPS(R,FE,Z,ULS(FE,x,zeroFE),_
                 EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE)),x)
        lseries := exprToUPS(fcn,true,"real: two sides")$lpack
        lseries case %problem =>
          trouble := lseries.%problem
          function := trouble.func; problem := trouble.prob
          okProblem?(function,problem) =>
            left :=
              xK : Kernel FE := kernel x
              fcn0 := eval(fcn,xK,-(xK :: FE))
              limitPlus(fcn0,x)
            right := limitPlus(fcn,x)
            (left case "failed") and (right case "failed") =>
              return "failed"
            if (left case OFE) and (right case OFE) then
              (left :: OFE) = (right :: OFE) => return (left :: OFE)
            return([left,right]$TwoSide)
          return "failed"
        if pole?(uls := lseries.%series) then uls := map(normalize,uls)
        pole? uls =>
          cl := coefficient(uls,ordl := order uls)
          return poleLimit(ordl :: RN,cl,x)
        coefficient(uls,0)
      lim case "failed" => "failed"
      member?(x,variables(lim :: FE)) =>
        member?(x,variables(answer := normalize(lim :: FE))) =>
          error "limit: can't evaluate limit"
        answer :: OFE
      lim :: FE :: OFE

    xxpLimit(fcn,x) ==
      -- computes lim(x -> 0+,fcn) using an exponential expansion of fcn
      xpack := FS2EXPXP(R,FE,x,zeroFE)
      xxp := exprToXXP(fcn,true)$xpack
      xxp case %problem => "failed"
      limitPlus(xxp.%expansion)

    limitPlus(fcn,x) ==
      -- computes lim(x -> 0+,fcn) using a generalized Puiseux expansion
      -- of fcn, if fcn is an expression involving roots, and using a
      -- generalized Laurent expansion of fcn otherwise
      lim : Union(FE,"failed") :=
        anyRootsOrAtrigs? fcn =>
          ppack := FS2UPS(R,FE,RN,_
               UPXS(FE,x,zeroFE),EFUPXS(FE,ULS(FE,x,zeroFE),UPXS(FE,x,zeroFE),_
               EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE))),x)
          pseries := exprToGenUPS(fcn,true,"real: right side")$ppack
          pseries case %problem =>
            trouble := pseries.%problem
            ff := trouble.func; pp := trouble.prob
            (pp = "negative leading coefficient") => return "failed"
            "failed"
          -- pseries case %problem => return "failed"
          if pole?(upxs := pseries.%series) then upxs := map(normalize,upxs)
          pole? upxs =>
            cp := coefficient(upxs,ordp := order upxs)
            return poleLimitPlus(ordp,cp,x)
          coefficient(upxs,0)
        lpack := FS2UPS(R,FE,Z,ULS(FE,x,zeroFE),_
                 EFULS(FE,UTS(FE,x,zeroFE),ULS(FE,x,zeroFE)),x)
        lseries := exprToGenUPS(fcn,true,"real: right side")$lpack
        lseries case %problem =>
          trouble := lseries.%problem
          ff := trouble.func; pp := trouble.prob
          (pp = "negative leading coefficient") => return "failed"
          "failed"
        -- lseries case %problem => return "failed"
        if pole?(uls := lseries.%series) then uls := map(normalize,uls)
        pole? uls =>
          cl := coefficient(uls,ordl := order uls)
          return poleLimitPlus(ordl :: RN,cl,x)
        coefficient(uls,0)
      lim case "failed" =>
        (xLim := xxpLimit(fcn,x)) case "failed" => specialLimit(fcn,x)
        xLim
      member?(x,variables(lim :: FE)) =>
        member?(x,variables(answer := normalize(lim :: FE))) =>
          (xLim := xxpLimit(answer,x)) case "failed" => specialLimit(answer,x)
          xLim
        answer :: OFE
      lim :: FE :: OFE

    limit(fcn:FE,eq:EQ OFE) ==
      (f := retractIfCan(lhs eq)@Union(FE,"failed")) case "failed" =>
        error "limit:left hand side must be a variable"
      (xx := retractIfCan(f)@Union(SY,"failed")) case "failed" =>
        error "limit:left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      locallimit(fcn,x,a)

    complexLimit(fcn:FE,eq:EQ OPF) ==
      (f := retractIfCan(lhs eq)@Union(FE,"failed")) case "failed" =>
        error "limit:left hand side must be a variable"
      (xx := retractIfCan(f)@Union(SY,"failed")) case "failed" =>
        error "limit:left hand side must be a variable"
      x := xx :: SY; a := rhs eq
      locallimitcomplex(fcn,x,a)

@
<<LIMITPS.dotabb>>=
"LIMITPS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=LIMITPS"]
"ULSCCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ULSCCAT"]
"LIMITPS" -> "ULSCCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PREASSOC PrecomputedAssociatedEquations}
\pagehead{PrecomputedAssociatedEquations}{PREASSOC}
\pagepic{ps/v104precomputedassociatedequations.ps}{PREASSOC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PREASSOC PrecomputedAssociatedEquations>>=
)abbrev package PREASSOC PrecomputedAssociatedEquations
++ Author: Manuel Bronstein
++ Date Created: 13 January 1994
++ Date Last Updated: 3 February 1994
++ Description:
++ \spadtype{PrecomputedAssociatedEquations} stores some generic
++ precomputations which speed up the computations of the
++ associated equations needed for factoring operators.
PrecomputedAssociatedEquations(R, L): Exports == Implementation where
  R: IntegralDomain
  L: LinearOrdinaryDifferentialOperatorCategory R
 
  PI  ==> PositiveInteger
  N   ==> NonNegativeInteger
  A   ==> PrimitiveArray R
  U   ==> Union(Matrix R, "failed")
 
  Exports ==> with
    firstUncouplingMatrix: (L, PI) -> U
      ++ firstUncouplingMatrix(op, m) returns the matrix A such that
      ++ \spad{A w = (W',W'',...,W^N)} in the corresponding associated
      ++ equations for right-factors of order m of op.
      ++ Returns "failed" if the matrix A has not been precomputed for
      ++ the particular combination \spad{degree(L), m}.
 
  Implementation ==> add
    A32:  L -> U
    A42:  L -> U
    A425: (A, A, A) -> List R
    A426: (A, A, A) -> List R
    makeMonic: L -> Union(A, "failed")
 
    diff:L := D()
 
    firstUncouplingMatrix(op, m) ==
      n := degree op
      n = 3 and m = 2 => A32 op
      n = 4 and m = 2 => A42 op
      "failed"
        
    makeMonic op ==
      lc := leadingCoefficient op
      a:A := new(n := degree op, 0)
      for i in 0..(n-1)::N repeat
        (u := coefficient(op, i) exquo lc) case "failed" => return "failed"
        a.i := - (u::R)
      a
    
    A32 op ==
      (u := makeMonic op) case "failed" => "failed"
      a := u::A
      matrix [[0, 1, 0], [a.1, a.2, 1],
              [diff(a.1) + a.1 * a.2 - a.0, diff(a.2) + a.2**2 + a.1, 2 * a.2]]
 
    A42 op ==
      (u := makeMonic op) case "failed" => "failed"
      a := u::A
      a':A := new(4, 0)
      a'':A := new(4, 0)
      for i in 0..3 repeat
        a'.i := diff(a.i)
        a''.i := diff(a'.i)
      matrix [[0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0], [a.1,a.2,0,a.3,2::R,0],
              [a'.1 + a.1 * a.3 - 2 * a.0, a'.2 + a.2 * a.3 + a.1, 3 * a.2,
               a'.3 + a.3 ** 2 + a.2, 3 * a.3, 2::R],
                A425(a, a', a''), A426(a, a', a'')]
 
    A425(a, a', a'') ==
      [a''.1 + 2 * a.1 * a'.3 + a.3 * a'.1 - 2 * a'.0 + a.1 * a.3 ** 2
       - 3 * a.0 * a.3 + a.1 * a.2,
        a''.2 + 2 * a.2 * a'.3 + a.3 * a'.2 + 2 * a'.1 + a.2 * a.3 ** 2
         + a.1 * a.3 + a.2 ** 2 - 4 * a.0,
          4 * a'.2 + 4 * a.2 * a.3 - a.1,
           a''.3 + 3 * a.3 * a'.3 + 2 * a'.2 + a.3 ** 3 + 2 * a.2 * a.3 + a.1,
            4 * a'.3 + 4 * a.3 ** 2 + 4 * a.2, 5 * a.3]
              
    A426(a, a', a'') ==
      [diff(a''.1) + 3 * a.1 * a''.3 + a.3 * a''.1 - 2 * a''.0
       + (3 * a'.1 + 5 * a.1 * a.3 - 7 * a.0) * a'.3 + 3 * a.1 * a'.2
        + (a.3 ** 2 + a.2) * a'.1 - 3 * a.3 * a'.0 + a.1 * a.3 ** 3
         - 4 * a.0 * a.3 ** 2 + 2 * a.1 * a.2 * a.3 - 4 * a.0 * a.2 + a.1 ** 2,
          diff(a''.2) + 3 * a.2 * a''.3 + a.3 * a''.2 + 3 * a''.1
           + (3*a'.2 + 5*a.2 * a.3 + 3 * a.1) * a'.3 + (a.3**2 + 4*a.2)*a'.2
            + 2 * a.3 * a'.1 - 6 * a'.0 + a.2 * a.3 ** 3 + a.1 * a.3 ** 2
             + (2 * a.2**2 - 8 * a.0) * a.3 + 2 * a.1 * a.2,
              5 * a''.2 + 10 * a.2 * a'.3 + 5 * a.3 * a'.2 + a'.1
               + 5 * a.2 * a.3 ** 2 - 4 * a.1 * a.3 + 5 * a.2**2 - 4 * a.0,
                diff(a''.3) + 4 * a.3 * a''.3 + 3*a''.2 + 3 * a'.3**2
                 + (6 * a.3**2 + 4 * a.2) * a'.3 + 5 * a.3 * a'.2 + 3 * a'.1
                  + a.3**4 + 3 * a.2 * a.3**2 + 2 * a.1 * a.3 + a.2**2 - 4*a.0,
                   5 * a''.3 + 15 * a.3 * a'.3 + 10 * a'.2 + 5 * a.3**3
                    + 10 * a.2 * a.3, 9 * a'.3 + 9 * a.3**2 + 4 * a.2]

@
<<PREASSOC.dotabb>>=
"PREASSOC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PREASSOC"]
"OREPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OREPCAT"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"PREASSOC" -> "OREPCAT"
"PREASSOC" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PRIMARR2 PrimitiveArrayFunctions2}
\pagehead{PrimitiveArrayFunctions2}{PRIMARR2}
\pagepic{ps/v104primitivearrayfunctions2.ps}{PRIMARR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PRIMARR2 PrimitiveArrayFunctions2>>=
)abbrev package PRIMARR2 PrimitiveArrayFunctions2
++ This package provides tools for operating on primitive arrays
++ with unary and binary functions involving different underlying types
PrimitiveArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> PrimitiveArray A
  VB ==> PrimitiveArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)
  Exports ==> with
   scan : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of primitive array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1
   
   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ primitive array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of primitive array
    ++ \spad{a} resulting in a new primitive array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<PRIMARR2.dotabb>>=
"PRIMARR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PRIMARR2"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"PRIMARR2" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEPRIM PrimitiveRatDE}
\pagehead{PrimitiveRatDE}{ODEPRIM}
\pagepic{ps/v104primitiveratde.ps}{ODEPRIM}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEPRIM PrimitiveRatDE>>=
)abbrev package ODEPRIM PrimitiveRatDE
++ Author: Manuel Bronstein
++ Date Created: 1 March 1991
++ Date Last Updated: 1 February 1994
++ Description:
++  \spad{PrimitiveRatDE} provides functions for in-field solutions of linear
++   ordinary differential equations, in the transcendental case.
++   The derivation to use is given by the parameter \spad{L}.
PrimitiveRatDE(F, UP, L, LQ): Exports == Implementation where
  F  : Join(Field, CharacteristicZero, RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F
  L  : LinearOrdinaryDifferentialOperatorCategory UP
  LQ : LinearOrdinaryDifferentialOperatorCategory Fraction UP

  N   ==> NonNegativeInteger
  Z   ==> Integer
  RF  ==> Fraction UP
  UP2 ==> SparseUnivariatePolynomial UP
  REC ==> Record(center:UP, equation:UP)

  Exports ==> with
    denomLODE: (L, RF) -> Union(UP, "failed")
      ++ denomLODE(op, g) returns a polynomial d such that
      ++ any rational solution of \spad{op y = g}
      ++ is of the form \spad{p/d} for some polynomial p, and
      ++ "failed", if the equation has no rational solution.
    denomLODE: (L, List RF) -> UP
      ++ denomLODE(op, [g1,...,gm]) returns a polynomial
      ++ d such that any rational solution of \spad{op y = c1 g1 + ... + cm gm}
      ++ is of the form \spad{p/d} for some polynomial p.
    indicialEquations: L -> List REC
      ++ indicialEquations op returns \spad{[[d1,e1],...,[dq,eq]]} where
      ++ the \spad{d_i}'s are the affine singularities of \spad{op},
      ++ and the \spad{e_i}'s are the indicial equations at each \spad{d_i}.
    indicialEquations: (L, UP) -> List REC
      ++ indicialEquations(op, p) returns \spad{[[d1,e1],...,[dq,eq]]} where
      ++ the \spad{d_i}'s are the affine singularities of \spad{op}
      ++ above the roots of \spad{p},
      ++ and the \spad{e_i}'s are the indicial equations at each \spad{d_i}.
    indicialEquation: (L, F) -> UP
      ++ indicialEquation(op, a) returns the indicial equation of \spad{op}
      ++ at \spad{a}.
    indicialEquations: LQ -> List REC
      ++ indicialEquations op returns \spad{[[d1,e1],...,[dq,eq]]} where
      ++ the \spad{d_i}'s are the affine singularities of \spad{op},
      ++ and the \spad{e_i}'s are the indicial equations at each \spad{d_i}.
    indicialEquations: (LQ, UP) -> List REC
      ++ indicialEquations(op, p) returns \spad{[[d1,e1],...,[dq,eq]]} where
      ++ the \spad{d_i}'s are the affine singularities of \spad{op}
      ++ above the roots of \spad{p},
      ++ and the \spad{e_i}'s are the indicial equations at each \spad{d_i}.
    indicialEquation: (LQ, F) -> UP
      ++ indicialEquation(op, a) returns the indicial equation of \spad{op}
      ++ at \spad{a}.
    splitDenominator: (LQ, List RF) -> Record(eq:L, rh:List RF)
      ++ splitDenominator(op, [g1,...,gm]) returns \spad{op0, [h1,...,hm]}
      ++ such that the equations \spad{op y = c1 g1 + ... + cm gm} and
      ++ \spad{op0 y = c1 h1 + ... + cm hm} have the same solutions.

  Implementation ==> add
    import BoundIntegerRoots(F, UP)
    import BalancedFactorisation(F, UP)
    import InnerCommonDenominator(UP, RF, List UP, List RF)
    import UnivariatePolynomialCategoryFunctions2(F, UP, UP, UP2)

    tau          : (UP, UP, UP, N) -> UP
    NPbound      : (UP, L, UP) -> N
    hdenom       : (L, UP, UP) -> UP
    denom0       : (Z, L, UP, UP, UP) -> UP
    indicialEq   : (UP, List N, List UP) -> UP
    separateZeros: (UP, UP) -> UP
    UPfact       : N -> UP
    UP2UP2       : UP -> UP2
    indeq        : (UP, L) -> UP
    NPmulambda   : (UP, L) -> Record(mu:Z, lambda:List N, func:List UP)

    diff := D()$L

    UP2UP2 p                    == map(#1::UP, p)
    indicialEquations(op:L)     == indicialEquations(op, leadingCoefficient op)
    indicialEquation(op:L, a:F) == indeq(monomial(1, 1) - a::UP, op)

    splitDenominator(op, lg) ==
      cd := splitDenominator coefficients op
      f  := cd.den / gcd(cd.num)
      l:L := 0
      while op ^= 0 repeat
          l  := l + monomial(retract(f * leadingCoefficient op), degree op)
          op := reductum op
      [l, [f * g for g in lg]]

    tau(p, pp, q, n) ==
      ((pp ** n) * ((q exquo (p ** order(q, p)))::UP)) rem p

    indicialEquations(op:LQ) ==
      indicialEquations(splitDenominator(op, empty()).eq)

    indicialEquations(op:LQ, p:UP) ==
      indicialEquations(splitDenominator(op, empty()).eq, p)

    indicialEquation(op:LQ, a:F) ==
      indeq(monomial(1, 1) - a::UP, splitDenominator(op, empty()).eq)

-- returns z(z-1)...(z-(n-1))
    UPfact n ==
      zero? n => 1
      z := monomial(1, 1)$UP
      */[z - i::F::UP for i in 0..(n-1)::N]

    indicialEq(c, lamb, lf) ==
      cp := diff c
      cc := UP2UP2 c
      s:UP2 := 0
      for i in lamb for f in lf repeat
        s := s + (UPfact i) * UP2UP2 tau(c, cp, f, i)
      primitivePart resultant(cc, s)

    NPmulambda(c, l) ==
      lamb:List(N) := [d := degree l]
      lf:List(UP) := [a := leadingCoefficient l]
      mup := d::Z - order(a, c)
      while (l := reductum l) ^= 0 repeat
          a := leadingCoefficient l
          if (m := (d := degree l)::Z - order(a, c)) > mup then
              mup := m
              lamb := [d]
              lf := [a]
          else if (m = mup) then
              lamb := concat(d, lamb)
              lf := concat(a, lf)
      [mup, lamb, lf]

-- e = 0 means homogeneous equation
    NPbound(c, l, e) ==
      rec := NPmulambda(c, l)
      n := max(0, - integerBound indicialEq(c, rec.lambda, rec.func))
      zero? e => n::N
      max(n, order(e, c)::Z - rec.mu)::N

    hdenom(l, d, e) ==
      */[dd.factor ** NPbound(dd.factor, l, e)
                    for dd in factors balancedFactorisation(d, coefficients l)]

    denom0(n, l, d, e, h) ==
      hdenom(l, d, e) * */[hh.factor ** max(0, order(e, hh.factor) - n)::N
                                 for hh in factors balancedFactorisation(h, e)]

-- returns a polynomials whose zeros are the zeros of e which are not
-- zeros of d
    separateZeros(d, e) ==
      ((g := squareFreePart e) exquo gcd(g, squareFreePart d))::UP

    indeq(c, l) ==
      rec := NPmulambda(c, l)
      indicialEq(c, rec.lambda, rec.func)

    indicialEquations(op:L, p:UP) ==
      [[dd.factor, indeq(dd.factor, op)]
                   for dd in factors balancedFactorisation(p, coefficients op)]

-- cannot return "failed" in the homogeneous case
    denomLODE(l:L, g:RF) ==
      d := leadingCoefficient l
      zero? g => hdenom(l, d, 0)
      h := separateZeros(d, e := denom g)
      n := degree l
      (e exquo (h**(n + 1))) case "failed" => "failed"
      denom0(n, l, d, e, h)

    denomLODE(l:L, lg:List RF) ==
      empty? lg => denomLODE(l, 0)::UP
      d := leadingCoefficient l
      h := separateZeros(d, e := "lcm"/[denom g for g in lg])
      denom0(degree l, l, d, e, h)

@
<<ODEPRIM.dotabb>>=
"ODEPRIM" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEPRIM"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"ODEPRIM" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTPAF PureAlgebraicIntegration}
\pagehead{PureAlgebraicIntegration}{INTPAF}
\pagepic{ps/v104purealgebraicintegration.ps}{INTPAF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTPAF PureAlgebraicIntegration>>=
)abbrev package INTPAF PureAlgebraicIntegration
++ Integration of pure algebraic functions;
++ Author: Manuel Bronstein
++ Date Created: 27 May 1988
++ Date Last Updated: 24 June 1994
++ Description:
++ This package provides functions for integration, limited integration,
++ extended integration and the risch differential equation for
++ pure algebraic integrands;
PureAlgebraicIntegration(R, F, L): Exports == Implementation where
  R: Join(GcdDomain,RetractableTo Integer,OrderedSet, CharacteristicZero,
          LinearlyExplicitRingOver Integer)
  F: Join(FunctionSpace R, AlgebraicallyClosedField,
          TranscendentalFunctionCategory)
  L: SetCategory

  SY  ==> Symbol
  N   ==> NonNegativeInteger
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  RF  ==> Fraction UP
  UPUP==> SparseUnivariatePolynomial RF
  IR  ==> IntegrationResult F
  IR2 ==> IntegrationResultFunctions2(curve, F)
  ALG ==> AlgebraicIntegrate(R, F, UP, UPUP, curve)
  LDALG ==> LinearOrdinaryDifferentialOperator1 curve
  RDALG ==> PureAlgebraicLODE(F, UP, UPUP, curve)
  LOG ==> Record(coeff:F, logand:F)
  REC ==> Record(particular:U1, basis:List F)
  CND ==> Record(left:UP, right:UP)
  CHV ==> Record(int:UPUP, left:UP, right:UP, den:RF, deg:N)
  U1  ==> Union(F, "failed")
  U2  ==> Union(Record(ratpart:F, coeff:F),"failed")
  U3  ==> Union(Record(mainpart:F, limitedlogs:List LOG), "failed")
  FAIL==> error "failed - cannot handle that integrand"

  Exports ==> with
    palgint   : (F, K, K)    -> IR
      ++ palgint(f, x, y) returns the integral of \spad{f(x,y)dx}
      ++ where y is an algebraic function of x.
    palgextint: (F, K, K, F) -> U2
      ++ palgextint(f, x, y, g) returns functions \spad{[h, c]} such that
      ++ \spad{dh/dx = f(x,y) - c g}, where y is an algebraic function of x;
      ++ returns "failed" if no such functions exist.
    palglimint: (F, K, K, List F) -> U3
      ++ palglimint(f, x, y, [u1,...,un]) returns functions
      ++ \spad{[h,[[ci, ui]]]} such that the ui's are among \spad{[u1,...,un]}
      ++ and \spad{d(h + sum(ci log(ui)))/dx = f(x,y)} if such functions exist,
      ++ "failed" otherwise;
      ++ y is an algebraic function of x.
    palgRDE   : (F, F, F, K, K, (F, F, SY) -> U1) -> U1
      ++ palgRDE(nfp, f, g, x, y, foo) returns a function \spad{z(x,y)}
      ++ such that \spad{dz/dx + n * df/dx z(x,y) = g(x,y)} if such a z exists,
      ++ "failed" otherwise;
      ++ y is an algebraic function of x;
      ++ \spad{foo(a, b, x)} is a function that solves
      ++ \spad{du/dx + n * da/dx u(x) = u(x)}
      ++ for an unknown \spad{u(x)} not involving y.
      ++ \spad{nfp} is \spad{n * df/dx}.
    if L has LinearOrdinaryDifferentialOperatorCategory F then
      palgLODE: (L, F, K, K, SY) -> REC
        ++ palgLODE(op, g, kx, y, x) returns the solution of \spad{op f = g}.
        ++ y is an algebraic function of x.

  Implementation ==> add
    import IntegrationTools(R, F)
    import RationalIntegration(F, UP)
    import GenusZeroIntegration(R, F, L)
    import ChangeOfVariable(F, UP, UPUP)
    import IntegrationResultFunctions2(F, F)
    import IntegrationResultFunctions2(RF, F)
    import SparseUnivariatePolynomialFunctions2(F, RF)
    import UnivariatePolynomialCommonDenominator(UP, RF, UPUP)
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                                                        K, R, P, F)

    quadIfCan      : (K, K) -> Union(Record(coef:F, poly:UP), "failed")
    linearInXIfCan : (K, K) -> Union(Record(xsub:F, dxsub:RF), "failed")
    prootintegrate : (F, K, K) -> IR
    prootintegrate1: (UPUP, K, K, UPUP) -> IR
    prootextint    : (F, K, K, F) -> U2
    prootlimint    : (F, K, K, List F) -> U3
    prootRDE       : (F, F, F, K, K, (F, F, SY) -> U1) -> U1
    palgRDE1       : (F, F, K, K) -> U1
    palgLODE1      : (List F, F, K, K, SY) -> REC
    palgintegrate  : (F, K, K) -> IR
    palgext        : (F, K, K, F) -> U2
    palglim        : (F, K, K, List F) -> U3
    UPUP2F1        : (UPUP, RF, RF, K, K) -> F
    UPUP2F0        : (UPUP, K, K) -> F
    RF2UPUP        : (RF, UPUP) -> UPUP
    algaddx        : (IR, F) -> IR
    chvarIfCan     : (UPUP, RF, UP, RF) -> Union(UPUP, "failed")
    changeVarIfCan : (UPUP, RF, N) -> Union(CHV, "failed")
    rationalInt    : (UPUP, N, UP) -> IntegrationResult RF
    chv            : (UPUP, N, F, F) -> RF
    chv0           : (UPUP, N, F, F) -> F
    candidates     : UP -> List CND

    dummy := new()$SY
    dumk  := kernel(dummy)@K

    UPUP2F1(p, t, cf, kx, k) == UPUP2F0(eval(p, t, cf), kx, k)
    UPUP2F0(p, kx, k)        == multivariate(p, kx, k::F)
    chv(f, n, a, b)          == univariate(chv0(f, n, a, b), dumk)

    RF2UPUP(f, modulus) ==
      bc := extendedEuclidean(map(#1::UP::RF, denom f), modulus,
                                      1)::Record(coef1:UPUP, coef2:UPUP)
      (map(#1::UP::RF, numer f) * bc.coef1) rem modulus

-- returns "failed", or (xx, c) such that f(x, y)dx = f(xx, y) c dy
-- if p(x, y) = 0 is linear in x
    linearInXIfCan(x, y) ==
      a := b := 0$UP
      p := clearDenominator lift(minPoly y, x)
      while p ^= 0 repeat
        degree(q := numer leadingCoefficient p) > 1 => return "failed"
        a := a + monomial(coefficient(q, 1), d := degree p)
        b := b - monomial(coefficient(q, 0), d)
        p := reductum p
      xx:RF := b / a
      [xx(dumk::F), differentiate(xx, differentiate)]

-- return Int(f(x,y)dx) where y is an n^th root of a rational function in x
    prootintegrate(f, x, y) ==
      modulus := lift(p := minPoly y, x)
      rf      := reductum(ff := univariate(f, x, y, p))
      ((r := retractIfCan(rf)@Union(RF,"failed")) case RF) and rf ^= 0 =>
            -- in this case, ff := lc(ff) y^i + r so we integrate both terms
            -- separately to gain time
            map(#1(x::F), integrate(r::RF)) +
                 prootintegrate1(leadingMonomial ff, x, y, modulus)
      prootintegrate1(ff, x, y, modulus)

    prootintegrate1(ff, x, y, modulus) ==
      chv:CHV
      r := radPoly(modulus)::Record(radicand:RF, deg:N)
      (uu := changeVarIfCan(ff, r.radicand, r.deg)) case CHV =>
        chv := uu::CHV
        newalg := nthRoot((chv.left)(dumk::F), chv.deg)
        kz := retract(numer newalg)@K
        newf := multivariate(chv.int, ku := dumk, newalg)
        vu := (chv.right)(x::F)
        vz := (chv.den)(x::F) * (y::F) * denom(newalg)::F
        map(eval(#1, [ku, kz], [vu, vz]), palgint(newf, ku, kz))
      cv     := chvar(ff, modulus)
      r      := radPoly(cv.poly)::Record(radicand:RF, deg:N)
      qprime := differentiate(q := retract(r.radicand)@UP)::RF
      not zero? qprime and
       ((u := chvarIfCan(cv.func, 1, q, inv qprime)) case UPUP) =>
         m := monomial(1, r.deg)$UPUP - q::RF::UPUP
         map(UPUP2F1(RF2UPUP(#1, m), cv.c1, cv.c2, x, y),
            rationalInt(u::UPUP, r.deg, monomial(1, 1)))
      curve  := RadicalFunctionField(F, UP, UPUP, q::RF, r.deg)
      algaddx(map(UPUP2F1(lift #1, cv.c1, cv.c2, x, y),
        palgintegrate(reduce(cv.func), differentiate$UP)$ALG)$IR2, x::F)

-- Do the rationalizing change of variable
-- Int(f(x, y) dx) --> Int(n u^(n-1) f((u^n - b)/a, u) / a du) where
-- u^n = y^n = g(x) = a x + b
-- returns the integral as an integral of a rational function in u
    rationalInt(f, n, g) ==
--      not one? degree g => error "rationalInt: radicand must be linear"
      not ((degree g) = 1) => error "rationalInt: radicand must be linear"
      a := leadingCoefficient g
      integrate(n * monomial(inv a, (n-1)::N)$UP
                  * chv(f, n, a, leadingCoefficient reductum g))

-- Do the rationalizing change of variable f(x,y) --> f((u^n - b)/a, u) where
-- u = y = (a x + b)^(1/n).
-- Returns f((u^n - b)/a,u) as an element of F
    chv0(f, n, a, b) ==
      d := dumk::F
      (f (d::UP::RF)) ((d ** n - b) / a)

-- candidates(p) returns a list of pairs [g, u] such that p(x) = g(u(x)),
-- those u's are candidates for change of variables
-- currently uses a dumb heuristic where the candidates u's are p itself
-- and all the powers x^2, x^3, ..., x^{deg(p)},
-- will use polynomial decomposition in smarter days   MB 8/93
    candidates p ==
      l:List(CND) := empty()
      ground? p => l
      for i in 2..degree p repeat
        if (u := composite(p, xi := monomial(1, i))) case UP then
          l := concat([u::UP, xi], l)
      concat([monomial(1, 1), p], l)

-- checks whether Int(p(x, y) dx) can be rewritten as
-- Int(r(u, z) du) where u is some polynomial of x,
-- z = d y for some polynomial d, and z^m = g(u)
-- returns either [r(u, z), g, u, d, m] or "failed"
-- we have y^n = radi
    changeVarIfCan(p, radi, n) ==
      rec := rootPoly(radi, n)
      for cnd in candidates(rec.radicand) repeat
        (u := chvarIfCan(p, rec.coef, cnd.right,
              inv(differentiate(cnd.right)::RF))) case UPUP =>
                 return [u::UPUP, cnd.left, cnd.right, rec.coef, rec.exponent]
      "failed"

-- checks whether Int(p(x, y) dx) can be rewritten as
-- Int(r(u, z) du) where u is some polynomial of x and z = d y
-- we have y^n = a(x)/d(x)
-- returns either "failed" or r(u, z)
    chvarIfCan(p, d, u, u1) ==
      ans:UPUP := 0
      while p ^= 0 repeat
        (v := composite(u1 * leadingCoefficient(p) / d ** degree(p), u))
          case "failed" => return "failed"
        ans := ans + monomial(v::RF, degree p)
        p   := reductum p
      ans

    algaddx(i, xx) ==
      elem? i => i
      mkAnswer(ratpart i, logpart i,
                [[- ne.integrand / (xx**2), xx] for ne in notelem i])

    prootRDE(nfp, f, g, x, k, rde) ==
      modulus := lift(p := minPoly k, x)
      r       := radPoly(modulus)::Record(radicand:RF, deg:N)
      rec     := rootPoly(r.radicand, r.deg)
      dqdx    := inv(differentiate(q := rec.radicand)::RF)
      ((uf := chvarIfCan(ff := univariate(f,x,k,p),rec.coef,q,1)) case UPUP) and
        ((ug:=chvarIfCan(gg:=univariate(g,x,k,p),rec.coef,q,dqdx)) case UPUP) =>
          (u := rde(chv0(uf::UPUP, rec.exponent, 1, 0), rec.exponent *
                    (dumk::F) ** (rec.exponent * (rec.exponent - 1))
                      * chv0(ug::UPUP, rec.exponent, 1, 0),
                       symbolIfCan(dumk)::SY)) case "failed" => "failed"
          eval(u::F, dumk, k::F)
--      one?(rec.coef) =>
      ((rec.coef) = 1) =>
        curve  := RadicalFunctionField(F, UP, UPUP, q::RF, rec.exponent)
        rc := algDsolve(D()$LDALG + reduce(univariate(nfp, x, k, p))::LDALG,
                         reduce univariate(g, x, k, p))$RDALG
        rc.particular case "failed" => "failed"
        UPUP2F0(lift((rc.particular)::curve), x, k)
      palgRDE1(nfp, g, x, k)

    prootlimint(f, x, k, lu) ==
      modulus := lift(p := minPoly k, x)
      r       := radPoly(modulus)::Record(radicand:RF, deg:N)
      rec     := rootPoly(r.radicand, r.deg)
      dqdx    := inv(differentiate(q := rec.radicand)::RF)
      (uf := chvarIfCan(ff := univariate(f,x,k,p),rec.coef,q,dqdx)) case UPUP =>
        l := empty()$List(RF)
        n := rec.exponent * monomial(1, (rec.exponent - 1)::N)$UP
        for u in lu repeat
          if ((v:=chvarIfCan(uu:=univariate(u,x,k,p),rec.coef,q,dqdx))case UPUP)
            then l := concat(n * chv(v::UPUP,rec.exponent, 1, 0), l) else FAIL
        m := monomial(1, rec.exponent)$UPUP - q::RF::UPUP
        map(UPUP2F0(RF2UPUP(#1,m), x, k),
            limitedint(n * chv(uf::UPUP, rec.exponent, 1, 0), reverse_! l))
      cv     := chvar(ff, modulus)
      r      := radPoly(cv.poly)::Record(radicand:RF, deg:N)
      dqdx   := inv(differentiate(q := retract(r.radicand)@UP)::RF)
      curve  := RadicalFunctionField(F, UP, UPUP, q::RF, r.deg)
      (ui := palginfieldint(reduce(cv.func), differentiate$UP)$ALG)
        case "failed" => FAIL
      [UPUP2F1(lift(ui::curve), cv.c1, cv.c2, x, k), empty()]

    prootextint(f, x, k, g) ==
      modulus := lift(p := minPoly k, x)
      r       := radPoly(modulus)::Record(radicand:RF, deg:N)
      rec     := rootPoly(r.radicand, r.deg)
      dqdx    := inv(differentiate(q := rec.radicand)::RF)
      ((uf:=chvarIfCan(ff:=univariate(f,x,k,p),rec.coef,q,dqdx)) case UPUP) and
        ((ug:=chvarIfCan(gg:=univariate(g,x,k,p),rec.coef,q,dqdx)) case UPUP) =>
          m := monomial(1, rec.exponent)$UPUP - q::RF::UPUP
          n := rec.exponent * monomial(1, (rec.exponent - 1)::N)$UP
          map(UPUP2F0(RF2UPUP(#1,m), x, k),
              extendedint(n * chv(uf::UPUP, rec.exponent, 1, 0),
                          n * chv(ug::UPUP, rec.exponent, 1, 0)))
      cv     := chvar(ff, modulus)
      r      := radPoly(cv.poly)::Record(radicand:RF, deg:N)
      dqdx   := inv(differentiate(q := retract(r.radicand)@UP)::RF)
      curve  := RadicalFunctionField(F, UP, UPUP, q::RF, r.deg)
      (u := palginfieldint(reduce(cv.func), differentiate$UP)$ALG)
        case "failed" => FAIL
      [UPUP2F1(lift(u::curve), cv.c1, cv.c2, x, k), 0]

    palgRDE1(nfp, g, x, y) ==
      palgLODE1([nfp, 1], g, x, y, symbolIfCan(x)::SY).particular

    palgLODE1(eq, g, kx, y, x) ==
      modulus:= lift(p := minPoly y, kx)
      curve  := AlgebraicFunctionField(F, UP, UPUP, modulus)
      neq:LDALG := 0
      for f in eq for i in 0.. repeat
          neq := neq + monomial(reduce univariate(f, kx, y, p), i)
      empty? remove_!(y, remove_!(kx, varselect(kernels g, x))) =>
        rec := algDsolve(neq, reduce univariate(g, kx, y, p))$RDALG
        bas:List(F) := [UPUP2F0(lift h, kx, y) for h in rec.basis]
        rec.particular case "failed" => ["failed", bas]
        [UPUP2F0(lift((rec.particular)::curve), kx, y), bas]
      rec := algDsolve(neq, 0)
      ["failed", [UPUP2F0(lift h, kx, y) for h in rec.basis]]

    palgintegrate(f, x, k) ==
      modulus:= lift(p := minPoly k, x)
      cv     := chvar(univariate(f, x, k, p), modulus)
      curve  := AlgebraicFunctionField(F, UP, UPUP, cv.poly)
      knownInfBasis(cv.deg)
      algaddx(map(UPUP2F1(lift #1, cv.c1, cv.c2, x, k),
        palgintegrate(reduce(cv.func), differentiate$UP)$ALG)$IR2, x::F)

    palglim(f, x, k, lu) ==
      modulus:= lift(p := minPoly k, x)
      cv     := chvar(univariate(f, x, k, p), modulus)
      curve  := AlgebraicFunctionField(F, UP, UPUP, cv.poly)
      knownInfBasis(cv.deg)
      (u := palginfieldint(reduce(cv.func), differentiate$UP)$ALG)
        case "failed" => FAIL
      [UPUP2F1(lift(u::curve), cv.c1, cv.c2, x, k), empty()]

    palgext(f, x, k, g) ==
      modulus:= lift(p := minPoly k, x)
      cv     := chvar(univariate(f, x, k, p), modulus)
      curve  := AlgebraicFunctionField(F, UP, UPUP, cv.poly)
      knownInfBasis(cv.deg)
      (u := palginfieldint(reduce(cv.func), differentiate$UP)$ALG)
        case "failed" => FAIL
      [UPUP2F1(lift(u::curve), cv.c1, cv.c2, x, k), 0]

    palgint(f, x, y) ==
      (v := linearInXIfCan(x, y)) case "failed" =>
        (u := quadIfCan(x, y)) case "failed" =>
          is?(y, "nthRoot"::SY) => prootintegrate(f, x, y)
          is?(y,  "rootOf"::SY) => palgintegrate(f, x, y)
          FAIL
        palgint0(f, x, y, u.coef, u.poly)
      palgint0(f, x, y, dumk, v.xsub, v.dxsub)

    palgextint(f, x, y, g) ==
      (v := linearInXIfCan(x, y)) case "failed" =>
        (u := quadIfCan(x, y)) case "failed" =>
          is?(y, "nthRoot"::SY) => prootextint(f, x, y, g)
          is?(y,  "rootOf"::SY) => palgext(f, x, y, g)
          FAIL
        palgextint0(f, x, y, g, u.coef, u.poly)
      palgextint0(f, x, y, g, dumk, v.xsub, v.dxsub)

    palglimint(f, x, y, lu) ==
      (v := linearInXIfCan(x, y)) case "failed" =>
        (u := quadIfCan(x, y)) case "failed" =>
          is?(y, "nthRoot"::SY) => prootlimint(f, x, y, lu)
          is?(y,  "rootOf"::SY) => palglim(f, x, y, lu)
          FAIL
        palglimint0(f, x, y, lu, u.coef, u.poly)
      palglimint0(f, x, y, lu, dumk, v.xsub, v.dxsub)

    palgRDE(nfp, f, g, x, y, rde) ==
      (v := linearInXIfCan(x, y)) case "failed" =>
        (u := quadIfCan(x, y)) case "failed" =>
          is?(y, "nthRoot"::SY) => prootRDE(nfp, f, g, x, y, rde)
          palgRDE1(nfp, g, x, y)
        palgRDE0(f, g, x, y, rde, u.coef, u.poly)
      palgRDE0(f, g, x, y, rde, dumk, v.xsub, v.dxsub)

    -- returns "failed", or (d, P) such that (dy)**2 = P(x)
    -- and degree(P) = 2
    quadIfCan(x, y) ==
      (degree(p := minPoly y) = 2) and zero?(coefficient(p, 1)) =>
        d := denom(ff :=
                 univariate(- coefficient(p, 0) / coefficient(p, 2), x))
        degree(radi := d * numer ff) = 2 => [d(x::F), radi]
        "failed"
      "failed"

    if L has LinearOrdinaryDifferentialOperatorCategory F then
      palgLODE(eq, g, kx, y, x) ==
        (v := linearInXIfCan(kx, y)) case "failed" =>
          (u := quadIfCan(kx, y)) case "failed" =>
            palgLODE1([coefficient(eq, i) for i in 0..degree eq], g, kx, y, x)
          palgLODE0(eq, g, kx, y, u.coef, u.poly)
        palgLODE0(eq, g, kx, y, dumk, v.xsub, v.dxsub)

@
<<INTPAF.dotabb>>=
"INTPAF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTPAF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"INTPAF" -> "FS"
"INTPAF" -> "ACF"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODEPAL PureAlgebraicLODE}
\pagehead{PureAlgebraicLODE}{ODEPAL}
\pagepic{ps/v104purealgebraiclode.ps}{ODEPAL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODEPAL PureAlgebraicLODE>>=
)abbrev package ODEPAL PureAlgebraicLODE
++ Author: Manuel Bronstein
++ Date Created: 21 August 1991
++ Date Last Updated: 3 February 1994
++ Description: In-field solution of an linear ordinary differential equation,
++ pure algebraic case.
PureAlgebraicLODE(F, UP, UPUP, R): Exports == Implementation where
  F   : Join(Field, CharacteristicZero,
             RetractableTo Integer, RetractableTo Fraction Integer)
  UP  : UnivariatePolynomialCategory F
  UPUP: UnivariatePolynomialCategory Fraction UP
  R   : FunctionFieldCategory(F, UP, UPUP)

  RF  ==> Fraction UP
  V   ==> Vector RF
  U   ==> Union(R, "failed")
  REC ==> Record(particular: Union(RF, "failed"), basis: List RF)
  L   ==> LinearOrdinaryDifferentialOperator1 R
  LQ  ==> LinearOrdinaryDifferentialOperator1 RF

  Exports ==> with
    algDsolve: (L, R) -> Record(particular: U, basis: List R)
      ++ algDsolve(op, g) returns \spad{["failed", []]} if the equation
      ++ \spad{op y = g} has no solution in \spad{R}. Otherwise, it returns
      ++ \spad{[f, [y1,...,ym]]} where \spad{f} is a particular rational
      ++ solution and the \spad{y_i's} form a basis for the solutions in
      ++ \spad{R} of the homogeneous equation.

  Implementation ==> add
    import RationalLODE(F, UP)
    import SystemODESolver(RF, LQ)
    import ReduceLODE(RF, LQ, UPUP, R, L)

    algDsolve(l, g) ==
      rec := reduceLODE(l, g)
      sol := solveInField(rec.mat, rec.vec, ratDsolve)
      bas:List(R) := [represents v for v in sol.basis]
      (u := sol.particular) case V => [represents(u::V), bas]
      ["failed", bas]

@
<<ODEPAL.dotabb>>=
"ODEPAL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODEPAL"]
"FFCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FFCAT"]
"ODEPAL" -> "FFCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PUSHVAR PushVariables}
\pagehead{PushVariables}{PUSHVAR}
\pagepic{ps/v104pushvariables.ps}{PUSHVAR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PUSHVAR PushVariables>>=
)abbrev package PUSHVAR PushVariables
++ This package \undocumented{}
PushVariables(R,E,OV,PPR):C == T where
   E : OrderedAbelianMonoidSup
   OV: OrderedSet with
        convert: % -> Symbol
	  ++ convert(x) converts x to a symbol
        variable: Symbol -> Union(%, "failed")
	  ++ variable(s) makes an element from symbol s or fails
   R  : Ring
   PR ==> Polynomial R
   PPR: PolynomialCategory(PR,E,OV)
   SUP ==> SparseUnivariatePolynomial
   C == with
     pushdown : (PPR, OV) -> PPR
	++ pushdown(p,v) \undocumented{}
     pushdown : (PPR, List OV) -> PPR
	++ pushdown(p,lv) \undocumented{}
     pushup   : (PPR, OV) -> PPR
	++ pushup(p,v) \undocumented{}
     pushup   : (PPR, List OV) -> PPR
	++ pushup(p,lv) \undocumented{}
     map      : ((PR -> PPR), PPR) -> PPR
	++ map(f,p) \undocumented{}

   T == add
     pushdown(g:PPR,x:OV) : PPR ==
       eval(g,x,monomial(1,convert x,1)$PR)

     pushdown(g:PPR, lv:List OV) : PPR ==
       vals:=[monomial(1,convert x,1)$PR for x in lv]
       eval(g,lv,vals)

     map(f:(PR -> PPR), p: PPR) : PPR ==
       ground? p => f(retract p)
       v:=mainVariable(p)::OV
       multivariate(map(map(f,#1),univariate(p,v)),v)

               ----  push back the variable  ----
     pushupCoef(c:PR, lv:List OV): PPR ==
       ground? c => c::PPR
       v:=mainVariable(c)::Symbol
       v2 := variable(v)$OV
       uc := univariate(c,v)
       ppr : PPR := 0
       v2 case OV =>
          while not zero? uc repeat
             ppr := ppr + monomial(1,v2,degree(uc))$PPR *
                            pushupCoef(leadingCoefficient uc, lv)
             uc := reductum uc
          ppr
       while not zero? uc repeat
          ppr := ppr + monomial(1,v,degree(uc))$PR *
                            pushupCoef(leadingCoefficient uc, lv)
          uc := reductum uc
       ppr

     pushup(f:PPR,x:OV) :PPR ==
       map(pushupCoef(#1,[x]), f)

     pushup(g:PPR, lv:List OV) : PPR ==
       map(pushupCoef(#1, lv), g)

@
<<PUSHVAR.dotabb>>=
"PUSHVAR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PUSHVAR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"PUSHVAR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Q}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package QFCAT2 QuotientFieldCategoryFunctions2}
\pagehead{QuotientFieldCategoryFunctions2}{QFCAT2}
\pagepic{ps/v104quotientfieldcategoryfunctions2.ps}{QFCAT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package QFCAT2 QuotientFieldCategoryFunctions2>>=
)abbrev package QFCAT2 QuotientFieldCategoryFunctions2
++ Author:
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package extends a function between integral domains
++ to a mapping between their quotient fields.
QuotientFieldCategoryFunctions2(A, B, R, S): Exports == Impl where
  A, B: IntegralDomain
  R   : QuotientFieldCategory(A)
  S   : QuotientFieldCategory(B)

  Exports ==> with
    map: (A -> B, R) -> S
      ++ map(func,frac) applies the function func to the numerator
      ++ and denominator of frac.

  Impl ==> add
    map(f, r) == f(numer r) / f(denom r)

@
<<QFCAT2.dotabb>>=
"QFCAT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=QFCAT2"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"QFCAT2" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter R}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DEFINTRF RationalFunctionDefiniteIntegration}
\pagehead{RationalFunctionDefiniteIntegration}{DEFINTRF}
\pagepic{ps/v104rationalfunctiondefiniteintegration.ps}{DEFINTRF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DEFINTRF RationalFunctionDefiniteIntegration>>=
)abbrev package DEFINTRF RationalFunctionDefiniteIntegration
++ Definite integration of rational functions.
++ Author: Manuel Bronstein
++ Date Created: 2 October 1989
++ Date Last Updated: 2 February 1993
++ Description:
++   \spadtype{RationalFunctionDefiniteIntegration} provides functions to
++   compute definite integrals of rational functions.


RationalFunctionDefiniteIntegration(R): Exports == Implementation where
  R : Join(EuclideanDomain, OrderedSet, CharacteristicZero,
           RetractableTo Integer, LinearlyExplicitRingOver Integer)

  SE  ==> Symbol
  RF  ==> Fraction Polynomial R
  FE  ==> Expression R
  ORF ==> OrderedCompletion RF
  OFE ==> OrderedCompletion FE
  U   ==> Union(f1:OFE, f2:List OFE, fail:"failed", pole:"potentialPole")

  Exports ==> with
    integrate: (RF, SegmentBinding OFE) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (RF, SegmentBinding OFE, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".
-- the following two are contained in the above, but they are for the
-- interpreter... DO NOT COMMENT OUT UNTIL THE INTERPRETER IS BETTER!
    integrate: (RF, SegmentBinding ORF) -> U
      ++ integrate(f, x = a..b) returns the integral of
      ++ \spad{f(x)dx} from a to b.
      ++ Error: if f has a pole for x between a and b.
    integrate: (RF, SegmentBinding ORF, String) -> U
      ++ integrate(f, x = a..b, "noPole") returns the
      ++ integral of \spad{f(x)dx} from a to b.
      ++ If it is not possible to check whether f has a pole for x
      ++ between a and b (because of parameters), then this function
      ++ will assume that f has no such pole.
      ++ Error: if f has a pole for x between a and b or
      ++ if the last argument is not "noPole".

  Implementation ==> add
    import DefiniteIntegrationTools(R, FE)
    import IntegrationResultRFToFunction(R)
    import OrderedCompletionFunctions2(RF, FE)

    int   : (RF, SE, OFE, OFE, Boolean) -> U
    nopole: (RF, SE, OFE, OFE) -> U

    integrate(f:RF, s:SegmentBinding OFE) ==
      int(f, variable s, lo segment s, hi segment s, false)

    nopole(f, x, a, b) ==
      k := kernel(x)@Kernel(FE)
      (u := integrate(f, x)) case FE =>
        (v := computeInt(k, u::FE, a, b, true)) case "failed" => ["failed"]
        [v::OFE]
      ans := empty()$List(OFE)
      for g in u::List(FE) repeat
        (v := computeInt(k, g, a, b, true)) case "failed" => return ["failed"]
        ans := concat_!(ans, [v::OFE])
      [ans]

    integrate(f:RF, s:SegmentBinding ORF) ==
      int(f, variable s, map(#1::FE, lo segment s),
                         map(#1::FE, hi segment s), false)

    integrate(f:RF, s:SegmentBinding ORF, str:String) ==
      int(f, variable s, map(#1::FE, lo segment s),
                         map(#1::FE, hi segment s), ignore? str)

    integrate(f:RF, s:SegmentBinding OFE, str:String) ==
      int(f, variable s, lo segment s, hi segment s, ignore? str)

    int(f, x, a, b, ignor?) ==
      a = b => [0::OFE]
      (z := checkForZero(denom f, x, a, b, true)) case "failed" =>
        ignor? => nopole(f, x, a, b)
        ["potentialPole"]
      z::Boolean => error "integrate: pole in path of integration"
      nopole(f, x, a, b)

@
<<DEFINTRF.dotabb>>=
"DEFINTRF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DEFINTRF"]
"ACFS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACFS"]
"DEFINTRF" -> "ACFS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACT RationalFunctionFactor}
\pagehead{RationalFunctionFactor}{RFFACT}
\pagepic{ps/v104rationalfunctionfactor.ps}{RFFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACT RationalFunctionFactor>>=
)abbrev package RFFACT RationalFunctionFactor
++ Factorisation in UP FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients which
++ are rational functions with integer coefficients.

RationalFunctionFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory Fraction Polynomial Integer
 
  SE ==> Symbol
  P  ==> Polynomial Integer
  RF ==> Fraction P
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2
 
  Exports ==> with
    factor: UP -> Factored UP
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    likuniv: (P, SE, P) -> UP
 
    dummy := new()$SE
 
    likuniv(p, x, d) ==
      map(#1 / d, univariate(p, x))$UPCF2(P,SparseUnivariatePolynomial P,
                                          RF, UP)
 
    factor p ==
      d  := denom(q := elt(p,dummy::P :: RF))
      map(likuniv(#1,dummy,d),
          factor(numer q)$MultivariateFactorize(SE,
               IndexedExponents SE,Integer,P))$FactoredFunctions2(P, UP)

@
<<RFFACT.dotabb>>=
"RFFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACTOR RationalFunctionFactorizer}
\pagehead{RationalFunctionFactorizer}{RFFACTOR}
\pagepic{ps/v104rationalfunctionfactorizer.ps}{RFFACTOR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACTOR RationalFunctionFactorizer>>=
)abbrev package RFFACTOR RationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: Fraction, Polynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype{RationalFunctionFactorizer} contains the factor function
++ (called factorFraction) which factors fractions of polynomials by factoring
++ the numerator and denominator. Since any non zero fraction is a unit
++ the usual factor operation will just return the original fraction.

RationalFunctionFactorizer(R) : C == T
 where
  R  :    EuclideanDomain  -- R with factor for R[X]
  P  ==>  Polynomial R
  FP ==>  Fraction P
  SE ==>  Symbol

  C  == with
     factorFraction    : FP  ->   Fraction Factored(P)
       ++ factorFraction(r) factors the numerator and the denominator of
       ++ the polynomial fraction r.
  T  == add

     factorFraction(p:FP) : Fraction Factored(P) ==
       R is Fraction Integer =>
         MR:=MRationalFactorize(IndexedExponents SE,SE,
                                Integer,P)
         (factor(numer p)$MR)/ (factor(denom p)$MR)

       R has FiniteFieldCategory =>
         FF:=MultFiniteFactorize(SE,IndexedExponents SE,R,P)
         (factor(numer p))$FF/(factor(denom p))$FF

       R has CharacteristicZero =>
          MFF:=MultivariateFactorize(SE,IndexedExponents SE,R,P)
          (factor(numer p))$MFF/(factor(denom p))$MFF
       error "case not handled"

@
<<RFFACTOR.dotabb>>=
"RFFACTOR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACTOR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"RFFACTOR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTRF RationalFunctionIntegration}
\pagehead{RationalFunctionIntegration}{INTRF}
\pagepic{ps/v104rationalfunctionintegration.ps}{INTRF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTRF RationalFunctionIntegration>>=
)abbrev package INTRF RationalFunctionIntegration
++ Integration of rational functions
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 29 Mar 1990
++ Keywords: polynomial, fraction, integration.
++ Description:
++   This package provides functions for the integration
++   of rational functions.
++ Examples: )r INTRF INPUT
RationalFunctionIntegration(F): Exports == Implementation where
  F: Join(IntegralDomain, RetractableTo Integer, CharacteristicZero)

  SE  ==> Symbol
  P   ==> Polynomial F
  Q   ==> Fraction P
  UP  ==> SparseUnivariatePolynomial Q
  QF  ==> Fraction UP
  LGQ ==> List Record(coeff:Q, logand:Q)
  UQ  ==> Union(Record(ratpart:Q, coeff:Q), "failed")
  ULQ ==> Union(Record(mainpart:Q, limitedlogs:LGQ), "failed")

  Exports ==> with
    internalIntegrate: (Q, SE) -> IntegrationResult Q
       ++ internalIntegrate(f, x) returns g such that \spad{dg/dx = f}.
    infieldIntegrate : (Q, SE) -> Union(Q, "failed")
       ++ infieldIntegrate(f, x) returns a fraction
       ++ g such that \spad{dg/dx = f}
       ++ if g exists, "failed" otherwise.
    limitedIntegrate : (Q, SE, List Q) -> ULQ
       ++ \spad{limitedIntegrate(f, x, [g1,...,gn])} returns fractions
       ++ \spad{[h, [[ci,gi]]]} such that the gi's are among
       ++ \spad{[g1,...,gn]},
       ++ \spad{dci/dx = 0}, and  \spad{d(h + sum(ci log(gi)))/dx = f}
       ++ if possible, "failed" otherwise.
    extendedIntegrate: (Q, SE, Q) -> UQ
       ++ extendedIntegrate(f, x, g) returns fractions \spad{[h, c]} such that
       ++ \spad{dc/dx = 0} and \spad{dh/dx = f - cg}, if \spad{(h, c)} exist,
       ++ "failed" otherwise.

  Implementation ==> add
    import RationalIntegration(Q, UP)
    import IntegrationResultFunctions2(QF, Q)
    import PolynomialCategoryQuotientFunctions(IndexedExponents SE,
                                                       SE, F, P, Q)

    infieldIntegrate(f, x) ==
      map(multivariate(#1, x), infieldint univariate(f, x))

    internalIntegrate(f, x) ==
      map(multivariate(#1, x), integrate univariate(f, x))

    extendedIntegrate(f, x, g) ==
      map(multivariate(#1, x),
          extendedint(univariate(f, x), univariate(g, x)))

    limitedIntegrate(f, x, lu) ==
      map(multivariate(#1, x),
          limitedint(univariate(f, x), [univariate(u, x) for u in lu]))

@
<<INTRF.dotabb>>=
"INTRF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTRF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INTRF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTRAT RationalIntegration}
\pagehead{RationalIntegration}{INTRAT}
\pagepic{ps/v104rationalintegration.ps}{INTRAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTRAT RationalIntegration>>=
)abbrev package INTRAT RationalIntegration
++ Rational function integration
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 24 October 1995
++ Description:
++   This package provides functions for the base
++   case of the Risch algorithm.
-- Used internally bt the integration packages
RationalIntegration(F, UP): Exports == Implementation where
  F : Join(Field, CharacteristicZero, RetractableTo Integer)
  UP: UnivariatePolynomialCategory F

  RF  ==> Fraction UP
  IR  ==> IntegrationResult RF
  LLG ==> List Record(coeff:RF, logand:RF)
  URF ==> Union(Record(ratpart:RF, coeff:RF), "failed")
  U   ==> Union(Record(mainpart:RF, limitedlogs:LLG), "failed")

  Exports ==> with
    integrate  : RF -> IR
      ++ integrate(f) returns g such that \spad{g' = f}.
    infieldint : RF -> Union(RF, "failed")
      ++ infieldint(f) returns g such that \spad{g' = f} or "failed"
      ++ if the integral of f is not a rational function.
    extendedint: (RF, RF) -> URF
       ++ extendedint(f, g) returns fractions \spad{[h, c]} such that
       ++ \spad{c' = 0} and \spad{h' = f - cg},
       ++ if \spad{(h, c)} exist, "failed" otherwise.
    limitedint : (RF, List RF) -> U
       ++ \spad{limitedint(f, [g1,...,gn])} returns
       ++ fractions \spad{[h,[[ci, gi]]]}
       ++ such that the gi's are among \spad{[g1,...,gn]}, \spad{ci' = 0}, and
       ++ \spad{(h+sum(ci log(gi)))' = f}, if possible, "failed" otherwise.

  Implementation ==> add
    import TranscendentalIntegration(F, UP)

    infieldint f ==
      rec := baseRDE(0, f)$TranscendentalRischDE(F, UP)
      rec.nosol => "failed"
      rec.ans

    integrate f ==
      rec := monomialIntegrate(f, differentiate)
      integrate(rec.polypart)::RF::IR + rec.ir

    limitedint(f, lu) ==
      quorem := divide(numer f, denom f)
      (u := primlimintfrac(quorem.remainder / (denom f), differentiate,
        lu)) case "failed" => "failed"
      [u.mainpart + integrate(quorem.quotient)::RF, u.limitedlogs]

    extendedint(f, g) ==
      fqr := divide(numer f, denom f)
      gqr := divide(numer g, denom g)
      (i1 := primextintfrac(fqr.remainder / (denom f), differentiate,
                   gqr.remainder / (denom g))) case "failed" => "failed"
      i2:=integrate(fqr.quotient-retract(i1.coeff)@UP *gqr.quotient)::RF
      [i2 + i1.ratpart, i1.coeff]

@
<<INTRAT.dotabb>>=
"INTRAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTRAT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INTRAT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODERAT RationalLODE}
\pagehead{RationalLODE}{ODERAT}
\pagepic{ps/v104rationallode.ps}{ODERAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODERAT RationalLODE>>=
)abbrev package ODERAT RationalLODE
++ Author: Manuel Bronstein
++ Date Created: 13 March 1991
++ Date Last Updated: 13 April 1994
++ Description:
++  \spad{RationalLODE} provides functions for in-field solutions of linear
++   ordinary differential equations, in the rational case.
RationalLODE(F, UP): Exports == Implementation where
  F  : Join(Field, CharacteristicZero, RetractableTo Integer,
                                       RetractableTo Fraction Integer)
  UP : UnivariatePolynomialCategory F

  N   ==> NonNegativeInteger
  Z   ==> Integer
  RF  ==> Fraction UP
  U   ==> Union(RF, "failed")
  V   ==> Vector F
  M   ==> Matrix F
  LODO ==> LinearOrdinaryDifferentialOperator1 RF
  LODO2==> LinearOrdinaryDifferentialOperator2(UP, RF)

  Exports ==> with
    ratDsolve: (LODO, RF) -> Record(particular: U, basis: List RF)
      ++ ratDsolve(op, g) returns \spad{["failed", []]} if the equation
      ++ \spad{op y = g} has no rational solution. Otherwise, it returns
      ++ \spad{[f, [y1,...,ym]]} where f is a particular rational solution
      ++ and the yi's form a basis for the rational solutions of the
      ++ homogeneous equation.
    ratDsolve: (LODO, List RF) -> Record(basis:List RF, mat:Matrix F)
      ++ ratDsolve(op, [g1,...,gm]) returns \spad{[[h1,...,hq], M]} such
      ++ that any rational solution of \spad{op y = c1 g1 + ... + cm gm}
      ++ is of the form \spad{d1 h1 + ... + dq hq} where
      ++ \spad{M [d1,...,dq,c1,...,cm] = 0}.
    ratDsolve: (LODO2, RF) -> Record(particular: U, basis: List RF)
      ++ ratDsolve(op, g) returns \spad{["failed", []]} if the equation
      ++ \spad{op y = g} has no rational solution. Otherwise, it returns
      ++ \spad{[f, [y1,...,ym]]} where f is a particular rational solution
      ++ and the yi's form a basis for the rational solutions of the
      ++ homogeneous equation.
    ratDsolve: (LODO2, List RF) -> Record(basis:List RF, mat:Matrix F)
      ++ ratDsolve(op, [g1,...,gm]) returns \spad{[[h1,...,hq], M]} such
      ++ that any rational solution of \spad{op y = c1 g1 + ... + cm gm}
      ++ is of the form \spad{d1 h1 + ... + dq hq} where
      ++ \spad{M [d1,...,dq,c1,...,cm] = 0}.
    indicialEquationAtInfinity: LODO -> UP
      ++ indicialEquationAtInfinity op returns the indicial equation of
      ++ \spad{op} at infinity.
    indicialEquationAtInfinity: LODO2 -> UP
      ++ indicialEquationAtInfinity op returns the indicial equation of
      ++ \spad{op} at infinity.

  Implementation ==> add
    import BoundIntegerRoots(F, UP)
    import RationalIntegration(F, UP)
    import PrimitiveRatDE(F, UP, LODO2, LODO)
    import LinearSystemMatrixPackage(F, V, V, M)
    import InnerCommonDenominator(UP, RF, List UP, List RF)

    nzero?             : V -> Boolean
    evenodd            : N -> F
    UPfact             : N -> UP
    infOrder           : RF -> Z
    infTau             : (UP, N) -> F
    infBound           : (LODO2, List RF) -> N
    regularPoint       : (LODO2, List RF) -> Z
    infIndicialEquation: (List N, List UP) -> UP
    makeDot            : (Vector F, List RF) -> RF
    unitlist           : (N, N) -> List F
    infMuLambda: LODO2 -> Record(mu:Z, lambda:List N, func:List UP)
    ratDsolve0: (LODO2, RF) -> Record(particular: U, basis: List RF)
    ratDsolve1: (LODO2, List RF) -> Record(basis:List RF, mat:Matrix F)
    candidates: (LODO2,List RF,UP) -> Record(basis:List RF,particular:List RF)

    dummy := new()$Symbol

    infOrder f == (degree denom f) - (degree numer f)
    evenodd n  == (even? n => 1; -1)

    ratDsolve1(op, lg) ==
      d := denomLODE(op, lg)
      rec := candidates(op, lg, d)
      l := concat([op q for q in rec.basis],
                  [op(rec.particular.i) - lg.i for i in 1..#(rec.particular)])
      sys1 := reducedSystem(matrix [l])@Matrix(UP)
      [rec.basis, reducedSystem sys1]

    ratDsolve0(op, g) ==
      zero? degree op => [inv(leadingCoefficient(op)::RF) * g, empty()]
      minimumDegree op > 0 =>
        sol := ratDsolve0(monicRightDivide(op, monomial(1, 1)).quotient, g)
        b:List(RF) := [1]
        for f in sol.basis repeat
          if (uu := infieldint f) case RF then b := concat(uu::RF, b)
        sol.particular case "failed" => ["failed", b]
        [infieldint(sol.particular::RF), b]
      (u := denomLODE(op, g)) case "failed" => ["failed", empty()]
      rec := candidates(op, [g], u::UP)
      l := lb := lsol := empty()$List(RF)
      for q in rec.basis repeat
          if zero?(opq := op q) then lsol := concat(q, lsol)
          else (l := concat(opq, l); lb := concat(q, lb))
      h:RF := (zero? g => 0; first(rec.particular))
      empty? l =>
          zero? g => [0, lsol]
          [(g = op h => h; "failed"), lsol]
      m:M
      v:V
      if zero? g then
          m := reducedSystem(reducedSystem(matrix [l])@Matrix(UP))@M
          v := new(ncols m, 0)$V
      else
          sys1 := reducedSystem(matrix [l], vector [g - op h]
                               )@Record(mat: Matrix UP, vec: Vector UP)
          sys2 := reducedSystem(sys1.mat, sys1.vec)@Record(mat:M, vec:V)
          m := sys2.mat
          v := sys2.vec
      sol := solve(m, v)
      part:U :=
        zero? g => 0
        sol.particular case "failed" => "failed"
        makeDot(sol.particular::V, lb) + first(rec.particular)
      [part,
       concat_!(lsol, [makeDot(v, lb) for v in sol.basis | nzero? v])]

    indicialEquationAtInfinity(op:LODO2) ==
      rec := infMuLambda op
      infIndicialEquation(rec.lambda, rec.func)

    indicialEquationAtInfinity(op:LODO) ==
      rec := splitDenominator(op, empty())
      indicialEquationAtInfinity(rec.eq)

    regularPoint(l, lg) ==
      a := leadingCoefficient(l) * commonDenominator lg
      coefficient(a, 0) ^= 0 => 0
      for i in 1.. repeat
        a(j := i::F) ^= 0 => return i
        a(-j) ^= 0 => return(-i)

    unitlist(i, q) ==
      v := new(q, 0)$Vector(F)
      v.i := 1
      parts v

    candidates(op, lg, d) ==
      n := degree d + infBound(op, lg)
      m := regularPoint(op, lg)
      uts := UnivariateTaylorSeries(F, dummy, m::F)
      tools := UTSodetools(F, UP, LODO2, uts)
      solver := UnivariateTaylorSeriesODESolver(F, uts)
      dd := UP2UTS(d)$tools
      f := LODO2FUN(op)$tools
      q := degree op
      e := unitlist(1, q)
      hom := [UTS2UP(dd * ode(f, unitlist(i, q))$solver, n)$tools /$RF d
                   for i in 1..q]$List(RF)
      a1 := inv(leadingCoefficient(op)::RF)
      part := [UTS2UP(dd * ode(RF2UTS(a1 * g)$tools + f #1, e)$solver, n)$tools
                /$RF d for g in lg | g ^= 0]$List(RF)
      [hom, part]

    nzero? v ==
      for i in minIndex v .. maxIndex v repeat
        not zero? qelt(v, i) => return true
      false

-- returns z(z+1)...(z+(n-1))
    UPfact n ==
      zero? n => 1
      z := monomial(1, 1)$UP
      */[z + i::F::UP for i in 0..(n-1)::N]

    infMuLambda l ==
      lamb:List(N) := [d := degree l]
      lf:List(UP) := [a := leadingCoefficient l]
      mup := degree(a)::Z - d
      while (l := reductum l) ^= 0 repeat
          a := leadingCoefficient l
          if (m := degree(a)::Z - (d := degree l)) > mup then
            mup := m
            lamb := [d]
            lf := [a]
          else if (m = mup) then
            lamb := concat(d, lamb)
            lf := concat(a, lf)
      [mup, lamb, lf]

    infIndicialEquation(lambda, lf) ==
      ans:UP := 0
      for i in lambda for f in lf repeat
        ans := ans + evenodd i * leadingCoefficient f * UPfact i
      ans

    infBound(l, lg) ==
      rec := infMuLambda l
      n := min(- degree(l)::Z - 1,
               integerBound infIndicialEquation(rec.lambda, rec.func))
      while not(empty? lg) and zero? first lg repeat lg := rest lg
      empty? lg => (-n)::N
      m := infOrder first lg
      for g in rest lg repeat
        if not(zero? g) and (mm := infOrder g) < m then m := mm
      (-min(n, rec.mu - degree(leadingCoefficient l)::Z + m))::N

    makeDot(v, bas) ==
      ans:RF := 0
      for i in 1.. for b in bas repeat ans := ans + v.i::UP * b
      ans

    ratDsolve(op:LODO, g:RF) ==
      rec := splitDenominator(op, [g])
      ratDsolve0(rec.eq, first(rec.rh))

    ratDsolve(op:LODO, lg:List RF) ==
      rec := splitDenominator(op, lg)
      ratDsolve1(rec.eq, rec.rh)

    ratDsolve(op:LODO2, g:RF) ==
      unit?(c := content op) => ratDsolve0(op, g)
      ratDsolve0((op exquo c)::LODO2, inv(c::RF) * g)

    ratDsolve(op:LODO2, lg:List RF) ==
      unit?(c := content op) => ratDsolve1(op, lg)
      ratDsolve1((op exquo c)::LODO2, [inv(c::RF) * g for g in lg])

@
<<ODERAT.dotabb>>=
"ODERAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODERAT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"ODERAT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REALSOLV RealSolvePackage}
<<RealSolvePackage.input>>=
-- acplot.spad.pamphlet RealSolvePackage.input
)sys rm RealSolvePackage.output
)spool RealSolvePackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 13
p := 4*x^3 - 3*x^2 + 2*x - 4
--R 
--R
--R          3     2
--R   (1)  4x  - 3x  + 2x - 4
--R                                                     Type: Polynomial Integer
--E 1

--S 2 of 13
ans1 := solve(p,0.01)$REALSOLV
--R 
--R
--R   (2)  [1.11328125]
--R                                                             Type: List Float
--E 2

--S 3 of 13
ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV
--R 
--R
--R   (3)  [1.11328125]
--R                                                             Type: List Float
--E 3

--S 4 of 13
R := Integer
--R 
--R
--R   (4)  Integer
--R                                                                 Type: Domain
--E 4

--S 5 of 13
ls : List Symbol := [x,y,z,t]
--R 
--R
--R   (5)  [x,y,z,t]
--R                                                            Type: List Symbol
--E 5

--S 6 of 13
ls2 : List Symbol := [x,y,z,t,new()$Symbol]
--R 
--R
--R   (6)  [x,y,z,t,%A]
--R                                                            Type: List Symbol
--E 6

--S 7 of 13
pack := ZDSOLVE(R,ls,ls2)
--R 
--R
--R   (7)  ZeroDimensionalSolvePackage(Integer,[x,y,z,t],[x,y,z,t,%A])
--R                                                                 Type: Domain
--E 7

--S 8 of 13
p1 := x**2*y*z + y*z
--R 
--R
--R          2
--R   (8)  (x  + 1)y z
--R                                                     Type: Polynomial Integer
--E 8

--S 9 of 13
p2 := x**2*y**2*z + x + z
--R 
--R
--R          2 2
--R   (9)  (x y  + 1)z + x
--R                                                     Type: Polynomial Integer
--E 9

--S 10 of 13
p3 := x**2*y**2*z**2 +  z + 1
--R 
--R
--R          2 2 2
--R   (10)  x y z  + z + 1
--R                                                     Type: Polynomial Integer
--E 10

--S 11 of 13
lp := [p1, p2, p3]
--R 
--R
--R            2           2 2            2 2 2
--R   (11)  [(x  + 1)y z,(x y  + 1)z + x,x y z  + z + 1]
--R                                                Type: List Polynomial Integer
--E 11

--S 12 of 13
lsv:List(Symbol):=[x,y,z]
--R 
--R
--R   (12)  [x,y,z]
--R                                                            Type: List Symbol
--E 12

--S 13 of 13
ans3 := realSolve(lp,lsv,0.01)$REALSOLV
--R 
--R
--R   (13)  [[1.0,0.0,- 1.0]]
--R                                                        Type: List List Float
--E 13
)spool

@
<<RealSolvePackage.help>>=
====================================================================
RealSolvePackage examples
====================================================================

  p := 4*x^3 - 3*x^2 + 2*x - 4

  ans1 := solve(p,0.01)$REALSOLV

  ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV

  R := Integer

  ls : List Symbol := [x,y,z,t]

  ls2 : List Symbol := [x,y,z,t,new()$Symbol]

  pack := ZDSOLVE(R,ls,ls2)

  p1 := x**2*y*z + y*z

  p2 := x**2*y**2*z + x + z

  p3 := x**2*y**2*z**2 +  z + 1

  lp := [p1, p2, p3]

  ans3 := realSolve(lp,[x,y,z],0.01)

See Also:
o )show RealSolvePackage

@
\pagehead{RealSolvePackage}{REALSOLV}
\pagepic{ps/v104realsolvepackage.ps}{REALSOLV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REALSOLV RealSolvePackage>>=
)abbrev package REALSOLV RealSolvePackage

RealSolvePackage(): _
  with

    solve: (Polynomial Fraction Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a
      ++ univariate rational polynomial p with precision eps.

    solve: (Polynomial Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a univariate
      ++ integer polynomial p with precision eps.

    realSolve: (List Polynomial Integer,List Symbol,Float) -> List List Float
      ++ realSolve(lp,lv,eps) = compute the list of the real
      ++ solutions of the list lp of polynomials with integer
      ++ coefficients with respect to the variables in lv,
      ++ with precision eps.

  ==  add

    prn2rfi: Polynomial Fraction Integer -> Fraction Polynomial Integer
    prn2rfi p ==
      map(#1 :: Fraction Polynomial Integer,_
          (numer(#1) :: Fraction Polynomial Integer)_
            /(denom(#1) :: Fraction Polynomial Integer),p)_
             $PolynomialCategoryLifting(IndexedExponents Symbol, _
               Symbol, _
               Fraction Integer, _
               Polynomial Fraction Integer, _
               Fraction Polynomial Integer)

    pi2rfi: Polynomial Integer -> Fraction Polynomial Integer
    pi2rfi p == p :: Fraction Polynomial Integer

    solve(p:Polynomial Fraction Integer,eps:Float) == 
      realRoots(prn2rfi p,eps)$(FloatingRealPackage(Float))

    solve(p:Polynomial Integer,eps:Float) ==
      realRoots(p :: Fraction Polynomial Integer,eps)_
       $(FloatingRealPackage(Float))

    realSolve(lp,lv,eps) ==
      realRoots(map(pi2rfi,lp)_
       $ListFunctions2(Polynomial Integer,Fraction Polynomial Integer),lv,eps)_
        $(FloatingRealPackage(Float))



@
<<REALSOLV.dotabb>>=
"REALSOLV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REALSOLV"]
"REALSOLV" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RMCAT2 RectangularMatrixCategoryFunctions2}
\pagehead{RectangularMatrixCategoryFunctions2}{RMCAT2}
\pagepic{ps/v104rectangularmatrixcategoryfunctions2.ps}{RMCAT2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RMCAT2 RectangularMatrixCategoryFunctions2>>=
)abbrev package RMCAT2 RectangularMatrixCategoryFunctions2
++ Author: Clifton J. Williamson
++ Date Created: 21 November 1989
++ Date Last Updated: 12 June 1991
++ Basic Operations:
++ Related Domains: IndexedMatrix(R,minRow,minCol), Matrix(R),
++    RectangularMatrix(n,m,R), SquareMatrix(n,R)
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Keywords: matrix, map, reduce
++ Examples:
++ References:
++ Description:
++ \spadtype{RectangularMatrixCategoryFunctions2} provides functions between
++ two matrix domains.  The functions provided are \spadfun{map} and \spadfun{reduce}.

RectangularMatrixCategoryFunctions2(m,n,R1,Row1,Col1,M1,R2,Row2,Col2,M2):_
         Exports == Implementation where
  m,n  : NonNegativeInteger
  R1   : Ring
  Row1 : DirectProductCategory(n, R1)
  Col1 : DirectProductCategory(m, R1)
  M1   : RectangularMatrixCategory(m,n,R1,Row1,Col1)
  R2   : Ring
  Row2 : DirectProductCategory(n, R2)
  Col2 : DirectProductCategory(m, R2)
  M2   : RectangularMatrixCategory(m,n,R2,Row2,Col2)

  Exports ==> with
    map: (R1 -> R2,M1) -> M2
      ++ \spad{map(f,m)} applies the function \spad{f} to the elements of the
      ++ matrix \spad{m}.
    reduce: ((R1,R2) -> R2,M1,R2) -> R2
      ++ \spad{reduce(f,m,r)} returns a matrix \spad{n} where
      ++ \spad{n[i,j] = f(m[i,j],r)} for all indices spad{i} and \spad{j}.

  Implementation ==> add
    minr ==> minRowIndex
    maxr ==> maxRowIndex
    minc ==> minColIndex
    maxc ==> maxColIndex

    map(f,mat) ==
      ans : M2 := new(m,n,0)$Matrix(R2) pretend M2
      for i in minr(mat)..maxr(mat) for k in minr(ans)..maxr(ans) repeat
        for j in minc(mat)..maxc(mat) for l in minc(ans)..maxc(ans) repeat
          qsetelt_!(ans pretend Matrix R2,k,l,f qelt(mat,i,j))
      ans

    reduce(f,mat,ident) ==
      s := ident
      for i in minr(mat)..maxr(mat) repeat
       for j in minc(mat)..maxc(mat) repeat
         s := f(qelt(mat,i,j),s)
      s

@
<<RMCAT2.dotabb>>=
"RMCAT2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RMCAT2"]
"RMATCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RMATCAT"]
"RMCAT2" -> "RMATCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODERED ReduceLODE}
\pagehead{ReduceLODE}{ODERED}
\pagepic{ps/v104reducelode.ps}{ODERED}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODERED ReduceLODE>>=
)abbrev package ODERED ReduceLODE
++ Author: Manuel Bronstein
++ Date Created: 19 August 1991
++ Date Last Updated: 11 April 1994
++ Description: Elimination of an algebraic from the coefficentss
++ of a linear ordinary differential equation.
ReduceLODE(F, L, UP, A, LO): Exports == Implementation where
  F : Field
  L : LinearOrdinaryDifferentialOperatorCategory F
  UP: UnivariatePolynomialCategory F
  A : MonogenicAlgebra(F, UP)
  LO: LinearOrdinaryDifferentialOperatorCategory A

  V ==> Vector F
  M ==> Matrix L

  Exports ==> with
    reduceLODE: (LO, A) -> Record(mat:M, vec:V)
      ++ reduceLODE(op, g) returns \spad{[m, v]} such that
      ++ any solution in \spad{A} of \spad{op z = g}
      ++ is of the form \spad{z = (z_1,...,z_m) . (b_1,...,b_m)} where
      ++ the \spad{b_i's} are the basis of \spad{A} over \spad{F} returned
      ++ by \spadfun{basis}() from \spad{A}, and the \spad{z_i's} satisfy the
      ++ differential system \spad{M.z = v}.

  Implementation ==> add
    matF2L: Matrix F -> M

    diff := D()$L

-- coerces a matrix of elements of F into a matrix of (order 0) L.O.D.O's
    matF2L m ==
      map(#1::L, m)$MatrixCategoryFunctions2(F, V, V, Matrix F,
                                                L, Vector L, Vector L, M)

-- This follows the algorithm and notation of
--  "The Risch Differential Equation on an Algebraic Curve", M. Bronstein,
-- in 'Proceedings of ISSAC '91', Bonn, BRD, ACM Press, pp.241-246, July 1991.
    reduceLODE(l, g) ==
      n := rank()$A
-- md is the basic differential matrix (D x I + Dy)
      md := matF2L transpose derivationCoordinates(basis(), diff #1)
      for i in minRowIndex md .. maxRowIndex md
        for j in minColIndex md .. maxColIndex md repeat
          md(i, j) := diff + md(i, j)
-- mdi will go through the successive powers of md
      mdi := copy md
      sys := matF2L(transpose regularRepresentation coefficient(l, 0))
      for i in 1..degree l repeat
        sys := sys +
                matF2L(transpose regularRepresentation coefficient(l, i)) * mdi
        mdi := md * mdi
      [sys, coordinates g]

@
<<ODERED.dotabb>>=
"ODERED" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODERED"]
"MONOGEN" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MONOGEN"]
"ODERED" -> "MONOGEN"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REDORDER ReductionOfOrder}
\pagehead{ReductionOfOrder}{REDORDER}
\pagepic{ps/v104reductionoforder.ps}{REDORDER}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REDORDER ReductionOfOrder>>=
)abbrev package REDORDER ReductionOfOrder
++ Author: Manuel Bronstein
++ Date Created: 4 November 1991
++ Date Last Updated: 3 February 1994
++ Description:
++ \spadtype{ReductionOfOrder} provides
++ functions for reducing the order of linear ordinary differential equations
++ once some solutions are known.
++ Keywords: differential equation, ODE
ReductionOfOrder(F, L): Exports == Impl where
  F: Field
  L: LinearOrdinaryDifferentialOperatorCategory F

  Z ==> Integer
  A ==> PrimitiveArray F

  Exports ==> with
    ReduceOrder: (L, F) -> L
      ++ ReduceOrder(op, s) returns \spad{op1} such that for any solution
      ++ \spad{z} of \spad{op1 z = 0}, \spad{y = s \int z} is a solution of
      ++ \spad{op y = 0}. \spad{s} must satisfy \spad{op s = 0}.
    ReduceOrder: (L, List F) -> Record(eq:L, op:List F)
      ++ ReduceOrder(op, [f1,...,fk]) returns \spad{[op1,[g1,...,gk]]} such that
      ++ for any solution \spad{z} of \spad{op1 z = 0},
      ++ \spad{y = gk \int(g_{k-1} \int(... \int(g1 \int z)...)} is a solution
      ++ of \spad{op y = 0}. Each \spad{fi} must satisfy \spad{op fi = 0}.

  Impl ==> add
    ithcoef   : (L, Z, A) -> F
    locals    : (A, Z, Z) -> F
    localbinom: (Z, Z) -> Z

    diff := D()$L

    localbinom(j, i) == (j > i => binomial(j, i+1); 0)
    locals(s, j, i)  == (j > i => qelt(s, j - i - 1); 0)

    ReduceOrder(l:L, sols:List F) ==
      empty? sols => [l, empty()]
      neweq := ReduceOrder(l, sol := first sols)
      rec := ReduceOrder(neweq, [diff(s / sol) for s in rest sols])
      [rec.eq, concat_!(rec.op, sol)]

    ithcoef(eq, i, s) ==
      ans:F := 0
      while eq ^= 0 repeat
          j   := degree eq
          ans := ans + localbinom(j, i) * locals(s,j,i) * leadingCoefficient eq
          eq  := reductum eq
      ans

    ReduceOrder(eq:L, sol:F) ==
      s:A := new(n := degree eq, 0)         -- will contain derivatives of sol
      si := sol                             -- will run through the derivatives
      qsetelt_!(s, 0, si)
      for i in 1..(n-1)::NonNegativeInteger repeat 
          qsetelt_!(s, i, si := diff si)
      ans:L := 0
      for i in 0..(n-1)::NonNegativeInteger repeat
          ans := ans + monomial(ithcoef(eq, i, s), i)
      ans

@
<<REDORDER.dotabb>>=
"REDORDER" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REDORDER"]
"OREPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OREPCAT"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"REDORDER" -> "OREPCAT"
"REDORDER" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REPDB RepeatedDoubling}
\pagehead{RepeatedDoubling}{REPDB}
\pagepic{ps/v104repeateddoubling.ps}{REPDB}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REPDB RepeatedDoubling>>=
)abbrev package REPDB RepeatedDoubling
++ Repeated Doubling
++ Integer multiplication by repeated doubling.
++ Description:
++ Implements multiplication by repeated addition
++ RelatedOperations: *
 
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains

)bo PUSH('RepeatedDoubling, $mutableDomains) 

RepeatedDoubling(S):Exports ==Implementation where
   S: SetCategory with 
	"+":(%,%)->%
		++ x+y returns the sum of x and y
   Exports == with
     double: (PositiveInteger,S) -> S 
       ++ double(i, r) multiplies r by i using repeated doubling.
   Implementation == add
     x: S
     n: PositiveInteger
     double(n,x) ==
--        one? n => x
        (n = 1) => x
        odd?(n)$Integer =>
           x + double(shift(n,-1) pretend PositiveInteger,(x+x))
        double(shift(n,-1) pretend PositiveInteger,(x+x))

@
<<REPDB.dotabb>>=
"REPDB" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REPDB"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"REPDB" -> "BASTYPE"
"REPDB" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REPSQ RepeatedSquaring}
\pagehead{RepeatedSquaring}{REPSQ}
\pagepic{ps/v104repeatedsquaring.ps}{REPSQ}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REPSQ RepeatedSquaring>>=
)abbrev package REPSQ RepeatedSquaring
++ Repeated Squaring
++ Description:
++ Implements exponentiation by repeated squaring
++ RelatedOperations: expt
-- the following package is only instantiated over %
-- thus shouldn't be cached. We prevent it
-- from being cached by declaring it to be mutableDomains

)bo PUSH('RepeatedSquaring, $mutableDomains) 

RepeatedSquaring(S): Exports == Implementation where
   S: SetCategory with 
	"*":(%,%)->%
	     ++ x*y returns the product of x and y
   Exports == with
     expt: (S,PositiveInteger) -> S 
       ++ expt(r, i) computes r**i  by repeated squaring
   Implementation == add
     x: S
     n: PositiveInteger
     expt(x, n) ==
--        one? n => x
        (n = 1) => x
        odd?(n)$Integer=> x * expt(x*x,shift(n,-1) pretend PositiveInteger)
        expt(x*x,shift(n,-1) pretend PositiveInteger)

@
<<REPSQ.dotabb>>=
"REPSQ" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REPSQ"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"REPSQ" -> "BASTYPE"
"REPSQ" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RETSOL RetractSolvePackage}
\pagehead{RetractSolvePackage}{RETSOL}
\pagepic{ps/v104retractsolvepackage.ps}{RETSOL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RETSOL RetractSolvePackage>>=
)abbrev package RETSOL RetractSolvePackage
++ Author: Manuel Bronstein
++ Date Created: 31 October 1991
++ Date Last Updated: 31 October 1991
++ Description:
++ RetractSolvePackage is an interface to \spadtype{SystemSolvePackage}
++ that attempts to retract the coefficients of the equations before
++ solving.

RetractSolvePackage(Q, R): Exports == Implementation where
  Q: IntegralDomain
  R: Join(IntegralDomain, RetractableTo Q)

  PQ  ==> Polynomial Q
  FQ  ==> Fraction PQ
  SY  ==> Symbol
  P   ==> Polynomial R
  F   ==> Fraction P
  EQ  ==> Equation
  SSP ==> SystemSolvePackage

  Exports ==> with
    solveRetract: (List P, List SY) -> List List EQ F
      ++ solveRetract(lp,lv) finds the solutions of the list lp of
      ++ rational functions with respect to the list of symbols lv.
      ++ The function tries to retract all the coefficients of the equations
      ++ to Q before solving if possible.

  Implementation ==> add
    LEQQ2F : List EQ FQ -> List EQ F
    FQ2F   : FQ -> F
    PQ2P   : PQ -> P
    QIfCan : List P -> Union(List FQ, "failed")
    PQIfCan: P -> Union(FQ, "failed")

    PQ2P p   == map(#1::R, p)$PolynomialFunctions2(Q, R)
    FQ2F f   == PQ2P numer f / PQ2P denom f
    LEQQ2F l == [equation(FQ2F lhs eq, FQ2F rhs eq) for eq in l]

    solveRetract(lp, lv) ==
      (u := QIfCan lp) case "failed" =>
        solve([p::F for p in lp]$List(F), lv)$SSP(R)
      [LEQQ2F l for l in solve(u::List(FQ), lv)$SSP(Q)]

    QIfCan l ==
      ans:List(FQ) := empty()
      for p in l repeat
        (u := PQIfCan p) case "failed" => return "failed"
        ans := concat(u::FQ, ans)
      ans

    PQIfCan p ==
      (u := mainVariable p) case "failed" =>
        (r := retractIfCan(ground p)@Union(Q,"failed")) case Q => r::Q::PQ::FQ
        "failed"
      up := univariate(p, s := u::SY)
      ans:FQ := 0
      while up ^= 0 repeat
        (v := PQIfCan leadingCoefficient up) case "failed" => return "failed"
        ans := ans + monomial(1, s, degree up)$PQ * (v::FQ)
        up  := reductum up
      ans

@
<<RETSOL.dotabb>>=
"RETSOL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RETSOL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"RETSOL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter S}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAERFFC SAERationalFunctionAlgFactor}
\pagehead{SAERationalFunctionAlgFactor}{SAERFFC}
\pagepic{ps/v104saerationalfunctionalgfactor.ps}{SAERFFC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAERFFC SAERationalFunctionAlgFactor>>=
)abbrev package SAERFFC SAERationalFunctionAlgFactor
++ Factorisation in UP SAE FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of \spadtype{Fraction Polynomial Integer}.
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SAERationalFunctionAlgFactor(UP, SAE, UPA): Exports == Implementation where
  UP : UnivariatePolynomialCategory Fraction Polynomial Integer
  SAE : Join(Field, CharacteristicZero,
                      MonogenicAlgebra(Fraction Polynomial Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFunctionFactor(UP)
              )$InnerAlgFactor(Fraction Polynomial Integer, UP, SAE, UPA)

@
<<SAERFFC.dotabb>>=
"SAERFFC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAERFFC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FORMULA1 ScriptFormulaFormat1}
\pagehead{ScriptFormulaFormat1}{FORMULA1}
\pagepic{ps/v104scriptformulaformat1.ps}{FORMULA1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FORMULA1 ScriptFormulaFormat1>>=
)abbrev package FORMULA1 ScriptFormulaFormat1
++ Author: Robert S. Sutor
++ Date Created: 1987 through 1990
++ Change History:
++ Basic Operations: coerce
++ Related Constructors: ScriptFormulaFormat
++ Also See: TexFormat, TexFormat1
++ AMS Classifications:
++ Keywords: output, format, SCRIPT, BookMaster, formula
++ References:
++   SCRIPT Mathematical Formula Formatter User's Guide, SH20-6453,
++   IBM Corporation, Publishing Systems Information Development,
++   Dept. G68, P.O. Box 1900, Boulder, Colorado, USA 80301-9191.
++ Description:
++   \spadtype{ScriptFormulaFormat1} provides a utility coercion for
++   changing to SCRIPT formula format anything that has a coercion to
++   the standard output format.

ScriptFormulaFormat1(S : SetCategory): public == private where
  public  ==  with
    coerce: S -> ScriptFormulaFormat()
      ++ coerce(s) provides a direct coercion from an expression s of domain S
      ++ to SCRIPT formula format. This allows the user to skip the step of
      ++ first manually coercing the object to standard output format
      ++ before it is coerced to SCRIPT formula format.

  private == add
    import ScriptFormulaFormat()

    coerce(s : S): ScriptFormulaFormat ==
      coerce(s :: OutputForm)$ScriptFormulaFormat

@
<<FORMULA1.dotabb>>=
"FORMULA1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FORMULA1"]
"BASTYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=BASTYPE"]
"KOERCE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=KOERCE"]
"FORMULA1" -> "BASTYPE"
"FORMULA1" -> "KOERCE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAEFACT SimpleAlgebraicExtensionAlgFactor}
\pagehead{SimpleAlgebraicExtensionAlgFactor}{SAEFACT}
\pagepic{ps/v104simplealgebraicextensionalgfactor.ps}{SAEFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>=
)abbrev package SAEFACT SimpleAlgebraicExtensionAlgFactor
++ Factorisation in a simple algebraic extension;
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of the rational numbers (\spadtype{Fraction Integer}).
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SimpleAlgebraicExtensionAlgFactor(UP,SAE,UPA):Exports==Implementation where
  UP : UnivariatePolynomialCategory Fraction Integer
  SAE : Join(Field, CharacteristicZero,
                         MonogenicAlgebra(Fraction Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFactorize(UP)
                       )$InnerAlgFactor(Fraction Integer, UP, SAE, UPA)

@
<<SAEFACT.dotabb>>=
"SAEFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAEFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SIMPAN SimplifyAlgebraicNumberConvertPackage}
\pagehead{SimplifyAlgebraicNumberConvertPackage}{SIMPAN}
\pagepic{ps/v104simplifyalgebraicnumberconvertpackage.ps}{SIMPAN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SIMPAN SimplifyAlgebraicNumberConvertPackage>>=
)abbrev package SIMPAN SimplifyAlgebraicNumberConvertPackage
++ Package to allow simplify to be called on AlgebraicNumbers
++ by converting to EXPR(INT)
SimplifyAlgebraicNumberConvertPackage(): with
  simplify: AlgebraicNumber -> Expression(Integer)
	++ simplify(an) applies simplifications to an
 == add
  simplify(a:AlgebraicNumber) ==
    simplify(a::Expression(Integer))$TranscendentalManipulations(Integer, Expression Integer)

@
<<SIMPAN.dotabb>>=
"SIMPAN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SIMPAN"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"SIMPAN" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SCACHE SortedCache}
\pagehead{SortedCache}{SCACHE}
\pagepic{ps/v104sortedcache.ps}{SCACHE}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SCACHE SortedCache>>=
)abbrev package SCACHE SortedCache
++ Cache of elements in a set
++ Author: Manuel Bronstein
++ Date Created: 31 Oct 1988
++ Date Last Updated: 14 May 1991
++   A sorted cache of a cachable set S is a dynamic structure that
++   keeps the elements of S sorted and assigns an integer to each
++   element of S once it is in the cache. This way, equality and ordering
++   on S are tested directly on the integers associated with the elements
++   of S, once they have been entered in the cache.
SortedCache(S:CachableSet): Exports == Implementation where
  N    ==> NonNegativeInteger
  DIFF ==> 1024

  Exports ==> with
    clearCache  : () -> Void
      ++ clearCache() empties the cache.
    cache       : () -> List S
      ++ cache() returns the current cache as a list.
    enterInCache: (S, S -> Boolean) -> S
      ++ enterInCache(x, f) enters x in the cache, calling \spad{f(y)} to
      ++ determine whether x is equal to y. It returns x with an integer
      ++ associated with it.
    enterInCache: (S, (S, S) -> Integer) -> S
      ++ enterInCache(x, f) enters x in the cache, calling \spad{f(x, y)} to
      ++ determine whether \spad{x < y (f(x,y) < 0), x = y (f(x,y) = 0)}, or
      ++ \spad{x > y (f(x,y) > 0)}.
      ++ It returns x with an integer associated with it.

  Implementation ==> add
    shiftCache   : (List S, N) -> Void
    insertInCache: (List S, List S, S, N) -> S

    cach := [nil()]$Record(cche:List S)

    cache() == cach.cche

    shiftCache(l, n) ==
      for x in l repeat setPosition(x, n + position x)
      void

    clearCache() ==
      for x in cache repeat setPosition(x, 0)
      cach.cche := nil()
      void

    enterInCache(x:S, equal?:S -> Boolean) ==
      scan := cache()
      while not null scan repeat
        equal?(y := first scan) =>
          setPosition(x, position y)
          return y
        scan := rest scan
      setPosition(x, 1 + #cache())
      cach.cche := concat(cache(), x)
      x

    enterInCache(x:S, triage:(S, S) -> Integer) ==
      scan := cache()
      pos:N:= 0
      for i in 1..#scan repeat
        zero?(n := triage(x, y := first scan)) =>
          setPosition(x, position y)
          return y
        n<0 => return insertInCache(first(cache(),(i-1)::N),scan,x,pos)
        scan := rest scan
        pos  := position y
      setPosition(x, pos + DIFF)
      cach.cche := concat(cache(), x)
      x

    insertInCache(before, after, x, pos) ==
      if ((pos+1) = position first after) then shiftCache(after, DIFF)
      setPosition(x, pos + (((position first after) - pos)::N quo 2))
      cach.cche := concat(before, concat(x, after))
      x

@
<<SCACHE.dotabb>>=
"SCACHE" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SCACHE"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"SCACHE" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SPECOUT SpecialOutputPackage}
\pagehead{SpecialOutputPackage}{SPECOUT}
\pagepic{ps/v104specialoutputpackage.ps}{SPECOUT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SPECOUT SpecialOutputPackage>>=
)abbrev package SPECOUT SpecialOutputPackage
++ Author: Stephen M. Watt
++ Date Created: September 1986
++ Date Last Updated: May 23, 1991
++ Basic Operations: outputAsFortran, outputAsScript, outputAsTex
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: SpecialOutputPackage allows FORTRAN, Tex and
++   Script Formula Formatter output from programs.

SpecialOutputPackage: public == private where
  public == with
    outputAsFortran: (String,OutputForm) -> Void
      ++ outputAsFortran(v,o) sends output v = o in FORTRAN format
      ++ to the destination defined by \spadsyscom{set output fortran}.
    outputAsFortran: OutputForm          -> Void
      ++ outputAsFortran(o) sends output o in FORTRAN format.
    outputAsScript:  OutputForm          -> Void
      ++ outputAsScript(o) sends output o in Script Formula Formatter format
      ++ to the destination defined by \spadsyscom{set output formula}.
    outputAsTex:     OutputForm          -> Void
      ++ outputAsTex(o) sends output o in Tex format to the destination
      ++ defined by \spadsyscom{set output tex}.
    outputAsFortran: List OutputForm     -> Void
      ++ outputAsFortran(l) sends (for each expression in the list l)
      ++ output in FORTRAN format to the destination defined by
      ++ \spadsyscom{set output fortran}.
    outputAsScript:  List OutputForm     -> Void
      ++ outputAsScript(l) sends (for each expression in the list l)
      ++ output in Script Formula Formatter format to the destination defined.
      ++ by \spadsyscom{set output forumula}.
    outputAsTex:     List OutputForm     -> Void
      ++ outputAsTex(l) sends (for each expression in the list l)
      ++ output in Tex format to the destination as defined by
      ++ \spadsyscom{set output tex}.

  private == add
    e : OutputForm
    l : List OutputForm
    var : String
    --ExpressionPackage()

    juxtaposeTerms: List OutputForm -> OutputForm
    juxtaposeTerms l == blankSeparate l

    outputAsFortran e ==
      dispfortexp$Lisp e
      void()$Void

    outputAsFortran(var,e) ==
      e := var::Symbol::OutputForm  = e
      dispfortexp(e)$Lisp
      void()$Void

    outputAsFortran l ==
      dispfortexp$Lisp juxtaposeTerms l
      void()$Void

    outputAsScript e ==
      formulaFormat$Lisp e
      void()$Void

    outputAsScript l ==
      formulaFormat$Lisp juxtaposeTerms l
      void()$Void

    outputAsTex e ==
      texFormat$Lisp e
      void()$Void

    outputAsTex l ==
      texFormat$Lisp juxtaposeTerms l
      void()$Void

@
<<SPECOUT.dotabb>>=
"SPECOUT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SPECOUT"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"SPECOUT" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MATSTOR StorageEfficientMatrixOperations}
\pagehead{StorageEfficientMatrixOperations}{MATSTOR}
\pagepic{ps/v104storageefficientmatrixoperations.ps}{MATSTOR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MATSTOR StorageEfficientMatrixOperations>>=
)abbrev package MATSTOR StorageEfficientMatrixOperations
++ Author: Clifton J. Williamson
++ Date Created: 18 July 1990
++ Date Last Updated: 18 July 1990
++ Basic Operations:
++ Related Domains: Matrix(R)
++ Also See:
++ AMS Classifications:
++ Keywords: matrix, linear algebra
++ Examples:
++ References:
++ Description:
++   This package provides standard arithmetic operations on matrices.
++   The functions in this package store the results of computations
++   in existing matrices, rather than creating new matrices.  This
++   package works only for matrices of type Matrix and uses the
++   internal representation of this type.
StorageEfficientMatrixOperations(R): Exports == Implementation where
  R     : Ring
  M   ==> Matrix R
  NNI ==> NonNegativeInteger
  ARR ==> PrimitiveArray R
  REP ==> PrimitiveArray PrimitiveArray R
 
  Exports ==> with
    copy_! : (M,M) -> M
     ++ \spad{copy!(c,a)} copies the matrix \spad{a} into the matrix c.
     ++ Error: if \spad{a} and c do not have the same
     ++ dimensions.
    plus_! : (M,M,M) -> M
     ++ \spad{plus!(c,a,b)} computes the matrix sum \spad{a + b} and stores the
     ++ result in the matrix c.
     ++ Error: if \spad{a}, b, and c do not have the same dimensions.
    minus_! : (M,M) -> M
     ++ \spad{minus!(c,a)} computes \spad{-a} and stores the result in the
     ++ matrix c.
     ++ Error: if a and c do not have the same dimensions.
    minus_! : (M,M,M) -> M
     ++ \spad{!minus!(c,a,b)} computes the matrix difference \spad{a - b}
     ++ and stores the result in the matrix c.
     ++ Error: if \spad{a}, b, and c do not have the same dimensions.
    leftScalarTimes_! : (M,R,M) -> M
     ++ \spad{leftScalarTimes!(c,r,a)} computes the scalar product
     ++ \spad{r * a} and stores the result in the matrix c.
     ++ Error: if \spad{a} and c do not have the same dimensions.
    rightScalarTimes_! : (M,M,R) -> M
     ++ \spad{rightScalarTimes!(c,a,r)} computes the scalar product
     ++ \spad{a * r} and stores the result in the matrix c.
     ++ Error: if \spad{a} and c do not have the same dimensions.
    times_! : (M,M,M) -> M
     ++ \spad{times!(c,a,b)} computes the matrix product \spad{a * b}
     ++ and stores the result in the matrix c.
     ++ Error: if \spad{a}, b, and c do not have
     ++ compatible dimensions.
    power_! : (M,M,M,M,NNI) -> M
     ++ \spad{power!(a,b,c,m,n)} computes m ** n and stores the result in
     ++ \spad{a}. The matrices b and c are used to store intermediate results.
     ++ Error: if \spad{a}, b, c, and m are not square
     ++ and of the same dimensions.
    "**" : (M,NNI) -> M
     ++ \spad{x ** n} computes the n-th power
     ++ of a square matrix. The power n is assumed greater than 1.
 
  Implementation ==> add
 
    rep : M -> REP
    rep m == m pretend REP
 
    copy_!(c,a) ==
      m := nrows a; n := ncols a
      not((nrows c) = m and (ncols c) = n) =>
        error "copy!: matrices of incompatible dimensions"
      aa := rep a; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,qelt(aRow,j))
      c
 
    plus_!(c,a,b) ==
      m := nrows a; n := ncols a
      not((nrows b) = m and (ncols b) = n) =>
        error "plus!: matrices of incompatible dimensions"
      not((nrows c) = m and (ncols c) = n) =>
        error "plus!: matrices of incompatible dimensions"
      aa := rep a; bb := rep b; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); bRow := qelt(bb,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,qelt(aRow,j) + qelt(bRow,j))
      c
 
    minus_!(c,a) ==
      m := nrows a; n := ncols a
      not((nrows c) = m and (ncols c) = n) =>
        error "minus!: matrices of incompatible dimensions"
      aa := rep a; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,-qelt(aRow,j))
      c
 
    minus_!(c,a,b) ==
      m := nrows a; n := ncols a
      not((nrows b) = m and (ncols b) = n) =>
        error "minus!: matrices of incompatible dimensions"
      not((nrows c) = m and (ncols c) = n) =>
        error "minus!: matrices of incompatible dimensions"
      aa := rep a; bb := rep b; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); bRow := qelt(bb,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,qelt(aRow,j) - qelt(bRow,j))
      c
 
    leftScalarTimes_!(c,r,a) ==
      m := nrows a; n := ncols a
      not((nrows c) = m and (ncols c) = n) =>
        error "leftScalarTimes!: matrices of incompatible dimensions"
      aa := rep a; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,r * qelt(aRow,j))
      c
 
    rightScalarTimes_!(c,a,r) ==
      m := nrows a; n := ncols a
      not((nrows c) = m and (ncols c) = n) =>
        error "rightScalarTimes!: matrices of incompatible dimensions"
      aa := rep a; cc := rep c
      for i in 0..(m-1) repeat
        aRow := qelt(aa,i); cRow := qelt(cc,i)
        for j in 0..(n-1) repeat
          qsetelt_!(cRow,j,qelt(aRow,j) * r)
      c
 
    copyCol_!: (ARR,REP,Integer,Integer) -> ARR
    copyCol_!(bCol,bb,j,n1) ==
      for i in 0..n1 repeat qsetelt_!(bCol,i,qelt(qelt(bb,i),j))
 
    times_!(c,a,b) ==
      m := nrows a; n := ncols a; p := ncols b
      not((nrows b) = n and (nrows c) = m and (ncols c) = p) =>
        error "times!: matrices of incompatible dimensions"
      aa := rep a; bb := rep b; cc := rep c
      bCol : ARR := new(n,0)
      m1 := (m :: Integer) - 1; n1 := (n :: Integer) - 1
      for j in 0..(p-1) repeat
        copyCol_!(bCol,bb,j,n1)
        for i in 0..m1 repeat
          aRow := qelt(aa,i); cRow := qelt(cc,i)
          sum : R := 0
          for k in 0..n1 repeat
            sum := sum + qelt(aRow,k) * qelt(bCol,k)
          qsetelt_!(cRow,j,sum)
      c
 
    power_!(a,b,c,m,p) ==
      mm := nrows a; nn := ncols a
      not(mm = nn) =>
        error "power!: matrix must be square"
      not((nrows b) = mm and (ncols b) = nn) =>
        error "power!: matrices of incompatible dimensions"
      not((nrows c) = mm and (ncols c) = nn) =>
        error "power!: matrices of incompatible dimensions"
      not((nrows m) = mm and (ncols m) = nn) =>
        error "power!: matrices of incompatible dimensions"
      flag := false
      copy_!(b,m)
      repeat
        if odd? p then
          flag =>
            times_!(c,b,a)
            copy_!(a,c)
          flag := true
          copy_!(a,b)
--        one? p => return a
        (p = 1) => return a
        p := p quo 2
        times_!(c,b,b)
        copy_!(b,c)
 
    m ** n ==
      not square? m => error "**: matrix must be square"
      a := copy m; b := copy m; c := copy m
      power_!(a,b,c,m,n)

@
<<MATSTOR.dotabb>>=
"MATSTOR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MATSTOR"]
"A1AGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=A1AGG"]
"MATSTOR" -> "A1AGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package STINPROD StreamInfiniteProduct}
\pagehead{StreamInfiniteProduct}{STINPROD}
\pagepic{ps/v104streaminfiniteproduct.ps}{STINPROD}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package STINPROD StreamInfiniteProduct>>=
)abbrev package STINPROD StreamInfiniteProduct
++ Author: Clifton J. Williamson
++ Date Created: 23 February 1990
++ Date Last Updated: 23 February 1990
++ Basic Operations: infiniteProduct, evenInfiniteProduct, oddInfiniteProduct,
++   generalInfiniteProduct
++ Related Domains: UnivariateTaylorSeriesCategory
++ Also See:
++ AMS Classifications:
++ Keywords: Taylor series, infinite product
++ Examples:
++ References:
++ Description: 
++   This package computes infinite products of Taylor series over an
++   integral domain of characteristic 0.  Here Taylor series are
++   represented by streams of Taylor coefficients.
StreamInfiniteProduct(Coef): Exports == Implementation where
  Coef: Join(IntegralDomain,CharacteristicZero)
  I  ==> Integer
  QF ==> Fraction
  ST ==> Stream
 
  Exports ==> with
 
    infiniteProduct: ST Coef -> ST Coef
      ++ infiniteProduct(f(x)) computes \spad{product(n=1,2,3...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    evenInfiniteProduct: ST Coef -> ST Coef
      ++ evenInfiniteProduct(f(x)) computes \spad{product(n=2,4,6...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    oddInfiniteProduct: ST Coef -> ST Coef
      ++ oddInfiniteProduct(f(x)) computes \spad{product(n=1,3,5...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
    generalInfiniteProduct: (ST Coef,I,I) -> ST Coef
      ++ generalInfiniteProduct(f(x),a,d) computes
      ++ \spad{product(n=a,a+d,a+2*d,...,f(x**n))}.
      ++ The series \spad{f(x)} should have constant coefficient 1.
 
  Implementation ==> add
 
    if Coef has Field then
 
      import StreamTaylorSeriesOperations(Coef)
      import StreamTranscendentalFunctions(Coef)
 
      infiniteProduct st             == exp lambert log st
      evenInfiniteProduct st         == exp evenlambert log st
      oddInfiniteProduct st          == exp oddlambert log st
      generalInfiniteProduct(st,a,d) == exp generalLambert(log st,a,d)
 
    else
 
      import StreamTaylorSeriesOperations(QF Coef)
      import StreamTranscendentalFunctions(QF Coef)
 
      applyOverQF:(ST QF Coef -> ST QF Coef,ST Coef) -> ST Coef
      applyOverQF(f,st) ==
        stQF := map(#1 :: QF(Coef),st)$StreamFunctions2(Coef,QF Coef)
        map(retract(#1)@Coef,f stQF)$StreamFunctions2(QF Coef,Coef)
 
      infiniteProduct st     == applyOverQF(exp lambert log #1,st)
      evenInfiniteProduct st == applyOverQF(exp evenlambert log #1,st)
      oddInfiniteProduct st  == applyOverQF(exp oddlambert log #1,st)
      generalInfiniteProduct(st,a,d) ==
        applyOverQF(exp generalLambert(log #1,a,d),st)

@
<<STINPROD.dotabb>>=
"STINPROD" [color="#FF4488",href="bookvol10.4.pdf#nameddest=STINPROD"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"STINPROD" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SCPKG StructuralConstantsPackage}
\pagehead{StructuralConstantsPackage}{SCPKG}
\pagepic{ps/v104structuralconstantspackage.ps}{SCPKG}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SCPKG StructuralConstantsPackage>>=
)abbrev package SCPKG StructuralConstantsPackage
++ Authors: J. Grabmeier
++ Date Created: 02 April 1992
++ Date Last Updated: 14 April 1992
++ Basic Operations:
++ Related Constructors: AlgebraPackage, AlgebraGivenByStructuralConstants
++ Also See:
++ AMS Classifications:
++ Keywords: structural constants
++ Reference:
++ Description:
++  StructuralConstantsPackage provides functions creating
++  structural constants from a multiplication tables or a basis
++  of a matrix algebra and other useful functions in this context.
StructuralConstantsPackage(R:Field): public == private where

  L  ==> List
  S  ==> Symbol
  FRAC ==> Fraction
  POLY ==> Polynomial
  V  ==> Vector
  M  ==> Matrix
  REC  ==> Record(particular: Union(V R,"failed"),basis: List V R)
  LSMP ==> LinearSystemMatrixPackage(R,V R,V R, M R)

  public ==>  with
      -- what we really want to have here is a matrix over
      -- linear polynomials in the list of symbols, having arbitrary
      -- coefficients from a ring extension of R, e.g. FRAC POLY R.
      structuralConstants : (L S, M FRAC POLY R) -> V M FRAC POLY R
        ++ structuralConstants(ls,mt) determines the structural constants
        ++ of an algebra with generators ls and multiplication table mt, the
        ++ entries of which must be given as linear polynomials in the
        ++ indeterminates given by ls. The result is in particular useful
        ++  as fourth argument for \spadtype{AlgebraGivenByStructuralConstants}
        ++  and \spadtype{GenericNonAssociativeAlgebra}.
      structuralConstants : (L S, M POLY R) -> V M POLY R
        ++ structuralConstants(ls,mt) determines the structural constants
        ++ of an algebra with generators ls and multiplication table mt, the
        ++ entries of which must be given as linear polynomials in the
        ++ indeterminates given by ls. The result is in particular useful
        ++  as fourth argument for \spadtype{AlgebraGivenByStructuralConstants}
        ++  and \spadtype{GenericNonAssociativeAlgebra}.
      structuralConstants: L M R -> V M R
        ++ structuralConstants(basis)  takes the basis of a matrix
        ++ algebra, e.g. the result of \spadfun{basisOfCentroid} and calculates
        ++ the structural constants.
        ++ Note, that the it is not checked, whether basis really is a
        ++ basis of a matrix algebra.
      coordinates: (M R, L M R) -> V R
        ++ coordinates(a,[v1,...,vn]) returns the coordinates of \spad{a}
        ++ with respect to the \spad{R}-module basis \spad{v1},...,\spad{vn}.

  private ==> add

      matrix2Vector: M R -> V R
      matrix2Vector m ==
        lili : L L R := listOfLists m
        --li : L R  := reduce(concat, listOfLists m)
        li : L R  := reduce(concat, lili)
        construct(li)$(V R)

      coordinates(x,b) ==
        m : NonNegativeInteger := (maxIndex b) :: NonNegativeInteger
        n : NonNegativeInteger := nrows(b.1) * ncols(b.1)
        transitionMatrix   : Matrix R := new(n,m,0$R)$Matrix(R)
        for i in 1..m repeat
          setColumn_!(transitionMatrix,i,matrix2Vector(b.i))
        res : REC := solve(transitionMatrix,matrix2Vector(x))$LSMP
        if (not every?(zero?$R,first res.basis)) then
          error("coordinates: the second argument is linearly dependent")
        (res.particular  case "failed") =>
          error("coordinates: first argument is not in linear span of _
second argument")
        (res.particular) :: (Vector R)

      structuralConstants b ==
        --n := rank()
        -- be careful with the possibility that b is not a basis
        m : NonNegativeInteger := (maxIndex b) :: NonNegativeInteger
        sC : Vector Matrix R := [new(m,m,0$R) for k in 1..m]
        for i in 1..m repeat
          for j in 1..m repeat
            covec : Vector R := coordinates(b.i * b.j, b)$%
            for k in 1..m repeat
               setelt( sC.k, i, j, covec.k )
        sC

      structuralConstants(ls:L S, mt: M POLY R)  ==
        nn := #(ls)
        nrows(mt) ^= nn or ncols(mt) ^= nn =>
          error "structuralConstants: size of second argument does not _
agree with number of generators"
        gamma : L M POLY R := []
        lscopy : L S := copy ls
        while not null lscopy repeat
          mat : M POLY R := new(nn,nn,0)
          s : S := first lscopy
          for i in 1..nn repeat
            for j in 1..nn repeat
              p := qelt(mt,i,j)
              totalDegree(p,ls) > 1 =>
                error "structuralConstants: entries of second argument _
must be linear polynomials in the generators"
              if (c := coefficient(p, s, 1) ) ^= 0 then qsetelt_!(mat,i,j,c)
          gamma := cons(mat, gamma)
          lscopy := rest lscopy
        vector reverse gamma

      structuralConstants(ls:L S, mt: M FRAC POLY R)  ==
        nn := #(ls)
        nrows(mt) ^= nn or ncols(mt) ^= nn =>
          error "structuralConstants: size of second argument does not _
agree with number of generators"
        gamma : L M FRAC(POLY R) := []
        lscopy : L S := copy ls
        while not null lscopy repeat
          mat : M FRAC(POLY R) := new(nn,nn,0)
          s : S := first lscopy
          for i in 1..nn repeat
            for j in 1..nn repeat
              r := qelt(mt,i,j)
              q := denom(r)
              totalDegree(q,ls) ^= 0 =>
                error "structuralConstants: entries of second argument _
must be (linear) polynomials in the generators"
              p := numer(r)
              totalDegree(p,ls) > 1 =>
                error "structuralConstants: entries of second argument _
must be linear polynomials in the generators"
              if (c := coefficient(p, s, 1) ) ^= 0 then qsetelt_!(mat,i,j,c/q)
          gamma := cons(mat, gamma)
          lscopy := rest lscopy
        vector reverse gamma

@
<<SCPKG.dotabb>>=
"SCPKG" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SCPKG"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SCPKG" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUBRESP SubResultantPackage}
\pagehead{SubResultantPackage}{SUBRESP}
\pagepic{ps/v104subresultantpackage.ps}{SUBRESP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUBRESP SubResultantPackage>>=
)abbrev package SUBRESP SubResultantPackage
++ Subresultants
++ Author: Barry Trager, Renaud Rioboo
++ Date Created: 1987
++ Date Last Updated: August 2000
++ Description:
++ This package computes the subresultants of two polynomials which is needed
++ for the `Lazard Rioboo' enhancement to Tragers integrations formula
++ For efficiency reasons this has been rewritten to call Lionel Ducos
++ package which is currently the best one.
++
SubResultantPackage(R, UP): Exports == Implementation where
  R : IntegralDomain
  UP: UnivariatePolynomialCategory R
 
  Z   ==> Integer
  N   ==> NonNegativeInteger
 
  Exports ==> with
    subresultantVector: (UP, UP) -> PrimitiveArray UP
      ++ subresultantVector(p, q) returns \spad{[p0,...,pn]}
      ++ where pi is the i-th subresultant of p and q.
      ++ In particular, \spad{p0 = resultant(p, q)}.
    if R has EuclideanDomain then
      primitivePart     : (UP,  R) -> UP
        ++ primitivePart(p, q) reduces the coefficient of p
        ++ modulo q, takes the primitive part of the result,
        ++ and ensures that the leading coefficient of that
        ++ result is monic.
 
  Implementation ==> add

    Lionel ==> PseudoRemainderSequence(R,UP)

    if R has EuclideanDomain then
      primitivePart(p, q) ==
         rec := extendedEuclidean(leadingCoefficient p, q,
                                  1)::Record(coef1:R, coef2:R)
         unitCanonical primitivePart map((rec.coef1 * #1) rem q, p)
 
    subresultantVector(p1, p2) ==
       F : UP -- auxiliary stuff !
       res : PrimitiveArray(UP) := new(2+max(degree(p1),degree(p2)), 0)
       --
       -- kind of stupid interface to Lionel's  Package !!!!!!!!!!!!
       -- might have been wiser to rewrite the loop ...
       -- But I'm too lazy. [rr]
       --
       l := chainSubResultants(p1,p2)$Lionel
       --
       -- this returns the chain of non null subresultants !
       -- we must  rebuild subresultants from this.
       -- we really hope Lionel Ducos minded what he wrote
       -- since we are fully blind !
       --
       null l =>
         -- Hum it seems that Lionel returns [] when min(|p1|,|p2|) = 0
         zero?(degree(p1)) =>
           res.degree(p2) := p2
           if degree(p2) > 0
           then
             res.((degree(p2)-1)::NonNegativeInteger) := p1
             res.0 := (leadingCoefficient(p1)**(degree p2)) :: UP
           else
             -- both are of degree 0 the resultant is 1 according to Loos
             res.0 := 1
           res
         zero?(degree(p2)) =>
           if degree(p1) > 0
           then
             res.((degree(p1)-1)::NonNegativeInteger) := p2
             res.0 := (leadingCoefficient(p2)**(degree p1)) :: UP
           else
             -- both are of degree 0 the resultant is 1 according to Loos
             res.0 := 1
           res
         error "SUBRESP: strange Subresultant chain from PRS"
       Sn := first(l)
       --
       -- as of Loos definitions last subresultant should not be defective
       --
       l := rest(l)
       n := degree(Sn)
       F := Sn
       null l => error "SUBRESP: strange Subresultant chain from PRS"
       zero? Sn => error "SUBRESP: strange Subresultant chain from PRS"
       while (l ^= []) repeat
         res.(n) := Sn
         F := first(l)
         l := rest(l)
         -- F is potentially defective
         if degree(F) = n
         then
           --
           -- F is defective
           --
           null l => error "SUBRESP: strange Subresultant chain from PRS"
           Sn := first(l)
           l := rest(l)
           n := degree(Sn)
           res.((n-1)::NonNegativeInteger) := F
         else
           --
           -- F is non defective
           --
           degree(F) < n => error "strange result !"
           Sn := F
           n := degree(Sn)
       --
       -- Lionel forgets about p1 if |p1| > |p2|
       -- forgets about p2 if |p2| > |p1|
       -- but he reminds p2 if |p1| = |p2|
       -- a glance at Loos should correct this !
       --
       res.n := Sn
       --
       -- Loos definition
       --
       if degree(p1) = degree(p2)
       then
         res.((degree p1)+1) := p1
       else
         if degree(p1) > degree(p2)
         then
           res.(degree p1) := p1
         else
           res.(degree p2) := p2
       res

@
<<SUBRESP.dotabb>>=
"SUBRESP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUBRESP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SUBRESP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUPFRACF SupFractionFactorizer}
\pagehead{SupFractionFactorizer}{SUPFRACF}
\pagepic{ps/v104supfractionfactorizer.ps}{SUPFRACF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUPFRACF SupFractionFactorizer>>=
)abbrev package SUPFRACF SupFractionFactorizer
++ Author: P. Gianni
++ Date Created: October 1993
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  SupFractionFactorize 
++ contains the factor function for univariate 
++ polynomials over the quotient field of a ring S such that the package
++ MultivariateFactorize works for S

SupFractionFactorizer(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   GcdDomain
  P   :   PolynomialCategory(R,E,OV)
  FP  ==> Fraction P
  SUP ==> SparseUnivariatePolynomial 

  C  == with
     factor      : SUP FP   ->  Factored SUP FP
       ++ factor(p) factors the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R.
     squareFree  : SUP FP   ->  Factored SUP FP
       ++ squareFree(p) returns the square-free factorization of the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R. Each factor has no repeated roots and the factors are
       ++ pairwise relatively prime.

  T  == add
     MFACT  ==> MultivariateFactorize(OV,E,R,P)
     MSQFR  ==> MultivariateSquareFree(E,OV,R,P)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     factor(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       R has CharacteristicZero and R has EuclideanDomain =>
         pden : P := lcm [denom c for c in coefficients p]
         pol  : SUP FP := (pden::FP)*p
         ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
         ffact: Factored SUP P := 0
         ffact := factor(ipol)$MFACT
         makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["prime",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])
       squareFree p

     squareFree(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       pden : P := lcm [denom c for c in coefficients p]
       pol  : SUP FP := (pden::FP)*p
       ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
       ffact: Factored SUP P := 0
       if R has CharacteristicZero and R has EuclideanDomain then
         ffact := squareFree(ipol)$MSQFR
       else ffact := squareFree(ipol)
       makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["sqfr",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])

@
<<SUPFRACF.dotabb>>=
"SUPFRACF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUPFRACF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SUPFRACF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ODESYS SystemODESolver}
\pagehead{SystemODESolver}{ODESYS}
\pagepic{ps/v104systemodesolver.ps}{ODESYS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ODESYS SystemODESolver>>=
)abbrev package ODESYS SystemODESolver
++ Author: Manuel Bronstein
++ Date Created: 11 June 1991
++ Date Last Updated: 13 April 1994
++ Description: SystemODESolver provides tools for triangulating
++ and solving some systems of linear ordinary differential equations.
++ Keywords: differential equation, ODE, system
SystemODESolver(F, LO): Exports == Implementation where
  F : Field
  LO: LinearOrdinaryDifferentialOperatorCategory F

  N   ==> NonNegativeInteger
  Z   ==> Integer
  MF  ==> Matrix F
  M   ==> Matrix LO
  V   ==> Vector F
  UF  ==> Union(F, "failed")
  UV  ==> Union(V, "failed")
  REC ==> Record(mat: M, vec: V)
  FSL ==> Record(particular: UF, basis: List F)
  VSL ==> Record(particular: UV, basis: List V)
  SOL ==> Record(particular: F, basis: List F)
  USL ==> Union(SOL, "failed")
  ER  ==> Record(C: MF, g: V, eq: LO, rh: F)

  Exports ==> with
    triangulate: (MF, V) -> Record(A:MF, eqs: List ER)
      ++ triangulate(M,v) returns
      ++ \spad{A,[[C_1,g_1,L_1,h_1],...,[C_k,g_k,L_k,h_k]]}
      ++ such that under the change of variable \spad{y = A z}, the first
      ++ order linear system \spad{D y = M y + v} is uncoupled as
      ++ \spad{D z_i = C_i z_i + g_i} and each \spad{C_i} is a companion
      ++ matrix corresponding to the scalar equation \spad{L_i z_j = h_i}.
    triangulate: (M, V) -> REC
      ++ triangulate(m, v) returns \spad{[m_0, v_0]} such that \spad{m_0}
      ++ is upper triangular and the system \spad{m_0 x = v_0} is equivalent
      ++ to \spad{m x = v}.
    solve: (MF,V,(LO,F)->USL) -> Union(Record(particular:V, basis:MF),"failed")
      ++ solve(m, v, solve) returns \spad{[[v_1,...,v_m], v_p]} such that
      ++ the solutions in \spad{F} of the system \spad{D x = m x + v} are
      ++ \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are
      ++ constants, and the \spad{v_i's} form a basis for the solutions of
      ++ \spad{D x = m x}.
      ++ Argument \spad{solve} is a function for solving a single linear
      ++ ordinary differential equation in \spad{F}.
    solveInField: (M, V, (LO, F) -> FSL) -> VSL
      ++ solveInField(m, v, solve) returns \spad{[[v_1,...,v_m], v_p]} such
      ++ that the solutions in \spad{F} of the system \spad{m x = v} are
      ++ \spad{v_p + c_1 v_1 + ... + c_m v_m} where the \spad{c_i's} are
      ++ constants, and the \spad{v_i's} form a basis for the solutions of
      ++ \spad{m x = 0}.
      ++ Argument \spad{solve} is a function for solving a single linear
      ++ ordinary differential equation in \spad{F}.

  Implementation ==> add
    import PseudoLinearNormalForm F

    applyLodo   : (M, Z, V, N) -> F
    applyLodo0  : (M, Z, Matrix F, Z, N) -> F
    backsolve   : (M, V, (LO, F) -> FSL) -> VSL
    firstnonzero: (M, Z) -> Z
    FSL2USL     : FSL -> USL
    M2F         : M -> Union(MF, "failed")

    diff := D()$LO

    solve(mm, v, solve) ==
      rec  := triangulate(mm, v)
      sols:List(SOL) := empty()
      for e in rec.eqs repeat
          (u := solve(e.eq, e.rh)) case "failed" => return "failed"
          sols := concat(u::SOL, sols)
      n := nrows(rec.A)    -- dimension of original vectorspace
      k:N := 0             -- sum of sizes of visited companionblocks
      i:N := 0             -- number of companionblocks
      m:N := 0             -- number of Solutions
      part:V := new(n, 0)
      -- count first the different solutions
      for sol in sols repeat m := m + count(#1 ^= 0, sol.basis)$List(F)
      SolMatrix:MF := new(n, m, 0)
      m := 0
      for sol in reverse_! sols repeat
          i := i+1
          er := rec.eqs.i
          nn := #(er.g)           -- size of active companionblock
          for s in sol.basis repeat
              solVec:V := new(n, 0)
              -- compute corresponding solution base with recursion (24)
              solVec(k+1) := s
              for l in 2..nn repeat solVec(k+l) := diff solVec(k+l-1)
              m := m+1
              setColumn!(SolMatrix, m, solVec)
          -- compute with (24) the corresponding components of the part. sol.
          part(k+1) := sol.particular
          for l in 2..nn repeat part(k+l) := diff part(k+l-1) - (er.g)(l-1)
          k := k+nn
      -- transform these values back to the original system
      [rec.A * part, rec.A * SolMatrix]

    triangulate(m:MF, v:V) ==
      k:N := 0       -- sum of companion-dimensions
      rat := normalForm(m, 1, - diff #1)
      l   := companionBlocks(rat.R, rat.Ainv * v)
      ler:List(ER) := empty()
      for er in l repeat
        n := nrows(er.C)         -- dimension of this companion vectorspace
        op:LO := 0               -- compute homogeneous equation
        for j in 0..n-1 repeat op := op + monomial((er.C)(n, j + 1), j)
        op := monomial(1, n) - op
        sum:V := new(n::N, 0)    -- compute inhomogen Vector (25)
        for j in 1..n-1 repeat sum(j+1) := diff(sum j) + (er.g) j
        h0:F := 0                 -- compute inhomogenity (26)
        for j in 1..n repeat h0 := h0 - (er.C)(n, j) * sum j
        h0 := h0 + diff(sum n) + (er.g) n
        ler := concat([er.C, er.g, op, h0], ler)
        k := k + n
      [rat.A, ler]

-- like solveInField, but expects a system already triangularized
    backsolve(m, v, solve) ==
      part:V
      r := maxRowIndex m
      offset := minIndex v - (mr := minRowIndex m)
      while r >= mr and every?(zero?, row(m, r))$Vector(LO) repeat r := r - 1
      r < mr => error "backsolve: system has a 0 matrix"
      (c := firstnonzero(m, r)) ^= maxColIndex m =>
        error "backsolve: undetermined system"
      rec := solve(m(r, c), v(r + offset))
      dim := (r - mr + 1)::N
      if (part? := ((u := rec.particular) case F)) then
        part := new(dim, 0)                           -- particular solution
        part(r + offset) :=  u::F
-- hom is the basis for the homogeneous solutions, each column is a solution
      hom:Matrix(F) := new(dim, #(rec.basis), 0)
      for i in minColIndex hom .. maxColIndex hom for b in rec.basis repeat
        hom(r, i) := b
      n:N := 1                 -- number of equations already solved
      while r > mr repeat
        r := r - 1
        c := c - 1
        firstnonzero(m, r) ^= c => error "backsolve: undetermined system"
        degree(eq := m(r, c)) > 0 => error "backsolve: pivot of order > 0"
        a := leadingCoefficient(eq)::F
        if part? then
           part(r + offset) := (v(r + offset) - applyLodo(m, r, part, n)) / a
        for i in minColIndex hom .. maxColIndex hom repeat
          hom(r, i) := - applyLodo0(m, r, hom, i, n)
        n := n + 1
      bas:List(V) := [column(hom,i) for i in minColIndex hom..maxColIndex hom]
      part? => [part, bas]
      ["failed", bas]

    solveInField(m, v, solve) ==
      ((n := nrows m) = ncols m) and
         ((u := M2F(diagonalMatrix [diff for i in 1..n] - m)) case MF) =>
             (uu := solve(u::MF, v, FSL2USL solve(#1, #2))) case "failed" =>
                  ["failed", empty()]
             rc := uu::Record(particular:V, basis:MF)
             [rc.particular, [column(rc.basis, i) for i in 1..ncols(rc.basis)]]
      rec := triangulate(m, v)
      backsolve(rec.mat, rec.vec, solve)

    M2F m ==
        mf:MF := new(nrows m, ncols m, 0)
        for i in minRowIndex m .. maxRowIndex m repeat
            for j in minColIndex m .. maxColIndex m repeat
                (u := retractIfCan(m(i, j))@Union(F, "failed")) case "failed" =>
                     return "failed"
                mf(i, j) := u::F
        mf

    FSL2USL rec ==
        rec.particular case "failed" => "failed"
        [rec.particular::F, rec.basis]

-- returns the index of the first nonzero entry in row r of m
    firstnonzero(m, r) ==
      for c in minColIndex m .. maxColIndex m repeat
        m(r, c) ^= 0 => return c
      error "firstnonzero: zero row"

-- computes +/[m(r, i) v(i) for i ranging over the last n columns of m]
    applyLodo(m, r, v, n) ==
      ans:F := 0
      c := maxColIndex m
      cv := maxIndex v
      for i in 1..n repeat
        ans := ans + m(r, c) (v cv)
        c := c - 1
        cv := cv - 1
      ans

-- computes +/[m(r, i) mm(i, c) for i ranging over the last n columns of m]
    applyLodo0(m, r, mm, c, n) ==
      ans := 0
      rr := maxRowIndex mm
      cc := maxColIndex m
      for i in 1..n repeat
        ans := ans + m(r, cc) mm(rr, c)
        cc := cc - 1
        rr := rr - 1
      ans

    triangulate(m:M, v:V) ==
      x := copy m
      w := copy v
      nrows := maxRowIndex x
      ncols := maxColIndex x
      minr  := i := minRowIndex x
      offset := minIndex w - minr
      for j in minColIndex x .. ncols repeat
        if i > nrows then leave x
        rown := minr - 1
        for k in i .. nrows repeat
          if (x(k, j) ^= 0) and ((rown = minr - 1) or
                              degree x(k,j) < degree x(rown,j)) then rown := k
          rown = minr - 1 => "enuf"
          x := swapRows_!(x, i, rown)
          swap_!(w, i + offset, rown + offset)
        for k in i+1 .. nrows | x(k, j) ^= 0 repeat
          l := rightLcm(x(i,j), x(k,j))
          a := rightQuotient(l, x(i, j))
          b := rightQuotient(l, x(k, j))
          -- l = a x(i,j) = b x(k,j)
          for k1 in j+1 .. ncols repeat
            x(k, k1) :=  a * x(i, k1) - b * x(k, k1)
          x(k, j) := 0
          w(k + offset) := a(w(i + offset)) - b(w(k + offset))
        i := i+1
      [x, w]

@
<<ODESYS.dotabb>>=
"ODESYS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ODESYS"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"ODESYS" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SYMFUNC SymmetricFunctions}
\pagehead{SymmetricFunctions}{SYMFUNC}
\pagepic{ps/v104symmetricfunctions.ps}{SYMFUNC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SYMFUNC SymmetricFunctions>>=
)abbrev package SYMFUNC SymmetricFunctions
++ The elementary symmetric functions
++ Author: Manuel Bronstein
++ Date Created: 13 Feb 1989
++ Date Last Updated: 28 Jun 1990
++ Description: Computes all the symmetric functions in n variables.
SymmetricFunctions(R:Ring): Exports == Implementation where
  UP  ==> SparseUnivariatePolynomial R

  Exports ==> with
    symFunc: List R  -> Vector R
      ++ symFunc([r1,...,rn]) returns the vector of the
      ++ elementary symmetric functions in the \spad{ri's}:
      ++ \spad{[r1 + ... + rn, r1 r2 + ... + r(n-1) rn, ..., r1 r2 ... rn]}.
    symFunc: (R, PositiveInteger) -> Vector R
      ++ symFunc(r, n) returns the vector of the elementary
      ++ symmetric functions in \spad{[r,r,...,r]} \spad{n} times.

  Implementation ==> add
    signFix: (UP, NonNegativeInteger) -> Vector R

    symFunc(x, n) == signFix((monomial(1, 1)$UP - x::UP) ** n, 1 + n)

    symFunc l ==
      signFix(*/[monomial(1, 1)$UP - a::UP for a in l], 1 + #l)

    signFix(p, n) ==
      m := minIndex(v := vectorise(p, n)) + 1
      for i in 0..((#v quo 2) - 1)::NonNegativeInteger repeat
        qsetelt_!(v, 2*i + m, - qelt(v, 2*i + m))
      reverse_! v

@
<<SYMFUNC.dotabb>>=
"SYMFUNC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SYMFUNC"]
"IVECTOR" [color="#88FF44",href="bookvol10.3.pdf#nameddest=IVECTOR"]
"SYMFUNC" -> "IVECTOR"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TBCMPPK TabulatedComputationPackage}
\pagehead{TabulatedComputationPackage}{TBCMPPK}
\pagepic{ps/v104tabulatedcomputationpackage.ps}{TBCMPPK}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TBCMPPK TabulatedComputationPackage>>=
)abbrev package TBCMPPK TabulatedComputationPackage
++ Author: Marc Moreno Maza
++ Date Created: 09/09/1998
++ Date Last Updated: 12/16/1998
++ Basic Functions:
++ Related Constructors:
++ Also See: 
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: 
++ \axiom{TabulatedComputationPackage(Key ,Entry)} provides some modest support
++   for dealing with operations with type \axiom{Key -> Entry}. The result of
++   such operations can be stored and retrieved with this package by using
++   a hash-table. The user does not need to worry about the management of
++   this hash-table. However, onnly one hash-table is built by calling
++   \axiom{TabulatedComputationPackage(Key ,Entry)}. 
++ Version: 2.

TabulatedComputationPackage(Key ,Entry): Exports == Implementation where
  Key: SetCategory
  Entry: SetCategory
  N ==> NonNegativeInteger
  H ==> HashTable(Key, Entry, "UEQUAL")
  iprintpack ==> InternalPrintPackage()

  Exports ==  with
     initTable!: () -> Void
       ++ \axiom{initTable!()} initializes the hash-table.
     printInfo!: (String, String) -> Void
       ++ \axiom{printInfo!(x,y)} initializes the mesages to be printed 
       ++ when manipulating items from the hash-table. If 
       ++ a key is retrieved then \axiom{x} is displayed. If an item is 
       ++ stored then \axiom{y} is displayed.
     startStats!: (String) -> Void
       ++ \axiom{startStats!(x)} initializes the statisitics process and
       ++ sets the comments to display when statistics are printed
     printStats!: () -> Void
       ++ \axiom{printStats!()} prints the statistics.
     clearTable!: () -> Void
       ++ \axiom{clearTable!()} clears the hash-table and assumes that
       ++ it will no longer be used.
     usingTable?: () -> Boolean
       ++ \axiom{usingTable?()} returns true iff the hash-table is used
     printingInfo?: () -> Boolean
       ++ \axiom{printingInfo?()} returns true iff messages are printed
       ++ when manipulating items from the hash-table.
     makingStats?: () -> Boolean
       ++ \axiom{makingStats?()} returns true iff the statisitics process
       ++ is running.
     extractIfCan: Key -> Union(Entry,"failed")
       ++ \axiom{extractIfCan(x)} searches the item whose key is \axiom{x}.
     insert!: (Key, Entry) -> Void
       ++ \axiom{insert!(x,y)} stores the item whose key is \axiom{x} and whose
       ++ entry is \axiom{y}.

  Implementation == add
     table?: Boolean := false
     t: H := empty()
     info?: Boolean := false
     stats?: Boolean := false
     used: NonNegativeInteger := 0
     ok: String := "o"
     ko: String := "+"
     domainName: String := empty()$String
     
     initTable!(): Void ==
       table? := true
       t := empty()
       void()
     printInfo!(s1: String, s2: String): Void ==
       (empty? s1) or (empty? s2) => void()
       not usingTable? =>
         error "in printInfo!()$TBCMPPK: not allowed to use hashtable"
       info? := true
       ok := s1
       ko := s2
       void()
     startStats!(s: String): Void == 
       empty? s => void()
       not table? =>
         error "in startStats!()$TBCMPPK: not allowed to use hashtable"
       stats? := true
       used := 0
       domainName := s
       void()
     printStats!(): Void == 
       not table? =>
         error "in printStats!()$TBCMPPK: not allowed to use hashtable"
       not stats? =>
         error "in printStats!()$TBCMPPK: statistics not started"
       output(" ")$OutputPackage
       title: String := concat("*** ", concat(domainName," Statistics ***"))
       output(title)$OutputPackage
       n: N := #t
       output("   Table     size: ", n::OutputForm)$OutputPackage
       output("   Entries reused: ", used::OutputForm)$OutputPackage
     clearTable!(): Void == 
       not table? =>
         error "in clearTable!()$TBCMPPK: not allowed to use hashtable"
       t := empty()
       table? := false
       info? := false
       stats? := false
       domainName := empty()$String
       void()
     usingTable?() == table?
     printingInfo?() == info?
     makingStats?() == stats?
     extractIfCan(k: Key): Union(Entry,"failed") ==
       not table? => "failed" :: Union(Entry,"failed")
       s: Union(Entry,"failed") := search(k,t)
       s case Entry => 
         if info? then iprint(ok)$iprintpack
         if stats? then used := used + 1
         return s
       "failed" :: Union(Entry,"failed")
     insert!(k: Key, e:Entry): Void ==
       not table? => void()
       t.k := e
       if info? then iprint(ko)$iprintpack
       void()

@
<<TBCMPPK.dotabb>>=
"TBCMPPK" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TBCMPPK"]
"TBAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TBAGG"]
"TBCMPPK" -> "TBAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TANEXP TangentExpansions}
\pagehead{TangentExpansions}{TANEXP}
\pagepic{ps/v104tangentexpansions.ps}{TANEXP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TANEXP TangentExpansions>>=
)abbrev package TANEXP TangentExpansions
++ Expansions of tangents of sums and quotients
++ Author: Manuel Bronstein
++ Date Created: 13 Feb 1989
++ Date Last Updated: 20 Apr 1990
++ Description: Expands tangents of sums and scalar products.
TangentExpansions(R:Field): Exports == Implementation where
  PI ==> PositiveInteger
  Z  ==> Integer
  UP ==> SparseUnivariatePolynomial R
  QF ==> Fraction UP

  Exports ==> with
    tanSum: List R -> R
      ++ tanSum([a1,...,an]) returns \spad{f(a1,...,an)} such that
      ++ if \spad{ai = tan(ui)} then \spad{f(a1,...,an) = tan(u1 + ... + un)}.
    tanAn : (R, PI) -> UP
      ++ tanAn(a, n) returns \spad{P(x)} such that
      ++ if \spad{a = tan(u)} then \spad{P(tan(u/n)) = 0}.
    tanNa : (R,  Z) -> R
      ++ tanNa(a, n) returns \spad{f(a)} such that
      ++ if \spad{a = tan(u)} then \spad{f(a) = tan(n * u)}.

  Implementation ==> add
    import SymmetricFunctions(R)
    import SymmetricFunctions(UP)

    m1toN : Integer -> Integer
    tanPIa: PI -> QF

    m1toN n     == (odd? n => -1; 1)
    tanAn(a, n) == a * denom(q := tanPIa n) - numer q

    tanNa(a, n) ==
      zero? n => 0
      negative? n => - tanNa(a, -n)
      (numer(t := tanPIa(n::PI)) a) / ((denom t) a)

    tanSum l ==
      m := minIndex(v := symFunc l)
      +/[m1toN(i+1) * v(2*i - 1 + m) for i in 1..(#v quo 2)]
        / +/[m1toN(i) * v(2*i + m) for i in 0..((#v - 1) quo 2)]

-- tanPIa(n) returns P(a)/Q(a) such that
-- if a = tan(u) then P(a)/Q(a) = tan(n * u);
    tanPIa n ==
      m := minIndex(v := symFunc(monomial(1, 1)$UP, n))
      +/[m1toN(i+1) * v(2*i - 1 + m) for i in 1..(#v quo 2)]
        / +/[m1toN(i) * v(2*i + m) for i in 0..((#v - 1) quo 2)]

@
<<TANEXP.dotabb>>=
"TANEXP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TANEXP"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"TANEXP" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TEMUTL TemplateUtilities}
\pagehead{TemplateUtilities}{TEMUTL}
\pagepic{ps/v104templateutilities.ps}{TEMUTL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TEMUTL TemplateUtilities>>=
)abbrev package TEMUTL TemplateUtilities
++ Author: Mike Dewar
++ Date Created:  October 1992
++ Date Last Updated: 
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description: This package provides functions for template manipulation
TemplateUtilities(): Exports == Implementation where

  Exports == with
    interpretString : String -> Any
      ++ interpretString(s) treats a string as a piece of AXIOM input, by
      ++ parsing and interpreting it.
    stripCommentsAndBlanks : String -> String
      ++ stripCommentsAndBlanks(s) treats s as a piece of AXIOM input, and
      ++ removes comments, and leading and trailing blanks.

  Implementation == add

    import InputForm

    stripC(s:String,u:String):String ==
      i : Integer := position(u,s,1)
      i = 0 => s
      delete(s,i..)

    stripCommentsAndBlanks(s:String):String ==
      trim(stripC(stripC(s,"++"),"--"),char " ")

    parse(s:String):InputForm ==
      ncParseFromString(s)$Lisp::InputForm 

    interpretString(s:String):Any ==
      interpret parse s

@
<<TEMUTL.dotabb>>=
"TEMUTL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TEMUTL"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"TEMUTL" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAW TopLevelDrawFunctions}
\pagehead{TopLevelDrawFunctions}{DRAW}
\pagepic{ps/v104topleveldrawfunctions.ps}{DRAW}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAW TopLevelDrawFunctions>>=
)abbrev package DRAW TopLevelDrawFunctions
++ Author: Clifton J. Williamson
++ Date Created: 23 January 1990
++ Date Last Updated: October 1991 by Jon Steinbach
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctions provides top level functions for 
++ drawing graphics of expressions.
TopLevelDrawFunctions(Ex:Join(ConvertibleTo InputForm,SetCategory)):
 Exports == Implementation where
  B    ==> Boolean
  BIND ==> SegmentBinding Float
  L    ==> List
  SF   ==> DoubleFloat
  DROP ==> DrawOption

  PPC  ==> ParametricPlaneCurve Ex
  PPCF ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve Ex
  PSCF ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface Ex
  PSFF ==> ParametricSurface((SF,SF) -> SF)
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with

--% Two Dimensional Function Plots

    draw: (Ex,BIND,L DROP) -> VIEW2
      ++ draw(f(x),x = a..b,l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{f(x)} is the 
      ++ default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (Ex,BIND) -> VIEW2
      ++ draw(f(x),x = a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{f(x)} appears 
      ++ in the title bar.

--% Parametric Plane Curves

    draw: (PPC,BIND,L DROP) -> VIEW2
      ++ draw(curve(f(t),g(t)),t = a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}; \spad{(f(t),g(t))} is the default title, and the
      ++ options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (PPC,BIND) -> VIEW2
      ++ draw(curve(f(t),g(t)),t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}; \spad{(f(t),g(t))} appears in the title bar.

--% Parametric Space Curves

    draw: (PSC,BIND,L DROP) -> VIEW3
      ++ draw(curve(f(t),g(t),h(t)),t = a..b,l) draws the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (PSC,BIND) -> VIEW3
      ++ draw(curve(f(t),g(t),h(t)),t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)} as t ranges
      ++ from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)} is the default
      ++ title.
    makeObject: (PSC,BIND,L DROP) -> SPACE3
      ++ makeObject(curve(f(t),g(t),h(t)),t = a..b,l) returns a space of
      ++ the domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject: (PSC,BIND) -> SPACE3
      ++ makeObject(curve(f(t),g(t),h(t)),t = a..b) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a,b)} to \spad{max(a,b)}; \spad{h(t)} is
      ++ the default title.

--% Three Dimensional Function Plots

    draw: (Ex,BIND,BIND,L DROP) -> VIEW3
      ++ draw(f(x,y),x = a..b,y = c..d,l) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} is the default
      ++ title, and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (Ex,BIND,BIND) -> VIEW3
      ++ draw(f(x,y),x = a..b,y = c..d) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} appears in the title bar.
    makeObject: (Ex,BIND,BIND,L DROP) -> SPACE3
      ++ makeObject(f(x,y),x = a..b,y = c..d,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of
      ++ \spad{z = f(x,y)} as x ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and y ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)}
      ++ is the default title, and the options contained in the list l of the
      ++ domain \spad{DrawOption} are applied.
    makeObject: (Ex,BIND,BIND) -> SPACE3
      ++ makeObject(f(x,y),x = a..b,y = c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}; \spad{f(x,y)} appears as the
      ++ default title.

--% Parametric Surfaces

    draw: (PSF,BIND,BIND,L DROP) -> VIEW3
      ++ draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (PSF,BIND,BIND) -> VIEW3
      ++ draw(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title.
    makeObject: (PSF,BIND,BIND,L DROP) -> SPACE3
      ++ makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d,l) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the graph
      ++ of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject: (PSF,BIND,BIND) -> SPACE3
      ++ makeObject(surface(f(u,v),g(u,v),h(u,v)),u = a..b,v = c..d) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}; \spad{h(t)} is
      ++ the default title.

  Implementation ==> add
    import TopLevelDrawFunctionsForCompiledFunctions
    import MakeFloatCompiledFunction(Ex)
    import ParametricPlaneCurve(SF -> SF)
    import ParametricSpaceCurve(SF -> SF)
    import ParametricSurface((SF,SF) -> SF)
    import ThreeSpace(SF)

------------------------------------------------------------------------
--                     2D - draw's  (given by formulae)
------------------------------------------------------------------------

--% Two Dimensional Function Plots
 
    draw(f:Ex,bind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM2D",l)
        else l := concat(title s,l)
      -- call 'draw'
      draw(makeFloatFunction(f,variable bind),segment bind,l)
 
    draw(f:Ex,bind:BIND) == draw(f,bind,nil())
 
--% Parametric Plane Curves

    draw(ppc:PPC,bind:BIND,l:L DROP) ==
      f := coordinate(ppc,1); g := coordinate(ppc,2)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM2D",l)
        else l := concat(title s,l)
      -- create curve with functions as coordinates
      curve : PPCF := curve(makeFloatFunction(f,variable bind),_
                            makeFloatFunction(g,variable bind))$PPCF
      -- call 'draw'
      draw(curve,segment bind,l)
 
    draw(ppc:PPC,bind:BIND) == draw(ppc,bind,nil())

------------------------------------------------------------------------
--                     3D - Curves  (given by formulas)
------------------------------------------------------------------------

    makeObject(psc:PSC,tBind:BIND,l:L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f,t),_
                            makeFloatFunction(g,t),_
                            makeFloatFunction(h,t))
      -- call 'draw'
      makeObject(curve,tSeg,l)

    makeObject(psc:PSC,tBind:BIND) ==
      makeObject(psc,tBind,nil())

    draw(psc:PSC,tBind:BIND,l:L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f,t),_
                            makeFloatFunction(g,t),_
                            makeFloatFunction(h,t))
      -- call 'draw'
      draw(curve,tSeg,l)

    draw(psc:PSC,tBind:BIND) ==
      draw(psc,tBind,nil())

------------------------------------------------------------------------
--                     3D - Surfaces  (given by formulas)
------------------------------------------------------------------------

--% Three Dimensional Function Plots

    makeObject(f:Ex,xBind:BIND,yBind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'draw'
      makeObject(makeFloatFunction(f,x,y),xSeg,ySeg,l)

    makeObject(f:Ex,xBind:BIND,yBind:BIND) ==
      makeObject(f,xBind,yBind,nil())

    draw(f:Ex,xBind:BIND,yBind:BIND,l:L DROP) ==
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'draw'
      draw(makeFloatFunction(f,x,y),xSeg,ySeg,l)

    draw(f:Ex,xBind:BIND,yBind:BIND) ==
      draw(f,xBind,yBind,nil())

--% parametric surface

    makeObject(s:PSF,uBind:BIND,vBind:BIND,l:L DROP) ==
      f := coordinate(s,1); g := coordinate(s,2); h := coordinate(s,3)
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      surf : PSFF := surface(makeFloatFunction(f,u,v),_
                             makeFloatFunction(g,u,v),_
                             makeFloatFunction(h,u,v))
      makeObject(surf,uSeg,vSeg,l)

    makeObject(s:PSF,uBind:BIND,vBind:BIND) ==
      makeObject(s,uBind,vBind,nil())

    draw(s:PSF,uBind:BIND,vBind:BIND,l:L DROP) ==
      f := coordinate(s,1); g := coordinate(s,2); h := coordinate(s,3)
      -- create title if necessary
      if not option?(l,"title" :: Symbol) then
        s:String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "AXIOM3D",l)
        else l := concat(title s,l)
      -- indicate draw style if necessary
      if not option?(l,"style" :: Symbol) then
        l := concat(style unparse(convert(f)@InputForm),l)
      -- obtain dependent variables and their ranges
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      -- create surface with functions as coordinates
      surf : PSFF := surface(makeFloatFunction(f,u,v),_
                             makeFloatFunction(g,u,v),_
                             makeFloatFunction(h,u,v))
      -- call 'draw'
      draw(surf,uSeg,vSeg,l)

    draw(s:PSF,uBind:BIND,vBind:BIND) ==
      draw(s,uBind,vBind,nil())

@
<<DRAW.dotabb>>=
"DRAW" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAW"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DRAW" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves}
\pagehead{TopLevelDrawFunctionsForAlgebraicCurves}{DRAWCURV}
\pagepic{ps/v104topleveldrawfunctionsforalgebraiccurves.ps}{DRAWCURV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves>>=
)abbrev package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves
++ Author: Clifton J. Williamson
++ Date Created: 26 June 1990
++ Date Last Updated:  October 1991 by Jon Steinbach
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForAlgebraicCurves provides top level 
++ functions for drawing non-singular algebraic curves.

TopLevelDrawFunctionsForAlgebraicCurves(R,Ex): Exports == Implementation where
  R  : Join(IntegralDomain, OrderedSet, RetractableTo Integer)
  Ex : FunctionSpace(R)

  ANY1  ==> AnyFunctions1
  DROP  ==> DrawOption
  EQ    ==> Equation
  F     ==> Float
  FRAC  ==> Fraction
  I     ==> Integer
  L     ==> List
  P     ==> Polynomial
  RN    ==> Fraction Integer
  SEG   ==> Segment
  SY    ==> Symbol
  VIEW2 ==> TwoDimensionalViewport

  Exports ==> with

    draw: (EQ Ex,SY,SY,L DROP) -> VIEW2
      ++ draw(f(x,y) = g(x,y),x,y,l) draws the graph of a polynomial
      ++ equation.  The list l of draw options must specify a region
      ++ in the plane in which the curve is to sketched.

  Implementation ==> add
    import ViewportPackage
    import PlaneAlgebraicCurvePlot
    import ViewDefaultsPackage
    import GraphicsDefaults
    import DrawOptionFunctions0
    import SegmentFunctions2(RN,F)
    import SegmentFunctions2(F,RN)
    import AnyFunctions1(L SEG RN)

    drawToScaleRanges: (SEG F,SEG F) -> L SEG F
    drawToScaleRanges(xVals,yVals) ==
      -- warning: assumes window is square
      xHi := hi xVals; xLo := lo xVals
      yHi := hi yVals; yLo := lo yVals
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad,xHi + pad),yVals]
      [xVals,segment(yLo - pad,yHi + pad)]

    intConvert: R -> I
    intConvert r ==
      (nn := retractIfCan(r)@Union(I,"failed")) case "failed" =>
        error "draw: polynomial must have rational coefficients"
      nn :: I

    polyEquation: EQ Ex -> P I
    polyEquation eq ==
      ff := lhs(eq) - rhs(eq)
      (r := retractIfCan(ff)@Union(FRAC P R,"failed")) case "failed" =>
        error "draw: not a polynomial equation"
      rat := r :: FRAC P R
      retractIfCan(denom rat)@Union(R,"failed") case "failed" =>
        error "draw: non-constant denominator"
      map(intConvert,numer rat)$PolynomialFunctions2(R,I)

    draw(eq,x,y,l) ==
      -- obtain polynomial equation
      p := polyEquation eq
      -- extract ranges from option list
      floatRange := option(l,"rangeFloat" :: Symbol)
      ratRange := option(l,"rangeRat" :: Symbol)
      (floatRange case "failed") and (ratRange case "failed") =>
        error "draw: you must specify ranges for an implicit plot"
      ranges : L SEG RN := nil()             -- dummy value
      floatRanges : L SEG F := nil()         -- dummy value
      xRange : SEG RN := segment(0,0)        -- dummy value
      yRange : SEG RN := segment(0,0)        -- dummy value
      xRangeFloat : SEG F := segment(0,0)    -- dummy value
      yRangeFloat : SEG F := segment(0,0)    -- dummy value
      if not ratRange case "failed" then
        ranges := retract(ratRange :: Any)$ANY1(L SEG RN)
        not size?(ranges,2) => error "draw: you must specify two ranges"
        xRange := first ranges; yRange := second ranges
        xRangeFloat := map(convert(#1)@Float,xRange)@(SEG F)
        yRangeFloat := map(convert(#1)@Float,yRange)@(SEG F)
        floatRanges := [xRangeFloat,yRangeFloat]
      else
        floatRanges := retract(floatRange :: Any)$ANY1(L SEG F)
        not size?(floatRanges,2) =>
          error "draw: you must specify two ranges"
        xRangeFloat := first floatRanges
        yRangeFloat := second floatRanges
        xRange := map(retract(#1)@RN,xRangeFloat)@(SEG RN)
        yRange := map(retract(#1)@RN,yRangeFloat)@(SEG RN)
        ranges := [xRange,yRange]
      -- create curve plot
      acplot := makeSketch(p,x,y,xRange,yRange)
      -- process scaling information
      if toScale(l,drawToScale()) then
        scaledRanges := drawToScaleRanges(xRangeFloat,yRangeFloat)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges,l)
      else
        -- add ranges to list of options
        l := concat(ranges floatRanges,l)
      -- process color information
      ptCol := pointColorPalette(l,pointColorDefault())
      crCol := curveColorPalette(l,lineColorDefault())
      -- draw
      drawCurves(listBranches acplot,ptCol,crCol,pointSizeDefault(),l)

@
<<DRAWCURV.dotabb>>=
"DRAWCURV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCURV"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"DRAWCURV" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions}
\pagehead{TopLevelDrawFunctionsForCompiledFunctions}{DRAWCFUN}
\pagepic{ps/v104topleveldrawfunctionsforcompiledfunctions.ps}{DRAWCFUN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=
)abbrev package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions
++ Author: Clifton J. Williamson
++ Date Created: 22 June 1990
++ Date Last Updated: January 1992 by Scott Morrison
++ Basic Operations: draw, recolor
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForCompiledFunctions provides top level 
++ functions for drawing graphics of expressions.
TopLevelDrawFunctionsForCompiledFunctions():
 Exports == Implementation where
  ANY1 ==> AnyFunctions1
  B    ==> Boolean
  F    ==> Float
  L    ==> List
  SEG  ==> Segment Float
  SF   ==> DoubleFloat
  DROP ==> DrawOption
  PLOT ==> Plot
  PPC  ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface((SF,SF) -> SF)
  Pt   ==> Point SF
  PSFUN ==> (SF, SF) -> Pt
  PCFUN ==> SF -> Pt
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with

--% Two Dimensional Function Plots

    draw: (SF -> SF,SEG,L DROP) -> VIEW2
      ++ draw(f,a..b,l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (SF -> SF,SEG) -> VIEW2
      ++ draw(f,a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.

--% Parametric Plane Curves

    draw: (PPC,SEG,L DROP) -> VIEW2
      ++ draw(curve(f,g),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (PPC,SEG) -> VIEW2
      ++ draw(curve(f,g),a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a,b)} to 
      ++ \spad{max(a,b)}.

--% Parametric Space Curves

    draw: (PSC,SEG,L DROP) -> VIEW3
      ++ draw(curve(f,g,h),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (PSC,SEG) -> VIEW3
      ++ draw(curve(f,g,h),a..b,l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
    draw: (PCFUN,SEG,L DROP) -> VIEW3
      ++ draw(f,a..b,l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: (PCFUN,SEG) -> VIEW3
      ++ draw(f,a..b,l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.

    makeObject: (PSC,SEG,L DROP) -> SPACE3
      ++ makeObject(curve(f,g,h),a..b,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)};
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject: (PSC,SEG) -> SPACE3
      ++ makeObject(sp,curve(f,g,h),a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.
    makeObject: (PCFUN,SEG,L DROP) -> SPACE3
      ++ makeObject(curve(f,g,h),a..b,l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from 
      ++ \spad{min(a,b)} to \spad{max(a,b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject: (PCFUN,SEG) -> SPACE3
      ++ makeObject(sp,curve(f,g,h),a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a,b)} to \spad{max(a,b)}.

--% Three Dimensional Function Plots

    draw: ((SF,SF) -> SF,SEG,SEG,L DROP) -> VIEW3
      ++ draw(f,a..b,c..d,l) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.
      ++ and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    draw: ((SF,SF) -> SF,SEG,SEG) -> VIEW3
      ++ draw(f,a..b,c..d) draws the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.
    makeObject: ((SF,SF) -> SF,SEG,SEG,L DROP) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}, and the options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: ((SF,SF) -> SF,SEG,SEG) -> SPACE3
      ++ makeObject(f,a..b,c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x,y)}
      ++ as x ranges from \spad{min(a,b)} to \spad{max(a,b)} and y ranges from
      ++ \spad{min(c,d)} to \spad{max(c,d)}.

--% Parametric Surfaces

    draw: (PSFUN, SEG, SEG, L DROP) -> VIEW3
      ++ draw(f,a..b,c..d) draws the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    draw: (PSFUN, SEG, SEG) -> VIEW3
      ++ draw(f,a..b,c..d) draws the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)}
      ++ The options contained in the list
      ++ l of the domain \spad{DrawOption} are applied.
    makeObject: (PSFUN, SEG, SEG, L DROP) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: (PSFUN, SEG, SEG) -> SPACE3
      ++ makeObject(f,a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u,v)}
      ++ as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
    draw: (PSF,SEG,SEG,L DROP) -> VIEW3
      ++ draw(surface(f,g,h),a..b,c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    draw: (PSF,SEG,SEG) -> VIEW3
      ++ draw(surface(f,g,h),a..b,c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to \spad{max(a,b)}
      ++ and v ranges from \spad{min(c,d)} to \spad{max(c,d)};
    makeObject: (PSF,SEG,SEG,L DROP) -> SPACE3
      ++ makeObject(surface(f,g,h),a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject: (PSF,SEG,SEG) -> SPACE3
      ++ makeObject(surface(f,g,h),a..b,c..d,l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u,v)}, \spad{y = g(u,v)},
      ++ \spad{z = h(u,v)} as u ranges from \spad{min(a,b)} to
      ++ \spad{max(a,b)} and v ranges from \spad{min(c,d)} to \spad{max(c,d)}.
    recolor: ((SF,SF) -> Pt,(SF,SF,SF) -> SF) -> ((SF,SF) -> Pt)
      ++ recolor(), uninteresting to top level user; exported in order to 
      ++ compile package.

  Implementation ==> add
@
I have had to work my way around the following bug in the compiler:
When a local variable is given a mapping as a value, e.g.
\begin{verbatim}
   foo : SF -> SF := makeFloatFunction(f,t),
\end{verbatim}
the compiler cannot distinguish that local variable from a local
function defined elsewhere in the package.  Thus, when 'foo' is
passed to a function, e.g.
\begin{verbatim}
  bird := fcn(foo),
\end{verbatim}
foo will often be compiled as [[|DRAW;foo|]] rather than [[|foo|]]. This,
of course, causes a run-time error.

To avoid this problem, local variables are not given mappings as
values, but rather (singleton) lists of mappings.  The first element
of the list can always be extracted and everything goes through
as before.  There is no major loss in efficiency, as the computation
of points will always dominate the computation time.\\
\ \ \ \  - cjw,  22 June MCMXC
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    import PLOT
    import TwoDimensionalPlotClipping
    import GraphicsDefaults
    import ViewportPackage
    import ThreeDimensionalViewport
    import DrawOptionFunctions0
    import MakeFloatCompiledFunction(Ex)
    import MeshCreationRoutinesForThreeDimensions
    import SegmentFunctions2(SF,Float)
    import ViewDefaultsPackage
    import AnyFunctions1(Pt -> Pt)
    import AnyFunctions1((SF,SF,SF) -> SF)
    import DrawOptionFunctions0
    import SPACE3

    EXTOVARERROR : String := _
      "draw: when specifying function, left hand side must be a variable"
    SMALLRANGEERROR : String := _
      "draw: range is in interval with only one point"
    DEPVARERROR : String := _
      "draw: independent variable appears on lhs of function definition"

------------------------------------------------------------------------
--                     2D - draw's  
------------------------------------------------------------------------

    drawToScaleRanges: (Segment SF,Segment SF) -> L SEG
    drawToScaleRanges(xVals,yVals) ==
      -- warning: assumes window is square
      xHi := convert(hi xVals)@Float; xLo := convert(lo xVals)@Float
      yHi := convert(hi yVals)@Float; yLo := convert(lo yVals)@Float
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad,xHi + pad),map(convert(#1)@Float,yVals)]
      [map(convert(#1)@Float,xVals),segment(yLo - pad,yHi + pad)]

    drawPlot: (PLOT,L DROP) -> VIEW2
    drawPlot(plot,l) ==
      branches := listBranches plot
      xRange := xRange plot; yRange := yRange plot
      -- process clipping information
      if (cl := option(l,"clipSegment" :: Symbol)) case "failed" then
        if clipBoolean(l,clipPointsDefault()) then
          clipInfo :=
            parametric? plot => clipParametric plot
            clip plot
          branches := clipInfo.brans
          xRange := clipInfo.xValues; yRange := clipInfo.yValues
        else
          "No explicit user-specified clipping"
      else
        segList := retract(cl :: Any)$ANY1(L SEG)
        empty? segList =>
          error "draw: you may specify at least 1 segment for 2D clipping"
        more?(segList,2) =>
          error "draw: you may specify at most 2 segments for 2D clipping"
        xLo : SF := 0; xHi : SF := 0; yLo : SF := 0; yHi : SF := 0
        if empty? rest segList then
          xLo := lo xRange; xHi := hi xRange
          yRangeF := first segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        else
          xRangeF := first segList
          xLo := convert(lo xRangeF)@SF; xHi := convert(hi xRangeF)@SF
          yRangeF := second segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        clipInfo := clipWithRanges(branches,xLo,xHi,yLo,yHi)
        branches := clipInfo.brans
        xRange := clipInfo.xValues; yRange := clipInfo.yValues
      -- process scaling information
      if toScale(l,drawToScale()) then
        scaledRanges := drawToScaleRanges(xRange,yRange)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges,l)
      else
        xRangeFloat : SEG := map(convert(#1)@Float,xRange)
        yRangeFloat : SEG := map(convert(#1)@Float,yRange)
        -- add ranges to list of options
        l := concat(ranges(ll : L SEG := [xRangeFloat,yRangeFloat]),l)
      -- process color information
      ptCol := pointColorPalette(l,pointColorDefault())
      crCol := curveColorPalette(l,lineColorDefault())
      -- draw
      drawCurves(branches,ptCol,crCol,pointSizeDefault(),l)

    normalize: SEG -> Segment SF
    normalize seg ==
      -- normalize [a,b]:
      -- error if a = b, returns [a,b] if a < b, returns [b,a] if b > a
      a := convert(lo seg)@SF; b := convert(hi seg)@SF
      a = b => error SMALLRANGEERROR
      a < b => segment(a,b)
      segment(b,a)

@
The function {\tt myTrap1} is a local function for used in creating
maps SF -> Point SF (two dimensional). The range of this function
is SingleFloat. As originally coded it would return {\tt \$NaNvalue\$Lisp}
which is outside the range. Since this function is only used internallly
by the draw package we handle the ``failed'' case by returning zero.
We handle the out-of-range case by returning the maximum or minimum
SingleFloat value.
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    myTrap1: (SF-> SF, SF) -> SF
    myTrap1(ff:SF-> SF, f:SF):SF ==
      s := trapNumericErrors(ff(f))$Lisp :: Union(SF, "failed")
      s case "failed" => 0
      r:=s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    makePt2: (SF,SF) -> Point SF
    makePt2(x,y) == point(l : List SF := [x,y])

--% Two Dimensional Function Plots
 
    draw(f:SF -> SF,seg:SEG,l:L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l,oldAdaptive))$PLOT
      -- create function SF -> Point SF
      ff : L(SF -> Point SF) := [makePt2(myTrap1(f,#1),#1)]
      -- process change of coordinates
      if (c := option(l,"coordinates" :: Symbol)) case "failed" then
        -- default coordinate transformation
        ff := [makePt2(#1,myTrap1(f,#1))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        ff := [(first cc)((first ff)(#1))]
      -- create PLOT
      pl := pointPlot(first ff,normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- draw
      drawPlot(pl,l)
 
    draw(f:SF -> SF,seg:SEG) == draw(f,seg,nil())
 
--% Parametric Plane Curves

    draw(ppc:PPC,seg:SEG,l:L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l,oldAdaptive))$PLOT
      -- create function SF -> Point SF
      f := coordinate(ppc,1); g := coordinate(ppc,2)
      fcn : L(SF -> Pt) := [makePt2(myTrap1(f,#1),myTrap1(g,#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- draw
      drawPlot(pl,l)
 
    draw(ppc:PPC,seg:SEG) == draw(ppc,seg,nil())

------------------------------------------------------------------------
--                     3D - Curves  
------------------------------------------------------------------------

--% functions for creation of maps SF -> Point SF (three dimensional)

    makePt4: (SF,SF,SF,SF) -> Point SF
    makePt4(x,y,z,c) == point(l : List SF := [x,y,z,c])

--% Parametric Space Curves

    id: SF -> SF
    id x == x

    zCoord: (SF,SF,SF) -> SF
    zCoord(x,y,z) == z

    colorPoints: (List List Pt,(SF,SF,SF) -> SF) -> List List Pt
    colorPoints(llp,func) ==
      for lp in llp repeat for p in lp repeat
        p.4 := func(p.1,p.2,p.3)
      llp

    makeObject(psc:PSC,seg:SEG,l:L DROP) ==
      sp := space l
      -- obtain dependent variable and coordinate functions
      f := coordinate(psc,1); g := coordinate(psc,2); h := coordinate(psc,3)
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [makePt4(myTrap1(f,#1),myTrap1(g,#1),myTrap1(h,#1),_
                            myTrap1(id,#1))]
      pointsColored? : Boolean := false
      if not (c1 := option(l,"colorFunction1" :: Symbol)) case "failed" then
        pointsColored? := true
        fcn := [makePt4(myTrap1(f,#1),myTrap1(g,#1),myTrap1(h,#1),_
                retract(c1 :: Any)$ANY1(SF -> SF)(#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- draw Tube
--      print(pl::OutputForm)
      option?(l,"tubeRadius" :: Symbol) =>
        pts := tubePoints(l,8)
        rad := convert(tubeRadius(l,0.25))@DoubleFloat
        tub := tube(pl,rad,pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        if not pointsColored? then
          if (c3 := option(l,"colorFunction3" :: Symbol)) case "failed"
            then colorPoints(loops,zCoord)  -- default color function
            else colorPoints(loops,retract(c3 :: Any)$ANY1((SF,SF,SF) -> SF))
        mesh(s,loops,false,false)
        s
      -- draw curve
      br := listBranches pl
      for b in br repeat curve(s,b)
      s

    makeObject(psc:PCFUN,seg:SEG,l:L DROP) ==
      sp := space l
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [psc]
      pointsColored? : Boolean := false
      if not (c1 := option(l,"colorFunction1" :: Symbol)) case "failed" then
        pointsColored? := true
        fcn := [concat(psc(#1), retract(c1 :: Any)$ANY1(SF -> SF)(#1))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1))]
      -- create PLOT
      pl := pointPlot(first fcn,normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- draw Tube
      option?(l,"tubeRadius" :: Symbol) =>
        pts := tubePoints(l,8)
        rad := convert(tubeRadius(l,0.25))@DoubleFloat
        tub := tube(pl,rad,pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        mesh(s,loops,false,false)
        s
      -- draw curve
      br := listBranches pl
      for b in br repeat curve(s,b)
      s

    makeObject(psc:PSC,seg:SEG) ==
      makeObject(psc,seg,nil())

    makeObject(psc:PCFUN,seg:SEG) ==
      makeObject(psc,seg,nil())

    draw(psc:PSC,seg:SEG,l:L DROP) ==
      sp := makeObject(psc,seg,l)
      makeViewport3D(sp, l)

    draw(psc:PSC,seg:SEG) ==
      draw(psc,seg,nil())

    draw(psc:PCFUN,seg:SEG,l:L DROP) ==
      sp := makeObject(psc,seg,l)
      makeViewport3D(sp, l)

    draw(psc:PCFUN,seg:SEG) ==
      draw(psc,seg,nil())

------------------------------------------------------------------------
--                     3D - Surfaces  
------------------------------------------------------------------------

@
The function {\tt myTrap2} is a local function for used in creating
maps SF -> Point SF (three dimensional). The range of this function
is SingleFloat. As originally coded it would return {\tt \$NaNvalue\$Lisp}
which is outside the range. Since this function is only used internallly
by the draw package we handle the ``failed'' case by returning zero.
We handle the out-of-range case by returning the maximum or minimum
SingleFloat value.
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>=

    myTrap2: ((SF, SF) -> SF, SF, SF) -> SF
    myTrap2(ff:(SF, SF) -> SF, u:SF, v:SF):SF ==
      s := trapNumericErrors(ff(u, v))$Lisp :: Union(SF, "failed")
      s case "failed" => 0
      r:SF := s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    recolor(ptFunc,colFunc) ==
      pt := ptFunc(#1,#2)
      pt.4 := colFunc(pt.1,pt.2,pt.3)
      pt

    xCoord: (SF,SF) -> SF
    xCoord(x,y) == x

--% Three Dimensional Function Plots

    makeObject(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG,l:L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) :=
        [makePt4(myTrap2(f,#1,#2),#1,#2,(first col2)(#1,#2))]
      -- process change of coordinates
      if (c := option(l,"coordinates" :: Symbol)) case "failed" then
        -- default coordinate transformation
        fcn := [makePt4(#1,#2,myTrap2(f,#1,#2),(first col2)(#1,#2))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        c := option(l,"colorFunction3" :: Symbol)
        fcn := 
          c case "failed" => [recolor((first fcn),zCoord)]
          [recolor((first fcn),retract(c :: Any)$ANY1((SF,SF,SF) -> SF))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize xSeg,normalize ySeg,l)
      mesh

    makeObject(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG) ==
      makeObject(f,xSeg,ySeg,nil())

    draw(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG,l:L DROP) ==
      sp := makeObject(f, xSeg, ySeg, l)
      makeViewport3D(sp, l)

    draw(f:(SF,SF) -> SF,xSeg:SEG,ySeg:SEG) ==
      draw(f,xSeg,ySeg,nil())

--% parametric surface

    makeObject(s:PSF,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      sp := space l
      -- create functions from expressions
      f : L((SF,SF) -> SF) := [coordinate(s,1)]
      g : L((SF,SF) -> SF) := [coordinate(s,2)]
      h : L((SF,SF) -> SF) := [coordinate(s,3)]
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) := 
        [makePt4(myTrap2((first f),#1,#2),myTrap2((first g),#1,#2),myTrap2((first h),#1,#2),_
                 myTrap2((first col2),#1,#2))]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        col3 : L((SF,SF,SF) -> SF) := [zCoord]  -- default color function
        if not (c := option(l,"colorFunction3" :: Symbol)) case "failed" then 
          col3 := [retract(c :: Any)$ANY1((SF,SF,SF) -> SF)]
        fcn := [recolor((first fcn),(first col3))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize uSeg,normalize vSeg,l)
      mesh

    makeObject(s:PSFUN,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF,SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l,"colorFunction2" :: Symbol)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF,SF) -> SF)]
      fcn : L((SF,SF) -> Pt) := 
        pointsColored? => [concat(s(#1, #2), (first col2)(#1, #2))]
        [s]
      -- process change of coordinates
      if not (c := option(l,"coordinates" :: Symbol)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(first cc)((first fcn)(#1,#2))]
      -- create mesh
      mesh := meshPar2Var(sp,first fcn,normalize uSeg,normalize vSeg,l)
      mesh

    makeObject(s:PSF,uSeg:SEG,vSeg:SEG) ==
      makeObject(s,uSeg,vSeg,nil())

    draw(s:PSF,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      -- draw
      mesh := makeObject(s,uSeg,vSeg,l)
      makeViewport3D(mesh,l)

    draw(s:PSF,uSeg:SEG,vSeg:SEG) ==
      draw(s,uSeg,vSeg,nil())
 
    makeObject(s:PSFUN,uSeg:SEG,vSeg:SEG) ==
      makeObject(s,uSeg,vSeg,nil())

    draw(s:PSFUN,uSeg:SEG,vSeg:SEG,l:L DROP) ==
      -- draw
      mesh := makeObject(s,uSeg,vSeg,l)
      makeViewport3D(mesh,l)

    draw(s:PSFUN,uSeg:SEG,vSeg:SEG) ==
      draw(s,uSeg,vSeg,nil())
 
@
<<DRAWCFUN.dotabb>>=
"DRAWCFUN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWCFUN"]
"ALIST" [color="#88FF44",href="bookvol10.3.pdf#nameddest=ALIST"]
"DRAWCFUN" -> "ALIST"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package DRAWPT TopLevelDrawFunctionsForPoints}
\pagehead{TopLevelDrawFunctionsForPoints}{DRAWPT}
\pagepic{ps/v104topleveldrawfunctionsforpoints.ps}{DRAWPT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package DRAWPT TopLevelDrawFunctionsForPoints>>=
)abbrev package DRAWPT TopLevelDrawFunctionsForPoints
++ Author: Mike Dewar
++ Date Created: 24 May 1995
++ Date Last Updated: 25 November 1996
++ Basic Operations: draw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForPoints provides top level functions 
++ for drawing curves and surfaces described by sets of points.
 
TopLevelDrawFunctionsForPoints(): Exports == Implementation where

  DROP  ==> DrawOption
  L     ==> List
  SF    ==> DoubleFloat
  Pt    ==> Point SF
  VIEW2 ==> TwoDimensionalViewport
  VIEW3 ==> ThreeDimensionalViewport

  Exports ==> with
    draw: (L SF,L SF) -> VIEW2
      ++ draw(lx,ly) plots the curve constructed of points (x,y) for x
      ++ in \spad{lx} for y in \spad{ly}.
    draw: (L SF,L SF,L DROP) -> VIEW2
      ++ draw(lx,ly,l) plots the curve constructed of points (x,y) for x
      ++ in \spad{lx} for y in \spad{ly}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    draw: (L Pt) -> VIEW2
      ++ draw(lp) plots the curve constructed from the list of points lp.
    draw: (L Pt,L DROP) -> VIEW2
      ++ draw(lp,l) plots the curve constructed from the list of points lp.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    draw: (L SF, L SF, L SF) -> VIEW3
      ++ draw(lx,ly,lz) draws the surface constructed by projecting the values
      ++ in the \axiom{lz} list onto the rectangular grid formed by the 
      ++ \axiom{lx X ly}.
    draw: (L SF, L SF, L SF, L DROP) -> VIEW3
      ++ draw(lx,ly,lz,l) draws the surface constructed by 
      ++ projecting the values
      ++ in the \axiom{lz} list onto the rectangular grid formed by the 
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.

  Implementation ==> add

    draw(lp:L Pt,l:L DROP):VIEW2 ==
      makeViewport2D(makeGraphImage([lp])$GraphImage,l)$VIEW2

    draw(lp:L Pt):VIEW2 == draw(lp,[])

    draw(lx: L SF, ly: L SF, l:L DROP):VIEW2 ==
      draw([point([x,y])$Pt for x in lx for y in ly],l)

    draw(lx: L SF, ly: L SF):VIEW2 == draw(lx,ly,[])

    draw(x:L SF,y:L SF,z:L SF):VIEW3 == draw(x,y,z,[])

    draw(x:L SF,y:L SF,z:L SF,l:L DROP):VIEW3 ==
      m  : Integer := #x
      zero? m => error "No X values"
      n  : Integer := #y
      zero? n => error "No Y values"
      zLen : Integer := #z
      zLen ~= (m*n) => 
        zLen > (m*n) => error "Too many Z-values to fit grid"
        error "Not enough Z-values to fit grid"
      points : L L Pt := []
      for j in n..1 by -1 repeat
        row : L Pt := []
        for i in m..1 by -1 repeat
          zval := (j-1)*m+i
          row := cons(point([x.i,y.j,z.zval,z.zval]),row)
        points := cons(row,points)
      makeViewport3D(mesh points,l)

@
<<DRAWPT.dotabb>>=
"DRAWPT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=DRAWPT"]
"FIELD"  [color="#4488FF",href="bookvol10.2.pdf#nameddest=FIELD"]
"RADCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=RADCAT"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"DRAWPT" -> "FIELD"
"DRAWPT" -> "RADCAT"
"DRAWPT" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTHERTR TranscendentalHermiteIntegration}
\pagehead{TranscendentalHermiteIntegration}{INTHERTR}
\pagepic{ps/v104transcendentalhermiteintegration.ps}{INTHERTR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTHERTR TranscendentalHermiteIntegration>>=
)abbrev package INTHERTR TranscendentalHermiteIntegration
++ Hermite integration, transcendental case
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 12 August 1992
++ Description: Hermite integration, transcendental case.
TranscendentalHermiteIntegration(F, UP): Exports == Implementation where
  F  : Field
  UP : UnivariatePolynomialCategory F

  N   ==> NonNegativeInteger
  RF  ==> Fraction UP
  REC ==> Record(answer:RF, lognum:UP, logden:UP)
  HER ==> Record(answer:RF, logpart:RF, specpart:RF, polypart:UP)

  Exports ==> with
    HermiteIntegrate: (RF, UP -> UP) -> HER
         ++ HermiteIntegrate(f, D) returns \spad{[g, h, s, p]}
         ++ such that \spad{f = Dg + h + s + p},
         ++ h has a squarefree denominator normal w.r.t. D,
         ++ and all the squarefree factors of the denominator of s are
         ++ special w.r.t. D. Furthermore, h and s have no polynomial parts.
         ++ D is the derivation to use on \spadtype{UP}.

  Implementation ==> add
    import MonomialExtensionTools(F, UP)

    normalHermiteIntegrate: (RF,UP->UP) -> Record(answer:RF,lognum:UP,logden:UP)

    HermiteIntegrate(f, derivation) ==
      rec := decompose(f, derivation)
      hi  := normalHermiteIntegrate(rec.normal, derivation)
      qr  := divide(hi.lognum, hi.logden)
      [hi.answer, qr.remainder / hi.logden, rec.special, qr.quotient + rec.poly]

-- Hermite Reduction on f, every squarefree factor of denom(f) is normal wrt D
-- this is really a "parallel" Hermite reduction, in the sense that
-- every multiple factor of the denominator gets reduced at each pass
-- so if the denominator is P1 P2**2 ... Pn**n, this requires O(n)
-- reduction steps instead of O(n**2), like Mack's algorithm
-- (D.Mack, On Rational Integration, Univ. of Utah C.S. Tech.Rep. UCP-38,1975)
-- returns [g, b, d] s.t. f = g' + b/d and d is squarefree and normal wrt D
    normalHermiteIntegrate(f, derivation) ==
      a := numer f
      q := denom f
      p:UP    := 0
      mult:UP := 1
      qhat := (q exquo (g0 := g := gcd(q, differentiate q)))::UP
      while(degree(qbar := g) > 0) repeat
        qbarhat := (qbar exquo (g := gcd(qbar, differentiate qbar)))::UP
        qtil:= - ((qhat * (derivation qbar)) exquo qbar)::UP
        bc :=
         extendedEuclidean(qtil, qbarhat, a)::Record(coef1:UP, coef2:UP)
        qr := divide(bc.coef1, qbarhat)
        a  := bc.coef2 + qtil * qr.quotient - derivation(qr.remainder)
               * (qhat exquo qbarhat)::UP
        p  := p + mult * qr.remainder
        mult:= mult * qbarhat
      [p / g0, a, qhat]

@
<<INTHERTR.dotabb>>=
"INTHERTR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTHERTR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INTHERTR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package INTTR TranscendentalIntegration}
\pagehead{TranscendentalIntegration}{INTTR}
\pagepic{ps/v104transcendentalintegration.ps}{INTTR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package INTTR TranscendentalIntegration>>=
)abbrev package INTTR TranscendentalIntegration
++ Risch algorithm, transcendental case
++ Author: Manuel Bronstein
++ Date Created: 1987
++ Date Last Updated: 24 October 1995
++ Description:
++   This package provides functions for the transcendental
++   case of the Risch algorithm.
-- Internally used by the integrator
TranscendentalIntegration(F, UP): Exports == Implementation where
  F  : Field
  UP : UnivariatePolynomialCategory F

  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Z
  GP  ==> LaurentPolynomial(F, UP)
  UP2 ==> SparseUnivariatePolynomial UP
  RF  ==> Fraction UP
  UPR ==> SparseUnivariatePolynomial RF
  IR  ==> IntegrationResult RF
  LOG ==> Record(scalar:Q, coeff:UPR, logand:UPR)
  LLG ==> List Record(coeff:RF, logand:RF)
  NE  ==> Record(integrand:RF, intvar:RF)
  NL  ==> Record(mainpart:RF, limitedlogs:LLG)
  UPF ==> Record(answer:UP, a0:F)
  RFF ==> Record(answer:RF, a0:F)
  IRF ==> Record(answer:IR, a0:F)
  NLF ==> Record(answer:NL, a0:F)
  GPF ==> Record(answer:GP, a0:F)
  UPUP==> Record(elem:UP, notelem:UP)
  GPGP==> Record(elem:GP, notelem:GP)
  RFRF==> Record(elem:RF, notelem:RF)
  FF  ==> Record(ratpart:F,  coeff:F)
  FFR ==> Record(ratpart:RF, coeff:RF)
  UF  ==> Union(FF,  "failed")
  UF2 ==> Union(List F, "failed")
  REC ==> Record(ir:IR, specpart:RF, polypart:UP)
  PSOL==> Record(ans:F, right:F, sol?:Boolean)
  FAIL==> error "Sorry - cannot handle that integrand yet"

  Exports ==> with
    primintegrate  : (RF, UP -> UP, F -> UF)          -> IRF
      ++ primintegrate(f, ', foo) returns \spad{[g, a]} such that
      ++ \spad{f = g' + a}, and \spad{a = 0} or \spad{a} has no integral in UP.
      ++ Argument foo is an extended integration function on F.
    expintegrate   : (RF, UP -> UP, (Z, F) -> PSOL) -> IRF
      ++ expintegrate(f, ', foo) returns \spad{[g, a]} such that
      ++ \spad{f = g' + a}, and \spad{a = 0} or \spad{a} has no integral in F;
      ++ Argument foo is a Risch differential equation solver on F;
    tanintegrate   : (RF, UP -> UP, (Z, F, F) -> UF2) -> IRF
      ++ tanintegrate(f, ', foo) returns \spad{[g, a]} such that
      ++ \spad{f = g' + a}, and \spad{a = 0} or \spad{a} has no integral in F;
      ++ Argument foo is a Risch differential system solver on F;
    primextendedint:(RF, UP -> UP, F->UF, RF) -> Union(RFF,FFR,"failed")
      ++ primextendedint(f, ', foo, g) returns either \spad{[v, c]} such that
      ++ \spad{f = v' + c g} and \spad{c' = 0}, or \spad{[v, a]} such that
      ++ \spad{f = g' + a}, and \spad{a = 0} or \spad{a} has no integral in UP.
      ++ Returns "failed" if neither case can hold.
      ++ Argument foo is an extended integration function on F.
    expextendedint:(RF,UP->UP,(Z,F)->PSOL, RF) -> Union(RFF,FFR,"failed")
      ++ expextendedint(f, ', foo, g) returns either \spad{[v, c]} such that
      ++ \spad{f = v' + c g} and \spad{c' = 0}, or \spad{[v, a]} such that
      ++ \spad{f = g' + a}, and \spad{a = 0} or \spad{a} has no integral in F.
      ++ Returns "failed" if neither case can hold.
      ++ Argument foo is a Risch differential equation function on F.
    primlimitedint:(RF, UP -> UP, F->UF, List RF) -> Union(NLF,"failed")
      ++ primlimitedint(f, ', foo, [u1,...,un]) returns
      ++ \spad{[v, [c1,...,cn], a]} such that \spad{ci' = 0},
      ++ \spad{f = v' + a + reduce(+,[ci * ui'/ui])},
      ++ and \spad{a = 0} or \spad{a} has no integral in UP.
      ++ Returns "failed" if no such v, ci, a exist.
      ++ Argument foo is an extended integration function on F.
    explimitedint:(RF, UP->UP,(Z,F)->PSOL,List RF) -> Union(NLF,"failed")
      ++ explimitedint(f, ', foo, [u1,...,un]) returns
      ++ \spad{[v, [c1,...,cn], a]} such that \spad{ci' = 0},
      ++ \spad{f = v' + a + reduce(+,[ci * ui'/ui])},
      ++ and \spad{a = 0} or \spad{a} has no integral in F.
      ++ Returns "failed" if no such v, ci, a exist.
      ++ Argument foo is a Risch differential equation function on F.
    primextintfrac    : (RF, UP -> UP, RF)  -> Union(FFR, "failed")
      ++ primextintfrac(f, ', g) returns \spad{[v, c]} such that
      ++ \spad{f = v' + c g} and \spad{c' = 0}.
      ++ Error: if \spad{degree numer f >= degree denom f} or
      ++ if \spad{degree numer g >= degree denom g} or
      ++ if \spad{denom g} is not squarefree.
    primlimintfrac    : (RF, UP -> UP, List RF) -> Union(NL, "failed")
      ++ primlimintfrac(f, ', [u1,...,un]) returns \spad{[v, [c1,...,cn]]}
      ++ such that \spad{ci' = 0} and \spad{f = v' + +/[ci * ui'/ui]}.
      ++ Error: if \spad{degree numer f >= degree denom f}.
    primintfldpoly    : (UP, F -> UF, F)    -> Union(UP, "failed")
      ++ primintfldpoly(p, ', t') returns q such that \spad{p' = q} or
      ++ "failed" if no such q exists. Argument \spad{t'} is the derivative of
      ++ the primitive generating the extension.
    expintfldpoly     : (GP, (Z, F) -> PSOL) -> Union(GP, "failed")
      ++ expintfldpoly(p, foo) returns q such that \spad{p' = q} or
      ++ "failed" if no such q exists.
      ++ Argument foo is a Risch differential equation function on F.
    monomialIntegrate : (RF, UP -> UP) -> REC
      ++ monomialIntegrate(f, ') returns \spad{[ir, s, p]} such that
      ++ \spad{f = ir' + s + p} and all the squarefree factors of the
      ++ denominator of s are special w.r.t the derivation '.
    monomialIntPoly   : (UP, UP -> UP) -> Record(answer:UP, polypart:UP)
      ++ monomialIntPoly(p, ') returns [q, r] such that
      ++ \spad{p = q' + r} and \spad{degree(r) < degree(t')}.
      ++ Error if \spad{degree(t') < 2}.

  Implementation ==> add
    import SubResultantPackage(UP, UP2)
    import MonomialExtensionTools(F, UP)
    import TranscendentalHermiteIntegration(F, UP)
    import CommuteUnivariatePolynomialCategory(F, UP, UP2)

    primintegratepoly  : (UP, F -> UF, F) -> Union(UPF, UPUP)
    expintegratepoly   : (GP, (Z, F) -> PSOL) -> Union(GPF, GPGP)
    expextintfrac      : (RF, UP -> UP, RF) -> Union(FFR, "failed")
    explimintfrac      : (RF, UP -> UP, List RF) -> Union(NL, "failed")
    limitedLogs        : (RF, RF -> RF, List RF) -> Union(LLG, "failed")
    logprmderiv        : (RF, UP -> UP)    -> RF
    logexpderiv        : (RF, UP -> UP, F) -> RF
    tanintegratespecial: (RF, RF -> RF, (Z, F, F) -> UF2) -> Union(RFF, RFRF)
    UP2UP2             : UP -> UP2
    UP2UPR             : UP -> UPR
    UP22UPR            : UP2 -> UPR
    notelementary      : REC -> IR
    kappa              : (UP, UP -> UP) -> UP

    dummy:RF := 0

    logprmderiv(f, derivation) == differentiate(f, derivation) / f

    UP2UP2 p ==
      map(#1::UP, p)$UnivariatePolynomialCategoryFunctions2(F, UP, UP, UP2)

    UP2UPR p ==
      map(#1::UP::RF, p)$UnivariatePolynomialCategoryFunctions2(F, UP, RF, UPR)

    UP22UPR p == map(#1::RF, p)$SparseUnivariatePolynomialFunctions2(UP, RF)

-- given p in k[z] and a derivation on k[t] returns the coefficient lifting
-- in k[z] of the restriction of D to k.
    kappa(p, derivation) ==
      ans:UP := 0
      while p ^= 0 repeat
        ans := ans + derivation(leadingCoefficient(p)::UP)*monomial(1,degree p)
        p := reductum p
      ans

-- works in any monomial extension
    monomialIntegrate(f, derivation) ==
      zero? f => [0, 0, 0]
      r := HermiteIntegrate(f, derivation)
      zero?(inum := numer(r.logpart)) => [r.answer::IR, r.specpart, r.polypart]
      iden  := denom(r.logpart)
      x := monomial(1, 1)$UP
      resultvec := subresultantVector(UP2UP2 inum -
                                 (x::UP2) * UP2UP2 derivation iden, UP2UP2 iden)
      respoly := primitivePart leadingCoefficient resultvec 0
      rec := splitSquarefree(respoly, kappa(#1, derivation))
      logs:List(LOG) := [
              [1, UP2UPR(term.factor),
               UP22UPR swap primitivePart(resultvec(term.exponent),term.factor)]
                     for term in factors(rec.special)]
      dlog :=
--           one? derivation x => r.logpart
           ((derivation x) = 1) => r.logpart
           differentiate(mkAnswer(0, logs, empty()),
                         differentiate(#1, derivation))
      (u := retractIfCan(p := r.logpart - dlog)@Union(UP, "failed")) case UP =>
        [mkAnswer(r.answer, logs, empty), r.specpart, r.polypart + u::UP]
      [mkAnswer(r.answer, logs, [[p, dummy]]), r.specpart, r.polypart]

-- returns [q, r] such that p = q' + r and degree(r) < degree(dt)
-- must have degree(derivation t) >= 2
    monomialIntPoly(p, derivation) ==
      (d := degree(dt := derivation monomial(1,1))::Z) < 2 =>
        error "monomIntPoly: monomial must have degree 2 or more"
      l := leadingCoefficient dt
      ans:UP := 0
      while (n := 1 + degree(p)::Z - d) > 0 repeat
        ans := ans + (term := monomial(leadingCoefficient(p) / (n * l), n::N))
        p   := p - derivation term      -- degree(p) must drop here
      [ans, p]

-- returns either
--   (q in GP, a in F)  st p = q' + a, and a=0 or a has no integral in F
-- or (q in GP, r in GP) st p = q' + r, and r has no integral elem/UP
    expintegratepoly(p, FRDE) ==
      coef0:F := 0
      notelm := answr := 0$GP
      while p ^= 0 repeat
        ans1 := FRDE(n := degree p, a := leadingCoefficient p)
        answr := answr + monomial(ans1.ans, n)
        if ~ans1.sol? then         -- Risch d.e. has no complete solution
               missing := a - ans1.right
               if zero? n then coef0 := missing
                          else notelm := notelm + monomial(missing, n)
        p   := reductum p
      zero? notelm => [answr, coef0]
      [answr, notelm]

-- f is either 0 or of the form p(t)/(1 + t**2)**n
-- returns either
--   (q in RF, a in F)  st f = q' + a, and a=0 or a has no integral in F
-- or (q in RF, r in RF) st f = q' + r, and r has no integral elem/UP
    tanintegratespecial(f, derivation, FRDE) ==
      ans:RF := 0
      p := monomial(1, 2)$UP + 1
      while (n := degree(denom f) quo 2) ^= 0 repeat
        r := numer(f) rem p
        a := coefficient(r, 1)
        b := coefficient(r, 0)
        (u := FRDE(n, a, b)) case "failed" => return [ans, f]
        l := u::List(F)
        term:RF := (monomial(first l, 1)$UP + second(l)::UP) / denom f
        ans := ans + term
        f   := f - derivation term    -- the order of the pole at 1+t^2 drops
      zero?(c0 := retract(retract(f)@UP)@F) or
        (u := FRDE(0, c0, 0)) case "failed" => [ans, c0]
      [ans + first(u::List(F))::UP::RF, 0::F]

-- returns (v in RF, c in RF) s.t. f = v' + cg, and c' = 0, or "failed"
-- g must have a squarefree denominator (always possible)
-- g must have no polynomial part and no pole above t = 0
-- f must have no polynomial part and no pole above t = 0
    expextintfrac(f, derivation, g) ==
      zero? f => [0, 0]
      degree numer f >= degree denom f => error "Not a proper fraction"
      order(denom f,monomial(1,1)) ^= 0 => error "Not integral at t = 0"
      r := HermiteIntegrate(f, derivation)
      zero? g =>
        r.logpart ^= 0 => "failed"
        [r.answer, 0]
      degree numer g >= degree denom g => error "Not a proper fraction"
      order(denom g,monomial(1,1)) ^= 0 => error "Not integral at t = 0"
      differentiate(c := r.logpart / g, derivation) ^= 0 => "failed"
      [r.answer, c]

    limitedLogs(f, logderiv, lu) ==
      zero? f => empty()
      empty? lu => "failed"
      empty? rest lu =>
        logderiv(c0 := f / logderiv(u0 := first lu)) ^= 0 => "failed"
        [[c0, u0]]
      num := numer f
      den := denom f
      l1:List Record(logand2:RF, contrib:UP) :=
--        [[u, numer v] for u in lu | one? denom(v := den * logderiv u)]
        [[u, numer v] for u in lu | (denom(v := den * logderiv u) = 1)]
      rows := max(degree den,
                  1 + reduce(max, [degree(u.contrib) for u in l1], 0)$List(N))
      m:Matrix(F) := zero(rows, cols := 1 + #l1)
      for i in 0..rows-1 repeat
        for pp in l1 for j in minColIndex m .. maxColIndex m - 1 repeat
          qsetelt_!(m, i + minRowIndex m, j, coefficient(pp.contrib, i))
        qsetelt_!(m,i+minRowIndex m, maxColIndex m, coefficient(num, i))
      m := rowEchelon m
      ans := empty()$LLG
      for i in minRowIndex m .. maxRowIndex m |
       qelt(m, i, maxColIndex m) ^= 0 repeat
        OK := false
        for pp in l1 for j in minColIndex m .. maxColIndex m - 1
         while not OK repeat
          if qelt(m, i, j) ^= 0 then
            OK := true
            c := qelt(m, i, maxColIndex m) / qelt(m, i, j)
            logderiv(c0 := c::UP::RF) ^= 0 => return "failed"
            ans := concat([c0, pp.logand2], ans)
        not OK => return "failed"
      ans

-- returns q in UP s.t. p = q', or "failed"
    primintfldpoly(p, extendedint, t') ==
      (u := primintegratepoly(p, extendedint, t')) case UPUP => "failed"
      u.a0 ^= 0 => "failed"
      u.answer

-- returns q in GP st p = q', or "failed"
    expintfldpoly(p, FRDE) ==
      (u := expintegratepoly(p, FRDE)) case GPGP => "failed"
      u.a0 ^= 0 => "failed"
      u.answer

-- returns (v in RF, c1...cn in RF, a in F) s.t. ci' = 0,
-- and f = v' + a + +/[ci * ui'/ui]
--                                  and a = 0 or a has no integral in UP
    primlimitedint(f, derivation, extendedint, lu) ==
      qr := divide(numer f, denom f)
      (u1 := primlimintfrac(qr.remainder / (denom f), derivation, lu))
        case "failed" => "failed"
      (u2 := primintegratepoly(qr.quotient, extendedint,
               retract derivation monomial(1, 1))) case UPUP => "failed"
      [[u1.mainpart + u2.answer::RF, u1.limitedlogs], u2.a0]

-- returns (v in RF, c1...cn in RF, a in F) s.t. ci' = 0,
-- and f = v' + a + +/[ci * ui'/ui]
--                                   and a = 0 or a has no integral in F
    explimitedint(f, derivation, FRDE, lu) ==
      qr := separate(f)$GP
      (u1 := explimintfrac(qr.fracPart,derivation, lu)) case "failed" =>
                                                                "failed"
      (u2 := expintegratepoly(qr.polyPart, FRDE)) case GPGP => "failed"
      [[u1.mainpart + convert(u2.answer)@RF, u1.limitedlogs], u2.a0]

-- returns [v, c1...cn] s.t. f = v' + +/[ci * ui'/ui]
-- f must have no polynomial part (degree numer f < degree denom f)
    primlimintfrac(f, derivation, lu) ==
      zero? f => [0, empty()]
      degree numer f >= degree denom f => error "Not a proper fraction"
      r := HermiteIntegrate(f, derivation)
      zero?(r.logpart) => [r.answer, empty()]
      (u := limitedLogs(r.logpart, logprmderiv(#1, derivation), lu))
        case "failed" => "failed"
      [r.answer, u::LLG]

-- returns [v, c1...cn] s.t. f = v' + +/[ci * ui'/ui]
-- f must have no polynomial part (degree numer f < degree denom f)
-- f must be integral above t = 0
    explimintfrac(f, derivation, lu) ==
      zero? f => [0, empty()]
      degree numer f >= degree denom f => error "Not a proper fraction"
      order(denom f, monomial(1,1)) > 0 => error "Not integral at t = 0"
      r  := HermiteIntegrate(f, derivation)
      zero?(r.logpart) => [r.answer, empty()]
      eta' := coefficient(derivation monomial(1, 1), 1)
      (u := limitedLogs(r.logpart, logexpderiv(#1,derivation,eta'), lu))
        case "failed" => "failed"
      [r.answer - eta'::UP *
        +/[((degree numer(v.logand))::Z - (degree denom(v.logand))::Z) *
                                            v.coeff for v in u], u::LLG]

    logexpderiv(f, derivation, eta') ==
      (differentiate(f, derivation) / f) -
            (((degree numer f)::Z - (degree denom f)::Z) * eta')::UP::RF

    notelementary rec ==
      rec.ir + integral(rec.polypart::RF + rec.specpart, monomial(1,1)$UP :: RF)

-- returns
--   (g in IR, a in F)  st f = g'+ a, and a=0 or a has no integral in UP
    primintegrate(f, derivation, extendedint) ==
      rec := monomialIntegrate(f, derivation)
      not elem?(i1 := rec.ir) => [notelementary rec, 0]
      (u2 := primintegratepoly(rec.polypart, extendedint,
                        retract derivation monomial(1, 1))) case UPUP =>
             [i1 + u2.elem::RF::IR
                 + integral(u2.notelem::RF, monomial(1,1)$UP :: RF), 0]
      [i1 + u2.answer::RF::IR, u2.a0]

-- returns
--   (g in IR, a in F)  st f = g' + a, and a = 0 or a has no integral in F
    expintegrate(f, derivation, FRDE) ==
      rec := monomialIntegrate(f, derivation)
      not elem?(i1 := rec.ir) => [notelementary rec, 0]
-- rec.specpart is either 0 or of the form p(t)/t**n
      special := rec.polypart::GP +
                   (numer(rec.specpart)::GP exquo denom(rec.specpart)::GP)::GP
      (u2 := expintegratepoly(special, FRDE)) case GPGP =>
        [i1 + convert(u2.elem)@RF::IR + integral(convert(u2.notelem)@RF,
                                                 monomial(1,1)$UP :: RF), 0]
      [i1 + convert(u2.answer)@RF::IR, u2.a0]

-- returns
--   (g in IR, a in F)  st f = g' + a, and a = 0 or a has no integral in F
    tanintegrate(f, derivation, FRDE) ==
      rec := monomialIntegrate(f, derivation)
      not elem?(i1 := rec.ir) => [notelementary rec, 0]
      r := monomialIntPoly(rec.polypart, derivation)
      t := monomial(1, 1)$UP
      c := coefficient(r.polypart, 1) / leadingCoefficient(derivation t)
      derivation(c::UP) ^= 0 =>
        [i1 + mkAnswer(r.answer::RF, empty(),
                       [[r.polypart::RF + rec.specpart, dummy]$NE]), 0]
      logs:List(LOG) :=
         zero? c => empty()
         [[1, monomial(1,1)$UPR - (c/(2::F))::UP::RF::UPR, (1 + t**2)::RF::UPR]]
      c0 := coefficient(r.polypart, 0)
      (u := tanintegratespecial(rec.specpart, differentiate(#1, derivation),
       FRDE)) case RFRF =>
        [i1 + mkAnswer(r.answer::RF + u.elem, logs, [[u.notelem,dummy]$NE]), c0]
      [i1 + mkAnswer(r.answer::RF + u.answer, logs, empty()), u.a0 + c0]

-- returns either (v in RF, c in RF) s.t. f = v' + cg, and c' = 0
--             or (v in RF, a in F)  s.t. f = v' + a
--                                  and a = 0 or a has no integral in UP
    primextendedint(f, derivation, extendedint, g) ==
      fqr := divide(numer f, denom f)
      gqr := divide(numer g, denom g)
      (u1 := primextintfrac(fqr.remainder / (denom f), derivation,
                   gqr.remainder / (denom g))) case "failed" => "failed"
      zero?(gqr.remainder) =>
      -- the following FAIL cannot occur if the primitives are all logs
         degree(gqr.quotient) > 0 => FAIL
         (u3 := primintegratepoly(fqr.quotient, extendedint,
               retract derivation monomial(1, 1))) case UPUP => "failed"
         [u1.ratpart + u3.answer::RF, u3.a0]
      (u2 := primintfldpoly(fqr.quotient - retract(u1.coeff)@UP *
        gqr.quotient, extendedint, retract derivation monomial(1, 1)))
          case "failed" => "failed"
      [u2::UP::RF + u1.ratpart, u1.coeff]

-- returns either (v in RF, c in RF) s.t. f = v' + cg, and c' = 0
--             or (v in RF, a in F)  s.t. f = v' + a
--                                   and a = 0 or a has no integral in F
    expextendedint(f, derivation, FRDE, g) ==
      qf := separate(f)$GP
      qg := separate g
      (u1 := expextintfrac(qf.fracPart, derivation, qg.fracPart))
         case "failed" => "failed"
      zero?(qg.fracPart) =>
      --the following FAIL's cannot occur if the primitives are all logs
        retractIfCan(qg.polyPart)@Union(F,"failed") case "failed"=> FAIL
        (u3 := expintegratepoly(qf.polyPart,FRDE)) case GPGP => "failed"
        [u1.ratpart + convert(u3.answer)@RF, u3.a0]
      (u2 := expintfldpoly(qf.polyPart - retract(u1.coeff)@UP :: GP
        * qg.polyPart, FRDE)) case "failed" => "failed"
      [convert(u2::GP)@RF + u1.ratpart, u1.coeff]

-- returns either
--   (q in UP, a in F)  st p = q'+ a, and a=0 or a has no integral in UP
-- or (q in UP, r in UP) st p = q'+ r, and r has no integral elem/UP
    primintegratepoly(p, extendedint, t') ==
      zero? p => [0, 0$F]
      ans:UP := 0
      while (d := degree p) > 0 repeat
        (ans1 := extendedint leadingCoefficient p) case "failed" =>
          return([ans, p])
        p   := reductum p - monomial(d * t' * ans1.ratpart, (d - 1)::N)
        ans := ans + monomial(ans1.ratpart, d)
                              + monomial(ans1.coeff / (d + 1)::F, d + 1)
      (ans1:= extendedint(rp := retract(p)@F)) case "failed" => [ans,rp]
      [monomial(ans1.coeff, 1) + ans1.ratpart::UP + ans, 0$F]

-- returns (v in RF, c in RF) s.t. f = v' + cg, and c' = 0
-- g must have a squarefree denominator (always possible)
-- g must have no polynomial part (degree numer g < degree denom g)
-- f must have no polynomial part (degree numer f < degree denom f)
    primextintfrac(f, derivation, g) ==
      zero? f => [0, 0]
      degree numer f >= degree denom f => error "Not a proper fraction"
      r := HermiteIntegrate(f, derivation)
      zero? g =>
        r.logpart ^= 0 => "failed"
        [r.answer, 0]
      degree numer g >= degree denom g => error "Not a proper fraction"
      differentiate(c := r.logpart / g, derivation) ^= 0 => "failed"
      [r.answer, c]

@
<<INTTR.dotabb>>=
"INTTR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=INTTR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"INTTR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TRMANIP TranscendentalManipulations}
\pagehead{TranscendentalManipulations}{TRMANIP}
\pagepic{ps/v104transcendentalmanipulations.ps}{TRMANIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TRMANIP TranscendentalManipulations>>=
)abbrev package TRMANIP TranscendentalManipulations
++ Transformations on transcendental objects
++ Author: Bob Sutor, Manuel Bronstein
++ Date Created: Way back
++ Date Last Updated: 22 January 1996, added simplifyLog MCD.
++ Description:
++   TranscendentalManipulations provides functions to simplify and
++   expand expressions involving transcendental operators.
++ Keywords: transcendental, manipulation.
TranscendentalManipulations(R, F): Exports == Implementation where
  R : Join(OrderedSet, GcdDomain)
  F : Join(FunctionSpace R, TranscendentalFunctionCategory)

  Z       ==> Integer
  K       ==> Kernel F
  P       ==> SparseMultivariatePolynomial(R, K)
  UP      ==> SparseUnivariatePolynomial P
  POWER   ==> "%power"::Symbol
  POW     ==> Record(val: F,exponent: Z)
  PRODUCT ==> Record(coef : Z, var : K)
  FPR     ==> Fraction Polynomial R

  Exports ==> with
    expand     : F -> F
      ++ expand(f) performs the following expansions on f:\begin{items}
      ++ \item 1. logs of products are expanded into sums of logs,
      ++ \item 2. trigonometric and hyperbolic trigonometric functions
      ++ of sums are expanded into sums of products of trigonometric
      ++ and hyperbolic trigonometric functions.
      ++ \item 3. formal powers of the form \spad{(a/b)**c} are expanded into
      ++ \spad{a**c * b**(-c)}.
      ++ \end{items}
    simplify   : F -> F
      ++ simplify(f) performs the following simplifications on f:\begin{items}
      ++ \item 1. rewrites trigs and hyperbolic trigs in terms
      ++ of \spad{sin} ,\spad{cos}, \spad{sinh}, \spad{cosh}.
      ++ \item 2. rewrites \spad{sin**2} and \spad{sinh**2} in terms
      ++ of \spad{cos} and \spad{cosh},
      ++ \item 3. rewrites \spad{exp(a)*exp(b)} as \spad{exp(a+b)}.
      ++ \item 4. rewrites \spad{(a**(1/n))**m * (a**(1/s))**t} as a single
      ++ power of a single radical of \spad{a}.
      ++ \end{items}
    htrigs     : F -> F
      ++ htrigs(f) converts all the exponentials in f into
      ++ hyperbolic sines and cosines.
    simplifyExp: F -> F
      ++ simplifyExp(f) converts every product \spad{exp(a)*exp(b)}
      ++ appearing in f into \spad{exp(a+b)}.
    simplifyLog : F -> F
      ++ simplifyLog(f) converts every \spad{log(a) - log(b)} appearing in f
      ++ into \spad{log(a/b)}, every \spad{log(a) + log(b)} into \spad{log(a*b)}
      ++ and every \spad{n*log(a)} into \spad{log(a^n)}.
    expandPower: F -> F
      ++ expandPower(f) converts every power \spad{(a/b)**c} appearing
      ++ in f into \spad{a**c * b**(-c)}.
    expandLog  : F -> F
      ++ expandLog(f) converts every \spad{log(a/b)} appearing in f into
      ++ \spad{log(a) - log(b)}, and every \spad{log(a*b)} into
      ++ \spad{log(a) + log(b)}..
    cos2sec    : F -> F
      ++ cos2sec(f) converts every \spad{cos(u)} appearing in f into
      ++ \spad{1/sec(u)}.
    cosh2sech  : F -> F
      ++ cosh2sech(f) converts every \spad{cosh(u)} appearing in f into
      ++ \spad{1/sech(u)}.
    cot2trig   : F -> F
      ++ cot2trig(f) converts every \spad{cot(u)} appearing in f into
      ++ \spad{cos(u)/sin(u)}.
    coth2trigh : F -> F
      ++ coth2trigh(f) converts every \spad{coth(u)} appearing in f into
      ++ \spad{cosh(u)/sinh(u)}.
    csc2sin    : F -> F
      ++ csc2sin(f) converts every \spad{csc(u)} appearing in f into
      ++ \spad{1/sin(u)}.
    csch2sinh  : F -> F
      ++ csch2sinh(f) converts every \spad{csch(u)} appearing in f into
      ++ \spad{1/sinh(u)}.
    sec2cos    : F -> F
      ++ sec2cos(f) converts every \spad{sec(u)} appearing in f into
      ++ \spad{1/cos(u)}.
    sech2cosh  : F -> F
      ++ sech2cosh(f) converts every \spad{sech(u)} appearing in f into
      ++ \spad{1/cosh(u)}.
    sin2csc    : F -> F
      ++ sin2csc(f) converts every \spad{sin(u)} appearing in f into
      ++ \spad{1/csc(u)}.
    sinh2csch  : F -> F
      ++ sinh2csch(f) converts every \spad{sinh(u)} appearing in f into
      ++ \spad{1/csch(u)}.
    tan2trig   : F -> F
      ++ tan2trig(f) converts every \spad{tan(u)} appearing in f into
      ++ \spad{sin(u)/cos(u)}.
    tanh2trigh : F -> F
      ++ tanh2trigh(f) converts every \spad{tanh(u)} appearing in f into
      ++ \spad{sinh(u)/cosh(u)}.
    tan2cot    : F -> F
      ++ tan2cot(f) converts every \spad{tan(u)} appearing in f into
      ++ \spad{1/cot(u)}.
    tanh2coth  : F -> F
      ++ tanh2coth(f) converts every \spad{tanh(u)} appearing in f into
      ++ \spad{1/coth(u)}.
    cot2tan    : F -> F
      ++ cot2tan(f) converts every \spad{cot(u)} appearing in f into
      ++ \spad{1/tan(u)}.
    coth2tanh  : F -> F
      ++ coth2tanh(f) converts every \spad{coth(u)} appearing in f into
      ++ \spad{1/tanh(u)}.
    removeCosSq: F -> F
      ++ removeCosSq(f) converts every \spad{cos(u)**2} appearing in f into
      ++ \spad{1 - sin(x)**2}, and also reduces higher
      ++ powers of \spad{cos(u)} with that formula.
    removeSinSq: F -> F
      ++ removeSinSq(f) converts every \spad{sin(u)**2} appearing in f into
      ++ \spad{1 - cos(x)**2}, and also reduces higher powers of
      ++ \spad{sin(u)} with that formula.
    removeCoshSq:F -> F
      ++ removeCoshSq(f) converts every \spad{cosh(u)**2} appearing in f into
      ++ \spad{1 - sinh(x)**2}, and also reduces higher powers of
      ++ \spad{cosh(u)} with that formula.
    removeSinhSq:F -> F
      ++ removeSinhSq(f) converts every \spad{sinh(u)**2} appearing in f into
      ++ \spad{1 - cosh(x)**2}, and also reduces higher powers
      ++ of \spad{sinh(u)} with that formula.
    if R has PatternMatchable(R) and R has ConvertibleTo(Pattern(R)) and F has ConvertibleTo(Pattern(R)) and F has PatternMatchable R then
      expandTrigProducts : F -> F
        ++ expandTrigProducts(e) replaces \axiom{sin(x)*sin(y)} by
        ++ \spad{(cos(x-y)-cos(x+y))/2}, \axiom{cos(x)*cos(y)} by
        ++ \spad{(cos(x-y)+cos(x+y))/2}, and \axiom{sin(x)*cos(y)} by
        ++ \spad{(sin(x-y)+sin(x+y))/2}.  Note that this operation uses
        ++ the pattern matcher and so is relatively expensive.  To avoid
        ++ getting into an infinite loop the transformations are applied
        ++ at most ten times.

  Implementation ==> add
    import FactoredFunctions(P)
    import PolynomialCategoryLifting(IndexedExponents K, K, R, P, F)
    import
      PolynomialCategoryQuotientFunctions(IndexedExponents K,K,R,P,F)

    smpexp    : P -> F
    termexp   : P -> F
    exlog     : P -> F
    smplog    : P -> F
    smpexpand : P -> F
    smp2htrigs: P -> F
    kerexpand : K -> F
    expandpow : K -> F
    logexpand : K -> F
    sup2htrigs: (UP, F) -> F
    supexp    : (UP, F, F, Z) -> F
    ueval     : (F, String, F -> F) -> F
    ueval2    : (F, String, F -> F) -> F
    powersimp : (P, List K) -> F
    t2t       : F -> F
    c2t       : F -> F
    c2s       : F -> F
    s2c       : F -> F
    s2c2      : F -> F
    th2th     : F -> F
    ch2th     : F -> F
    ch2sh     : F -> F
    sh2ch     : F -> F
    sh2ch2    : F -> F
    simplify0 : F -> F
    simplifyLog1 : F -> F
    logArgs   : List F -> F

    import F
    import List F

    if R has PatternMatchable R and R has ConvertibleTo Pattern R and F has ConvertibleTo(Pattern(R)) and F has PatternMatchable R then
      XX : F := coerce new()$Symbol
      YY : F := coerce new()$Symbol
      sinCosRule : RewriteRule(R,R,F) :=
        rule(cos(XX)*sin(YY),(sin(XX+YY)-sin(XX-YY))/2::F)
      sinSinRule : RewriteRule(R,R,F) :=
        rule(sin(XX)*sin(YY),(cos(XX-YY)-cos(XX+YY))/2::F)
      cosCosRule : RewriteRule(R,R,F) :=
        rule(cos(XX)*cos(YY),(cos(XX-YY)+cos(XX+YY))/2::F)
      expandTrigProducts(e:F):F ==
        applyRules([sinCosRule,sinSinRule,cosCosRule],e,10)$ApplyRules(R,R,F)

    logArgs(l:List F):F ==
      -- This function will take a list of Expressions (implicitly a sum) and
      -- add them up, combining log terms.  It also replaces n*log(x) by
      -- log(x^n).
      import K
      sum  : F := 0
      arg  : F := 1
      for term in l repeat
        is?(term,"log"::Symbol) =>
          arg := arg * simplifyLog(first(argument(first(kernels(term)))))
        -- Now look for multiples, including negative ones.
        prod : Union(PRODUCT, "failed") := isMult(term)
        (prod case PRODUCT) and is?(prod.var,"log"::Symbol) =>
            arg := arg * simplifyLog ((first argument(prod.var))**(prod.coef))
        sum := sum+term
      sum+log(arg)
    
    simplifyLog(e:F):F ==
      simplifyLog1(numerator e)/simplifyLog1(denominator e)

    simplifyLog1(e:F):F ==
      freeOf?(e,"log"::Symbol) => e

      -- Check for n*log(u)
      prod : Union(PRODUCT, "failed") := isMult(e)
      (prod case PRODUCT) and is?(prod.var,"log"::Symbol) =>
        log simplifyLog ((first argument(prod.var))**(prod.coef))
      
      termList : Union(List(F),"failed") := isTimes(e)
      -- I'm using two variables, termList and terms, to work round a
      -- bug in the old compiler.
      not (termList case "failed") =>
        -- We want to simplify each log term in the product and then multiply
        -- them together.  However, if there is a constant or arithmetic
        -- expression (i.e. somwthing which looks like a Polynomial) we would
        -- like to combine it with a log term.
        terms :List F := [simplifyLog(term) for term in termList::List(F)]
        exprs :List F := []
        for i in 1..#terms repeat
          if retractIfCan(terms.i)@Union(FPR,"failed") case FPR then
            exprs := cons(terms.i,exprs)
            terms := delete!(terms,i)
        if not empty? exprs then
          foundLog := false
          i : NonNegativeInteger := 0
          while (not(foundLog) and (i < #terms)) repeat
            i := i+1
            if is?(terms.i,"log"::Symbol) then
              args : List F := argument(retract(terms.i)@K)
              setelt(terms,i, log simplifyLog1(first(args)**(*/exprs)))
              foundLog := true
          -- The next line deals with a situation which shouldn't occur,
          -- since we have checked whether we are freeOf log already.
          if not foundLog then terms := append(exprs,terms)
        */terms
    
      terms : Union(List(F),"failed") := isPlus(e)
      not (terms case "failed") => logArgs(terms) 

      expt : Union(POW, "failed") := isPower(e)
--      (expt case POW) and not one? expt.exponent =>
      (expt case POW) and not (expt.exponent = 1) =>
        simplifyLog(expt.val)**(expt.exponent)
    
      kers : List K := kernels e
--      not(one?(#kers)) => e -- Have a constant
      not(((#kers) = 1)) => e -- Have a constant
      kernel(operator first kers,[simplifyLog(u) for u in argument first kers])


    if R has RetractableTo Integer then
      simplify x == rootProduct(simplify0 x)$AlgebraicManipulations(R,F)

    else simplify x == simplify0 x

    expandpow k ==
      a := expandPower first(arg := argument k)
      b := expandPower second arg
--      ne:F := (one? numer a => 1; numer(a)::F ** b)
      ne:F := (((numer a) = 1) => 1; numer(a)::F ** b)
--      de:F := (one? denom a => 1; denom(a)::F ** (-b))
      de:F := (((denom a) = 1) => 1; denom(a)::F ** (-b))
      ne * de

    termexp p ==
      exponent:F := 0
      coef := (leadingCoefficient p)::P
      lpow := select(is?(#1, POWER)$K, lk := variables p)$List(K)
      for k in lk repeat
        d := degree(p, k)
        if is?(k, "exp"::Symbol) then
          exponent := exponent + d * first argument k
        else if not is?(k, POWER) then
          -- Expand arguments to functions as well ... MCD 23/1/97
          --coef := coef * monomial(1, k, d)
          coef := coef * monomial(1, kernel(operator k,[simplifyExp u for u in argument k], height k), d)
      coef::F * exp exponent * powersimp(p, lpow)

    expandPower f ==
      l := select(is?(#1, POWER)$K, kernels f)$List(K)
      eval(f, l, [expandpow k for k in l])

-- l is a list of pure powers appearing as kernels in p
    powersimp(p, l) ==
      empty? l => 1
      k := first l                           -- k = a**b
      a := first(arg := argument k)
      exponent := degree(p, k) * second arg
      empty?(lk := select(a = first argument #1, rest l)) =>
        (a ** exponent) * powersimp(p, rest l)
      for k0 in lk repeat
        exponent := exponent + degree(p, k0) * second argument k0
      (a ** exponent) * powersimp(p, setDifference(rest l, lk))

    t2t x         == sin(x) / cos(x)
    c2t x         == cos(x) / sin(x)
    c2s x         == inv sin x
    s2c x         == inv cos x
    s2c2 x        == 1 - cos(x)**2
    th2th x       == sinh(x) / cosh(x)
    ch2th x       == cosh(x) / sinh(x)
    ch2sh x       == inv sinh x
    sh2ch x       == inv cosh x
    sh2ch2 x      == cosh(x)**2 - 1
    ueval(x, s,f) == eval(x, s::Symbol, f)
    ueval2(x,s,f) == eval(x, s::Symbol, 2, f)
    cos2sec x     == ueval(x, "cos", inv sec #1)
    sin2csc x     == ueval(x, "sin", inv csc #1)
    csc2sin x     == ueval(x, "csc", c2s)
    sec2cos x     == ueval(x, "sec", s2c)
    tan2cot x     == ueval(x, "tan", inv cot #1)
    cot2tan x     == ueval(x, "cot", inv tan #1)
    tan2trig x    == ueval(x, "tan", t2t)
    cot2trig x    == ueval(x, "cot", c2t)
    cosh2sech x   == ueval(x, "cosh", inv sech #1)
    sinh2csch x   == ueval(x, "sinh", inv csch #1)
    csch2sinh x   == ueval(x, "csch", ch2sh)
    sech2cosh x   == ueval(x, "sech", sh2ch)
    tanh2coth x   == ueval(x, "tanh", inv coth #1)
    coth2tanh x   == ueval(x, "coth", inv tanh #1)
    tanh2trigh x  == ueval(x, "tanh", th2th)
    coth2trigh x  == ueval(x, "coth", ch2th)
    removeCosSq x == ueval2(x, "cos", 1 - (sin #1)**2)
    removeSinSq x == ueval2(x, "sin", s2c2)
    removeCoshSq x== ueval2(x, "cosh", 1 + (sinh #1)**2)
    removeSinhSq x== ueval2(x, "sinh", sh2ch2)
    expandLog x   == smplog(numer x) / smplog(denom x)
    simplifyExp x == (smpexp numer x) / (smpexp denom x)
    expand x      == (smpexpand numer x) / (smpexpand denom x)
    smpexpand p   == map(kerexpand, #1::F, p)
    smplog p      == map(logexpand, #1::F, p)
    smp2htrigs p  == map(htrigs(#1::F), #1::F, p)

    htrigs f ==
      (m := mainKernel f) case "failed" => f
      op  := operator(k := m::K)
      arg := [htrigs x for x in argument k]$List(F)
      num := univariate(numer f, k)
      den := univariate(denom f, k)
      is?(op, "exp"::Symbol) =>
        g1 := cosh(a := first arg) + sinh(a)
        g2 := cosh(a) - sinh(a)
        supexp(num,g1,g2,b:= (degree num)::Z quo 2)/supexp(den,g1,g2,b)
      sup2htrigs(num, g1:= op arg) / sup2htrigs(den, g1)

    supexp(p, f1, f2, bse) ==
      ans:F := 0
      while p ^= 0 repeat
        g := htrigs(leadingCoefficient(p)::F)
        if ((d := degree(p)::Z - bse) >= 0) then
             ans := ans + g * f1 ** d
        else ans := ans + g * f2 ** (-d)
        p := reductum p
      ans

    sup2htrigs(p, f) ==
      (map(smp2htrigs, p)$SparseUnivariatePolynomialFunctions2(P, F)) f

    exlog p == +/[r.coef * log(r.logand::F) for r in log squareFree p]

    logexpand k ==
      nullary?(op := operator k) => k::F
      is?(op, "log"::Symbol) =>
         exlog(numer(x := expandLog first argument k)) - exlog denom x
      op [expandLog x for x in argument k]$List(F)

    kerexpand k ==
      nullary?(op := operator k) => k::F
      is?(op, POWER) => expandpow k
      arg := first argument k
      is?(op, "sec"::Symbol) => inv expand cos arg
      is?(op, "csc"::Symbol) => inv expand sin arg
      is?(op, "log"::Symbol) =>
         exlog(numer(x := expand arg)) - exlog denom x
      num := numer arg
      den := denom arg
      (b := (reductum num) / den) ^= 0 =>
        a := (leadingMonomial num) / den
        is?(op, "exp"::Symbol) => exp(expand a) * expand(exp b)
        is?(op, "sin"::Symbol) =>
           sin(expand a) * expand(cos b) + cos(expand a) * expand(sin b)
        is?(op, "cos"::Symbol) =>
           cos(expand a) * expand(cos b) - sin(expand a) * expand(sin b)
        is?(op, "tan"::Symbol) =>
          ta := tan expand a
          tb := expand tan b
          (ta + tb) / (1 - ta * tb)
        is?(op, "cot"::Symbol) =>
          cta := cot expand a
          ctb := expand cot b
          (cta * ctb - 1) / (ctb + cta)
        op [expand x for x in argument k]$List(F)
      op [expand x for x in argument k]$List(F)

    smpexp p ==
      ans:F := 0
      while p ^= 0 repeat
        ans := ans + termexp leadingMonomial p
        p   := reductum p
      ans

    -- this now works in 3 passes over the expression:
    --   pass1 rewrites trigs and htrigs in terms of sin,cos,sinh,cosh
    --   pass2 rewrites sin**2 and sinh**2 in terms of cos and cosh.
    --   pass3 groups exponentials together
    simplify0 x ==
      simplifyExp eval(eval(x,
          ["tan"::Symbol,"cot"::Symbol,"sec"::Symbol,"csc"::Symbol,
           "tanh"::Symbol,"coth"::Symbol,"sech"::Symbol,"csch"::Symbol],
              [t2t,c2t,s2c,c2s,th2th,ch2th,sh2ch,ch2sh]),
                ["sin"::Symbol, "sinh"::Symbol], [2, 2], [s2c2, sh2ch2])

@
<<TRMANIP.dotabb>>=
"TRMANIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TRMANIP"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"TRMANIP" -> "FS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TRIMAT TriangularMatrixOperations}
\pagehead{TriangularMatrixOperations}{TRIMAT}
\pagepic{ps/v104triangularmatrixoperations.ps}{TRIMAT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TRIMAT TriangularMatrixOperations>>=
)abbrev package TRIMAT TriangularMatrixOperations
++ Fraction free inverses of triangular matrices
++ Author: Victor Miller
++ Date Created:
++ Date Last Updated: 24 Jul 1990
++ Keywords:
++ Examples:
++ References:
++ Description:
++ This package provides functions that compute "fraction-free"
++ inverses of upper and lower triangular matrices over a integral
++ domain.  By "fraction-free inverses" we mean the following:
++ given a matrix B with entries in R and an element d of R such that
++ d * inv(B) also has entries in R, we return d * inv(B).  Thus,
++ it is not necessary to pass to the quotient field in any of our
++ computations.


TriangularMatrixOperations(R,Row,Col,M): Exports == Implementation where
  R   : IntegralDomain
  Row : FiniteLinearAggregate R
  Col : FiniteLinearAggregate R
  M   : MatrixCategory(R,Row,Col)

  Exports ==> with

    UpTriBddDenomInv: (M,R) -> M
      ++ UpTriBddDenomInv(B,d) returns M, where
      ++ B is a non-singular upper triangular matrix and d is an
      ++ element of R such that \spad{M = d * inv(B)} has entries in R.
    LowTriBddDenomInv:(M,R) -> M
      ++ LowTriBddDenomInv(B,d) returns M, where
      ++ B is a non-singular lower triangular matrix and d is an
      ++ element of R such that \spad{M = d * inv(B)} has entries in R.

  Implementation ==> add

    UpTriBddDenomInv(A,denom) ==
      AI := zero(nrows A, nrows A)$M
      offset := minColIndex AI - minRowIndex AI
      for i in minRowIndex AI .. maxRowIndex AI
        for j in minColIndex AI .. maxColIndex AI repeat
          qsetelt_!(AI,i,j,(denom exquo qelt(A,i,j))::R)
      for i in minRowIndex AI .. maxRowIndex AI repeat
        for j in offset + i + 1 .. maxColIndex AI repeat
          qsetelt_!(AI,i,j, - (((+/[qelt(AI,i,k) * qelt(A,k-offset,j)
                                   for k in i+offset..(j-1)])
                                     exquo qelt(A, j-offset, j))::R))
      AI

    LowTriBddDenomInv(A, denom) ==
      AI := zero(nrows A, nrows A)$M
      offset := minColIndex AI - minRowIndex AI
      for i in minRowIndex AI .. maxRowIndex AI
        for j in minColIndex AI .. maxColIndex AI repeat
          qsetelt_!(AI,i,j,(denom exquo qelt(A,i,j))::R)
      for i in minColIndex AI .. maxColIndex AI repeat
        for j in i - offset + 1 .. maxRowIndex AI repeat
          qsetelt_!(AI,j,i, - (((+/[qelt(A,j,k+offset) * qelt(AI,k,i)
                                    for k in i-offset..(j-1)])
                                      exquo qelt(A, j, j+offset))::R))
      AI

@
<<TRIMAT.dotabb>>=
"TRIMAT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TRIMAT"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"TRIGMNIP" -> "ACF"
"TRIGMNIP" -> "FS"
"TRIGMNIP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package TRIGMNIP TrigonometricManipulations}
\pagehead{TrigonometricManipulations}{TRIGMNIP}
\pagepic{ps/v104trigonometricmanipulations.ps}{TRIGMNIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package TRIGMNIP TrigonometricManipulations>>=
)abbrev package TRIGMNIP TrigonometricManipulations
++ Trigs to/from exps and logs
++ Author: Manuel Bronstein
++ Date Created: 4 April 1988
++ Date Last Updated: 14 February 1994
++ Description:
++   \spadtype{TrigonometricManipulations} provides transformations from
++   trigonometric functions to complex exponentials and logarithms, and back.
++ Keywords: trigonometric, function, manipulation.
TrigonometricManipulations(R, F): Exports == Implementation where
  R : Join(GcdDomain, OrderedSet, RetractableTo Integer,
           LinearlyExplicitRingOver Integer)
  F : Join(AlgebraicallyClosedField, TranscendentalFunctionCategory,
           FunctionSpace R)

  Z   ==> Integer
  SY  ==> Symbol
  K   ==> Kernel F
  FG  ==> Expression Complex R

  Exports ==> with
    complexNormalize: F -> F
      ++ complexNormalize(f) rewrites \spad{f} using the least possible number
      ++ of complex independent kernels.
    complexNormalize: (F, SY) -> F
      ++ complexNormalize(f, x) rewrites \spad{f} using the least possible
      ++ number of complex independent kernels involving \spad{x}.
    complexElementary: F -> F
      ++ complexElementary(f) rewrites \spad{f} in terms of the 2 fundamental
      ++ complex transcendental elementary functions: \spad{log, exp}.
    complexElementary: (F, SY) -> F
      ++ complexElementary(f, x) rewrites the kernels of \spad{f} involving
      ++ \spad{x} in terms of the 2 fundamental complex
      ++ transcendental elementary functions: \spad{log, exp}.
    trigs  : F -> F
      ++ trigs(f) rewrites all the complex logs and exponentials
      ++ appearing in \spad{f} in terms of trigonometric functions.
    real   : F -> F
      ++ real(f) returns the real part of \spad{f} where \spad{f} is a complex
      ++ function.
    imag   : F -> F
      ++ imag(f) returns the imaginary part of \spad{f} where \spad{f}
      ++ is a complex function.
    real?  : F -> Boolean
      ++ real?(f) returns \spad{true} if \spad{f = real f}.
    complexForm: F -> Complex F
      ++ complexForm(f) returns \spad{[real f, imag f]}.

  Implementation ==> add
    import ElementaryFunctionSign(R, F)
    import InnerTrigonometricManipulations(R,F,FG)
    import ElementaryFunctionStructurePackage(R, F)
    import ElementaryFunctionStructurePackage(Complex R, FG)

    s1  := sqrt(-1::F)
    ipi := pi()$F * s1

    K2KG          : K -> Kernel FG
    kcomplex      : K -> Union(F, "failed")
    locexplogs    : F -> FG
    localexplogs  : (F, F, List SY) -> FG
    complexKernels: F -> Record(ker: List K, val: List F)

    K2KG k           == retract(tan F2FG first argument k)@Kernel(FG)
    real? f          == empty?(complexKernels(f).ker)
    real f           == real complexForm f
    imag f           == imag complexForm f

-- returns [[k1,...,kn], [v1,...,vn]] such that ki should be replaced by vi
    complexKernels f ==
      lk:List(K) := empty()
      lv:List(F) := empty()
      for k in tower f repeat
        if (u := kcomplex k) case F then
           lk := concat(k, lk)
           lv := concat(u::F, lv)
      [lk, lv]

-- returns f if it is certain that k is not a real kernel and k = f,
-- "failed" otherwise
    kcomplex k ==
      op := operator k
      is?(k, "nthRoot"::SY) =>
        arg := argument k
        even?(retract(n := second arg)@Z) and ((u := sign(first arg)) case Z)
          and (u::Z < 0) => op(s1, n / 2::F) * op(- first arg, n)
        "failed"
      is?(k, "log"::SY) and ((u := sign(a := first argument k)) case Z)
          and (u::Z < 0) => op(- a) + ipi
      "failed"

    complexForm f ==
      empty?((l := complexKernels f).ker) => complex(f, 0)
      explogs2trigs locexplogs eval(f, l.ker, l.val)

    locexplogs f ==
      any?(has?(#1, "rtrig"),
           operators(g := realElementary f))$List(BasicOperator) =>
              localexplogs(f, g, variables g)
      F2FG g

    complexNormalize(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
               | member?(x, variables(k::F))]$List(K))$List(K) =>
                   FG2F(rischNormalize(localexplogs(f, g, [x]), x).func)
      rischNormalize(g, x).func

    complexNormalize f ==
      l := variables(g := realElementary f)
      any?(has?(#1, "rtrig"), operators g)$List(BasicOperator) =>
        h := localexplogs(f, g, l)
        for x in l repeat h := rischNormalize(h, x).func
        FG2F h
      for x in l repeat g := rischNormalize(g, x).func
      g

    complexElementary(f, x) ==
      any?(has?(operator #1, "rtrig"),
       [k for k in tower(g := realElementary(f, x))
                 | member?(x, variables(k::F))]$List(K))$List(K) =>
                     FG2F localexplogs(f, g, [x])
      g

    complexElementary f ==
      any?(has?(#1, "rtrig"),
        operators(g := realElementary f))$List(BasicOperator) =>
          FG2F localexplogs(f, g, variables g)
      g

    localexplogs(f, g, lx) ==
      trigs2explogs(F2FG g, [K2KG k for k in tower f
                          | is?(k, "tan"::SY) or is?(k, "cot"::SY)], lx)

    trigs f ==
      real? f => f
      g := explogs2trigs F2FG f
      real g + s1 * imag g

@
<<TRIGMNIP.dotabb>>=
"TRIGMNIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=TRIGMNIP"]
"ACF" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ACF"]
"FS" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FS"]
"COMPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=COMPCAT"]
"TRIGMNIP" -> "ACF"
"TRIGMNIP" -> "FS"
"TRIGMNIP" -> "COMPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CLIP TwoDimensionalPlotClipping}
\pagehead{TwoDimensionalPlotClipping}{CLIP}
\pagepic{ps/v104twodimensionalplotclipping.ps}{CLIP}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CLIP TwoDimensionalPlotClipping>>=
)abbrev package CLIP TwoDimensionalPlotClipping
++ Automatic clipping for 2-dimensional plots
++ Author: Clifton J. Williamson
++ Date Created: 22 December 1989
++ Date Last Updated: 10 July 1990
++ Keywords: plot, singularity
++ Examples:
++ References:
 
TwoDimensionalPlotClipping(): Exports == Implementation where
  ++ The purpose of this package is to provide reasonable plots of
  ++ functions with singularities.
  B      ==> Boolean
  L      ==> List
  SEG    ==> Segment
  RN     ==> Fraction Integer
  SF     ==> DoubleFloat
  Pt     ==> Point DoubleFloat
  PLOT   ==> Plot
  CLIPPED ==> Record(brans: L L Pt,xValues: SEG SF,yValues: SEG SF)
 
  Exports ==> with
    clip: PLOT -> CLIPPED
      ++ clip(p) performs two-dimensional clipping on a plot, p, from
      ++ the domain \spadtype{Plot} for the graph of one variable,
      ++ \spad{y = f(x)}; the default parameters \spad{1/4} for the fraction 
      ++ and \spad{5/1} for the scale are used in the \spadfun{clip} function.
    clip: (PLOT,RN,RN) -> CLIPPED
      ++ clip(p,frac,sc) performs two-dimensional clipping on a plot, p, 
      ++ from the domain \spadtype{Plot} for the graph of one variable
      ++ \spad{y = f(x)}; the fraction parameter is specified by \spad{frac} 
      ++ and the scale parameter is specified by \spad{sc} for use in the 
      ++ \spadfun{clip} function.
    clipParametric: PLOT -> CLIPPED
      ++ clipParametric(p) performs two-dimensional clipping on a plot,
      ++ p, from the domain \spadtype{Plot} for the parametric curve
      ++ \spad{x = f(t)}, \spad{y = g(t)}; the default parameters \spad{1/2} 
      ++ for the fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this
      ++ function.
    clipParametric: (PLOT,RN,RN) -> CLIPPED
      ++ clipParametric(p,frac,sc) performs two-dimensional clipping on a 
      ++ plot, p, from the domain \spadtype{Plot} for the parametric curve
      ++ \spad{x = f(t)}, \spad{y = g(t)}; the fraction parameter is 
      ++ specified by \spad{frac} and the scale parameter is specified 
      ++ by \spad{sc} for use in the \fakeAxiomFun{iClipParametric} subroutine,
      ++ which is called by this function.
    clipWithRanges: (L L Pt,SF,SF,SF,SF) -> CLIPPED
      ++ clipWithRanges(pointLists,xMin,xMax,yMin,yMax) performs clipping
      ++ on a list of lists of points, \spad{pointLists}.  Clipping is 
      ++ done within the specified ranges of \spad{xMin}, \spad{xMax} and 
      ++ \spad{yMin}, \spad{yMax}.  This function is used internally by 
      ++ the \fakeAxiomFun{iClipParametric} subroutine in this package.
    clip: L Pt -> CLIPPED
      ++ clip(l) performs two-dimensional clipping on a curve l, which is
      ++ a list of points; the default parameters \spad{1/2} for the 
      ++ fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this 
      ++ function.
    clip: L L Pt -> CLIPPED
      ++ clip(ll) performs two-dimensional clipping on a list of lists 
      ++ of points, \spad{ll}; the default parameters \spad{1/2} for
      ++ the fraction and \spad{5/1} for the scale are used in the 
      ++ \fakeAxiomFun{iClipParametric} subroutine, which is called by this 
      ++ function.
 
  Implementation ==> add
    import PointPackage(DoubleFloat)
    import ListFunctions2(Point DoubleFloat,DoubleFloat)
 
    point:(SF,SF) -> Pt
    intersectWithHorizLine:(SF,SF,SF,SF,SF) -> Pt
    intersectWithVertLine:(SF,SF,SF,SF,SF) -> Pt
    intersectWithBdry:(SF,SF,SF,SF,Pt,Pt) -> Pt
    discardAndSplit: (L Pt,Pt -> B,SF,SF,SF,SF) -> L L Pt
    norm: Pt -> SF
    iClipParametric: (L L Pt,RN,RN) -> CLIPPED
    findPt: L L Pt -> Union(Pt,"failed")
    Fnan?: SF ->Boolean
    Pnan?:Pt ->Boolean

    Fnan? x == x~=x
    Pnan? p == any?(Fnan?,p)
   
    iClipParametric(pointLists,fraction,scale) ==
      -- error checks and special cases
      (fraction < 0) or (fraction > 1) =>
        error "clipDraw: fraction should be between 0 and 1"
      empty? pointLists => [nil(),segment(0,0),segment(0,0)]
      -- put all points together , sort them according to norm
      sortedList := sort(norm(#1) < norm(#2),select(not Pnan? #1,concat pointLists))
      empty? sortedList => [nil(),segment(0,0),segment(0,0)]
      n := # sortedList 
      num := numer fraction
      den := denom fraction
      clipNum := (n * num) quo den
      lastN := n - 1 - clipNum
      firstPt := first sortedList
      xMin : SF := xCoord firstPt
      xMax : SF := xCoord firstPt
      yMin : SF := yCoord firstPt 
      yMax : SF := yCoord firstPt
      -- calculate min/max for the first (1-fraction)*N points
      -- this contracts the range
      -- this unnecessarily clips monotonic functions (step-function, x^(high power),etc.)
      for k in 0..lastN  for pt in rest sortedList repeat
        xMin := min(xMin,xCoord pt)
        xMax := max(xMax,xCoord pt)
        yMin := min(yMin,yCoord pt)
        yMax := max(yMax,yCoord pt)
      xDiff := xMax - xMin; yDiff := yMax - yMin
      xDiff = 0 =>
        yDiff = 0 =>
          [pointLists,segment(xMin-1,xMax+1),segment(yMin-1,yMax+1)]
        [pointLists,segment(xMin-1,xMax+1),segment(yMin,yMax)]
      yDiff = 0 =>
        [pointLists,segment(xMin,xMax),segment(yMin-1,yMax+1)]
      numm := numer scale; denn := denom scale
      -- now expand the range by scale
      xMin := xMin - (numm :: SF) * xDiff / (denn :: SF)
      xMax := xMax + (numm :: SF) * xDiff / (denn :: SF)
      yMin := yMin - (numm :: SF) * yDiff / (denn :: SF)
      yMax := yMax + (numm :: SF) * yDiff / (denn :: SF)
      -- clip with the calculated range
      newclip:=clipWithRanges(pointLists,xMin,xMax,yMin,yMax)
      -- if we split the lists use the new clip
      # (newclip.brans) > # pointLists   => newclip
      -- calculate extents
      xs :L SF:= map (xCoord,sortedList)
      ys :L SF:= map (yCoord,sortedList)
      xMin :SF :=reduce (min,xs)
      yMin :SF :=reduce (min,ys)
      xMax :SF :=reduce (max,xs)
      yMax :SF :=reduce (max,ys) 
      xseg:SEG SF :=xMin..xMax
      yseg:SEG SF :=yMin..yMax
      -- return original
      [pointLists,xseg,yseg]@CLIPPED
      


 
    point(xx,yy) == point(l : L SF := [xx,yy])
 
    intersectWithHorizLine(x1,y1,x2,y2,yy) ==
      x1 = x2 => point(x1,yy)
      point(x1 + (x2 - x1)*(yy - y1)/(y2 - y1),yy)
 
    intersectWithVertLine(x1,y1,x2,y2,xx) ==
      y1 = y2 => point(xx,y1)
      point(xx,y1 + (y2 - y1)*(xx - x1)/(x2 - x1))
 
    intersectWithBdry(xMin,xMax,yMin,yMax,pt1,pt2) ==
      -- pt1 is in rectangle, pt2 is not
      x1 := xCoord pt1; y1 := yCoord pt1
      x2 := xCoord pt2; y2 := yCoord pt2
      if y2 > yMax then
        pt2 := intersectWithHorizLine(x1,y1,x2,y2,yMax)
        x2 := xCoord pt2; y2 := yCoord pt2
      if y2 < yMin then
        pt2 := intersectWithHorizLine(x1,y1,x2,y2,yMin)
        x2 := xCoord pt2; y2 := yCoord pt2
      if x2 > xMax then
        pt2 := intersectWithVertLine(x1,y1,x2,y2,xMax)
        x2 := xCoord pt2; y2 := yCoord pt2
      if x2 < xMin then
        pt2 := intersectWithVertLine(x1,y1,x2,y2,xMin)
      pt2
 
    discardAndSplit(pointList,pred,xMin,xMax,yMin,yMax) ==
      ans : L L Pt := nil()
      list : L Pt  := nil()
      lastPt? : B  := false
      lastPt : Pt  := point(0,0)
      while not empty? pointList repeat
        pt := first pointList
        pointList := rest pointList
        pred(pt) =>
          if (empty? list) and lastPt? then
            bdryPt := intersectWithBdry(xMin,xMax,yMin,yMax,pt,lastPt)
            -- print bracket [ coerce bdryPt ,coerce pt ]	
            --list := cons(bdryPt,list)
          list := cons(pt,list)
        if not empty? list then
          bdryPt := intersectWithBdry(xMin,xMax,yMin,yMax,first list,pt)
	  -- print bracket [ coerce bdryPt,coerce first list]	
          --list := cons(bdryPt,list)
          ans := cons( list,ans)
        lastPt := pt 
	lastPt? := true
	list := nil()
      empty? list => ans
      reverse_! cons(reverse_! list,ans)
 
    clip(plot,fraction,scale) ==
--      sayBrightly(["   clip: "::OutputForm]$List(OutputForm))$Lisp
      (fraction < 0) or (fraction > 1/2) =>
        error "clipDraw: fraction should be between 0 and 1/2"
      xVals := xRange plot
      empty?(pointLists := listBranches plot) =>
        [nil(),xVals,segment(0,0)]
      more?(pointLists := listBranches plot,1) =>
        error "clipDraw: plot has more than one branch"
      empty?(pointList := first pointLists) =>
        [nil(),xVals,segment(0,0)]
      sortedList := sort(yCoord(#1) < yCoord(#2),pointList)
      n := # sortedList; num := numer fraction; den := denom fraction
      clipNum := (n * num) quo den
      -- throw out points with large and small y-coordinates
      yMin := yCoord(sortedList.clipNum)
      yMax := yCoord(sortedList.(n - 1 - clipNum))
      if Fnan? yMin then yMin : SF := 0
      if Fnan? yMax then yMax : SF := 0
      (yDiff := yMax - yMin) = 0 =>
        [pointLists,xRange plot,segment(yMin - 1,yMax + 1)]
      numm := numer scale; denn := denom scale
      xMin := lo xVals; xMax := hi xVals
      yMin := yMin - (numm :: SF) * yDiff / (denn :: SF)
      yMax := yMax + (numm :: SF) * yDiff / (denn :: SF)
      lists := discardAndSplit(pointList,_
         (yCoord(#1) < yMax) and (yCoord(#1) > yMin),xMin,xMax,yMin,yMax)
      yMin := yCoord(sortedList.clipNum)
      yMax := yCoord(sortedList.(n - 1 - clipNum))
      if Fnan? yMin then yMin : SF := 0
      if Fnan? yMax then yMax : SF := 0
      for list in lists repeat
        for pt in list repeat
          if not Fnan?(yCoord pt) then
            yMin := min(yMin,yCoord pt)
            yMax := max(yMax,yCoord pt)
      [lists,xVals,segment(yMin,yMax)]
 
    clip(plot:PLOT) == clip(plot,1/4,5/1)
 
    norm(pt) == 
      x := xCoord(pt); y := yCoord(pt)
      if Fnan? x then
        if Fnan? y then
          r:SF := 0
        else
          r:SF := y**2
      else
        if Fnan? y then
          r:SF := x**2
        else
          r:SF := x**2 + y**2
      r
 
    findPt lists ==
      for list in lists repeat
        not empty? list => 
	     for p in list repeat 
               not Pnan? p => return p
      "failed"

    clipWithRanges(pointLists,xMin,xMax,yMin,yMax) ==
      lists : L L Pt := nil()
      for pointList in pointLists repeat
        lists := concat(lists,discardAndSplit(pointList,_
           (xCoord(#1) <= xMax) and (xCoord(#1) >= xMin) and _
           (yCoord(#1) <= yMax) and (yCoord(#1) >= yMin), _
           xMin,xMax,yMin,yMax))
      (pt := findPt lists) case "failed" =>
        [nil(),segment(0,0),segment(0,0)]
      firstPt := pt :: Pt
      xMin : SF := xCoord firstPt; xMax : SF := xCoord firstPt
      yMin : SF := yCoord firstPt; yMax : SF := yCoord firstPt
      for list in lists repeat
        for pt in list repeat
          if not Pnan? pt then
            xMin := min(xMin,xCoord pt)
            xMax := max(xMax,xCoord pt)
            yMin := min(yMin,yCoord pt)
            yMax := max(yMax,yCoord pt)
      [lists,segment(xMin,xMax),segment(yMin,yMax)]
 
    clipParametric(plot,fraction,scale) ==
      iClipParametric(listBranches plot,fraction,scale)
 
    clipParametric plot == clipParametric(plot,1/2,5/1)
 
    clip(l: L Pt)   == iClipParametric(list l,1/2,5/1)
    clip(l: L L Pt) == iClipParametric(l,1/2,5/1)

@
<<CLIP.dotabb>>=
"CLIP" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CLIP"]
"PTCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PTCAT"]
"CLIP" -> "PTCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter U}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package UFPS1 UnivariateFormalPowerSeriesFunctions}
\pagehead{UnivariateFormalPowerSeriesFunctions}{UFPS1}
\pagepic{ps/v104univariateformalpowerseriesfunctions.ps}{UFPS1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package UFPS1 UnivariateFormalPowerSeriesFunctions>>=
)abbrev package UFPS1 UnivariateFormalPowerSeriesFunctions
UnivariateFormalPowerSeriesFunctions(Coef: Ring): Exports == Implementation 
  where

    UFPS ==> UnivariateFormalPowerSeries Coef

    Exports == with

      hadamard: (UFPS, UFPS) -> UFPS

    Implementation == add

      hadamard(f, g) ==
        series map(#1*#2, coefficients f, coefficients g)
                  $StreamFunctions3(Coef, Coef, Coef) 

@
<<UFPS1.dotabb>>=
"UFPS1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=UFPS1"]
"UFPS" [color="#88FF44",href="bookvol10.3.pdf#nameddest=UFPS"]
"UFPS1" -> "UFPS"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ULS2 UnivariateLaurentSeriesFunctions2}
\pagehead{UnivariateLaurentSeriesFunctions2}{ULS2}
\pagepic{ps/v104univariatelaurentseriesfunctions2.ps}{ULS2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ULS2 UnivariateLaurentSeriesFunctions2>>=
)abbrev package ULS2 UnivariateLaurentSeriesFunctions2
++ Author: Clifton J. Williamson
++ Date Created: 5 March 1990
++ Date Last Updated: 5 March 1990
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords: Laurent series, map
++ Examples:
++ References:
++ Description: Mapping package for univariate Laurent series
++   This package allows one to apply a function to the coefficients of
++   a univariate Laurent series.
UnivariateLaurentSeriesFunctions2(Coef1,Coef2,var1,var2,cen1,cen2):_
 Exports == Implementation where
  Coef1 : Ring
  Coef2 : Ring
  var1: Symbol
  var2: Symbol
  cen1: Coef1
  cen2: Coef2
  ULS1  ==> UnivariateLaurentSeries(Coef1, var1, cen1)
  ULS2  ==> UnivariateLaurentSeries(Coef2, var2, cen2)
  UTS1  ==> UnivariateTaylorSeries(Coef1, var1, cen1)
  UTS2  ==> UnivariateTaylorSeries(Coef2, var2, cen2)
  UTSF2 ==> UnivariateTaylorSeriesFunctions2(Coef1, Coef2, UTS1, UTS2)

  Exports ==> with
    map: (Coef1 -> Coef2,ULS1) -> ULS2
      ++ \spad{map(f,g(x))} applies the map f to the coefficients of the Laurent
      ++ series \spad{g(x)}.

  Implementation ==> add

    map(f,ups) == laurent(degree ups, map(f, taylorRep ups)$UTSF2)

@
<<ULS2.dotabb>>=
"ULS2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ULS2"]
"MODULE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MODULE"]
"SGROUP" [color="#4488FF",href="bookvol10.2.pdf#nameddest=SGROUP"]
"ULS2" -> "LMODULE"
"ULS2" -> "SGROUP"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package UPCDEN UnivariatePolynomialCommonDenominator}
\pagehead{UnivariatePolynomialCommonDenominator}{UPCDEN}
\pagepic{ps/v104univariatepolynomialcommondenominator.ps}{UPCDEN}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package UPCDEN UnivariatePolynomialCommonDenominator>>=
)abbrev package UPCDEN UnivariatePolynomialCommonDenominator
--% UnivariatePolynomialCommonDenominator
++ Author: Manuel Bronstein
++ Date Created: 2 May 1988
++ Date Last Updated: 22 Feb 1990
++ Description: UnivariatePolynomialCommonDenominator provides
++ functions to compute the common denominator of the coefficients of
++ univariate polynomials over the quotient field of a gcd domain.
++ Keywords: gcd, quotient, common, denominator, polynomial.
 
UnivariatePolynomialCommonDenominator(R, Q, UP): Exports == Impl where
  R : IntegralDomain
  Q : QuotientFieldCategory R
  UP: UnivariatePolynomialCategory Q
 
  Exports ==> with
    commonDenominator: UP -> R
      ++ commonDenominator(q) returns a common denominator d for
      ++ the coefficients of q.
    clearDenominator : UP -> UP
      ++ clearDenominator(q) returns p such that \spad{q = p/d} where d is
      ++ a common denominator for the coefficients of q.
    splitDenominator : UP -> Record(num: UP, den: R)
      ++ splitDenominator(q) returns \spad{[p, d]} such that \spad{q = p/d} and d
      ++ is a common denominator for the coefficients of q.
 
  Impl ==> add
    import CommonDenominator(R, Q, List Q)
 
    commonDenominator p == commonDenominator coefficients p
 
    clearDenominator p ==
      d := commonDenominator p
      map(numer(d * #1)::Q, p)
 
    splitDenominator p ==
      d := commonDenominator p
      [map(numer(d * #1)::Q, p), d]

@
<<UPCDEN.dotabb>>=
"UPCDEN" [color="#FF4488",href="bookvol10.4.pdf#nameddest=UPCDEN"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"UPCDEN" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OREPCTO UnivariateSkewPolynomialCategoryOps}
\pagehead{UnivariateSkewPolynomialCategoryOps}{OREPCTO}
\pagepic{ps/v104univariateskewpolynomialcategoryops.ps}{OREPCTO}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OREPCTO UnivariateSkewPolynomialCategoryOps>>=
)abbrev package OREPCTO UnivariateSkewPolynomialCategoryOps
++ Author: Manuel Bronstein
++ Date Created: 1 February 1994
++ Date Last Updated: 1 February 1994
++ Description:
++   \spad{UnivariateSkewPolynomialCategoryOps} provides products and
++    divisions of univariate skew polynomials.
-- Putting those operations here rather than defaults in OREPCAT allows
-- OREPCAT to be defined independently of sigma and delta.
-- MB 2/94
UnivariateSkewPolynomialCategoryOps(R, C): Exports == Implementation where
    R: Ring
    C: UnivariateSkewPolynomialCategory R
 
    N   ==> NonNegativeInteger
    MOR ==> Automorphism R
    QUOREM ==> Record(quotient: C, remainder: C)
 
    Exports ==> with
        times: (C, C, MOR, R -> R) -> C
           ++ times(p, q, sigma, delta) returns \spad{p * q}.
           ++ \spad{\sigma} and \spad{\delta} are the maps to use.
        apply: (C, R, R, MOR, R -> R) -> R
          ++ apply(p, c, m, sigma, delta) returns \spad{p(m)} where the action
          ++ is given by \spad{x m = c sigma(m) + delta(m)}.
        if R has IntegralDomain then
            monicLeftDivide: (C, C, MOR) -> QUOREM
                ++ monicLeftDivide(a, b, sigma) returns the pair \spad{[q,r]}
                ++ such that \spad{a = b*q + r} and the degree of \spad{r} is
                ++ less than the degree of \spad{b}.
                ++ \spad{b} must be monic.
                ++ This process is called ``left division''.
                ++ \spad{\sigma} is the morphism to use.
            monicRightDivide: (C, C, MOR) -> QUOREM
                ++ monicRightDivide(a, b, sigma) returns the pair \spad{[q,r]}
                ++ such that \spad{a = q*b + r} and the degree of \spad{r} is
                ++ less than the degree of \spad{b}.
                ++ \spad{b} must be monic.
                ++ This process is called ``right division''.
                ++ \spad{\sigma} is the morphism to use.
        if R has Field then
            leftDivide: (C, C, MOR) -> QUOREM
                ++ leftDivide(a, b, sigma) returns the pair \spad{[q,r]} such
                ++ that \spad{a = b*q + r} and the degree of \spad{r} is
                ++ less than the degree of \spad{b}.
                ++ This process is called ``left division''.
                ++ \spad{\sigma} is the morphism to use.
            rightDivide: (C, C, MOR) -> QUOREM
                ++ rightDivide(a, b, sigma) returns the pair \spad{[q,r]} such
                ++ that \spad{a = q*b + r} and the degree of \spad{r} is
                ++ less than the degree of \spad{b}.
                ++ This process is called ``right division''.
                ++ \spad{\sigma} is the morphism to use.
 
    Implementation ==> add
        termPoly:         (R, N, C, MOR, R -> R) -> C
        localLeftDivide : (C, C, MOR, R) -> QUOREM
        localRightDivide: (C, C, MOR, R) -> QUOREM
 
        times(x, y, sigma, delta) ==
          zero? y => 0
          z:C := 0
          while x ^= 0 repeat
            z := z + termPoly(leadingCoefficient x, degree x, y, sigma, delta)
            x := reductum x
          z
 
        termPoly(a, n, y, sigma, delta) ==
          zero? y => 0
          (u := subtractIfCan(n, 1)) case "failed" => a * y
          n1 := u::N
          z:C := 0
          while y ^= 0 repeat
            m := degree y
            b := leadingCoefficient y
            z := z + termPoly(a, n1, monomial(sigma b, m + 1), sigma, delta)
                   + termPoly(a, n1, monomial(delta b, m), sigma, delta)
            y := reductum y
          z
 
        apply(p, c, x, sigma, delta) ==
          w:R  := 0
          xn:R := x
          for i in 0..degree p repeat
            w  := w + coefficient(p, i) * xn
            xn := c * sigma xn + delta xn
          w
 
        -- localLeftDivide(a, b) returns [q, r] such that a = q b + r
        -- b1 is the inverse of the leadingCoefficient of b
        localLeftDivide(a, b, sigma, b1) ==
            zero? b => error "leftDivide: division by 0"
            zero? a or
             (n := subtractIfCan(degree(a),(m := degree b))) case "failed" =>
                    [0,a]
            q  := monomial((sigma**(-m))(b1 * leadingCoefficient a), n::N)
            qr := localLeftDivide(a - b * q, b, sigma, b1)
            [q + qr.quotient, qr.remainder]
 
        -- localRightDivide(a, b) returns [q, r] such that a = q b + r
        -- b1 is the inverse of the leadingCoefficient of b
        localRightDivide(a, b, sigma, b1) ==
            zero? b => error "rightDivide: division by 0"
            zero? a or
              (n := subtractIfCan(degree(a),(m := degree b))) case "failed" =>
                    [0,a]
            q := monomial(leadingCoefficient(a) * (sigma**n) b1, n::N)
            qr := localRightDivide(a - q * b, b, sigma, b1)
            [q + qr.quotient, qr.remainder]
 
        if R has IntegralDomain then
            monicLeftDivide(a, b, sigma) ==
                unit?(u := leadingCoefficient b) =>
                    localLeftDivide(a, b, sigma, recip(u)::R)
                error "monicLeftDivide: divisor is not monic"
 
            monicRightDivide(a, b, sigma) ==
                unit?(u := leadingCoefficient b) =>
                    localRightDivide(a, b, sigma, recip(u)::R)
                error "monicRightDivide: divisor is not monic"
 
        if R has Field then
            leftDivide(a, b, sigma) ==
                localLeftDivide(a, b, sigma, inv leadingCoefficient b)
 
            rightDivide(a, b, sigma) ==
                localRightDivide(a, b, sigma, inv leadingCoefficient b)

@
<<OREPCTO.dotabb>>=
"OREPCTO" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OREPCTO"]
"OREPCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=OREPCAT"]
"OREPCTO" -> "OREPCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package UTSODETL UTSodetools}
\pagehead{UTSodetools}{UTSODETL}
\pagepic{ps/v104utsodetools.ps}{UTSODETL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package UTSODETL UTSodetools>>=
)abbrev package UTSODETL UTSodetools
++ Author: Manuel Bronstein
++ Date Created: 31 January 1994
++ Date Last Updated: 3 February 1994
++ Description:
++  \spad{RUTSodetools} provides tools to interface with the series
++   ODE solver when presented with linear ODEs.
UTSodetools(F, UP, L, UTS): Exports == Implementation where
  F  : Ring
  UP : UnivariatePolynomialCategory F
  L  : LinearOrdinaryDifferentialOperatorCategory UP
  UTS: UnivariateTaylorSeriesCategory F

  Exports ==> with
      UP2UTS:   UP -> UTS
          ++ UP2UTS(p) converts \spad{p} to a Taylor series.
      UTS2UP:   (UTS, NonNegativeInteger) -> UP
          ++ UTS2UP(s, n) converts the first \spad{n} terms of \spad{s}
          ++ to a univariate polynomial.
      LODO2FUN: L -> (List UTS -> UTS)
          ++ LODO2FUN(op) returns the function to pass to the series ODE
          ++ solver in order to solve \spad{op y = 0}.
      if F has IntegralDomain then
          RF2UTS: Fraction UP -> UTS
              ++ RF2UTS(f) converts \spad{f} to a Taylor series.

  Implementation ==> add
      fun: (Vector UTS, List UTS) -> UTS

      UP2UTS p ==
        q := p(monomial(1, 1) + center(0)::UP)
        +/[monomial(coefficient(q, i), i)$UTS for i in 0..degree q]

      UTS2UP(s, n) ==
        xmc     := monomial(1, 1)$UP - center(0)::UP
        xmcn:UP := 1
        ans:UP  := 0
        for i in 0..n repeat
            ans  := ans + coefficient(s, i) * xmcn
            xmcn := xmc * xmcn
        ans

      LODO2FUN op ==
          a := recip(UP2UTS(- leadingCoefficient op))::UTS
          n := (degree(op) - 1)::NonNegativeInteger
          v := [a * UP2UTS coefficient(op, i) for i in 0..n]$Vector(UTS)
          fun(v, #1)

      fun(v, l) ==
          ans:UTS := 0
          for b in l for i in 1.. repeat ans := ans + v.i * b
          ans

      if F has IntegralDomain then
          RF2UTS f == UP2UTS(numer f) * recip(UP2UTS denom f)::UTS

@
<<UTSODETL.dotabb>>=
"UTSODETL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=UTSODETL"]
"UTSCAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=UTSCAT"]
"UTSODETL" -> "UTSCAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter V}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter W}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package WFFINTBS WildFunctionFieldIntegralBasis}
\pagehead{WildFunctionFieldIntegralBasis}{WFFINTBS}
\pagepic{ps/v104wildfunctionfieldintegralbasis.ps}{WFFINTBS}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package WFFINTBS WildFunctionFieldIntegralBasis>>=
)abbrev package WFFINTBS WildFunctionFieldIntegralBasis
++ Authors: Victor Miller, Clifton Williamson
++ Date Created: 24 July 1991
++ Date Last Updated: 20 September 1994
++ Basic Operations: integralBasis, localIntegralBasis
++ Related Domains: IntegralBasisTools(R,UP,F),
++   TriangularMatrixOperations(R,Vector R,Vector R,Matrix R)
++ Also See: FunctionFieldIntegralBasis, NumberFieldIntegralBasis
++ AMS Classifications:
++ Keywords: function field, integral basis
++ Examples:
++ References:
++ Description:
++ In this package K is a finite field, R is a ring of univariate
++ polynomials over K, and F is a framed algebra over R.  The package
++ provides a function to compute the integral closure of R in the quotient
++ field of F as well as a function to compute a "local integral basis"
++ at a specific prime.

WildFunctionFieldIntegralBasis(K,R,UP,F): Exports == Implementation where
  K  : FiniteFieldCategory
  --K  : Join(Field,Finite)
  R  : UnivariatePolynomialCategory K
  UP : UnivariatePolynomialCategory R
  F  : FramedAlgebra(R,UP)

  I       ==> Integer
  Mat     ==> Matrix R
  NNI     ==> NonNegativeInteger
  SAE     ==> SimpleAlgebraicExtension
  RResult ==> Record(basis: Mat, basisDen: R, basisInv:Mat)
  IResult ==> Record(basis: Mat, basisDen: R, basisInv:Mat,discr: R)
  MATSTOR ==> StorageEfficientMatrixOperations

  Exports ==> with
    integralBasis : () -> RResult
      ++ \spad{integralBasis()} returns a record
      ++ \spad{[basis,basisDen,basisInv]} containing information regarding
      ++ the integral closure of R in the quotient field of F, where
      ++ F is a framed algebra with R-module basis \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.
    localIntegralBasis : R -> RResult
      ++ \spad{integralBasis(p)} returns a record
      ++ \spad{[basis,basisDen,basisInv]} containing information regarding
      ++ the local integral closure of R at the prime \spad{p} in the quotient
      ++ field of F, where F is a framed algebra with R-module basis
      ++ \spad{w1,w2,...,wn}.
      ++ If \spad{basis} is the matrix \spad{(aij, i = 1..n, j = 1..n)}, then
      ++ the \spad{i}th element of the local integral basis is
      ++ \spad{vi = (1/basisDen) * sum(aij * wj, j = 1..n)}, i.e. the
      ++ \spad{i}th row of \spad{basis} contains the coordinates of the
      ++ \spad{i}th basis vector.  Similarly, the \spad{i}th row of the
      ++ matrix \spad{basisInv} contains the coordinates of \spad{wi} with
      ++ respect to the basis \spad{v1,...,vn}: if \spad{basisInv} is the
      ++ matrix \spad{(bij, i = 1..n, j = 1..n)}, then
      ++ \spad{wi = sum(bij * vj, j = 1..n)}.

  Implementation ==> add
    import IntegralBasisTools(R, UP, F)
    import ModularHermitianRowReduction(R)
    import TriangularMatrixOperations(R, Vector R, Vector R, Matrix R)
    import DistinctDegreeFactorize(K,R)

    listSquaredFactors: R -> List R
    listSquaredFactors px ==
      -- returns a list of the factors of px which occur with
      -- exponent > 1
      ans : List R := empty()
      factored := factor(px)$DistinctDegreeFactorize(K,R)
      for f in factors(factored) repeat
        if f.exponent > 1 then ans := concat(f.factor,ans)
      ans

    iLocalIntegralBasis: (Vector F,Vector F,Matrix R,Matrix R,R,R) -> IResult
    iLocalIntegralBasis(bas,pows,tfm,matrixOut,disc,prime) ==
      n := rank()$F; standardBasis := basis()$F
      -- 'standardBasis' is the basis for F as a FramedAlgebra;
      -- usually this is [1,y,y**2,...,y**(n-1)]
      p2 := prime * prime; sae := SAE(K,R,prime)
      p := characteristic()$F; q := size()$sae
      lp := leastPower(q,n)
      rb := scalarMatrix(n,1); rbinv := scalarMatrix(n,1)
      -- rb    = basis matrix of current order
      -- rbinv = inverse basis matrix of current order
      -- these are wrt the orginal basis for F
      rbden : R := 1; index : R := 1; oldIndex : R := 1
      -- rbden = denominator for current basis matrix
      -- index = index of original order in current order
      repeat
        -- pows = [(w1 * rbden) ** q,...,(wn * rbden) ** q], where
        -- bas = [w1,...,wn] is 'rbden' times the basis for the order B = 'rb'
        for i in 1..n repeat
          bi : F := 0
          for j in 1..n repeat
            bi := bi + qelt(rb,i,j) * qelt(standardBasis,j)
          qsetelt_!(bas,i,bi)
          qsetelt_!(pows,i,bi ** p)
        coor0 := transpose coordinates(pows,bas)
        denPow := rbden ** ((p - 1) :: NNI)
        (coMat0 := coor0 exquo denPow) case "failed" =>
          error "can't happen"
        -- the jth column of coMat contains the coordinates of (wj/rbden)**q
        -- with respect to the basis [w1/rbden,...,wn/rbden]
        coMat := coMat0 :: Matrix R
        -- the ith column of 'pPows' contains the coordinates of the pth power
        -- of the ith basis element for B/prime.B over 'sae' = R/prime.R
        pPows := map(reduce,coMat)$MatrixCategoryFunctions2(R,Vector R,
                    Vector R,Matrix R,sae,Vector sae,Vector sae,Matrix sae)
        -- 'frob' will eventually be the Frobenius matrix for B/prime.B over
        -- 'sae' = R/prime.R; at each stage of the loop the ith column will
        -- contain the coordinates of p^k-th powers of the ith basis element
        frob := copy pPows; tmpMat : Matrix sae := new(n,n,0)
        for r in 2..leastPower(p,q) repeat
          for i in 1..n repeat for j in 1..n repeat
            qsetelt_!(tmpMat,i,j,qelt(frob,i,j) ** p)
          times_!(frob,pPows,tmpMat)$MATSTOR(sae)
        frobPow := frob ** lp
        -- compute the p-radical
        ns := nullSpace frobPow
        for i in 1..n repeat for j in 1..n repeat qsetelt_!(tfm,i,j,0)
        for vec in ns for i in 1.. repeat
          for j in 1..n repeat
            qsetelt_!(tfm,i,j,lift qelt(vec,j))
        id := squareTop rowEchelon(tfm,prime)
        -- id = basis matrix of the p-radical
        idinv := UpTriBddDenomInv(id, prime)
        -- id * idinv = prime * identity
        -- no need to check for inseparability in this case
        rbinv := idealiser(id * rb, rbinv * idinv, prime * rbden)
        index := diagonalProduct rbinv
        rb := rowEchelon LowTriBddDenomInv(rbinv,rbden * prime)
        if divideIfCan_!(rb,matrixOut,prime,n) = 1
          then rb := matrixOut
          else rbden := rbden * prime
        rbinv := UpTriBddDenomInv(rb,rbden)
        indexChange := index quo oldIndex
        oldIndex := index
        disc := disc quo (indexChange * indexChange)
        (not sizeLess?(1,indexChange)) or ((disc exquo p2) case "failed") =>
          return [rb, rbden, rbinv, disc]

    integralBasis() ==
      traceMat := traceMatrix()$F; n := rank()$F
      disc := determinant traceMat        -- discriminant of current order
      zero? disc => error "integralBasis: polynomial must be separable"
      singList := listSquaredFactors disc -- singularities of relative Spec
      runningRb := scalarMatrix(n,1); runningRbinv := scalarMatrix(n,1)
      -- runningRb    = basis matrix of current order
      -- runningRbinv = inverse basis matrix of current order
      -- these are wrt the original basis for F
      runningRbden : R := 1
      -- runningRbden = denominator for current basis matrix
      empty? singList => [runningRb, runningRbden, runningRbinv]
      bas : Vector F := new(n,0); pows : Vector F := new(n,0)
      -- storage for basis elements and their powers
      tfm : Matrix R := new(n,n,0)
      -- 'tfm' will contain the coordinates of a lifting of the kernel
      -- of a power of Frobenius
      matrixOut : Matrix R := new(n,n,0)
      for prime in singList repeat
        lb := iLocalIntegralBasis(bas,pows,tfm,matrixOut,disc,prime)
        rb := lb.basis; rbinv := lb.basisInv; rbden := lb.basisDen
        disc := lb.discr
        -- update 'running integral basis' if newly computed
        -- local integral basis is non-trivial
        if sizeLess?(1,rbden) then
          mat := vertConcat(rbden * runningRb,runningRbden * rb)
          runningRbden := runningRbden * rbden
          runningRb := squareTop rowEchelon(mat,runningRbden)
          runningRbinv := UpTriBddDenomInv(runningRb,runningRbden)
      [runningRb, runningRbden, runningRbinv]

    localIntegralBasis prime ==
      traceMat := traceMatrix()$F; n := rank()$F
      disc := determinant traceMat        -- discriminant of current order
      zero? disc => error "localIntegralBasis: polynomial must be separable"
      (disc exquo (prime * prime)) case "failed" =>
        [scalarMatrix(n,1), 1, scalarMatrix(n,1)]
      bas : Vector F := new(n,0); pows : Vector F := new(n,0)
      -- storage for basis elements and their powers
      tfm : Matrix R := new(n,n,0)
      -- 'tfm' will contain the coordinates of a lifting of the kernel
      -- of a power of Frobenius
      matrixOut : Matrix R := new(n,n,0)
      lb := iLocalIntegralBasis(bas,pows,tfm,matrixOut,disc,prime)
      [lb.basis, lb.basisDen, lb.basisInv]

@
<<WFFINTBS.dotabb>>=
"WFFINTBS" [color="#FF4488",href="bookvol10.4.pdf#nameddest=WFFINTBS"]
"MONOGEN" [color="#4488FF",href="bookvol10.2.pdf#nameddest=MONOGEN"]
"WFFINTBS" -> "MONOGEN"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter X}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Y}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Z}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chunk collections}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<algebra>>=
<<package AF AlgebraicFunction>>
<<package INTHERAL AlgebraicHermiteIntegration>>
<<package INTALG AlgebraicIntegrate>>
<<package INTAF AlgebraicIntegration>>
<<package ALGMANIP AlgebraicManipulations>>
<<package ALGMFACT AlgebraicMultFact>>
<<package ALGPKG AlgebraPackage>>
<<package ALGFACT AlgFactor>>
<<package INTPACK AnnaNumericalIntegrationPackage>>
<<package OPTPACK AnnaNumericalOptimizationPackage>>
<<package ODEPACK AnnaOrdinaryDifferentialEquationPackage>>
<<package PDEPACK AnnaPartialDifferentialEquationPackage>>
<<package ANY1 AnyFunctions1>>
<<package APPLYORE ApplyUnivariateSkewPolynomial>>
<<package ASSOCEQ AssociatedEquations>>
<<package PMPRED AttachPredicates>>
<<package AXSERV AxiomServer>>

<<package BALFACT BalancedFactorisation>>
<<package BOP1 BasicOperatorFunctions1>>
<<package BEZOUT BezoutMatrix>>
<<package BOUNDZRO BoundIntegerRoots>>
<<package BRILL BrillhartTests>>

<<package CARTEN2 CartesianTensorFunctions2>>
<<package CHVAR ChangeOfVariable>>
<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>
<<package CHARPOL CharacteristicPolynomialPackage>>
<<package CVMP CoerceVectorMatrixPackage>>
<<package COMBF CombinatorialFunction>>
<<package CDEN CommonDenominator>>
<<package COMMONOP CommonOperators>>
<<package COMPFACT ComplexFactorization>>
<<package COMPLEX2 ComplexFunctions2>>
<<package CINTSLPE ComplexIntegerSolveLinearPolynomialEquation>>
<<package COMPLPAT ComplexPattern>>
<<package CPMATCH ComplexPatternMatch>>
<<package CRFP ComplexRootFindingPackage>>
<<package CMPLXRT ComplexRootPackage>>
<<package CTRIGMNP ComplexTrigonometricManipulations>>
<<package ODECONST ConstantLODE>>
<<package COORDSYS CoordinateSystems>>
<<package CRAPACK CRApackage>>
<<package CYCLES CycleIndicators>>
<<package CYCLOTOM CyclotomicPolynomialPackage>>

<<package DFINTTLS DefiniteIntegrationTools>>
<<package DEGRED DegreeReductionPackage>>
<<package DLP DiscreteLogarithmPackage>>
<<package DISPLAY DisplayPackage>>
<<package DDFACT DistinctDegreeFactorize>>
<<package DBLRESP DoubleResultantPackage>>
<<package DRAWCX DrawComplex>>
<<package DRAWHACK DrawNumericHack>>
<<package DROPT0 DrawOptionFunctions0>>
<<package DROPT1 DrawOptionFunctions1>>
<<package D01AGNT d01AgentsPackage>>
<<package D01WGTS d01WeightsPackage>>
<<package D02AGNT d02AgentsPackage>>
<<package D03AGNT d03AgentsPackage>>

<<package EP EigenPackage>>
<<package EF ElementaryFunction>>
<<package DEFINTEF ElementaryFunctionDefiniteIntegration>>
<<package LODEEF ElementaryFunctionLODESolver>>
<<package ODEEF ElementaryFunctionODESolver>>
<<package SIGNEF ElementaryFunctionSign>>
<<package EFSTRUC ElementaryFunctionStructurePackage>>
<<package EFULS ElementaryFunctionsUnivariateLaurentSeries>>
<<package EFUPXS ElementaryFunctionsUnivariatePuiseuxSeries>>
<<package INTEF ElementaryIntegration>>
<<package ELFUTS EllipticFunctionsUnivariateTaylorSeries>>
<<package EQ2 EquationFunctions2>>
<<package ERROR ErrorFunctions>>
<<package GBEUCLID EuclideanGroebnerBasisPackage>>
<<package EVALCYC EvaluateCycleIndicators>>
<<package ESCONT ExpertSystemContinuityPackage>>
<<package ESCONT1 ExpertSystemContinuityPackage1>>
<<package EXPR2 ExpressionFunctions2>>
<<package ES1 ExpressionSpaceFunctions1>>
<<package ES2 ExpressionSpaceFunctions2>>
<<package EXPRODE ExpressionSpaceODESolver>>
<<package OMEXPR ExpressionToOpenMath>>
<<package EXPR2UPS ExpressionToUnivariatePowerSeries>>
<<package E04AGNT e04AgentsPackage>>

<<package FACTFUNC FactoredFunctions>>
<<package FR2 FactoredFunctions2>>
<<package FRUTIL FactoredFunctionUtilities>>
<<package FACUTIL FactoringUtilities>>
<<package FAMR2 FiniteAbelianMonoidRingFunctions2>>
<<package FDIV2 FiniteDivisorFunctions2>>
<<package FFF FiniteFieldFunctions>>
<<package FFHOM FiniteFieldHomomorphisms>>
<<package FFPOLY FiniteFieldPolynomialPackage>>
<<package FFPOLY2 FiniteFieldPolynomialPackage2>>
<<package FFSLPE FiniteFieldSolveLinearPolynomialEquation>>
<<package FLAGG2 FiniteLinearAggregateFunctions2>>
<<package FLASORT FiniteLinearAggregateSort>>
<<package FSAGG2 FiniteSetAggregateFunctions2>>
<<package FLOATCP FloatingComplexPackage>>
<<package FLOATRP FloatingRealPackage>>
<<package FCPAK1 FortranCodePackage1>>
<<package FOP FortranOutputStackPackage>>
<<package FORT FortranPackage>>
<<package FRIDEAL2 FractionalIdealFunctions2>>
<<package FFFG FractionFreeFastGaussian>>
<<package FFFGF FractionFreeFastGaussianFractions>>
<<package FRAC2 FractionFunctions2>>
<<package FRNAAF2 FramedNonAssociativeAlgebraFunctions2>>
<<package FSPECF FunctionalSpecialFunction>>
<<package FFCAT2 FunctionFieldCategoryFunctions2>>
<<package FFINTBAS FunctionFieldIntegralBasis>>
<<package PMASSFS FunctionSpaceAssertions>>
<<package PMPREDFS FunctionSpaceAttachPredicates>>
<<package FSCINT FunctionSpaceComplexIntegration>>
<<package FS2 FunctionSpaceFunctions2>>
<<package FSINT FunctionSpaceIntegration>>
<<package SUMFS FunctionSpaceSum>>
<<package FS2EXPXP FunctionSpaceToExponentialExpansion>>
<<package FS2UPS FunctionSpaceToUnivariatePowerSeries>>
<<package FSUPFACT FunctionSpaceUnivariatePolynomialFactor>>

<<package GALFACTU GaloisGroupFactorizationUtilities>>
<<package GALFACT GaloisGroupFactorizer>>
<<package GALPOLYU GaloisGroupPolynomialUtilities>>
<<package GALUTIL GaloisGroupUtilities>>
<<package GAUSSFAC GaussianFactorizationPackage>>
<<package GHENSEL GeneralHenselPackage>>
<<package GENMFACT GeneralizedMultivariateFactorize>>
<<package GENPGCD GeneralPolynomialGcdPackage>>
<<package GENUPS GenerateUnivariatePowerSeries>>
<<package GENEEZ GenExEuclid>>
<<package GENUFACT GenUFactorize>>
<<package INTG0 GenusZeroIntegration>>
<<package GRDEF GraphicsDefaults>>
<<package GBF GroebnerFactorizationPackage>>
<<package GBINTERN GroebnerInternalPackage>>
<<package GB GroebnerPackage>>
<<package GROEBSOL GroebnerSolve>>
<<package GUESS Guess>>
<<package GUESSAN GuessAlgebraicNumber>>
<<package GUESSF GuessFinite>>
<<package GUESSF1 GuessFiniteFunctions>>
<<package GUESSINT GuessInteger>>
<<package GOPT0 GuessOptionFunctions0>>
<<package GUESSP GuessPolynomial>>
<<package GUESSUP GuessUnivariatePolynomial>>

<<package HB HallBasis>>
<<package HEUGCD HeuGcd>>

<<package IDECOMP IdealDecompositionPackage>>
<<package INFPROD0 InfiniteProductCharacteristicZero>>
<<package INPRODFF InfiniteProductFiniteField>>
<<package INPRODPF InfiniteProductPrimeField>>
<<package ITFUN2 InfiniteTupleFunctions2>>
<<package ITFUN3 InfiniteTupleFunctions3>>
<<package INFINITY Infinity>>
<<package IALGFACT InnerAlgFactor>>
<<package ICDEN InnerCommonDenominator>>
<<package IMATLIN InnerMatrixLinearAlgebraFunctions>>
<<package IMATQF InnerMatrixQuotientFieldFunctions>>
<<package INMODGCD InnerModularGcd>>
<<package INNMFACT InnerMultFact>>
<<package INBFF InnerNormalBasisFieldFunctions>>
<<package INEP InnerNumericEigenPackage>>
<<package INFSP InnerNumericFloatSolvePackage>>
<<package ITRIGMNP InnerTrigonometricManipulations>>
<<package INFORM1 InputFormFunctions1>>
<<package COMBINAT IntegerCombinatoricFunctions>>
<<package INTFACT IntegerFactorizationPackage>>
<<package ZLINDEP IntegerLinearDependence>>
<<package INTHEORY IntegerNumberTheoryFunctions>>
<<package PRIMES IntegerPrimesPackage>>
<<package IROOT IntegerRoots>>
<<package INTSLPE IntegerSolveLinearPolynomialEquation>>
<<package IBATOOL IntegralBasisTools>>
<<package IR2 IntegrationResultFunctions2>>
<<package IRRF2F IntegrationResultRFToFunction>>
<<package IR2F IntegrationResultToFunction>>
<<package IPRNTPK InternalPrintPackage>>
<<package IRREDFFX IrredPolyOverFiniteField>>
<<package IRSN IrrRepSymNatPackage>>
<<package INVLAPLA InverseLaplaceTransform>>

<<package KERNEL2 KernelFunctions2>>
<<package KOVACIC Kovacic>>

<<package LAPLACE LaplaceTransform>>
<<package LAZM3PK LazardSetSolvingPackage>>
<<package LEADCDET LeadingCoefDetermination>>
<<package LINDEP LinearDependence>>
<<package LODOF LinearOrdinaryDifferentialOperatorFactorizer>>
<<package LODOOPS LinearOrdinaryDifferentialOperatorsOps>>
<<package LPEFRAC LinearPolynomialEquationByFractions>>
<<package LGROBP LinGroebnerPackage>>
<<package LF LiouvillianFunction>>
<<package LIST2 ListFunctions2>>
<<package LIST3 ListFunctions3>>
<<package LIST2MAP ListToMap>>

<<package MKBCFUNC MakeBinaryCompiledFunction>>
<<package MKFLCFN MakeFloatCompiledFunction>>
<<package MKFUNC MakeFunction>>
<<package MKRECORD MakeRecord>>
<<package MKUCFUNC MakeUnaryCompiledFunction>>
<<package MAPHACK1 MappingPackageInternalHacks1>>
<<package MAPHACK2 MappingPackageInternalHacks2>>
<<package MAPHACK3 MappingPackageInternalHacks3>>
<<package MAPPKG1 MappingPackage1>>
<<package MAPPKG2 MappingPackage2>>
<<package MAPPKG3 MappingPackage3>>
<<package MAPPKG4 MappingPackage4>>
<<package MMLFORM MathMLForm>>
<<package MATCAT2 MatrixCategoryFunctions2>>
<<package MCDEN MatrixCommonDenominator>>
<<package MATLIN MatrixLinearAlgebraFunctions>>
<<package MTHING MergeThing>>
<<package MESH MeshCreationRoutinesForThreeDimensions>>
<<package MDDFACT ModularDistinctDegreeFactorizer>>
<<package MHROWRED ModularHermitianRowReduction>>
<<package MRF2 MonoidRingFunctions2>>
<<package MONOTOOL MonomialExtensionTools>>
<<package MPCPF MPolyCatPolyFactorizer>>
<<package MPRFF MPolyCatRationalFunctionFactorizer>>
<<package MRATFAC MRationalFactorize>>
<<package MFINFACT MultFiniteFactorize>>
<<package MMAP MultipleMap>>
<<package MCALCFN MultiVariableCalculusFunctions>>
<<package MULTFACT MultivariateFactorize>>
<<package MLIFT MultivariateLifting>>
<<package MULTSQFR MultivariateSquareFree>>

<<package NAGF02 NagEigenPackage>>
<<package NAGE02 NagFittingPackage>>
<<package NAGF04 NagLinearEquationSolvingPackage>>
<<package NAGSP NAGLinkSupportPackage>>
<<package NAGD01 NagIntegrationPackage>>
<<package NAGE01 NagInterpolationPackage>>
<<package NAGF07 NagLapack>>
<<package NAGF01 NagMatrixOperationsPackage>>
<<package NAGE04 NagOptimisationPackage>>
<<package NAGD02 NagOrdinaryDifferentialEquationsPackage>>
<<package NAGD03 NagPartialDifferentialEquationsPackage>>
<<package NAGC02 NagPolynomialRootsPackage>>
<<package NAGC05 NagRootFindingPackage>>
<<package NAGC06 NagSeriesSummationPackage>>
<<package NSUP2 NewSparseUnivariatePolynomialFunctions2>>
<<package NEWTON NewtonInterpolation>>
<<package NCODIV NonCommutativeOperatorDivision>>
<<package NONE1 NoneFunctions1>>
<<package NODE1 NonLinearFirstOrderODESolver>>
<<package NLINSOL NonLinearSolvePackage>>
<<package NORMPK NormalizationPackage>>
<<package NORMMA NormInMonogenicAlgebra>>
<<package NPCOEF NPCoef>>
<<package NFINTBAS NumberFieldIntegralBasis>>
<<package NUMFMT NumberFormats>>
<<package NUMERIC Numeric>>
<<package NUMODE NumericalOrdinaryDifferentialEquations>>
<<package NUMQUAD NumericalQuadrature>>
<<package NCEP NumericComplexEigenPackage>>
<<package NCNTFRAC NumericContinuedFraction>>
<<package NREP NumericRealEigenPackage>>

<<package OCTCT2 OctonionCategoryFunctions2>>
<<package ODEINT ODEIntegration>>
<<package ODETOOLS ODETools>>
<<package ARRAY12 OneDimensionalArrayFunctions2>>
<<package ONECOMP2 OnePointCompletionFunctions2>>
<<package OMPKG OpenMathPackage>>
<<package OMSERVER OpenMathServerPackage>>
<<package ORDCOMP2 OrderedCompletionFunctions2>>
<<package ORDFUNS OrderingFunctions>>
<<package OPQUERY OperationsQuery>>
<<package OUT OutputPackage>>

<<package PMASS PatternMatchAssertions>>
<<package INTPM PatternMatchIntegration>>
<<package PICOERCE PiCoercions>>
<<package PTFUNC2 PointFunctions2>>
<<package PTPACK PointPackage>>
<<package PAN2EXPR PolynomialAN2Expression>>
<<package POLY2 PolynomialFunctions2>>
<<package PNTHEORY PolynomialNumberTheoryFunctions>>
<<package POLYROOT PolynomialRoots>>
<<package LIMITPS PowerSeriesLimitPackage>>
<<package PREASSOC PrecomputedAssociatedEquations>>
<<package PRIMARR2 PrimitiveArrayFunctions2>>
<<package ODEPRIM PrimitiveRatDE>>
<<package INTPAF PureAlgebraicIntegration>>
<<package ODEPAL PureAlgebraicLODE>>
<<package PUSHVAR PushVariables>>

<<package QFCAT2 QuotientFieldCategoryFunctions2>>

<<package DEFINTRF RationalFunctionDefiniteIntegration>>
<<package RFFACT RationalFunctionFactor>>
<<package RFFACTOR RationalFunctionFactorizer>>
<<package INTRF RationalFunctionIntegration>>
<<package INTRAT RationalIntegration>>
<<package ODERAT RationalLODE>>
<<package REALSOLV RealSolvePackage>>
<<package RMCAT2 RectangularMatrixCategoryFunctions2>>
<<package ODERED ReduceLODE>>
<<package REDORDER ReductionOfOrder>>
<<package REPDB RepeatedDoubling>>
<<package REPSQ RepeatedSquaring>>
<<package RETSOL RetractSolvePackage>>

<<package SAERFFC SAERationalFunctionAlgFactor>>
<<package FORMULA1 ScriptFormulaFormat1>>
<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>
<<package SIMPAN SimplifyAlgebraicNumberConvertPackage>>
<<package SCACHE SortedCache>>
<<package SPECOUT SpecialOutputPackage>>
<<package MATSTOR StorageEfficientMatrixOperations>>
<<package STINPROD StreamInfiniteProduct>>
<<package SCPKG StructuralConstantsPackage>>
<<package SUBRESP SubResultantPackage>>
<<package SUPFRACF SupFractionFactorizer>>
<<package ODESYS SystemODESolver>>
<<package SYMFUNC SymmetricFunctions>>

<<package TBCMPPK TabulatedComputationPackage>>
<<package TANEXP TangentExpansions>>
<<package TEMUTL TemplateUtilities>>
<<package DRAW TopLevelDrawFunctions>>
<<package DRAWCURV TopLevelDrawFunctionsForAlgebraicCurves>>
<<package DRAWCFUN TopLevelDrawFunctionsForCompiledFunctions>>
<<package DRAWPT TopLevelDrawFunctionsForPoints>>
<<package INTHERTR TranscendentalHermiteIntegration>>
<<package INTTR TranscendentalIntegration>>
<<package TRMANIP TranscendentalManipulations>>
<<package TRIMAT TriangularMatrixOperations>>
<<package TRIGMNIP TrigonometricManipulations>>
<<package CLIP TwoDimensionalPlotClipping>>

<<package UFPS1 UnivariateFormalPowerSeriesFunctions>>
<<package ULS2 UnivariateLaurentSeriesFunctions2>>
<<package UPCDEN UnivariatePolynomialCommonDenominator>>
<<package OREPCTO UnivariateSkewPolynomialCategoryOps>>
<<package UTSODETL UTSodetools>>

<<package WFFINTBS WildFunctionFieldIntegralBasis>>

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex
\end{document}
