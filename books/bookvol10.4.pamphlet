\documentclass[dvipdfm]{book}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{axiom}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}
%%
%% pagehead consolidates standard page indexing
%%
\newcommand{\pagehead}[2]{% e.g. \pagehead{name}{abb}
\section{#1}
\label{#1}%
\label{#2}%
\index{{#1}}%
\index{{#2}}}%
%%
%% pagepic adds an image and an index entry
%%
\newcommand{\pagepic}[2]{% e.g. \pagepic{pathandfile}{abb}
\includegraphics{#1}%
\index{images!#2}}
%%
%% pageto is a forward link to a referenced page
%%
\newcommand{\pageto}[2]{% e.g. \pageto{abb}{name}
\ \\${\bf\Rightarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
%% pageback is a backward link to a referencing page
%%
\newcommand{\pagefrom}[2]{% e.g. \pagefrom{name}{abb}
\ \\${\bf\Leftarrow{}}${``#1''} (#2) \ref{#1} on page~\pageref{#1}}
%%
% special meanings for math characters
\providecommand{\N}{\mbox{\bbold N}}
\providecommand{\Natural}{\mbox{\bbold N}}
\providecommand{\Z}{\mbox{\bbold Z}}
\providecommand{\Integer}{\mbox{\bbold Z}}
\providecommand{\Rational}{\mbox{\bbold Q}}
\providecommand{\Q}{\mbox{\bbold Q}}
\providecommand{\Complex}{\mbox{\bbold C}}
\providecommand{\C}{{\mathcal C}}
\providecommand{\Real}{\mbox{\bbold R}}
\providecommand{\F}{{\mathcal F}}
\providecommand{\R}{{\mathcal R}}
\begin{document}
\begin{titlepage}
\center{\includegraphics{ps/axiomfront.ps}}
\vskip 0.1in
\includegraphics{ps/bluebayou.ps}\\
\vskip 0.1in
{\Huge{The 30 Year Horizon}}
\vskip 0.1in
$$
\begin{array}{lll}
Manuel\ Bronstein      & William\ Burge   & Timothy\ Daly \\
James\ Davenport       & Michael\ Dewar   & Martin\ Dunstan \\
Albrecht\ Fortenbacher & Patrizia\ Gianni & Johannes\ Grabmeier \\
Jocelyn\ Guidry        & Richard\ Jenks   & Larry\ Lambe \\
Michael\ Monagan       & Scott\ Morrison  & William\ Sit \\
Jonathan\ Steinbach    & Robert\ Sutor    & Barry\ Trager \\
Stephen\ Watt          & Jim\ Wen         & Clifton\ Williamson
\end{array}
$$
\center{\large{Volume 10: Axiom Algebra: Packages}}
\end{titlepage}
\pagenumbering{roman}
\begin{verbatim}
Portions Copyright (c) 2005 Timothy Daly

The Blue Bayou image Copyright (c) 2004 Jocelyn Guidry

Portions Copyright (c) 2004 Martin Dunstan

Portions Copyright (c) 1991-2002, 
The Numerical ALgorithms Group Ltd.
All rights reserved.

This book and the Axiom software is licensed as follows:

Redistribution and use in source and binary forms, with or 
without modification, are permitted provided that the following 
conditions are
met:

    - Redistributions of source code must retain the above 
      copyright notice, this list of conditions and the 
      following disclaimer.

    - Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the 
      following disclaimer in the documentation and/or other 
      materials provided with the distribution.

    - Neither the name of The Numerical ALgorithms Group Ltd. 
      nor the names of its contributors may be used to endorse 
      or promote products derived from this software without 
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

\end{verbatim}

Inclusion of names in the list of credits is based on historical
information and is as accurate as possible. Inclusion of names
does not in any way imply an endorsement but represents historical
influence on Axiom development.
\vfill
\eject
\begin{tabular}{lll}
Cyril Alberga         & Roy Adler             & Richard Anderson\\
George Andrews        & Henry Baker           & Stephen Balzac\\
Yurij Baransky        & David R. Barton       & Gerald Baumgartner\\
Gilbert Baumslag      & Fred Blair            & Vladimir Bondarenko\\
Mark Botch            & Alexandre Bouyer      & Peter A. Broadbery\\
Martin Brock          & Manuel Bronstein      & Florian Bundschuh\\
William Burge         & Quentin Carpent       & Bob Caviness\\
Bruce Char            & Cheekai Chin          & David V. Chudnovsky\\
Gregory V. Chudnovsky & Josh Cohen            & Christophe Conil\\
Don Coppersmith       & George Corliss        & Robert Corless\\
Gary Cornell          & Meino Cramer          & Claire Di Crescenzo\\
Timothy Daly Sr.      & Timothy Daly Jr.      & James H. Davenport\\
Jean Della Dora       & Gabriel Dos Reis      & Michael Dewar\\
Claire DiCrescendo    & Sam Dooley            & Lionel Ducos\\
Martin Dunstan        & Brian Dupee           & Dominique Duval\\
Robert Edwards        & Heow Eide-Goodman     & Lars Erickson\\
Richard Fateman       & Bertfried Fauser      & Stuart Feldman\\
Brian Ford            & Albrecht Fortenbacher & George Frances\\
Constantine Frangos   & Timothy Freeman       & Korrinn Fu\\
Marc Gaetano          & Rudiger Gebauer       & Kathy Gerber\\
Patricia Gianni       & Holger Gollan         & Teresa Gomez-Diaz\\
Laureano Gonzalez-Vega& Stephen Gortler       & Johannes Grabmeier\\
Matt Grayson          & James Griesmer        & Vladimir Grinberg\\
Oswald Gschnitzer     & Jocelyn Guidry        & Steve Hague\\
Vilya Harvey          & Satoshi Hamaguchi     & Martin Hassner\\
Ralf Hemmecke         & Henderson             & Antoine Hersen\\
Pietro Iglio          & Richard Jenks         & Kai Kaminski\\
Grant Keady           & Tony Kennedy          & Paul Kosinski\\
Klaus Kusche          & Bernhard Kutzler      & Larry Lambe\\
Frederic Lehobey      & Michel Levaud         & Howard Levy\\
Rudiger Loos          & Michael Lucks         & Richard Luczak\\
Camm Maguire          & Bob McElrath          & Michael McGettrick\\
Ian Meikle            & David Mentre          & Victor S. Miller\\
Gerard Milmeister     & Mohammed Mobarak      & H. Michael Moeller\\
Michael Monagan       & Marc Moreno-Maza      & Scott Morrison\\
Mark Murray           & William Naylor        & C. Andrew Neff\\
John Nelder           & Godfrey Nolan         & Arthur Norman\\
Jinzhong Niu          & Michael O'Connor      & Kostas Oikonomou\\
Julian A. Padget      & Bill Page             & Jaap Weel\\
Susan Pelzel          & Michel Petitot        & Didier Pinchon\\
Claude Quitte         & Norman Ramsey         & Michael Richardson\\
Renaud Rioboo         & Jean Rivlin           & Nicolas Robidoux\\
Simon Robinson        & Michael Rothstein     & Martin Rubey\\
Philip Santas         & Alfred Scheerhorn     & William Schelter\\
Gerhard Schneider     & Martin Schoenert      & Marshall Schor\\
Fritz Schwarz         & Nick Simicich         & William Sit\\
Elena Smirnova        & Jonathan Steinbach    & Christine Sundaresan\\
Robert Sutor          & Moss E. Sweedler      & Eugene Surowitz\\
James Thatcher        & Baldir Thomas         & Mike Thomas\\
Dylan Thurston        & Barry Trager          & Themos T. Tsikas\\
Gregory Vanuxem       & Bernhard Wall         & Stephen Watt\\
Juergen Weiss         & M. Weller             & Mark Wegman\\
James Wen             & Thorsten Werther      & Michael Wester\\
John M. Wiley         & Berhard Will          & Clifton J. Williamson\\
Stephen Wilson        & Shmuel Winograd       & Robert Wisbauer\\
Sandra Wityak         & Waldemar Wiwianka     & Knut Wolf\\
Clifford Yapp         & David Yun             & Richard Zippel\\
Evelyn Zoernack       & Bruno Zuercher        & Dan Zwillinger 
\end{tabular}
\eject
\tableofcontents
\vfill
\eject
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}
{\Large{\bf New Foreword}}
\vskip .25in

On October 1, 2001 Axiom was withdrawn from the market and ended
life as a commercial product.
On September 3, 2002 Axiom was released under the Modified BSD
license, including this document.
On August 27, 2003 Axiom was released as free and open source
software available for download from the Free Software Foundation's
website, Savannah.

Work on Axiom has had the generous support of the Center for 
Algorithms and Interactive Scientific Computation (CAISS) at
City College of New York. Special thanks go to Dr. Gilbert 
Baumslag for his support of the long term goal.

The online version of this documentation is roughly 1000 pages.
In order to make printed versions we've broken it up into three
volumes. The first volume is tutorial in nature. The second volume
is for programmers. The third volume is reference material. We've
also added a fourth volume for developers. All of these changes
represent an experiment in print-on-demand delivery of documentation.
Time will tell whether the experiment succeeded.

Axiom has been in existence for over thirty years. It is estimated to
contain about three hundred man-years of research and has, as of
September 3, 2003, 143 people listed in the credits. All of these
people have contributed directly or indirectly to making Axiom
available.  Axiom is being passed to the next generation. I'm looking
forward to future milestones.

With that in mind I've introduced the theme of the ``30 year horizon''.
We must invent the tools that support the Computational Mathematician
working 30 years from now. How will research be done when every bit of
mathematical knowledge is online and instantly available? What happens
when we scale Axiom by a factor of 100, giving us 1.1 million domains?
How can we integrate theory with code? How will we integrate theorems
and proofs of the mathematics with space-time complexity proofs and
running code? What visualization tools are needed? How do we support
the conceptual structures and semantics of mathematics in effective
ways? How do we support results from the sciences? How do we teach
the next generation to be effective Computational Mathematicians?

The ``30 year horizon'' is much nearer than it appears.

\vskip .25in
%\noindent
Tim Daly\\
CAISS, City College of New York\\
November 10, 2003 ((iHy))
\vfill
\eject
\pagenumbering{arabic}
\chapter{Chapter Overview}
This book contains the domains in Axiom, in alphabetical order.

Each domain has an associated 'dotpic' chunk which only lists the
domains, categories, and packages that are in the layer immediately
below in the build order. For the full list see the algebra Makefile
where this information is maintained.

Each domain is preceded by a picture. The picture indicates several 
things. The colors indicate whether the name refers to a category,
domain, or package. An ellipse means that the name refers to something
in the bootstrap set. Thus,

\includegraphics[scale=0.85]{ps/v103colorchart.ps}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\pagehead{Domain}{ABB}
%\pagepic{ps/v103domain.ps}{ABB}{1.00}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter A}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AF AlgebraicFunction}
\pagehead{AlgebraicFunction}{AF}
\pagepic{ps/v104algebraicfunction.ps}{AF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AF AlgebraicFunction>>=
)abbrev package AF AlgebraicFunction
++ Author: Manuel Bronstein
++ Date Created: 21 March 1988
++ Date Last Updated: 11 November 1993
++ Description:
++   This package provides algebraic functions over an integral domain.
++ Keywords: algebraic, function.

AlgebraicFunction(R, F): Exports == Implementation where
  R: Join(OrderedSet, IntegralDomain)
  F: FunctionSpace R

  SE  ==> Symbol
  Z   ==> Integer
  Q   ==> Fraction Z
  OP  ==> BasicOperator
  K   ==> Kernel F
  P   ==> SparseMultivariatePolynomial(R, K)
  UP  ==> SparseUnivariatePolynomial F
  UPR ==> SparseUnivariatePolynomial R
  ALGOP       ==> "%alg"
  SPECIALDISP ==> "%specialDisp"
  SPECIALDIFF ==> "%specialDiff"

  Exports ==> with
    rootOf  : (UP, SE) -> F
      ++ rootOf(p, y) returns y such that \spad{p(y) = 0}.
      ++ The object returned displays as \spad{'y}.
    operator: OP -> OP
      ++ operator(op) returns a copy of \spad{op} with the domain-dependent
      ++ properties appropriate for \spad{F}.
      ++ Error: if op is not an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    belong? : OP -> Boolean
      ++ belong?(op) is true if \spad{op} is an algebraic operator, that is,
      ++ an nth root or implicit algebraic operator.
    inrootof: (UP, F) -> F
      ++ inrootof(p, x) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    droot : List F -> OutputForm
      ++ droot(l) should be a non-exported function.
      -- un-export when the compiler accepts conditional local functions!
    if R has RetractableTo Integer then
      "**"   : (F, Q) -> F
        ++ x ** q is \spad{x} raised to the rational power \spad{q}.
      minPoly: K  -> UP
        ++ minPoly(k) returns the defining polynomial of \spad{k}.
      definingPolynomial: F -> F
        ++ definingPolynomial(f) returns the defining polynomial of \spad{f}
        ++ as an element of \spad{F}.
        ++ Error: if f is not a kernel.
      iroot : (R, Z) -> F
        ++ iroot(p, n) should be a non-exported function.
        -- un-export when the compiler accepts conditional local functions!

  Implementation ==> add
    ialg : List F -> F
    dvalg: (List F, SE) -> F
    dalg : List F -> OutputForm

    opalg  := operator("rootOf"::Symbol)$CommonOperators
    oproot := operator("nthRoot"::Symbol)$CommonOperators

    belong? op == has?(op, ALGOP)
    dalg l     == second(l)::OutputForm

    rootOf(p, x) ==
      k := kernel(x)$K
      (r := retractIfCan(p)@Union(F, "failed")) case "failed" =>
        inrootof(p, k::F)
      n := numer(f := univariate(r::F, k))
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(n, k::F)

    dvalg(l, x) ==
      p := numer univariate(first l, retract(second l)@K)
      alpha := kernel(opalg, l)
      - (map(differentiate(#1, x), p) alpha) / ((differentiate p) alpha)

    ialg l ==
      f := univariate(p := first l, retract(x := second l)@K)
      degree denom f > 0 => error "roofOf: variable appears in denom"
      inrootof(numer f, x)

    operator op ==
      is?(op,  "rootOf"::Symbol) => opalg
      is?(op, "nthRoot"::Symbol) => oproot
      error "Unknown operator"

    if R has AlgebraicallyClosedField then
      UP2R: UP -> Union(UPR, "failed")

      inrootof(q, x) ==
        monomial? q => 0

        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d=> - leadingCoefficient(reductum q) / leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) / leadingCoefficient q
        ((rx := retractIfCan(x)@Union(SE, "failed")) case SE) and
          ((r := UP2R q) case UPR) => rootOf(r::UPR, rx::SE)::F
        kernel(opalg, [q x, x])

      UP2R p ==
        ans:UPR := 0
        while p ^= 0 repeat
          (r := retractIfCan(leadingCoefficient p)@Union(R, "failed"))
            case "failed" => return "failed"
          ans := ans + monomial(r::R, degree p)
          p   := reductum p
        ans

    else
      inrootof(q, x) ==
        monomial? q => 0
        (d := degree q) <= 0 => error "rootOf: constant polynomial"
--        one? d => - leadingCoefficient(reductum q) /leadingCoefficient q
        (d = 1) => - leadingCoefficient(reductum q) /leadingCoefficient q
        kernel(opalg, [q x, x])

    evaluate(opalg, ialg)$BasicOperatorFunctions1(F)
    setProperty(opalg, SPECIALDIFF,
                              dvalg@((List F, SE) -> F) pretend None)
    setProperty(opalg, SPECIALDISP,
                              dalg@(List F -> OutputForm) pretend None)

    if R has RetractableTo Integer then
      import PolynomialRoots(IndexedExponents K, K, R, P, F)

      dumvar := "%%var"::Symbol::F

      lzero   : List F -> F
      dvroot  : List F -> F
      inroot  : List F -> F
      hackroot: (F, Z) -> F
      inroot0 : (F, Z, Boolean, Boolean) -> F

      lzero l == 0

      droot l ==
        x := first(l)::OutputForm
        (n := retract(second l)@Z) = 2 => root x
        root(x, n::OutputForm)

      dvroot l ==
        n := retract(second l)@Z
        (first(l) ** ((1 - n) / n)) / (n::F)

      x ** q ==
        qr := divide(numer q, denom q)
        x ** qr.quotient * inroot([x, (denom q)::F]) ** qr.remainder

      hackroot(x, n) ==
        (n = 1) or (x = 1) => x
        (((dx := denom x) ^= 1) and
           ((rx := retractIfCan(dx)@Union(Integer,"failed")) case Integer) and
           positive?(rx))
           => hackroot((numer x)::F, n)/hackroot(rx::Integer::F, n)
        (x = -1) and n = 4 =>
          ((-1::F) ** (1::Q / 2::Q) + 1) / ((2::F) ** (1::Q / 2::Q))
        kernel(oproot, [x, n::F])

      inroot l ==
        zero?(n := retract(second l)@Z) => error "root: exponent = 0"
--        one?(x := first l) or one? n => x
        ((x := first l) = 1) or (n = 1) => x
        (r := retractIfCan(x)@Union(R,"failed")) case R => iroot(r::R,n)
        (u := isExpt(x, oproot)) case Record(var:K, exponent:Z) =>
          pr := u::Record(var:K, exponent:Z)
          (first argument(pr.var)) **
              (pr.exponent /$Fraction(Z)
                   (n * retract(second argument(pr.var))@Z))
        inroot0(x, n, false, false)

-- removes powers of positive integers from numer and denom
-- num? or den? is true if numer or denom already processed
      inroot0(x, n, num?, den?) ==
        rn:Union(Z, "failed") := (num? => "failed"; retractIfCan numer x)
        rd:Union(Z, "failed") := (den? => "failed"; retractIfCan denom x)
        (rn case Z) and (rd case Z) =>
          rec := qroot(rn::Z / rd::Z, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)
        rn case Z =>
          rec := qroot(rn::Z::Fraction(Z), n::NonNegativeInteger)
          rec.coef * inroot0((rec.radicand**(n exquo rec.exponent)::Z)
                                / (denom(x)::F), n, true, den?)
        rd case Z =>
          rec := qroot(rd::Z::Fraction(Z), n::NonNegativeInteger)
          inroot0((numer(x)::F) /
                  (rec.radicand ** (n exquo rec.exponent)::Z),
                   n, num?, true) / rec.coef
        hackroot(x, n)

      if R has AlgebraicallyClosedField then iroot(r, n) == nthRoot(r, n)::F
      else
        iroot0: (R, Z) -> F

        if R has RadicalCategory then
          if R has imaginary:() -> R then iroot(r, n) == nthRoot(r, n)::F
          else
            iroot(r, n) ==
              odd? n or r >= 0 => nthRoot(r, n)::F
              iroot0(r, n)

        else iroot(r, n) == iroot0(r, n)

        iroot0(r, n) ==
          rec := rroot(r, n::NonNegativeInteger)
          rec.coef * hackroot(rec.radicand, rec.exponent)

      definingPolynomial x ==
        (r := retractIfCan(x)@Union(K, "failed")) case K =>
          is?(k := r::K, opalg) => first argument k
          is?(k, oproot) =>
            dumvar ** retract(second argument k)@Z - first argument k
          dumvar - x
        dumvar - x

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        is?(k, oproot) =>
           monomial(1,retract(second argument k)@Z :: NonNegativeInteger)
             - first(argument k)::UP
        monomial(1, 1) - k::F::UP

      evaluate(oproot, inroot)$BasicOperatorFunctions1(F)
      derivative(oproot, [dvroot, lzero])

    else   -- R is not retractable to Integer
      droot l ==
        x := first(l)::OutputForm
        (n := second l) = 2::F => root x
        root(x, n::OutputForm)

      minPoly k ==
        is?(k, opalg)  =>
           numer univariate(first argument k,
                                           retract(second argument k)@K)
        monomial(1, 1) - k::F::UP

    setProperty(oproot, SPECIALDISP,
                              droot@(List F -> OutputForm) pretend None)

@
<<AF.dotabb>>=
"AF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AF"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ALGFACT AlgFactor}
\pagehead{AlgFactor}{ALGFACT}
\pagepic{ps/v104algfactor.ps}{ALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ALGFACT AlgFactor>>=
)abbrev package ALGFACT AlgFactor
++ Factorization of UP AN;
++ Author: Manuel Bronstein
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in 
++ \spadtype{AlgebraicNumber}.
 
AlgFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory AlgebraicNumber
 
  N   ==> NonNegativeInteger
  Z   ==> Integer
  Q   ==> Fraction Integer
  AN  ==> AlgebraicNumber
  K   ==> Kernel AN
  UPQ ==> SparseUnivariatePolynomial Q
  SUP ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
 
  Exports ==> with
    factor: (UP, List AN) -> FR
      ++ factor(p, [a1,...,an]) returns a prime factorisation of p
      ++ over the field generated by its coefficients and a1,...,an.
    factor: UP            -> FR
      ++ factor(p) returns a prime factorisation of p
      ++ over the field generated by its coefficients.
    split : UP            -> FR
      ++ split(p) returns a prime factorisation of p
      ++ over its splitting field.
    doublyTransitive?: UP -> Boolean
      ++ doublyTransitive?(p) is true if p is irreducible over
      ++ over the field K generated by its coefficients, and
      ++ if \spad{p(X) / (X - a)} is irreducible over 
      ++ \spad{K(a)} where \spad{p(a) = 0}.
 
  Implementation ==> add
    import PolynomialCategoryQuotientFunctions(IndexedExponents K,
                           K, Z, SparseMultivariatePolynomial(Z, K), AN)

    UPCF2 ==> UnivariatePolynomialCategoryFunctions2

    fact    : (UP,  List K) -> FR
    ifactor : (SUP, List K) -> Factored SUP
    extend  : (UP, Z) -> FR
    allk    : List AN -> List K
    downpoly: UP  -> UPQ
    liftpoly: UPQ -> UP
    irred?  : UP  -> Boolean
 
    allk l       == removeDuplicates concat [kernels x for x in l]
    liftpoly p   == map(#1::AN,  p)$UPCF2(Q, UPQ, AN, UP)
    downpoly p   == map(retract(#1)@Q, p)$UPCF2(AN, UP ,Q, UPQ)
    ifactor(p,l) == (fact(p pretend UP, l)) pretend Factored(SUP)
    factor p     == fact(p, allk coefficients p)
 
    factor(p, l) ==
      fact(p, allk removeDuplicates concat(l, coefficients p))
 
    split p ==
      fp := factor p
      unit(fp) *
            _*/[extend(fc.factor, fc.exponent) for fc in factors fp]
 
    extend(p, n) ==
--      one? degree p => primeFactor(p, n)
      (degree p = 1) => primeFactor(p, n)
      q := monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP
      primeFactor(q, n) * split((p exquo q)::UP) ** (n::N)
 
    doublyTransitive? p ==
      irred? p and irred?((p exquo
        (monomial(1, 1)$UP - zeroOf(p pretend SUP)::UP))::UP)
 
    irred? p ==
      fp := factor p
--      one? numberOfFactors fp and one? nthExponent(fp, 1)
      (numberOfFactors fp = 1) and  (nthExponent(fp, 1) = 1)
 
    fact(p, l) ==
--      one? degree p => primeFactor(p, 1)
      (degree p = 1) => primeFactor(p, 1)
      empty? l =>
        dr := factor(downpoly p)$RationalFactorize(UPQ)
        (liftpoly unit dr) *
          _*/[primeFactor(liftpoly dc.factor,dc.exponent)
            for dc in factors dr]
      q   := minPoly(alpha := "max"/l)$AN
      newl  := remove(alpha = #1, l)
      sae := SimpleAlgebraicExtension(AN, SUP, q)
      ups := SparseUnivariatePolynomial sae
      fr  := factor(map(reduce univariate(#1, alpha, q),
                     p)$UPCF2(AN, UP, sae, ups),
                      ifactor(#1, newl))$InnerAlgFactor(AN, SUP, sae, ups)
      newalpha := alpha::AN
      map((lift(#1)$sae) newalpha, unit fr)$UPCF2(sae, ups, AN, UP) *
            _*/[primeFactor(map((lift(#1)$sae) newalpha,
                      fc.factor)$UPCF2(sae, ups, AN, UP),
                                 fc.exponent) for fc in factors fr]

@
<<ALGFACT.dotabb>>=
"ALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ANY1 AnyFunctions1}
\pagehead{AnyFunctions1}{ANY1}
\pagepic{ps/v104anyfunctions1.ps}{ANY1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ANY1 AnyFunctions1>>=
)abbrev package ANY1 AnyFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions:  coerce, retractIfCan, retractable?, retract
++ Related Constructors: Any
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{AnyFunctions1} implements several utility functions for
++   working with \spadtype{Any}. These functions are used to go back
++   and forth between objects of \spadtype{Any} and objects of other
++   types.

AnyFunctions1(S:Type): with
        coerce      : S -> Any
          ++ coerce(s) creates an object of \spadtype{Any} from the
          ++ object \spad{s} of type \spad{S}.
        retractIfCan: Any -> Union(S, "failed")
          ++ retractIfCan(a) tries change \spad{a} into an object
          ++ of type \spad{S}. If it can, then such an object is
          ++ returned. Otherwise, "failed" is returned.
        retractable?: Any -> Boolean
          ++ retractable?(a) tests if \spad{a} can be converted
          ++ into an object of type \spad{S}.
        retract     : Any -> S
          ++ retract(a) tries to convert \spad{a} into an object of
          ++ type \spad{S}. If possible, it returns the object.
          ++ Error: if no such retraction is possible.

    == add
        import NoneFunctions1(S)

        Sexpr:SExpression := devaluate(S)$Lisp

        retractable? a  == dom(a) = Sexpr
        coerce(s:S):Any == any(Sexpr, s::None)

        retractIfCan a ==
            retractable? a => obj(a) pretend S
            "failed"

        retract a ==
            retractable? a => obj(a) pretend S
            error "Cannot retract value."

@
<<ANY1.dotabb>>=
"ANY1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ANY1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"ANY1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package AXSERV AxiomServer}
\pagehead{AxiomServer}{AXSERV}
\pagepic{ps/v104axiomserver.ps}{AXSERV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package AXSERV AxiomServer>>=

)abbrev package AXSERV AxiomServer
AxiomServer: public == private where

 public == with

   axServer: (Integer, SExpression->Void) -> Void
   multiServ: SExpression -> Void
   getDatabase: (String,String) -> String

 private == add

   getFile: (SExpression,String) -> Void
   getCommand: (SExpression,String) -> Void
   getDescription: String -> String
   getInterp: (SExpression,String) -> Void
   getLisp:   (SExpression,String) -> Void
   getShow:   (SExpression,String) -> Void
   lastStep: () -> String
   lastType: () -> String
   formatMessages: String -> String
   makeErrorPage: String -> String
   getSourceFile: (String,String,String) -> String
   makeDBPage: String -> String
   getContentType: String -> String
   readTheFile: SExpression -> String 
   outputToSocket: (SExpression,String,String) -> Void 

   getDatabase(constructor:String, key:String):String ==
     answer:=string GETDATABASE(INTERN$Lisp constructor,INTERN$Lisp key)$Lisp
--     WriteLine$Lisp concat ["getDatabase: ",constructor," ",key," ",answer]
     answer

@
The axServer function handles the socket connection on the given port.
When it gets a input on the socket it calls the server
function on the socket input.
<<package AXSERV AxiomServer>>=
   axServer(port:Integer,serverfunc:SExpression->Void):Void ==
     WriteLine$Lisp "listening on port 8085"
     s := SiSock(port,serverfunc)$Lisp
     -- To listen for just one connection and then close the socket
     -- uncomment i := 0.
     i:Integer := 1
     while (i > 0) repeat
       if not null?(SiListen(s)$Lisp)$SExpression then
         w := SiAccept(s)$Lisp
         serverfunc(w)
--        i := 0

@
The multiServ function parses the socket input.
It expects either a GET or POST request.

A GET request fetches a new page, calling ``getFile''.
A POST request starts with 
\begin{itemize}
\item ``command='' which expects axiom interpreter commands. 
       When this is recognized we call the ``getCommand'' function.
\item ``lispcall='' which expects lisp interpreter input
       When this is recognized we call the ``getLisp'' function.
\end{itemize}
<<package AXSERV AxiomServer>>=

   multiServ(s:SExpression):Void ==
--     WriteLine("multiServ begin")$Lisp
     headers:String := ""
     char:String
     -- read in the http headers
     while (char := _
       STRING(READ_-CHAR_-NO_-HANG(s,NIL$Lisp,'EOF)$Lisp)$Lisp) ^= "EOF"_
        repeat
         headers := concat [headers,char]
--     sayTeX$Lisp headers
     StringMatch("([^ ]*)", headers)$Lisp
     u:UniversalSegment(Integer)
     u := segment(MatchBeginning(1)$Lisp+1,_
                  MatchEnd(1)$Lisp)$UniversalSegment(Integer)
     reqtype:String := headers.u
--     sayTeX$Lisp  concat ["request type: ",reqtype]
     if  reqtype = "GET" then
         StringMatch("GET ([^ ]*)",headers)$Lisp
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getFile(s,headers.u)
     if reqtype = "POST" and StringMatch("command=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getCommand(s,headers.u)
     if reqtype = "POST" and StringMatch("interpcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getInterp(s,headers.u)
     if reqtype = "POST" and StringMatch("lispcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getLisp(s,headers.u)
     if reqtype = "POST" and StringMatch("showcall=(.*)$",headers)$Lisp > 0
      then
         u:UniversalSegment(Integer)
         u := segment(MatchBeginning(1)$Lisp+1,_
                      MatchEnd(1)$Lisp)$UniversalSegment(Integer)
         getShow(s,headers.u)
--     WriteLine("multiServ end")$Lisp
--     WriteLine("")$Lisp

@
\subsubsection{getFile}
Given a socket and the URL of the file we create an input stream 
that contains the file. If the filename contains a question mark
then we need to parse the parameters and dynamically construct the
file contents.
<<package AXSERV AxiomServer>>=
   getFile(s:SExpression,pathvar:String):Void ==
--     WriteLine("")$Lisp
     WriteLine$Lisp concat ["getFile: ",pathvar]
     params:=split(pathvar,char "?")
     if #params = 1 
      then if not null? PATHNAME_-NAME(PATHNAME(pathvar)$Lisp)$Lisp 
       then
         contentType:String := getContentType(pathvar)
         q:=Open(pathvar)$Lisp
         if null? q 
           then
             q := MAKE_-STRING_-INPUT_-STREAM(_
                   makeErrorPage("File doesn't exist"))$Lisp
       else
         q:=MAKE_-STRING_-INPUT_-STREAM(_
             makeErrorPage("Problem with file path"))$Lisp
      else
       q:=MAKE_-STRING_-INPUT_-STREAM(makeDBPage(pathvar))$Lisp
     outputToSocket(s,readTheFile(q),contentType)     

@
\subsubsection{makeErrorPage}
<<package AXSERV AxiomServer>>=
   makeErrorPage(msg:String):String ==
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head><title>Error</title></head><body>" msg "</body></html>"
--     WriteLine(page)$Lisp
     page
@
\subsubsection{getDescription}
We need to fish around in the data structure to return the piece of 
documentation for the domain. We have to call the lisp version of
GETDATABASE because the version above returns a string object. The
string object is missing quotes and cannot be properly read. So we
need to get the lisp object and work with it in native form first.

The doc string also contains spad markup which we need to replace with html.
<<package AXSERV AxiomServer>>=
   getDescription(dom:String):String ==
    d:=CADR(CADAR(GETDATABASE(INTERN(dom)$Lisp,'DOCUMENTATION)$Lisp)$Lisp)$Lisp
    string d
@
\subsubsection{getSourceFile}
During build we construct a hash table that takes the chunk name as
the key and returns the filename. We reconstruct the chunk name here
and do a lookup for the source file.
<<package AXSERV AxiomServer>>=
   getSourceFile(constructorkind:String,_
                 abbreviation:String,_
                 dom:String):String ==
     sourcekey:="@<<" constructorkind " " abbreviation " " dom ">>"
--     WriteLine(sourcekey)$Lisp
     sourcefile:=lowerCase last split(getDatabase(dom,"SOURCEFILE"),char "/") 
     sourcefile:=sourcefile ".pamphlet"

@
\subsubsection{makeDBPage}
<<package AXSERV AxiomServer>>=
   makeDBPage(pathvar:String):String ==
     params:List(String):=split(pathvar,char "?")
     for i in 1..#params repeat WriteLine$Lisp concat ["params: ",params.i]
     pathparts:List(String):=split(params.1,char "/")
     for i in 1..#pathparts repeat 
       WriteLine$Lisp concat ["pathparts: ",pathparts.i]
     pagename:=last pathparts
     WriteLine$Lisp concat ["pagename: ",pagename]
     cmd:=first split(pagename,char ".")
     WriteLine$Lisp concat ["cmd: ",cmd]
     args:List(String):=split(params.2, char "&")
     for i in 1..#args repeat WriteLine$Lisp concat ["args: ",args.i]
     page:String:="<!DOCTYPE html PUBLIC "
     page:=page "_"-//W3C//DTD XHTML 1.0 Strict//EN_" "
     page:=page "_"http://www.w3.org/TR/xthml1/DTD/xhtml1-strict.dtd_">"
     page:=page "<html xmlns=_"http://www.w3.org/1999/xhtml_">"
     page:=page "<head>"
     page:=page "<meta http-equiv=_"Content-Type_" content=_"text/html_"" 
     page:=page " charset=_"us-ascii_"/>"
     page:=page "<title>" cmd " " args.1 "</title></head>"
     page:=page "<style> html { background-color: #FFFF66; } </style>"
     page:=page "<body>"
     cmd = "db" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
     cmd = "op" =>
      dom:=args.1
      domi:=INTERN(dom)$Lisp
      -- category, domain, or package?
      constructorkind:=getDatabase(dom,"CONSTRUCTORKIND")
      abbreviation:=getDatabase(dom, "ABBREVIATION")
      sourcefile:=getDatabase(dom, "SOURCEFILE")
      constructorkind.1:=upperCase constructorkind.1
      description:=getDescription(dom)
      page:=page "<div align=_"center_">"
      page:=page "<img align=_"middle_" src=_"doctitle.png_"/></div><hr/>"
      page:=page "<div align=_"center_">" constructorkind " " dom "</div><hr/>"
      page:=page "<table>"
      page:=page "<tr><td valign=_"top_">Description:  </td>"
      page:=page "<td>" description  "</td></tr>"
      page:=page "<tr><td>Abbreviation: </td><td>" abbreviation "</td></tr>"
      page:=page "<tr><td>Source File:  </td><td>" sourcefile   "</td></tr>"
      page:=page "</table><hr/>"
      page:=page "<table>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Ancestors_">Ancestors</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Dependents_">Dependents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Exports_">Exports</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Parents_">Parents</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Users_">Users</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "<tr>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Attributes_">Attributes</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Examples_">Examples</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Operations_">Operations</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=SearchPath_">Search Path</a>"
      page:=page "</td>"
      page:=page "<td>"
      page:=page "<a href=_"?" dom "&lookup=Uses_">Uses</a>"
      page:=page "</td>"
      page:=page "</tr>"
      page:=page "</table>"
--     WriteLine(page)$Lisp
     page:=page "</body></html>"
     page
@
\subsubsection{readTheFile}
We have q which is a stream which contains the file. We read the file
into a string-stream to get it all into one string. We return the string.
<<package AXSERV AxiomServer>>=
   readTheFile(q:SExpression):String ==
--     WriteLine("begin reading file")$Lisp
     r := MAKE_-STRING_-OUTPUT_-STREAM()$Lisp
     SiCopyStream(q,r)$Lisp
     filestream:String := GET_-OUTPUT_-STREAM_-STRING(r)$Lisp
     CLOSE(r)$Lisp
     CLOSE(q)$Lisp
--     WriteLine("end reading file")$Lisp
     filestream

@
\subsubsection{outputToSocket}
We have ``s'' which is the socket, ``filestream'' which is the text of
the file to output, and ``contentType'' which is the HTML Content-Type.
We construct the HTML header information according to the standard and
prepend it to the file. The resulting string is output to the socket.
<<package AXSERV AxiomServer>>=
   outputToSocket(s:SExpression,filestream:String,contentType:String):Void ==
     filelength:String := string(#filestream)
     file:String := ""
     nl:String:=STRING(NewLine$Lisp)$Lisp
     file := concat ["Content-Length: ",filelength,nl,nl,file]
     file := concat ["Connection: close",nl,file]
     file := concat ["Content-Type: ",contentType,nl,file]
     file := concat ["HTTP/1.1 200 OK",nl,file]
     file := concat [file,filestream]
--     WriteLine(file)$Lisp
     f:=MAKE_-STRING_-INPUT_-STREAM(file)$Lisp
     SiCopyStream(f,s)$Lisp
     CLOSE(f)$Lisp
     CLOSE(s)$Lisp

@
\subsubsection{getCommand}
The getCommand function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getCommand(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getCommand: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getInterp}
The getInterp function is invoked when the HTTP request is a POST
and contains the string "command". Essentially the game here is
to rebind the various output streams used by Axiom so we can
capture the normal output. This function returns a set of HTML 5 div
blocks:
\begin{enumerate}
\item stepnum, the value of lastStep()
\item command, the value of the  command variable
\item algebra, the value of the algebra variable
\item mathml, the value of the mathml variable
\item type, the value of lastType()
\end{enumerate}
The HTML functions in the hyperdoc browser depend on the order
of these variables so do not change this without changing the
corresponding functions in the browser HTML.
<<package AXSERV AxiomServer>>=
   getInterp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getInterp: ",command]
       SETQ(tmpmathml$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       ans := string parseAndEvalToStringEqNum$Lisp command
       SETQ(resultmathml$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$texOutputStream$Lisp)$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpmathml$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       mathml:String := string(resultmathml$Lisp)
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
         concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                  <div class=_"command_">", command, "</div>_
                  <div class=_"algebra_">",algebra,"</div>_
                  <div class=_"mathml_">",mathml,"</div>_
                  <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@

\subsubsection{getLisp}
The getLisp function is invoked when the HTTP request is a POST
and contains the string "lispcall".
<<package AXSERV AxiomServer>>=
   getLisp(s:SExpression,command:String):Void ==
       WriteLine$Lisp concat ["getLisp: ",command]
       evalresult:=EVAL(READ_-FROM_-STRING(command)$Lisp)$Lisp
       mathml:String:=string(evalresult)
--       WriteLine$Lisp concat ["getLisp: after ",mathml]
--       WriteLine$Lisp concat ["getLisp output: ",mathml]
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", command, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
--       WriteLine$Lisp concat ["algebra answer: ",algebra]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{getShow}
The getShow function is invoked when the HTTP request is a POST
and contains the string "showcall". The )show command generates
output to lisp's *standard-output* so we wrap that stream to capture it.
The resulting string needs to be transformed into html-friendly form.
This is done in the call to replace-entitites (see http.lisp)
<<package AXSERV AxiomServer>>=
   getShow(s:SExpression,showarg:String):Void ==
       WriteLine$Lisp concat ["getShow: ",showarg]
       realarg:=SUBSEQ(showarg,6)$Lisp
       show:=_
        "(progn (setq |$options| '((|operations|))) (|show| '|" realarg "|))"
--       WriteLine$Lisp concat ["getShow: ",show]
       SETQ(SAVESTREAM$Lisp,_*STANDARD_-OUTPUT_*$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,_
             MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       evalresult:=EVAL(READ_-FROM_-STRING(show)$Lisp)$Lisp
       SETQ(evalresult,_
             GET_-OUTPUT_-STREAM_-STRING(_*STANDARD_-OUTPUT_*$Lisp)$Lisp)$Lisp
       SETQ(_*STANDARD_-OUTPUT_*$Lisp,SAVESTREAM$Lisp)$Lisp
       mathml:String:=string(REPLACE_-ENTITIES(evalresult)$Lisp)
       SETQ(tmpalgebra$Lisp, MAKE_-STRING_-OUTPUT_-STREAM()$Lisp)$Lisp
       SETQ(savemathml$Lisp, _$texOutputStream$Lisp)$Lisp
       SETQ(savealgebra$Lisp, _$algebraOutputStream$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,tmpmathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,tmpalgebra$Lisp)$Lisp
       SETQ(resultalgebra$Lisp,_
            GET_-OUTPUT_-STREAM_-STRING(_$algebraOutputStream$Lisp)$Lisp)$Lisp
       SETQ(_$texOutputStream$Lisp,savemathml$Lisp)$Lisp
       SETQ(_$algebraOutputStream$Lisp,savealgebra$Lisp)$Lisp
       CLOSE(tmpalgebra$Lisp)$Lisp
       -- Since strings returned from axiom are going to be displayed in html I
       -- should really check for the characters &,<,> and replace them with
       -- &amp;,&lt;,&gt;.  
       -- At present I only check for ampersands in formatMessages.
       algebra:String := string(resultalgebra$Lisp)
       algebra := formatMessages(algebra)
       -- At this point mathml contains the mathml for the output but does not
       -- include step number or type information.  
       -- We should also save the command.
       -- I get the type and step number from the $internalHistoryTable
       axans:String := _
        concat ["<div class=_"stepnum_">", lastStep(), "</div>_
                 <div class=_"command_">", showarg, "</div>_
                 <div class=_"algebra_">",algebra,"</div>_
                 <div class=_"mathml_">",mathml,"</div>_
                 <div class=_"type_">",lastType(),"</div>"]       
--       WriteLine$Lisp concat ["mathml answer: ",mathml]
       q:=MAKE_-STRING_-INPUT_-STREAM(axans)$Lisp
       SiCopyStream(q,s)$Lisp
       CLOSE(q)$Lisp
       CLOSE(s)$Lisp

@
\subsubsection{lastType}
To examine the \$internalHistoryTable use the following line
\begin{verbatim}
  )lisp |$internalHistoryTable|
\end{verbatim}
We need to pick out first member of internalHistoryTable and then pick out
the element with \% as first element. Here is an example showing just
the first element of the list, which correponds to the last command.

Note that the last command does not necessarily correspond to the last
element of the first element of \$internalHistoryTable as it is in this
example.
\begin{verbatim}
   (
    (4 NIL
    (x (value (BasicOperator) WRAPPED . #<vector 09a93bd0>))
    (y (value (BasicOperator) WRAPPED . #<vector 09a93bb4>))
    (% (value (Matrix (Polynomial (Integer))) WRAPPED . #<vector 0982e0e0>))
    )
   ...
   )
\end{verbatim}

We also need to check for input error in which case the \$internalHistoryTable
is not changed and the type retrieved would be that for the last correct
input.
<<package AXSERV AxiomServer>>=
   lastType():String ==
     SETQ(first$Lisp,FIRST(_$internalHistoryTable$Lisp)$Lisp)$Lisp
     count:Integer := 0
     hisLength:Integer := LIST_-LENGTH(_$internalHistoryTable$Lisp)$Lisp
     length:Integer := LIST_-LENGTH(first$Lisp)$Lisp
     -- This initializes stepSav.  The test is a bit of a hack, maybe I'll
     -- figure out the right way to do it later.
     if string stepSav$Lisp = "#<OBJNULL>" then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     -- If hisLength = 0 then the history table has been reset to NIL
     -- and we're starting numbering over
     if hisLength = 0 then SETQ(stepSav$Lisp, 0$Lisp)$Lisp
     if hisLength > 0 and 
       car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp ^= stepSav$Lisp then
        SETQ(stepSav$Lisp,car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp)$Lisp
        while count < length  repeat
         position(char "%",string FIRST(first$Lisp)$Lisp) = 2 => 
           count := length+1
         count := count +1
         SETQ(first$Lisp,REST(first$Lisp)$Lisp)$Lisp
     count = length + 1 => 
         string SECOND(SECOND(FIRST(first$Lisp)$Lisp)$Lisp)$Lisp
     ""


   lastStep():String ==
       string car(car(_$internalHistoryTable$Lisp)$Lisp)$Lisp

   formatMessages(str:String):String ==
--       WriteLine("formatMessages")$Lisp
       -- I need to replace any ampersands with &amp; and may also need to
       -- replace < and > with &lt; and &gt;
       strlist:List String
--       WriteLine(str)$Lisp
       strlist := split(str,char "&")
       str := ""
       -- oops, if & is the last character in the string this method
       -- will eliminate it.  Need to redo this.
       for s in strlist repeat
           str := concat [str,s,"&amp;"]
       strlen:Integer := #str
       str := str.(1..(#str - 5))
--       WriteLine(str)$Lisp
       -- Here I split the string into lines and put each line in a "div".
       strlist := split(str, char string NewlineChar$Lisp)
       str := ""
--       WriteLine("formatMessages1")$Lisp
--       WriteLine(concat strlist)$Lisp
       for s in strlist repeat
--           WriteLine(s)$Lisp
           str := concat [str,"<div>",s,"</div>"]
       str

   getContentType(pathvar:String):String ==
--       WriteLine("getContentType begin")$Lisp
       -- set default content type
       contentType:String := "text/plain"
       -- need to test for successful match?
       StringMatch(".*\.(.*)$", pathvar)$Lisp
       u:UniversalSegment(Integer)
       u := segment(MatchBeginning(1)$Lisp+1,_
                    MatchEnd(1)$Lisp)$UniversalSegment(Integer)
       extension:String := pathvar.u
--       WriteLine$Lisp concat ["file extension: ",extension]
       -- test for extensions: html, htm, xml, xhtml, js, css
       if extension = "html" then
           contentType:String := "text/html"
       else if extension = "htm" then
           contentType:String := "text/html"
       else if extension = "xml" then
           contentType:String := "text/xml"
       else if extension = "xhtml" then
           contentType:String := "application/xhtml+xml"
       else if extension = "js" then
           contentType:String := "text/javascript"
       else if extension = "css" then
           contentType:String := "text/css"
       else if extension = "png" then
           contentType:String := "image/png"
       else if extension = "jpg" then
           contentType:String := "image/jpeg"
       else if extension = "jpeg" then
           contentType:String := "image/jpeg"
--       WriteLine$Lisp concat ["Content-Type: ",contentType]
--       WriteLine("getContentType end")$Lisp
       contentType

@
<<AXSERV.dotabb>>=
"AXSERV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=AXSERV"]
"STRING" [color="#88FF44",href="bookvol10.3.pdf#nameddest=STRING"]
"AXSERV" -> "STRING"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter B}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BEZOUT BezoutMatrix}
\pagehead{BezoutMatrix}{BEZOUT}
\pagepic{ps/v104bezoutmatrix.ps}{BEZOUT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BEZOUT BezoutMatrix>>=
)abbrev package BEZOUT BezoutMatrix
++ Author: Clifton J. Williamson
++ Date Created: 2 August 1988
++ Date Last Updated: 3 November 1993
++ Basic Operations: bezoutMatrix, bezoutResultant, bezoutDiscriminant
++ Related Domains
++ Also See:
++ AMS Classifiactions:
++ Keywords: Bezout matrix, resultant, discriminant
++ Examples:
++ Reference: Knuth, The Art of Computer Programming, 2nd edition,
++            Vol. 2, p. 619, problem 12.
++ Description:
++   \spadtype{BezoutMatrix} contains functions for computing resultants and
++   discriminants using Bezout matrices.

BezoutMatrix(R,UP,M,Row,Col): Exports == Implementation where
  R    : Ring
  UP   : UnivariatePolynomialCategory R
  Row  : FiniteLinearAggregate R
  Col  : FiniteLinearAggregate R
  M    : MatrixCategory(R,Row,Col)
  I  ==> Integer
  lc ==> leadingCoefficient

  Exports ==> with
    sylvesterMatrix: (UP,UP) -> M
      ++ sylvesterMatrix(p,q) returns the Sylvester matrix for the two
      ++ polynomials p and q.
    bezoutMatrix: (UP,UP) -> M
      ++ bezoutMatrix(p,q) returns the Bezout matrix for the two
      ++ polynomials p and q.

    if R has commutative("*") then
      bezoutResultant: (UP,UP) -> R
       ++ bezoutResultant(p,q) computes the resultant of the two
       ++ polynomials p and q by computing the determinant of a Bezout matrix.

      bezoutDiscriminant: UP -> R
       ++ bezoutDiscriminant(p) computes the discriminant of a polynomial p
       ++ by computing the determinant of a Bezout matrix.

  Implementation ==> add

    sylvesterMatrix(p,q) ==
      n1 := degree p; n2 := degree q; n := n1 + n2
      sylmat : M := new(n,n,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not zero? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        for i in 0..n2 - 1 repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        for i in 0..n1-1 repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      sylmat

    bezoutMatrix(p,q) ==
    -- This function computes the Bezout matrix for 'p' and 'q'.
    -- See Knuth, The Art of Computer Programming, Vol. 2, p. 619, # 12.
    -- One must have deg(p) >= deg(q), so the arguments are reversed
    -- if this is not the case.
      n1 := degree p; n2 := degree q; n := n1 + n2
      n1 < n2 => bezoutMatrix(q,p)
      m1 : I := n1 - 1; m2 : I := n2 - 1; m : I := n - 1
      -- 'sylmat' will be a matrix consisting of the first n1 columns
      -- of the standard Sylvester matrix for 'p' and 'q'
      sylmat : M := new(n,n1,0)
      minR := minRowIndex sylmat; minC := minColIndex sylmat
      maxR := maxRowIndex sylmat; maxC := maxColIndex sylmat
      p0 := p
      -- fill in coefficients of 'p'
      while not ground? p0 repeat
        coef := lc p0; deg := degree p0; p0 := reductum p0
        -- put bk = coef(p,k) in sylmat(minR + i,minC + i + (n1 - k))
        -- for i = 0...
        -- quit when i > m2 or when i + (n1 - k) > m1, whichever happens first
        for i in 0..min(m2,deg - 1) repeat
          qsetelt_!(sylmat,minR + i,minC + n1 - deg + i,coef)
      q0 := q
      -- fill in coefficients of 'q'
      while not zero? q0 repeat
        coef := lc q0; deg := degree q0; q0 := reductum q0
        -- put ak = coef(q,k) in sylmat(minR + n1 + i,minC + i + (n2 - k))
        -- for i = 0...
        -- quit when i > m1 or when i + (n2 - k) > m1, whichever happens first
        -- since n2 - k >= 0, we quit when i + (n2 - k) > m1
        for i in 0..(deg + n1 - n2 - 1) repeat
          qsetelt_!(sylmat,minR + n2 + i,minC + n2 - deg + i,coef)
      -- 'bezmat' will be the 'Bezout matrix' as described in Knuth
      bezmat : M := new(n1,n1,0)
      for i in 0..m2 repeat
        -- replace A_i by (b_0 A_i + ... + b_{n_2-1-i} A_{n_2 - 1}) -
        -- (a_0 B_i + ... + a_{n_2-1-i} B_{n_2-1}), as in Knuth
        bound : I := n2 - i; q0 := q
        while not zero? q0 repeat
          deg := degree q0
          if (deg < bound) then
            -- add b_deg A_{n_2 - deg} to the new A_i
            coef := lc q0
            for k in minC..maxC repeat
              c := coef * qelt(sylmat,minR + m2 - i - deg,k) +
                          qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          q0 := reductum q0
        p0 := p
        while not zero? p0 repeat
          deg := degree p0
          if deg < bound then
            coef := lc p0
            -- subtract a_deg B_{n_2 - deg} from the new A_i
            for k in minC..maxC repeat
              c := -coef * qelt(sylmat,minR + m - i - deg,k) +
                           qelt(bezmat,minR + m2 - i,k)
              qsetelt_!(bezmat,minR + m2 - i,k,c)
          p0 := reductum p0
      for i in n2..m1 repeat for k in minC..maxC repeat
        qsetelt_!(bezmat,minR + i,k,qelt(sylmat,minR + i,k))
      bezmat

    if R has commutative("*") then

      bezoutResultant(f,g) == determinant bezoutMatrix(f,g)

      if R has IntegralDomain then

        bezoutDiscriminant f ==
          degMod4 := (degree f) rem 4
          (degMod4 = 0) or (degMod4 = 1) =>
            (bezoutResultant(f,differentiate f) exquo (lc f)) :: R
          -((bezoutResultant(f,differentiate f) exquo (lc f)) :: R)

        else

          bezoutDiscriminant f ==
            lc f = 1 =>
              degMod4 := (degree f) rem 4
              (degMod4 = 0) or (degMod4 = 1) =>
                bezoutResultant(f,differentiate f)
              -bezoutResultant(f,differentiate f)
            error "bezoutDiscriminant: leading coefficient must be 1"

@
<<BEZOUT.dotabb>>=
"BEZOUT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BEZOUT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BEZOUT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package BRILL BrillhartTests}
\pagehead{BrillhartTests}{BRILL}
\pagepic{ps/v104brillharttests.ps}{BRILL}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package BRILL BrillhartTests>>=
)abbrev package BRILL BrillhartTests
++ Author: Frederic Lehobey, James H. Davenport
++ Date Created: 28 June 1994
++ Date Last Updated: 11 July 1997
++ Basic Operations: brillhartIrreducible?
++ Related Domains: 
++ Also See:
++ AMS Classifications:
++ Keywords: factorization
++ Examples:
++ References:
++ [1] John Brillhart, Note on Irreducibility Testing,
++ Mathematics of Computation, vol. 35, num. 35, Oct. 1980, 1379-1381
++ [2] James Davenport, On Brillhart Irreducibility. To appear.
++ [3] John Brillhart, On the Euler and Bernoulli polynomials,
++ J. Reine Angew. Math., v. 234, (1969), pp. 45-64

BrillhartTests(UP): Exports == Implementation where
  N ==> NonNegativeInteger
  Z ==> Integer
  UP: UnivariatePolynomialCategory Z

  Exports ==> with
    brillhartIrreducible?: UP -> Boolean -- See [1]
      ++ brillhartIrreducible?(p) returns \spad{true} if p can be shown to be
      ++ irreducible by a remark of Brillhart, \spad{false} is inconclusive.
    brillhartIrreducible?: (UP,Boolean) -> Boolean -- See [1]
      ++ brillhartIrreducible?(p,noLinears) returns \spad{true} if p can be 
      ++ shown to be irreducible by a remark of Brillhart, \spad{false} else.
      ++ If noLinears is \spad{true}, we are being told p has no linear factors
      ++ \spad{false} does not mean that p is reducible.
    brillhartTrials: () -> N
      ++ brillhartTrials() returns the number of tests in
      ++ \spadfun{brillhartIrreducible?}.
    brillhartTrials: N -> N
      ++ brillhartTrials(n) sets to n the number of tests in 
      ++ \spadfun{brillhartIrreducible?} and returns the previous value.
    noLinearFactor?: UP -> Boolean -- See [3] p. 47
      ++ noLinearFactor?(p) returns \spad{true} if p can be shown to have no
      ++ linear factor by a theorem of Lehmer, \spad{false} else. I insist on
      ++ the fact that \spad{false} does not mean that p has a linear factor.

  Implementation ==> add

    import GaloisGroupFactorizationUtilities(Z,UP,Float)

    squaredPolynomial(p:UP):Boolean ==
      d := degree p
      d = 0 => true
      odd? d => false
      squaredPolynomial reductum p

    primeEnough?(n:Z,b:Z):Boolean ==
       -- checks if n is prime, with the possible exception of 
       -- factors whose product is at most b
       import Float
       bb: Float := b::Float
       for i in 2..b repeat
           while (d:= n exquo i) case Integer repeat
                 n:=d::Integer
                 bb:=bb / i::Float
                 bb < 1$Float => return false
                 --- we over-divided, so it can't be prime
       prime? n

    brillharttrials: N := 6
    brillhartTrials():N == brillharttrials

    brillhartTrials(n:N):N ==
      (brillharttrials,n) := (n,brillharttrials)
      n

    brillhartIrreducible?(p:UP):Boolean ==
      brillhartIrreducible?(p,noLinearFactor? p)

    brillhartIrreducible?(p:UP,noLinears:Boolean):Boolean == -- See [1]
      zero? brillharttrials => false
      origBound := (largeEnough := rootBound(p)+1)
      -- see remarks 2 and 4
      even0 := even? coefficient(p,0)
      even1 := even? p(1)
      polyx2 := squaredPolynomial(p)
      prime? p(largeEnough) => true
      not polyx2 and prime? p(-largeEnough) => true
--      one? brillharttrials => false
      (brillharttrials = 1) => false
      largeEnough := largeEnough+1
      primeEnough?(p(largeEnough),if noLinears then 4 else 2) => true
      not polyx2 and
       primeEnough?(p(-largeEnough),if noLinears then 4 else 2) => true
      if odd? largeEnough then 
        if even0 then largeEnough := largeEnough+1
      else 
        if even1 then largeEnough := largeEnough+1
      count :=(if polyx2 then 2 else 1)*(brillharttrials-2)+largeEnough
      for i in (largeEnough+1)..count repeat
        small := if noLinears then (i-origBound)**2 else (i-origBound)
        primeEnough?(p(i),small) => return true
        not polyx2 and primeEnough?(p(-i),small) => return true
      false

    noLinearFactor?(p:UP):Boolean ==
      (odd? leadingCoefficient p) and (odd? coefficient(p,0)) and (odd? p(1)) 

@
<<BRILL.dotabb>>=
"BRILL" [color="#FF4488",href="bookvol10.4.pdf#nameddest=BRILL"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"BRILL" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter C}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package CPIMA CharacteristicPolynomialInMonogenicalAlgebra}
\pagehead{CharacteristicPolynomialInMonogenicalAlgebra}{CPIMA}
\pagepic{ps/v104characteristicpolynomialinmonogenicalalgebra.ps}{CPIMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>=
)abbrev package CPIMA CharacteristicPolynomialInMonogenicalAlgebra
++ Author: Claude Quitte
++ Date Created: 10/12/93
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ This package implements characteristicPolynomials for monogenic algebras
++ using resultants
CharacteristicPolynomialInMonogenicalAlgebra(R : CommutativeRing,
    PolR : UnivariatePolynomialCategory(R),
    E : MonogenicAlgebra(R, PolR)): with
     characteristicPolynomial : E -> PolR
	++ characteristicPolynomial(e) returns the characteristic polynomial 
	++ of e using resultants

  == add
    Pol ==> SparseUnivariatePolynomial

    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, Pol(PolR))
    XtoY(Q : PolR) : Pol(PolR) == map(monomial(#1, 0), Q)

    P : Pol(PolR) := XtoY(definingPolynomial()$E)
    X : Pol(PolR) := monomial(monomial(1, 1)$PolR, 0)

    characteristicPolynomial(x : E) : PolR ==
       Qx : PolR := lift(x)
       -- on utilise le fait que resultant_Y (P(Y), X - Qx(Y))
       return resultant(P, X - XtoY(Qx))

@
<<CPIMA.dotabb>>=
"CPIMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=CPIMA"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter E}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter F}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FLAGG2 FiniteLinearAggregateFunctions2}
\pagehead{FiniteLinearAggregateFunctions2}{FLAGG2}
\pagepic{ps/v104finitelinearaggregatefunctions2.ps}{FLAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FLAGG2 FiniteLinearAggregateFunctions2>>=
)abbrev package FLAGG2 FiniteLinearAggregateFunctions2
--% FiniteLinearAggregateFunctions2

++ Author: ???
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ FiniteLinearAggregateFunctions2 provides functions involving two
++ FiniteLinearAggregates where the underlying domains might be
++ different. An example of this might be creating a list of rational
++ numbers by mapping a function across a list of integers where the
++ function divides each integer by 1000.

FiniteLinearAggregateFunctions2(S, A, R, B):
 Exports == Implementation where
  S, R: Type
  A   : FiniteLinearAggregate S
  B   : FiniteLinearAggregate R

  Exports ==> with
    map    : (S -> R, A) -> B          
     ++ map(f,a) applies function f to each member of aggregate
     ++ \spad{a} resulting in a new aggregate over a
     ++ possibly different underlying domain.
    reduce : ((S, R) -> R, A, R) -> R  
     ++ reduce(f,a,r) applies function f to each
     ++ successive element of the
     ++ aggregate \spad{a} and an accumulant initialized to r.
     ++ For example,
     ++ \spad{reduce(_+$Integer,[1,2,3],0)}
     ++ does \spad{3+(2+(1+0))}. Note: third argument r
     ++ may be regarded as the
     ++ identity element for the function f.
    scan   : ((S, R) -> R, A, R) -> B  
     ++ scan(f,a,r) successively applies
     ++ \spad{reduce(f,x,r)} to more and more leading sub-aggregates
     ++ x of aggregrate \spad{a}.
     ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
     ++ \spad{scan(f,a,r)} returns
     ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
  Implementation ==> add
    if A has ListAggregate(S) then         -- A is a list-oid
      reduce(fn, l, ident) ==
        empty? l => ident
        reduce(fn, rest l, fn(first l, ident))

      if B has ListAggregate(R) or not(B has shallowlyMutable) then
        -- A is a list-oid, and B is either list-oids or not mutable
        map(f, l) == construct [f s for s in entries l]

        scan(fn, l, ident) ==
          empty? l => empty()
          val := fn(first l, ident)
          concat(val, scan(fn, rest l, val))

      else                      -- A is a list-oid, B a mutable array-oid
        map(f, l) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          for a in entries l repeat (qsetelt_!(w, i, f a); i := inc i)
          w

        scan(fn, l, ident) ==
          i := minIndex(w := new(#l,NIL$Lisp)$B)
          vl := ident
          for a in entries l repeat
            vl := qsetelt_!(w, i, fn(a, vl))
            i := inc i
          w

    else                              -- A is an array-oid
      reduce(fn, v, ident) ==
        val := ident
        for i in minIndex v .. maxIndex v repeat
          val := fn(qelt(v, i), val)
        val

      if B has ListAggregate(R) then   -- A is an array-oid, B a list-oid
        map(f, v) ==
          construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

        scan(fn, v, ident) ==
          w := empty()$B
          for i in minIndex v .. maxIndex v repeat
            ident := fn(qelt(v, i), ident)
            w := concat(ident, w)
          reverse_! w

      else                             -- A and B are array-oid's
        if B has shallowlyMutable then -- B is also mutable
          map(f, v) ==
            w := new(#v,NIL$Lisp)$B
            for i in minIndex w .. maxIndex w repeat
              qsetelt_!(w, i, f qelt(v, i))
            w

          scan(fn, v, ident) ==
            w   := new(#v,NIL$Lisp)$B
            vl := ident
            for i in minIndex v .. maxIndex v repeat
              vl := qsetelt_!(w, i, fn(qelt(v, i), vl))
            w

        else                                   -- B non mutable array-oid
          map(f, v) ==
            construct [f qelt(v, i) for i in minIndex v .. maxIndex v]

          scan(fn, v, ident) ==
            w := empty()$B
            for i in minIndex v .. maxIndex v repeat
              ident := fn(qelt(v, i), ident)
              w := concat(w, ident)
            w

@
<<FLAGG2.dotabb>>=
"FLAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FLAGG2"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"FLAGG2" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package FSAGG2 FiniteSetAggregateFunctions2}
\pagehead{FiniteSetAggregateFunctions2}{FSAGG2}
\pagepic{ps/v104finitesetaggregatefunctions2.ps}{FSAGG2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package FSAGG2 FiniteSetAggregateFunctions2>>=
)abbrev package FSAGG2 FiniteSetAggregateFunctions2

--% FiniteSetAggregateFunctions2

++ Author: Robert S. Sutor
++ Date Created: 15 May 1990
++ Date Last Updated: 14 Oct 1993
++ Description:
++ FiniteSetAggregateFunctions2 provides functions involving two
++ finite set aggregates where the underlying domains might be
++ different. An example of this is to create a set of rational
++ numbers by mapping a function across a set of integers, where the
++ function divides each integer by 1000.

FiniteSetAggregateFunctions2(S, A, R, B): Exports == Implementation where
   S, R: SetCategory
   A   : FiniteSetAggregate S
   B   : FiniteSetAggregate R

   Exports ==> with
     map    : (S -> R, A) -> B          
      ++ map(f,a) applies function f to each member of
      ++ aggregate \spad{a}, creating a new aggregate with
      ++ a possibly different underlying domain.
     reduce : ((S, R) -> R, A, R) -> R  
      ++ reduce(f,a,r) applies function f to each
      ++ successive element of the aggregate \spad{a} and an
      ++ accumulant initialised to r.
      ++ For example,
      ++ \spad{reduce(_+$Integer,[1,2,3],0)}
      ++ does a \spad{3+(2+(1+0))}.
      ++ Note: third argument r may be regarded
      ++ as an identity element for the function.
     scan   : ((S, R) -> R, A, R) -> B  
      ++ scan(f,a,r) successively applies \spad{reduce(f,x,r)}
      ++ to more and more leading sub-aggregates x of
      ++ aggregate \spad{a}.
      ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
      ++ \spad{scan(f,a,r)} returns
      ++ \spad {[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
   Implementation ==> add
     map(fn, a) ==
       set(map(fn, parts a)$ListFunctions2(S, R))$B
     reduce(fn, a, ident) ==
       reduce(fn, parts a, ident)$ListFunctions2(S, R)
     scan(fn, a, ident) ==
       set(scan(fn, parts a, ident)$ListFunctions2(S, R))$B

@
<<FSAGG2.dotabb>>=
"FSAGG2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=FSAGG2"]
"FSAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FSAGG"]
"FSAGG2" -> "FSAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter G}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package GENMFACT GeneralizedMultivariateFactorize}
\pagehead{GeneralizedMultivariateFactorize}{GENMFACT}
\pagepic{ps/v104generalizedmultivariatefactorize.ps}{GENMFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package GENMFACT GeneralizedMultivariateFactorize>>=
)abbrev package GENMFACT GeneralizedMultivariateFactorize
++ Author: P. Gianni
++ Date Created: 1983
++ Date Last Updated: Sept. 1990
++ Basic Functions:
++ Related Constructors: MultFiniteFactorize, AlgebraicMultFact, MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++   This is the top level package for doing multivariate factorization
++ over basic domains like \spadtype{Integer} or \spadtype{Fraction Integer}.

GeneralizedMultivariateFactorize(OV,E,S,R,P) : C == T
 where
  R          :   IntegralDomain
                    -- with factor on R[x]
  S          :   IntegralDomain
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  E          :   OrderedAbelianMonoidSup
  P          :   PolynomialCategory(R,E,OV)

  C == with
    factor      :      P  ->  Factored P
      ++ factor(p) factors the multivariate polynomial p over its coefficient
      ++ domain

  T == add
    factor(p:P) : Factored P ==
      R has FiniteFieldCategory => factor(p)$MultFiniteFactorize(OV,E,R,P)
      R is Polynomial(S) and S has EuclideanDomain =>
         factor(p)$MPolyCatPolyFactorizer(E,OV,S,P)
      R is Fraction(S) and S has CharacteristicZero and 
        S has EuclideanDomain =>
            factor(p)$MRationalFactorize(E,OV,S,P)
      R is Fraction Polynomial S =>
         factor(p)$MPolyCatRationalFunctionFactorizer(E,OV,S,P)
      R has CharacteristicZero and R has EuclideanDomain =>
               factor(p)$MultivariateFactorize(OV,E,R,P)
      squareFree p

@
<<GENMFACT.dotabb>>=
"GENMFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=GENMFACT"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"GENMFACT" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter H}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter I}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package IALGFACT InnerAlgFactor}
\pagehead{InnerAlgFactor}{IALGFACT}
\pagepic{ps/v104inneralgfactor.ps}{IALGFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package IALGFACT InnerAlgFactor>>=
)abbrev package IALGFACT InnerAlgFactor
++ Factorisation in a simple algebraic extension
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: 20 Jul 1988
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of a field over which we can factor UP's;
++ Keywords: factorization, algebraic extension, univariate polynomial

InnerAlgFactor(F, UP, AlExt, AlPol): Exports == Implementation where
  F    : Field
  UP   : UnivariatePolynomialCategory F
  AlPol: UnivariatePolynomialCategory AlExt
  AlExt : Join(Field, CharacteristicZero, MonogenicAlgebra(F,UP))
  NUP   ==> SparseUnivariatePolynomial UP
  N     ==> NonNegativeInteger
  Z     ==> Integer
  FR    ==> Factored UP
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2


  Exports ==> with
    factor: (AlPol, UP -> FR)  ->  Factored AlPol
      ++ factor(p, f) returns a prime factorisation of p;
      ++ f is a factorisation map for elements of UP;
 
  Implementation ==> add
    pnorm        : AlPol -> UP
    convrt       : AlPol -> NUP
    change       : UP    -> AlPol
    perturbfactor: (AlPol, Z, UP -> FR) -> List AlPol
    irrfactor    : (AlPol, Z, UP -> FR) -> List AlPol
 
 
    perturbfactor(f, k, fact) ==
      pol   := monomial(1$AlExt,1)-
               monomial(reduce monomial(k::F,1)$UP ,0)
      newf  := elt(f, pol)
      lsols := irrfactor(newf, k, fact)
      pol   := monomial(1, 1) +
               monomial(reduce monomial(k::F,1)$UP,0)
      [elt(pp, pol) for pp in lsols]
 
    ---  factorize the square-free parts of f  ---
    irrfactor(f, k, fact) ==
      degree(f) =$N 1 => [f]
      newf := f
      nn   := pnorm f
      --newval:RN:=1
      --pert:=false
      --if ^ SqFr? nn then
      --  pert:=true
      --  newterm:=perturb(f)
      --  newf:=newterm.ppol
      --  newval:=newterm.pval
      --  nn:=newterm.nnorm
      listfact := factors fact nn
      #listfact =$N 1 =>
        first(listfact).exponent =$Z 1 => [f]
        perturbfactor(f, k + 1, fact)
      listerm:List(AlPol):= []
      for pelt in listfact repeat
        g    := gcd(change(pelt.factor), newf)
        newf := (newf exquo g)::AlPol
        listerm :=
          pelt.exponent =$Z 1 => cons(g, listerm)
          append(perturbfactor(g, k + 1, fact), listerm)
      listerm
 
    factor(f, fact) ==
      sqf := squareFree f
      unit(sqf) * _*/[_*/[primeFactor(pol, sqterm.exponent)
                          for pol in irrfactor(sqterm.factor, 0, fact)]
                                            for sqterm in factors sqf]
 
    p := definingPolynomial()$AlExt
    newp := map(#1::UP, p)$UPCF2(F, UP, UP, NUP)
 
    pnorm  q == resultant(convrt q, newp)
    change q == map(coerce, q)$UPCF2(F,UP,AlExt,AlPol)
 
    convrt q ==
      swap(map(lift, q)$UPCF2(AlExt, AlPol,
           UP, NUP))$CommuteUnivariatePolynomialCategory(F, UP, NUP)

@
<<IALGFACT.dotabb>>=
"IALGFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=IALGFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter J}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter K}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter L}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter M}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MTHING MergeThing}
\pagehead{MergeThing}{MTHING}
\pagepic{ps/v104mergething.ps}{MTHING}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MTHING MergeThing>>=
)abbrev package MTHING MergeThing
++ This package exports tools for merging lists
MergeThing(S:OrderedSet): Exports == Implementation where
  Exports == with
    mergeDifference: (List(S),List(S)) -> List(S)
	++ mergeDifference(l1,l2) returns a list of elements in l1 not present
	++ in l2. Assumes lists are ordered and all x in l2 are also in l1.
  Implementation == add
    mergeDifference1: (List S,S,List S) -> List S
    mergeDifference(x,y) == 
      null x or null y => x
      mergeDifference1(x,y.first,y.rest)
      x.first=y.first => x.rest
      x
    mergeDifference1(x,fy,ry) ==  
      rx := x
      while not null rx repeat
        rx := rx.rest
        frx := rx.first
        while fy < frx repeat
          null ry => return x
          fy := first ry
          ry := rest ry
        frx = fy =>
          x.rest := rx.rest
          null ry => return x
          fy := ry.first
          ry := ry.rest
        x := rx

@
<<MTHING.dotabb>>=
"MTHING" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MTHING"]
"FLAGG" [color="#4488FF",href="bookvol10.2.pdf#nameddest=FLAGG"]
"MTHING" -> "FLAGG"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPCPF MPolyCatPolyFactorizer}
\pagehead{MPolyCatPolyFactorizer}{MPCPF}
\pagepic{ps/v104mpolycatpolyfactorizer.ps}{MPCPF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPCPF MPolyCatPolyFactorizer>>=
)abbrev package MPCPF MPolyCatPolyFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are polynomials over
++ some ring R over which we can factor. It is used internally by packages
++ such as the solve package which need to work with polynomials in a specific
++ set of variables with coefficients which are polynomials in all the other
++ variables.

MPolyCatPolyFactorizer(E,OV,R,PPR) : C == T
 where
  R     :   EuclideanDomain
  E     :   OrderedAbelianMonoidSup
    -- following type is required by PushVariables
  OV    :   OrderedSet  with  
                 convert : % -> Symbol
                   ++ convert(x) converts x to a symbol
                 variable: Symbol -> Union(%, "failed")
                   ++ variable(s) makes an element from symbol s or fails.
  PR    ==> Polynomial R
  PPR   :   PolynomialCategory(PR,E,OV)
  NNI   ==> NonNegativeInteger
  ISY   ==> IndexedExponents Symbol
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial PR
  UPPR  ==> SparseUnivariatePolynomial PPR

  C  == with
     factor      :        PPR             ->   Factored PPR
       ++ factor(p) factors a polynomial with polynomial
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

     import PushVariables(R,E,OV,PPR)

        ----  factorization of p ----
     factor(p:PPR) : Factored PPR ==
       ground? p => nilFactor(p,1)
       c := content p
       p := (p exquo c)::PPR
       vars:List OV :=variables p
       g:PR:=retract pushdown(p, vars)
       flist := factor(g)$GeneralizedMultivariateFactorize(Symbol,ISY,R,R,PR)
       ffact : List(Record(irr:PPR,pow:Integer))
       ffact:=[[pushup(u.factor::PPR,vars),u.exponent] for u in factors flist]
       fcont:=(unit flist)::PPR
       nilFactor(c*fcont,1)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])

@
<<MPCPF.dotabb>>=
"MPCPF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPCPF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPCPF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MPRFF MPolyCatRationalFunctionFactorizer}
\pagehead{MPolyCatRationalFunctionFactorizer}{MPRFF}
\pagepic{ps/v104mpolycatrationalfunctionfactorizer.ps}{MPRFF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MPRFF MPolyCatRationalFunctionFactorizer>>=
)abbrev package MPRFF MPolyCatRationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++    This package exports a factor operation for multivariate polynomials
++ with coefficients which are rational functions over
++ some ring R over which we can factor. It is used internally by packages
++ such as primary decomposition which need to work with polynomials
++ with rational function coefficients, i.e. themselves fractions of
++ polynomials.

MPolyCatRationalFunctionFactorizer(E,OV,R,PRF) : C == T
 where
  R     :   IntegralDomain
  F     ==> Fraction Polynomial R
  RN    ==> Fraction Integer
  E     :   OrderedAbelianMonoidSup
  OV    :   OrderedSet  with 
                convert : % -> Symbol
                  ++ convert(x) converts x to a symbol
  PRF   :   PolynomialCategory(F,E,OV)
  NNI   ==> NonNegativeInteger
  P     ==> Polynomial R
  ISE   ==> IndexedExponents  SE
  SE    ==> Symbol
  UP    ==> SparseUnivariatePolynomial P
  UF    ==> SparseUnivariatePolynomial F
  UPRF  ==> SparseUnivariatePolynomial PRF
  QuoForm   ==> Record(sup:P,inf:P)

  C  == with
     totalfract  :        PRF             ->   QuoForm
       ++ totalfract(prf) takes a polynomial whose coefficients are
       ++ themselves fractions of polynomials and returns a record
       ++ containing the numerator and denominator resulting from
       ++ putting prf over a common denominator.
     pushdown    :      (PRF,OV)          ->   PRF
       ++ pushdown(prf,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the polynomial prf.
     pushdterm   :      (UPRF,OV)         ->   PRF
       ++ pushdterm(monom,var) pushes all top level occurences of the
       ++ variable var into the coefficient domain for the monomial monom.
     pushup      :      (PRF,OV)          ->   PRF
       ++ pushup(prf,var) raises all occurences of the
       ++ variable var in the coefficients of the polynomial prf
       ++ back to the polynomial level.
     pushucoef   :       (UP,OV)          ->   PRF
       ++ pushucoef(upoly,var) converts the anonymous univariate
       ++ polynomial upoly to a polynomial in var over rational functions.
     pushuconst  :        (F,OV)          ->   PRF
       ++ pushuconst(r,var) takes a rational function and raises
       ++ all occurances of the variable var to the polynomial level.
     factor      :        PRF             ->   Factored PRF
       ++ factor(prf) factors a polynomial with rational function
       ++ coefficients.

             ---  Local Functions  ----
  T  == add

        ----  factorization of p ----
     factor(p:PRF) : Factored PRF ==
       truelist:List OV :=variables p
       tp:=totalfract(p)
       nump:P:= tp.sup
       denp:F:=inv(tp.inf ::F)
       ffact : List(Record(irr:PRF,pow:Integer))
       flist:Factored P
       if R is Fraction Integer then
         flist:=
           ((factor nump)$MRationalFactorize(ISE,SE,Integer,P))
                          pretend (Factored P)
       else
         if R has FiniteFieldCategory  then
            flist:= ((factor nump)$MultFiniteFactorize(SE,ISE,R,P))
                    pretend (Factored P)

         else
            if R has Field then error "not done yet"

            else
              if R has CharacteristicZero then 
                flist:= ((factor nump)$MultivariateFactorize(SE,ISE,R,P))
                                                pretend (Factored P)
              else error "can't happen"  
       ffact:=[[u.factor::F::PRF,u.exponent] for u in factors flist]
       fcont:=(unit flist)::F::PRF
       for x in truelist repeat
         fcont:=pushup(fcont,x)
         ffact:=[[pushup(ff.irr,x),ff.pow] for ff in ffact]
       (denp*fcont)*(_*/[primeFactor(ff.irr,ff.pow) for ff in ffact])


-- the following functions are used to "push" x in the coefficient ring -

        ----  push x in the coefficient domain for a polynomial ----
     pushdown(g:PRF,x:OV) : PRF ==
       ground? g => g
       rf:PRF:=0$PRF
       ug:=univariate(g,x)
       while ug^=0 repeat
         rf:=rf+pushdterm(ug,x)
         ug := reductum ug
       rf

      ----  push x in the coefficient domain for a term ----
     pushdterm(t:UPRF,x:OV):PRF ==
       n:=degree(t)
       cf:=monomial(1,convert x,n)$P :: F
       cf * leadingCoefficient t

               ----  push back the variable  ----
     pushup(f:PRF,x:OV) :PRF ==
       ground? f => pushuconst(retract f,x)
       v:=mainVariable(f)::OV
       g:=univariate(f,v)
       multivariate(map(pushup(#1,x),g),v)

      ----  push x back from the coefficient domain ----
     pushuconst(r:F,x:OV):PRF ==
       xs:SE:=convert x
       degree(denom r,xs)>0 => error "bad polynomial form"
       inv((denom r)::F)*pushucoef(univariate(numer r,xs),x)


     pushucoef(c:UP,x:OV):PRF ==
       c = 0 => 0
       monomial((leadingCoefficient c)::F::PRF,x,degree c) +
                 pushucoef(reductum c,x)


           ----  write p with a common denominator  ----

     totalfract(p:PRF) : QuoForm ==
       p=0 => [0$P,1$P]$QuoForm
       for x in variables p repeat p:=pushdown(p,x)
       g:F:=retract p
       [numer g,denom g]$QuoForm

@
<<MPRFF.dotabb>>=
"MPRFF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MPRFF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"MPRFF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package MRATFAC MRationalFactorize}
\pagehead{MRationalFactorize}{MRATFAC}
\pagepic{ps/v104mrationalfactorize.ps}{MRATFAC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package MRATFAC MRationalFactorize>>=
)abbrev package MRATFAC MRationalFactorize
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated:
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  MRationalFactorize contains the factor function for multivariate
++ polynomials over the quotient field of a ring R such that the package
++ MultivariateFactorize can factor multivariate polynomials over R.


MRationalFactorize(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   Join(EuclideanDomain, CharacteristicZero)  -- with factor over R[x]
  FR  ==> Fraction R
  P  :    PolynomialCategory(FR,E,OV)
  MPR ==> SparseMultivariatePolynomial(R,OV)
  SUP ==> SparseUnivariatePolynomial

  C  == with
     factor      : P   ->  Factored P
       ++ factor(p) factors the multivariate polynomial p with coefficients
       ++ which are fractions of elements of R.

  T  == add
     IE     ==> IndexedExponents OV
     PCLFRR ==> PolynomialCategoryLifting(E,OV,FR,P,MPR)
     PCLRFR ==> PolynomialCategoryLifting(IE,OV,R,MPR,P)
     MFACT  ==> MultivariateFactorize(OV,IE,R,MPR)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     numer1(c:FR): MPR   == (numer c) :: MPR
     numer2(pol:P) : MPR == map(coerce,numer1,pol)$PCLFRR
     coerce1(d:R) : P == (d::FR)::P
     coerce2(pp:MPR) :P == map(coerce,coerce1,pp)$PCLRFR 

     factor(p:P) : Factored P ==
       pden:R:=lcm([denom c for c in coefficients p])
       pol :P:= (pden::FR)*p
       ipol:MPR:= map(coerce,numer1,pol)$PCLFRR
       ffact:=(factor ipol)$MFACT
       (1/pden)*map(coerce,coerce1,(unit ffact))$PCLRFR *
           _*/[primeFactor(map(coerce,coerce1,u.factor)$PCLRFR,
                           u.exponent) for u in factors ffact]

@
<<MRATFAC.dotabb>>=
"MRATFAC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=MRATFAC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter N}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NONE1 NoneFunctions1}
\pagehead{NoneFunctions1}{NONE1}
\pagepic{ps/v104nonefunctions1.ps}{NONE1}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NONE1 NoneFunctions1>>=
)abbrev package NONE1 NoneFunctions1
++ Author:
++ Date Created:
++ Change History:
++ Basic Functions: coerce
++ Related Constructors: None
++ Also See:
++ AMS Classification:
++ Keywords:
++ Description:
++   \spadtype{NoneFunctions1} implements functions on \spadtype{None}.
++   It particular it includes a particulary dangerous coercion from
++   any other type to \spadtype{None}.

NoneFunctions1(S:Type): Exports == Implementation where
  Exports ==> with
    coerce: S -> None
      ++ coerce(x) changes \spad{x} into an object of type
      ++ \spadtype{None}.

  Implementation ==> add
    coerce(s:S):None == s pretend None

@
<<NONE1.dotabb>>=
"NONE1" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NONE1"]
"TYPE" [color="#4488FF",href="bookvol10.2.pdf#nameddest=TYPE"]
"NONE1" -> "TYPE"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package NORMMA NormInMonogenicAlgebra}
\pagehead{NormInMonogenicAlgebra}{NORMMA}
\pagepic{ps/v104norminmonogenicalgebra.ps}{NORMMA}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package NORMMA NormInMonogenicAlgebra>>=
)abbrev package NORMMA NormInMonogenicAlgebra
++ Author: Manuel Bronstein
++ Date Created: 23 February 1995
++ Date Last Updated: 23 February 1995
++ Basic Functions: norm
++ Description:
++ This package implements the norm of a polynomial with coefficients
++ in a monogenic algebra (using resultants)

NormInMonogenicAlgebra(R, PolR, E, PolE): Exports == Implementation where
  R: GcdDomain
  PolR: UnivariatePolynomialCategory R
  E: MonogenicAlgebra(R, PolR)
  PolE: UnivariatePolynomialCategory E

  SUP ==> SparseUnivariatePolynomial

  Exports ==> with
    norm: PolE -> PolR
      ++ norm q returns the norm of q,
      ++ i.e. the product of all the conjugates of q.

  Implementation ==> add
    import UnivariatePolynomialCategoryFunctions2(R, PolR, PolR, SUP PolR)

    PolR2SUP: PolR -> SUP PolR
    PolR2SUP q == map(#1::PolR, q)

    defpol := PolR2SUP(definingPolynomial()$E)

    norm q ==
      p:SUP PolR := 0
      while q ~= 0 repeat
        p := p + monomial(1,degree q)$PolR * PolR2SUP lift leadingCoefficient q
        q := reductum q
      primitivePart resultant(p, defpol)

@
<<NORMMA.dotabb>>=
"NORMMA" [color="#FF4488",href="bookvol10.4.pdf#nameddest=NORMMA"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter O}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package ARRAY12 OneDimensionalArrayFunctions2}
\pagehead{OneDimensionalArrayFunctions2}{ARRAY12}
\pagepic{ps/v104onedimensionalarrayfunctions2.ps}{ARRAY12}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package ARRAY12 OneDimensionalArrayFunctions2>>=
)abbrev package ARRAY12 OneDimensionalArrayFunctions2
++ This package provides tools for operating on one-dimensional arrays
++ with unary and binary functions involving different underlying types
OneDimensionalArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> OneDimensionalArray A
  VB ==> OneDimensionalArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)

  Exports ==> with
   scan   : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of one-dimensional array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1

   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ one-dimensional array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of one-dimensional array
    ++ \spad{a} resulting in a new one-dimensional array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=OneDimensionalArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<ARRAY12.dotabb>>=
"ARRAY12" [color="#FF4488",href="bookvol10.4.pdf#nameddest=ARRAY12"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package OPQUERY OperationsQuery}
\pagehead{OperationsQuery}{OPQUERY}
\pagepic{ps/v104operationsquery.ps}{OPQUERY}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package OPQUERY OperationsQuery>>=
)abbrev package OPQUERY OperationsQuery
++ This package exports tools to create AXIOM Library information databases.
OperationsQuery(): Exports == Implementation where
  Exports == with
    getDatabase: String -> Database(IndexCard)
      ++ getDatabase("char") returns a list of appropriate entries in the
      ++ browser database.  The legal values for "char" are "o" (operations),
      ++ "k" (constructors), "d" (domains), "c" (categories) or "p" (packages).
  Implementation == add
    getDatabase(s) == getBrowseDatabase(s)$Lisp

@
<<OPQUERY.dotabb>>=
"OPQUERY" [color="#FF4488",href="bookvol10.4.pdf#nameddest=OPQUERY"]
"ORDSET" [color="#4488FF",href="bookvol10.2.pdf#nameddest=ORDSET"]
"OPQUERY" -> "ORDSET"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter P}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package PRIMARR2 PrimitiveArrayFunctions2}
\pagehead{PrimitiveArrayFunctions2}{PRIMARR2}
\pagepic{ps/v104primitivearrayfunctions2.ps}{PRIMARR2}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package PRIMARR2 PrimitiveArrayFunctions2>>=
)abbrev package PRIMARR2 PrimitiveArrayFunctions2
++ This package provides tools for operating on primitive arrays
++ with unary and binary functions involving different underlying types
PrimitiveArrayFunctions2(A, B): Exports == Implementation where
  A, B: Type

  VA ==> PrimitiveArray A
  VB ==> PrimitiveArray B
  O2 ==> FiniteLinearAggregateFunctions2(A, VA, B, VB)
  Exports ==> with
   scan : ((A, B) -> B, VA, B) -> VB
    ++ scan(f,a,r) successively applies
    ++ \spad{reduce(f,x,r)} to more and more leading sub-arrays
    ++ x of primitive array \spad{a}.
    ++ More precisely, if \spad{a} is \spad{[a1,a2,...]}, then
    ++ \spad{scan(f,a,r)} returns
    ++ \spad{[reduce(f,[a1],r),reduce(f,[a1,a2],r),...]}.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X scan(adder,[i for i in 1..10],0)$T1
   
   reduce : ((A, B) -> B, VA, B) -> B
    ++ reduce(f,a,r) applies function f to each
    ++ successive element of the
    ++ primitive array \spad{a} and an accumulant initialized to r.
    ++ For example, \spad{reduce(_+$Integer,[1,2,3],0)}
    ++ does \spad{3+(2+(1+0))}. Note: third argument r
    ++ may be regarded as the identity element for the function f.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X adder(a:Integer,b:Integer):Integer == a+b
    ++X reduce(adder,[i for i in 1..10],0)$T1

   map : (A -> B, VA) -> VB
    ++ map(f,a) applies function f to each member of primitive array
    ++ \spad{a} resulting in a new primitive array over a
    ++ possibly different underlying domain.
    ++
    ++X T1:=PrimitiveArrayFunctions2(Integer,Integer)
    ++X map(x+->x+2,[i for i in 1..10])$T1

  Implementation ==> add
    map(f, v)       == map(f, v)$O2
    scan(f, v, b)   == scan(f, v, b)$O2
    reduce(f, v, b) == reduce(f, v, b)$O2

@
<<PRIMARR2.dotabb>>=
"PRIMARR2" [color="#FF4488",href="bookvol10.4.pdf#nameddest=PRIMARR2"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Q}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter R}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACT RationalFunctionFactor}
\pagehead{RationalFunctionFactor}{RFFACT}
\pagepic{ps/v104rationalfunctionfactor.ps}{RFFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACT RationalFunctionFactor>>=
)abbrev package RFFACT RationalFunctionFactor
++ Factorisation in UP FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients which
++ are rational functions with integer coefficients.

RationalFunctionFactor(UP): Exports == Implementation where
  UP: UnivariatePolynomialCategory Fraction Polynomial Integer
 
  SE ==> Symbol
  P  ==> Polynomial Integer
  RF ==> Fraction P
  UPCF2 ==> UnivariatePolynomialCategoryFunctions2
 
  Exports ==> with
    factor: UP -> Factored UP
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    likuniv: (P, SE, P) -> UP
 
    dummy := new()$SE
 
    likuniv(p, x, d) ==
      map(#1 / d, univariate(p, x))$UPCF2(P,SparseUnivariatePolynomial P,
                                          RF, UP)
 
    factor p ==
      d  := denom(q := elt(p,dummy::P :: RF))
      map(likuniv(#1,dummy,d),
          factor(numer q)$MultivariateFactorize(SE,
               IndexedExponents SE,Integer,P))$FactoredFunctions2(P, UP)

@
<<RFFACT.dotabb>>=
"RFFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package RFFACTOR RationalFunctionFactorizer}
\pagehead{RationalFunctionFactorizer}{RFFACTOR}
\pagepic{ps/v104rationalfunctionfactorizer.ps}{RFFACTOR}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package RFFACTOR RationalFunctionFactorizer>>=
)abbrev package RFFACTOR RationalFunctionFactorizer
++ Author: P. Gianni
++ Date Created:
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: Fraction, Polynomial
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:
++ \spadtype{RationalFunctionFactorizer} contains the factor function
++ (called factorFraction) which factors fractions of polynomials by factoring
++ the numerator and denominator. Since any non zero fraction is a unit
++ the usual factor operation will just return the original fraction.

RationalFunctionFactorizer(R) : C == T
 where
  R  :    EuclideanDomain  -- R with factor for R[X]
  P  ==>  Polynomial R
  FP ==>  Fraction P
  SE ==>  Symbol

  C  == with
     factorFraction    : FP  ->   Fraction Factored(P)
       ++ factorFraction(r) factors the numerator and the denominator of
       ++ the polynomial fraction r.
  T  == add

     factorFraction(p:FP) : Fraction Factored(P) ==
       R is Fraction Integer =>
         MR:=MRationalFactorize(IndexedExponents SE,SE,
                                Integer,P)
         (factor(numer p)$MR)/ (factor(denom p)$MR)

       R has FiniteFieldCategory =>
         FF:=MultFiniteFactorize(SE,IndexedExponents SE,R,P)
         (factor(numer p))$FF/(factor(denom p))$FF

       R has CharacteristicZero =>
          MFF:=MultivariateFactorize(SE,IndexedExponents SE,R,P)
          (factor(numer p))$MFF/(factor(denom p))$MFF
       error "case not handled"

@
<<RFFACTOR.dotabb>>=
"RFFACTOR" [color="#FF4488",href="bookvol10.4.pdf#nameddest=RFFACTOR"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"RFFACTOR" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package REALSOLV RealSolvePackage}
<<RealSolvePackage.input>>=
-- acplot.spad.pamphlet RealSolvePackage.input
)spool RealSolvePackage.output
)set message test on
)set message auto off
)clear all
--S 1 of 13
p := 4*x^3 - 3*x^2 + 2*x - 4
--R 
--R
--R          3     2
--R   (1)  4x  - 3x  + 2x - 4
--R                                                     Type: Polynomial Integer
--E 1

--S 2 of 13
ans1 := solve(p,0.01)$REALSOLV
--R 
--R
--R   (2)  [1.11328125]
--R                                                             Type: List Float
--E 2

--S 3 of 13
ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV
--R 
--R
--R   (3)  [1.11328125]
--R                                                             Type: List Float
--E 3

--S 4 of 13
R := Integer
--R 
--R
--R   (4)  Integer
--R                                                                 Type: Domain
--E 4

--S 5 of 13
ls : List Symbol := [x,y,z,t]
--R 
--R
--R   (5)  [x,y,z,t]
--R                                                            Type: List Symbol
--E 5

--S 6 of 13
ls2 : List Symbol := [x,y,z,t,new()$Symbol]
--R 
--R
--R   (6)  [x,y,z,t,%A]
--R                                                            Type: List Symbol
--E 6

--S 7 of 13
pack := ZDSOLVE(R,ls,ls2)
--R 
--R
--R   (7)  ZeroDimensionalSolvePackage(Integer,[x,y,z,t],[x,y,z,t,%A])
--R                                                                 Type: Domain
--E 7

--S 8 of 13
p1 := x**2*y*z + y*z
--R 
--R
--R          2
--R   (8)  (x  + 1)y z
--R                                                     Type: Polynomial Integer
--E 8

--S 9 of 13
p2 := x**2*y**2*z + x + z
--R 
--R
--R          2 2
--R   (9)  (x y  + 1)z + x
--R                                                     Type: Polynomial Integer
--E 9

--S 10 of 13
p3 := x**2*y**2*z**2 +  z + 1
--R 
--R
--R          2 2 2
--R   (10)  x y z  + z + 1
--R                                                     Type: Polynomial Integer
--E 10

--S 11 of 13
lp := [p1, p2, p3]
--R 
--R
--R            2           2 2            2 2 2
--R   (11)  [(x  + 1)y z,(x y  + 1)z + x,x y z  + z + 1]
--R                                                Type: List Polynomial Integer
--E 11

--S 12 of 13
lsv:List(Symbol):=[x,y,z]
--R 
--R
--R   (12)  [x,y,z]
--R                                                            Type: List Symbol
--E 12

--S 13 of 13
ans3 := realSolve(lp,lsv,0.01)$REALSOLV
--R 
--R
--R   (13)  [[1.0,0.0,- 1.0]]
--R                                                        Type: List List Float
--E 13
)spool

@
<<RealSolvePackage.help>>=
====================================================================
RealSolvePackage examples
====================================================================

  p := 4*x^3 - 3*x^2 + 2*x - 4

  ans1 := solve(p,0.01)$REALSOLV

  ans2 := solve(p::POLY(FRAC(INT)),0.01)$REALSOLV

  R := Integer

  ls : List Symbol := [x,y,z,t]

  ls2 : List Symbol := [x,y,z,t,new()$Symbol]

  pack := ZDSOLVE(R,ls,ls2)

  p1 := x**2*y*z + y*z

  p2 := x**2*y**2*z + x + z

  p3 := x**2*y**2*z**2 +  z + 1

  lp := [p1, p2, p3]

  ans3 := realSolve(lp,[x,y,z],0.01)

See Also:
o )show RealSolvePackage

@
\pagehead{RealSolvePackage}{REALSOLV}
\pagepic{ps/v104realsolvepackage.ps}{REALSOLV}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package REALSOLV RealSolvePackage>>=
)abbrev package REALSOLV RealSolvePackage

RealSolvePackage(): _
  with

    solve: (Polynomial Fraction Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a
      ++ univariate rational polynomial p with precision eps.

    solve: (Polynomial Integer,Float) -> List Float
      ++ solve(p,eps) finds the real zeroes of a univariate
      ++ integer polynomial p with precision eps.

    realSolve: (List Polynomial Integer,List Symbol,Float) -> List List Float
      ++ realSolve(lp,lv,eps) = compute the list of the real
      ++ solutions of the list lp of polynomials with integer
      ++ coefficients with respect to the variables in lv,
      ++ with precision eps.

  ==  add

    prn2rfi: Polynomial Fraction Integer -> Fraction Polynomial Integer
    prn2rfi p ==
      map(#1 :: Fraction Polynomial Integer,_
          (numer(#1) :: Fraction Polynomial Integer)_
            /(denom(#1) :: Fraction Polynomial Integer),p)_
             $PolynomialCategoryLifting(IndexedExponents Symbol, _
               Symbol, _
               Fraction Integer, _
               Polynomial Fraction Integer, _
               Fraction Polynomial Integer)

    pi2rfi: Polynomial Integer -> Fraction Polynomial Integer
    pi2rfi p == p :: Fraction Polynomial Integer

    solve(p:Polynomial Fraction Integer,eps:Float) == 
      realRoots(prn2rfi p,eps)$(FloatingRealPackage(Float))

    solve(p:Polynomial Integer,eps:Float) ==
      realRoots(p :: Fraction Polynomial Integer,eps)_
       $(FloatingRealPackage(Float))

    realSolve(lp,lv,eps) ==
      realRoots(map(pi2rfi,lp)_
       $ListFunctions2(Polynomial Integer,Fraction Polynomial Integer),lv,eps)_
        $(FloatingRealPackage(Float))



@
<<REALSOLV.dotabb>>=
"REALSOLV" [color="#FF4488",href="bookvol10.4.pdf#nameddest=REALSOLV"]
"REALSOLV" -> "Package"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter S}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAEFACT SimpleAlgebraicExtensionAlgFactor}
\pagehead{SimpleAlgebraicExtensionAlgFactor}{SAEFACT}
\pagepic{ps/v104simplealgebraicextensionalgfactor.ps}{SAEFACT}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>=
)abbrev package SAEFACT SimpleAlgebraicExtensionAlgFactor
++ Factorisation in a simple algebraic extension;
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of the rational numbers (\spadtype{Fraction Integer}).
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SimpleAlgebraicExtensionAlgFactor(UP,SAE,UPA):Exports==Implementation where
  UP : UnivariatePolynomialCategory Fraction Integer
  SAE : Join(Field, CharacteristicZero,
                         MonogenicAlgebra(Fraction Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFactorize(UP)
                       )$InnerAlgFactor(Fraction Integer, UP, SAE, UPA)

@
<<SAEFACT.dotabb>>=
"SAEFACT" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAEFACT"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SAERFFC SAERationalFunctionAlgFactor}
\pagehead{SAERationalFunctionAlgFactor}{SAERFFC}
\pagepic{ps/v104saerationalfunctionalgfactor.ps}{SAERFFC}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SAERFFC SAERationalFunctionAlgFactor>>=
)abbrev package SAERFFC SAERationalFunctionAlgFactor
++ Factorisation in UP SAE FRAC POLY INT
++ Author: Patrizia Gianni
++ Date Created: ???
++ Date Last Updated: ???
++ Description:
++ Factorization of univariate polynomials with coefficients in an
++ algebraic extension of \spadtype{Fraction Polynomial Integer}.
++ Keywords: factorization, algebraic extension, univariate polynomial
 
SAERationalFunctionAlgFactor(UP, SAE, UPA): Exports == Implementation where
  UP : UnivariatePolynomialCategory Fraction Polynomial Integer
  SAE : Join(Field, CharacteristicZero,
                      MonogenicAlgebra(Fraction Polynomial Integer, UP))
  UPA: UnivariatePolynomialCategory SAE
 
  Exports ==> with
    factor: UPA -> Factored UPA
      ++ factor(p) returns a prime factorisation of p.
 
  Implementation ==> add
    factor q ==
      factor(q, factor$RationalFunctionFactor(UP)
              )$InnerAlgFactor(Fraction Polynomial Integer, UP, SAE, UPA)

@
<<SAERFFC.dotabb>>=
"SAERFFC" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SAERFFC"]

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{package SUPFRACF SupFractionFactorizer}
\pagehead{SupFractionFactorizer}{SUPFRACF}
\pagepic{ps/v104supfractionfactorizer.ps}{SUPFRACF}{1.00}

{\bf Exports:}\\
\begin{tabular}{lllll}
\end{tabular}

<<package SUPFRACF SupFractionFactorizer>>=
)abbrev package SUPFRACF SupFractionFactorizer
++ Author: P. Gianni
++ Date Created: October 1993
++ Date Last Updated: March 1995
++ Basic Functions:
++ Related Constructors: MultivariateFactorize
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description:  SupFractionFactorize 
++ contains the factor function for univariate 
++ polynomials over the quotient field of a ring S such that the package
++ MultivariateFactorize works for S

SupFractionFactorizer(E,OV,R,P) : C == T
 where
  E   :   OrderedAbelianMonoidSup
  OV  :   OrderedSet
  R   :   GcdDomain
  P   :   PolynomialCategory(R,E,OV)
  FP  ==> Fraction P
  SUP ==> SparseUnivariatePolynomial 

  C  == with
     factor      : SUP FP   ->  Factored SUP FP
       ++ factor(p) factors the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R.
     squareFree  : SUP FP   ->  Factored SUP FP
       ++ squareFree(p) returns the square-free factorization of the univariate polynomial p with coefficients
       ++ which are fractions of polynomials over R. Each factor has no repeated roots and the factors are
       ++ pairwise relatively prime.

  T  == add
     MFACT  ==> MultivariateFactorize(OV,E,R,P)
     MSQFR  ==> MultivariateSquareFree(E,OV,R,P)
     UPCF2  ==> UnivariatePolynomialCategoryFunctions2

     factor(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       R has CharacteristicZero and R has EuclideanDomain =>
         pden : P := lcm [denom c for c in coefficients p]
         pol  : SUP FP := (pden::FP)*p
         ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
         ffact: Factored SUP P := 0
         ffact := factor(ipol)$MFACT
         makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["prime",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])
       squareFree p

     squareFree(p:SUP FP) : Factored SUP FP  ==
       p=0 => 0
       pden : P := lcm [denom c for c in coefficients p]
       pol  : SUP FP := (pden::FP)*p
       ipol: SUP P := map(numer,pol)$UPCF2(FP,SUP FP,P,SUP P)
       ffact: Factored SUP P := 0
       if R has CharacteristicZero and R has EuclideanDomain then
         ffact := squareFree(ipol)$MSQFR
       else ffact := squareFree(ipol)
       makeFR((1/pden * map(coerce,unit ffact)$UPCF2(P,SUP P,FP,SUP FP)),
         [["sqfr",map(coerce,u.factor)$UPCF2(P,SUP P,FP,SUP FP),
            u.exponent] for u in factors ffact])

@
<<SUPFRACF.dotabb>>=
"SUPFRACF" [color="#FF4488",href="bookvol10.4.pdf#nameddest=SUPFRACF"]
"PFECAT" [color="#4488FF",href="bookvol10.2.pdf#nameddest=PFECAT"]
"SUPFRACF" -> "PFECAT"

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter T}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter U}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter V}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter W}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter X}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Y}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chapter Z}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Chunk collections}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<algebra>>=
<<package AF AlgebraicFunction>>
<<package ALGFACT AlgFactor>>
<<package ANY1 AnyFunctions1>>
<<package AXSERV AxiomServer>>

<<package BEZOUT BezoutMatrix>>
<<package BRILL BrillhartTests>>

<<package CPIMA CharacteristicPolynomialInMonogenicalAlgebra>>

<<package FLAGG2 FiniteLinearAggregateFunctions2>>
<<package FSAGG2 FiniteSetAggregateFunctions2>>

<<package GENMFACT GeneralizedMultivariateFactorize>>

<<package IALGFACT InnerAlgFactor>>

<<package MTHING MergeThing>>
<<package MPCPF MPolyCatPolyFactorizer>>
<<package MPRFF MPolyCatRationalFunctionFactorizer>>
<<package MRATFAC MRationalFactorize>>

<<package NONE1 NoneFunctions1>>
<<package NORMMA NormInMonogenicAlgebra>>

<<package ARRAY12 OneDimensionalArrayFunctions2>>
<<package OPQUERY OperationsQuery>>

<<package PRIMARR2 PrimitiveArrayFunctions2>>

<<package RFFACT RationalFunctionFactor>>
<<package RFFACTOR RationalFunctionFactorizer>>
<<package REALSOLV RealSolvePackage>>

<<package SAERFFC SAERationalFunctionAlgFactor>>
<<package SAEFACT SimpleAlgebraicExtensionAlgFactor>>
<<package SUPFRACF SupFractionFactorizer>>
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Index}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printindex
\end{document}
